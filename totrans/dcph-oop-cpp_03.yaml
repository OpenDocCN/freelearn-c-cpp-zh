- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Indirect Addressing – Pointers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接寻址 – 指针
- en: This chapter will provide a thorough understanding of how to utilize pointers
    in C++. Though it is assumed that you have some prior experience with indirect
    addressing, we will start at the beginning. Pointers are a ground-level and pervasive
    feature of the language – one you must thoroughly understand and be able to utilize
    with ease. Many other languages use indirect addressing through references alone;
    however, in C++ you must roll up your sleeves and understand how to use and return
    heap memory correctly and effectively with pointers. You will see pointers heavily
    used throughout code from other programmers; there is no sensible way to ignore
    their use. Misusing pointers can create the most difficult errors to find in a
    program. A thorough understanding of indirect addressing using pointers is a necessity
    in C++ to create successful and maintainable code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将全面介绍如何在C++中利用指针。虽然假设您对间接寻址有一些先前的经验，但我们将从基础开始。指针是语言的一个基础且普遍的特性 – 您必须彻底理解并能够轻松地利用它。许多其他语言仅通过引用来实现间接寻址；然而，在C++中，您必须亲自动手，理解如何正确和有效地使用指针来访问和返回堆内存。您将在其他程序员的代码中看到指针被大量使用；忽视它们的使用是没有道理的。误用指针可能会在程序中产生最难以找到的错误。在C++中，对使用指针进行间接寻址的彻底理解是创建成功且可维护代码的必要条件。
- en: In this chapter, you will additionally preview the concept of a smart pointer,
    which can help alleviate the difficulty and potential pitfalls that may easily
    arise with native pointers. Nonetheless, you will need to have a facility with
    all types of pointers in order to successfully use existing class libraries or
    to integrate with or maintain existing code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您还将预览智能指针的概念，这可以帮助减轻与原生指针相关的难度和潜在陷阱。尽管如此，您仍需要熟练掌握所有类型的指针，以便成功使用现有的类库或与现有代码集成或维护。
- en: The goal of this chapter will be to build or enhance your understanding of indirect
    addressing using pointers so that you can easily understand and modify others’
    code, as well as write original, sophisticated, error-free C++ code yourself.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标将是构建或增强您对指针间接寻址的理解，以便您能够轻松理解和修改他人的代码，以及自己编写原创、复杂、无错误的C++代码。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Pointer basics, including access, and memory allocation and release – for standard
    and user defined types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针基础，包括访问、内存分配和释放 – 对于标准类型和用户定义类型
- en: Dynamically allocating arrays of `1`, `2`, and `N` dimensions, and managing
    their memory release
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态分配一维、二维和N维数组，并管理它们的内存释放
- en: Pointers as arguments to functions and as return values from functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针作为函数的参数和作为函数的返回值
- en: Adding the `const` qualifier to pointer variables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向指针变量添加`const`限定符
- en: Using void pointers – pointers to objects of unspecified types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空指针 – 指向未指定类型的对象的指针
- en: Looking ahead to smart pointers to alleviate typical pointer usage errors
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预览智能指针以减轻典型指针使用错误
- en: By the end of this chapter, you will understand how to allocate memory from
    the heap using `new()` for simple and complex data types, as well as mark the
    memory for return to the heap management facility using `delete()`. You will be
    able to dynamically allocate arrays of any data type and of any number of dimensions,
    as well as understand basic memory management for releasing memory when it is
    no longer needed in your applications, to avoid memory leakage. You will be able
    to pass pointers as arguments to functions with any level of indirection – that
    is, pointers to data, pointers to pointers to data, and so on. You will understand
    how and why to combine the const qualification with pointers – to the data, to
    the pointer itself, or to both. You will additionally understand how to declare
    and utilize generic pointers with no type – void pointers – and understand the
    situations in which they may prove useful. Lastly, you will preview the concept
    of a smart pointer to alleviate potential pointer conundrums and usage errors.
    These skills will be necessary in order to move forward with the next chapters
    in the book successfully.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何使用`new()`为简单和复杂的数据类型在堆上分配内存，以及如何使用`delete()`标记内存以将其返回到堆管理设施。你将能够动态分配任何数据类型和任何维度的数组，并理解在应用程序中不再需要内存时释放内存的基本内存管理，以避免内存泄漏。你将能够将指针作为任何级别的间接函数的参数传递——即指向数据的指针、指向数据指针的指针，依此类推。你将了解如何以及为什么将const限定符与指针结合——指向数据、指向指针本身或两者。你还将了解如何声明和使用无类型的泛型指针——void指针——以及了解它们可能有用的情况。最后，你将预览智能指针的概念，以减轻潜在的指针难题和使用错误。这些技能将有助于你在本书的下一章中成功前进。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter03](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter03).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in this chapter can be found in the subdirectory `Chapter03`
    in a file named `Chp3-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL中找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter03](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter03)。每个完整程序示例都可以在GitHub的相应章节标题（子目录）下找到，对应章节的文件名，后面跟着一个连字符，然后是当前章节中的示例编号。例如，本章的第一个完整程序可以在上述GitHub目录下的`Chapter03`子目录中的`Chp3-Ex1.cpp`文件中找到。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3AtBPlV](https://bit.ly/3AtBPlV).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在以下链接查看：[https://bit.ly/3AtBPlV](https://bit.ly/3AtBPlV)。
- en: Understanding pointer basics and memory allocation
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解指针基础和内存分配
- en: In this section, we will review pointer basics as well as introduce operators
    applicable to pointers, such as the address-of operator, the dereference operator,
    and operators `new()` and `delete()`. We will employ the address-of operator `&`
    to calculate the address of an existing variable, and conversely, we will apply
    the dereference operator `*` to a pointer variable to go to the address contained
    within the variable. We will see examples of memory allocation on the heap, as
    well as how to mark that same memory for potential reuse by returning it to the
    free list when we are done with it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾指针基础，并介绍适用于指针的运算符，例如取地址运算符、解引用运算符以及`new()`和`delete()`运算符。我们将使用取地址运算符`&`来计算现有变量的地址，相反，我们将应用解引用运算符`*`到指针变量上以访问变量中包含的地址。我们将看到堆上内存分配的示例，以及如何在完成使用后通过将其返回到空闲列表来标记相同内存以供潜在重用。
- en: Using pointer variables allows our applications to have greater flexibility.
    At runtime, we can determine the quantity of a certain data type we may need (such
    as in a dynamically allocated array), organize data in data structures that facilitate
    sorting (such as in a linked list), or gain speed by passing an address of a large
    piece of data to a function (rather than passing a copy of the entire piece of
    data itself). Pointers have many uses, and we will see many examples throughout
    this chapter and throughout the course. Let’s start at the beginning with pointer
    basics.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '使用指针变量可以使我们的应用程序具有更大的灵活性。在运行时，我们可以确定我们可能需要的数据类型数量（例如在动态分配的数组中），在数据结构中组织数据以方便排序（例如在链表中），或者通过传递大型数据块的地址给函数来提高速度（而不是传递整个数据块的副本）。指针有很多用途，我们将在本章和整个课程中看到许多例子。让我们从指针基础知识开始。 '
- en: Revisiting pointer basics
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾指针基础知识
- en: First and foremost, let us review the meaning of a pointer variable. A pointer
    variable is one that may contain an address, and memory at that address may contain
    relevant data. It is typical to say that the pointer variable *points* to an address
    containing the relevant data. The value of the pointer variable itself is an address,
    not the data we are after. When we then go to that address, we find the data of
    interest. This is known as **indirect addressing**. To summarize, the content
    of a pointer variable is an address; if you then go to that address, you find
    the data. This is for a single level of indirection.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下指针变量的含义。指针变量是可能包含地址的变量，该地址的内存可能包含相关数据。通常说，指针变量*指向*包含相关数据的地址。指针变量的值是一个地址，而不是我们想要的数据。当我们到达那个地址时，我们找到感兴趣的数据。这被称为**间接寻址**。总结一下，指针变量的内容是一个地址；如果你然后去那个地址，你就能找到数据。这是单级间接寻址。
- en: A pointer variable may point to the existing memory of a non-pointer variable,
    or it may point to memory that is dynamically allocated on the heap. The latter
    case is the most usual situation. Unless a pointer variable is properly initialized
    or assigned a value, the content of the pointer variable is meaningless and does
    not represent a usable address. A large mistake can be assuming that a pointer
    variable has been properly initialized when it may not have been. Let us look
    at some basic operators that are useful with pointers. We will start with the
    address-of `&` and the dereference operator `*`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 指针变量可能指向非指针变量的现有内存，或者它可能指向在堆上动态分配的内存。后一种情况是最常见的情况。除非指针变量被正确初始化或分配了值，否则指针变量的内容是无意义的，并不代表一个可用的地址。一个很大的错误是假设指针变量已经被正确初始化，而实际上可能没有。让我们看看一些对指针有用的基本运算符。我们将从地址-of
    `&` 和解引用运算符 `*` 开始。
- en: Using the address-of and dereference operators
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用地址-of 和解引用运算符
- en: The address-of operator `&` can be applied to a variable to determine its location
    in memory. The dereference operator `*` can be applied to a pointer variable to
    obtain the value of the data at the valid address contained within the pointer
    variable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 地址-of 运算符 `&` 可以应用于变量以确定其在内存中的位置。解引用运算符 `*` 可以应用于指针变量以获取指针变量中包含的有效地址的数据值。
- en: 'Let’s see a simple example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice in the previous segment of code that we first declare and initialize
    variable `x` to `10`. Next, we declare `int *pointerToX = nullptr;` to state that
    variable `pointerToX` may someday point to an integer, yet it is initialized with
    a `nullptr` for safety. Had we not initialized this variable with a `nullptr`,
    it would have been uninitialized and, therefore, would not contain a valid memory
    address.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在之前的代码段中，我们首先声明并初始化变量 `x` 为 `10`。接下来，我们声明 `int *pointerToX = nullptr;` 来表示变量
    `pointerToX` 可能将来会指向一个整数，但它用 `nullptr` 初始化以确保安全。如果我们没有用 `nullptr` 初始化这个变量，它将是未初始化的，因此不会包含一个有效的内存地址。
- en: Moving forward in the code to the line `pointerToX = &x;`, we assign the memory
    location of `x` using the address-of operator (`&`) as the value of `pointerToX`,
    which is waiting to be filled with a valid address of some integer. On the last
    line of this code fragment, we print out both `x` and `*pointerToX`. Here, we
    are using the dereference operator `*` with the variable `pointerToX`. The dereference
    operator tells us to go to the address contained in the variable `pointerToX`.
    At that address, we find the data value of integer `10`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中向前移动到行`pointerToX = &x;`，我们使用取地址运算符（`&`）将`x`的内存位置赋值给`pointerToX`，它等待被填充为某个整数的有效地址。在这段代码的最后一行，我们打印出`x`和`*pointerToX`。在这里，我们使用了解引用运算符`*`与变量`pointerToX`。解引用运算符告诉我们去变量`pointerToX`中包含的地址。在那个地址，我们找到整数`10`的数据值。
- en: 'Here is the output this fragment would generate as a full program:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个片段作为完整程序生成的输出：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For efficiency, C++ does not neatly initialize all memory with zeros when an
    application starts, nor does C++ ensure that memory is conveniently empty, without
    values, when paired with a variable. The memory simply has in it what was previously
    stored there; C++ memory is not considered *clean*. Because memory is not given
    to a programmer *clean* in C++, the contents of a newly declared pointer variable,
    unless properly initialized or assigned a value, should not be construed to contain
    a valid address.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率，C++在应用程序启动时并不会整齐地将所有内存初始化为零，也不会确保与变量配对时内存是方便地空的，没有值。内存中简单地包含之前存储的内容；C++的内存不被认为是*干净的*。因为C++中内存没有给程序员*干净*，所以新声明的指针变量的内容，除非正确初始化或赋值，否则不应被视为包含有效地址。
- en: In the preceding example, we used the address-of operator `&` to calculate the
    address of an existing integer in memory, and we set our pointer variable to point
    to that memory. Instead, let us introduce operators `new()` and `delete()` to
    allow us to utilize dynamically allocated heap memory for use with pointer variables.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用取地址运算符`&`来计算内存中现有整数的地址，并将我们的指针变量设置为指向那个内存。相反，让我们引入`new()`和`delete()`运算符，以便我们可以利用动态分配的堆内存与指针变量一起使用。
- en: Using operators new() and delete()
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用new()和delete()运算符
- en: Operator `new()` can be utilized to obtain dynamically allocated memory from
    the heap. A pointer variable may choose to point to memory that is dynamically
    allocated at runtime, rather than to point to another variable’s existing memory.
    This gives us flexibility as to when we want to allocate the memory, and how many
    pieces of such memory we may choose to have. Operator `delete()` can then be applied
    to a pointer variable to mark memory we no longer require, returning the memory
    to the heap management facility for later reuse in the application. It is important
    to understand that once we `delete()` a pointer variable, we should no longer
    use the address contained within that variable as a valid address.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符`new()`可以用来从堆中获取动态分配的内存。指针变量可以选择指向在运行时动态分配的内存，而不是指向另一个变量的现有内存。这给了我们灵活性，关于我们想要何时分配内存，以及我们可能选择有多少这样的内存块。然后，可以使用运算符`delete()`对一个指针变量应用，以标记我们不再需要的内存，将内存返回给堆管理设施以供应用程序稍后重用。重要的是要理解，一旦我们`delete()`了一个指针变量，我们就不再应该使用该变量中包含的地址作为有效地址。
- en: 'Let’s take a look at simple memory allocation and release using a basic data
    type:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用基本数据类型进行简单内存分配和释放的例子：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous program segment, we first declare pointer variable `y` with
    `int *y = nullptr;`. Here, `y` may someday contain the address of an integer,
    yet it is meanwhile safely initialized with a `nullptr`. On the next line, we
    allocate memory from the heap large enough to accommodate an integer with `y =
    new int;`, storing that address in pointer variable `y`. Next, with `*y = 17;`,
    we dereference `y` and store the value of `17` in the memory location pointed
    to by `y`. After printing out the value of `*y`, we then decide that we are done
    with the memory `y` points to and return it to the heap management facility by
    using operator `delete()`. It is important to note that variable `y` still contains
    the memory address it obtained with its call to `new()`; however, `y` should no
    longer use this relinquished memory.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个程序段中，我们首先使用`int *y = nullptr;`声明了指针变量`y`。在这里，`y`将来可能包含一个整数的地址，但与此同时，它被安全地初始化为`nullptr`。在下一行，我们使用`y
    = new int;`从堆中分配足够的内存来容纳一个整数，并将该地址存储在指针变量`y`中。接下来，使用`*y = 17;`解引用`y`并将值`17`存储在`y`指向的内存位置。在打印出`*y`的值后，我们决定我们完成了对`y`指向的内存的处理，并通过使用运算符`delete()`将其返回给堆管理设施。重要的是要注意，变量`y`仍然包含它通过调用`new()`获得的内存地址；然而，`y`不应再使用这个释放的内存。
- en: Towards the end of the previous program segment, we alternatively declare pointer
    variable `z`, allocate heap memory for it to point to, and initialize that memory
    with `int *z = new int(22);`. Notice that we likewise deallocate the heap memory
    using `delete z;`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个程序段快结束时，我们交替地声明了指针变量`z`，为其分配了堆内存，并使用`int *z = new int(22);`初始化了该内存。请注意，我们同样使用`delete
    z;`来释放堆内存。
- en: Important note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is the programmer’s responsibility to remember that once memory has been
    deallocated, you should never again dereference that pointer variable; please
    understand that that address may have been reissued to another variable through
    another call to `new()` elsewhere in the program. A safeguard would be to reset
    a pointer to `nullptr` once its memory has been deallocated with `delete()`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一旦内存被释放，就不应该再次解引用该指针变量；请理解，该地址可能已经被重新分配给程序其他地方的另一个变量。一种保护措施是在使用`delete()`释放内存后，将指针重置为`nullptr`。
- en: Now that we understand pointer basics with simple data types, let us move onward
    by allocating more complex data types, as well as understanding the notation necessary
    to utilize and access members of user defined data types.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了简单数据类型的指针基础知识，让我们继续前进，分配更复杂的数据类型，并了解利用和访问用户定义数据类型成员所需的表示法。
- en: Creating and using pointers to user defined types
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用用户定义类型的指针
- en: Next, let us examine how to declare pointers to user defined types, and how
    to allocate their associated memory on the heap. To dynamically allocate a user
    defined type, the pointer will first be declared of that type. The pointer then
    must either be initialized or assigned a valid memory address – the memory can
    either be that of an existing variable or newly allocated heap memory. Once the
    address for the appropriate memory has been placed within the pointer variable,
    the `->` operator may be utilized to access struct or class members. Alternatively,
    the `(*ptr).member` notation may be used to access struct or class members.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来探讨如何声明用户定义类型的指针，以及如何在堆上为其分配关联的内存。为了动态分配一个用户定义类型，首先需要声明该类型的指针。然后，该指针必须被初始化或分配一个有效的内存地址——内存可以是现有变量的内存或新分配的堆内存。一旦适当的内存地址被放置在指针变量中，就可以使用`->`运算符来访问结构体或类的成员。或者，可以使用`(*ptr).member`的表示法来访问结构体或类的成员。
- en: 'Let’s see a basic example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个基本示例：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex1.cpp)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex1.cpp)'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, in the aforementioned program, we have declared a user defined type of
    `collection`, with data members `x` and `y`. Next, we declare `item` as a pointer
    to that type with `collection *item = nullptr;` while initializing the pointer
    with a `nullptr` for safety. Then, we allocate heap memory for `item` to point
    to, using operator `new()`. Now, we assign values to the `x` and `y` members of
    `item`, respectively, using either the `->` operator or the `(*).` member access
    notation. In either case, the notation means to first dereference the pointer
    and then choose the appropriate data member. It’s pretty straightforward with
    the `(*).` notation – the parentheses show us that the pointer dereference happens
    first, and then the choice of the member happens next with the `.` (member selection)
    operator. The `->` shorthand notation indicates pointer dereference followed by
    member selection. After we use `cout` with the insertion operator `<<` to print
    the appropriate values, we decide that we no longer need the memory associated
    with `item` and issue a `delete item;` to mark this segment of heap memory for
    return to the free list.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在上述程序中，我们声明了一个名为`collection`的用户定义类型，具有数据成员`x`和`y`。接下来，我们声明`item`为该类型的指针，使用`collection
    *item = nullptr;`初始化指针，以确保安全。然后，我们使用操作符`new()`为`item`分配堆内存。现在，我们分别使用`->`操作符或`(*).`成员访问符号为`item`的`x`和`y`成员赋值。在两种情况下，这种表示法意味着首先取消引用指针，然后选择适当的数据成员。使用`(*).`表示法非常直接——括号表明指针取消引用先发生，然后使用`.`（成员选择）操作符选择成员。`->`简写表示法表示指针取消引用后跟成员选择。在使用`cout`和插入操作符`<<`打印适当的值后，我们决定不再需要与`item`关联的内存，并发出`delete
    item;`来标记这段堆内存以返回到空闲列表。
- en: 'Let’s take a look at this example’s output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个示例的输出：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let us also take a look at the memory layout for this example. The memory address
    (`9000`) used is arbitrary – just an example address that may be generated by
    `new()`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看看这个示例的内存布局。使用的内存地址（`9000`）是任意的——只是一个可能由`new()`生成的示例地址。
- en: '![Figure 3.1 – Memory model for Chp3-Ex1.cpp ](img/Figure_3.01_B19087.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – Chp3-Ex1.cpp的内存模型](img/Figure_3.01_B19087.jpg)'
- en: Figure 3.1 – Memory model for Chp3-Ex1.cpp
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – Chp3-Ex1.cpp的内存模型
- en: Now that we know how to allocate and release memory for user defined types,
    let’s move forward and dynamically allocate arrays of any data type.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何为用户定义类型分配和释放内存，让我们继续前进，动态分配任何数据类型的数组。
- en: Allocating and deallocating arrays at runtime
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时分配和释放数组
- en: Arrays may be dynamically allocated so that their size may be determined at
    runtime. Dynamically allocated arrays may be of any type, including user defined
    types. Determining the size of an array at runtime can be a space-saving advantage
    and gives us programming flexibility. Rather than allocating a fixed-sized array
    of the largest possible quantity needed (potentially wasting space), you can instead
    allocate the necessary size determined by various factors at runtime. You have
    the additional flexibility to delete and reallocate an array should the need arise
    to change an array’s size. Arrays of any number of dimensions can be dynamically
    allocated.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以动态分配，以便在运行时确定其大小。动态分配的数组可以是任何类型，包括用户定义的类型。在运行时确定数组的大小可以节省空间，并给我们带来编程灵活性。而不是分配一个固定大小的数组，该数组包含所需的最大数量（可能浪费空间），您可以根据运行时确定的各种因素分配所需的大小。如果您需要更改数组的大小，您还有额外的灵活性来删除和重新分配数组。任何数量的维度的数组都可以动态分配。
- en: In this section, we will examine how to dynamically allocate arrays of both
    basic and user defined data types, and of single and multiple dimensions. Let’s
    get started.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何动态分配基本和用户定义数据类型的数组和单维或多维数组。让我们开始吧。
- en: Dynamically allocating single dimension arrays
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态分配单维数组
- en: Single-dimension arrays may be dynamically allocated so that their size may
    be determined at runtime. We will use a pointer to represent each array and will
    allocate the required memory with operator `new()`. Once the array is allocated,
    standard array notation can be used to access each array element.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 单维数组可以动态分配，以便在运行时确定其大小。我们将使用指针来表示每个数组，并使用操作符`new()`分配所需的内存。一旦数组被分配，就可以使用标准数组表示法来访问每个数组元素。
- en: 'Let’s take a look at a simple example. We’ll break it into two segments, however,
    the full program example can be found using the following link:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的例子。我们将将其分为两个部分，但是完整的程序示例可以通过以下链接找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex2.cpp)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex2.cpp)'
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the first part of this program, we first declare a user defined type, `collection`,
    using a struct. Next, we declare an integer variable to hold the number of elements
    we would like to prompt the user to enter to select as the size for our two arrays.
    We also declare a pointer to an integer with `int *intArray;`, and a pointer to
    a `collection` using `collection *collectionArray;`. These declarations state
    that these pointers may one day each, respectively, point to one or more integers,
    or one or more objects of type `collection`. These variables, once allocated,
    will comprise our two arrays.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序的第一个部分，我们首先使用 `struct` 声明一个用户定义的类型 `collection`。接下来，我们声明一个整数变量来保存我们希望提示用户输入以选择两个数组大小的元素数量。我们还使用
    `int *intArray;` 声明一个指向整数的指针，并使用 `collection *collectionArray;` 声明一个指向 `collection`
    的指针。这些声明表明，这些指针将来可能分别指向一个或多个整数，或者一个或多个 `collection` 类型的对象。一旦分配，这些变量将组成我们的两个数组。
- en: 'After prompting the user to enter the number of elements desired using `cin`
    and the extraction operator `>>`, we dynamically allocate both an array of integers
    of that size and an array of `collection` of that size. We use operator `new()`
    in both cases: `intArray = new int[numElements];` and `collectionArray = new collection[numElements];`.
    The bracketed quantity of `numElements` indicates that the respective chunks of
    memory requested for each data type will be large enough to accommodate that many
    sequential elements of the relevant data type. That is, `intArray` will have memory
    allocated to accommodate `numElements` multiplied by the size needed for an integer.
    Note that an object’s data type is known because the data type of what will be
    pointed to is included in the pointer declaration itself. The appropriate amount
    of memory for `collectionArray` will be similarly provided for with its respective
    call to operator `new()`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `cin` 和提取运算符 `>>` 提示用户输入所需元素数量之后，我们动态分配了一个整数数组和一个相同大小的 `collection` 类型的数组。在这两种情况下，我们都使用了运算符
    `new()`：`intArray = new int[numElements];` 和 `collectionArray = new collection[numElements];`。括号中的
    `numElements` 表示为每种数据类型请求的内存块将足够大，以容纳相应数据类型的那么多连续元素。也就是说，`intArray` 将分配足够的内存来容纳
    `numElements` 乘以整数所需的大小。请注意，对象的数据类型是已知的，因为指针声明中包含了将要指向的数据类型。`collectionArray`
    将通过其相应的 `new()` 运算符调用提供适当的内存量。
- en: 'Let’s continue by examining the remaining code in this example program:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续检查这个示例程序中剩余的代码：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, as we continue this example with the `for` loop, notice that we are using
    a typical array notation of `[]` to access each element of the two arrays, even
    though the arrays have been dynamically allocated. Because `collectionArray` is
    a dynamically allocated array of user defined types, we must also use `.` notation
    to access individual data members within each array element. Though using standard
    array notation makes accessing dynamically arrays quite simple, you may alternatively
    use pointer notation to access the memory.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当我们继续使用 `for` 循环这个例子时，请注意，我们正在使用典型的数组表示法 `[]` 来访问两个数组的每个元素，尽管这些数组是动态分配的。因为
    `collectionArray` 是用户定义类型的动态分配数组，我们必须使用 `.` 表示法来访问每个数组元素中的单个数据成员。虽然使用标准数组表示法使访问动态数组变得相当简单，但您也可以使用指针表示法来访问内存。
- en: Within the loop, notice that we incrementally print both the elements of `intArray`
    and the `y` member of `collectionArray` using pointer notation. In the expression
    `*(intArray +i)`, the identifier `intArray` represents the starting address of
    the array. By adding `i` offsets to this address, you are now at the address of
    the `i`th element in this array. By dereferencing this composite address with
    `*`, you will now go to the proper address to retrieve the relevant integer data,
    which is then printed using `cout` and the insertion operator `<<`. Likewise,
    with `(*(collectionArray + i)).y`, we first add `i` to the starting address of
    `collectionArray`, then using `()`, we dereference that address with `*`. Since
    this is a user defined type, we must then use `.` to select the appropriate data
    member `y`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，请注意我们使用指针表示法逐步打印`intArray`数组的元素和`collectionArray`集合的`y`成员。在表达式`*(intArray
    +i)`中，标识符`intArray`代表数组的起始地址。通过向这个地址添加`i`个偏移量，你现在就到达了该数组第`i`个元素的地址。通过使用`*`解引用这个复合地址，你现在将到达正确的地址以检索相关的整数数据，然后使用`cout`和插入操作符`<<`打印出来。同样，对于`(*(collectionArray
    + i)).y`，我们首先将`i`加到`collectionArray`的起始地址上，然后使用`()`解引用这个地址，由于这是一个用户定义的类型，我们必须使用`.`来选择适当的数据成员`y`。
- en: 'Lastly, in this example, we demonstrate how to deallocate memory that we no
    longer need using `delete()`. Though a simple statement of `delete intArray;`
    would suffice for the dynamically allocated array of standard types, we instead
    choose `delete [] intArray;` to be consistent with the required manner for deletion
    for dynamically allocated arrays of user defined types. That is, the more complex
    statement of `delete [] collectionArray;` is necessary for the proper deletion
    of an array of user defined types. In all cases, the memory associated with each
    dynamically allocated array will be returned to the free-list, and can then be
    reused when heap memory is again allocated with subsequent calls to operator `new()`.
    However, as we will later see, the `[]` used with `delete()` will allow for a
    special clean-up function to be applied to each array element of a user defined
    type before the memory is relinquished. Additionally, consistency is appreciated:
    if you allocate with `new()`, relinquish the memory with `delete()`; if you allocate
    with `new []`, then relinquish with `delete []`. This consistent pairing will
    also keep your program working as intended should any of these aforementioned
    operators be overloaded (that is, redefined) at a future date by the programmer.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个例子中，我们展示了如何使用`delete()`来释放我们不再需要的内存。虽然一个简单的`delete intArray;`语句就足以用于标准类型的动态分配数组，但我们选择使用`delete
    [] intArray;`来与用户定义类型动态分配数组删除所需的方式保持一致。也就是说，对于用户定义类型的数组，需要使用更复杂的`delete [] collectionArray;`语句来正确删除。在所有情况下，与每个动态分配数组相关的内存都将返回到空闲列表，然后可以在后续调用操作符`new()`再次分配堆内存时被重用。然而，正如我们稍后将看到的，与`delete()`一起使用的`[]`将允许在释放内存之前对用户定义类型的每个数组元素应用特殊的清理函数。此外，一致性很重要：如果你使用`new()`分配，则使用`delete()`释放内存；如果你使用`new
    []`分配，则使用`delete []`释放。这种一致的配对也将确保在将来程序员对上述任何操作符进行重载（即重新定义）时，程序按预期工作。
- en: It is crucial to remember not to dereference a pointer variable once its memory
    has been marked for deletion. Though that address will remain in the pointer variable
    until you assign the pointer a new address (or null pointer), once memory is marked
    for deletion, the memory in question might have been already reused by a subsequent
    call to `new()` elsewhere in the program. This is one of many ways you must be
    diligent when using pointers in C++.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记住不要在内存被标记为删除后解引用指针变量非常重要。尽管那个地址将保留在指针变量中，直到你将指针分配新的地址（或空指针），但一旦内存被标记为删除，相关的内存可能已经被程序其他地方的后续`new()`调用重用。这是在使用C++中的指针时你必须勤勉注意的许多方式之一。
- en: 'The output to accompany the full program example is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随完整程序示例的输出如下：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s additionally take a look at the memory layout for this example. The memory
    addresses (`8500` and `9500`) used are arbitrary – they are example addresses
    on the heap that may be generated by `new()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看这个例子的内存布局。使用的内存地址（`8500`和`9500`）是任意的——它们是堆上可能由`new()`生成的示例地址。
- en: '![Figure 3.2 – Memory model for Chp3-Ex2.cpp ](img/Figure_3.02_B19087.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – Chp3-Ex2.cpp的内存模型](img/Figure_3.02_B19087.jpg)'
- en: Figure 3.2 – Memory model for Chp3-Ex2.cpp
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – Chp3-Ex2.cpp的内存模型
- en: Next, let’s move forward with our discussion on dynamically allocated arrays
    by allocating arrays of multiple dimensions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过分配多维数组来继续我们关于动态分配数组的讨论。
- en: Dynamically allocating 2-D arrays – an array of pointers
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态分配二维数组 - 指针数组
- en: Two or more dimensioned arrays may also be dynamically allocated. For a 2-D
    array, the column dimension may be dynamically allocated and the row dimension
    may remain fixed, or both dimensions may be dynamically allocated. Allocating
    one or more dimensions dynamically allows the programmer to account for run time
    decisions regarding the array size.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以动态分配两个或更多维度的数组。对于二维数组，列维度可以动态分配，而行维度可能保持固定，或者两个维度都可以动态分配。动态分配一个或多个维度允许程序员对关于数组大小的运行时决策进行考虑。
- en: Let’s first consider the case where we have a fixed number of rows and a variable
    amount of entries in each of those rows (which would be the column dimension).
    For simplicity, we will assume that the number of entries in each row is the same
    from row to row, but it need not be. We can model a 2-D array with a fixed number
    of rows and a run-time-determined amount of entries in each of those rows (the
    column dimension) using an array of pointers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑这种情况，即我们有一个固定数量的行，以及每行中不同数量的条目（这将成为列维度）。为了简单起见，我们将假设每行的条目数从行到行是相同的，但不必如此。我们可以使用指针数组来模拟一个具有固定行数和每行运行时确定的条目数（列维度）的二维数组。
- en: 'Let’s consider an example to illustrate a 2-D array where the column dimension
    is dynamically allocated:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例来阐述一个列维度动态分配的二维数组：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex3.cpp)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex3.cpp)'
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, notice that we initially declare an array of pointers to floats
    using `float *TwoDimArray[NUMROWS];`. For safety, we initialize each of these
    pointers to `nullptr`. Sometimes, it is helpful to read pointer declarations from
    right to left; that is, we have an array `NUMROWS` in size that contains pointers
    to floating-point numbers. More specifically, we have a fixed-sized array of pointers
    where each pointer entry can point to one or more contiguous floating-point numbers.
    The number of entries pointed to in each row comprises the column dimension.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，请注意，我们最初使用`float *TwoDimArray[NUMROWS];`声明了一个指向浮点数的指针数组。为了安全起见，我们将每个指针初始化为`nullptr`。有时，从右到左阅读指针声明是有帮助的；也就是说，我们有一个大小为`NUMROWS`的数组，它包含指向浮点数的指针。更具体地说，我们有一个固定大小的指针数组，其中每个指针条目可以指向一个或多个连续的浮点数。每行中指向的条目数构成了列维度。
- en: Next, we prompt the user for the number of column entries. Here, we are assuming
    that each row will have the same number of entries in it (to make the column dimension);
    however, it is possible that each row could have a different total number of entries.
    By assuming each row will have a uniform number of entries, we have a straightforward
    loop using `i` to allocate the column quantity for each row using `TwoDimArray[i]
    = new float [numColumns];`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提示用户输入列条目的数量。在这里，我们假设每行将具有相同数量的条目（以使列维度）；然而，每行可能具有不同的总条目数。通过假设每行将具有均匀的条目数，我们可以使用`i`来为每行分配列数量，即`TwoDimArray[i]
    = new float [numColumns];`。
- en: In the nested loop that uses `j` as an index, we simply load values for each
    column entry of the row specified by `i` in the outer loop. The arbitrary assignment
    of `TwoDimArray[i][j] = i + j + .05;` loads an interesting value into each element.
    In the nested loop indexed on `j`, we also print out each column entry for row
    `i`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`j`作为索引的嵌套循环中，我们简单地加载由外循环中指定的`i`行中每一列的值。任意赋值`TwoDimArray[i][j] = i + j +
    .05;`将一个有趣的价值加载到每个元素中。在以`j`为索引的嵌套循环中，我们也打印出`i`行的每一列条目。
- en: 'Lastly, the program illustrates how to deallocate the dynamically allocated
    memory. Since the memory was allocated in a loop over a fixed number of rows –
    one memory allocation to gather memory to comprise each row’s column entries –
    the deallocation will work similarly. For each of the rows, we utilize the statement:
    `delete [] TwoDimArray[i];`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，程序说明了如何释放动态分配的内存。由于内存是在一个固定数量的行循环中分配的——一次内存分配来收集构成每一行列条目的内存——释放操作将类似地进行。对于每一行，我们使用以下语句：`delete
    [] TwoDimArray[i];`。
- en: 'The output for the example is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的输出如下：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, let’s take a look at the memory layout for this example. As in previous
    memory diagrams, the memory addresses used are arbitrary – they are example addresses
    on the heap as may be generated by `new()`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看这个例子的内存布局。就像之前的内存图一样，使用的内存地址是任意的——它们是`new()`可能生成的堆上的示例地址。
- en: '![Figure 3.3 – Memory model for Chp3-Ex3.cpp ](img/Figure_3.03_B19087.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – Chp3-Ex3.cpp的内存模型](img/Figure_3.03_B19087.jpg)'
- en: Figure 3.3 – Memory model for Chp3-Ex3.cpp
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – Chp3-Ex3.cpp的内存模型
- en: Now that we have seen how to utilize an array of pointers to model a 2-D array,
    let’s move onward to see how we can model a 2-D array using a pointer to a pointer
    so that we may choose both dimensions at runtime.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何利用指针数组来模拟二维数组，让我们继续看看如何使用指针的指针来模拟二维数组，这样我们就可以在运行时选择两个维度。
- en: Dynamically allocating 2-D arrays – pointers to pointers
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态分配二维数组 – 指针的指针
- en: Dynamically allocating both the row and column dimensions for an array can add
    necessary runtime flexibility to a program. To achieve this ultimate flexibility,
    a 2-D array can be modeled using a pointer to a pointer of the desired data type.
    Initially, the dimension representing the number of rows will be allocated. Next,
    for each row, the number of elements in each row will be allocated. As with the
    last example using an array of pointers, the number of elements in each row (the
    column entries) need not be uniform in size across rows. However, to accurately
    model the concept of a 2-D array, it is assumed that the column size will be allocated
    uniformly from row to row.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为数组动态分配行和列的维度可以为程序添加必要的运行时灵活性。为了实现这种终极灵活性，可以使用指向所需数据类型的指针的指针来模拟二维数组。最初，将分配表示行数的维度。接下来，对于每一行，将分配每一行的元素数量。与使用指针数组的最后一个例子一样，每一行的元素数量（列条目）不需要在行之间大小一致。然而，为了准确模拟二维数组的概念，假设列大小将在行与行之间均匀分配。
- en: 'Let’s consider an example to illustrate a 2-D array where both the row and
    column dimensions are dynamically allocated:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来说明一个二维数组，其中行和列的维度都是动态分配的：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex4.cpp)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex4.cpp)'
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, notice that we initially declare a pointer to a pointer of
    type `float` using: `float **TwoDimArray;`. Reading this declaration from right
    to left, we see that `TwoDimArray` is a pointer to a pointer to `float`. More
    specifically, we understand that `TwoDimArray` will contain the address of one
    or more contiguous pointers, each of which may point to one or more contiguous
    floating-point numbers.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，请注意我们最初使用以下方式声明了一个指向`float`类型的指针的指针：`float **TwoDimArray;`。从右到左阅读这个声明，我们看到`TwoDimArray`是一个指向`float`指针的指针。更具体地说，我们理解`TwoDimArray`将包含一个或多个连续指针的地址，每个指针可能指向一个或多个连续的浮点数。
- en: Now, we prompt the user for the number of row entries. We follow this input
    with the allocation to a set of float pointers, `TwoDimArray = new float * [numRows];`.
    This allocation creates a `numRows` quantity of contiguous `float` pointers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们提示用户输入行条目的数量。我们随后进行分配到一组浮点指针，`TwoDimArray = new float * [numRows];`。这个分配创建了一个`numRows`数量的连续`float`指针。
- en: Just as in the previous example, we prompt the user for how many columns in
    each row we would like to have. Just as before, in the outer loop indexed on `i`,
    we allocate the column entries for each row. In the nested loop indexed on `j`,
    we again assign values to our array entries and print them just as before.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一个例子一样，我们提示用户输入每行希望有多少列。就像之前一样，在外层循环中，我们根据索引`i`为每一行分配列条目。在内层循环中，我们再次为我们的数组条目赋值并像之前一样打印它们。
- en: Lastly, the program continues with the memory deallocation. Just as before,
    the column entries for each row are deallocated within a loop. Additionally, however,
    we need to deallocate the dynamically allocated number of row entries. We do this
    with `delete [] TwoDimArray;`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，程序继续进行内存释放。就像之前一样，在循环中释放了每一行的列条目。然而，我们还需要释放动态分配的行条目数量。我们通过 `delete [] TwoDimArray;`
    来完成这个操作。
- en: 'The output for this program is slightly more flexible, as we can enter at runtime
    the number of both the desired rows and columns:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出稍微灵活一些，因为我们可以在运行时输入所需的行数和列数：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s again take a look at the memory model for this program. As a reminder,
    just as in previous memory diagrams, the memory addresses used are arbitrary –
    they are example addresses on the heap as may be generated by `new()`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看这个程序的内存模型。提醒一下，就像之前的内存图一样，使用的内存地址是任意的——它们是 `new()` 可能生成的堆上的示例地址。
- en: '![Figure 3.4 – Memory model for Chp3-Ex4.cpp ](img/Figure_3.04_B19087.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – Chp3-Ex4.cpp 的内存模型](img/Figure_3.04_B19087.jpg)'
- en: Figure 3.4 – Memory model for Chp3-Ex4.cpp
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Chp3-Ex4.cpp 的内存模型
- en: Now that we have seen how to utilize pointers to pointers to model a 2-D array,
    let’s move onward to see how we may model arrays of any number of dimensions using
    pointers to pointers to pointers, and so on. In C++, you can model any dimensionality
    of a dynamically allocated array, so long as you can imagine it!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何利用指针到指针来模拟二维数组，让我们继续看看如何使用指针到指针到指针等来模拟任意维度的数组。在 C++ 中，你可以模拟任何维度的动态分配数组，只要你能够想象出来！
- en: Dynamically allocating N-D arrays – pointers to pointers to pointers
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态分配 N 维数组——指针到指针到指针
- en: In C++, you can model any dimensionality of a dynamically allocated array. You
    need only to be able to imagine it, declare the appropriate levels of pointers,
    and make the required levels of memory allocation (and eventual deallocation).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，你可以模拟任何维度的动态分配数组。你需要做的只是能够想象出来，声明适当的指针级别，并执行所需的内存分配（以及最终的释放）。
- en: 'Let’s take a look at the pattern you will need to follow:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你需要遵循的模式：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex5.cpp)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex5.cpp)'
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, notice that we use three levels of indirection to specify the
    variable to represent the 3-D array `int ***ThreeDimArray;`. We subsequently allocate
    the required memory for each level of indirection. The first allocation is `ThreeDimArray
    = new int ** [dim1];`, which allocates dimension 1’s set of pointers to pointers.
    Next, in a loop iterating over `i`, and for each element in dimension 1, we allocate
    `ThreeDimArray[i] = new int * [dim2];` to allocate the pointers to integers for
    the second dimension of the array. And in a nested loop iterating over `j`, and
    for each element in dimension 2, we allocate `ThreeDimArray[i][j] = new int [dim3];`
    to allocate the integers themselves in a quantity specified by `dim3`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，请注意我们使用了三个级别的间接引用来指定变量以表示三维数组 `int ***ThreeDimArray;`。随后，我们为每个级别的间接引用分配所需的内存。第一次分配是
    `ThreeDimArray = new int ** [dim1];`，它分配了维度 1 的指针集。接下来，在一个遍历 `i` 的循环中，并为数组第一维的每个元素，我们分配
    `ThreeDimArray[i] = new int * [dim2];` 以分配第二维数组中整数的指针。然后在嵌套循环中遍历 `j`，并为第二维的每个元素，我们分配
    `ThreeDimArray[i][j] = new int [dim3];` 以分配由 `dim3` 指定的整数本身。
- en: As in the last two examples, we initialize the array elements in the inner loops
    and print their values. At this point, you will undoubtedly notice the similarities
    between this program and its predecessor. A pattern for the allocation is emerging.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两个例子一样，我们在内循环中初始化数组元素并打印它们的值。此时，你无疑会注意到这个程序与其前辈之间的相似之处。一个分配模式正在出现。
- en: Lastly, we will deallocate the three levels of memory in a manner similar –
    yet in reverse – to the levels of allocation. We use a nested loop iterating over
    `j` to release the memory of the innermost level, followed by the memory release
    in the outer loop that iterates over `i`. Finally, we relinquish the memory for
    the initial dimension with a simple call to `delete [] ThreeDimArray;`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将以类似但相反的方式释放三个级别的内存，这与分配级别的方式相似。我们使用嵌套循环遍历`j`来释放最内层级别的内存，然后是遍历`i`的外层循环释放内存。最后，我们通过简单的调用`delete
    [] ThreeDimArray;`来释放初始维度的内存。
- en: 'The output for this example is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的输出如下：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have seen how to model a 3-D array using pointers to pointers to
    pointers, a pattern has emerged to show us how to declare the required level and
    number of pointers to model an N-D array. We can also see the pattern for the
    necessary allocations. Multidimensional arrays can become quite large, especially
    if you were forced to model them with the largest potentially necessary fixed-sized
    array. The beauty of modeling with pointers to pointers (to pointers, and so on)
    for each level of a necessary multi-dimensional array is that you can allocate
    exactly a size that may be determined at runtime. To make usage easy, array notation
    using `[]` can be used as an alternative to pointer notation to access the elements
    in the dynamically allocated array. C++ has a lot of flexibility stemming from
    pointers. Dynamically allocated arrays demonstrate one such flexibility.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用指针到指针到指针来模拟3-D数组，一个模式已经出现，展示了如何声明所需的级别和指针数量来模拟N-D数组。我们还可以看到必要的分配模式。多维数组可以变得相当大，尤其是如果你被迫使用可能需要的最大固定大小数组来模拟它们。使用指针到指针（到指针，等等）来模拟每个必要的多维数组的美丽之处在于，你可以分配一个在运行时可能确定的精确大小。为了使使用简单，可以使用`[]`数组符号作为指针符号的替代，以访问动态分配数组中的元素。C++有很多来自指针的灵活性。动态分配的数组展示了这种灵活性之一。
- en: Let’s now move forward with our understanding of pointers and consider their
    usage in functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在继续我们的指针理解，并考虑它们在函数中的使用。
- en: Using pointers with functions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指针与函数
- en: Functions in C++ will undoubtedly take arguments. We have seen many examples
    in the previous chapters illustrating function prototypes and function definitions.
    Now, let’s augment our understanding of functions by passing pointers as arguments
    to functions, and using pointers as return values from a function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的函数无疑会接受参数。我们在前面的章节中看到了许多示例，说明了函数原型和函数定义。现在，让我们通过将指针作为函数参数传递以及将指针作为函数的返回值来增强我们对函数的理解。
- en: Passing pointers as arguments to functions
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将指针作为函数参数传递
- en: Arguments passed from actual to formal parameters in a function call are by
    default copied on the stack. In order to modify the contents of a variable as
    an argument to a function, a pointer to that argument must instead be used as
    a function parameter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用中，从实际参数传递到形式参数默认是在栈上复制的。为了将变量的内容作为函数的参数修改，必须使用该参数的指针作为函数参数。
- en: Any time an actual parameter is passed to a function in C++, a copy of something
    is made and passed on the stack to that function. For example, if an integer is
    passed as an actual parameter to a function, a copy of that integer is made and
    then passed on the stack to the function to be received as the formal parameter.
    Changing the formal parameter in the scope of the function would only change the
    copy of the data that was passed into the function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，每次将实际参数传递给函数时，都会在栈上创建一个副本并将其传递给该函数。例如，如果将整数作为实际参数传递给函数，就会创建该整数的副本，然后将其传递到栈上，作为函数接收的形式参数。在函数的作用域内更改形式参数只会更改传递给函数的数据的副本。
- en: Should we instead require the ability to modify a function’s parameters, it
    is then necessary that we pass a pointer to the desired data as a parameter to
    the function. In C++, passing a pointer as an actual parameter copies this address
    on the stack, and the copy of the address is received as the formal parameter
    in the function. However, using the copy of the address, we can still go to that
    address (by dereferencing that pointer) to access the desired data and make changes
    to the desired data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要求能够修改函数的参数，那么就必须将所需数据的指针作为参数传递给函数。在C++中，将指针作为实际参数时，会在栈上复制这个地址，并且地址的副本作为形式参数在函数中接收。然而，使用地址的副本，我们仍然可以到达那个地址（通过取消引用该指针）来访问所需的数据并对所需数据进行更改。
- en: To reiterate, something is always copied on the stack when you pass a parameter
    in C++. If you pass a non-pointer variable, you get a copy of that data passed
    on the stack to the function. Changes made to that data in the scope of that function
    are local changes only and do not persist when the function returns. The local
    copy is simply popped off the stack at the conclusion of the function. However,
    if you pass a pointer to a function, though the address stored in the pointer
    variable is still copied on the stack and passed to the function, you can still
    dereference the copy of the pointer to access the real data at the desired address.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在C++中传递参数时，总会在栈上复制某个东西。如果你传递一个非指针变量，你将得到该数据的副本，并将其作为栈上的数据传递给函数。在该函数的作用域内对该数据进行更改仅是局部更改，并且在函数返回时不会持续存在。局部副本在函数结束时简单地从栈上弹出。然而，如果你传递一个指向函数的指针，尽管存储在指针变量中的地址仍然被复制到栈上并传递给函数，你仍然可以取消引用指针的副本来访问所需地址的实际数据。
- en: You always need to be one step back from that which you want to modify. If you
    want to change a standard data type, pass a pointer to that type. If you want
    to change the value of the pointer itself (the address), you must pass a pointer
    to that pointer as a parameter to the function. Remember, a copy of something
    is passed to the function on the stack. You cannot change that copy beyond the
    scope of the function. Pass the address of that which you want to change – you
    are still passing a copy of that address, but using it will get you to the real
    data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是需要退一步来修改你想要修改的东西。如果你想更改标准数据类型，请传递该类型的指针。如果你想更改指针本身的价值（地址），你必须将指向该指针的指针作为参数传递给函数。记住，某物的副本被传递到函数的栈上。你无法在函数的作用域之外更改该副本。传递你想要更改的东西的地址——你仍然在传递该地址的副本，但使用它将带你到实际数据。
- en: 'Let’s take a few minutes to understand an example illustrating passing pointers
    as arguments to functions. Here, we will begin by examining two functions that
    contribute to the following full program example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花几分钟时间理解一个示例，说明将指针作为函数参数传递。在这里，我们将首先检查两个函数，这两个函数有助于以下完整程序示例：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex6.cpp)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex6.cpp)'
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Examining the previous functions, notice that `TryToAddOne()` takes an `int`
    as a formal parameter, while `AddOne()` takes an `int *` as a formal parameter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 检查前面的函数，注意`TryToAddOne()`函数接受一个`int`作为形式参数，而`AddOne()`函数接受一个`int *`作为形式参数。
- en: In `TryToAddOne()`, an integer passed to the function is merely a copy of the
    actual parameter sent to the function. This parameter is referred to as `arg`
    in the formal parameter list. Incrementing the value of `arg` by one in the body
    of the function is a local change only within `TryToAddOne()`. Once the function
    completes, the formal parameter, `arg`, is popped off the stack and the actual
    parameter in the call to this function will not have been modified.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TryToAddOne()`中，传递给函数的整数仅仅是实际参数的副本。在形式参数列表中，该参数被称为`arg`。在函数体中将`arg`的值增加一仅是`TryToAddOne()`内部的局部更改。一旦函数完成，形式参数`arg`将从栈上弹出，调用此函数的实际参数将不会被修改。
- en: 'However, notice that `AddOne()` takes an `int *` as a formal parameter. The
    address of the actual integer parameter will be copied on the stack and received
    as the formal parameter, `arg`. Using the copy of that address, we dereference
    the pointer `arg` using `*`, then increment the integer value at that address
    using `++` in the line of code: `(*arg)++;`. When this function completes, the
    actual parameter will have been modified because we have passed a copy of the
    pointer to that integer, rather than a copy of the integer itself.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意`AddOne()`接受一个`int *`作为形式参数。实际整数参数的地址将被复制到栈上，并作为形式参数`arg`接收。使用该地址的副本，我们使用`*`解引用指针`arg`，然后在代码行中使用`++`递增该地址处的整数值：`(*arg)++;`。当这个函数完成时，实际参数将被修改，因为我们传递的是该整数的指针副本，而不是整数的副本本身。
- en: 'Let’s examine the remainder of this program:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这个程序的其余部分：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice the function prototypes at the top of this program segment. They will
    match the function definitions in the previous segment of code. Now, in the `main()`
    function, we declare and initialize `int x = 10;` and declare a pointer: `int
    *y;`. We allocate the memory for `y` using `new()` and then assign a value by
    dereferencing the pointer with `*y = 15;`. We print out the respective values
    of `x` and `*y` as a baseline.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个程序段顶部的函数原型。它们将与之前代码段中的函数定义相匹配。现在，在`main()`函数中，我们声明并初始化`int x = 10;`并声明一个指针：`int
    *y;`。我们使用`new()`为`y`分配内存，然后通过解引用指针赋值`*y = 15;`。我们打印出`x`和`*y`的相应值作为基准。
- en: Next, we call `TryToAddOne(x);` followed by `TryToAddOne(*y);`. In both cases,
    we are passing integers as actual parameters to the function. Variable `x` is
    declared to be an integer, and `*y` refers to the integer pointed to by `y`. Neither
    of these function calls will result in the actual parameter being changed, which
    we can verify when their respective values are next printed using `cout` and the
    insertion operator `<<`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`TryToAddOne(x);`然后是`TryToAddOne(*y);`。在这两种情况下，我们都是将整数作为实际参数传递给函数。变量`x`被声明为整数，而`*y`指的是`y`所指向的整数。这两个函数调用都不会导致实际参数被改变，这在我们使用`cout`和插入操作符`<<`打印各自的值时可以验证。
- en: 'Finally, we call `AddOne(&x);` followed by `AddOne(y);`. In both cases, we
    are passing a copy of an address as the actual parameter to the function. Of course,
    `&x` is the address of variable `x`, so this works. Likewise, `y` itself is an
    address – it is declared as a pointer variable. Recall that inside the `AddOne()`
    function, the formal parameter is first dereferenced and then incremented in the
    body of the function: `(*arg)++;`. We can use a copy of a pointer to access actual
    data.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`AddOne(&x);`然后是`AddOne(y);`。在这两种情况下，我们都是将地址的副本作为实际参数传递给函数。当然，`&x`是变量`x`的地址，所以这可行。同样，`y`本身也是一个地址——它被声明为一个指针变量。回想一下，在`AddOne()`函数内部，形式参数首先在函数体中被解引用然后递增：`(*arg)++;`。我们可以使用指针副本来访问实际数据。
- en: 'Here is the output for the full program example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整程序示例的输出：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, let us add to our discussion of using pointers with functions by using
    pointers as return values from functions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过使用函数作为返回值来指针使用进行讨论。
- en: Using pointers as return values from functions
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数返回值作为指针的返回值
- en: Functions may return pointers to data via their return statements. When returning
    a pointer via the return statement of a function, be sure that the memory that
    is pointed to will persist after the function call is completed. Do not return
    a pointer to stack memory that is local to the function. That is, do not return
    a pointer to local variables defined on the stack within the function. However,
    returning a pointer to memory allocated using `new()` within the function is acceptable.
    As the allocated memory will be on the heap, it will exist past the function call.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过它们的返回语句返回数据指针。当通过函数的返回语句返回指针时，请确保所指向的内存将在函数调用完成后持续存在。不要返回指向函数中局部栈上定义的局部变量的指针。也就是说，不要返回指向函数中栈上定义的局部变量的指针。然而，返回函数内部使用`new()`分配的内存的指针是可以接受的。因为分配的内存将在堆上，它将在函数调用之后存在。
- en: 'Let’s see an example to illustrate these concepts:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来说明这些概念：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex7.cpp)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex7.cpp)'
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, `constexpr int MAX = 20;` is defined and then `char *createName();`
    is prototyped, indicating that this function takes no arguments, yet returns a
    pointer to one or more characters.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，定义了`constexpr int MAX = 20;`，然后原型化了`char *createName();`，这表明这个函数不接受任何参数，但返回一个指向一个或多个字符的指针。
- en: 'In the `main()` function, a local variable: `char *name;` is defined, but not
    initialized. Next, `createName()` is called and its return value is used to assign
    a value to `name`. Notice that both `name` and the function’s return type are
    of type `char *`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，定义了一个局部变量：`char *name;`，但没有初始化。接下来，调用`createName()`并使用其返回值来给`name`赋值。请注意，`name`和函数的返回类型都是`char
    *`类型。
- en: In the call to `createName()`, notice that a local variable `char *temp = new
    char[MAX];` is both defined and allocated to point to a fixed amount of memory
    on the heap using operator `new()`. The user is then prompted to enter a name
    and that name is stored in `temp`. The local variable `temp` is then returned
    from `createName()`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`createName()`时，请注意，局部变量`char *temp = new char[MAX];`既被定义也被分配，用于在堆上使用操作符`new()`指向固定数量的内存。然后提示用户输入一个名字，该名字被存储在`temp`中。随后，局部变量`temp`从`createName()`返回。
- en: In `createName()`, it is important that the memory for `temp` be comprised of
    heap memory so that it will persist beyond the scope of this function. Here, a
    copy of the address stored in `temp` will be copied onto the stack in the area
    reserved for a return value from the function. Fortunately, that address refers
    to heap memory. The assignment `name = createName();` in `main()` will capture
    this address and copy it to be stored into the `name` variable, which is local
    to `main()`. Since the memory allocated in `createName()` is on the heap, this
    memory will exist once the function completes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createName()`中，重要的是`temp`的内存应该由堆内存组成，这样它将超出这个函数的作用域。在这里，`temp`中存储的地址的副本将被复制到函数返回值预留的栈区。幸运的是，这个地址指向堆内存。在`main()`中的`name
    = createName();`赋值将捕获这个地址并将其复制到存储在`name`变量中，该变量是`main()`的局部变量。由于在`createName()`中分配的内存是在堆上，所以这个内存将在函数完成后存在。
- en: Just as important to note, had `temp` been defined as `char temp[MAX];` in `createName()`,
    the memory comprising `temp` would have existed on the stack and would have been
    local to `createName()`. Once `createName()` returns to `main()`, the memory for
    this variable would have been popped off the stack and been unavailable for proper
    use – even if that address had been captured in a pointer variable within `main()`.
    This is another potential pointer trap in C++. When returning a pointer from a
    function, always ensure that the memory to which the pointer points exists beyond
    the extent of the function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是要注意，如果`temp`在`createName()`中被定义为`char temp[MAX];`，那么`temp`所包含的内存将存在于栈上，并且是`createName()`的局部内存。一旦`createName()`返回到`main()`，这个变量的内存就会被从栈上弹出，变得不可用——即使这个地址被捕获在`main()`中的一个指针变量中。这是C++中另一个潜在的指针陷阱。在从函数返回指针时，始终确保指针指向的内存存在于函数的作用域之外。
- en: 'The output for this example is:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的输出如下：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we understand how pointers can be used within parameters to functions
    and as return values from functions, let’s move forward by examining further pointer
    nuances.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在函数参数中使用指针以及如何从函数返回值中获取指针，让我们继续前进，通过检查更多的指针细微差别来深入探讨。
- en: Using the const qualifier with pointers
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指针的const限定符
- en: The `const` qualifier can be used to qualify pointers in several different ways.
    The keyword `const` can be applied to the data pointed to, to the pointer itself,
    or both. By using the `const` qualifier in these ways, C++ offers means to protect
    values in a program that may be meant to be initialized but never again modified.
    Let’s examine each of these various scenarios. We will also be combining `const`
    qualified pointers with return values from functions to understand which of these
    various scenarios are reasonable to implement.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`限定符可以用来以几种不同的方式限定指针。关键字`const`可以应用于所指向的数据，应用于指针本身，或者两者都应用。通过以这种方式使用`const`限定符，C++提供了在程序中保护值的手段，这些值可能被初始化但不再修改。让我们检查这些不同的场景。我们还将结合`const`限定指针与函数的返回值来了解这些不同场景中哪些是合理的实现。'
- en: Using pointers to constant objects
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指向常量对象的指针
- en: A pointer to a constant object may be specified so that the object that is pointed
    to may not be directly modified. A dereferenced pointer to this object may not
    be used as an l-value in any assignment. An **l-value** means a value that can
    be modified, and that occurs on the left-hand side of an assignment.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可以指定指向常量对象的指针，以便指向的对象不能被直接修改。指向此对象的解引用指针不能在任何赋值中用作左值。**左值**意味着可以修改的值，并且出现在赋值的左侧。
- en: 'Let’s introduce a simple example to understand the situation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来理解这种情况：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we’ve introduced `const char *constData = "constant";`. The pointer points
    to data, which is initialized, and which may never again be modified through this
    identifier. For example, should we try to alter this value using a `strcpy`, where
    `constData` is the destination string, the compiler will issue an error.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们引入了`const char *constData = "constant";`。这个指针指向初始化的数据，并且可能永远不会通过这个标识符再次修改。例如，如果我们尝试使用`strcpy`来改变这个值，其中`constData`是目标字符串，编译器将发出错误。
- en: Also, trying to circumvent the situation by trying to store `constData` into
    a pointer of the same (but not `const`) type, will generate a compiler error,
    such as in the line of code `regularString = constData;`. Of course, in C++, you
    can do anything if you try hard enough, so an explicit typecast here will work,
    but is purposely not shown. An explicit typecast will still generate a compiler
    warning to allow you to question whether this is truly something you intend to
    do. When we move forward with OO concepts, we will introduce ways to further protect
    data so that this type of circumvention can be eliminated.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尝试通过将`constData`存储到相同（但不是`const`）类型的指针中来规避这种情况，将会生成编译器错误，例如在代码行`regularString
    = constData;`中。当然，在C++中，如果你足够努力，你可以做任何事情，所以这里的显式类型转换将有效，但这里故意没有展示。显式类型转换仍然会生成编译器警告，以便你可以质疑这真的是你想要做的事情。当我们向前推进到面向对象的概念时，我们将介绍进一步保护数据的方法，以便消除这种规避。
- en: On the last line of the previous code, notice that we store the address of a
    regular string into `const char *moreConstData`. This is allowed – you can always
    treat something with more respect than it was defined to have (just not less).
    This means that when using the identifier `moreConstData`, this string may not
    be modified. However, using its own identifier, which is defined as `char *anotherRegularString;`,
    this string may be changed. This seems inconsistent, but it is not. The `const
    char *` variable chose to point to a `char *` – elevating its protection for a
    particular situation. If the `const char *` truly wanted to point to an immutable
    object, it would have chosen to instead point to another `const char *` variable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码的最后一行，注意我们将普通字符串的地址存储到`const char *moreConstData`中。这是允许的——你总是可以比定义时赋予它更多的尊重（只是不能更少）。这意味着当使用标识符`moreConstData`时，这个字符串不能被修改。然而，使用其自己的标识符，定义为`char
    *anotherRegularString;`，这个字符串可以被改变。这似乎不一致，但事实并非如此。`const char *`变量选择指向一个`char
    *`——在特定情况下提高了其保护。如果`const char *`真正想要指向一个不可变对象，它会选择指向另一个`const char *`变量。
- en: Next, let’s see a variation on this theme.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看这个主题的一个变体。
- en: Using constant pointers to objects
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指向对象的常量指针
- en: A constant pointer to an object is a pointer that is initialized to point to
    a specific object. This pointer may never be assigned to point to another object.
    This pointer itself may not be used as an l-value in an assignment.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的常量指针是一个初始化为指向特定对象的指针。这个指针永远不能被分配以指向另一个对象。这个指针本身不能在赋值中用作左值。
- en: 'Let’s review a simple example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个简单的例子：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, two regular `char *` variables (`regularString` and `anotherRegularString`)
    are defined and loaded with string literals. Next, `char *const constPtrString
    = regularString;` is defined and initialized to point to a modifiable string.
    Because the `const` qualification is on the pointer itself and not the data pointed
    to, the pointer itself must be initialized with a value at declaration. Notice
    that the line of code: `constPtrString = anotherRegularString;` would generate
    a compiler error because a `const` pointer cannot be on the left hand of an assignment.
    However, because the `const` qualification is not applicable to the data pointed
    to, a `strcpy` may be used to modify the value of the data as is seen in `strcpy(constPtrString,
    "I can change the value");`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，定义了两个常规的`char *`变量（`regularString`和`anotherRegularString`），并加载了字符串字面量。接下来，定义并初始化`char
    *const constPtrString = regularString;`，使其指向一个可修改的字符串。因为`const`修饰的是指针本身而不是指向的数据，所以指针本身必须在声明时初始化。请注意，代码行`constPtrString
    = anotherRegularString;`将生成编译器错误，因为`const`指针不能在赋值的左侧。然而，因为`const`修饰不适用于指向的数据，可以使用`strcpy`来修改数据的值，如`strcpy(constPtrString,
    "I can change the value");`所示。
- en: Next, let us combine the `const` qualifier on both the pointer and the data
    which is pointed to.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将`const`修饰符应用于指针及其指向的数据。
- en: Using constant pointers to constant objects
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用常量指针指向常量对象
- en: A constant pointer to a constant object is a pointer that is established to
    point to a specific object and to unmodifiable data. The pointer itself must be
    initialized to a given object, which is (hopefully) initialized with appropriate
    values. Neither the object nor the pointer may be modified or used as l-values
    in assignments.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 指向常量对象的常量指针是一个指向特定对象且指向不可修改数据的指针。指针本身必须初始化为给定的对象，该对象（希望）已用适当的值初始化。对象和指针都不能被修改或用作赋值中的左值。
- en: 'Here is an example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, two regular `char *` variables are declared, `regularString`
    and `anotherRegularString`. Each is initialized with a string literal. Next, we
    introduce `const char *const constStringandPtr = regularString;`, which is a `const`
    qualified pointer to data that is also treated as `const`. Notice that this variable
    must be initialized because the pointer itself cannot be an l-value in a later
    assignment. You will also want to ensure that this pointer is initialized with
    a meaningful value, as the data that is pointed to also cannot be changed (as
    illustrated by the `strcpy` statement, which would generate a compiler error).
    Combining `const` on the pointer as well as the data pointed to is a strict way
    to safeguard data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，声明了两个常规的`char *`变量，分别是`regularString`和`anotherRegularString`。每个变量都初始化为一个字符串字面量。接下来，我们引入`const
    char *const constStringandPtr = regularString;`，这是一个`const`修饰的指针，它指向的数据也被视为`const`。请注意，这个变量必须被初始化，因为指针本身不能在后续的赋值中作为左值。你还想确保这个指针被初始化为一个有意义的值，因为指向的数据也不能被更改（如`strcpy`语句所示，这将生成编译器错误）。在指针及其指向的数据上结合`const`是一种严格的数据保护方式。
- en: Tip – deciphering pointer declarations
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 - 解析指针声明
- en: To read complex pointer declarations, it often helps to read the declaration
    backward – from right to left. For example, the pointer declaration `const char
    *p1 = "hi!";` would be interpreted as `p1` is a pointer to (one or more) characters
    that are constant. The declaration `const char *const p2 = p1;` would be read
    as `p2` is a constant pointer to (one or more) characters that are constant.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取复杂的指针声明，从右到左读取声明通常有帮助。例如，指针声明`const char *p1 = "hi!";`可以解释为`p1`是一个指向一个或多个常量字符的指针。声明`const
    char *const p2 = p1;`可以解释为`p2`是一个指向一个或多个常量字符的常量指针。
- en: Finally, let us move forward to understand the implications of `const` qualifying
    pointers, which serve as function parameters or as return values from functions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们前进，了解使用`const`修饰指针的内涵，这些指针作为函数参数或作为函数的返回值。
- en: Using pointers to constant objects as function arguments and as return types
    from functions
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指向常量对象的指针作为函数参数和作为函数的返回类型
- en: Copying arguments on the stack that are user defined types can be time-consuming.
    Passing a pointer as a function argument is speedier, yet permits the dereferenced
    object to possibly be modified in the scope of the function. Passing a pointer
    to a constant object as a function argument provides both speed and safety for
    the argument in question. The dereferenced pointer simply may not be an l-value
    in the scope of the function in question. The same principle holds true for the
    return value from a function. Constant qualifying the data pointed to insists
    that the caller of the function must also store the return value in a pointer
    to a constant object, ensuring the object’s long-term immutability.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈上复制用户定义类型作为参数可能会消耗时间。将指针作为函数参数传递更快，同时允许在函数的作用域内修改解引用的对象。将指向常量对象的指针作为函数参数提供了针对该参数的速度和安全性。解引用的指针在函数的作用域内可能不是一个左值。同样的原则也适用于函数的返回值。对指向的数据使用常量限定符要求函数的调用者也必须将返回值存储在指向常量对象的指针中，确保对象的长期不可变性。
- en: 'Let’s take a look at an example to examine these ideas:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来考察这些想法：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex8.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex8.cpp)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex8.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex8.cpp)'
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this example, we begin with a global variable to store an initial suffix,
    `char *suffix = ''A'';`, and the prototype for the function: `const char *GenId(const
    char *base);`. In `main()`, we declare, but do not initialize, `const char* newId1,
    *newId2;`, which will eventually hold the IDs generated by `GenId()`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从一个全局变量开始，用于存储初始后缀，`char *suffix = 'A';`，以及函数的原型：`const char *GenId(const
    char *base);`。在`main()`函数中，我们声明了`const char* newId1, *newId2;`，但没有初始化，它们最终将保存由`GenId()`生成的ID。
- en: 'Next, we call `GenId()` twice, passing a string literal `"Group"` to this function
    as the actual parameter. This parameter is received as a formal parameter: `const
    char *base`. The return value of this function will be used to assign values to
    `newId1` and `newId2`, respectively.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们两次调用`GenId()`函数，将字符串字面量`"Group"`作为实际参数传递给这个函数。这个参数作为形式参数接收：`const char
    *base`。这个函数的返回值将被用来分别赋值给`newId1`和`newId2`。
- en: Looking more closely, we see that the call to `GenId("Group")` passes the string
    literal `"Group"` as the actual parameter, which is received as `const char *base`
    in the formal parameter list of the function definition. This means that when
    using the identifier `base`, this string may not be modified.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 更仔细地看，我们看到调用`GenId("Group")`时，将字符串字面量`"Group"`作为实际参数传递，它在函数定义的形式参数列表中被接收为`const
    char *base`。这意味着在使用标识符`base`时，这个字符串可能不会被修改。
- en: Next, within `GenId()`, we declare local pointer variable `temp` on the stack
    and allocate enough heap memory for `temp` to point to, to accommodate the string
    pointed to by `base` plus an extra character for the suffix to be added, plus
    one for the null character to terminate the new string. Note that `strlen()` counts
    the number of characters in a string, excluding the null character. Now, by using
    `strcpy()`, `base` is copied into `temp`. Then, using the assignment `temp[strlen(base)]
    = suffix++;`, the letter stored in `suffix` is added to the string pointed to
    by `temp` (and `suffix` is incremented to the next letter for the next time we
    call this function). Remember that arrays are zero-based in C++ when adding characters
    to the end of a given string. For example, if `"Group"` comprises five characters
    in array `temp`’s positions 0 through 4, then the next character (from `suffix`)
    would be added at position 5 in `temp` (overwriting the current null character).
    In the next line of code, the null character is re-added to the end of the new
    string pointed to by `temp`, as all strings need to be null terminated. Note that,
    whereas `strcpy()` will automatically null-terminate a string, once you resort
    to a single-character replacement, such as by adding the suffix to the string,
    you then need to re-add the null character to the new overall string yourself.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`GenId()`函数内部，我们在栈上声明了局部指针变量`temp`，并为`temp`分配了足够的堆内存，以便它指向一个字符串，以容纳由`base`指向的字符串加上一个额外的字符用于添加后缀，再加上一个用于终止新字符串的空字符。请注意，`strlen()`函数计算字符串中的字符数，不包括空字符。现在，通过使用`strcpy()`，将`base`复制到`temp`中。然后，使用赋值`temp[strlen(base)]
    = suffix++;`，将存储在`suffix`中的字母添加到由`temp`指向的字符串中（并且`suffix`递增到下一次调用此函数时的下一个字母）。请记住，在C++中向给定字符串的末尾添加字符时，数组是从零开始的。例如，如果`"Group"`在`temp`数组的0到4位置包含五个字符，那么下一个字符（来自`suffix`）将添加到`temp`的位置5（覆盖当前的空字符）。在下一条代码行中，将空字符重新添加到由`temp`指向的新字符串的末尾，因为所有字符串都需要以空字符终止。请注意，虽然`strcpy()`会自动以空字符终止字符串，但一旦你求助于单字符替换，例如通过将后缀添加到字符串中，那么你需要自己重新添加空字符到新的整体字符串中。
- en: Lastly, in this function, `temp` is returned. Notice that though `temp` is declared
    as a `char *`, it is returned as a `const char *`. This means that the string
    will be treated in a more restrictive fashion upon its return to `main()` than
    it was treated in the body of the function. In essence, it has been upcast to
    a `const char *`. The implication is that since the return value of this function
    is a `const char *`, only a pointer of type `const char *` can capture the return
    value of this function. This is required so that the string cannot be treated
    in a less restrictive fashion than intended by the creator of function `GenId()`.
    Had `newId1` and `newId2` been declared of type `char *` rather than `const char
    *`, they would not have been allowed to serve as l-values to capture the return
    value of `GenId()`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个函数中，返回`temp`。请注意，尽管`temp`被声明为`char *`类型，但它被返回为`const char *`类型。这意味着在返回到`main()`函数体时，字符串将以更严格的方式处理，而不是在函数体中处理。本质上，它已经被提升为`const
    char *`类型。这意味着，由于这个函数的返回值是`const char *`类型，因此只能捕获该函数返回值的`const char *`类型的指针。这是必要的，以便字符串不能以比函数`GenId()`的创建者所期望的更宽松的方式处理。如果`newId1`和`newId2`被声明为`char
    *`类型而不是`const char *`类型，它们将不允许作为l-values来捕获`GenId()`函数的返回值。
- en: At the end of `main()`, we delete the memory associated with `newId1` and `newId2`.
    Notice that the memory for these pointer variables was allocated and released
    in different scopes within the program. The programmer must always be diligent
    to keep track of memory allocation and release in C++. Forgetting to deallocate
    memory can lead to memory leakage within an application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数的末尾，我们删除了与`newId1`和`newId2`相关的内存。请注意，这些指针变量的内存是在程序的不同作用域内分配和释放的。程序员必须始终勤奋地跟踪C++中的内存分配和释放。忘记释放内存可能导致应用程序中的内存泄漏。
- en: 'Here is the output to accompany our example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是伴随我们示例的输出：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that we have an understanding of how and why to `const` qualify pointers,
    let’s take a look at how and why we might choose a generic pointer type by considering
    void pointers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何以及为什么需要对指针进行`const`限定，让我们通过考虑空指针来探讨我们可能如何以及为什么选择一个泛型指针类型。
- en: Using pointers to objects of unspecified types
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用未指定类型的对象指针
- en: Sometimes, programmers ask why they cannot simply have a generic pointer. That
    is, why must we always declare the type of data to which the pointer will eventually
    point, such as `int *ptr;`? C++ certainly does allow us to create pointers without
    associated types, but C++ then requires the programmer to keep track of things
    that would normally be done on their behalf. Nonetheless, we will see why void
    pointers are useful and what the programmer must undertake when using more generic
    void pointers in this section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，程序员会问为什么他们不能简单地有一个泛型指针。也就是说，为什么我们必须始终声明指针最终指向的数据类型，例如 `int *ptr;`？C++ 当然允许我们创建没有关联类型的指针，但
    C++ 那时要求程序员跟踪那些通常由他们自己完成的事情。尽管如此，我们将在本节中看到空指针为什么有用，以及程序员在使用更通用的空指针时必须承担什么。
- en: It is important to note that void pointers require careful handling, and their
    misuse can be extremely dangerous. We will, much later in the book, see a safer
    alternative to genericize types (including pointers) in [*Chapter 13*](B19087_13.xhtml#_idTextAnchor561),
    *Working with Templates*. Nonetheless, there are careful encapsulated techniques
    that use an underlying implementation of a `void *` for efficiency, paired with
    a safe wrapper of a template. We will see that templates are expanded for every
    type needed and can sometimes lead to *template bloat*. In these cases, a safe
    pairing of a template with an underlying `void *` implementation gives us both
    safety and efficiency.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，空指针需要谨慎处理，它们的误用可能非常危险。我们将在本书的较后部分看到一种更安全的泛化类型（包括指针）的替代方案（包括指针），即在第 13
    章[*模板工作*](B19087_13.xhtml#_idTextAnchor561)中。不过，有一些谨慎封装的技术使用 `void *` 的底层实现以提高效率，并配以模板的安全包装。我们将看到模板为每个需要的类型展开，有时可能导致
    *模板膨胀*。在这些情况下，模板与底层 `void *` 实现的安全配对为我们提供了安全和效率。
- en: To understand a void pointer, let us first consider why a type is typically
    associated with a pointer variable. Typically, declaring the type with the pointer
    gives C++ information about how to conduct pointer arithmetic or index into a
    dynamically allocated array of that pointer type. That is, if we have allocated
    `int *ptr = new int [10];`, we have 10 consecutive integers. Using either the
    array notation of `ptr[3] = 5;` or the pointer arithmetic of `*(ptr + 3) = 5;`
    to access one such element in this dynamically allocated set relies on the size
    of the data type `int` to internally allow C++ to understand how large each element
    is and how to move from one such item to the next. The data type also tells C++,
    once it has arrived at an appropriate memory address, how to interpret the memory.
    For example, an `int` and a `float` may have the same storage size on a given
    machine, however, the two’s complement memory layout of an `int` versus the mantissa,
    exponent layout of a `float` is quite different. C++’s knowledge of how to interpret
    the given memory is crucial, and the data type of the pointer does just that.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解空指针，我们首先考虑为什么类型通常与指针变量相关联。通常，用指针声明类型会给 C++ 提供关于如何进行指针算术或索引到该指针类型的动态分配数组的信息。也就是说，如果我们分配了
    `int *ptr = new int [10];`，我们就有了 10 个连续的整数。使用数组的表示法 `ptr[3] = 5;` 或指针算术 `*(ptr
    + 3) = 5;` 来访问这个动态分配集合中的一个元素，依赖于数据类型 `int` 的大小，以便 C++ 内部理解每个元素的大小以及如何从一个元素移动到下一个元素。数据类型还告诉
    C++，一旦到达适当的内存地址，如何解释内存。例如，`int` 和 `float` 在给定的机器上可能具有相同的存储大小，然而，`int` 的二进制补码内存布局与
    `float` 的尾数、指数布局是相当不同的。C++ 如何解释给定内存的知识至关重要，而指针的数据类型正是这样做的。
- en: However, the need still exists to have a more generic pointer. For example,
    you may want a pointer that might point to an integer in one situation, yet to
    a set of user defined types in another situation. Using a `void *` allows just
    this to happen. But what about type? What happens when you dereference a void
    pointer? If C++ does not know how many bytes to go from one element in a set to
    another, how can it index into a dynamically allocated array of void pointers?
    How will it interpret the bytes once at an address? What is the type?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然需要有一个更通用的指针。例如，你可能希望一个指针在一种情况下指向一个整数，在另一种情况下指向一组用户定义的类型。使用 `void *` 允许发生这种情况。但是类型怎么办？当你取消引用空指针时会发生什么？如果
    C++ 不知道从一个集合中的一个元素移动到另一个元素需要多少字节，它如何索引空指针的动态分配数组？它如何解释地址上的字节？类型是什么？
- en: The answer is that you, the programmer, must personally remember what you are
    pointing to at all times. Without the type associated with the pointer, the compiler
    cannot do this for you. And when it is time to dereference the void pointer, you
    will be in charge of correctly remembering the ultimate type involved and performing
    the appropriate type cast on that pointer.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，你必须始终亲自记住你指向的内容。没有与指针关联的类型，编译器无法为你做这件事。当需要解引用 void 指针时，你将负责正确地记住涉及到的最终类型，并对该指针执行适当的类型转换。
- en: Let’s take a look at the mechanics and logistics of what is involved.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看涉及到的机制和后勤。
- en: Creating void pointers
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 void 指针
- en: Pointers to objects of unspecified types may be specified by using `void *`.
    The void pointer may then point to an object of any type. Explicit casting must
    be used in order to dereference actual memory pointed to by the `void *`. Explicit
    casting must also be used in C++ to assign memory pointed to by a `void *` to
    a pointer variable of a known type. It is the programmer’s responsibility to ensure
    that the dereferenced data types are the same before making the assignment. Should
    the programmer be incorrect, there will be an elusive pointer mistake to find
    elsewhere in the code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `void *` 来指定指向未指定类型的对象的指针。void 指针可以指向任何类型的对象。为了解引用由 `void *` 指向的实际内存，必须使用显式转换。在
    C++ 中，也必须使用显式转换将 `void *` 指向的内存分配给已知类型的指针变量。确保在赋值之前解引用的数据类型相同是程序员的职责。如果程序员出错，将会有一个难以追踪的指针错误出现在代码的其他地方。
- en: 'Here is an example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex9.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex9.cpp)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex9.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter03/Chp3-Ex9.cpp)'
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, the declaration `void *unspecified;` creates a pointer that
    may, one day, point to memory that can be of any data type. The declaration `int
    *x;` declares a pointer that may someday point to one or more consecutive integers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，声明 `void *unspecified;` 创建了一个指针，将来可能指向任何数据类型的内存。声明 `int *x;` 声明了一个指针，将来可能指向一个或多个连续的整数。
- en: The assignment `*(static_cast<int *>(unspecified)) = 89;` first uses an explicit
    typecast to cast `unspecified` to an `(int *)` and then dereferences the `int
    *` to place the value of `89` in memory. It is important to note that this typecast
    must be done before `unspecified` may be dereferenced – otherwise, C++ does not
    understand how to interpret the memory that `unspecified` points to. Also note
    that if you accidentally typecast `unspecified` to the wrong type, the compiler
    would let you proceed, as typecasts are seen as a *“just do it”* command to the
    compiler. It is your job, as the programmer, to remember what type of data your
    `void *` points.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值 `*(static_cast<int *>(unspecified)) = 89;` 首先使用显式类型转换将 `unspecified` 转换为
    `(int *)`，然后解引用 `int *` 将值 `89` 放入内存。重要的是要注意，在解引用 `unspecified` 之前必须进行此类型转换——否则，C++
    不理解如何解释 `unspecified` 指向的内存。还要注意，如果你不小心将 `unspecified` 转换为错误类型，编译器会允许你继续，因为类型转换被视为对编译器的一个
    *“只管做”* 命令。作为程序员，记住你的 `void *` 指向的数据类型是你的责任。
- en: 'Lastly, we would like `x` to point to where `unspecified` points. Variable
    `x` is an integer and needs to point to one or more integers. Variable `unspecified`
    truly points to an integer, but since the data type of unspecified is `void *`,
    we must use an explicit typecast to make the following assignment work: `x = static_cast<int
    *>(unspecified) ;`. Also, programmatically, we hope that we are correct and that
    we have remembered that `unspecified` truly points to an `int`; knowing the correct
    memory layout is important should the `int *` ever be dereferenced. Otherwise,
    we have just forced an assignment between pointers of different types, leaving
    a lurking error in our program.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望 `x` 指向 `unspecified` 指向的位置。变量 `x` 是一个整数，需要指向一个或多个整数。变量 `unspecified`
    确实指向一个整数，但由于未指定类型的数据类型是 `void *`，我们必须使用显式类型转换来使以下赋值工作：`x = static_cast<int *>(unspecified)
    ;`。此外，从程序的角度来看，我们希望我们是正确的，并且记得 `unspecified` 真正指向一个 `int`；如果 `int *` 任何时候被解引用，知道正确的内存布局是很重要的。否则，我们只是强制在类型不同的指针之间进行赋值，在我们的程序中留下了一个潜伏的错误。
- en: 'Here is the output to accompany our program:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是伴随我们程序的输出：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There are many creative uses of void pointers in C++. Some techniques use `void
    *`’s for generic pointer manipulations and pair this inner processing with a thin
    layer on top to cast the data into a known data type. The thin top layers can
    be further genericized with the C++ feature of templates. Using templates, only
    one version of the explicit type casts is maintained by the programmer, yet many
    versions are truly made available on your behalf – one per actual concrete data
    type needed. These ideas encompass advanced techniques, but we will see several
    of them in the chapters ahead, starting with [*Chapter 13*](B19087_13.xhtml#_idTextAnchor561),
    *Working with Templates*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，void指针有许多创造性的用法。一些技术使用`void *`进行通用指针操作，并将这种内部处理与顶层薄层相结合，以将数据转换为已知的数据类型。这些薄层可以通过C++的模板功能进一步泛化。使用模板，程序员只需维护一个显式类型转换的版本，但实际上为你的需求提供了许多版本——每个实际具体数据类型需要一个。这些想法包括高级技术，但在接下来的章节中，我们将看到其中的一些，从[*第13章*](B19087_13.xhtml#_idTextAnchor561)，*使用模板*开始。
- en: Looking ahead to smart pointers for safety
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展望智能指针的安全性
- en: We have seen many uses of pointers to add flexibility and efficiency to our
    programs. However, we have also seen that with the power that pointers can provide
    comes potential havoc! Dereferencing uninitialized pointers can take us to non-existent
    memory locations that will inevitably crash our programs. Accidentally dereferencing
    memory that we have marked for deletion is similarly destructive – the memory
    address may have already been reused by the heap management facility elsewhere
    in our program. Neglecting to delete dynamically allocated memory when we are
    done with it will cause memory leaks. Even more challenging is allocating memory
    in one scope and expecting to remember to delete that memory in another scope.
    Or, consider what happens when two or more pointers point to the same piece of
    heap memory. Which pointer is responsible for deleting the memory? This is an
    issue we will see several times throughout the book with various solutions. These
    issues are just a few of the potential landmines we may step on when we utilize
    pointers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多指针的使用，它们为我们的程序增加了灵活性和效率。然而，我们也看到了指针所提供的强大功能可能带来的潜在灾难！解引用未初始化的指针可能会带我们到不存在的内存位置，这不可避免地会导致我们的程序崩溃。意外地解引用我们已标记为删除的内存同样具有破坏性——内存地址可能已经被程序其他地方的堆管理设施重新使用。当我们完成对动态分配内存的使用时，忘记删除它将导致内存泄漏。更具有挑战性的是，在一个作用域中分配内存，并期望在另一个作用域中记住删除该内存。或者，考虑当两个或更多指针指向同一块堆内存时会发生什么。哪个指针负责删除内存？这个问题在本书的多个地方都会出现，我们将看到各种解决方案。这些问题只是我们在使用指针时可能遇到的潜在地雷中的一小部分。
- en: You may ask whether there is another way to have the benefits of dynamically
    allocated memory, and yet have a safety net to govern its use. Fortunately, the
    answer is yes. The concept is a `unique_ptr`, `shared_ptr`, and `weak_ptr`. The
    premise of a smart pointer is that it is a class to safely wrap the usage of a
    raw pointer, minimally handling the proper deallocation of heap memory when the
    outer smart pointer goes out of scope.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，是否还有其他方法可以享有动态分配内存的好处，同时又能有一个安全网来管理其使用。幸运的是，答案是肯定的。这个概念是`unique_ptr`、`shared_ptr`和`weak_ptr`。智能指针的前提是它是一个类，用于安全地封装原始指针的使用，当外部智能指针超出作用域时，最小化处理堆内存的正确释放。
- en: However, to best understand smart pointers, we will need to understand [*Chapter
    5*](B19087_05.xhtml#_idTextAnchor222), *Exploring Classes in Detail*, [*Chapter
    12*](B19087_12.xhtml#_idTextAnchor526), *Friends and Operator Overloading*, and
    [*Chapter 13*](B19087_13.xhtml#_idTextAnchor561), *Working with Templates*. After
    understanding these core C++ features, smart pointers will be a meaningful option
    for us to embrace for pointer safety in the new code that we create. Will you
    still need to understand how to use native pointers in C++? Yes. It is inevitable
    that you will utilize many class libraries in C++ that heavily use native pointers,
    so you will need to understand their usage as well. Additionally, you may be integrating
    with, or maintaining, existing C++ code that is heavily native pointer reliant.
    You may also look online at many C++ forums or tutorials, and native pointers
    will inevitably pop up there as well.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了最好地理解智能指针，我们需要了解[第 5 章](B19087_05.xhtml#_idTextAnchor222)《详细探索类》，[第 12
    章](B19087_12.xhtml#_idTextAnchor526)《友元和运算符重载》，以及[第 13 章](B19087_13.xhtml#_idTextAnchor561)《与模板一起工作》。在理解了这些核心的
    C++ 特性之后，智能指针将是我们拥抱指针安全性的一个有意义的选项，用于我们创建的新代码。你还需要了解如何使用 C++ 中的原生指针吗？是的。在 C++ 中，你不可避免地会使用许多大量使用原生指针的类库，因此你需要了解它们的用法。此外，你可能正在集成或维护大量依赖原生指针的现有
    C++ 代码。你还可以在网上查看许多 C++ 论坛或教程，那里也会不可避免地出现原生指针。
- en: The bottom line is that as C++ programmers, we need to understand how to use
    native C++ pointers, yet also understand their dangers, potential misuse, and
    pitfalls. Then, once we have mastered classes, operator overloading, and templates,
    we can add smart pointers to our repertoire and wisely choose to use them in our
    wholly new code. Yet, we will be prepared for any C++ situation by also understanding
    native C++ pointers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 核心在于，作为 C++ 程序员，我们需要了解如何使用原生 C++ 指针，同时也要了解它们的风险、潜在的误用和陷阱。一旦我们掌握了类、运算符重载和模板，我们就可以将智能指针添加到我们的工具箱中，并明智地选择在我们的全新代码中使用它们。然而，通过理解原生
    C++ 指针，我们将为任何 C++ 场景做好准备。
- en: With that in mind, we will continue gaining facility with native C++ pointers
    until we have best laid the groundwork to add these useful smart pointer classes
    into our repertoire. Then, we will see each smart pointer type in full detail.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，我们将继续提高对原生 C++ 指针的熟练程度，直到我们为将这些有用的智能指针类添加到我们的工具箱中打下坚实的基础。然后，我们将详细查看每种智能指针类型。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned many aspects surrounding pointers in C++. We
    have seen how to allocate memory from the heap using `new()` and how to relinquish
    that memory to the heap management facility using `delete()`. We have seen examples
    using both standard and user defined types. We have also understood why we may
    want to dynamically allocate arrays and have seen how to do so for `1`, `2`, and
    `N` dimensions. We have seen how to release the corresponding memory using `delete[]`.
    We have reviewed functions by adding pointers as parameters to functions and as
    return values from functions. We have also learned how to `const` qualify pointers
    as well as the data to which they point (or both) and why you may want to do so.
    We have seen one way to genericize pointers by introducing void pointers. Lastly,
    we have looked ahead to the concept of smart pointers.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了围绕 C++ 中指针的许多方面。我们看到了如何使用 `new()` 从堆中分配内存，以及如何使用 `delete()` 将内存归还给堆管理设施。我们看到了使用标准类型和用户定义类型的示例。我们还理解了为什么我们可能想要动态分配数组，并看到了如何为一维、二维和
    N 维进行动态分配。我们还看到了如何使用 `delete[]` 释放相应的内存。我们通过向函数添加指针作为参数和从函数返回值来回顾了函数。我们还学习了如何使用
    `const` 来指定指针及其指向的数据（或两者）以及为什么你可能想要这样做。我们看到了通过引入空指针来泛化指针的一种方法。最后，我们展望了智能指针的概念。
- en: All of the skills using pointers from this chapter will be used freely in the
    upcoming chapters. C++ expects programmers to have great facility using pointers.
    Pointers allow the language great freedom and efficiency to utilize a vast number
    of data structures and to employ creative programming solutions. However, pointers
    can provide a massive way to introduce errors into a program with memory leakage,
    returning pointers to memory that no longer exists, dereferencing pointers that
    have been deleted, and so on. Not to worry; we will utilize many examples going
    forward using pointers so that you will be able to manipulate pointers with great
    facility. Additionally, we will later add specific types of smart pointers to
    our upcoming programming repertoire to allow us to use add pointer safety when
    constructing code from scratch.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有指针技能都将自由地应用于即将到来的章节中。C++期望程序员能够熟练地使用指针。指针使语言具有极大的自由度和效率，可以充分利用大量的数据结构，并采用创造性的编程解决方案。然而，指针可以通过内存泄漏、返回不再存在的内存的指针、取消引用已删除的指针等方式，以巨大的方式向程序中引入错误。不要担心；我们将继续使用许多指针示例，以便你能够熟练地操作指针。此外，我们将在以后的编程中添加特定类型的智能指针，以便我们在从头开始构建代码时能够使用指针安全性。
- en: Most importantly, you are now ready to move forward to [*Chapter 4*](B19087_04.xhtml#_idTextAnchor188),
    *Indirect Addressing – References*, in which we will explore indirect addressing
    using references. Once you have understood both types of indirect addressing –
    pointers and references – and can manipulate either with ease, we will take on
    the core object-oriented concepts in this book, starting in [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222),
    *Exploring Classes in Detail*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，你现在已经准备好向前迈进到[*第4章*](B19087_04.xhtml#_idTextAnchor188)，*间接寻址 – 引用*，我们将探讨使用引用的间接寻址。一旦你理解了两种间接寻址类型
    – 指针和引用 – 并且可以轻松地操作它们，我们将在本书中承担核心的面向对象概念，从[*第5章*](B19087_05.xhtml#_idTextAnchor222)，*详细探索类*开始。
- en: Questions
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Modify and augment your C++ program from [*Chapter 2*](B19087_02.xhtml#_idTextAnchor072),
    *Adding Language Necessities*, *Question 2*, as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改并增强你的C++程序，从[*第2章*](B19087_02.xhtml#_idTextAnchor072)，*添加语言需求*，*问题2*，如下：
- en: Create a function, `ReadData()`, which accepts a pointer to a Student as an
    argument to allow for `firstName`, `lastName`, and `gpa`, and the `currentCourseEnrolled`
    to be entered from the keyboard within the function and stored as the input parameter’s
    data.
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数`ReadData()`，它接受一个指向`Student`的指针作为参数，以便在函数内部从键盘输入`firstName`、`lastName`、`gpa`和`currentCourseEnrolled`，并将这些作为输入参数的数据存储。
- en: Modify `firstName`, `lastName`, and `currentCourseEnrolled` to be modeled as
    `char *` (or `string`) in your `Student` class instead of using fixed-sized arrays
    (as they may have been modeled in [*Chapter 2*](B19087_02.xhtml#_idTextAnchor072),
    *Adding Language Necessities*). You may utilize a `temp` variable that is a fixed
    size to initially capture user input for these values, and then allocate the proper,
    respective sizes for each of these data members. Note that using a `string` will
    be the simplest and safest approach.
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`firstName`、`lastName`和`currentCourseEnrolled`在`Student`类中修改为`char *`（或`string`），而不是使用固定大小的数组（如它们可能在[*第2章*](B19087_02.xhtml#_idTextAnchor072)，*添加语言需求*中建模的那样）。你可以使用一个固定大小的`temp`变量来最初捕获这些值的用户输入，然后为这些数据成员中的每一个分配适当的、相应的尺寸。请注意，使用`string`将是简单且最安全的方法。
- en: Rewrite, if necessary, the `Print()` function from your solution in [*Chapter
    2*](B19087_02.xhtml#_idTextAnchor072), *Adding Language Necessities*, to take
    a `Student` as a parameter for `Printd().`
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，重写你在[*第2章*](B19087_02.xhtml#_idTextAnchor072)，*添加语言需求*中的解决方案中的`Print()`函数，使其接受`Student`作为`Printd()`的参数。
- en: Overload the `Print()` function with one that takes a `const Student *` as a
    parameter. Which one is more efficient? Why?
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 载荷`Print()`函数，添加一个接受`const Student *`作为参数的版本。哪一个更高效？为什么？
- en: In `main()`, create an array of pointers to `Student` to accommodate five students.
    Allocate each `Student`, call `ReadData()` for each `Student`, and then `Print()`
    each `Student` using a selection from your previous functions. When done, remember
    to `delete()` the memory for each `Student` allocated.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`中创建一个指向`Student`的指针数组，以容纳五个学生。为每个`Student`分配内存，为每个`Student`调用`ReadData()`，然后使用你之前的功能之一`Print()`每个`Student`。完成后，记得删除为每个`Student`分配的内存。
- en: 'Also in `main()`, create an array of void pointers that is the same size as
    the array of pointers to `Student`. Set each element in the array of `void` pointers
    to point to a corresponding `Student` from the array of `Student` pointers. Call
    the version of `Print()` that takes a `const Student *` as a parameter for each
    element in the `void *` array. Hint: you will need to cast `void *` elements to
    type `Student *` prior to making certain assignments and function calls.'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样在 `main()` 中，创建一个与指向 `Student` 的指针数组大小相同的 `void` 指针数组。将 `void` 指针数组中的每个元素设置为指向从
    `Student` 指针数组中对应的 `Student`。为 `void *` 数组中的每个元素调用接受 `const Student *` 作为参数的 `Print()`
    版本。提示：在执行某些赋值和函数调用之前，你需要将 `void *` 元素转换为 `Student *` 类型。
- en: 'Write the following pointer declarations that include a `const` qualification:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下包含 `const` 修饰符的指针声明：
- en: 'Write a declaration for a pointer to a constant object. Assume the object is
    of type `Student`. Hint: read your declaration from right to left to verify correctness.'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个指向常量对象的指针的声明。假设对象是 `Student` 类型。提示：从右到左阅读你的声明以验证其正确性。
- en: Write a declaration for a constant pointer to a non-constant object. Again,
    assume the object is of type `Student.`
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个指向非常量对象的常量指针的声明。再次，假设对象是 `Student` 类型。
- en: Write a declaration for a constant pointer to a constant object. The object
    will again be of type `Student`.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个指向常量对象的常量指针的声明。对象再次是 `Student` 类型。
- en: Why does passing an argument of type `const Student *` to `Print()` in your
    preceding program make sense, yet passing a parameter of type `Student * const`
    does not make sense?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在先前的程序中将类型为 `const Student *` 的参数传递给 `Print()` 有意义，而传递类型为 `Student * const`
    的参数则没有意义？
- en: Can you think of programming situations that may require a dynamically allocated
    3-D array? What about a dynamically allocated array with more dimensions?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能想到需要动态分配三维数组的编程场景吗？更多维度的动态分配数组又如何？
