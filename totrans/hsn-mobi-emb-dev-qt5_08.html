<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Connectivity with Qt Bluetooth LE</h1>
                </header>
            
            <article>
                
<p>You will learn about using Qt Bluetooth <strong>Low Energy</strong> (<strong><span>LE</span></strong>) to build connectivity to devices that have LE Bluetooth radios. Bluetooth is more than mice, keyboards, and audio. Device discovery, data exchange, and other tasks involving Bluetooth Low Energy will be examined. We will use the <kbd>QBluetoothUuid</kbd>, <kbd>QBluetoothCharacteristic</kbd>, <kbd>QLowEnergyController</kbd>, and <kbd>QLowEnergyService</kbd> classes.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li><span>What is Bluetooth Low Energy</span></li>
<li><span>Discovering and connecting with devices</span></li>
<li><span>Advertising services</span></li>
<li><span>Retrieving sensor data from remote device</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is Bluetooth Low Energy?</h1>
                </header>
            
            <article>
                
<p><span><strong>Bluetooth Low Energy</strong> (<strong>BLE</strong>), or Bluetooth Smart as it is also called, was originally developed by Nokia under the name </span><span>Wibree and was originally released in 2006. It was integrated into the Bluetooth 4.0 specification and released in 2010.</span></p>
<p>Bluetooth is a wireless connection technology that operates in the 2,400-2,483.5 MHz range of the 2.4 GHz frequency band. There are 79 data channels it can choose for transmitting packets. BLE limits the data channels to 40.</p>
<p>BLE is targeted at mobile and embedded devices that require lower power consumption. Unlike Bluetooth, BLE is designed for devices that exchange small amounts of data periodically, as opposed to regular Bluetooth that was designed for continuous data streams. Most importantly, BLE has a sleep mode that it uses to conserve power.</p>
<p>Qt has support for BLE in the Qt Connectivity module alongside <strong>Near-field Communication</strong> (NFC). BLE has a number of profiles and services:</p>
<ul>
<li>Alerts</li>
<li>Battery</li>
<li>Fitness</li>
<li>Health</li>
<li>HID</li>
<li>Internet</li>
<li>Mesh</li>
<li>Sensors</li>
</ul>
<p><strong>Generic Attribute</strong> (<strong><span>GATT</span></strong>) is used to store profiles, services, characteristics, and other data. Each entry is a unique 16-bit ID. The BLE connection is exclusive in that it can only connect to one computer at a time. The BLE peripheral device is known as the GATT server, and the computer it connects to is the GATT client.</p>
<p>Each profile can have a number of services. Each service can have a number of characteristics. A profile is just the collection of pre-defined services in the specification.</p>
<p>A service is just a group of characteristics defined by a unique 16 or 128-bit ID. A characteristic is a single data point, which may contain an array of data, such as with an accelerometer.</p>
<p>Now that you know a little bit of the background, let's get started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a BLE GATT server</h1>
                </header>
            
            <article>
                
<p>I guess we really need a BLE server now.</p>
<p>Let's say you have an embedded device that has a few environmental sensors attached, such as humidity and temperature. You need to send this data over Bluetooth to another handheld device once in a while. On the embedded sensor device, you need to setup the device. The basic procedure to set up the BLE server is as follows:</p>
<ol>
<li>Supply advertisement data (<kbd>QLowEnergyAdvertisingData</kbd><span>)</span></li>
<li>Supply characteristic data (<kbd>QLowEnergyCharacteristicData</kbd><span>)</span></li>
<li>Set up the service data (<kbd>QLowEnergyServiceData</kbd>)</li>
<li>Start advertising and listening for connections</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QLowEnergyAdvertisingData</h1>
                </header>
            
            <article>
                
<p><kbd>QLowEnergyAdvertisingData</kbd> is the class you use to tell the server what and how the data is going to be presented.</p>
<p>Here's how we would use <span><kbd>QLowEnergyAdvertisingData.</kbd></span></p>
<p><span>Construct a <kbd>QLowEnergyAdvertisingData</kbd> object:</span></p>
<pre>QLowEnergyAdvertisingData *leAdd = new QLowEnergyAdvertisingData;</pre>
<p>Set <kbd>Discoverability</kbd> options:</p>
<pre><span>leAdd-&gt;</span>setDiscoverability(<br/>QLowEnergyAdvertisingData::DiscoverabilityGeneral);</pre>
<p><br/>
Set a <kbd>Name</kbd> for our service:</p>
<pre><span>leAdd-&gt;</span>setLocalName("SensorServer");</pre>
<p>Add a list of services we are interested it:</p>
<pre>QList&lt;QBluetoothUuid&gt; servicesList <br/>&lt;&lt; <span>QBluetoothUuid::EnvironmentalSensing;<br/></span><span>leAdd-&gt;setServices(servicesList);</span></pre>
<p> </p>
<div class="packt_infobox"><span>The source code can be found on the Git repository under the </span><kbd>Chapter06-1</kbd><span> directory, in the</span><span> <kbd>cp6</kbd> </span><span>branch.</span></div>
<p>We need to create some characteristic data now. Let's create a <kbd>Characteristic</kbd> that handles temperature, so we set its <kbd>uuid</kbd> to <kbd>TemperatureMearurement</kbd>. We need to also let it be configurable for notifications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QLowEnergyCharacteristicData</h1>
                </header>
            
            <article>
                
<p><kbd>QLowEnergyCharacteristicData</kbd> represents a <strong>Generic Attribute Profile</strong> (<strong>GATT</strong>) characteristic, which defines a single data point in the Bluetooth transfer. You use it to set up service data:</p>
<pre>QLowEnergyCharacteristicData chData;<br/>chData.setUuid(<span>QBluetoothUuid::TemperatureMeasurement</span>);<br/>chData.setValue(QByteArray(2,0));<br/>chData.setProperties(<span class="type"><span class="typ">QLowEnergyCharacteristic</span></span><span class="operator"><span class="pun">::</span></span><span class="typ">Notify</span>);<br/>const<span> </span>QLowEnergyDescriptorData<span> </span>descriptorData(QBluetoothUuid::ClientCharacteristicConfiguration,<span> </span>QByteArray(2,<span> </span>0));<br/>chData.addDescriptor(descriptorData);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QLowEnergyServiceData</h1>
                </header>
            
            <article>
                
<p>Here, we set up the <kbd>Temperature</kbd> service data as a <kbd>Primary</kbd> service, and add <kbd>Characteristic</kbd> to <kbd>service</kbd>:</p>
<pre>QLowEnergyServiceData serviceData;<br/>serviceData.setUuid(<span>QBluetoothUuid::Temperature</span>);<br/>serviceData.setType(QLowEnergyServiceData::ServiceTypePrimary);<br/>serviceData.addCharacteristic(chData);</pre>
<p>Now, let's supply the temperature data. We construct <kbd>QLowEnergyCharacteristic</kbd> with the <span><kbd>TemperatureMeasurement</kbd> type, </span>and supply to it some data. The first bit specifies that we are supplying the <kbd>temperature</kbd> unit in Celsius:</p>
<pre>QLowEnergyCharacteristic characteristic = service-&gt;characteristic(QLowEnergyCharacteristic::TemperatureMeasurement);<br/><span>quint8 </span>temperature = 35;<br/><br/><span>QByteArray</span><span> currentTemp</span><span>Value</span>;<br/><span>value</span>.<span>append</span>(<span>char</span>(<span>0</span>));<span><br/></span><span>value</span>.<span>append</span>(<span>char</span>(<span>temperature</span>));<br/>service-&gt;writeCharacteristic(<span>characteristic, </span><span>currentTemp</span><span>Value</span>);</pre>
<p>We are all set up now, and all we need is to start <kbd>Advertising</kbd> to listen for connections:</p>
<pre>controller-&gt;startAdvertising(<span>QLowEnergyAdvertisingParameters</span>(),<span> </span>leAdd,<span> </span>leAdd);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Discovery and Pair-ity – search and connect for BLE devices</h1>
                </header>
            
            <article>
                
<p>The first thing you need to do is search for devices, which is called discovery. It entails putting the Bluetooth device into search, or discovery mode. You then receive a list of devices address with which you can connect or pair to be able to access and share data.</p>
<p>Let's look at how that is done in Qt using <kbd>QBluetoothDeviceDiscoveryAgent</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QBluetoothDeviceDiscoveryAgent</h1>
                </header>
            
            <article>
                
<p><span>The </span><span><kbd>QBluetoothDeviceDiscoveryAgent</kbd> class is responsible for the device discovery search. It will emit the </span><kbd>deviceDiscovered</kbd><span> signal when any Bluetooth is found:</span></p>
<pre>QBluetoothDeviceDiscoveryAgent<span> </span>*discoveryAgent<span> </span>=<span> </span>new<span> </span>QBluetoothDeviceDiscoveryAgent(this);<span> </span>connect(discoveryAgent,<span> </span>SIGNAL(deviceDiscovered(QBluetoothDeviceInfo)),<br/><span>          </span>this,<span> </span>SLOT(newDevice(QBluetoothDeviceInfo)));<br/><span>discoveryAgent-&gt;start(</span>QBluetoothDeviceDiscoveryAgent::LowEnergyMethod)<span>);</span></pre>
<div class="packt_infobox"><span>The source code can be found on the Git repository under the </span><kbd>Chapter06-1a</kbd><span> directory, in the</span><span> <kbd>cp6</kbd></span><span> </span><span>branch.</span></div>
<p>The call to <kbd>start()</kbd> will initiate the discovery process. The <kbd>QBluetoothDeviceDiscoveryAgent::LowEnergyMethod</kbd> argument <span>will set a filter to only discover <kbd>LowEnergy</kbd> devices. Once you find the device you want, you can call</span> <kbd>stop()</kbd> <span>to stop the device search.</span></p>
<p>You can wait for errors by connecting to the error (<kbd>QBluetoothDeviceDiscoveryAgent::Error error</kbd>) signal.</p>
<p><span>The </span><kbd>error</kbd><span> signal in the </span><span><kbd>QBluetoothDeviceDiscoveryAgent</kbd> class is overloaded, so special care needs to happen in order to connect to the signal. Qt provides <kbd>QOverload</kbd></span> and can be implemented like this:</p>
<div>
<pre><span>connect</span><span>(discoveryAgent, QOverload</span><span>&lt;</span><span>QBluetoothDeviceDiscoveryAgent::Error</span><span>&gt;</span><span>::of</span><span>(</span><span>&amp;</span><span>QBluetoothDeviceDiscoveryAgent::error), </span><span>this</span><span>, </span><span>&amp;</span><span>SomeClass::deviceDiscoveryError);</span></pre></div>
<p>If you would rather get a list of devices all at one time, connect to the <kbd>Finished</kbd> signal and use the <kbd>discoveryDevices()</kbd> call, which returns <kbd>QList &lt;QBluetoothDeviceInfo&gt;</kbd><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fa9c6ddf-5c99-47b2-a1af-e024d5852294.png" style="width:24.58em;height:16.67em;"/></p>
<p>You might want to check for the remote devices pairing status, so call <kbd>pairingStatus</kbd> of <kbd>QLocalBluetoothDevice</kbd>.</p>
<p>You can pair with a device by then calling the <kbd>requestPairing</kbd> function of <kbd>QBluetoothLocalDevice</kbd>, with <kbd>QBluetoothAddress</kbd> of the remote Bluetooth device:</p>
<pre>SomeClass::newDevice(const QBluetoothDeviceInfo &amp;info)<br/>{<br/>    QBluetoothLocalDevice::Pairing pairingStatus = localDevice-&gt;pairingStatus(info.address()); <br/>    if (pairingStatus == QBluetoothLocalDevice::Unpaired) {<br/>        QMessageBox msgBox; <br/>        msgBox.setText("Bluetooth Pairing."); <br/>        msgBox.setInformativeText("Do you want to pair with device: " + item-&gt;data(Qt::UserRole).toString()); <br/>        msgBox.setStandardButtons(QMessageBox::Ok | QMessageBox::Cancel); <br/>        msgBox.setDefaultButton(QMessageBox::Cancel); <br/>        int ret = msgBox.exec(); <br/><span>        if (ret == QMessageBox::Ok) { <br/>            qDebug() &lt;&lt; Q_FUNC_INFO &lt;&lt; "Pairing..."; <br/>            localDevice-&gt;requestPairing(address, QBluetoothLocalDevice::Paired); <br/>     } <br/></span><br/>    }<br/>}</pre>
<p class="mce-root"/>
<p>Our example app asks to pair the device before we execute the <kbd>requestPairing</kbd> procedure:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/02444217-bc7a-4b09-84bd-a389e3f211f8.png"/></p>
<p>You can then call <kbd>requestPairing</kbd> on <kbd>QBluetoothLocalDevice</kbd> with the <kbd>QBluetoothAddress</kbd> of the device you wish to pair with. Let's take a look at <kbd>QBluetoothLocalDevice</kbd></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"> QBluetoothLocalDevice</h1>
                </header>
            
            <article>
                
<p><kbd>QBluetoothLocalDevice</kbd> represents the Bluetooth on your device. You use this class to initiate pairing to another device, but also to handle pairing requests from remote Bluetooth devices. It has a few signals to help with that:</p>
<ul>
<li><kbd>pairingDisplayConfirmation</kbd>:<span class="packt_screen"> </span>This is a signal the remote device requests to show user a PIN and ask whether it is the same on both devices. You must call <kbd>pairingConfirmation</kbd> with <kbd>true</kbd> or <kbd>false</kbd> on <kbd>QBluetoothLocalDevice</kbd>.</li>
<li><kbd>pairingDisplayPinCode</kbd>:<span class="packt_screen"> </span><span>This is a request to enter a PIB.</span></li>
<li><kbd>pairingFinished</kbd>:<span class="packt_screen"> </span><span>Pairing is completed successfully.</span></li>
</ul>
<p class="mce-root"/>
<p>We then connect to these signals, if the user allows it when they click on the <span class="packt_screen">OK</span> button:</p>
<pre>        if (ret == QMessageBox::Ok) { <br/><br/>            connect(localDevice, &amp;QBluetoothLocalDevice::pairingDisplayPinCode, this, &amp;MainWindow::displayPin);     <br/>            connect(localDevice, &amp;QBluetoothLocalDevice::pairingDisplayConfirmation, this, &amp;MainWindow::displayConfirmation);     <br/>            connect(localDevice, &amp;QBluetoothLocalDevice::pairingFinished, this, &amp;MainWindow::pairingFinished);     <br/>            connect(localDevice, &amp;QBluetoothLocalDevice::error, this, &amp;MainWindow::pairingError);<br/>            <br/>            localDevice-&gt;requestPairing(address, QBluetoothLocalDevice::Paired); <br/>        }</pre>
<p>When the remote device only needs a PIN confirmation, the <kbd>pairingDisplayConfirmation</kbd> signal is called:</p>
<pre>SomeClass::displayConfirmation(const QBluetoothAddress &amp;address, const QString &amp;pin)<br/>{<br/>    QMessageBox msgBox; <br/>    msgBox.setText("Confirm pin"); <br/>    msgBox.setInformativeText("<span>Confirm the pin is the same as on the device.</span>");<br/>    msgBox.setStandardButtons(QMessageBox::Ok | QMessageBox::Cancel);<br/>    msgBox.setDefaultButton(QMessageBox::Cancel);<br/>    int ret = msgBox.exec(); <br/>    if (ret == QMessageBox::Ok) {<br/>        localDevice-&gt;pairingConfirmed(true);<br/>     } else {<br/>        localDevice-&gt;pairingConfirmed(false);<br/>    }<br/>}</pre>
<p>When the remote device needs user to enter a PIN, the <kbd>pairingDisplayPinCode</kbd> signal is called with a PIN to be displayed and entered on the remote device:</p>
<pre>SomeClass::displayPin(const QBluetoothAddress &amp;address, const QString &amp;pin) {<br/>{<br/>    QMessageBox msgBox; <br/>    msgBox.setText(pin);<br/>    msgBox.setInformativeText("Enter pin on remote device"); <br/>    msgBox.setStandardButtons(QMessageBox::Ok); <br/>    msgBox.exec(); <br/>}</pre>
<p>On the other side, to receive pairing, you need to put <kbd>QBluetoothLocalDevice</kbd> into the <kbd>Discoverable</kbd> mode:</p>
<pre>   localDevice-&gt;setHostMode(QBluetoothLocalDevice::HostDiscoverable);</pre>
<p>The device can then be seen by other devices that are in the Bluetooth <kbd>Discovery</kbd> mode.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying and getting client data</h1>
                </header>
            
            <article>
                
<p>Once you have connected to a BLE device peripheral, you need to discover its characteristics to be able to read and write them. You do that by using <kbd>QLowEnergyController</kbd>. Let's take a look at what <kbd>QLowEnergyController</kbd> is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QLowEnergyController</h1>
                </header>
            
            <article>
                
<p><kbd>QLowEnergyController</kbd> is the central place to access BLE devices both local and remote.</p>
<p>The local <kbd>QLowEnergyController</kbd> can be created by using the static <kbd>QLowEnergyController::createPeripheral(QObject *parent)</kbd> function.</p>
<p>Creating a <kbd>QLowEnergyController</kbd> object that represents the remote device is done b<span>y calling the static class <kbd>QLowEnergyController::createCentral</kbd> using the <kbd>QBluetoothDeviceInfo</kbd> </span>object that you receive when you discover remote devices.</p>
<p>The <kbd>QLowEnergyController</kbd> object has several signals:</p>
<div>
<ul>
<li><kbd><span>discoveryFinished</span></kbd></li>
<li>
<div><kbd><span>serviceDiscovered</span></kbd></div>
</li>
<li>
<div><kbd><span>connected</span></kbd></div>
</li>
<li>
<div><kbd><span>disconnected</span></kbd></div>
</li>
</ul>
</div>
<p>Connect to the<span> </span><kbd>connected</kbd><span> </span>signal and start connecting by calling <kbd>connectToDevice()</kbd><span>:</span></p>
<pre>SomeClass::newDevice(const QBluetoothDeviceInfo &amp;device) <br/>{<br/>    QLowEnergyController *controller = new QLowEnergyController(device.address());<br/>    connect(controller, &amp;QLowEnergyController::connected, this, &amp;SomeClass::controllerConnected);<br/><br/>    controller-&gt;connectToDevice();<br/>}<br/><br/>SomeClass::controllerConnected()<br/>{<br/>    QLowEnergyController *controller = qobject_cast&lt;QLowEnergyController *&gt;(sender());<br/>    if (controller) {<br/>        connect(controller, &amp;QLowEnergyController::serviceDiscovered, this, &amp;SomeClass::newServiceFound);<br/>        controller-&gt;discoverServices();<br/>}</pre>
<p><span>Once the device is connected, it's time to discover its services, so we connect to the </span><kbd>serviceDiscovered</kbd><span> signal and initiate the</span> service <span>discovery by calling </span><kbd>discoverServices()</kbd><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QLowEnergyService</h1>
                </header>
            
            <article>
                
<p><span>You can also connect to the</span> <kbd>discoveryFinished()</kbd> <span>signal, which returns a list of discovered services by calling</span> <kbd>services()</kbd><span>. With either of these, you will get the</span> <kbd>QBluetoothUuid</kbd> <span>that belongs to that service, with which you can then create a</span> <kbd>QLowEnergyService</kbd> <span>object:</span></p>
<pre><span>SomeClass::</span><span>newServiceFound</span><span>(</span><span>const</span><span> QBluetoothUuid </span><span>&amp;</span><span>gatt)<br/>{<br/></span>    QLowEnergyController *controller = qobject_cast&lt;QLowEnergyController *&gt;(sender());<br/>    QLowEnergyService *myLEService = controller-&gt;createServiceObject(gatt, this);<br/>}</pre>
<p>We now have a <kbd>QLowEnergyService</kbd> object, which gives us details about it. We can only read its service details when its state becomes <kbd>ServiceDiscovered</kbd>, so now call the <kbd>discoverDetails()</kbd> function of the service to start the discovery process:</p>
<pre>   QLowEnergyService *myLEService = controller-&gt;createServiceObject(gatt, this);<br/>    connect(myLEService, &amp;QLowEnergyService::stateChanged, this, &amp;SomeClass::serviceStateChanged);<br/>    myLEService-&gt;discoverDetails();</pre>
<p>Let's have a look at <kbd>QLowEnergyCharacteristic</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QLowEnergyCharacteristic</h1>
                </header>
            
            <article>
                
<p>Once the service details or <kbd>characteristics</kbd> are discovered, we can perform actions with <kbd>QLowEnergyCharacteristic</kbd>, such as enabling notifications:</p>
<pre>void SomeClass::serviceStateChanged(QLowEnergyService::ServiceState state))<br/>{<br/>    if (state != QLowEnergyService::ServiceDiscovered)<br/>        return;<br/>    QLowEnergyService <span>*</span><span>myLEService </span><span>=</span><span> qobject_cast</span><span>&lt;</span><span>QLowEnergyService </span><span>*&gt;</span><span>(</span><span>sender</span><span>());<br/></span>    QList &lt;QLowEnergyCharacteristic&gt; characteristics = myLEService-&gt;characteristics();<br/><br/>}</pre>
<div>
<p>Using <kbd>QLowEnergyCharacteristic</kbd>, we can get a <kbd>QLowEnergyDescriptor</kbd><span> </span>that we use to enable or disable notifications.</p>
<p>Sometimes, a <kbd>characteristic</kbd> on the remote device needs to be written to as well, such as enabling a specific sensor. In this case, you need to use the <kbd>writeCharacteristic</kbd> function of the service with <kbd>characteristic</kbd> as the first argument and the value to be written as the second:</p>
<pre>QLowEnergyCharacteristic *movementCharacteristic = myLEService-&gt;characteristic(someUuid);<br/>myLEService-&gt;writeCharacteristic(movementCharacteristic, <span>QLowEnergyCharacteristic::Read</span>);</pre></div>
<p>Writing to <kbd>QLowEnergyDescriptor</kbd> is just as easy; let's take a look.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QLowEnergyDescriptor</h1>
                </header>
            
            <article>
                
<p>From the Bluetooth specifications, a descriptor is <span>defined as attributes that describe a characteristic value. It contains additional information about a characteristic.</span> <kbd>QLowEnergyDescriptor</kbd> <span>encapsulates a GATT descriptor. Descriptors and characteristics can have notifications when changes happen.</span></p>
<p>To enable notifications, we might need to write a value to the descriptor. Here are some possible values:</p>
<table style="border-collapse: collapse;width: 98.4869%" border="1">
<tbody>
<tr>
<td style="width: 15%" class="CDPAlignCenter CDPAlign"><strong>GATT term</strong></td>
<td style="width: 23%" class="CDPAlignCenter CDPAlign"><strong>Description</strong></td>
<td style="width: 13%" class="CDPAlignCenter CDPAlign"><strong>Value</strong></td>
<td style="width: 30.1074%" class="CDPAlignCenter CDPAlign"><strong>Qt constant</strong></td>
</tr>
<tr>
<td style="width: 15%">Broadcast</td>
<td style="width: 23%">Permits<span> broadcast</span></td>
<td style="width: 13%"><kbd>0x01</kbd><span> </span></td>
<td style="width: 30.1074%"><kbd><span>QLowEnergyCharacteristic::Broadcasting</span></kbd></td>
</tr>
<tr>
<td style="width: 15%"><span>Read</span></td>
<td style="width: 23%"><span>Permits reading </span></td>
<td style="width: 13%"><kbd><span>0x02</span></kbd><span> </span></td>
<td style="width: 30.1074%"><kbd><span>QLowEnergyCharacteristic::Read</span></kbd></td>
</tr>
<tr>
<td style="width: 15%"><span>Write without response</span></td>
<td style="width: 23%"><span>Permits writing with any response </span></td>
<td style="width: 13%"><kbd><span>0x04</span></kbd></td>
<td style="width: 30.1074%"><kbd><span>QLowEnergyCharacteristic::WriteNoResponse</span></kbd></td>
</tr>
<tr>
<td style="width: 15%"><span>Write</span></td>
<td style="width: 23%"><span>Permits writing with a response </span></td>
<td style="width: 13%"><kbd><span>0x08</span></kbd></td>
<td style="width: 30.1074%"><kbd><span>QLowEnergyCharacteristic::Write</span></kbd></td>
</tr>
<tr>
<td style="width: 15%"><span>Notify</span></td>
<td style="width: 23%"><span>Permits notifications </span></td>
<td style="width: 13%"><kbd><span>0x10</span></kbd></td>
<td style="width: 30.1074%"><kbd><span>QLowEnergyCharacteristic::Notify</span></kbd></td>
</tr>
<tr>
<td style="width: 15%"><span>Indicate</span></td>
<td style="width: 23%"><span>Permits notification with client confirmation required</span></td>
<td style="width: 13%"><kbd><span>0x20</span></kbd></td>
<td style="width: 30.1074%"><kbd><span>QLowEnergyCharacteristic::Indicate</span></kbd></td>
</tr>
<tr>
<td style="width: 15%"><span>Authenticated signed writes</span></td>
<td style="width: 23%"><span>Permits signed writes </span></td>
<td style="width: 13%"><kbd><span>0x40</span></kbd></td>
<td style="width: 30.1074%"><kbd><span>QLowEnergyCharacteristic::</span><span>WriteSigned</span></kbd></td>
</tr>
<tr>
<td style="width: 15%"><span>Extended properties</span></td>
<td style="width: 23%"><span>Queued writes and writable auxiliaries </span></td>
<td style="width: 13%"><kbd><span>0x80</span></kbd></td>
<td style="width: 30.1074%"><kbd><span>QLowEnergyCharacteristic::</span><span>ExtendedProperty</span></kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p>The difference between notifications and indications is that, with indications, the server requires the client to confirm that it has received the message, whereas with a notification, the server doesn't care whether the client receives it.</p>
<div class="packt_infobox">Qt does not currently have support to use a<span>uthenticated signed writes (<kbd>0x40</kbd>)</span> with Qt, nor does it have support to use indications (<kbd>0x20</kbd>).</div>
<p>We want to be notified when the characteristic values change. To enable this, we need to write a value of <kbd>0x10</kbd> or <span><kbd>QLowEnergyCharacteristic::Notify</kbd></span><span> </span>to <kbd>descriptor</kbd>:</p>
<pre>for ( const QLowEnergyCharacteristic character :  characteristics) {<br/>    QLowEnergyDescriptor descriptor = character.descriptor(<span class="type"><span class="typ">QBluetoothUuid</span></span><span class="operator"><span class="pun">::</span></span><span class="typ">ClientCharacteristicConfiguration);<br/></span><span>    connect</span><span>(myLEService, </span><span>&amp;</span><span>QLowEnergyService::characteristicChanged, </span><span>this</span><span>, </span><span>&amp;</span><span>SomeClass::characteristicUpdated);<br/></span>    myLEService-&gt;writeDescriptor(descriptor, <span>QByteArrayLiteral</span><span>(</span><span>"</span><span>\x01\x00</span><span>"</span><span>)</span><span>);<br/></span>}</pre>
<p>Or we can use the predefined <kbd>QLowEnergyCharacteristic::Notify</kbd>, <span>like so:</span></p>
<pre>myLEService-&gt;writeDescriptor(descriptor, <span>QLowEnergyCharacteristic::Notify</span><span>));</span></pre>
<p>Now, we can finally get values out of our Bluetooth LE device:</p>
<pre>void SomeClass::characteristicUpdated(const QLowEnergyCharacteristic &amp;ch, const QByteArray &amp;value)<br/>{<br/>    qWarning() &lt;&lt; ch.name() &lt;&lt; "value changed!" &lt;&lt; value;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bluetooth QML</h1>
                </header>
            
            <article>
                
<p>There are Bluetooth QML components you can use as a client to scan and connect to Bluetooth devices as well. They are simple but functional.</p>
<div class="packt_infobox"><span>The source code can be found on the Git repository under the </span><kbd>Chapter06-2</kbd><span> directory, in the</span><span> <kbd>cp6</kbd> </span><span>branch.</span></div>
<ol>
<li>Add the <kbd>bluetooth</kbd> module to your <kbd>pro</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">QT += bluetooth</pre>
<ol start="2">
<li>In your <kbd>qml</kbd> file, use the <kbd>QtBluetooth</kbd> import:</li>
</ol>
<pre style="padding-left: 60px">import QtBluetooth 5.12</pre>
<p>The most important element is <kbd>BluetoothDiscoveryModel</kbd>. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">BluetoothDiscoveryModel</h1>
                </header>
            
            <article>
                
<p><kbd>BluetoothDiscoveryModel</kbd> provides a data model of available Bluetooth devices nearby. You can use it in various model-based Qt Quick components, such as <kbd>GridView</kbd>, <kbd>ListView</kbd>, and <kbd>PathView</kbd>. Setting the <kbd>discoveryMode</kbd> property tells the local Bluetooth device the level of service discovery, which is one of the following:</p>
<ul>
<li><kbd>FullServiceDiscovery</kbd>: Discovers all services of all devices</li>
<li><kbd>MinimalServiceDiscovery</kbd>: Minimal discovery only includes device and UUID information</li>
<li><kbd>DeviceDiscovery</kbd>: Discovers only devices and no services</li>
</ul>
<p>The discovery process will take various amounts of time according to the number of services that need to be discovered. To speed up the discovery of a specific device, you can set the <kbd>discoveryMode</kbd> property to <kbd>BluetoothDiscoveryModel.DeviceDiscovery</kbd>, which will allow you to discover the target device address. In the following example, I have commented out the device's target Bluetooth address so it will at least show some devices when you run it:</p>
<pre>BluetoothDiscoveryModel {<br/>    id: discoveryModel<br/>    discoveryMode: BluetoothDiscoveryModel.DeviceDiscovery<br/>    onDeviceDiscovered: {<br/>        if (/*device == "01:01:01:01:01:01" &amp;&amp; */ <span>discoveryMode == BluetoothDiscoveryModel.DeviceDiscovery</span>) {<br/>            discoveryModel.running = false<br/>            discoveryModel.discoveryMode = BluetoothDiscoveryModel.FullServiceDiscovery<br/>            discoveryModel.remoteAddress = device<br/>            discoveryModel.running = true     <br/>        }<br/>    }   <br/>}</pre>
<p>To discover all services of all nearby devices, set <kbd>discoveryMode</kbd> to <kbd>BluetoothDiscoveryModel.FullServiceDiscovery</kbd>. If you set the <kbd>remoteAddress</kbd><span> property </span>with a device address, you can target that one specific device. You will then have to toggle the<span> </span><kbd>running</kbd><span> </span>property off and then on to start a new scan.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We have a basic data model, but we need somewhere to display it. Qt Quick has a few options for viewing model data:</p>
<ul>
<li><kbd>GridView</kbd></li>
<li><kbd>ListView</kbd></li>
<li><kbd>PathView</kbd></li>
</ul>
<div class="packt_tip"><kbd>PathView</kbd> is best written with Qt Creator QML designer, as you can visually adjust its path.</div>
<p>Let's choose a <kbd>ListView</kbd> for simplicity although I really wanted to use <kbd>PathView</kbd>:</p>
<pre>ListView {<br/>    id: mainList<br/>    anchors.top: busy.bottom<br/>    anchors.fill: parent<br/>    model: discoveryModel   <br/>}</pre>
<p>It's not going to show anything without defining <kbd>delegate</kbd>:</p>
<pre>delegate: Rectangle {<br/>    id: btDelegate<br/>    width: parent.width<br/>    height: column.height + 10<br/>    focus: true<br/>    Column {<br/>        id: column<br/>        anchors.horizontalCenter: parent.horizontalCenter<br/>        Text {<br/>            id: btText<br/>            text: deviceName ? deviceName : name<br/>            font.pointSize: 14<br/>        }<br/>    }<br/>}</pre>
<p>Scanning for devices can take a while to complete sometimes, so I want to add a busy indicator. Qt Quick Control 2 has <kbd>BusyIndicator</kbd>:</p>
<pre>BusyIndicator {<br/>    id: busy<br/>    width: mainWindow.width *.6<br/>    anchors.horizontalCenter: parent.horizontalCenter<br/>    anchors.top: mainWindow.top<br/>    height: mainWindow.height / 8<br/>    running: discoveryModel.running<br/>}</pre>
<p>When you discover remote services, you will get a <kbd>BluetoothService</kbd> object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">BluetoothService</h1>
                </header>
            
            <article>
                
<p>When you specify <kbd>BluetoothDiscoveryModel.FullServiceDiscovery</kbd> for a discovery scan and when <kbd>BluetoothDiscoveryModel</kbd> locates a new service, the <kbd>serviceDiscovered</kbd> <span>signal will be emitted. When we connect to that signal, we will receive the</span> <kbd>BluetoothService</kbd> <span>object in the slot.</span></p>
<p>We can the get the <strong>universal unique identifier</strong> (<strong>uuid</strong>), device and service name, service description, and other details. You can use this <kbd>BluetoothService</kbd> to connect to <kbd>BluetoothSocket</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">BluetoothSocket</h1>
                </header>
            
            <article>
                
<p>The <kbd>BluetoothSocket</kbd> component can be used to send and receive <kbd>String</kbd> messages.</p>
<p>To implement this component, at it's simplest would be the following:</p>
<div>
<pre><br/>BluetoothSocket {<br/>    id: btSocket<br/>}</pre></div>
<div class="packt_infobox"><kbd>BluetoothSocket</kbd> does not handle binary data. For that, you will have to use the C++ <kbd>QBluetoothSocket</kbd> class.</div>
<p>In <kbd>BluetoothDiscoveryModel</kbd><span>, handle the</span> <kbd>serviceDiscovered</kbd> <span>signal. You will get a</span> <kbd>BluetoothService</kbd> <span>object named</span> <kbd>service</kbd><span>. You can then set <kbd>Socket</kbd> to use the</span> service <span>with the</span> <kbd>setService</kbd> <span>method:</span></p>
<pre><br/>onServiceDiscovered {<br/>    if (service.serviceName == "Magical Service")<br/>       btSocket.setService(service)<br/><br/>}</pre>
<p>First, you might want to handle the <kbd>stateChanged</kbd> signals:</p>
<pre>onSocketStateChanged: {<br/> switch (socketState) {<br/> case BluetoothSocket.Unconnected:<br/> case BluetoothSocket.NoServiceSet:<br/> break;<br/> case BluetoothSocket.Connected:<br/> console.log("Connected");<br/> break;<br/> case BluetoothSocket.Connecting:<br/> console.log("Connecting...");<br/> break;<br/> case BluetoothSocket.ServiceLookup:<br/> console.log("Looking up Service");<br/> break;<br/> case BluetoothSocket.Closing:<br/> console.log("Closing connection");<br/> break;<br/> case BluetoothSocket.Listening:<br/> console.log("Listening for incoming connections");<br/> break;<br/> case BluetoothSocket.Bound:<br/> console.log("Bound to local address")<br/> break;<br/> }<br/> }</pre>
<p>To connect to the service, write <kbd>true</kbd> to the <kbd>connected</kbd> property<span>:</span></p>
<pre>btSocket.connected = true</pre>
<p>Once the <kbd>socketState</kbd> property is <kbd>Connected</kbd>, you can transmit a message or string data using the <kbd>stringData</kbd> property:</p>
<pre>btSocket.stringData = "Message Ok"</pre>
<p>Qt Quick offers a simple way to send string messages over Bluetooth.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Bluetooth Low Energy is meant to have lower energy requirements for mobile and embedded devices. Qt offers both C++ and QML classes and components to use it. You should now be able to discover and connect to a Bluetooth Low Energy device. </p>
<p>Advertising GATT services so users and clients can receive and send data was also covered.</p>
<p>In the next chapter, we will go over some of the main components for the <strong>Internet of Things</strong> (<strong><span>IoT</span></strong>), such as sensors and automation communication protocols.</p>


            </article>

            
        </section>
    </body></html>