- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Open Asset Import Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to *Mastering C++ Game Animations*! Are you the kind of person who
    looks at the animated models in a computer or console game, or a 3D animation
    tool, and asks yourself questions like:'
  prefs: []
  type: TYPE_NORMAL
- en: How does this work? How do they do this? Could I do this myself, too?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If so, this book will take you in the right direction to achieving this. In
    the next 14 chapters, you will learn how to create your own little game character
    model viewer.
  prefs: []
  type: TYPE_NORMAL
- en: The book starts with loading a file using Open Asset Import Library, converting
    the data structures from the importer library into more efficient data structures
    for rendering, and rendering the character model with a simple OpenGL or Vulkan
    renderer. You will also learn how to optimize data updates and rendering by relocating
    computational load to the GPU in the form of GPU-based lookup tables and compute
    shaders.
  prefs: []
  type: TYPE_NORMAL
- en: For the character animations, you will not only dive into normal animation blending
    but also be introduced to state-based animation control, additive animation blending
    to move the head independently of the rest of the body, and facial animations.
    You will also learn how to control the behavior of the instances by using a simplified
    version of behavior trees and implement interaction between the instances on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: To give a proper home to the game characters, you will learn how to load a game
    map into the application. Moving around in the game map will be enhanced by adding
    collision detection, inverse kinematics for the character feet, and simple navigation
    to let the instances run around fully on their own in the virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the animations, features such as interactive selection by using
    the mouse, saving and loading the configuration to a file to allow working on
    larger virtual worlds, and handling different cameras in the virtual world are
    introduced. Also, a graphical, node-based configuration will be implemented, enabling
    you to change the behavior of the instances in a non-programming way.
  prefs: []
  type: TYPE_NORMAL
- en: With all these steps combined, your virtual characters in the virtual world
    will come closer to real game characters.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_code_Discord.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation).'
  prefs: []
  type: TYPE_NORMAL
- en: Every journey starts with the first step, so welcome to *Chapter 1*! This chapter
    will set the foundation for the animation application, as you will get an insight
    into how to load a model file from your computer into the program, position the
    instance in the vast emptiness of the virtual world, and play the animations that
    are included in the file. By the end of this chapter, your game character model
    will be able to jump, run, or walk on the screen, maybe surrounded by non-animated
    models or other static objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Animating game characters – a primer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Open Asset Import Library?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading a model file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the UI with an Open File dialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and removing model instances dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we will use open source software and platform-independent libraries in this
    book, you should be able to compile and run the code “out of the box” on Windows
    and Linux. You will find a detailed list of the required software and libraries,
    plus their installation, in the following *Technical requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A PC with Windows or Linux, and the tools listed later in this section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git for source-code management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text editor (such as Notepad++ or Kate) or a full IDE (such as Visual Studio
    2022 for Windows, or Eclipse/KDevelop for Linux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A recent C++ compiler is required to compile the code. In the current CMake
    build system, C++17 is configured, but the code is known to work with newer C++
    standards, up to and including C++26 (although the compiler must support those
    standards).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s get the source code for this book and start unpacking the code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the source code and the basic tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code for this book is hosted on GitHub, which you can find here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming](https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming)'
  prefs: []
  type: TYPE_NORMAL
- en: You need to install Git since the build system utilizes Git to download the
    third-party projects used in the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux systems, use your package manager. For Ubuntu, the following line
    installs Git:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, you can download Git here: [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  prefs: []
  type: TYPE_NORMAL
- en: To unpack the code, you can use any of the following two methods.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the code using Git
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get the code in the book, you should use Git. Using Git offers you additional
    features, such as creating a local branch for your changes, keeping track of your
    progress, and comparing your updates to the example code. Also, you can easily
    revert changes if you have broken the code during the exploration of the source
    code, or while working on the practical sessions at the end of each chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get a local checkout of the code in a specific location on your system
    either through the Git GUI, by cloning the repository in Visual Studio 2022, or
    by executing the following command in a CMD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Please make sure that you use a path without spaces or special characters such
    as umlauts as this might confuse some compilers and development environments.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the code as a ZIP file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although Git is recommended, you can also download the code as a ZIP file from
    GitHub. You will need to unpack the ZIP file to a location of your choice on your
    system. Also, make sure that the path the ZIP file is unpacked to contains no
    spaces or special characters.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can use the code from the book, some tools and libraries must be installed.
    We will start with the Windows installation, followed by the Linux installation.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required tools and libraries for Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To compile the example code on a Windows machine, I recommend using Visual Studio
    2022 as the IDE since it contains all you need for a quick start. Using other
    IDEs like Eclipse, Rider, or KDevelop is no problem as the build is managed by
    CMake, but you may need to install a C++ compiler like MSYS2 plus the compiler
    packages as an additional dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Studio 2022 on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to use Visual Studio for the example files and don’t have it installed
    yet, download the free Community Edition of Visual Studio at [https://visualstudio.microsoft.com/de/downloads/](https://visualstudio.microsoft.com/de/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose the **Desktop development with C++** option so that the C++ compiler
    and the other required tools are installed on your machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B22428_01_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Installing the C++ desktop development in Visual Studio 2022'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, under **Individual components**, also check the **C++ CMake tools for
    Windows** option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B22428_01_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Check the box for CMake tools for Windows to be installed in Visual
    Studio 2022'
  prefs: []
  type: TYPE_NORMAL
- en: Finish the installation of Visual Studio, start it, and skip the initial project
    selection screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enabling long path names on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using a fresh installation of Windows 10 or 11, the maximum path length
    for files is 260 characters. Depending on the location of the folder containing
    the code for the book, Visual Studio 2022 might run into errors caused by paths
    for temporary build folders exceeding the 260 characters limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable long path names, the **Windows Registry** needs to be adjusted. A
    simple way is to create a text file with the `.reg` extension, for instance, `long-paths.reg`,
    and copy the following content to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A double-click on the file will automatically start the **Windows Registry Editor**
    to import the settings to the Windows Registry. After confirming both the **UAC**
    dialog and the following warning dialogs by clicking **Yes**, the Registry Editor
    will import the new settings.
  prefs: []
  type: TYPE_NORMAL
- en: Now, reboot the PC to activate the long path names and continue with the installations.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Open Asset Import Library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For Windows, Open Asset Import Library must be built and installed from the
    source files. Clone the repository from [https://github.com/assimp/assimp](https://github.com/assimp/assimp)
    in a new Visual Studio 2022 project, as shown in *Figure 1.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_01_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Cloning the asset importer GitHub repository within Visual Studio
    2022'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative, you can create a clone from a Git Bash, or via the Git GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to make a few adjustments to create a static library instead of a dynamic
    library. Using a static library makes the build process easier for us, as we don’t
    have to worry about an additional DLL file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the CMake settings, choose the following option after right-clicking
    on the `CMakeLists.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_01_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Changing the CMake settings for the asset importer'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Configuration** tab of Visual Studio 2022 that appears, change the
    configuration name to `x64-RelWithDebInfo`, and change the configuration type
    to `RelWithDebInfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_01_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Modifying the current configuration of the asset importer'
  prefs: []
  type: TYPE_NORMAL
- en: By using `RelWithDebInfo`, a release version with debug information will be
    created. The resulting executable will be optimized by the compiler, but the file
    still contains data to allow debugging the program in case of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, change the following settings in the CMake settings. You can use the
    search field on the bottom left, named **Filter variables...**, to search for
    the specified setting:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Disable building a shared library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B22428_01_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Switching the setting to create a static library'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the linking of the C runtime:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B22428_01_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: Linking the C runtime statically'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the library suffix to create a file name without the compiler version:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B22428_01_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: Removing the suffix of the created file'
  prefs: []
  type: TYPE_NORMAL
- en: Next, select **Build** and then **Install** in the context menu of the `CMakeLists.txt`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation is finished, the following folder structure will be
    generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_01_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.9: Asset importer library and includes'
  prefs: []
  type: TYPE_NORMAL
- en: We have to make all the files discussed in this section available for all examples
    in the book. To do this, two options are available – copy the files to a fixed
    path or add an environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Copying the Assimp files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, create this folder on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, copy the two folders `lib` and `include` into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_01_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.10: The two folders have been copied to the Program Files folder'
  prefs: []
  type: TYPE_NORMAL
- en: The CMake search script for Assimp will try to find the static library and the
    header files in this folder.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an environment variable to help CMake find the files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an alternative solution, you can create a folder on your PC wherever you
    want, for instance, to `D:\assimp`. Then, copy the folders `lib` and `include`
    into the folder and set the environment variable **ASSIMP_ROOT** to the location
    of the created folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B22428_01_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.11: The environment variable ASSIMP_ROOT pointing to a folder on the
    PC'
  prefs: []
  type: TYPE_NORMAL
- en: '*Please remember that you have to restart Visual Studio 2022 after setting
    the environment variable.*'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Vulkan SDK on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For Vulkan support, you also need to have the Vulkan SDK installed. Get it
    here: [https://vulkan.lunarg.com/sdk/home](https://vulkan.lunarg.com/sdk/home).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Do a default installation, and make sure to add **GLM headers.** and **Vulkan
    Memory Allocator header.**, as the CMake search scripts will use them if the Vulkan
    SDK is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_01_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.12: Adding GLM and VMA during Vulkan SDK installation'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to restart Visual Studio 2022 after installing the Vulkan SDK to allow
    detecting the Vulkan SDK header files and environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and starting the example code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running the examples can be done in two different ways: following the book
    example by example or compiling all the code at once to browse all the examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compiling the code can be done using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To open an example project, choose **Open a local folder** from the Visual
    Studio 2022 start screen or **Open CMake** from the **File** menu of Visual Studio
    2022, then navigate to the folder with the example code you want to compile, or
    to the top-level folder of the example code if you want to compile all examples
    at once. Visual Studio will automatically detect and configure CMake in the selected
    folder for you. The last line of the output window should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This confirms the successful run of the CMake file generation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, set the startup item by right-clicking on the `CMakeLists.txt` file –
    this step is required to build and run the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22428_01_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.13: Configuring the startup item in Visual Studio 2022'
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting the startup item, we can build the current project. Right-click
    on the `CMakeLists.txt` file and choose **Build**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22428_01_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.14: Build the project in Visual Studio 2022'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the compilation succeeds, start the program in a non-debug build by using
    the unfilled green arrow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22428_01_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.15: Start the compiled program without debugging in Visual Studio
    2022'
  prefs: []
  type: TYPE_NORMAL
- en: If you are a Linux user, you can follow the explanation in the following section
    to get all the tools and libraries onto your system.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required tools and libraries for Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern Linux distributions already contain most of the tools needed to compile
    the example code for the book.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Open Asset Import Library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the common Linux distributions, Assimp should be available from the package
    manager. For Ubuntu, you need to install the Assimp development package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Installing a C++ compiler and the required libraries on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you use Ubuntu Linux, all required dependencies can be installed by using
    the integrated package manager. Use this command to install the packages for the
    OpenGL-based examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To use Clang as a compiler, instead of GCC, you can use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you plan to build the Vulkan examples, these additional packages are required
    and should be installed to get the most out of the Vulkan code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to use the latest Vulkan SDK instead of the Ubuntu version, you
    can download the package from the **LunarG** website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://vulkan.lunarg.com/sdk/home#linux](https://vulkan.lunarg.com/sdk/home#linux)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For other Linux distributions, the package manager and the names of the packages
    may differ. For instance, on an Arch-based system, this command line will install
    all required packages to build the OpenGL examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For the Vulkan examples, these additional packages are required on Arch-based
    installations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Compiling the examples via the command line on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The examples can be compiled directly on the command line, without using an
    IDE or editor. To build a single example, change into the chapter and example
    subfolders of the folder containing the cloned repository, create a new subfolder
    named `build`, and change into the new subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To compile all examples at once, create the `build` folder in the top-level
    folder of the example code and then change into the new subfolder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, run CMake to create the files required to build the code with the `ninja`
    build tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The two dots at the end are needed; CMake needs the path to the `CMakeLists.txt`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you build a single example, let `ninja` compile the code and run the generated
    executable file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If all the required tools and libraries are installed and the compilation is
    successful, an application window should open.
  prefs: []
  type: TYPE_NORMAL
- en: When building all examples at once, a new folder named `bin` will be created
    inside the top-level folder, containing a subfolder for every chapter and in every
    chapter’s folder the two subfolders for the two examples of that chapter, similar
    to the source-code structures.
  prefs: []
  type: TYPE_NORMAL
- en: In case of build errors, you need to check the requirements again.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use an IDE, you can continue with the installation of Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Eclipse on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to compile the example code with the Eclipse IDE on Linux, some
    extra steps are required:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install **Eclipse IDE for C/C++ Developers** from [https://www.eclipse.org/downloads/packages/](https://www.eclipse.org/downloads/packages/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After installing Eclipse, head to the marketplace under **Help**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B22428_01_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.16: Accessing the Eclipse marketplace'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the **cmake4eclipse** and **CMake Editor** packages. The first one
    enables CMake support in Eclipse, with all the features we need, and the second
    one adds syntax coloring to the CMake files. The extra colors make it more convenient
    to edit the files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22428_01_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.17: Installing the CMake Editor and cmake4eclipse'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compiling and starting the example code can be done in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Open Project from File System** from the **File** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose **Directory...** and navigate to the folder with the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to build all examples at once, select the top-level source folder,
    press **Deselect All**, and select only the first project.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To build only a single example, you can either use **Deselect All** on the top-level
    folder and select only the example you want to build, or you can descend into
    the folder for the specific example.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Finish** to open the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, choose **Build Project** from the context of the project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may need to switch the console output to show the current build messages.
    Use the small arrow with the tooltip **Display Selected Console**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22428_01_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.18: Selecting the right output to see the build messages'
  prefs: []
  type: TYPE_NORMAL
- en: If Eclipse does not refresh the project content after the build, choose **Refresh**
    from the context menu of the project folder, or press *F5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Run As**, and select the second option, **Local C/C++ application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Main** executable from the window to run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22428_01_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.19: Choosing the Main executable to run the compiled application'
  prefs: []
  type: TYPE_NORMAL
- en: As the last step of the preparations, we look at the organization of the code
    in the GitHub repository of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Code organization in this book
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code for every chapter is stored in the GitHub repository, in a separate
    folder with the relevant chapter number. The number uses two digits to get the
    ordering right. Inside each folder, one or more subfolders can be found. These
    subfolders contain the code of the chapter, depending on the progress of that
    specific chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For all chapters, we put the `Main.cpp` class and the CMake configuration file,
    `CMakeLists.txt`, into the project root folder. Inside the `cmake` folder, helper
    scripts for CMake are stored. These files are required to find additional header
    and library files.
  prefs: []
  type: TYPE_NORMAL
- en: All C++ classes are located inside folders, collecting the classes of the objects
    we create. The `Window` class will be stored in the `window` subfolder to hold
    all files related to the class itself, and the same applies to tools – the logger,
    the model classes, and the renderer-related classes. After you have all the required
    code and tools installed, let’s get a general idea of what game character animations
    are about.
  prefs: []
  type: TYPE_NORMAL
- en: Animating game characters – a primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving a game character around in a virtual world with lots of different animations,
    changeable outfits, a collision detection system for other characters and the
    environment, and maybe even interaction with other characters looks nice and simple
    when playing a game.
  prefs: []
  type: TYPE_NORMAL
- en: But the mathematics and techniques behind the smoothly animated game characters
    are extensive and complex. Every movement, animation, action, or state change
    of the character involves a long journey until the final image is rendered to
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a high-level explanation of animations first. If you already know
    the details, you can skip to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: About nodes, bones, skeletal animation, and skinning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The building blocks of an animated three-dimensional character model are the
    so-called **nodes**. A node can be compared to a joint in the virtual body of
    the character, like the shoulder or hip.
  prefs: []
  type: TYPE_NORMAL
- en: All nodes in the character model are connected in the form of a virtual skeleton,
    forming the **bones** of the model. By attaching child nodes to a node, modeling
    an arm with a hand and fingers, or a leg with a foot and toes – or even an entire
    human-like skeleton – is no problem. The starting point of the virtual skeleton
    is the so-called root node. The root node has no parent node and is used as the
    starting point for animations.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the level of detail does not reach the details of a skeleton in a real-world
    object since many of the real bones are static or play only a minor role in muscle
    or pose changes during animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The virtual skeleton of the character model can be animated by rotating nodes
    around their center point – and thus rotating the bone to all attached child nodes
    around the center point of this node. Just imagine raising your arm a bit: your
    upper arm will rotate around your shoulder joint, and the lower arm, hand, and
    finger follow the shoulder rotation. This kind of animation is called a **skeletal
    animation**.'
  prefs: []
  type: TYPE_NORMAL
- en: A character needs to be stored in a more or less natural pose in the file, which
    is called the reference pose, or **bind pose**. You will find most models in a
    **T-pose** where both arms create a horizontal line, and sometimes see the **A-pose**,
    where the position of the arms of the skeleton resembles the uppercase letter
    A.
  prefs: []
  type: TYPE_NORMAL
- en: To animate a character, the transforms of each node between the position in
    the bind pose and the desired position in an animation pose need to be changed.
    Since the transformation of a node needs to be calculated in the local coordinates
    of that specific node, an **inverse bind matrix** per node exists to transform
    between local and world coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The animations themselves are stored in animation **clips**. An animation clip
    does not contain node transforms for every possible time of the animation but
    only for specific time points. Only the node transforms at so-called **key frames**
    are stored in the animation clip data, resulting in less data usage. Node positions
    between two key frames are interpolated using linear interpolation for translation
    and scaling, and spherical linear interpolation (SLERP) for rotations.
  prefs: []
  type: TYPE_NORMAL
- en: By using interpolation between two key frames, the skeleton can be brought into
    virtually any pose between the two stored poses. By interpolating between key
    frames or even interpolated poses of different animation clips, **blending** between
    the two poses can be achieved, Blending can be used to change the animation clip
    of a model without visual distortion, for instance, to create a smooth transition
    between a walking and a running animation clip.
  prefs: []
  type: TYPE_NORMAL
- en: The virtual skin of a character model is called a **mesh**, and applying a mesh
    to a skeleton in the vertex shader of the rendering pipeline is called **skinning**.
    To give the virtual skin a natural appearance, every vertex of the mesh uses **weights**
    to handle the influence of surrounding nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'These weights are used as a factor for node transforms: the higher the node
    weight, the more transforms of that node will be applied to the vertex, and vice
    versa. By using the node weights, the effects of expanding and compressing the
    skin and underlying muscles of the virtual body can be modeled with good precision.'
  prefs: []
  type: TYPE_NORMAL
- en: In the glTF file format, four weights per vertex are used, but other file formats
    with more weights also exist.
  prefs: []
  type: TYPE_NORMAL
- en: There is a special kind of animation called a **morph animation**. In a morph
    animation, parts of a mesh are replaced, and the vertex positions can be interpolated
    between the different meshes. Morph animations are used to model facial expressions,
    updating only parts of a character model’s face instead of the entire model. By
    replacing only parts of the mesh but keeping the skeletal information unchanged,
    morph animations can be easily added to skeletal animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another form of animation is the so-called **additive animation**. Additive
    animations are some sort of mix between skeletal and morph animations: by adding
    the difference between the current pose and the bind pose to the skeletal animation
    clip, the animations of the additive clip are modeled on top of the skeletal animation,
    but only for the nodes that are changed in the additive animation clip.'
  prefs: []
  type: TYPE_NORMAL
- en: Additive animations are used to move only specific parts of a character independently
    of the main skeletal animation. For instance, the skeletal animation contains
    only the walking or running part of the body, while the additive animation clip
    changes only the head or hands. Now the character can move the head to look around,
    without the need to create walking and running animations containing all possible
    head movements.
  prefs: []
  type: TYPE_NORMAL
- en: The combination of skeletal, morph, and additive animation enables us to build
    powerful and natural-looking characters for our virtual world, allowing the model
    to walk or run beside us, follow our movements with the head, and use facial morph
    animations to speak all at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us look at the general workflow for creating character model animations.
    We can divide the animation workflow into two parts: preparation and updates.
    While the preparation part is needed only once while loading the model, updates
    are usually made for every frame drawn to the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: We will dive into the preparation process of the model first.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the data for efficient usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Game character models are stored in single files, or as a collection of files,
    each for a specific purpose. For instance, model and texture data could reside
    in separate files, allowing artists to change the images independently of the
    model vertices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps must be done in the application before the file in the
    model data can be used for animation and rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: As the first step in the preparation phase, these files must be loaded into
    the memory of the computer. Depending on the implementation in the game, partial
    loading is possible, adding only the elements of the character model that are
    needed at a specific level, or in a specific part of the virtual world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the data needs to be pre-processed. The representation of the data in
    the files on disk may be optimized in terms of saving space, but for efficient
    manipulation and rendering, a different kind of optimization is required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, different rendering APIs, like OpenGL, Vulkan, and DirectX, may
    need slightly different representations of vertex or texture data, or shader code
    to be uploaded to the GPU. Instead of storing the different versions in the model
    file, a generic representation may be used. The required adjustments or conversions
    will be done after loading.
  prefs: []
  type: TYPE_NORMAL
- en: As the last step, static data like vertex data or textures will be uploaded
    to the GPU, and other static and variable data parts are stored in C++ classes
    and objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, the model is ready to use. With the first appearance of that
    character on the screen, a continuously running task of data updates is needed.
    These per-frame tasks are required for states that change at runtime, such as
    positions or animation poses.
  prefs: []
  type: TYPE_NORMAL
- en: Updating character data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the data of the character is split between main memory and GPU memory,
    the game or animation program must sample, extract, convert, and upload data for
    every single frame the character is drawn to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the key-frame data of the animations needs to be updated according
    to the animation clip to be shown and the time since the last frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps must be done in every frame to create the pixels of a single
    model instance for a specific time point of a selected animation clip:'
  prefs: []
  type: TYPE_NORMAL
- en: Blending between different animation clips could be requested by the program
    flow, and additional animation parts may be needed, like additive blending for
    the head or the hands, or facial animations to allow a facial expression for the
    character. So, we extract rotation, translation, and scaling for all nodes at
    the specified replay time from all animation clips and combine the per-clip node
    transformsations into a final transformation matrix for every node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the animation data is sampled and combined, the skeleton of the character
    needs to be adjusted. According to the animation data, every virtual bone must
    be translated, rotated, and scaled to reach the desired destination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, the world position of the character may need to be updated. World position
    changes can occur in different forms, like running around, jumping, or falling
    down. Knowing the exact position of all characters is an important part of the
    remaining steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once bone positions and the world position of the character have been determined,
    collision detection can run. The collision detection checks if the character intersects
    with other characters or environmental objects like the floor and walls, or even
    if the character was hit by a projectile. As a reaction to the collision detection
    results, adjustments to the character properties, like position, or animation
    clip may be triggered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having the collision data at hand, inverse kinematics adjustments may run. Adjusting
    the skeleton data of the character could be needed to avoid character limbs intersecting
    with the wall or the floor, or to level the feet position on uneven ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the pure CPU part of the character update is nearly over. As a final step
    from the CPU side, the updated animation data is uploaded to the GPU and the render
    commands are issued. By storing the dynamic character data in the GPU, the rendering
    itself can run without much additional workload from the CPU.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the GPU, the vertex shader transforms the incoming vertex data according
    to the properties of the current view, like distances or perspective distortion.
    After other possible shader stages, the fragment shader receives the data from
    the rasterization stage of the GPU and draws the pixels to the output framebuffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After all pixels of the level data, characters, and the HUD, as well as maybe
    additional debug data, have been sent to the GPU, the visible and the drawing
    buffers are swapped – at this point, the character appears on the screen, at the
    position and in the animated pose we expect to see.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In between all these update steps, compute shaders may run on the GPU to calculate
    data. Running compute shaders allows the program to offload the calculations for
    multiple characters, freeing the CPU to work on other parts of the game.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a lot of work is needed until you see a game character running
    around in the virtual world. Let’s now start the journey into character animation
    with an overview of Open Asset Import Library.
  prefs: []
  type: TYPE_NORMAL
- en: What is Open Asset Import Library?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Open Asset Import Library**, in short **Assimp**, is a cross-platform library
    to import and convert 3D model files. The different file formats are converted
    into a hierarchical data structure, enabling a programmer to support a wider range
    of model formats in a single, comprehensive way.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1.20* shows the key elements and their relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_01_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.20: A simplified version of Assimp’s data structures'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a closer look at these data structures and their functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aiScene` is the central element of Assimp’s data structure. The root node
    entry, all information about the polygonal meshes, the materials, and the animations
    are stored in the `aiScene` element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The root node of `aiScene` points to a structure called `aiNode`. In every
    `aiNode`, possible child nodes are stored, eventually creating a node tree. Also,
    a transform matrix resides in the `aiNode` structure, defining the local transformation,
    relative to the parent node. This matrix is called the TRS matrix for the three
    possible transformations: translation, rotation, and scale, in this order. By
    combining the TRS transforms from the root node down to every node of the skeleton,
    the final world position of a node can be calculated only by using the world position
    of the root node and the local transformations of every node in the skeleton hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The node name is used in other structs, like the bones or the animations, to
    refer back to this specific node. For the vertices of the node, an index to the
    corresponding `aiMesh` structure in `aiScene` is stored here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All data that will be drawn on the screen is stored in `aiMesh` structs. Every
    mesh consists of a number of so-called faces, usually triangles. For every vertex
    of every face, important data like the vertices, normals, and texture coordinates
    are stored directly in `aiMesh`. The drawing order of the vertices is stored separately
    as indices in the other structures, allowing features like space-saving reuse
    of vertices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For animations, the model “skeleton” consists of bones, stored in `aiBone` structs.
    Here, the offset matrix defines the offset between the position in mesh space
    and the bind pose in bone space (in the glTF file format, this is the “inverse
    bind matrix”). Additionally, ,several value pairs are stored for every vertex,
    each containing a node index and a weight value. In every pair, the weight value
    specifies the fraction of the nodes movement that is applied to the vertex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The position of every vertex in the `Assimp` meshes can be bound to up to four
    bones, and the influence of each of these four bones on the final vertex position
    can be controlled by a weight value between `0` and `1`. The weight is used as
    a scaling factor for the transformations of the specified bone – a value of `1`
    means that the vertex makes the same transformations as the bone, and for a value
    of `0`, the vertex ignores the transforms of the bone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the right side of *Figure 1.20*, the data for animations is shown. The `aiAnimation`
    struct contains the animation channels for bones and meshes, the overall duration
    of the specific animation, and the number of frames per second for this animation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an example for the animations, we will look at the `aiNodeAnim` struct. This
    struct consists of key frames with rotations, translations, or scales to apply
    to a specific node. The node name in the `aiNode` struct is used to find the corresponding
    bone to animate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Currently, more than 50 different file formats are known to Assimp. Some notable
    examples are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Autodesk 3D Studio (`.3ds`), AutoCAD (`.dxf`), and FBX (`.fbx`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collada (`.dae`) and glTF (`.gltf` and `.glb`), managed by the Khronos Group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wavefront vertices (`.obj`) plus materials (`.mat`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: STL files, mostly known from 3D printing (`.stl`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game engine formats, i.e., from Quake (`.md3`/`.md5`), or Half-Life (`.mdl`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though the number of formats is impressive, it needs to be stated that
    not all models you find can be imported into the application by using `Assimp`.
  prefs: []
  type: TYPE_NORMAL
- en: Several of these file formats are reverse-engineered from closed source applications,
    and only a subset of versions work. Other formats are open source, like Collada
    or glTF, but some of those formats are also constantly evolving. Also, not all
    new features have yet been implemented in `Assimp`. So, even with a versatile
    asset import library like `Assimp`, you may end up with a model that fails to
    be imported, produces “vertex garbage” on screen, or is missing some of its properties.
    Nevertheless, `Assimp` is currently the best open source solution to load many
    different game and non-game 3D models into your own application.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a model file with `Assimp` boils down to importing the `aiScene` object
    of a file, checking for the existence of other data types, and importing that
    data into the application. In the next section, we will do a short walk-through
    of the steps to load a model file with `Assimp`.
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code for the application can be found in the folder `chapter01`,
    the subfolder `01_opengl_assimp` for OpenGL, and the subfolder `02_vulkan_assimp`
    for Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a model file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To load a model file with Open Asset Import Library, we must include the following
    three headers in the implementation file of the `AssimpModel` model loading class
    in the `model` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create an `Assimp::Importer` instance in the `loadModel()` method,
    and use the importer to load a file from disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We hand over the file name of the asset file we want to load, plus the two values
    `aiProcess_Triangulate` and `aiProcess_GenNormals` as optional postprocessing
    flags.
  prefs: []
  type: TYPE_NORMAL
- en: The first flag, `aiProcess_Triangulate`, instructs `Assimp` to triangulate all
    polygons with more than three vertices, if those polygons exist in the file. Since
    our basic renderer only understands triangles, a polygon with more than three
    vertices would cause graphical errors.
  prefs: []
  type: TYPE_NORMAL
- en: Using `aiProcess_GenNormals` as the import flag ensures that all triangles have
    normal vectors. Default normal vectors pointing upward from the surface of the
    triangle will be created only if no normal vector is found. Existing normals are
    not changed by the flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must check if the import was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We assume a failed import if the scene pointer itself is a `nullptr`, the scene
    is marked as incomplete by the importer, or the scene has no root node defined.
  prefs: []
  type: TYPE_NORMAL
- en: After the model file has been loaded successfully, we will scan the model for
    embedded textures.
  prefs: []
  type: TYPE_NORMAL
- en: Loading embedded textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some model formats can embed the textures into the object file. If the function
    call to `HasTextures()` returns `true`, we loop over all textures of the model
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the loop, we extract the texture name, height, and width, as well as
    the pixel data of the texture. The texture name is only for information purposes,
    since the data is embedded into the model file, but having the name is helpful
    while debugging problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we create a shared pointer and try to import the texture data. If the
    import fails with an unexpected error, we stop loading the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Embedded textures are references in the format `*10` – a star plus the index
    number of the texture. So, we create the internal name and insert the shared pointer
    into a `std::unordered_map`, mapping the texture name to our data object containing
    the texture data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to any embedded textures, a placeholder texture will be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Placeholder textures for objects are common in many game engines, showing objects
    with missing textures, instead of a black object or random data from the GPU memory.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the node hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After checking for embedded textures, we continue by processing all nodes.
    Due to the hierarchical organization, we take a recursive approach here. As the
    first step, we create an object for the root node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: An `AssimpNode` object contains data about the position, rotation, and scaling
    of one of the model parts in the virtual world. This transformation data also
    includes the position, rotation, and scale of its parent node, moving all the
    nodes to their intended position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, this new root node will be used as the basis to collect all child nodes,
    grandchild nodes, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `processNode()` method, four tasks are done for every node:'
  prefs: []
  type: TYPE_NORMAL
- en: Collecting the mesh data itself, like vertex positions, normals, or texture
    coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting external textures from materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting bones for skeletal animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Descending into the hierarchy to process the child nodes of this node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We start by iterating through all meshes of the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AssimpMesh` class contains the logic to extract vertex data, textures,
    and bones. We simply create a local `mesh` instance and let the `processMesh()`
    method do all the extraction work for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After the Assimp mesh has been processed, we add the converted mesh data, the
    collected textures, and the bones to the data structures of the model itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we store the current node in a node map and a node list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Saving the same node in two different data structures is needed to speed up
    the access during different phases of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mNodeMap` contains the nodes in a `std::unordered_map`, allowing us to
    access any node by its node name in constant time. But a huge disadvantage is
    that a `std::unordered_map` does not preserve the insertion order by default.
    Using a `std::map` would not help either since all entries of a `std::map` will
    be sorted by the key in ascending order. We could solve the sorting issue by using
    a custom comparator function for the map, but since we are also accessing the
    nodes based on the index position, a second data structure will be used: the `mNodeList`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `mNodeList`, all nodes are stored in a flat but hierarchical order, guaranteeing
    us to access any of the nodes before its child nodes. This way, the `mNodeList`
    is fast when it comes to updates that need to be done in all nodes. We can just
    iterate from start to end through the vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of `processNode()`, we check for child nodes, and process any child
    nodes we find in a recursive manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After processing all nodes in the hierarchy, we have collected all meshes, textures,
    and skeletal data from the model.
  prefs: []
  type: TYPE_NORMAL
- en: Adding vertex buffers for the meshes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in the `loadModel()` method, we create a combined vertex and index buffer
    object for every mesh, upload the extracted vertex data, and store the buffer
    in a `std::vector` called `mVertexBuffers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: To draw the imported model, we can now simply iterate over the `mModelMeshes`
    vector and use the `drawIndirect()` call of the `VertexIndexBuffer` class to draw
    all triangles of this specific mesh with only a single draw command. The method
    is called “indirect” because Assimp stores the model data internally as vertices
    plus indices, and we draw the triangles in the indirect mode, via the indices.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, an instanced version of the draw call is available, named `drawIndirectInstanced()`.
    Instanced drawing allows us to draw several instances of the same mesh on different
    positions of the screen, but the workload of creating the extra triangles is done
    by the GPU, not the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Importing animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the last step of the model-loading process, we check for animations and
    iterate over the internal data structure of the animations in the model file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For every animation we find, we create an object of the class `AssimpAnimClip`,
    and add all channels of the current animation clip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Some models do not specify a name for the animation clip, so we set the name
    to the number of the clip if the name is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Having distinctive clip names is a requirement for the UI to select the animations
    by name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we store the clips in the `mAnimClips` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: At this point, all relevant data of the model has been loaded, extracted, and
    converted. As stated at the end of the *What is Open Asset Import Library?* section,
    the quality of the imported data depends on various factors, particularly the
    compatibility with `Assimp`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the code for all the details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should take a look at the implementation of the other classes prefixed with
    “Assimp” in the `model` folder, and the implementations of the extraction methods
    in these classes. In general, the methods simply read out the C-style data structures
    from `Assimp`, constructing custom C++ classes. The data for the mesh is converted
    into GLM types, allowing us to do a simple upload to the GPU, instead of a time-consuming
    change at every draw.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the basics ready to open a model file, we run into a simple
    but essential problem: *The file name for the model file is hardcoded*.'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than hardcode the path to our model file for loading, let’s add the ability
    to browse for a file. A simple way to load a specific model from a file into the
    application is with an “Open File” dialog, allowing us to choose the file we want
    to import. To achieve the seamless integration of such a dialog into the program,
    we will use an ImGui-based solution, instead of an OS-native dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the UI with an Open File dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ImGui can be used to create simple UIs like in our animation application, but
    the code can be also extended to build different kinds of tools. For our application,
    a dialog to choose a file on the system is helpful to load models at runtime,
    freeing us of hardcoding the model names in the code or using models as command-line
    parameters when starting the application.
  prefs: []
  type: TYPE_NORMAL
- en: Various ImGui-based file dialogs exist; a nice and easy-to-integrate file dialog
    can be found in the GitHub repository of Stephane Cuillerdier at [https://github.com/aiekick/ImGuiFileDialog](https://github.com/aiekick/ImGuiFileDialog).
  prefs: []
  type: TYPE_NORMAL
- en: For a simple integration of the file dialog, we will use CMake’s `FetchContent`
    to download and build the code.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the file dialog into CMakeLists.txt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we add a new `FetchContent` block into the `CMakeLists.txt` file, right
    below the end of the ImGui fetching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We “short-cut” the configure and build commands here, since we only want to
    have the source code available, instead of building a standalone version of the
    file dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the initial configuration still needs the location of the ImGui
    headers. Since the `FetchContent` block does not allow setting additional compiler
    options, we need a small hack to alter the value of the CMake property `COMPILE_OPTIONS`
    during the fetch process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we save the current state of `COMPILE_OPTIONS` in a new CMake variable
    called `current_compile_options`. Then, we adjust the compile options to include
    the headers from the ImGui source folder in the search list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can trigger the download and initialization of the file dialog source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid further confusion in the build system, we set the `COMPILE_OPTIONS`
    property back to its saved state, and also unset the variable we used to save
    the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In Visual Studio 2022, a new CMake configuration run is triggered automatically.
    In Eclipse, a new run of CMake must be triggered via the **Build Project** option
    in the right-click context menu of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Including the functionality of the file dialog is easy; the UI class needs to
    be extended by only a couple of lines.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ImGui file dialog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can place the dialog code anywhere in the code of the `createFrame()` method
    of the `UserInterface` class in the `UserInterface.cpp` file within the folder
    `opengl`. First, we add an `ImGui::Button` named `"Import Model"`. This button
    will open a modal version of the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This button configures a special `FileDialogConfig` property of the file dialog.
    The `config.path` entry sets the path to open to the current path where the executable
    was started, while `countSelectionMax` tells the dialog to accept only a single
    file to be selected. Setting `flags` to `ImGuiFileDialogFlags_Modal` presents
    the file dialog on top of all other ImGui windows.
  prefs: []
  type: TYPE_NORMAL
- en: When the flags are set, `OpenDialog()` is called to open a dialog instance with
    the internal name `"ChooseModelFile"` as the first parameter; the window title
    `"Choose Model File"` as the second parameter; a filter to show all files, regardless
    of the file extensions, as the third parameter; and the configuration property
    as the last parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the internal name of the dialog to open in the `Display()` call allows
    us to define multiple open file dialogs, depending on the requirements of the
    program in the specific situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right after the button, the file dialog itself is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The code for the file dialog follows the ImGui coding style. The first `if`
    around the `Display()` call returns `true` if the dialog is shown, that is, after
    the above `"Import Model"` button has been clicked. Then, the dialog code reacts
    by setting `IsOk()` to `true` after the `"OK"` button of the dialog has been clicked,
    allowing us to insert actions to take on the selected file. The final `Close()`
    call closes the dialog when a file has been selected.
  prefs: []
  type: TYPE_NORMAL
- en: Before we check the return value of the file dialog, we take a look at the file
    extension filter. Showing all files could make it difficult to find the file we
    want to load.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a filter to show only supported file types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `filter` field of the file dialog allows quite complex configurations,
    but we will check only three of them: a single filter, a group of extensions,
    and a regular expression-style filter.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a single filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code in the *Using the ImGui file dialog* section already shows a single
    filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This filter simply means “anything after the last dot of the file name,” so
    you will see all the visible files in the current folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also specify a single extension here, and only files with this one
    extension are shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note on case sensitivity
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, filtering is case sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: So, the `.jpg` filter will *not* show a file named `IMAGE.JPG`!
  prefs: []
  type: TYPE_NORMAL
- en: Adding a group of filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Grouping file extensions into a single filter works by separating them with
    a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: However, this may not work as intended – you can still choose only one extension
    from the group, showing only files with the specific extension in the current
    folder. Allowing only one file extension from a group can be used for **Save File**
    dialogs, forcing the user to choose a specific file format from a list of available
    formats.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a regular expression-style filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most useful variant for the filter is the regular expression style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, the string `"Supported Types"` will be shown as a filter in the dialog,
    and all files with the file extension named in the curly braces are shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also add multiple regular expression filters, separated by commas,
    to create a drop-down list of various file types. This line would enable you to
    choose between a couple of pictures, the textual and binary glTF formats, and
    all files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Since the filter field of the `OpenDialog()` call is a pointer to a character
    array, the filter list could even be created dynamically. Depending on the state
    of the program, the file types you want the user to select, and so on, you can
    present various filter options.
  prefs: []
  type: TYPE_NORMAL
- en: Having the file dialog open with a (possibly limited) amount of file types presented
    to the user, let’s complete the code handling the file selected by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the model file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a file was selected and the `OK` button was pressed, or the file name was
    double-clicked, the name including the full path of the chosen file is available
    by calling `GetFilePathName()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For a clear separation of concerns, the UI code does not handle the loading
    process itself. Instead, a simple lambda-based callback is created, and we call
    this callback with the name of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback to add a new model is defined in the file `ModelAndInstanceData.h`
    in the `model` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'During initialization of the renderer, the callback function is bound to the
    method `addModel()` of the renderer class via a lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now, when a file has been selected, the renderer is doing all the “dirty work”
    of importing the new model, signaling back if the model import was successful.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, the return value of the callback only adjusts the position in the
    list of models. But it could be used to give feedback to the user – an error message
    popup can be presented if the model file could not be opened, or the same model
    file was already loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the model to the screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process of drawing the model in the renderer is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the smart pointer that points to the `Assimp` model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the model is animated, update the animation with the delta time between the
    last frame and this frame, and collect the new bone matrices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the model is not animated, simply get the node matrices of the instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload the matrix data to the shader storage buffer on the shader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issue a draw call to the graphics API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The custom classes handle all other steps required to draw the model, like uploading
    the vertex data or binding the correct texture for the mesh to draw next.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and drawing a single file is already cool. But to use the full power
    of `Assimp`, we will allow adding and deleting different models and model instances
    at program runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing model instances dynamically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Supporting multiple instances from multiple models was done by creating the
    class `AssimpInstance` in the `model` folder. Every `AssimpInstance` contains
    a smart pointer to access its base model, including the nodes and bones. Adding
    multiple instances of the same model requires one of two options to handle nodes
    and bones: using a copy of the node data structures in every instance or sharing
    the model’s nodes across all instances.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid the duplication of all nodes in every instance, we will reuse the nodes
    of the model during the calculation of each final node position for the frame.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing the bones for the sake of simplicity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To calculate the nodes during animation in the `updateAnimation()` method,
    we iterate the channels of the clip and use the model’s corresponding node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The position, rotation, or scale of every node change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For the root node, the local transformation of the instance is applied to the
    root transform matrix of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Then, the node properties are used to generate the final position of the bone,
    using the stored offset matrix from the corresponding bone and the local transformation
    matrix of the node.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we get the node corresponding to the bone of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we update the matrix containing the translation, rotation, and scale
    properties of the node (hence the three letters **TRS** in the name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Calling `updateTRSMatrix()` also retrieves the TRS matrix of the parent node
    and multiplies the local TRS matrix by the parent node’s TRS matrix. Combining
    the local TRS matrix with its parent node matrix makes sure that all nodes will
    inherit the transformations from all previous nodes in the model’s skeleton hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we multiply the TRS matrix of the current node by the bone offset
    matrix for the node to compute the final world position for every node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Reusing the model nodes works fine unless you plan to add a parallel (multi-threaded)
    calculation of instance animations: if more than one thread accesses the nodes
    of the model at the same time, at least one thread is modifying the node properties
    while other threads are reading the data, thus a so-called data race may occur,
    leading to a possible mix-up of the old and new data.'
  prefs: []
  type: TYPE_NORMAL
- en: So, when using a multi-threading version of the code, a local copy of the node
    list will be required. The additional node map can be generated from the node
    list with a simple iteration over the list, adding the nodes by their names to
    a map.
  prefs: []
  type: TYPE_NORMAL
- en: Storing instance-specific settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The remaining per-instance settings are stored in the struct `InstanceSettings`,
    defined in the file `InstanceSettings.h` in the `model` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In the first three variables, `isWorldPosition`, `isWorldRotation`, and `isScale`,
    the rotation, translation, and uniform scale of the instance are stored. The prefix
    `is` does not mean “it is” in this context but is the abbreviation of the struct
    name to have distinct variable names.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth variable, `isSwapYZAxis`, has been added for tools using a different
    coordinate system. While we are using the Y axis as the vertical axis, several
    tools used (and still use) a coordinate system where the Z axis is vertical, and
    the Y axis is one of the horizontal axes. To change the coordinate systems, a
    simple rotation matrix will be applied if `isSwapYZAxis` is set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining three variables, `isAnimClipNr`, `isAnimPlayTimePos`, and `isAnimSpeedFactor`,
    are also quite self-explanatory. These variables are used to control the animation
    parameters of the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `AssimpModel` and `AsssimpInstance` classes will help us to develop
    a simple way to add and delete models and instances.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic model and instance management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first building block of dynamic management is the struct `ModelAndInstanceData`,
    defined in the file `ModelAndInstanceData.h` in the `model` folder. A variable
    of this struct is maintained by the renderer, used during the `draw()` call, and
    also handed over to the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The first vector, `miModelList`, contains all loaded models in the order of
    their addition. This list is shown in the UI as a list of currently loaded models.
    By using `miSelectedModel`, we keep track of which model is selected in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we maintain two separate data structures for the instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The instance is stored in two different kinds of structures for the same reasons
    as the node map and node list – depending on the requirements, accessing the instances
    in one or the other data structure will be faster and/or simpler.
  prefs: []
  type: TYPE_NORMAL
- en: The `miAssimpInstances` is a normal `std::vector`, where all instances of all
    models are stored. The instances vector is used to create the list of instances
    in the UI, retaining the order of addition. If instances or models are removed,
    the instances vector will be cleaned, still keeping the order of the remaining
    models.
  prefs: []
  type: TYPE_NORMAL
- en: For `miAssimpInstancesPerModel`, the reason is different. When we want to draw
    the models in the renderer, we need all instances of a specific model to collect
    the bone matrices for animated models, and the normal node matrices for non-animated
    models. Sorting or filtering the `miAssimpInstances` vector on every draw call
    would be quite expensive on the CPU side, so the separate structure helps us here.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the `ModelAndInstanceData` struct, some callback variables are
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: These callbacks are used to move the job of creating or deleting models and
    instances from the UI back to the renderer. The UI is not the right place to adjust
    the data structures for models and instances, so these tasks will be forwarded
    to the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The callbacks themselves are C++-style function pointers, created with `std::function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Going back to the renderer, we look at the `addModel()` method that is called
    from the UI, as mentioned in the section *Loading the model file*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `addModel()` method for the OpenGL renderer looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: First, we check if the model has been already loaded. To avoid confusion, a
    model file can be loaded only once. Having the exact same model file loaded twice
    (or more times) makes little sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we try to load the specified model file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: When the loading fails, the model also returns `false` to the caller, even though
    the return value is not used currently.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the model file can be loaded, it will be placed into a `std::vector` of
    models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: From this list, the UI generates the combo box with the currently loaded model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also add an instance of the model and return the information about a successfully
    loaded model to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: For a loaded model to be helpful, we need to create at least one instance, so
    we have something to render in the world. We use the already implemented way of
    creating a first instance, instead of having a separate solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `addInstance()` method is also only a couple of lines long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The signature of the method shows that we return the created instance to the
    caller. Even though the instance will be added to the internal data structures,
    getting the new instance from the method may be handy, i.e., when the instance
    should be further adjusted.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a new smart pointer of an `AssimpInstance` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the base model is given as the only parameter. The constructor of the
    `AssimpInstance` class has three additional parameters with default values set:
    the initial position, rotation, and scale. Setting these parameters may be useful
    in the future, but to create a single instance, they can be omitted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the new instance is inserted into two data structures, `miAssimpInstances`
    and `miAssimpInstancesPerModel`, of the struct `ModelAndInstanceData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As the last steps, we update the triangle count shown in the UI and return the
    newly created instance
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Deleting models and instances follows broadly the same path. The UI triggers
    the action via the callback; the renderer searches for the instance, or the model
    and all instances of that model, and removes them from the data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing all instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process of drawing the instances of the `Assimp` models has not changed
    much. We need to loop over all model instances, instead of just a single model.
    We use an “instanced” type of call to the graphics API that draws all instances
    of one `Assimp` model directly on the GPU:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate over the `miAssimpInstancesPerModel` map to find all instances of a
    specific model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the model is animated, update the animation with the delta time between the
    last frame and this frame, and collect the new bone matrices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the model is not animated, simply get the node matrices of the instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the matrix data to the shader storage buffer on the shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Issue an instanced draw call to the graphics API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For *step 5* of the list, it is mandatory to have the exact count of the instances
    per model available as quickly as possible. The fastest way to get the number
    of instances is to measure the size of each vector in the `miAssimpInstancesPerModel`
    map.
  prefs: []
  type: TYPE_NORMAL
- en: If we use the unsorted `miAssimpInstances` vector to draw the instances instead,
    collecting all instances of the same model type would require extra work. Iterating
    over the `miAssimpInstances` vector to find all instances of the same model and
    adding these instances to temporary data structures costs precious time. This
    strategy would lower the maximum number of frames per second we could achieve.
    In order to use instanced draw calls, we need to process instances grouped by
    their associated model. So, we are drawing all instances by using the `miAssimpInstancesPerModel`
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1.21* shows the application after loading the example model from the
    `assets` folder and spawning a number of instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_01_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.21: Multiple instances of the example animated character model'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took the first steps toward mastering C++ game animation
    programming by using **Open Asset Importer Library**, or `Assimp`. `Assimp` enables
    us to simplify and accelerate the path to animating and rendering model instances.
  prefs: []
  type: TYPE_NORMAL
- en: We started by looking at the general data structures of the `Assimp` library,
    how to parse the different parts of a file, and in which order. Next, we added
    a nice ImGui-based file dialog to the code, allowing us to select files in an
    interactive manner, instead of having to hardcode one or more model files we wish
    to open. At the end of the chapter, we explored how to add or remove models and
    instances at runtime, enabling us to create a more “crowded” virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](Chapter_2.xhtml), we will move the computational load to calculate
    the model matrices from the CPU to the GPU, allowing us to have more CPU power
    left to do amazing things in our virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: Practical sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will see this section at the end of every chapter in the book. Here, I will
    add a bunch of suggestions and exercises that you can try out with the code on
    GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could try to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add more controls to the animations, like the play direction, one/time vs. loop
    play, or even ping-pong replay, alternating between forward and backward replay
    of the chosen animation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an animation slider that lets you choose to show the frame at some point
    in time of an animation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for model files on the internet. Try out which models work, or to which
    extent they work. You do not have to limit this search to game character models;
    you can also search for game maps in compatible formats, or 3D-printable objects.
    Remember to adjust the file dialog filter to show the additional file formats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further reading, please take a look at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft on path length limit: [https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry](https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assimp GitHub repository: [https://github.com/assimp/assimp](https://github.com/assimp/assimp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assimp documentation: [https://assimp-docs.readthedocs.io/en/latest/](https://assimp-docs.readthedocs.io/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learn OpenGL section on Assimp: [https://learnopengl.com/Model-Loading/Assimp](https://learnopengl.com/Model-Loading/Assimp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Skeletal animation tutorial: [https://www.ogldev.org/www/tutorial38/tutorial38.html](https://www.ogldev.org/www/tutorial38/tutorial38.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
