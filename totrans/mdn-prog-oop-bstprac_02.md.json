["```cpp\nclass SomeClass\n {\n   private int field;\n   public int Field => field;\n }\n```", "```cpp\nstruct SomeClass\n {\n   int Field;\n }\n```", "```cpp\npublic interface MutableList<T> {\n  void setElements(T[] elements);\n  void appendObject(T element);\n  void removeObject(int index) throws OutOfBoundsException;\n  void replaceObject(int index, T element) throws OutOfBoundsException;\n  int count();\n  T at(int index);\n };\n```", "```cpp\npublic interface TemporalList<T> {\n  void setInitialState(T[] elements);\n  void appendObject(T element, Time when);\n  void removeObject(int index, Time when) throws   InconsistentHistoryException;\n  void replaceObject(int index, T element, Time when) throws   InconsistentHistoryException;\n  void revertMostRecentChange(Time beforeNow);\n  int count(Time when);\n  T at(int index, Time when);\n };\n```", "```cpp\npublic interface ImmutableList<T> {\n  ImmutableList<T> addObject(T element);\n  ImmutableList<T> removeObject(int index) throws OutOfBoundsException;\n  ImmutableList<T> replaceObject(int index, T element) throws OutOfBoundsException;\n  int count();\n  T at(int index);\n }\n```", "```cpp\nclass ImmutableList:\n  def addObject(this, element):\n     pass\n  def removeObject(this, index):\n     pass\n  def replaceObject(this, index, element):\n     pass\n  def count(this):\n     pass\n  def at(this, index):\n     pass\n```", "```cpp\n\tclass ImmutableList:\n\t\tdef __init__(this, elements):\n\t\t\tthis.elements = elements\n\t\tdef __getattr__(this, name):\n\t\t\tif name == \"count\":\n\t\t\t\treturn lambda: len(this.elements)\n\t\t\telif name == \"at\":\n\t\t\t\treturn lambda index: this.elements[index]\n\t\t\t# ...\n```", "```cpp\n    >>> il = ImmutableList([1,2,3])\n\t>>> il.count()\n\t3\n\t>>> il.at(0)\n\t1\n\t>>>\n```", "```cpp\n    (constructor arguments) -> message -> (method arguments) -> method return type\n```", "```cpp\n\tdef ImmutableList(elements):\n\t\treturn type('ImmutableList',\n\t\t\t\t\t(object,),\n\t\t\t\t\t{'__getattr__':\n\t\t\t\t\t (lambda this, name:\n\t\t\t\t\t (lambda: len(elements)) if name==\"count\"\n\t\t\t\t\t else (lambda index: elements[index]) if name==\"at\"\n\t\t\t\t\t else False)\n\t\t\t\t\t})()\n```", "```cpp\n    const foo = {\n\t  doAThing: () => { console.log(\"I'm doing a thing!\"); }\n\t}\n\n\tfoo.doAThing();\n```", "```cpp\n    const foo = new Proxy({}, {\n\t  get: (target, prop, receiver) => (() => {\n\t    console.log(\"I'm doing my own thing!\");\n      }),\n\t});\n\n\tfoo.doAThing();\n```", "```cpp\n    function Foo() {};\n\tFoo.prototype.doAThing = () => { console.log(\"Doing my prototype's thing!\"); };\n\n\tnew Foo().doAThing();\n```", "```cpp\n    class Foo {\n\t  doAThing() { console.log(\"Doing my class's thing!\"); }\n\t}\n\n\tnew Foo().doAThing();\n```"]