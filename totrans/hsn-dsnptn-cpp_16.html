<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-283"><a id="_idTextAnchor739"/>16</h1>
<h1 id="_idParaDest-284"><a id="_idTextAnchor740"/>Adapters and Decorators</h1>
<p>This chapter takes on two classic patterns in <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) - the Adapter pattern and the decorator pattern. These patterns are just two of the original twenty-three design patterns that were introduced in the <em class="italic">Design Patterns – Elements of Reusable Object-Oriented Software</em> book by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. As an object-oriented language, C++ can take advantage of these patterns as well as any other language. But, as is often the case, generic programming brings some advantages, variations, and, with it, new challenges to the classic patterns.</p>
<p>The following topics are covered in this chapter:</p>
<ul>
<li>What are the adapter and decorator patterns?</li>
<li>What is the difference between the two?</li>
<li>What design problems can be solved by these patterns?</li>
<li>How are these patterns used in C++?</li>
<li>How does generic programming help to design adapters and decorators?</li>
<li>What other, different, patterns offer alternative solutions to similar problems?<a id="_idTextAnchor741"/></li>
</ul>
<h1 id="_idParaDest-285"><a id="_idTextAnchor742"/>Technical requirements</h1>
<p>The example code for this chapter can be found on GitHub at the following link: <a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter16">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter16</a>.<a id="_idTextAnchor743"/></p>
<h1 id="_idParaDest-286"><a id="_idTextAnchor744"/>The decorator pattern</h1>
<p>We will begin this<a id="_idIndexMarker887"/> study with the definitions of the two classic patterns. As we will see, on paper, the patterns, as well as the differences between them, are quite clear. Then, C++ comes in and blurs the lines by allowing design solutions that fall somewhere in-between the two. Still, the clarity of these simple cases is helpful, even if it gets muddled as we pile on the complexity. Let’s start with what is clear, then.</p>
<p>The decorator pattern is also a structural pattern; it allows a behavior to be added to an object. The classic decorator pattern extends the behavior of an existing operation that’s performed by a class. It <em class="italic">decorates</em> the class with the new behavior and creates an object of the new, decorated type. The decorator implements the interface of the original class and forwards the requests from its own interface to that class, but it also performs additional actions before and after these forwarded requests - these are the <em class="italic">decorations.</em> Such<a id="_idIndexMarker888"/> decorators are sometimes called “class wrappers<a id="_idTextAnchor745"/>”<a id="_idTextAnchor746"/>.</p>
<h2 id="_idParaDest-287"><a id="_idTextAnchor747"/>Basic decorator pattern</h2>
<p>We will begin with a C++ example of the decorator pattern that follows the classic definition as closely as possible. For this example, we will imagine designing a fantasy game that’s set in medieval times (true to life, only with dragons and elves and so on). Of course, what are medieval times without fighting? And so, in our game, the player has a choice of units appropriate for his/her side, and they can do battle when called on. Here is the basic <code>Unit</code> class - at least the combat-related part:</p>
<pre class="source-code">
// Example 01
class Unit {
  public:
  Unit(double strength, double armor) :
    strength_(strength), armor_(armor) {}
  virtual bool hit(Unit&amp; target) {
    return attack() &gt; target.defense();
  }
  virtual double attack() = 0;
  virtual double defense() = 0;
  protected:
  double strength_;
  double armor_;
};</pre>
<p>The unit has <code>strength</code>, which determines its attack, and <code>armor</code>, which provides defense. The actual values of the attack and the defense are computed by the derived classes - the concrete units - but the combat mechanism itself is right here - if the attack is stronger than the defense, the unit successfully hits the target (this is a very simplistic approach to gaming, of course, but we want to make the examples as concise as possible).</p>
<p>Now, what are the actual units in the game? The pillar of the human armies is the valorous <code>Knight</code>. This unit <a id="_idIndexMarker889"/>has strong armor and a sharp sword, giving it bonuses to both attack and defend:</p>
<pre class="source-code">
// Example 01
class Knight : public Unit {
  public:
  using Unit::Unit;
  double attack() { return strength_ + sword_bonus_; }
  double defense() { return armor_ + plate_bonus_; }
  protected:
  static constexpr double sword_bonus_ = 2;
  static constexpr double plate_bonus_ = 3;
};</pre>
<p>Fighting against the knights are the brutish ogres. The ogres swing simple wooden clubs and wear ragged leather, neither of which are great implements of war, giving them some combat penalties:</p>
<pre class="source-code">
// Example 01
class Ogre : public Unit {
  public:
  using Unit::Unit;
  double attack() { return strength_ + club_penalty_; }
  double defense() { return armor_ + leather_penalty_; }
  protected:
  static constexpr double club_penalty_ = -1;
  static constexpr double leather_penalty_ = -1;
};</pre>
<p>On the other hand, ogres are remarkably strong, to begin with:</p>
<pre class="source-code">
Knight k(10, 5);
Ogre o(12, 2);
k.hit(o); // Yes!</pre>
<p>Here the knight, aided by his attack bonus and the enemy’s weak armor, will successfully hit the ogre. But the game is far from over. As the units fight, the surviving ones gain experience and eventually become veterans. A veteran unit is still the same kind of unit, but it <a id="_idIndexMarker890"/>gains attack and defense bonuses, reflecting its combat experience. Here, we do not want to change any of the class interfaces, but we want to modify the behavior of the <code>attack()</code> and <code>defense()</code> functions. This is the job of the decorator pattern, and what follows is the classic implementation of the <code>VeteranUnit</code> decorator:</p>
<pre class="source-code">
// Example 01
class VeteranUnit : public Unit {
  public:
  VeteranUnit(Unit&amp; unit,
              double strength_bonus,
              double armor_bonus) :
    Unit(strength_bonus, armor_bonus), unit_(unit) {}
  double attack() { return unit_.attack() + strength_; }
  double defense() { return unit_.defense() + armor_; }
  private:
  Unit&amp; unit_;
};</pre>
<p>Note that this class inherits directly from the <code>Unit</code> class, so in the class hierarchy, it is <em class="italic">to the side</em> of concrete unit classes such as <code>Knight</code> or <code>Ogre</code>. We still have the original unit that is decorated and becomes the veteran - the <code>VeteranUnit</code> decorator contains a reference to it. The way it is used, then, is to decorate a unit and use the decorated unit from then on, but it does not delete the original unit:</p>
<pre class="source-code">
// Example 01
Knight k(10, 5);
Ogre o(12, 2);
VeteranUnit vk(k, 7, 2);
VeteranUnit vo(o, 1, 9);
vk.hit(vo); // Another hit!</pre>
<p>Here, both our old<a id="_idIndexMarker891"/> enemies reached their first veterancy levels, and the victory again goes to the knight. But experience is the best teacher, and our ogre gains another level, and, with it, enchanted runic armor with a massive defense bonus:</p>
<pre class="source-code">
VeteranUnit vvo(vo, 1, 9);
vk.hit(vvo); // Miss!</pre>
<p>Note that we can decorate a decorated object in this design! This is intentional, and the bonuses stack up as the unit gains levels. This time, the experienced fighter’s defense proves to be too much for the knight.</p>
<p>As we already mentioned, this is the classic decorator pattern, straight out of the textbook. It works in C++ but with some limitations. The first one is rather evident  even though we want to use the decorated unit once we have it, the original unit must be kept around, and the lifetimes of these objects must be carefully managed. There are practical solutions to such practical problems, but the focus of this book is on combining design patterns with generic programming, and the new design possibilities that pairing creates. Therefore, our creative path takes us elsewhere.</p>
<p>The second problem is more endemic to C++. It is best illustrated by an example. The game’s designers have added a special ability to the <code>Knight</code> unit - it can charge forward at its enemy, gaining a short-term attack bonus. This bonus is valid only for the next attack, but in the thick of the battle, it may be just enough:</p>
<pre class="source-code">
// Example 02
class Knight : public Unit {
  public:
  Knight(double strength, double armor) :
  Unit(strength, armor), charge_bonus_(0) {}
  double attack() {
    double res = strength_ + sword_bonus_ + charge_bonus_;
    charge_bonus_ = 0;
    return res;
  }
  double defense() { return armor_ + plate_bonus_; }
  void charge() { charge_bonus_ = 1; }
  protected:
  double charge_bonus_;
  static constexpr double sword_bonus_ = 2;
  static constexpr double plate_bonus_ = 3;
};</pre>
<p>The charge bonus is<a id="_idIndexMarker892"/> activated by calling the <code>charge()</code> member function and lasts for one attack, and then it is reset. When the player activates the charge, the game executes the code, which looks something like this:</p>
<pre class="source-code">
Knight k(10, 5);
Ogre o(12, 2);
k.charge();
k.hit(o);</pre>
<p>Of course, we would expect the veteran knight to be able to charge forward as well, but here we run into a problem - our code does not compile:</p>
<pre class="source-code">
VeteranUnit vk(k, 7, 2);
vk.charge(); // Does not compile!</pre>
<p>The root of the problem is that <code>charge()</code> is a part of the interface of the <code>Knight</code> class, while the <code>VeteranUnit</code> decorator is derived from the <code>Unit</code> class. We could move the <code>charge()</code> function into the base class, <code>Unit</code>, but this is a bad design - <code>Ogre</code> is also derived from <code>Unit</code>, and ogres cannot charge, so they should not have such an interface (it violates the <em class="italic">is-a</em> principle of public inheritance).</p>
<p>This is a problem that’s inherent in the way we implemented the decorator object - both <code>Knight</code> and <code>VeteranUnit</code> are derived from the same base class, <code>Unit</code>, but they don’t know anything about each other. There are some ugly workarounds, but it is a fundamental C++ limitation; it does not handle <em class="italic">cross-casting</em> well (casting to a type in another branch of the same hierarchy). But what the language takes with one hand, it gives with the other - we <a id="_idIndexMarker893"/>have much better tools to deal with this problem, and we are going to learn about these tool<a id="_idTextAnchor748"/>s<a id="_idTextAnchor749"/> next.</p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor750"/>Decorators the C++ way</h2>
<p>We have encountered<a id="_idIndexMarker894"/> two problems while implementing a classic decorator in C++ - first of all, the decorated object did not take ownership of the original object, so both must be kept around (this may not be so much a problem as a feature if the decoration needs to be removed later, which is one of the reasons the decorator pattern is implemented this way). The other problem is that a decorated <code>Knight</code> is not really a <code>Knight</code> at all, but a <code>Unit</code>. We can solve the second problem if the decorator is itself derived from the class that is being decorated. This would imply that the <code>VeteranUnit</code> class does not have a fixed base class - the base class should be whatever class is being decorated. This description matches the <strong class="bold">Curiously Recurring Template Pattern</strong> (<strong class="bold">CRTP</strong>) to<a id="_idIndexMarker895"/> a tee (this C++ idiom was described earlier in this book in <a href="B19262_08.xhtml#_idTextAnchor360"><em class="italic">Chapter 8</em></a><em class="italic">, The Curiously Recurring Template Pattern</em>). To apply CRTP, we need to make the decorator into a template and inherit from the template parameter:</p>
<pre class="source-code">
// Example 03
template &lt;typename U&gt;
class VeteranUnit : public U {
  public:
  VeteranUnit(U&amp;&amp; unit,
              double strength_bonus,
              double armor_bonus) :
    U(unit), strength_bonus_(strength_bonus),
    armor_bonus_(armor_bonus) {}
  double attack() { return U::attack() + strength_bonus_; }
  double defense() { return U::defense() + armor_bonus_; }
  private:
  double strength_bonus_;
  double armor_bonus_;
};</pre>
<p>Now, to promote a unit to the veteran status, we must convert it to the decorated version of the<a id="_idIndexMarker896"/> concrete <code>unit</code> class:</p>
<pre class="source-code">
// Example 03
Knight k(10, 5);
Ogre o(12, 2);
k.hit(o); // Hit!
VeteranUnit&lt;Knight&gt; vk(std::move(k), 7, 2);
VeteranUnit&lt;Ogre&gt; vo(std::move(o), 1, 9);
vk.hit(vo); // Hit!
VeteranUnit&lt;VeteranUnit&lt;Ogre&gt;&gt; vvo(std::move(vo), 1, 9);
vk.hit(vvo); // Miss...
vk.charge(); // Compiles now, vk is a Knight too
vk.hit(vvo); // Hit with the charge bonus!</pre>
<p>This is the same scenario that we saw at the end of the previous section, but it now uses the template decorator. Notice the differences. First of all, a <code>VeteranUnit</code> is a class that’s derived from a concrete unit such as <code>Knight</code> or <code>Ogre</code>. As such, it has access to the interface of the base class: for example, a veteran knight, <code>VeteranUnit&lt;Knight&gt;</code>, is a <code>Knight</code> too and has the member function <code>charge()</code> inherited from <code>Knight</code>. Second, the decorated unit explicitly takes ownership of the original unit - to create a veteran unit, we have to move the original unit into it (the base class of the veteran unit is move-constructed from the original unit). The original object is left in the unspecified moved-from state, and the only safe action that can be done on this object is a call to the destructor. Note that, at least for the simple implementation of unit classes, the <code>move</code> operation is just a copy, so the original object is usable, but you should not rely on it - making assumptions about the moved-from state is a bug waiting to happen.</p>
<p>It is worth pointing out that our declaration of the <code>VeteranUnit</code> constructor enforces and requires this ownership transfer. If we try to construct a veteran unit without moving from the original unit, it will not compile:</p>
<pre class="source-code">
VeteranUnit&lt;Knight&gt; vk(k, 7, 2); // Does not compile</pre>
<p>By providing only one constructor that accepts an r-value reference, that is, <code>Unit&amp;&amp;</code>, we require that the caller agrees to the transfer of ownership.</p>
<p>So far, for<a id="_idIndexMarker897"/> demonstration purposes, we have created all unit objects on the stack as local variables. In any non-trivial program, this is not going to work - we need these objects to stay around, long after the function that created them is done. We can integrate decorator objects and the memory ownership mechanism and ensure that the moved-from original units are deleted after a decorated version is created.</p>
<p>Let’s say that ownership is managed throughout the program by unique pointers (each object has a clear owner at any given time). Here is how this can be accomplished. First of all, it is convenient to declare aliases for the pointers we need to use:</p>
<pre class="source-code">
using Unit_ptr = std::unique_ptr&lt;Unit&gt;;
using Knight_ptr = std::unique_ptr&lt;Knight&gt;;</pre>
<p>While any unit can be owned by the <code>Unit_ptr</code> pointer, we cannot call unit-specific member functions such as <code>charge()</code> through it, so we may need pointers to the concrete classes as well. As we will see next, we need to move the object between these pointers. Moving from a pointer to the derived class to the pointer to the base class is easy:</p>
<pre class="source-code">
Knight_ptr k(new Knight(10, 5));
Unit_ptr u(std::move(k)); // Now k is null</pre>
<p>Going in the other direction is a little harder; <code>std::move</code> will not work implicitly, just like we cannot convert from <code>Unit*</code> to <code>Knight*</code> without an explicit cast. We need a <em class="italic">moving cast</em>:</p>
<pre class="source-code">
// Example 04
template &lt;typename To, typename From&gt;
std::unique_ptr&lt;To&gt; move_cast(std::unique_ptr&lt;From&gt;&amp; p) {
 return std::unique_ptr&lt;To&gt;(static_cast&lt;To*&gt;(p.release()));
}</pre>
<p>Here, we use <code>static_cast</code> to cast to the derived class, which works if the assumed relation (that the base object really is the expected derived object) is correct, otherwise, the results are undefined. We can test this assumption at runtime if we want to, using <code>dynamic_cast</code> instead. Here is a version that does the test, but only if asserts are enabled (we could <a id="_idIndexMarker898"/>throw an exception instead of the assert):</p>
<pre class="source-code">
// Example 04
template &lt;typename To, typename From&gt;
std::unique_ptr&lt;To&gt; move_cast(std::unique_ptr&lt;From&gt;&amp; p) {
#ifndef NDEBUG
 auto p1 =
   std::unique_ptr&lt;To&gt;(dynamic_cast&lt;To*&gt;(p.release()));
 assert(p1);
 return p1;
#else
 return std::unique_ptr&lt;To&gt;(static_cast&lt;To*&gt;(p.release()));
#endif
}</pre>
<p>If all objects will be owned by instances of a unique pointer, then the <code>VeteranUnit</code> decorator has to accept a pointer in its constructor and move the object out of this pointer:</p>
<pre class="source-code">
// Example 04
template &lt;typename U&gt; class VeteranUnit : public U {
  public:
  template &lt;typename P&gt;
  VeteranUnit(P&amp;&amp; p,
              double strength_bonus,
              double armor_bonus) :
    U(std::move(*move_cast&lt;U&gt;(p))),
    strength_bonus_(strength_bonus),
    armor_bonus_(armor_bonus) {}
  double attack() { return U::attack() + strength_bonus_; }
  double defense() { return U::defense() + armor_bonus_; }
  private:
  double strength_bonus_;
  double armor_bonus_;
};</pre>
<p>The tricky part here is<a id="_idIndexMarker899"/> in the initialization of the base class <code>U</code> of <code>VeteranUnit&lt;U&gt;</code> - we have to move the unit from a unique pointer to the base class into a move-constructor of the derived class (there is no way to simply move the object from one unique pointer to another; we need to wrap it into the derived class). We have to do this without leaking any memory, too. The original, unique pointer, is released, so its destructor will do nothing, but our <code>move_cast</code> returns a new unique pointer that now owns the same object. This unique pointer is a temporary variable and will be deleted at the end of the initialization of the new object, but not before we use its object to construct a new derived object that is a <code>VeteranUnit</code> (the move-initialization of the unit object itself does not save any time versus copy in our case, but it is a good practice in the event a more heavyweight unit object provides an optimized move constructor).</p>
<p>Here is how this new decorator is used in a program that manages resources (units, in our case) by unique pointers:</p>
<pre class="source-code">
// Example 04
Knight_ptr k(new Knight(10, 5));
  // Knight_ptr so we can call charge()
Unit_ptr o(new Ogre(12, 2));
  // Could be Orge_ptr if we needed one
Knight_ptr vk(new VeteranUnit&lt;Knight&gt;(k, 7, 2));
Unit_ptr vo(new VeteranUnit&lt;Ogre&gt;(o, 1, 9));
Unit_ptr vvo(new VeteranUnit&lt;VeteranUnit&lt;Ogre&gt;&gt;(vo, 1, 9));
vk-&gt;hit(*vvo); // Miss
vk-&gt;charge(); // Works because vk is Knight_ptr
vk-&gt;hit(*vvo); // Hit</pre>
<p>Note that we did not redefine the <code>hit()</code> function - it still accepts a unit object by reference. This is correct because this function does not take ownership of the object - it merely operates on it. There is no need to pass an owning pointer into it - that would suggest a transfer of ownership.</p>
<p>Note that, strictly <a id="_idIndexMarker900"/>speaking, there is very little difference between this example and the last one - the moved-from unit should not be accessed either way. Practically speaking, there is a significant difference - the moved-from pointer no longer owns the object. Its value is null, so any attempt to operate on the original unit after it was promoted will become evident in very short order (the program will dereference a null pointer and crash).</p>
<p>As we have seen, we can decorate an already decorated class, as the effects of the decorators stack up. Similarly, we can apply two different decorators to the same class. Each decorator adds a particular new behavior to the class. In our game engine, we can print the results of each attack, whether or not there was a hit. But if the result does not match the expectations, we don’t know why. For debugging, it might be useful to print the attack and defense values. We would not want to do this all the time for all units, but for the part of the code we are interested in, we could use a debugging decorator that adds new behavior to the units to print the intermediate results of the calculations.</p>
<p>The <code>DebugDecorator</code> uses the same design idea as the previous decorator - it’s a class template that generates a class that’s derived from the object to be decorated. Its <code>attack()</code> and <code>defense()</code> virtual functions forward the calls to the base class and print the results:</p>
<pre class="source-code">
// Example 05
template &lt;typename U&gt; class DebugDecorator : public U {
  public:
  using U::U;
  template &lt;typename P&gt; DebugDecorator(P&amp;&amp; p) :
    U(std::move(*move_cast&lt;U&gt;(p))) {}
  double attack() {
    double res = U::attack();
    cout &lt;&lt; "Attack: " &lt;&lt; res &lt;&lt; endl;
    return res;
  }
  double defense() {
    double res = U::defense();
    cout &lt;&lt; "Defense: " &lt;&lt; res &lt;&lt; endl;
    return res;
  }
};</pre>
<p>In this example, we<a id="_idIndexMarker901"/> left out the dynamic memory allocations and relied on moving the objects themselves for ownership transfer. There is no reason we cannot have both stackable decorators and unique pointers:</p>
<pre class="source-code">
// Example 06
template &lt;typename U&gt; class VeteranUnit : public U {
  ...
};
template &lt;typename U&gt; class DebugDecorator : public U {
  using U::U;
  public:
  template &lt;typename P&gt;
  DebugDecorator(std::unique_ptr&lt;P&gt;&amp; p) :
    U(std::move(*move_cast&lt;U&gt;(p))) {}
  double attack() override {
    double res = U::attack();
    cout &lt;&lt; "Attack: " &lt;&lt; res &lt;&lt; endl;
    return res;
  }
  double defense() override {
    double res = U::defense();
    cout &lt;&lt; "Defense: " &lt;&lt; res &lt;&lt; endl;
    return res;
  }
  using ptr = std::unique_ptr&lt;DebugDecorator&gt;;
  template &lt;typename... Args&gt;
  static ptr construct(Args&amp;&amp;... args) { return
    ptr{new DebugDecorator(std::forward&lt;Args&gt;(args)...)};
  }
};</pre>
<p>When implementing<a id="_idIndexMarker902"/> decorators, you should be careful to not inadvertently change the behavior of the base class in unexpected ways. For example, consider this possible implementation of <code>DebugDecorator</code>:</p>
<pre class="source-code">
template &lt;typename U&gt; class DebugDecorator : public U {
  double attack() {
    cout &lt;&lt; "Attack: " &lt;&lt; U::attack() &lt;&lt; endl;
    return U::attack();
  }
};</pre>
<p>There is a subtle bug here - the decorated object, in addition to the expected new behavior - the printout - hides a change in the original behavior - it calls <code>attack()</code> twice on the base class. Not only might the printed value be incorrect if two calls to <code>attack()</code> return different values, but also any one-time attack bonuses such as the knight’s charge will be canceled.</p>
<p><code>DebugDecorator</code> adds very similar behavior to each member function it decorates. C++ has a rich<a id="_idIndexMarker903"/> set of tools that are aimed specifically at improving code reuse and reducing duplication. Let’s see if we can do better and come up with a more reusable, uni<a id="_idTextAnchor751"/>v<a id="_idTextAnchor752"/>ersal decorator.</p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor753"/>Polymorphic decorators and their limitations</h2>
<p>Some decorators <a id="_idIndexMarker904"/>are very specific to the classes they <a id="_idIndexMarker905"/>modify, and their behavior is narrowly targeted. Others are very general, at least in principle. For example, a debugging decorator that logs function calls and prints return values could be used with any function if we could only implement it correctly.</p>
<p>Such an implementation is pretty straightforward in C++14 or above using <code>variadic</code> templates, parameter packs, and perfect forwarding:</p>
<pre class="source-code">
// Example 07
template &lt;typename Callable&gt; class DebugDecorator {
  public:
  template &lt;typename F&gt;
  DebugDecorator(F&amp;&amp; f, const char* s) :
    c_(std::forward&lt;F&gt;(f)), s_(s) {}
  template &lt;typename ... Args&gt;
  auto operator()(Args&amp;&amp; ... args) const {
    cout &lt;&lt; "Invoking " &lt;&lt; s_ &lt;&lt; endl;
    auto res = c_(std::forward&lt;Args&gt;(args) ...);
    cout &lt;&lt; "Result: " &lt;&lt; res &lt;&lt; endl;
    return res;
  }
  private:
  Callable c_;
  const std::string s_;
};</pre>
<p>This decorator can be wrapped around any callable object or function (anything that can be called with the <code>()</code> syntax) with any number of arguments. It prints the custom string and the result of the call. However, writing out the callable type is often tricky - it is much better to get the compiler to do it for us using template argument deduction:</p>
<pre class="source-code">
// Example 07
template &lt;typename Callable&gt;
  auto decorate_debug(Callable&amp;&amp; c, const char* s) {
  return DebugDecorator&lt;Callable&gt;(
    std::forward&lt;Callable&gt;(c), s);
}</pre>
<p>This template<a id="_idIndexMarker906"/> function<a id="_idIndexMarker907"/> deduces the type of the <code>Callable</code> and decorates it with the debugging wrapper. We can now apply it to any function or object. Here is a decorated function:</p>
<pre class="source-code">
// Example 07
int g(int i, int j) { return i - j; } // Some function
auto g1 = decorate_debug(g, "g()"); // Decorated function
g1(5, 2); // Prints "Invoking g()" and "Result: 3"</pre>
<p>We can also decorate a callable object:</p>
<pre class="source-code">
// Example 07
struct S {
  double operator()() const {
    return double(rand() + 1)/double(rand() + 1);
  }
};
S s; // Callable
auto s1 =
  decorate_debug(s, "rand/rand"); // Decorated callable
s1(); s1(); // Prints the result, twice</pre>
<p>Note that our decorator does not take ownership of the callable object (we could write it in such a way that it does so if we wanted to).</p>
<p>We can even decorate a lambda expression, which is really just an implicitly typed callable object. The<a id="_idIndexMarker908"/> one<a id="_idIndexMarker909"/> in this example defines a callable object with two integer arguments:</p>
<pre class="source-code">
// Example 07
auto f2 = decorate_debug(
  [](int i, int j) { return i + j; }, "i+j");
f2(5, 3); // Prints "Invoking i+j" and "Result: 8"</pre>
<p>In our example, we decided to forward the callables both in the decorator class constructor and in the helper function. Often, the callables are passed by value instead and are assumed to be cheap to copy. In all cases, it is important that the decorator stores a copy of the callable in its data member. If you capture it by reference instead, there is a subtle error waiting to happen:</p>
<pre class="source-code">
template &lt;typename Callable&gt; class DebugDecorator {
  public:
  DebugDecorator(const Callable&amp; c, const char* s) :
    c_(c), s_(s) {}
  ...
  private:
  const Callable&amp; c_;
  const std::string s_;
};</pre>
<p>Decorating a function is likely to work fine, but decorating a lambda will fail (although not necessarily in an immediately visible way). The <code>const Callable&amp; c_</code> member is going to be bound to a temporary lambda object:</p>
<pre class="source-code">
auto f2 = decorate_debug(
  [](int i, int j) { return i + j; }, "i+j");</pre>
<p>The lifetime of this object ends at the semicolon at the end of this statement, and any subsequent use of <code>f2</code> accesses a dangling reference (address sanitizer tools can help detect such errors).</p>
<p>Our decorator has some limitations. First, it falls short when we try to decorate a function that<a id="_idIndexMarker910"/> does <a id="_idIndexMarker911"/>not return anything, such as the following lambda expression, which increments its argument but returns nothing:</p>
<pre class="source-code">
auto incr = decorate_debug([](int&amp; x) { ++x; }, "++x");
int i;
incr(i); // Does not compile</pre>
<p>The problem lies with the <code>void res</code> expression that is coming from the <code>auto res = ...</code> line inside the <code>DebugDecorator</code>. This makes sense since we cannot declare variables of the <code>void</code> type. This problem can be solved using <code>if constexpr</code> in C++17:</p>
<pre class="source-code">
// Example 08
template &lt;typename Callable&gt; class DebugDecorator {
  public:
  ...
  template &lt;typename... Args&gt;
  auto operator()(Args&amp;&amp;... args) const {
    cout &lt;&lt; "Invoking " &lt;&lt; s_ &lt;&lt; endl;
    using r_t = decltype(c_(std::forward&lt;Args&gt;(args)...));
    if constexpr (!std::is_same_v&lt;res_t, void&gt;) {
      auto res = c_(std::forward&lt;Args&gt;(args)...);
      cout &lt;&lt; "Result: " &lt;&lt; res &lt;&lt; endl;
      return res;
    } else {
      c_(std::forward&lt;Args&gt;(args)...);
    }
  }
    private:
    Callable c_;
    const std::string s_;
};</pre>
<p>Before C++17, the most <a id="_idIndexMarker912"/>common alternative to if constexpr uses<a id="_idIndexMarker913"/> function overloading (the first argument is <code>std::true_type</code> or <code>std::false_type</code> depending on the branch of if constexpr provided by the corresponding function):</p>
<pre class="source-code">
// Example 08a
template &lt;typename Callable&gt; class DebugDecorator {
  public:
  ...
  template &lt;typename... Args&gt;
  auto operator()(Args&amp;&amp;... args) const {
    cout &lt;&lt; "Invoking " &lt;&lt; s_ &lt;&lt; endl;
    using r_t = decltype(c_(std::forward&lt;Args&gt;(args)...));
    return this-&gt;call_impl(std::is_same&lt;res_t, void&gt;{},
                           std::forward&lt;Args&gt;(args)...);
    }
    private:
    Callable c_;
    const std::string s_;
    template &lt;typename... Args&gt;
    auto call_impl(std::false_type, Args&amp;&amp;... args) const {
      auto res = c_(std::forward&lt;Args&gt;(args)...);
      cout &lt;&lt; "Result: " &lt;&lt; res &lt;&lt; endl;
      return res;
    }
    template &lt;typename... Args&gt;
    void call_impl(std::true_type, Args&amp;&amp;... args) const {
      c_(std::forward&lt;Args&gt;(args)...);
  }
};</pre>
<p>The second limitation <a id="_idIndexMarker914"/>is <a id="_idIndexMarker915"/>that the <code>auto</code> return type of our decorator is deduced only <em class="italic">mostly</em> accurately - for example, if a function returns <code>double&amp;</code>, the decorated function will return just <code>double</code>. Lastly, wrapping member function calls is possible, but requires a somewhat different syntax.</p>
<p>Now, the template mechanism in C++ is powerful, and there are ways to make our generic decorator even more generic. These ways also make it more complex. Code like this belongs in a library, such as the standard library, but in most practical applications a debugging decorator is not worth such effort.</p>
<p>The other limitation is that the more generic a decorator becomes, the less it can do. As it is, there are very few actions we could take that make sense for calling any function or member function (even to produce a good debug message in our decorator we might need to use compiler extensions, see <em class="italic">Example 09</em>). We could add some debug printouts, and print the result as long as it has the stream output operator defined. We could lock a mutex to protect a non-thread-safe function call in a multi-threaded program. Maybe there are a few more general actions. But, in general, do not get seduced by the pursuit of the most generic code for its own sake.</p>
<p>Whether we have somewhat generic or very specific decorators, we often have the need to add<a id="_idIndexMarker916"/> multiple<a id="_idIndexMarker917"/> behaviors to an object. We have seen one such example already. Now, let’s review the problem of applying multiple <a id="_idTextAnchor754"/>d<a id="_idTextAnchor755"/>ecorators more systematically.</p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor756"/>Composable decorators</h2>
<p>The decorator<a id="_idIndexMarker918"/> property that we would like to have here has a name  composability. Behaviors are composable if they can be applied to the same object separately: in our case, if we have two decorators, <code>A</code> and <code>B</code>. Therefore, <code>A(B(object))</code> should have both behaviors applied. The alternative to composability is the explicit creation of the combined behaviors: to have both behaviors without composability, we would need to write a new decorator, <code>AB</code>. Since writing new code for any combination of several decorators would be impossible even for a relatively small number of decorators, composability is a very important property.</p>
<p>Fortunately, composability is not hard to achieve with our approach to decorators. The CRTP decorators we used in our game design earlier are naturally composable:</p>
<pre class="source-code">
template &lt;typename U&gt; class VeteranUnit : public U { ... };
template &lt;typename U&gt; class DebugDecorator : public U { ...
};
Unit_ptr o(new DebugDecorator&lt;Ogre&gt;(12, 2));
Unit_ptr vo(new DebugDecorator&lt;VeteranUnit&lt;Ogre&gt;&gt;(o, 1, 9));</pre>
<p>Each decorator inherits from the object it decorates and, thus, preserves its interface, except for the added behavior. Note that the order of the decorators matters since the new behavior is added before or after the decorated call. <code>DebugDecorator</code> applies to the object it decorates and provides debugging for it, so a <code>VeteranUnit&lt;DebugDecorator&lt;Ogre&gt;&gt;</code> object would debug the base portion of the object (<code>Ogre</code>), which can be useful as well.</p>
<p>Our (somewhat) universal decorators can be composed as well. We already have a debugging decorator that can work with many different callable objects, and we mentioned a possible need to protect these calls with a mutex. We can now implement such a locking decorator in a similar manner (and with similar limitations) to the polymorphic <a id="_idIndexMarker919"/>debugging decorator:</p>
<pre class="source-code">
// Example 10
template &lt;typename Callable&gt; class LockDecorator {
  public:
  template &lt;typename F&gt;
  LockDecorator(F&amp;&amp; f, std::mutex&amp; m) :
    c_(std::forward&lt;F&gt;(f)), m_(m) {}
  template &lt;typename ... Args&gt;
  auto operator()(Args&amp;&amp; ... args) const {
    std::lock_guard&lt;std::mutex&gt; l(m_);
    return c_(std::forward&lt;Args&gt;(args) ...);
  }
  private:
  Callable c_;
  std::mutex&amp; m_;
};
template &lt;typename Callable&gt;
auto decorate_lock(Callable&amp;&amp; c, std::mutex&amp; m) {
  return
    LockDecorator&lt;Callable&gt;(std::forward&lt;Callable&gt;(c), m);
}</pre>
<p>Again, we will use the <code>decorate_lock()</code> helper function to delegate to the compiler the tedious work of figuring out the right type of the callable object. We can now use a mutex to protect a function call that is not thread-safe:</p>
<pre class="source-code">
std::mutex m;
auto safe_f = decorate_lock([](int x) {
  return unsafe_f(x); }, m
);</pre>
<p>If we want to protect a function by a mutex and have a debug printout when it’s called, we do not need to write a new <em class="italic">locking debugging decorator,</em> but instead can apply both decorators in sequence:</p>
<pre class="source-code">
auto safe_f = decorate_debug(
  decorate_lock(
    [](int x) { return unsafe_f(x); },
    m
  ),
  "f(x)");</pre>
<p>This example demonstrates the benefits of composability - we do not have to write a special <a id="_idIndexMarker920"/>decorator for every combination of behaviors (think how many decorators you would have to write for any combination of five different primary decorators if they were not composable!).</p>
<p>This composability is achieved easily in our decorators because they preserve the interface of the original object, at least the part we are interested in - the behavior changes, but the interface does not. When a decorator is used as an original object for another decorator, the preserved interface is once again preserved, and so on.</p>
<p>This preservation of the interface is a fundamental feature of the Decorator pattern. It is also one of its most serious limitations. Our locking decorator is not nearly as useful as it may seem at first glance (so do not go around your code bolting a lock onto every call when you need to <a id="_idIndexMarker921"/>make the code thread-safe). As we will see next, not every interface can be made thread-safe, no matter how good the implementation is. That’s when we have to change the interface in a<a id="_idTextAnchor757"/>ddition to modifying the behavior. This i<a id="_idTextAnchor758"/>s the job for the Adapter pattern.</p>
<h1 id="_idParaDest-291"><a id="_idTextAnchor759"/>The Adapter pattern</h1>
<p>We ended the last<a id="_idIndexMarker922"/> section with the notion that the decorator pattern has particular advantages that come from preserving the decorated interface and that these advantages can sometimes turn into limitations. The Adapter pattern is a more general pattern that can be used in such cases.</p>
<p>The Adapter pattern is defined very generally - it is a structural pattern that allows an interface of a class to be used as another, different interface. It allows an existing class to be used in code that expects a different interface, without modifying the original class. Such adapters are sometimes <a id="_idIndexMarker923"/>called <strong class="bold">class wrappers</strong> since they <em class="italic">wrap</em> around a class and present a different interface. You may recall that decorators are also sometimes called <strong class="bold">class wrappers</strong>, much for the same reason.</p>
<p>However, Adapter is a very general, broad pattern. It can be used to implement several other, more narrowly defined patterns - in particular, the decorator. The decorator pattern is easier to follow, so we dealt with that first. Now,<a id="_idTextAnchor760"/> <a id="_idTextAnchor761"/>we will move on to the general case.</p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor762"/>Basic Adapter pattern</h2>
<p>Let’s follow on from the final example from the last section - the locking decorator. It calls any function under a lock, so no other function protected by the same mutex can be called on any other thread at the same time. In some cases, this could be enough to make the entire code thread-safe. Often, it is not.</p>
<p>To demonstrate this, we are going to implement a thread-safe queue object. A queue is a moderately complex data structure, even without thread safety, but, fortunately, we do not need to start from scratch - we have <code>std::queue</code> in the C++ standard library. We can push objects onto the queue and take them from the queue in first-in-first-out order, but only on one thread - it is not safe to push two objects onto the same queue from two different threads at the same time, for example. But we have a solution for that - we can implement a locking queue as a decorator for the basic one. Since we are not concerned about the empty base optimization here (<code>std::queue</code> is not an empty class) and we have to forward every member function call, we do not need the inheritance and can use composition instead. Our decorator will contain the queue and the lock. Wrapping the <code>push()</code> method is easy. There are two versions of <code>push()</code> in <code>std::queue</code> - one moves the object and one copies it. We should protect both with the lock:</p>
<pre class="source-code">
// Example 11
template &lt;typename T&gt; class locking_queue {
  using mutex = std::mutex;
  using lock_guard = std::lock_guard&lt;mutex&gt;;
  using value_type = typename std::queue&lt;T&gt;::value_type;
  void push(const value_type&amp; value) {
    lock_guard l(m_);
    q_.push(value);
  }
  void push(value_type&amp;&amp; value) {
    lock_guard l(m_);
    q_.push(value);
  }
  private:
  std::queue&lt;T&gt; q_;
  mutex m_;
};</pre>
<p>Now, let’s turn our <a id="_idIndexMarker924"/>attention to getting elements off the queue. The standard queue has three relevant member functions - first, there is <code>front()</code>, which lets us access the front element of the queue, but does not remove it from the queue. Then, there is <code>pop()</code>, which removes the front element but returns nothing (it gives no access to the front element - it just removes it). Both of these functions should not be called if the queue is empty - there is no error checking, but the result is undefined.</p>
<p>Finally, there is the third function, <code>empty()</code>; it returns false if the queue is not empty, and then we can call <code>front()</code> and <code>pop()</code>. If we decorate them with locking, we will be able to write code like the following:</p>
<pre class="source-code">
locking_queue&lt;int&gt; q;
q.push(5);
... sometime later in the program ...
if (!q.empty()) {
  int i = q.front();
  q.pop();
}</pre>
<p>Each function is thread-safe by itself. The entire combination of them is not. It is important to understand why. First, we call <code>q.empty()</code>. Let’s assume that it returns <code>false</code>, so we know there is at least one element on the queue. We go on to access it on the next line by calling <code>q.front()</code>, which returns <code>5</code>. But this is just one of many threads in the program. Another thread is going through the same code at the same time (enabling this behavior is the point of the exercise). That thread, too, calls <code>q.empty()</code> and also gets <code>false</code> - as we just said, there is an element in the queue, and we have done nothing to remove it yet. The second thread also calls <code>q.front()</code> and gets <code>5</code> as well. That is already a problem - two threads each tried to take an element from the queue, but got the same one instead. But it gets worse - our first thread now calls <code>q.pop()</code> and removes <code>5</code> from the queue. The queue is now empty, but the second thread does not know about this - it called <code>q.empty()</code> earlier. Therefore, the second thread now calls <code>q.pop()</code> as well, this time on an empty queue. The best-case scenario here is that the program will crash right away.</p>
<p>We have just seen a<a id="_idIndexMarker925"/> specific case of a general problem - a sequence of actions, each of which is thread-safe, but is not thread-safe as a whole. In fact, this <em class="italic">locking queue</em> is entirely useless, and there is no way to write thread-safe code with it. What we need is a single thread-safe function that performs the entire transaction under one lock, as a single uninterruptible action (such transactions are called <code>std::queue</code> interface does not provide such a transactional API.</p>
<p>So, now, we need a new pattern - one that transforms the existing interface of a class to our needs for a different interface. This cannot be done with the decorator pattern, but this is exactly the problem that the Adapter pattern solves. Now that we have agreed that we need a different interface, we just have to decide what it should be. Our single new <code>pop()</code> member function should do all of this - if the queue is not empty, it should remove the first element from the queue and return it, by copy or move, to the caller. If the queue is empty, it should not alter the state of the queue at all, but should somehow notify the caller that the queue was empty. One way to do this is to return two values - the element itself (if there is one) and a Boolean value that tells us whether the queue was empty or not. Here is the <code>pop()</code> part of the locking queue, which is now an adapter, not a decorator:</p>
<pre class="source-code">
// Example 11
template &lt;typename T&gt; class locking_queue {
  ... the push() is unchanged ...
  bool pop(value_type&amp; value) {
    lock_guard l(m_);
    if (q_.empty()) return false;
    value = std::move(q_.front());
    q_.pop();
    return true;
  }
  private:
  std::queue&lt;T&gt; q_;
  mutex m_;
};</pre>
<p>Note that we do<a id="_idIndexMarker926"/> not need to change <code>push()</code> - the single function call already does everything we need, so that part of the interface is just forwarded one-to-one by our adapter. This version of <code>pop()</code> returns <code>true</code> if it removed an element from the queue, and <code>false</code> otherwise. If <code>true</code> is returned, the element is saved into the provided argument, but if <code>false</code> is returned, the argument is unchanged. If the element type <code>T</code> is move-assignable, a move will be used instead of copy.</p>
<p>This is, of course, not the only possible interface for such an atomic <code>pop()</code>. Another way would be to return both the element and the Boolean value as a pair. One significant difference is that there is now no way to leave the element unchanged - it’s the return value and it always has to be something. The natural way is to default-construct the element if there isn’t one on the queue (which implies a restriction on the element type <code>T</code> - it has to be default-constructible).</p>
<p>In C++17, the better alternative is to return a <code>std::optional</code>:</p>
<pre class="source-code">
// Example 12
template &lt;typename T&gt; class locking_queue {
  ... the push() is unchanged ...
  std::optional&lt;value_type&gt; pop() {
    lock_guard l(m_);
    if (q_.empty()) return std::nullopt;
    value_type value = std::move(q_.front());
    q_.pop();
    return { value };
  }
};</pre>
<p>Depending on the application code that needs this queue, one of the interfaces may be preferable, and so there are other ways to design it as well. In all cases, we end up with two member functions, <code>push()</code> and <code>pop()</code>, that are protected by the same mutex. Now, any number of threads can execute any combination of these operations at the same time, and the behavior is well-defined. This means that the <code>locking_queue</code> object is thread-safe.</p>
<p>Converting an object from its current interface to the interface needed by a particular application, without <a id="_idIndexMarker927"/>rewriting the object itself, is the purpose and use of the Adapter pattern. All kinds of interfaces may have to be converted, and so there are many different types of adapters. We will lear<a id="_idTextAnchor763"/>n<a id="_idTextAnchor764"/> about some of them in the next section.</p>
<h2 id="_idParaDest-293"><a id="_idTextAnchor765"/>Function adapters</h2>
<p>We have<a id="_idIndexMarker928"/> just seen <a id="_idIndexMarker929"/>a class adapter that changes the interface of a class. Another kind of interface is a function (a member or a non-member function). A function has certain arguments, but we may want to call it with a different set of arguments. This would need an adapter. One common application of such adapters is known as currying one (or more) of the function’s arguments. All it means is that we have a function of several arguments, and we fix the value of one of these arguments, so we don’t have to specify it on every call. One example would be if we have <code>f(int i, int j)</code>, but we want <code>g(i)</code>, which is the same as <code>f(i, 5)</code>, only without typing the <code>5</code> every time.</p>
<p>Here is a more interesting example that we are actually going to work our way through and implement an adapter. The <code>std::sort</code> function takes an iterator range (the sequence to sort), but it can also be called with three arguments - the third one is the comparison object (by default, <code>std::less</code> is used, which, in turn, calls <code>operator&lt;()</code> on the objects being sorted).</p>
<p>We want something else now - we want to compare floating-point numbers <em class="italic">fuzzily</em>, with tolerance - if the two numbers <code>x</code> and <code>y</code> are close enough to each other, then we don’t consider one to be less than the other. Only when <code>x</code> is much less than <code>y</code> do we want to enforce the sorted order where <code>x</code> comes before <code>y</code>.</p>
<p>Here is our<a id="_idIndexMarker930"/> comparison<a id="_idIndexMarker931"/> functor (a callable object):</p>
<pre class="source-code">
// Example 13
struct much_less {
  template &lt;typename T&gt;
  bool operator()(T x, T y) {
    return x &lt; y &amp;&amp; std::abs(x - y) &gt; tolerance);
  }
  static constexpr double tolerance = 0.2;
};</pre>
<p>This comparison object can be used with a standard sort:</p>
<pre class="source-code">
std::vector&lt;double&gt; v;
std::sort(v.begin(), v.end(), much_less());</pre>
<p>However, if we need this kind of sort often, we may want to curry the last argument and make ourselves an adapter that has just two arguments, the iterators, and the sorting function implied. Here is such an adapter - it is very simple:</p>
<pre class="source-code">
// Example 13
template&lt;typename RandomIt&gt;
  void sort_much_less(RandomIt first, RandomIt last) {
  std::sort(first, last, much_less());
}</pre>
<p>Now, we can call a sort function with two arguments:</p>
<pre class="source-code">
// Example 13
std::vector&lt;double&gt; v;
sort_much_less(v.begin(), v.end());</pre>
<p>Now, if we often call sort in this manner to sort the entire container, we may want to change the interface once again and make another adapter:</p>
<pre class="source-code">
// Example 14
template&lt;typename Container&gt; void sort_much_less(Container&amp;
   c) {
std::sort(c.begin(), c.end(), much_less());
}</pre>
<p>In C++20, <code>std::sort</code> and other STL functions have variants that accept ranges; they are a<a id="_idIndexMarker932"/> generalization <a id="_idIndexMarker933"/>of our container adapter. Now, the code in our program looks even simpler:</p>
<pre class="source-code">
// Example 14
std::vector&lt;double&gt; v;
sort_much_less(v);</pre>
<p>It is important to point out that C++14 provides an alternative for writing such simple adapters that should, in general, be preferred; we can use a lambda expression, as follows:</p>
<pre class="source-code">
// Example 15
auto sort_much_less = [](auto first, auto last) {
  return std::sort(first, last, much_less());
};</pre>
<p>Of course, the comparison function much_less() is itself a callable, so it could be a lambda too:</p>
<pre class="source-code">
// Example 15a
auto sort_much_less = [](auto first, auto last) {
  return std::sort(first, last,
    [](auto x, auto y) {
      static constexpr double tolerance = 0.2;
      return x &lt; y &amp;&amp; std::abs(x - y) &gt; tolerance;
    }); };</pre>
<p>The container adapter is just as easy to write:</p>
<pre class="source-code">
// Example 16
auto sort_much_less = [](auto&amp; container) {
  return std::sort(container.begin(), container.end(),
                   much_less());
};</pre>
<p>Note that you<a id="_idIndexMarker934"/> cannot <a id="_idIndexMarker935"/>have both of these in the same program under the same name - lambda expressions cannot be <em class="italic">overloaded</em> in this manner; they are actually not functions at all, but rather objects (you can create an overload set from lambdas, as was shown in <a href="B19262_02.xhtml#_idTextAnchor043"><em class="italic">Chapter 2</em></a><em class="italic">, Class and </em><em class="italic">Function Templates</em>).</p>
<p>Coming back to the matter of calling a function with some arguments fixed, or bound, to constant values, we should say that this is such a common need that the C++ standard library provides a standard customizable adapter for this purpose, <code>std::bind</code>. <a id="_idTextAnchor766"/>Here is an example that shows us how it is used:</p>
<pre class="source-code">
// Example 17
using namespace std::placeholders; // For _1, _2 etc
int f3(int i, int j, int k) { return i + j + k; }
auto f2 = std::bind(f3, _1, _2, 42);
auto f1 = std::bind(f3, 5, _1, 7);
f2(2, 6);     // Returns 50
f1(3);     // Returns 15</pre>
<p>This standard adapter has its own <em class="italic">mini-language</em> - the first argument to <code>std::bind</code> is the function to be bound, while the rest are its arguments, in order. The arguments that should be bound are replaced by the specified values. The arguments that should remain free are replaced by the placeholders <code>_1</code>, <code>_2</code>, and so on (not necessarily in that order; that is, we can also change the order of the arguments). The returned value is of an unspecified type and has to be captured using <code>auto</code>. The only thing we know about the return value is that it can be called as a function with as many arguments as there are placeholders. It can also be used as a function in any context that expects a callable, for example, in another <code>std::bind</code>:</p>
<pre class="source-code">
// Example 17
...
auto f1 = std::bind(f3, 5, _1, 7);
auto f0 = std::bind(f1, 3);
f1(3);    // Returns 15
f0();         // Also returns 15</pre>
<p>However, these<a id="_idIndexMarker936"/> objects <a id="_idIndexMarker937"/>are callables, not functions, and you will discover that if you try to assign one of them to a function pointer:</p>
<pre class="source-code">
// Example 17
int (*p3)(int, int, int) = f3;    // OK
int (*p1)(int) = f1;            // Does not compile</pre>
<p>In contrast, lambdas can be converted to function pointers if they have no captures:</p>
<pre class="source-code">
auto l1 = [](int i) { return f3(5, i, 7); }
int (*p1)(int) = l1;            // OK</pre>
<p>As useful as <code>std::bind</code> is, it does not free us from the need to learn how to write our own function adapters - its greatest limitation is that <code>std::bind</code> cannot bind template functions. We cannot write the following:</p>
<pre class="source-code">
auto sort_much_less = std::bind(std::sort, _1, _2, much_less()); // No!</pre>
<p>This does not compile. Inside a template, we can bind the specific instantiation of it, but, at least in our sorting example, this really does not buy us anything:</p>
<pre class="source-code">
template&lt;typename RandomIt&gt;
void sort_much_less(RandomIt first, RandomIt last) {
  auto f = std::bind(std::sort&lt;RandomIt, much_less&gt;,
                     _1, _2, much_less());
  f(first, last, much_less());
}</pre>
<p>As we mentioned at the beginning of this section, decorators can be seen as a special case of the <a id="_idIndexMarker938"/>Adapter<a id="_idIndexMarker939"/> pattern. Sometimes, the distinction is not so much in a particular application of the pattern but in how we choose to view it.</p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor767"/>Adapter or Decorator</h2>
<p>Until now, we<a id="_idIndexMarker940"/> described <a id="_idIndexMarker941"/>the Decorator as a pattern we use to augment an existing interface, while the Adapter is used to convert (adapt) an interface for integration with code that expects a different interface. The distinction is not always clear.</p>
<p>For example, let us consider a simple class that adapts the result of the system call <code>std::time</code> to a printable date format (<code>std::chrono</code> provides this functionality, but it makes for an easy-to-follow example). The function <code>std::time</code> returns a value of the type <code>std::time_t</code> which is an integer containing the time in seconds since some standard moment in the past that is called the “start of the epoch.” Another system function, <code>localtime</code>, converts this value to a struct that contains the date elements: year, month, and day (also hours, minutes, etc). The calendar calculations, in general, are rather non-trivial (which is why <code>std::chrono</code> is not as simple as we might wish) but for now, let us assume that the system library does the right thing and all we have to do is print the date in the right format. For example, here is how to print the current date in the US format:</p>
<pre class="source-code">
const std::time_t now = std::time(nullptr);
const tm local_tm = *localtime(&amp;now);
cout &lt;&lt; local_tm.tm_mon + 1 &lt;&lt; "/" &lt;&lt;
        local_tm.tm_mday &lt;&lt; "/" &lt;&lt;
        local_tm.tm_year + 1900;</pre>
<p>We want to create an adapter that converts a time in seconds to the date in a particular format and lets us print it; we will need separate adapters for the US format (month first), European format (day first), and ISO format (year first).</p>
<p>The implementation<a id="_idIndexMarker942"/> of<a id="_idIndexMarker943"/> the adapter is pretty straightforward:</p>
<pre class="source-code">
// Example 18
class USA_Date {
  public:
  explicit USA_Date(std::time_t t) : t_(t) {}
  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                                  const USA_Date&amp; d) {
    const tm local_tm = *localtime(&amp;d.t_);
    out &lt;&lt; local_tm.tm_mon + 1 &lt;&lt; "/" &lt;&lt;
           local_tm.tm_mday &lt;&lt; "/" &lt;&lt;
           local_tm.tm_year + 1900;
    return out;
  }
  private:
  const std::time_t t_;
};</pre>
<p>The other two date formats are similar except for the order in which we print the fields. In fact, they are so similar that we may want to refactor the code to avoid typing three almost identical classes. The easiest way to do this is to use a template and encode the field order in a “format code” which specifies the order in which we print the day (field 0), month (field 1), and year (field 2). For example, “format” 210 means year, then month, then day – the ISO <a id="_idIndexMarker944"/>date<a id="_idIndexMarker945"/> format. The format code can be an integer template parameter:</p>
<pre class="source-code">
// Example 19
template &lt;size_t F&gt; class Date {
  public:
  explicit Date(std::time_t t) : t_(t) {}
  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                                  const Date&amp; d) {
    const tm local_tm = *localtime(&amp;d.t_);
    const int t[3] = { local_tm.tm_mday,
                       local_tm.tm_mon + 1,
                       local_tm.tm_year + 1900 };
    constexpr size_t i1 = F/100;
    constexpr size_t i2 = (F - i1*100)/10;
    constexpr size_t i3 = F - i1*100 - i2*10;
    static_assert(i1 &gt;= 0 &amp;&amp; i1 &lt;= 2 &amp;&amp; ..., "Bad format");
    out &lt;&lt; t[i1] &lt;&lt; "/" &lt;&lt; t[i2] &lt;&lt; "/" &lt;&lt; t[i3];
    return out;
  }
  private:
  const std::time_t t_;
};
using USA_Date = Date&lt;102&gt;;
using European_Date = Date&lt;12&gt;;
using ISO_Date = Date&lt;210&gt;;</pre>
<p>Our little wrapper adapts a type (an integer) to be used in the code that expects dates in a particular format. Or does it decorate the integer with the <code>operator&lt;&lt;()</code>? The best answer is … whichever one is more helpful to you to think about your particular problem. It is important to remember the purpose of speaking in the language of the patterns in the first place: we do it to have a compact and commonly understood way to describe our software problems and the solutions we choose. When multiple patterns appear to yield similar results, the description you choose lets you focus on the aspect that is most important to you.</p>
<p>So far, we have considered only adapters that convert runtime interfaces, which are the interfaces we call when the program is executed. However, C++ has compile-time interfaces as well - one of the prime examples that we considered in the last chapter was policy-based <a id="_idIndexMarker946"/>design. These <a id="_idIndexMarker947"/>interfaces are not always exactly what we need them to<a id="_idTextAnchor768"/> <a id="_idTextAnchor769"/>be, so we have to learn to write compile-time adapters next.</p>
<h2 id="_idParaDest-295"><a id="_idTextAnchor770"/>Compile-time adapters</h2>
<p>In <a href="B19262_16.xhtml#_idTextAnchor739"><em class="italic">Chapter 16</em></a>,<em class="italic"> Adapters and Decorators</em>, we learned about policies, which are building blocks for<a id="_idIndexMarker948"/> classes - they let the programmer<a id="_idIndexMarker949"/> customize the implementation for a particular behavior. As an example, we can implement this policy-based smart pointer that automatically deletes the object it owns. The policy is the particular implementation of the deletion:</p>
<pre class="source-code">
// Chapter 15, Example 08
template &lt;typename T,
          template &lt;typename&gt; class DeletionPolicy =
                                    DeleteByOperator&gt;
class SmartPtr {
  public:
  explicit SmartPtr(T* p = nullptr,
    const DeletionPolicy&lt;T&gt;&amp; del_policy =
                             DeletionPolicy&lt;T&gt;())
  : p_(p), deletion_policy_(deletion_policy)
  {}
  ~SmartPtr() {
    deletion_policy_(p_);
  }
  ... pointer interface ...
  private:
  T* p_;
  DeletionPolicy&lt;T&gt; deletion_policy_;
};</pre>
<p>Note that the deletion policy is itself a template - this is a <em class="italic">template</em> parameter. The default deletion policy is to use <code>operator delete</code>:</p>
<pre class="source-code">
template &lt;typename T&gt; struct DeleteByOperator {
  void operator()(T* p) const {
    delete p;
  }
};</pre>
<p>However, for<a id="_idIndexMarker950"/> objects<a id="_idIndexMarker951"/> allocated on a user-given heap, we need a different deletion policy that returns the memory to that heap:</p>
<pre class="source-code">
template &lt;typename T&gt; struct DeleteHeap {
  explicit DeleteHeap(MyHeap&amp; heap) : heap_(heap) {}
  void operator()(T* p) const {
    p-&gt;~T();
    heap_.deallocate(p);
  }
  private:
  MyHeap&amp; heap_;
};</pre>
<p>Then we have to create a policy object to use with the pointer:</p>
<pre class="source-code">
MyHeap H;
SmartPtr&lt;int, DeleteHeap&lt;int&gt;&gt; p(new int, H);</pre>
<p>This policy is not very flexible, however - it can handle heaps of only one type - <code>MyHeap</code>. We can make the policy more general if we make the heap type the second template parameter. As long as the heap has the <code>deallocate()</code> member function to return memory to it, we can use any heap class with this policy:</p>
<pre class="source-code">
// Example 20
template &lt;typename T, typename Heap&gt; struct DeleteHeap {
  explicit DeleteHeap(Heap&amp; heap) : heap_(heap) {}
  void operator()(T* p) const {
    p-&gt;~T();
    heap_.deallocate(p);
  }
  private:
  Heap&amp; heap_;
};</pre>
<p>Of course, if we<a id="_idIndexMarker952"/> have <a id="_idIndexMarker953"/>a heap class that uses another name for this member function, we can use a class adapter to make that class work with our policy, too. But we have a larger problem - our policy does not work with our smart pointer. The following code does not compile:</p>
<pre class="source-code">
SmartPtr&lt;int, DeletelHeap&gt; p; // Does not compile</pre>
<p>The reason is again the interface mismatch, only now it is a different kind of interface – the <code>template &lt;typename T, template &lt;typename&gt; class DeletionPolicy&gt; class SmartPtr {};</code> template expects the second argument to be a template with one type parameter. Instead, we have the <code>DeleteHeap</code> template with two type parameters. This is just like trying to call a function that has one parameter but uses two arguments - it won’t work. We need an adapter to convert our two-parameter template into a one-parameter one, and we have to fix the second argument to a particular heap type (but we do not need to rewrite the policy if we have multiple heap types, we just need to write several adapters). We can create this adapter, <code>DeleteMyHeap</code>, using inheritance (and remembering to bring the constructors of the base class into the derived adapter class scope):</p>
<pre class="source-code">
// Example 20
template &lt;typename T&gt;
struct DeleteMyHeap : public DeleteHeap&lt;T, MyHeap&gt; {
  using DeleteHeap&lt;T, MyHeap&gt;::DeleteHeap;
};</pre>
<p>We could do the same using the template alias:</p>
<pre class="source-code">
// Example 21
template &lt;typename T&gt;
using DeleteMyHeap = DeleteHeap&lt;T, MyHeap&gt;;</pre>
<p>This first version is, obviously, much longer. However, we have to learn both ways of writing<a id="_idIndexMarker954"/> template<a id="_idIndexMarker955"/> adapters because the template alias has one major limitation. To illustrate it, let’s consider another example where an adapter is needed. We will begin by implementing a stream insertion operator for any STL-compliant sequence container whose elements have such an operator defined. It is a simple function template:</p>
<pre class="source-code">
// Example 22
template &lt;template &lt;typename&gt; class Container, typename T&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                         const Container&lt;T&gt;&amp; c) {
  bool first = true;
  for (auto x : c) {
  if (!first) out &lt;&lt; ", ";
    first = false;
    out &lt;&lt; x;
  }
  return out;
}</pre>
<p>This <code>template</code> function has two type parameters, the container type and the element type. The container is itself a template with one type parameter. The compiler deduces both the container type and the element type from the second function argument (the first argument in any <code>operator&lt;&lt;()</code> is always the stream). We can test our insertion operator on a simple container:</p>
<pre class="source-code">
// Example 22
template &lt;typename T&gt; class Buffer {
  public:
  explicit Buffer(size_t N) : N_(N), buffer_(new T[N_]) {}
  ~Buffer() { delete [] buffer_; }
  T* begin() const { return buffer_; }
  T* end() const { return buffer_ + N_; }
  ...
  private:
  const size_t N_;
  T* const buffer_;
};
Buffer&lt;int&gt; buffer(10);
... fill the buffer ...
cout &lt;&lt; buffer; // Prints all elements of the buffer</pre>
<p>But this is just <a id="_idIndexMarker956"/>a<a id="_idIndexMarker957"/> toy container and is not very useful. What we really want is to print elements of a real container, such as <code>std::vector</code>:</p>
<pre class="source-code">
std::vector&lt;int&gt; v;
... add some values to v ...
cout &lt;&lt; v;</pre>
<p>Unfortunately, this code does not compile. The reason is that <code>std::vector</code> is not really a template with one type parameter, even though we used it as such. It has two parameters - the second is the allocator type. There is a default for this allocator, which is why we can write <code>std::vector&lt;int&gt;</code> and it compiles. But, even with this default argument, this is still a template with two parameters, while our stream insertion operator is declared to accept container templates with only one parameter. Again, we can solve the problem by writing an adapter (most STL containers are used with the default allocator anyway). The easiest way to write this adapter is with an alias:</p>
<pre class="source-code">
template &lt;typename T&gt; using vector1 = std::vector&lt;T&gt;;
vector1&lt;int&gt; v;
...
cout &lt;&lt; v; // Does not compile either</pre>
<p>Unfortunately, this does not compile either, and now we can show the template alias limitation that we alluded to earlier - template aliases are not used in template argument type deduction. When the compiler attempts to figure out the template argument types for the call of <code>operator&lt;&lt;()</code> with the arguments <code>cout</code> and <code>v</code>, the template <a id="_idIndexMarker958"/>alias <code>vector1</code> is <em class="italic">invisible</em>. In this case, we <a id="_idIndexMarker959"/>have to use a derived class adapter:</p>
<pre class="source-code">
// Example 22
template &lt;typename T&gt;
struct vector1 : public std::vector&lt;T&gt; {
  using std::vector&lt;T&gt;::vector;
};
vector1&lt;int&gt; v;
...
cout &lt;&lt; v;</pre>
<p>By the way, if you paid attention to the previous chapter, you may realize that we already encountered the problem of extra parameters to the template template parameters, and solved it by declaring these parameters as variadic templates:</p>
<pre class="source-code">
// Example 23
template &lt;typename T,
  template &lt;typename, typename...&gt; class Container,
  typename... Args&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                         const Container&lt;T, Args...&gt;&amp; c) {
  ...
}</pre>
<p>Now our <code>operator&lt;&lt;()</code> can print any container, so we no longer need to worry about adapters, right? Not quite: one of the containers we still cannot print is <code>std::array</code> which is a class template with one type and one non-type parameter. We could declare an overload just to handle this case:</p>
<pre class="source-code">
// Example 23
template &lt;typename T,
  template &lt;typename, size_t&gt; class Container, size_t N&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                         const Container&lt;T, N&gt;&amp; c) {
  ...
}</pre>
<p>But we may<a id="_idIndexMarker960"/> have<a id="_idIndexMarker961"/> yet another kind of container that does not fit either of these templates (whether because it has to or simply because it is part of legacy code that was written differently). Then, we have to use an adapter again.</p>
<p>We have now seen how we can implement decorators to augment class and function interfaces with the desired behavior, and how to create adapters when the existing interface is not suitable for a particular application. Decorator, and, even more so, Adapter, are very general and versatile patterns that can be used to solve many problems. It should come as no surprise that, often, a problem can be solved in more than one way, so there is a<a id="_idTextAnchor771"/> <a id="_idTextAnchor772"/>choice of patterns to use. In the next section, we will see one such case.</p>
<h1 id="_idParaDest-296"><a id="_idTextAnchor773"/>Adapter versus policy</h1>
<p>The adapter and<a id="_idIndexMarker962"/> the policy (or strategy) patterns are<a id="_idIndexMarker963"/> some of the more general patterns, and C++ adds generic programming capabilities to these patterns. This tends to extend their usability and sometimes blurs the lines between the patterns. The patterns themselves are defined very distinctly - policies provide custom implementations while adapters change the interface and add functionality to the existing interface (the latter is a decorator aspect, but, as we have seen, most decorators are implemented as adapters). We also saw in the last chapter that C++ broadens the capabilities of policy-based design; in particular, policies in C++ can add or remove parts of the interface as well as control the implementation. So, while patterns are different, there is significant overlap in the types of problems they can be used for. It is instructive to compare the two approaches when a problem is, broadly speaking, amenable to both. For this exercise, we will consider the problem of designing a custom value type.</p>
<p>A value type, to put it simply, is a type that behaves mostly like an <code>int</code>. Often, these types are numbers. While we have a set of built-in types for that, we may want to operate on rational numbers, complex numbers, tensors, matrices, or numbers that have units associated with them (meters, grams, and so on). These value types support a set of operations such as arithmetic operations, comparisons, assignments, and copying. Depending on what the value represents, we may need only a limited subset of these operations - for example, we may need to support addition and multiplication for matrices, but no division, and comparing matrices for anything other than equality probably doesn’t make sense in most cases. Similarly, we probably don’t want to allow the addition of meters to grams.</p>
<p>More generally, there is often a desire to have a numeric type with a limited interface - we would like it if the operations that we do not wish to allow for the quantity represented by such numbers did not compile. This way, a program with an invalid operation simply cannot be written. To be general, our design has to allow us to build the interface piece by piece. For example, we may want a value that is comparable for equality, ordered (has the less-than operation defined), and addable, but without multiplication or division. This seems like a problem that is tailor-made for the Decorator (or, more generally, Adapter) pattern: decorators can add behaviors like comparison operator or addition operator. On the other hand, creating a type with a set of capabilities<a id="_idIndexMarker964"/> configured<a id="_idIndexMarker965"/> by plugging in the right policies is exactly what the Policy pattern is for.</p>
<h2 id="_idParaDest-297"><a id="_idTextAnchor774"/>Adapter solution</h2>
<p>Let us examine the<a id="_idIndexMarker966"/> Adapter solution first. We will start with a basic value type that supports almost nothing in its interface, and then we can add the desired capabilities, one by one.</p>
<p>Here is our initial <code>Value</code> class template:</p>
<pre class="source-code">
// Example 24
template &lt;typename T&gt; class Value {
  public:
  using basic_type = T;
  using value_type = Value;
  explicit Value() : val_(T()) {}
  explicit Value(T v) : val_(v) {}
  Value(const Value&amp;) = default;
  Value&amp; operator=(const Value&amp;) = default;
  Value&amp; operator=(basic_type rhs) {
    val_ = rhs;
    return *this;
  }
  protected:
  T val_ {};
};</pre>
<p>The <code>Value</code> is copyable and assignable, both from the underlying type such as <code>int</code> and from another <code>Value</code>. We could have moved some of those capabilities into adapters as well if we wanted to have non-copyable values, but you will find this an easy change after making your way through the rest of the chapter.</p>
<p>For convenience, we will also make our Value printable (in any real situation you would likely want this to be a separate and configurable capability, but it makes the examples simpler without taking anything important away).</p>
<pre class="source-code">
// Example 24
template &lt;typename T&gt; class Value {
  public:
  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                                  Value x) {
    out &lt;&lt; x.val_;
    return out;
  }
  friend std::istream&amp; operator&gt;&gt;(std::istream&amp; in,
                                  Value&amp; x) {
    in &gt;&gt; x.val_;
    return in;
  }
  ...
};</pre>
<p>We use the <em class="italic">friend factory</em>, which <a id="_idIndexMarker967"/>was described in <a href="B19262_12.xhtml#_idTextAnchor562"><em class="italic">Chapter 12</em></a>, <em class="italic">Friend Factory</em>, to generate these functions. So far, all we can do with our Value is to initialize it, maybe assign it to another value, and print it:</p>
<pre class="source-code">
// Example 24
using V = Value&lt;int&gt;;
V i, j(5), k(3);
i = j;
std::cout &lt;&lt; i;     // Prints 5</pre>
<p>There is nothing else we can do with this class - no comparisons for equality or inequality, no arithmetic operations. However, we can create an adapter that adds the comparison interface:</p>
<pre class="source-code">
// Example 24
template &lt;typename V&gt; class Comparable : public V {
  public:
  using V::V;
  using V::operator=;
  using value_type = typename V::value_type;
  using basic_type = typename value_type::basic_type;
  Comparable(value_type v) : V(v) {}
  friend bool operator==(Comparable lhs, Comparable rhs) {
    return lhs.val_ == rhs.val_;
  }
  friend bool operator==(Comparable lhs, basic_type rhs) {
    return lhs.val_ == rhs;
  }
  friend bool operator==(basic_type lhs, Comparable rhs) {
    return lhs == rhs.val_;
  }
  ... same for the operator!= ...
};</pre>
<p>This is a class <a id="_idIndexMarker968"/>adapter - it is derived from the class it is augmenting with new capabilities, so it inherits all of its interface and adds some more - the complete set of comparison operators. Note that it is common to use pass-by-value instead of reference when dealing with value types (passing by reference to <code>const</code> isn’t wrong either, and some compilers may optimize either version to the same end result).</p>
<p>We are familiar with the way these adapters are used:</p>
<pre class="source-code">
using V = Comparable&lt;Value&lt;int&gt;&gt;;
V i(3), j(5);
i == j; // False
i == 3; // True
5 == j; // Also true</pre>
<p>That is one capability. What about some more? No problem - the <code>Ordered</code> adapter can be written very <a id="_idIndexMarker969"/>similarly, only it provides the operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> (or, in C++20, operator <code>&lt;=&gt;</code>):</p>
<pre class="source-code">
// Example 24
template &lt;typename V&gt; class Ordered : public V {
  public:
  using V::V;
  using V::operator=;
  using value_type = typename V::value_type;
  using basic_type = typename value_type::basic_type;
  Ordered(value_type v) : V(v) {}
  friend bool operator&lt;(Ordered lhs, Ordered rhs) {
    return lhs.val_ &lt; rhs.val_;
  }
  friend bool operator&lt;(basic_type lhs, Ordered rhs) {
    return lhs &lt; rhs.val_;
  }
  friend bool operator&lt;(Ordered lhs, basic_type rhs) {
    return lhs.val_ &lt; rhs;
  }
  ... same for the other operators ...
};</pre>
<p>We can combine the two adapters - as we say, they are composable, and they work in any order:</p>
<pre class="source-code">
using V = Ordered&lt;Comparable&lt;Value&lt;int&gt;&gt;&gt;;
// Or Comparable&lt;Ordered&lt;...&gt;
V i(3), j(5);
i == j; // False
i &lt;= 3; // True</pre>
<p>Some operations, or capabilities, require more work. If our value type is numeric, such as <code>Value&lt;int&gt;</code>, we will want some arithmetic operations like addition and multiplication. Here is a <a id="_idIndexMarker970"/>decorator that enables addition and subtraction:</p>
<pre class="source-code">
// Example 24
template &lt;typename V&gt; class Addable : public V {
  public:
  using V::V;
  using V::operator=;
  using value_type = typename V::value_type;
  using basic_type = typename value_type::basic_type;
  Addable(value_type v) : V(v) {}
  friend Addable operator+(Addable lhs, Addable rhs) {
    return Addable(lhs.val_ + rhs.val_);
  }
  friend Addable operator+(Addable lhs, basic_type rhs) {
    return Addable(lhs.val_ + rhs);
  }
  friend Addable operator+(basic_type lhs, Addable rhs) {
    return Addable(lhs + rhs.val_);
  }
  ... same for the operator- ...
};</pre>
<p>The decorator is trivial to use:</p>
<pre class="source-code">
using V = Addable&lt;Value&lt;int&gt;&gt;;
V i(5), j(3), k(7);
k = i + j; // 8</pre>
<p>We can also combine <code>Addable</code> with other decorators:</p>
<pre class="source-code">
using V = Addable&lt;Ordered&lt;Value&lt;int&gt;&gt;&gt;;
V i(5), j(3), k(7);
if (k - 1 &lt; i + j) { ... yes it is ... }</pre>
<p>But we have a problem that so far has been hidden only by good luck. We could have just as easily written:</p>
<pre class="source-code">
using V = Ordered&lt;Addable&lt;Value&lt;int&gt;&gt;&gt;;
V i(5), j(3), k(7);
if (k - 1 &lt; i + j) { ... }</pre>
<p>There should be no<a id="_idIndexMarker971"/> difference whatsoever between this example and the previous one. Instead, we get a compilation error: there is no valid <code>operator&lt;</code> to be used in the last line. The problem here is that the <code>i + j</code> expression uses the <code>operator+()</code> that comes from the <code>Addable</code> adapter, and this operator returns an object of type <code>Addable&lt;Value&lt;int&gt;&gt;</code>. The comparison operator expects the type <code>Ordered&lt;Addable&lt;Value&lt;int&gt;&gt;&gt;</code>, and will not accept the “partial” type (there is no implicit conversion from a base class to the derived one). The unsatisfactory solution is to require that <code>Addable</code> is always the top decorator. Not only it just feels wrong, but it also doesn’t get us very far: the next decorator we will want is <code>Multipliable</code> and it is going to have the same problem. When something is both <code>Addable</code> and <code>Multipliable</code> we can’t have both be on top.</p>
<p>Note that we had no problems with comparison operators returning <code>bool</code>, but once we have to return the decorated type itself, which is what <code>operator+()</code> does, the composability breaks down. To solve this problem, every operator that returns the decorated type has to return the original (outermost) type. For example, if our value type is <code>Ordered&lt;Addable&lt;Value&lt;int&gt;&gt;&gt;</code>, the result of adding two values should have the same type. The problem, of course, is that <code>operator+()</code> is provided by the <code>Addable</code> decorator which knows only about <code>Addable</code> and its base classes. We need an intermediate class in the hierarchy (<code>Addable&lt;...&gt;</code>) to return objects of its derived type (<code>Ordered&lt;Addable&lt;...&gt;&gt;</code>). This is a very common design problem, and there is a pattern for it: the Curiously Recurring Template Pattern, or CRTP (see the eponymous <a href="B19262_08.xhtml#_idTextAnchor360"><em class="italic">Chapter 8</em></a><em class="italic">, The Curiously Recurring Template Pattern</em>). Applying this pattern to our decorators takes some recursive thinking. We will introduce the two main ideas, then we just have to wade through a fairly large coding example.</p>
<p>First of all, every decorator is going to have two template parameters. The first one is the same as before: it is the next decorator in the chain, or <code>Value&lt;int&gt;</code> at the end of the chain (of course, the pattern is not limited to <code>int</code>, but we’re simplifying our examples by staying with the same base type throughout). The second parameter is going to be the outermost type; we will call it the “final value type.” Thus, all of our decorators are going to be declared like this:</p>
<pre class="source-code">
template &lt;typename V, typename FV&gt; class Ordered : ...</pre>
<p>But in our code, we still want to write</p>
<pre class="source-code">
using V = Ordered&lt;Addable&lt;Value&lt;int&gt;&gt;&gt;;</pre>
<p>This means we need a<a id="_idIndexMarker972"/> default value for the second template parameter. This value can be any type that we’re not going to use elsewhere in our decorators; <code>void</code> will do nicely. We will also need a partial template specialization for this default type since, if the final value type is not specified explicitly, we have to somehow figure out what it is:</p>
<pre class="source-code">
template &lt;typename V, typename FV = void&gt; class Ordered;
template &lt;typename V&gt; class Ordered&lt;V, void&gt;;</pre>
<p>Now we’re going to walk through our “nested” type <code>Ordered&lt;Addable&lt;Value&lt; int&gt;&gt;&gt;</code> step by step. At the outer layer, we can think of it as <code>Ordered&lt;T&gt;</code> where <code>T</code> is <code>Addable&lt;Value&lt;int&gt;&gt;</code>. Since we did not specify the second type parameter <code>FV</code> to the <code>Ordered</code> template, we are going to get the default value <code>void</code> and the template instantiation <code>Ordered&lt;T&gt;</code> is going to use the partial specialization of the <code>Ordered</code> template. Even thought we don’t have the “final value type” <code>FV</code> specified, we know what that is: it’s <code>Ordered&lt;T&gt;</code> itself.</p>
<p>Now we need to figure out the base class to inherit from. Since every decorator inherits from the type it decorates, it should be <code>T</code> which is <code>Addable&lt;U&gt;</code> (where <code>U</code> is <code>Value&lt;int&gt;</code>). But that’s not going to work: we need to pass the correct final value type into <code>Addable</code>. So we should inherit from <code>Addable&lt;U, FV&gt;</code> where <code>FV</code> is the final value type <code>Ordered&lt;T&gt;</code>. Unfortunately, we do not have <code>Addable&lt;U, FV&gt;</code> written in the code: we have <code>Addable&lt;U&gt;</code>. What we need is to somehow figure out the type that would have been generated by the same template <code>Addable</code> but with a different second type argument (<code>Ordered&lt;T&gt;</code> instead of the default <code>void</code>).</p>
<p>This is a very common problem in C++ templates, and it has an equally common solution: template rebinding. Every one of our decorator templates needs to define the following template alias:</p>
<pre class="source-code">
template &lt;typename V, typename FV = void&gt;
class Ordered : public ... some base class ... {
  public:
  template &lt;typename FV1&gt; using rebind = Ordered&lt;V, FV1&gt;;
};</pre>
<p>Now, given the type <code>T</code>, which is an instantiation of one of the decorator templates, we can find out the type <a id="_idIndexMarker973"/>that would have been produced by the same template but with a different second template argument <code>FV</code>: it’s <code>T::template rebind&lt;FV&gt;</code>. That is what our <code>Ordered&lt;V&gt;</code> needs to inherit from to pass the correct final value type to the next decorator:</p>
<pre class="source-code">
// Example 25
template &lt;typename V, typename FV = void&gt;
class Ordered : public V::template rebind&lt;FV&gt; { ... };</pre>
<p>This class template says that given a type <code>Ordered&lt;T, FV&gt;</code> we are going to inherit from the type <code>T</code> rebound to the same final value type <code>FV</code> and ignore the second template argument of <code>T</code>. The exception from this is the outermost type, where the template parameter <code>FV</code> is void but we know what the final value type should be, so we can rebind to that type:</p>
<pre class="source-code">
// Example 25
template &lt;typename V&gt; class Ordered&lt;V, void&gt; :
  public V::template rebind&lt;Ordered&lt;V&gt;&gt; { ... };</pre>
<p>Note the syntax, with the keyword <code>template</code>: some compilers will accept <code>V:: rebind&lt;Ordered&lt;V&gt;&gt;</code> but this is wrong, the standard requires this exact syntax.</p>
<p>Now we can put everything together. In the general case where our decorator is somewhere in the <a id="_idIndexMarker974"/>middle of the decorator chain, we must pass the final value type to the base class:</p>
<pre class="source-code">
// Example 25
template &lt;typename V, typename FV = void&gt;
class Ordered : public V::template rebind&lt;FV&gt; {
  using base_t = typename V::template rebind&lt;FV&gt;;
  public:
  using base_t::base_t;
  using base_t::operator=;
  template &lt;typename FV1&gt; using rebind = Ordered&lt;V, FV1&gt;;
  using value_type = typename base_t::value_type;
  using basic_type = typename value_type::basic_type;
  explicit Ordered(value_type v) : base_t(v) {}
  friend bool operator&lt;(FV lhs, FV rhs) {
    return lhs.val_ &lt; rhs.val_;
  }
  ... the rest of the operators ...
};</pre>
<p>The type alias <code>base_t</code> is introduced for convenience, it makes writing using statements easier. Note that we need the <code>typename</code> keyword before any type that depends on the template parameters; we did not need this keyword to specify the base class because the base class is always a type, so writing <code>typename</code> would be redundant.</p>
<p>The special case of the outermost type where the final value type is not specified and defaults to <code>void</code> is very similar:</p>
<pre class="source-code">
// Example 25
template &lt;typename V&gt; class Ordered&lt;V, void&gt;
  : public V::template rebind&lt;Ordered&lt;V&gt;&gt; {
  using base_t = typename V::template rebind&lt;Ordered&gt;;
  public:
  using base_t::base_t;
  using base_t::operator=;
  template &lt;typename FV1&gt; using rebind = Ordered&lt;V, FV1&gt;;
  using value_type = typename base_t::value_type;
  using basic_type = typename value_type::basic_type;
  explicit Ordered(value_type v) : base_t(v) {}
  friend bool operator&lt;(Ordered lhs, Ordered rhs) {
    return lhs.val_ &lt; rhs.val_;
  }
  ... the rest of the operators ...
};</pre>
<p>The specialization differs<a id="_idIndexMarker975"/> from the general case in two ways. In addition to the base class, the parameters of the operators cannot be of the type <code>FV</code> since it is <code>void</code>. Instead, we must use the type of the class generated by the template, which inside the template definition can be referred to simply as <code>Ordered</code> (the name of the template, when used inside the class, refers to the specific instantiation – you do not need to repeat the template arguments).</p>
<p>For decorators whose operators return a value, we need to make sure to always use the correct final value type for the return type. In the general case, this is the second template parameter <code>FV</code>:</p>
<pre class="source-code">
// Example 25
template &lt;typename V, typename FV = void&gt; class Addable :
  public V::template rebind&lt;FV&gt; {
  friend FV operator+(FV lhs, FV rhs) {
    return FV(lhs.val_ + rhs.val_);
  }
  ...
};</pre>
<p>In the specialization for the outermost decorator, the final value type is the decorator itself:</p>
<pre class="source-code">
// Example 25
template &lt;typename V&gt; class Addable&lt;V, void&gt; :
  public V::template rebind&lt;FV&gt; {
  friend Addable operator+(Addable lhs,Addable rhs) {
    return Addable(lhs.val_ + rhs.val_);
  }
  ...
};</pre>
<p>We must apply this technique to every decorator template. Now we can compose the decorators in any order<a id="_idIndexMarker976"/> and define value types with any subset of available operations:</p>
<pre class="source-code">
// Example 25
using V = Comparable&lt;Ordered&lt;Addable&lt;Value&lt;int&gt;&gt;&gt;&gt;;
// Addable&lt;Ordered&lt;Comparable&lt;Value&lt;int&gt;&gt;&gt;&gt; also OK
V i, j(5), k(3);
i = j; j = 1;
i == j;         // OK – Comparable
i &gt; j;        // OK – Ordered
i + j == 7 – k;    // OK – Comparable and Addable
i*j;             // Not Multipliable – does not compile</pre>
<p>So far, all of our decorators added member or non-member operators to the class. We can also add member functions and even constructors. The latter is useful if we want to add a conversion. For example, we can add an implicit conversion from the underlying type (as written, <code>Value&lt;T&gt;</code> is not implicitly constructible from <code>T</code>). The conversion decorator follows the same pattern as all the other decorators but adds an implicit converting constructor:</p>
<pre class="source-code">
// Example 25
template &lt;typename V, typename FV = void&gt;
class ImplicitFrom : public V::template rebind&lt;FV&gt; {
  ...
  explicit ImplicitFrom(value_type v) : base_t(v) {}
  ImplicitFrom(basic_type rhs) : base_t(rhs) {}
};
template &lt;typename V&gt; class ImplicitFrom&lt;V, void&gt; :
  public V::template rebind&lt;ImplicitFrom&lt;V&gt;&gt; {
  ...
  explicit ImplicitFrom(value_type v) : base_t(v) {}
  ImplicitFrom(basic_type rhs) : base_t(rhs) {}
};</pre>
<p>Now we can use implicit <a id="_idIndexMarker977"/>conversions to our value type, for example, when calling functions:</p>
<pre class="source-code">
using V = ImplicitFrom&lt;Ordered&lt;Addable&lt;Value&lt;int&gt;&gt;&gt;&gt;;
void f(V v);
f(3);</pre>
<p>If you want an implicit conversion to the underlying type, you can use a very similar adapter but instead of the constructor, it adds the conversion operator:</p>
<pre class="source-code">
// Example 25
template &lt;typename V, typename FV = void&gt;
class ImplicitTo : public V::template rebind&lt;FV&gt; {
  ...
  explicit ImplicitTo(value_type v) : base_t(v) {}
  operator basic_type(){ return this-&gt;val_; }
  operator const basic_type() const { return this-&gt;val_; }
};
template &lt;typename V&gt; class ImplicitTo&lt;V, void&gt; :
  public V::template rebind&lt;ImplicitTo&lt;V&gt;&gt; {
  ...
  explicit ImplicitTo(value_type v) : base_t(v) {}
  operator basic_type(){ return this-&gt;val_; }
  operator const basic_type() const { return this-&gt;val_; }
};</pre>
<p>This allows us to do the conversion in the opposite direction:</p>
<pre class="source-code">
using V = ImplicitTo&lt;Ordered&lt;Addable&lt;Value&lt;int&gt;&gt;&gt;&gt;;
void f(int i);
V i(3);
f(i);</pre>
<p>This design gets the job done, there aren’t any particular problems with it, other than the complexity of writing the adapters themselves: the recursive application of CRTP tends to send your<a id="_idIndexMarker978"/> brain into infinite recursion until you get used to thinking about this kind of template adapters. The other alternative is a policy-based value type.</p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor775"/>Policy solution</h2>
<p>We are now going to look <a id="_idIndexMarker979"/>at a somewhat different form of the policy-based design compared to what we saw in <a href="B19262_15.xhtml#_idTextAnchor689"><em class="italic">Chapter 15</em></a><em class="italic">, Policy-Based Design</em>. It is not as general, but when it works, it can provide all the advantages of the policies, in particular, the composability, without some of the problems. The problem remains the same: create a custom value type with a set of operations we can control. This problem can be tackled with the standard policy-based approach:</p>
<pre class="source-code">
template &lt;typename T, typename AdditionPolicy,
                      typename ComparisonPolicy,
                      typename OrderPolicy,
                      typename AssignmentPolicy, ... &gt;
class Value { ... };</pre>
<p>This implementation runs into the entire set of drawbacks of policy-based design - the policy list is long, all policies must be spelled out, and there aren’t any good defaults; the policies are positional, so the type declaration requires careful counting of commas, and, as the new policies are added, any semblance of a meaningful order of policies disappears. Note that we did not mention the problem of different sets of policies creating different types - in this case, this is not a drawback, but the design intent. If we want a type with support for addition and a similar type but without addition, these have to be different types.</p>
<p>Ideally, we would like to just list the policies for the properties we want our value to have - I want a value type based on integers that support addition, multiplication, and assignment, but nothing else. After all, we did this with the Adapter pattern, so we would not settle for anything less now. As it turns out, there is a way to accomplish this.</p>
<p>First, let’s think of what such a policy might look like. For example, the policy that enables addition should inject <code>operator+()</code> into the public interface of the class (and maybe also <code>operator+=()</code>). The policy that makes the value assignable should inject <code>operator=()</code>. We <a id="_idIndexMarker980"/>have seen enough of such policies to know how they are implemented - they have to be base classes, publicly inherited, and they need to know what the derived class is and cast it to its type, so they have to use CRTP:</p>
<pre class="source-code">
template &lt;
  typename T,    // The base type (like int)
  typename V&gt;    // The derived class
struct Incrementable {
  V operator++() {
    V&amp; v = static_cast&lt;V&amp;&gt;(*this);
    ++v.val_;     // The value inside the derived class
    return v;
  }
};</pre>
<p>Now, we need to give some thought to the use of these policies in the primary template. First of all, we want to support the unknown number of policies, in any order. This brings <code>variadic</code> templates to mind. However, to use CRTP, the template parameters have to be templates themselves. Then, we want to inherit from an instantiation of each of these templates, however many there are. What we need is a <code>variadic</code> template with a template template parameter pack:</p>
<pre class="source-code">
// Example 26
template &lt;typename T,
          template &lt;typename, typename&gt; class ... Policies&gt;
class Value :
  public Policies&lt;T, Value&lt;T, Policies ... &gt;&gt; ...
{ ... };</pre>
<p>The preceding declaration introduces a class template called <code>Value</code>, with at least one parameter that is a type, plus zero or more template policies, which themselves have two type parameters (in C++17, we can also write <code>typename ... Policies</code> instead of <code>class ... Policies</code>). The <code>Value</code> class instantiates these templates with the type <code>T</code> and<a id="_idIndexMarker981"/> itself and inherits publicly from all of them.</p>
<p>The <code>Value</code> class template should contain the interface that we want to be common for all our value types. The rest will have to come from policies. Let’s make the values copyable, assignable, and printable by default:</p>
<pre class="source-code">
// Example 26
template &lt;typename T,
          template &lt;typename, typename&gt; class ... Policies&gt;
class Value :
  public Policies&lt;T, Value&lt;T, Policies ... &gt;&gt; ...
{
  public:
  using base_type = T;
  explicit Value() = default;
  explicit Value(T v) : val_(v) {}
  Value(const Value&amp; rhs) : val_(rhs.val_) {}
  Value&amp; operator=(Value rhs) {
    val_ = rhs.val_;
    return *this;
  }
  Value&amp; operator=(T rhs) { val_ = rhs; return *this; }
  friend std::ostream&amp;
  operator&lt;&lt;(std::ostream&amp; out, Value x) {
    out &lt;&lt; x.val_; return out;
  }
  friend std::istream&amp;
    operator&gt;&gt;(std::istream&amp; in, Value&amp; x) {
    in &gt;&gt; x.val_; return in;
  }
  private:
  T val_ {};
};</pre>
<p>Again, we use the <em class="italic">friend factor</em>y from <a href="B19262_12.xhtml#_idTextAnchor562"><em class="italic">Chapter 12</em></a><em class="italic">, Friend Factory, </em>to generate the stream operators.</p>
<p>Before we can indulge<a id="_idIndexMarker982"/> ourselves in implementing all of the policies, there is one more hurdle to overcome. The <code>val_</code> value is private in the <code>Value</code> class, and we like it this way. However, the policies need to access and modify it. In the past, we solved this problem by making each policy that needed such access into a friend. This time, we don’t even know the names of the policies we may have. After working through the preceding declaration of the parameter pack expansion as a set of base classes, the reader may reasonably expect us to pull a rabbit out of the hat and somehow declare friendship to the entire parameter pack. Unfortunately, the standard offers no such way. The best solution we can suggest is to provide a set of accessor functions that should be called only by the policies, but there is no good way to enforce that (a name, such as <code>policy_accessor_do_not_call()</code>, might go some way to suggest that the user code should stay away from it, but the ingenuity of the programmer knows no bounds, and such hints are not universally respected):</p>
<pre class="source-code">
// Example 26
template &lt;typename T,
          template &lt;typename, typename&gt; class ... Policies&gt;
class Value :
  public Policies&lt;T, Value&lt;T, Policies ... &gt;&gt; ...
{
  public:
  ...
  T get() const { return val_; }
  T&amp; get() { return val_; }
  private:
  T val_ {};
};</pre>
<p>To create a value type<a id="_idIndexMarker983"/> with a restricted set of operations, we have to instantiate this template with a list of policies we want, and nothing else:</p>
<pre class="source-code">
// Example 26
using V = Value&lt;int, Addable, Incrementable&gt;;
V v1(0), v2(1);
v1++; // Incrementable - OK
V v3(v1 + v2); // Addable - OK
v3 *= 2; // No multiplication policies - won't compile</pre>
<p>The number and the type of policies we can implement are limited mostly by the need at hand (or imagination), but here are some examples that demonstrate adding different kinds of operations to the class.</p>
<p>First of all, we can implement the aforementioned <code>Incrementable</code> policy that provides the two <code>++</code> operators, postfix and prefix:</p>
<pre class="source-code">
// Example 26
template &lt;typename T, typename V&gt; struct Incrementable {
  V operator++() {
    V&amp; v = static_cast&lt;V&amp;&gt;(*this);
    ++(v.get());
    return v;
  }
  V operator++(int) {
    V&amp; v = static_cast&lt;V&amp;&gt;(*this);
    return V(v.get()++);
  }
};</pre>
<p>We can make a<a id="_idIndexMarker984"/> separate <code>Decrementable</code> policy for the <code>--</code> operators, or have one policy for both if it makes sense for our type. Also, if want to increment by some value other than one, then we need the <code>+=</code> operators as well:</p>
<pre class="source-code">
// Example 26
template &lt;typename T, typename V&gt; struct Incrementable {
  V&amp; operator+=(V val) {
    V&amp; v = static_cast&lt;V&amp;&gt;(*this);
    v.get() += val.get();
    return v;
  }
  V&amp; operator+=(T val) {
    V&amp; v = static_cast&lt;V&amp;&gt;(*this);
    v.get() += val;
    return v;
  }
};</pre>
<p>The preceding policy provides two versions of <code>operator+=()</code> - one accepts the increment of the same <code>Value</code> type, and the other of the foundation type <code>T</code>. This is not a requirement, and we could implement an increment by values of some other types as needed. We can even have several versions of the increment policy, as long as only one is used (the compiler would let us know if we were introducing incompatible overloads of the same operator).</p>
<p>We can add the operators <code>*=</code> and <code>/=</code> in a similar manner. Adding binary operators such as comparison operators or addition and multiplication is a little different - these operators have to be non-member functions to allow for type conversions on the first argument. Again, the <a id="_idIndexMarker985"/>friend factory pattern comes in handy. Let’s start with the comparison operators:</p>
<pre class="source-code">
// Example 26
template &lt;typename T, typename V&gt; struct ComparableSelf {
  friend bool operator==(V lhs, V rhs) {
    return lhs.get() == rhs.get();
  }
  friend bool operator!=(V lhs, V rhs) {
    return lhs.get() != rhs.get();
  }
};</pre>
<p>When instantiated, this template generates two non-member non-template functions, that is, the comparison operators for variables of the type of the specific <code>Value</code> class, the one that is instantiated. We may also want to allow comparisons with the foundation type (such as <code>int</code>):</p>
<pre class="source-code">
template &lt;typename T, typename V&gt; struct ComparableValue {
  friend bool operator==(V lhs, T rhs) {
    return lhs.get() == rhs;
  }
  friend bool operator==(T lhs, V rhs) {
    return lhs == rhs.get();
  }
  friend bool operator!=(V lhs, T rhs) {
    return lhs.get() != rhs;
  }
  friend bool operator!=(T lhs, V rhs) {
    return lhs != rhs.get();
  }
};</pre>
<p>More often than not, we will likely want both types of comparison at the same time. We could simply put them both into the same policy and not worry about separating them, or we could create a<a id="_idIndexMarker986"/> combined policy from the two we already have:</p>
<pre class="source-code">
// Example 26
template &lt;typename T, typename V&gt;
struct Comparable : public ComparableSelf&lt;T, V&gt;,
                    public ComparableValue&lt;T, V&gt; {};</pre>
<p>In the previous section, we combined all comparisons in a single adapter from the beginning. Here, we use a slightly different approach just to illustrate different options for controlling class interfaces with policies or adapters (both solutions offer the same options). The addition and multiplication operators are created by similar policies. They are also friend non-template non-member functions. The only difference is the return value type - they return the object itself, for example:</p>
<pre class="source-code">
// Example 26
template &lt;typename T, typename V&gt; struct Addable {
  friend V operator+(V lhs, V rhs) {
    return V(lhs.get() + rhs.get());
  }
  friend V operator+(V lhs, T rhs) {
    return V(lhs.get() + rhs);
  }
  friend V operator+(T lhs, V rhs) {
    return V(lhs + rhs.get());
  }
};</pre>
<p>As you can see, the problem of returning the “final value type” that we struggled with while writing adapters does not exist here: the derived class that is passed into each policy is the value type itself.</p>
<p>Explicit or implicit conversion operators for conversions to the base type can be added just as easily:</p>
<pre class="source-code">
// Example 26
template &lt;typename T, typename V&gt;
struct ExplicitConvertible {
  explicit operator T() {
    return static_cast&lt;V*&gt;(this)-&gt;get();
  }
  explicit operator const T() const {
    return static_cast&lt;const V*&gt;(this)-&gt;get();
  }
};</pre>
<p>This approach, at first <a id="_idIndexMarker987"/>glance, seems to solve most of the drawbacks of the traditional policy-based types. The order of the policies does not matter - we can specify only the ones we want and not worry about the other ones - what’s not to like? There are, however, two fundamental limitations. First of all, the policy-based class cannot refer to any policy by name. There is no longer a slot for <code>DeletionPolicy</code> or <code>AdditionPolicy</code>. There are no convention-enforced policy interfaces, such as the deletion policy having to be callable. The entire process of binding the policies into a single type is implicit; it’s just a superposition of interfaces.</p>
<p>Therefore, we are limited in what we can do using these policies - we can inject public member functions and non-member functions - even add private data members - but we cannot provide an implementation for an aspect of behavior that’s determined and limited by the primary policy-based class. As such, this is not an implementation of the Strategy pattern - we are composing the interface, and, perforce, the implementation, at will, not customizing a specific algorithm (which is why we deferred the demonstration of this alternative policy-based design pattern until this chapter).</p>
<p>The second, closely related, limitation is that there are no default policies. The missing policies are just that, missing. There is nothing in their place. The default behavior is always the absence of any behavior. In the traditional policy-based design, each policy slot has to be filled. If there is a reasonable default, it can be specified, and then that is the policy unless the user overrides it (for example, the default deletion policy uses <code>operator delete</code>). If there is no default, the compiler won’t let us omit the policy - we have to give an argument to the template.</p>
<p>The consequences of<a id="_idIndexMarker988"/> these limitations reach farther than you may think at first glance. For example, it may be tempting to use the <code>enable_if</code> technique we saw in <a href="B19262_15.xhtml#_idTextAnchor689"><em class="italic">Chapter 15</em></a><em class="italic">, Policy-Based Design,</em> instead of injecting public member functions through the base class. Then, we could have a default behavior that is enabled if none of the other options are. But it won’t work here. We can certainly create a policy that is targeted for use with <code>enable_if</code>:</p>
<pre class="source-code">
template &lt;typename T, typename V&gt; struct Addable {
  constexpr bool adding_enabled = true;
};</pre>
<p>But there is no way to use it - we can’t use <code>AdditionPolicy::adding_enabled</code> because there is no <code>AdditionPolicy</code> - all policy slots are unnamed. The other option would be to use <code>Value::adding_enabled</code> - the addition policy is a base class of <code>Value</code>, and, therefore, all of its data members are visible in the <code>Value</code> class. The only problem is that it does not work - at the point where this expression is evaluated by the compiler (in the definition of the <code>Value</code> type as the template parameter for the CRTP policies), <code>Value</code> is an incomplete type and we cannot access its data members yet. We could evaluate <code>policy_name::adding_enabled</code> if we knew what the policy name was. But that knowledge is exactly what we gave up in trade for not having to specify the entire list of policies.</p>
<p>While not, strictly speaking, an application of the Strategy pattern, the alternative to the policy-based design that we have just learned about can be attractive when the policies are primarily used to control a set of supported operations. While discussing the guidelines for policy-based design, we have mentioned that it is rarely worth it to use a policy slot just to provide the additional safe<a id="_idTextAnchor776"/>ty of the restricted interface. For such situations, this alternative approach should be kept in mind.</p>
<p>Overall, we can see that both patterns have their advantages and drawbacks: adapters rely on a more complex form of CRTP while the “slot-less” policies we just saw require us to compromise the encapsulation (we have to expose the value to the policies using something like our <code>get()</code> methods).</p>
<p>Such is the nature of the problems we have to solve as software engineers - once a problem becomes complex enough, it can be solved, frequently using more than one design, and each approach has its own advantages and limitations. There is no way we can compare every two patterns that can be used to create two very different designs that address <a id="_idIndexMarker989"/>the same need, at least not in a book of any finite size. By presenting and analyzing these examples, we hope to equip the reader with the understanding and insight <a id="_idTextAnchor777"/><a id="_idTextAnchor778"/>that will be helpful in evaluating similarly complex and varied design options for real-life problems.</p>
<h1 id="_idParaDest-299"><a id="_idTextAnchor779"/>Summary</h1>
<p>We have studied two of the most commonly used patterns - not just in C++, but in software design in general. The Adapter pattern offers an approach to solving a wide class of design challenges. These challenges have only the most general property in common - given a class, a function, or a software component that provides certain functionality, we must solve a particular problem, and build a solution for a different, related problem. The decorator pattern is, in many ways, a subset of the Adapter pattern, which is restricted to augmenting the existing interface of the class of a function with new behavior.</p>
<p>We have seen that the interface conversion and modification done by the adapters and decorators can be applied to interfaces at every stage of the program’s life - while the most common use is to modify runtime interfaces so that a class can be used in a different context, there are also compile-time adapters for generic code that allow us to use a class as a building block or a component of a larger, more complex, class.</p>
<p>The Adapter pattern can be applied to many very different design challenges. The varied nature of these challenges and the generality of the pattern itself often mean that an alternative solution is possible. Such alternatives often use a completely different approach - an entirely different design pattern - but end up providing similar behavior. The difference lies in trade-offs, additional conditions, and limitations imposed by the chosen approach to the design, and the possibilities of extending the solution in different ways. To this end, this chapter offers a comparison of two very different design approaches to the same problem, complete with an evaluation of the strengths and drawbacks of both options.</p>
<p>The next, penultimate, chapter introduces a pattern that is large, complex, and has several<a id="_idTextAnchor780"/> <a id="_idTextAnchor781"/>interacting components - an appropriate pattern to be left for our grand finale - the Visitor pattern.</p>
<h1 id="_idParaDest-300"><a id="_idTextAnchor782"/>Questions</h1>
<ol>
<li value="1">What is the Adapter pattern?</li>
<li>What is the decorator pattern and how does it differ from the Adapter pattern?</li>
<li>The classic OOP implementation of the decorator pattern is usually not recommended in C++. Why not?</li>
<li>When should the C++ class decorator use inheritance or composition?</li>
<li>When should the C++ class adapter use inheritance or composition?</li>
<li>C++ provides a general function adapter for currying function arguments, <code>std::bind</code>. What are its limitations?</li>
<li>C++11 provides template aliases that can be used as adapters. What are their limitations?</li>
<li>Both the adapter and policy patterns can be used to add or modify the public interface of a class. Give some reasons for preferring one over the other.</li>
</ol>
</div>
</body></html>