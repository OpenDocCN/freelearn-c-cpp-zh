<html><head></head><body>
<div id="_idContainer035">
<h1 class="chapter-number" id="_idParaDest-283"><a id="_idTextAnchor739"/><span class="koboSpan" id="kobo.1.1">16</span></h1>
<h1 id="_idParaDest-284"><a id="_idTextAnchor740"/><span class="koboSpan" id="kobo.2.1">Adapters and Decorators</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This chapter takes on two classic patterns in </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">OOP</span></strong><span class="koboSpan" id="kobo.7.1">) - the Adapter pattern and the decorator pattern. </span><span class="koboSpan" id="kobo.7.2">These patterns are just two of the original twenty-three design patterns that were introduced in the </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Design Patterns – Elements of Reusable Object-Oriented Software</span></em><span class="koboSpan" id="kobo.9.1"> book by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </span><span class="koboSpan" id="kobo.9.2">As an object-oriented language, C++ can take advantage of these patterns as well as any other language. </span><span class="koboSpan" id="kobo.9.3">But, as is often the case, generic programming brings some advantages, variations, and, with it, new challenges to the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">classic patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">The following topics are covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">What are the adapter and </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">decorator patterns?</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">What is the difference between </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">the two?</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">What design problems can be solved by </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">these patterns?</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">How are these patterns used </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">in C++?</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">How does generic programming help to design adapters </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">and decorators?</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">What other, different, patterns offer alternative solutions to </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">similar problems?</span></span><a id="_idTextAnchor741"/></li>
</ul>
<h1 id="_idParaDest-285"><a id="_idTextAnchor742"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.26.1">The example code for this chapter can be found on GitHub at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">link: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter16"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter16</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">.</span></span><a id="_idTextAnchor743"/></p>
<h1 id="_idParaDest-286"><a id="_idTextAnchor744"/><span class="koboSpan" id="kobo.30.1">The decorator pattern</span></h1>
<p><span class="koboSpan" id="kobo.31.1">We will begin this</span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.32.1"> study with the definitions of the two classic patterns. </span><span class="koboSpan" id="kobo.32.2">As we will see, on paper, the patterns, as well as the differences between them, are quite clear. </span><span class="koboSpan" id="kobo.32.3">Then, C++ comes in and blurs the lines by allowing design solutions that fall somewhere in-between the two. </span><span class="koboSpan" id="kobo.32.4">Still, the clarity of these simple cases is helpful, even if it gets muddled as we pile on the complexity. </span><span class="koboSpan" id="kobo.32.5">Let’s start with what is </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">clear, then.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">The decorator pattern is also a structural pattern; it allows a behavior to be added to an object. </span><span class="koboSpan" id="kobo.34.2">The classic decorator pattern extends the behavior of an existing operation that’s performed by a class. </span><span class="koboSpan" id="kobo.34.3">It </span><em class="italic"><span class="koboSpan" id="kobo.35.1">decorates</span></em><span class="koboSpan" id="kobo.36.1"> the class with the new behavior and creates an object of the new, decorated type. </span><span class="koboSpan" id="kobo.36.2">The decorator implements the interface of the original class and forwards the requests from its own interface to that class, but it also performs additional actions before and after these forwarded requests - these are the </span><em class="italic"><span class="koboSpan" id="kobo.37.1">decorations.</span></em><span class="koboSpan" id="kobo.38.1"> Such</span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.39.1"> decorators are sometimes called “</span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">class wrappers</span><a id="_idTextAnchor745"/><span class="koboSpan" id="kobo.41.1">”</span><a id="_idTextAnchor746"/><span class="koboSpan" id="kobo.42.1">.</span></span></p>
<h2 id="_idParaDest-287"><a id="_idTextAnchor747"/><span class="koboSpan" id="kobo.43.1">Basic decorator pattern</span></h2>
<p><span class="koboSpan" id="kobo.44.1">We will begin with a C++ example of the decorator pattern that follows the classic definition as closely as possible. </span><span class="koboSpan" id="kobo.44.2">For this example, we will imagine designing a fantasy game that’s set in medieval times (true to life, only with dragons and elves and so on). </span><span class="koboSpan" id="kobo.44.3">Of course, what are medieval times without fighting? </span><span class="koboSpan" id="kobo.44.4">And so, in our game, the player has a choice of units appropriate for his/her side, and they can do battle when called on. </span><span class="koboSpan" id="kobo.44.5">Here is the basic </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">Unit</span></strong><span class="koboSpan" id="kobo.46.1"> class - at least the </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">combat-related part:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.48.1">
// Example 01
class Unit {
  public:
  Unit(double strength, double armor) :
    strength_(strength), armor_(armor) {}
  virtual bool hit(Unit&amp; target) {
    return attack() &gt; target.defense();
  }
  virtual double attack() = 0;
  virtual double defense() = 0;
  protected:
  double strength_;
  double armor_;
};</span></pre>
<p><span class="koboSpan" id="kobo.49.1">The unit has </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">strength</span></strong><span class="koboSpan" id="kobo.51.1">, which determines its attack, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">armor</span></strong><span class="koboSpan" id="kobo.53.1">, which provides defense. </span><span class="koboSpan" id="kobo.53.2">The actual values of the attack and the defense are computed by the derived classes - the concrete units - but the combat mechanism itself is right here - if the attack is stronger than the defense, the unit successfully hits the target (this is a very simplistic approach to gaming, of course, but we want to make the examples as concise </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">as possible).</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Now, what are the actual units in the game? </span><span class="koboSpan" id="kobo.55.2">The pillar of the human armies is the valorous </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">Knight</span></strong><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">This unit </span><a id="_idIndexMarker889"/><span class="koboSpan" id="kobo.58.1">has strong armor and a sharp sword, giving it bonuses to both attack </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">and defend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.60.1">
// Example 01
class Knight : public Unit {
  public:
  using Unit::Unit;
  double attack() { return strength_ + sword_bonus_; }
  double defense() { return armor_ + plate_bonus_; }
  protected:
  static constexpr double sword_bonus_ = 2;
  static constexpr double plate_bonus_ = 3;
};</span></pre>
<p><span class="koboSpan" id="kobo.61.1">Fighting against the knights are the brutish ogres. </span><span class="koboSpan" id="kobo.61.2">The ogres swing simple wooden clubs and wear ragged leather, neither of which are great implements of war, giving them some </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">combat penalties:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.63.1">
// Example 01
class Ogre : public Unit {
  public:
  using Unit::Unit;
  double attack() { return strength_ + club_penalty_; }
  double defense() { return armor_ + leather_penalty_; }
  protected:
  static constexpr double club_penalty_ = -1;
  static constexpr double leather_penalty_ = -1;
};</span></pre>
<p><span class="koboSpan" id="kobo.64.1">On the other hand, ogres are remarkably strong, to </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">begin with:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.66.1">
Knight k(10, 5);
Ogre o(12, 2);
k.hit(o); // Yes!</span></pre>
<p><span class="koboSpan" id="kobo.67.1">Here the knight, aided by his attack bonus and the enemy’s weak armor, will successfully hit the ogre. </span><span class="koboSpan" id="kobo.67.2">But the game is far from over. </span><span class="koboSpan" id="kobo.67.3">As the units fight, the surviving ones gain experience and eventually become veterans. </span><span class="koboSpan" id="kobo.67.4">A veteran unit is still the same kind of unit, but it </span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.68.1">gains attack and defense bonuses, reflecting its combat experience. </span><span class="koboSpan" id="kobo.68.2">Here, we do not want to change any of the class interfaces, but we want to modify the behavior of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">attack()</span></strong><span class="koboSpan" id="kobo.70.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">defense()</span></strong><span class="koboSpan" id="kobo.72.1"> functions. </span><span class="koboSpan" id="kobo.72.2">This is the job of the decorator pattern, and what follows is the classic implementation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">VeteranUnit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.74.1"> decorator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.75.1">
// Example 01
class VeteranUnit : public Unit {
  public:
  VeteranUnit(Unit&amp; unit,
              double strength_bonus,
              double armor_bonus) :
    Unit(strength_bonus, armor_bonus), unit_(unit) {}
  double attack() { return unit_.attack() + strength_; }
  double defense() { return unit_.defense() + armor_; }
  private:
  Unit&amp; unit_;
};</span></pre>
<p><span class="koboSpan" id="kobo.76.1">Note that this class inherits directly from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">Unit</span></strong><span class="koboSpan" id="kobo.78.1"> class, so in the class hierarchy, it is </span><em class="italic"><span class="koboSpan" id="kobo.79.1">to the side</span></em><span class="koboSpan" id="kobo.80.1"> of concrete unit classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">Knight</span></strong><span class="koboSpan" id="kobo.82.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">Ogre</span></strong><span class="koboSpan" id="kobo.84.1">. </span><span class="koboSpan" id="kobo.84.2">We still have the original unit that is decorated and becomes the veteran - the </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">VeteranUnit</span></strong><span class="koboSpan" id="kobo.86.1"> decorator contains a reference to it. </span><span class="koboSpan" id="kobo.86.2">The way it is used, then, is to decorate a unit and use the decorated unit from then on, but it does not delete the </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">original unit:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.88.1">
// Example 01
Knight k(10, 5);
Ogre o(12, 2);
VeteranUnit vk(k, 7, 2);
VeteranUnit vo(o, 1, 9);
vk.hit(vo); // Another hit!</span></pre>
<p><span class="koboSpan" id="kobo.89.1">Here, both our old</span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.90.1"> enemies reached their first veterancy levels, and the victory again goes to the knight. </span><span class="koboSpan" id="kobo.90.2">But experience is the best teacher, and our ogre gains another level, and, with it, enchanted runic armor with a massive </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">defense bonus:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.92.1">
VeteranUnit vvo(vo, 1, 9);
vk.hit(vvo); // Miss!</span></pre>
<p><span class="koboSpan" id="kobo.93.1">Note that we can decorate a decorated object in this design! </span><span class="koboSpan" id="kobo.93.2">This is intentional, and the bonuses stack up as the unit gains levels. </span><span class="koboSpan" id="kobo.93.3">This time, the experienced fighter’s defense proves to be too much for </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">the knight.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">As we already mentioned, this is the classic decorator pattern, straight out of the textbook. </span><span class="koboSpan" id="kobo.95.2">It works in C++ but with some limitations. </span><span class="koboSpan" id="kobo.95.3">The first one is rather evident  even though we want to use the decorated unit once we have it, the original unit must be kept around, and the lifetimes of these objects must be carefully managed. </span><span class="koboSpan" id="kobo.95.4">There are practical solutions to such practical problems, but the focus of this book is on combining design patterns with generic programming, and the new design possibilities that pairing creates. </span><span class="koboSpan" id="kobo.95.5">Therefore, our creative path takes </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">us elsewhere.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">The second problem is more endemic to C++. </span><span class="koboSpan" id="kobo.97.2">It is best illustrated by an example. </span><span class="koboSpan" id="kobo.97.3">The game’s designers have added a special ability to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">Knight</span></strong><span class="koboSpan" id="kobo.99.1"> unit - it can charge forward at its enemy, gaining a short-term attack bonus. </span><span class="koboSpan" id="kobo.99.2">This bonus is valid only for the next attack, but in the thick of the battle, it may be </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">just enough:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.101.1">
// Example 02
class Knight : public Unit {
  public:
  Knight(double strength, double armor) :
  Unit(strength, armor), charge_bonus_(0) {}
  double attack() {
    double res = strength_ + sword_bonus_ + charge_bonus_;
    charge_bonus_ = 0;
    return res;
  }
  double defense() { return armor_ + plate_bonus_; }
  void charge() { charge_bonus_ = 1; }
  protected:
  double charge_bonus_;
  static constexpr double sword_bonus_ = 2;
  static constexpr double plate_bonus_ = 3;
};</span></pre>
<p><span class="koboSpan" id="kobo.102.1">The charge bonus is</span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.103.1"> activated by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">charge()</span></strong><span class="koboSpan" id="kobo.105.1"> member function and lasts for one attack, and then it is reset. </span><span class="koboSpan" id="kobo.105.2">When the player activates the charge, the game executes the code, which looks something </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.107.1">
Knight k(10, 5);
Ogre o(12, 2);
k.charge();
k.hit(o);</span></pre>
<p><span class="koboSpan" id="kobo.108.1">Of course, we would expect the veteran knight to be able to charge forward as well, but here we run into a problem - our code does </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">not compile:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.110.1">
VeteranUnit vk(k, 7, 2);
vk.charge(); // Does not compile!</span></pre>
<p><span class="koboSpan" id="kobo.111.1">The root of the problem is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">charge()</span></strong><span class="koboSpan" id="kobo.113.1"> is a part of the interface of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">Knight</span></strong><span class="koboSpan" id="kobo.115.1"> class, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">VeteranUnit</span></strong><span class="koboSpan" id="kobo.117.1"> decorator is derived from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">Unit</span></strong><span class="koboSpan" id="kobo.119.1"> class. </span><span class="koboSpan" id="kobo.119.2">We could move the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">charge()</span></strong><span class="koboSpan" id="kobo.121.1"> function into the base class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">Unit</span></strong><span class="koboSpan" id="kobo.123.1">, but this is a bad design - </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">Ogre</span></strong><span class="koboSpan" id="kobo.125.1"> is also derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">Unit</span></strong><span class="koboSpan" id="kobo.127.1">, and ogres cannot charge, so they should not have such an interface (it violates the </span><em class="italic"><span class="koboSpan" id="kobo.128.1">is-a</span></em><span class="koboSpan" id="kobo.129.1"> principle of </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">public inheritance).</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">This is a problem that’s inherent in the way we implemented the decorator object - both </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">Knight</span></strong><span class="koboSpan" id="kobo.133.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">VeteranUnit</span></strong><span class="koboSpan" id="kobo.135.1"> are derived from the same base class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">Unit</span></strong><span class="koboSpan" id="kobo.137.1">, but they don’t know anything about each other. </span><span class="koboSpan" id="kobo.137.2">There are some ugly workarounds, but it is a fundamental C++ limitation; it does not handle </span><em class="italic"><span class="koboSpan" id="kobo.138.1">cross-casting</span></em><span class="koboSpan" id="kobo.139.1"> well (casting to a type in another branch of the same hierarchy). </span><span class="koboSpan" id="kobo.139.2">But what the language takes with one hand, it gives with the other - we </span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.140.1">have much better tools to deal with this problem, and we are going to learn about these </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">tool</span><a id="_idTextAnchor748"/><span class="koboSpan" id="kobo.142.1">s</span><a id="_idTextAnchor749"/><span class="koboSpan" id="kobo.143.1"> next.</span></span></p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor750"/><span class="koboSpan" id="kobo.144.1">Decorators the C++ way</span></h2>
<p><span class="koboSpan" id="kobo.145.1">We have encountered</span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.146.1"> two problems while implementing a classic decorator in C++ - first of all, the decorated object did not take ownership of the original object, so both must be kept around (this may not be so much a problem as a feature if the decoration needs to be removed later, which is one of the reasons the decorator pattern is implemented this way). </span><span class="koboSpan" id="kobo.146.2">The other problem is that a decorated </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">Knight</span></strong><span class="koboSpan" id="kobo.148.1"> is not really a </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">Knight</span></strong><span class="koboSpan" id="kobo.150.1"> at all, but a </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">Unit</span></strong><span class="koboSpan" id="kobo.152.1">. </span><span class="koboSpan" id="kobo.152.2">We can solve the second problem if the decorator is itself derived from the class that is being decorated. </span><span class="koboSpan" id="kobo.152.3">This would imply that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">VeteranUnit</span></strong><span class="koboSpan" id="kobo.154.1"> class does not have a fixed base class - the base class should be whatever class is being decorated. </span><span class="koboSpan" id="kobo.154.2">This description matches the </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">Curiously Recurring Template Pattern</span></strong><span class="koboSpan" id="kobo.156.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.157.1">CRTP</span></strong><span class="koboSpan" id="kobo.158.1">) to</span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.159.1"> a tee (this C++ idiom was described earlier in this book in </span><a href="B19262_08.xhtml#_idTextAnchor360"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.160.1">Chapter 8</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.161.1">, The Curiously Recurring Template Pattern</span></em><span class="koboSpan" id="kobo.162.1">). </span><span class="koboSpan" id="kobo.162.2">To apply CRTP, we need to make the decorator into a template and inherit from the </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">template parameter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.164.1">
// Example 03
template &lt;typename U&gt;
class VeteranUnit : public U {
  public:
  VeteranUnit(U&amp;&amp; unit,
              double strength_bonus,
              double armor_bonus) :
    U(unit), strength_bonus_(strength_bonus),
    armor_bonus_(armor_bonus) {}
  double attack() { return U::attack() + strength_bonus_; }
  double defense() { return U::defense() + armor_bonus_; }
  private:
  double strength_bonus_;
  double armor_bonus_;
};</span></pre>
<p><span class="koboSpan" id="kobo.165.1">Now, to promote a unit to the veteran status, we must convert it to the decorated version of the</span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.166.1"> concrete </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">unit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.168.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.169.1">
// Example 03
Knight k(10, 5);
Ogre o(12, 2);
k.hit(o); // Hit!
</span><span class="koboSpan" id="kobo.169.2">VeteranUnit&lt;Knight&gt; vk(std::move(k), 7, 2);
VeteranUnit&lt;Ogre&gt; vo(std::move(o), 1, 9);
vk.hit(vo); // Hit!
</span><span class="koboSpan" id="kobo.169.3">VeteranUnit&lt;VeteranUnit&lt;Ogre&gt;&gt; vvo(std::move(vo), 1, 9);
vk.hit(vvo); // Miss...
</span><span class="koboSpan" id="kobo.169.4">vk.charge(); // Compiles now, vk is a Knight too
vk.hit(vvo); // Hit with the charge bonus!</span></pre>
<p><span class="koboSpan" id="kobo.170.1">This is the same scenario that we saw at the end of the previous section, but it now uses the template decorator. </span><span class="koboSpan" id="kobo.170.2">Notice the differences. </span><span class="koboSpan" id="kobo.170.3">First of all, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">VeteranUnit</span></strong><span class="koboSpan" id="kobo.172.1"> is a class that’s derived from a concrete unit such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">Knight</span></strong><span class="koboSpan" id="kobo.174.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">Ogre</span></strong><span class="koboSpan" id="kobo.176.1">. </span><span class="koboSpan" id="kobo.176.2">As such, it has access to the interface of the base class: for example, a veteran knight, </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">VeteranUnit&lt;Knight&gt;</span></strong><span class="koboSpan" id="kobo.178.1">, is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">Knight</span></strong><span class="koboSpan" id="kobo.180.1"> too and has the member function </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">charge()</span></strong><span class="koboSpan" id="kobo.182.1"> inherited from </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Knight</span></strong><span class="koboSpan" id="kobo.184.1">. </span><span class="koboSpan" id="kobo.184.2">Second, the decorated unit explicitly takes ownership of the original unit - to create a veteran unit, we have to move the original unit into it (the base class of the veteran unit is move-constructed from the original unit). </span><span class="koboSpan" id="kobo.184.3">The original object is left in the unspecified moved-from state, and the only safe action that can be done on this object is a call to the destructor. </span><span class="koboSpan" id="kobo.184.4">Note that, at least for the simple implementation of unit classes, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">move</span></strong><span class="koboSpan" id="kobo.186.1"> operation is just a copy, so the original object is usable, but you should not rely on it - making assumptions about the moved-from state is a bug waiting </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">to happen.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">It is worth pointing out that our declaration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">VeteranUnit</span></strong><span class="koboSpan" id="kobo.190.1"> constructor enforces and requires this ownership transfer. </span><span class="koboSpan" id="kobo.190.2">If we try to construct a veteran unit without moving from the original unit, it will </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">not compile:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.192.1">
VeteranUnit&lt;Knight&gt; vk(k, 7, 2); // Does not compile</span></pre>
<p><span class="koboSpan" id="kobo.193.1">By providing only one constructor that accepts an r-value reference, that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">Unit&amp;&amp;</span></strong><span class="koboSpan" id="kobo.195.1">, we require that the caller agrees to the transfer </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">of ownership.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">So far, for</span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.198.1"> demonstration purposes, we have created all unit objects on the stack as local variables. </span><span class="koboSpan" id="kobo.198.2">In any non-trivial program, this is not going to work - we need these objects to stay around, long after the function that created them is done. </span><span class="koboSpan" id="kobo.198.3">We can integrate decorator objects and the memory ownership mechanism and ensure that the moved-from original units are deleted after a decorated version </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">is created.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">Let’s say that ownership is managed throughout the program by unique pointers (each object has a clear owner at any given time). </span><span class="koboSpan" id="kobo.200.2">Here is how this can be accomplished. </span><span class="koboSpan" id="kobo.200.3">First of all, it is convenient to declare aliases for the pointers we need </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">to use:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.202.1">
using Unit_ptr = std::unique_ptr&lt;Unit&gt;;
using Knight_ptr = std::unique_ptr&lt;Knight&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.203.1">While any unit can be owned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">Unit_ptr</span></strong><span class="koboSpan" id="kobo.205.1"> pointer, we cannot call unit-specific member functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">charge()</span></strong><span class="koboSpan" id="kobo.207.1"> through it, so we may need pointers to the concrete classes as well. </span><span class="koboSpan" id="kobo.207.2">As we will see next, we need to move the object between these pointers. </span><span class="koboSpan" id="kobo.207.3">Moving from a pointer to the derived class to the pointer to the base class </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">is easy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.209.1">
Knight_ptr k(new Knight(10, 5));
Unit_ptr u(std::move(k)); // Now k is null</span></pre>
<p><span class="koboSpan" id="kobo.210.1">Going in the other direction is a little harder; </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">std::move</span></strong><span class="koboSpan" id="kobo.212.1"> will not work implicitly, just like we cannot convert from </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">Unit*</span></strong><span class="koboSpan" id="kobo.214.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">Knight*</span></strong><span class="koboSpan" id="kobo.216.1"> without an explicit cast. </span><span class="koboSpan" id="kobo.216.2">We need a </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.217.1">moving cast</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.219.1">
// Example 04
template &lt;typename To, typename From&gt;
std::unique_ptr&lt;To&gt; move_cast(std::unique_ptr&lt;From&gt;&amp; p) {
 return std::unique_ptr&lt;To&gt;(static_cast&lt;To*&gt;(p.release()));
}</span></pre>
<p><span class="koboSpan" id="kobo.220.1">Here, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">static_cast</span></strong><span class="koboSpan" id="kobo.222.1"> to cast to the derived class, which works if the assumed relation (that the base object really is the expected derived object) is correct, otherwise, the results are undefined. </span><span class="koboSpan" id="kobo.222.2">We can test this assumption at runtime if we want to, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">dynamic_cast</span></strong><span class="koboSpan" id="kobo.224.1"> instead. </span><span class="koboSpan" id="kobo.224.2">Here is a version that does the test, but only if asserts are enabled (we could </span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.225.1">throw an exception instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">the assert):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
// Example 04
template &lt;typename To, typename From&gt;
std::unique_ptr&lt;To&gt; move_cast(std::unique_ptr&lt;From&gt;&amp; p) {
#ifndef NDEBUG
 auto p1 =
   std::unique_ptr&lt;To&gt;(dynamic_cast&lt;To*&gt;(p.release()));
 assert(p1);
 return p1;
#else
 return std::unique_ptr&lt;To&gt;(static_cast&lt;To*&gt;(p.release()));
#endif
}</span></pre>
<p><span class="koboSpan" id="kobo.228.1">If all objects will be owned by instances of a unique pointer, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">VeteranUnit</span></strong><span class="koboSpan" id="kobo.230.1"> decorator has to accept a pointer in its constructor and move the object out of </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">this pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.232.1">
// Example 04
template &lt;typename U&gt; class VeteranUnit : public U {
  public:
  template &lt;typename P&gt;
  VeteranUnit(P&amp;&amp; p,
              double strength_bonus,
              double armor_bonus) :
    U(std::move(*move_cast&lt;U&gt;(p))),
    strength_bonus_(strength_bonus),
    armor_bonus_(armor_bonus) {}
  double attack() { return U::attack() + strength_bonus_; }
  double defense() { return U::defense() + armor_bonus_; }
  private:
  double strength_bonus_;
  double armor_bonus_;
};</span></pre>
<p><span class="koboSpan" id="kobo.233.1">The tricky part here is</span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.234.1"> in the initialization of the base class </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">U</span></strong><span class="koboSpan" id="kobo.236.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">VeteranUnit&lt;U&gt;</span></strong><span class="koboSpan" id="kobo.238.1"> - we have to move the unit from a unique pointer to the base class into a move-constructor of the derived class (there is no way to simply move the object from one unique pointer to another; we need to wrap it into the derived class). </span><span class="koboSpan" id="kobo.238.2">We have to do this without leaking any memory, too. </span><span class="koboSpan" id="kobo.238.3">The original, unique pointer, is released, so its destructor will do nothing, but our </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">move_cast</span></strong><span class="koboSpan" id="kobo.240.1"> returns a new unique pointer that now owns the same object. </span><span class="koboSpan" id="kobo.240.2">This unique pointer is a temporary variable and will be deleted at the end of the initialization of the new object, but not before we use its object to construct a new derived object that is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">VeteranUnit</span></strong><span class="koboSpan" id="kobo.242.1"> (the move-initialization of the unit object itself does not save any time versus copy in our case, but it is a good practice in the event a more heavyweight unit object provides an optimized </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">move constructor).</span></span></p>
<p><span class="koboSpan" id="kobo.244.1">Here is how this new decorator is used in a program that manages resources (units, in our case) by </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">unique pointers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.246.1">
// Example 04
Knight_ptr k(new Knight(10, 5));
  // Knight_ptr so we can call charge()
Unit_ptr o(new Ogre(12, 2));
  // Could be Orge_ptr if we needed one
Knight_ptr vk(new VeteranUnit&lt;Knight&gt;(k, 7, 2));
Unit_ptr vo(new VeteranUnit&lt;Ogre&gt;(o, 1, 9));
Unit_ptr vvo(new VeteranUnit&lt;VeteranUnit&lt;Ogre&gt;&gt;(vo, 1, 9));
vk-&gt;hit(*vvo); // Miss
vk-&gt;charge(); // Works because vk is Knight_ptr
vk-&gt;hit(*vvo); // Hit</span></pre>
<p><span class="koboSpan" id="kobo.247.1">Note that we did not redefine the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">hit()</span></strong><span class="koboSpan" id="kobo.249.1"> function - it still accepts a unit object by reference. </span><span class="koboSpan" id="kobo.249.2">This is correct because this function does not take ownership of the object - it merely operates on it. </span><span class="koboSpan" id="kobo.249.3">There is no need to pass an owning pointer into it - that would suggest a transfer </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">of ownership.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">Note that, strictly </span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.252.1">speaking, there is very little difference between this example and the last one - the moved-from unit should not be accessed either way. </span><span class="koboSpan" id="kobo.252.2">Practically speaking, there is a significant difference - the moved-from pointer no longer owns the object. </span><span class="koboSpan" id="kobo.252.3">Its value is null, so any attempt to operate on the original unit after it was promoted will become evident in very short order (the program will dereference a null pointer </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">and crash).</span></span></p>
<p><span class="koboSpan" id="kobo.254.1">As we have seen, we can decorate an already decorated class, as the effects of the decorators stack up. </span><span class="koboSpan" id="kobo.254.2">Similarly, we can apply two different decorators to the same class. </span><span class="koboSpan" id="kobo.254.3">Each decorator adds a particular new behavior to the class. </span><span class="koboSpan" id="kobo.254.4">In our game engine, we can print the results of each attack, whether or not there was a hit. </span><span class="koboSpan" id="kobo.254.5">But if the result does not match the expectations, we don’t know why. </span><span class="koboSpan" id="kobo.254.6">For debugging, it might be useful to print the attack and defense values. </span><span class="koboSpan" id="kobo.254.7">We would not want to do this all the time for all units, but for the part of the code we are interested in, we could use a debugging decorator that adds new behavior to the units to print the intermediate results of </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">the calculations.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">DebugDecorator</span></strong><span class="koboSpan" id="kobo.258.1"> uses the same design idea as the previous decorator - it’s a class template that generates a class that’s derived from the object to be decorated. </span><span class="koboSpan" id="kobo.258.2">Its </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">attack()</span></strong><span class="koboSpan" id="kobo.260.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">defense()</span></strong><span class="koboSpan" id="kobo.262.1"> virtual functions forward the calls to the base class and print </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">the results:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.264.1">
// Example 05
template &lt;typename U&gt; class DebugDecorator : public U {
  public:
  using U::U;
  template &lt;typename P&gt; DebugDecorator(P&amp;&amp; p) :
    U(std::move(*move_cast&lt;U&gt;(p))) {}
  double attack() {
    double res = U::attack();
    cout &lt;&lt; "Attack: " &lt;&lt; res &lt;&lt; endl;
    return res;
  }
  double defense() {
    double res = U::defense();
    cout &lt;&lt; "Defense: " &lt;&lt; res &lt;&lt; endl;
    return res;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.265.1">In this example, we</span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.266.1"> left out the dynamic memory allocations and relied on moving the objects themselves for ownership transfer. </span><span class="koboSpan" id="kobo.266.2">There is no reason we cannot have both stackable decorators and </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">unique pointers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
// Example 06
template &lt;typename U&gt; class VeteranUnit : public U {
  ...
</span><span class="koboSpan" id="kobo.268.2">};
template &lt;typename U&gt; class DebugDecorator : public U {
  using U::U;
  public:
  template &lt;typename P&gt;
  DebugDecorator(std::unique_ptr&lt;P&gt;&amp; p) :
    U(std::move(*move_cast&lt;U&gt;(p))) {}
  double attack() override {
    double res = U::attack();
    cout &lt;&lt; "Attack: " &lt;&lt; res &lt;&lt; endl;
    return res;
  }
  double defense() override {
    double res = U::defense();
    cout &lt;&lt; "Defense: " &lt;&lt; res &lt;&lt; endl;
    return res;
  }
  using ptr = std::unique_ptr&lt;DebugDecorator&gt;;
  template &lt;typename... </span><span class="koboSpan" id="kobo.268.3">Args&gt;
  static ptr construct(Args&amp;&amp;... </span><span class="koboSpan" id="kobo.268.4">args) { return
    ptr{new DebugDecorator(std::forward&lt;Args&gt;(args)...)};
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.269.1">When implementing</span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.270.1"> decorators, you should be careful to not inadvertently change the behavior of the base class in unexpected ways. </span><span class="koboSpan" id="kobo.270.2">For example, consider this possible implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">DebugDecorator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.274.1">
template &lt;typename U&gt; class DebugDecorator : public U {
  double attack() {
    cout &lt;&lt; "Attack: " &lt;&lt; U::attack() &lt;&lt; endl;
    return U::attack();
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.275.1">There is a subtle bug here - the decorated object, in addition to the expected new behavior - the printout - hides a change in the original behavior - it calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">attack()</span></strong><span class="koboSpan" id="kobo.277.1"> twice on the base class. </span><span class="koboSpan" id="kobo.277.2">Not only might the printed value be incorrect if two calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">attack()</span></strong><span class="koboSpan" id="kobo.279.1"> return different values, but also any one-time attack bonuses such as the knight’s charge will </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">be canceled.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">DebugDecorator</span></strong><span class="koboSpan" id="kobo.282.1"> adds very similar behavior to each member function it decorates. </span><span class="koboSpan" id="kobo.282.2">C++ has a rich</span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.283.1"> set of tools that are aimed specifically at improving code reuse and reducing duplication. </span><span class="koboSpan" id="kobo.283.2">Let’s see if we can do better and come up with a more reusable, </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">uni</span><a id="_idTextAnchor751"/><span class="koboSpan" id="kobo.285.1">v</span><a id="_idTextAnchor752"/><span class="koboSpan" id="kobo.286.1">ersal decorator.</span></span></p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor753"/><span class="koboSpan" id="kobo.287.1">Polymorphic decorators and their limitations</span></h2>
<p><span class="koboSpan" id="kobo.288.1">Some decorators </span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.289.1">are very specific to the classes they </span><a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.290.1">modify, and their behavior is narrowly targeted. </span><span class="koboSpan" id="kobo.290.2">Others are very general, at least in principle. </span><span class="koboSpan" id="kobo.290.3">For example, a debugging decorator that logs function calls and prints return values could be used with any function if we could only implement </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">it correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">Such an implementation is pretty straightforward in C++14 or above using </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">variadic</span></strong><span class="koboSpan" id="kobo.294.1"> templates, parameter packs, and </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">perfect forwarding:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.296.1">
// Example 07
template &lt;typename Callable&gt; class DebugDecorator {
  public:
  template &lt;typename F&gt;
  DebugDecorator(F&amp;&amp; f, const char* s) :
    c_(std::forward&lt;F&gt;(f)), s_(s) {}
  template &lt;typename ... </span><span class="koboSpan" id="kobo.296.2">Args&gt;
  auto operator()(Args&amp;&amp; ... </span><span class="koboSpan" id="kobo.296.3">args) const {
    cout &lt;&lt; "Invoking " &lt;&lt; s_ &lt;&lt; endl;
    auto res = c_(std::forward&lt;Args&gt;(args) ...);
    cout &lt;&lt; "Result: " &lt;&lt; res &lt;&lt; endl;
    return res;
  }
  private:
  Callable c_;
  const std::string s_;
};</span></pre>
<p><span class="koboSpan" id="kobo.297.1">This decorator can be wrapped around any callable object or function (anything that can be called with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">()</span></strong><span class="koboSpan" id="kobo.299.1"> syntax) with any number of arguments. </span><span class="koboSpan" id="kobo.299.2">It prints the custom string and the result of the call. </span><span class="koboSpan" id="kobo.299.3">However, writing out the callable type is often tricky - it is much better to get the compiler to do it for us using template </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">argument deduction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
// Example 07
template &lt;typename Callable&gt;
  auto decorate_debug(Callable&amp;&amp; c, const char* s) {
  return DebugDecorator&lt;Callable&gt;(
    std::forward&lt;Callable&gt;(c), s);
}</span></pre>
<p><span class="koboSpan" id="kobo.302.1">This template</span><a id="_idIndexMarker906"/><span class="koboSpan" id="kobo.303.1"> function</span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.304.1"> deduces the type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">Callable</span></strong><span class="koboSpan" id="kobo.306.1"> and decorates it with the debugging wrapper. </span><span class="koboSpan" id="kobo.306.2">We can now apply it to any function or object. </span><span class="koboSpan" id="kobo.306.3">Here is a </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">decorated function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.308.1">
// Example 07
int g(int i, int j) { return i - j; } // Some function
auto g1 = decorate_debug(g, "g()"); // Decorated function
g1(5, 2); // Prints "Invoking g()" and "Result: 3"</span></pre>
<p><span class="koboSpan" id="kobo.309.1">We can also decorate a </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">callable object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.311.1">
// Example 07
struct S {
  double operator()() const {
    return double(rand() + 1)/double(rand() + 1);
  }
};
S s; // Callable
auto s1 =
  decorate_debug(s, "rand/rand"); // Decorated callable
s1(); s1(); // Prints the result, twice</span></pre>
<p><span class="koboSpan" id="kobo.312.1">Note that our decorator does not take ownership of the callable object (we could write it in such a way that it does so if we </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">wanted to).</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">We can even decorate a lambda expression, which is really just an implicitly typed callable object. </span><span class="koboSpan" id="kobo.314.2">The</span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.315.1"> one</span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.316.1"> in this example defines a callable object with two </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">integer arguments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.318.1">
// Example 07
auto f2 = decorate_debug(
  [](int i, int j) { return i + j; }, "i+j");
f2(5, 3); // Prints "Invoking i+j" and "Result: 8"</span></pre>
<p><span class="koboSpan" id="kobo.319.1">In our example, we decided to forward the callables both in the decorator class constructor and in the helper function. </span><span class="koboSpan" id="kobo.319.2">Often, the callables are passed by value instead and are assumed to be cheap to copy. </span><span class="koboSpan" id="kobo.319.3">In all cases, it is important that the decorator stores a copy of the callable in its data member. </span><span class="koboSpan" id="kobo.319.4">If you capture it by reference instead, there is a subtle error waiting </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">to happen:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.321.1">
template &lt;typename Callable&gt; class DebugDecorator {
  public:
  DebugDecorator(const Callable&amp; c, const char* s) :
    c_(c), s_(s) {}
  ...
</span><span class="koboSpan" id="kobo.321.2">  private:
  const Callable&amp; c_;
  const std::string s_;
};</span></pre>
<p><span class="koboSpan" id="kobo.322.1">Decorating a function is likely to work fine, but decorating a lambda will fail (although not necessarily in an immediately visible way). </span><span class="koboSpan" id="kobo.322.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">const Callable&amp; c_</span></strong><span class="koboSpan" id="kobo.324.1"> member is going to be bound to a temporary </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">lambda object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.326.1">
auto f2 = decorate_debug(
  [](int i, int j) { return i + j; }, "i+j");</span></pre>
<p><span class="koboSpan" id="kobo.327.1">The lifetime of this object ends at the semicolon at the end of this statement, and any subsequent use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">f2</span></strong><span class="koboSpan" id="kobo.329.1"> accesses a dangling reference (address sanitizer tools can help detect </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">such errors).</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">Our decorator has some limitations. </span><span class="koboSpan" id="kobo.331.2">First, it falls short when we try to decorate a function that</span><a id="_idIndexMarker910"/><span class="koboSpan" id="kobo.332.1"> does </span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.333.1">not return anything, such as the following lambda expression, which increments its argument but </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">returns nothing:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.335.1">
auto incr = decorate_debug([](int&amp; x) { ++x; }, "++x");
int i;
incr(i); // Does not compile</span></pre>
<p><span class="koboSpan" id="kobo.336.1">The problem lies with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">void res</span></strong><span class="koboSpan" id="kobo.338.1"> expression that is coming from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">auto res = ...</span></strong><span class="koboSpan" id="kobo.340.1"> line inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">DebugDecorator</span></strong><span class="koboSpan" id="kobo.342.1">. </span><span class="koboSpan" id="kobo.342.2">This makes sense since we cannot declare variables of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">void</span></strong><span class="koboSpan" id="kobo.344.1"> type. </span><span class="koboSpan" id="kobo.344.2">This problem can be solved using </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">if constexpr</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.346.1">in C++17:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
// Example 08
template &lt;typename Callable&gt; class DebugDecorator {
  public:
  ...
</span><span class="koboSpan" id="kobo.347.2">  template &lt;typename... </span><span class="koboSpan" id="kobo.347.3">Args&gt;
  auto operator()(Args&amp;&amp;... </span><span class="koboSpan" id="kobo.347.4">args) const {
    cout &lt;&lt; "Invoking " &lt;&lt; s_ &lt;&lt; endl;
    using r_t = decltype(c_(std::forward&lt;Args&gt;(args)...));
    if constexpr (!std::is_same_v&lt;res_t, void&gt;) {
      auto res = c_(std::forward&lt;Args&gt;(args)...);
      cout &lt;&lt; "Result: " &lt;&lt; res &lt;&lt; endl;
      return res;
    } else {
      c_(std::forward&lt;Args&gt;(args)...);
    }
  }
    private:
    Callable c_;
    const std::string s_;
};</span></pre>
<p><span class="koboSpan" id="kobo.348.1">Before C++17, the most </span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.349.1">common alternative to if constexpr uses</span><a id="_idIndexMarker913"/><span class="koboSpan" id="kobo.350.1"> function overloading (the first argument is </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">std::true_type</span></strong><span class="koboSpan" id="kobo.352.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">std::false_type</span></strong><span class="koboSpan" id="kobo.354.1"> depending on the branch of if constexpr provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">corresponding function):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.356.1">
// Example 08a
template &lt;typename Callable&gt; class DebugDecorator {
  public:
  ...
</span><span class="koboSpan" id="kobo.356.2">  template &lt;typename... </span><span class="koboSpan" id="kobo.356.3">Args&gt;
  auto operator()(Args&amp;&amp;... </span><span class="koboSpan" id="kobo.356.4">args) const {
    cout &lt;&lt; "Invoking " &lt;&lt; s_ &lt;&lt; endl;
    using r_t = decltype(c_(std::forward&lt;Args&gt;(args)...));
    return this-&gt;call_impl(std::is_same&lt;res_t, void&gt;{},
                           std::forward&lt;Args&gt;(args)...);
    }
    private:
    Callable c_;
    const std::string s_;
    template &lt;typename... </span><span class="koboSpan" id="kobo.356.5">Args&gt;
    auto call_impl(std::false_type, Args&amp;&amp;... </span><span class="koboSpan" id="kobo.356.6">args) const {
      auto res = c_(std::forward&lt;Args&gt;(args)...);
      cout &lt;&lt; "Result: " &lt;&lt; res &lt;&lt; endl;
      return res;
    }
    template &lt;typename... </span><span class="koboSpan" id="kobo.356.7">Args&gt;
    void call_impl(std::true_type, Args&amp;&amp;... </span><span class="koboSpan" id="kobo.356.8">args) const {
      c_(std::forward&lt;Args&gt;(args)...);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.357.1">The second limitation </span><a id="_idIndexMarker914"/><span class="koboSpan" id="kobo.358.1">is </span><a id="_idIndexMarker915"/><span class="koboSpan" id="kobo.359.1">that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">auto</span></strong><span class="koboSpan" id="kobo.361.1"> return type of our decorator is deduced only </span><em class="italic"><span class="koboSpan" id="kobo.362.1">mostly</span></em><span class="koboSpan" id="kobo.363.1"> accurately - for example, if a function returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">double&amp;</span></strong><span class="koboSpan" id="kobo.365.1">, the decorated function will return just </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">double</span></strong><span class="koboSpan" id="kobo.367.1">. </span><span class="koboSpan" id="kobo.367.2">Lastly, wrapping member function calls is possible, but requires a somewhat </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">different syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">Now, the template mechanism in C++ is powerful, and there are ways to make our generic decorator even more generic. </span><span class="koboSpan" id="kobo.369.2">These ways also make it more complex. </span><span class="koboSpan" id="kobo.369.3">Code like this belongs in a library, such as the standard library, but in most practical applications a debugging decorator is not worth </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">such effort.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">The other limitation is that the more generic a decorator becomes, the less it can do. </span><span class="koboSpan" id="kobo.371.2">As it is, there are very few actions we could take that make sense for calling any function or member function (even to produce a good debug message in our decorator we might need to use compiler extensions, see </span><em class="italic"><span class="koboSpan" id="kobo.372.1">Example 09</span></em><span class="koboSpan" id="kobo.373.1">). </span><span class="koboSpan" id="kobo.373.2">We could add some debug printouts, and print the result as long as it has the stream output operator defined. </span><span class="koboSpan" id="kobo.373.3">We could lock a mutex to protect a non-thread-safe function call in a multi-threaded program. </span><span class="koboSpan" id="kobo.373.4">Maybe there are a few more general actions. </span><span class="koboSpan" id="kobo.373.5">But, in general, do not get seduced by the pursuit of the most generic code for its </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">own sake.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">Whether we have somewhat generic or very specific decorators, we often have the need to add</span><a id="_idIndexMarker916"/><span class="koboSpan" id="kobo.376.1"> multiple</span><a id="_idIndexMarker917"/><span class="koboSpan" id="kobo.377.1"> behaviors to an object. </span><span class="koboSpan" id="kobo.377.2">We have seen one such example already. </span><span class="koboSpan" id="kobo.377.3">Now, let’s review the problem of applying multiple </span><a id="_idTextAnchor754"/><span class="koboSpan" id="kobo.378.1">d</span><a id="_idTextAnchor755"/><span class="koboSpan" id="kobo.379.1">ecorators </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">more systematically.</span></span></p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor756"/><span class="koboSpan" id="kobo.381.1">Composable decorators</span></h2>
<p><span class="koboSpan" id="kobo.382.1">The decorator</span><a id="_idIndexMarker918"/><span class="koboSpan" id="kobo.383.1"> property that we would like to have here has a name  composability. </span><span class="koboSpan" id="kobo.383.2">Behaviors are composable if they can be applied to the same object separately: in our case, if we have two decorators, </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">A</span></strong><span class="koboSpan" id="kobo.385.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">B</span></strong><span class="koboSpan" id="kobo.387.1">. </span><span class="koboSpan" id="kobo.387.2">Therefore, </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">A(B(object))</span></strong><span class="koboSpan" id="kobo.389.1"> should have both behaviors applied. </span><span class="koboSpan" id="kobo.389.2">The alternative to composability is the explicit creation of the combined behaviors: to have both behaviors without composability, we would need to write a new decorator, </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">AB</span></strong><span class="koboSpan" id="kobo.391.1">. </span><span class="koboSpan" id="kobo.391.2">Since writing new code for any combination of several decorators would be impossible even for a relatively small number of decorators, composability is a very </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">important property.</span></span></p>
<p><span class="koboSpan" id="kobo.393.1">Fortunately, composability is not hard to achieve with our approach to decorators. </span><span class="koboSpan" id="kobo.393.2">The CRTP decorators we used in our game design earlier are </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">naturally composable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.395.1">
template &lt;typename U&gt; class VeteranUnit : public U { ... </span><span class="koboSpan" id="kobo.395.2">};
template &lt;typename U&gt; class DebugDecorator : public U { ...
</span><span class="koboSpan" id="kobo.395.3">};
Unit_ptr o(new DebugDecorator&lt;Ogre&gt;(12, 2));
Unit_ptr vo(new DebugDecorator&lt;VeteranUnit&lt;Ogre&gt;&gt;(o, 1, 9));</span></pre>
<p><span class="koboSpan" id="kobo.396.1">Each decorator inherits from the object it decorates and, thus, preserves its interface, except for the added behavior. </span><span class="koboSpan" id="kobo.396.2">Note that the order of the decorators matters since the new behavior is added before or after the decorated call. </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">DebugDecorator</span></strong><span class="koboSpan" id="kobo.398.1"> applies to the object it decorates and provides debugging for it, so a </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">VeteranUnit&lt;DebugDecorator&lt;Ogre&gt;&gt;</span></strong><span class="koboSpan" id="kobo.400.1"> object would debug the base portion of the object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">Ogre</span></strong><span class="koboSpan" id="kobo.402.1">), which can be useful </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">Our (somewhat) universal decorators can be composed as well. </span><span class="koboSpan" id="kobo.404.2">We already have a debugging decorator that can work with many different callable objects, and we mentioned a possible need to protect these calls with a mutex. </span><span class="koboSpan" id="kobo.404.3">We can now implement such a locking decorator in a similar manner (and with similar limitations) to the polymorphic </span><a id="_idIndexMarker919"/><span class="No-Break"><span class="koboSpan" id="kobo.405.1">debugging decorator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.406.1">
// Example 10
template &lt;typename Callable&gt; class LockDecorator {
  public:
  template &lt;typename F&gt;
  LockDecorator(F&amp;&amp; f, std::mutex&amp; m) :
    c_(std::forward&lt;F&gt;(f)), m_(m) {}
  template &lt;typename ... </span><span class="koboSpan" id="kobo.406.2">Args&gt;
  auto operator()(Args&amp;&amp; ... </span><span class="koboSpan" id="kobo.406.3">args) const {
    std::lock_guard&lt;std::mutex&gt; l(m_);
    return c_(std::forward&lt;Args&gt;(args) ...);
  }
  private:
  Callable c_;
  std::mutex&amp; m_;
};
template &lt;typename Callable&gt;
auto decorate_lock(Callable&amp;&amp; c, std::mutex&amp; m) {
  return
    LockDecorator&lt;Callable&gt;(std::forward&lt;Callable&gt;(c), m);
}</span></pre>
<p><span class="koboSpan" id="kobo.407.1">Again, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">decorate_lock()</span></strong><span class="koboSpan" id="kobo.409.1"> helper function to delegate to the compiler the tedious work of figuring out the right type of the callable object. </span><span class="koboSpan" id="kobo.409.2">We can now use a mutex to protect a function call that is </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">not thread-safe:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.411.1">
std::mutex m;
auto safe_f = decorate_lock([](int x) {
  return unsafe_f(x); }, m
);</span></pre>
<p><span class="koboSpan" id="kobo.412.1">If we want to protect a function by a mutex and have a debug printout when it’s called, we do not need to write a new </span><em class="italic"><span class="koboSpan" id="kobo.413.1">locking debugging decorator,</span></em><span class="koboSpan" id="kobo.414.1"> but instead can apply both decorators </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">in sequence:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
auto safe_f = decorate_debug(
  decorate_lock(
    [](int x) { return unsafe_f(x); },
    m
  ),
  "f(x)");</span></pre>
<p><span class="koboSpan" id="kobo.417.1">This example demonstrates the benefits of composability - we do not have to write a special </span><a id="_idIndexMarker920"/><span class="koboSpan" id="kobo.418.1">decorator for every combination of behaviors (think how many decorators you would have to write for any combination of five different primary decorators if they were </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">not composable!).</span></span></p>
<p><span class="koboSpan" id="kobo.420.1">This composability is achieved easily in our decorators because they preserve the interface of the original object, at least the part we are interested in - the behavior changes, but the interface does not. </span><span class="koboSpan" id="kobo.420.2">When a decorator is used as an original object for another decorator, the preserved interface is once again preserved, and </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">This preservation of the interface is a fundamental feature of the Decorator pattern. </span><span class="koboSpan" id="kobo.422.2">It is also one of its most serious limitations. </span><span class="koboSpan" id="kobo.422.3">Our locking decorator is not nearly as useful as it may seem at first glance (so do not go around your code bolting a lock onto every call when you need to </span><a id="_idIndexMarker921"/><span class="koboSpan" id="kobo.423.1">make the code thread-safe). </span><span class="koboSpan" id="kobo.423.2">As we will see next, not every interface can be made thread-safe, no matter how good the implementation is. </span><span class="koboSpan" id="kobo.423.3">That’s when we have to change the interface in a</span><a id="_idTextAnchor757"/><span class="koboSpan" id="kobo.424.1">ddition to modifying the behavior. </span><span class="koboSpan" id="kobo.424.2">This i</span><a id="_idTextAnchor758"/><span class="koboSpan" id="kobo.425.1">s the job for the </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">Adapter pattern.</span></span></p>
<h1 id="_idParaDest-291"><a id="_idTextAnchor759"/><span class="koboSpan" id="kobo.427.1">The Adapter pattern</span></h1>
<p><span class="koboSpan" id="kobo.428.1">We ended the last</span><a id="_idIndexMarker922"/><span class="koboSpan" id="kobo.429.1"> section with the notion that the decorator pattern has particular advantages that come from preserving the decorated interface and that these advantages can sometimes turn into limitations. </span><span class="koboSpan" id="kobo.429.2">The Adapter pattern is a more general pattern that can be used in </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">such cases.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">The Adapter pattern is defined very generally - it is a structural pattern that allows an interface of a class to be used as another, different interface. </span><span class="koboSpan" id="kobo.431.2">It allows an existing class to be used in code that expects a different interface, without modifying the original class. </span><span class="koboSpan" id="kobo.431.3">Such adapters are sometimes </span><a id="_idIndexMarker923"/><span class="koboSpan" id="kobo.432.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.433.1">class wrappers</span></strong><span class="koboSpan" id="kobo.434.1"> since they </span><em class="italic"><span class="koboSpan" id="kobo.435.1">wrap</span></em><span class="koboSpan" id="kobo.436.1"> around a class and present a different interface. </span><span class="koboSpan" id="kobo.436.2">You may recall that decorators are also sometimes called </span><strong class="bold"><span class="koboSpan" id="kobo.437.1">class wrappers</span></strong><span class="koboSpan" id="kobo.438.1">, much for the </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">same reason.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">However, Adapter is a very general, broad pattern. </span><span class="koboSpan" id="kobo.440.2">It can be used to implement several other, more narrowly defined patterns - in particular, the decorator. </span><span class="koboSpan" id="kobo.440.3">The decorator pattern is easier to follow, so we dealt with that first. </span><span class="koboSpan" id="kobo.440.4">Now,</span><a id="_idTextAnchor760"/> <a id="_idTextAnchor761"/><span class="koboSpan" id="kobo.441.1">we will move on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">general case.</span></span></p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor762"/><span class="koboSpan" id="kobo.443.1">Basic Adapter pattern</span></h2>
<p><span class="koboSpan" id="kobo.444.1">Let’s follow on from the final example from the last section - the locking decorator. </span><span class="koboSpan" id="kobo.444.2">It calls any function under a lock, so no other function protected by the same mutex can be called on any other thread at the same time. </span><span class="koboSpan" id="kobo.444.3">In some cases, this could be enough to make the entire code thread-safe. </span><span class="koboSpan" id="kobo.444.4">Often, it </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">is not.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">To demonstrate this, we are going to implement a thread-safe queue object. </span><span class="koboSpan" id="kobo.446.2">A queue is a moderately complex data structure, even without thread safety, but, fortunately, we do not need to start from scratch - we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">std::queue</span></strong><span class="koboSpan" id="kobo.448.1"> in the C++ standard library. </span><span class="koboSpan" id="kobo.448.2">We can push objects onto the queue and take them from the queue in first-in-first-out order, but only on one thread - it is not safe to push two objects onto the same queue from two different threads at the same time, for example. </span><span class="koboSpan" id="kobo.448.3">But we have a solution for that - we can implement a locking queue as a decorator for the basic one. </span><span class="koboSpan" id="kobo.448.4">Since we are not concerned about the empty base optimization here (</span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">std::queue</span></strong><span class="koboSpan" id="kobo.450.1"> is not an empty class) and we have to forward every member function call, we do not need the inheritance and can use composition instead. </span><span class="koboSpan" id="kobo.450.2">Our decorator will contain the queue and the lock. </span><span class="koboSpan" id="kobo.450.3">Wrapping the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">push()</span></strong><span class="koboSpan" id="kobo.452.1"> method is easy. </span><span class="koboSpan" id="kobo.452.2">There are two versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">push()</span></strong><span class="koboSpan" id="kobo.454.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">std::queue</span></strong><span class="koboSpan" id="kobo.456.1"> - one moves the object and one copies it. </span><span class="koboSpan" id="kobo.456.2">We should protect both with </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">the lock:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.458.1">
// Example 11
template &lt;typename T&gt; class locking_queue {
  using mutex = std::mutex;
  using lock_guard = std::lock_guard&lt;mutex&gt;;
  using value_type = typename std::queue&lt;T&gt;::value_type;
  void push(const value_type&amp; value) {
    lock_guard l(m_);
    q_.push(value);
  }
  void push(value_type&amp;&amp; value) {
    lock_guard l(m_);
    q_.push(value);
  }
  private:
  std::queue&lt;T&gt; q_;
  mutex m_;
};</span></pre>
<p><span class="koboSpan" id="kobo.459.1">Now, let’s turn our </span><a id="_idIndexMarker924"/><span class="koboSpan" id="kobo.460.1">attention to getting elements off the queue. </span><span class="koboSpan" id="kobo.460.2">The standard queue has three relevant member functions - first, there is </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">front()</span></strong><span class="koboSpan" id="kobo.462.1">, which lets us access the front element of the queue, but does not remove it from the queue. </span><span class="koboSpan" id="kobo.462.2">Then, there is </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">pop()</span></strong><span class="koboSpan" id="kobo.464.1">, which removes the front element but returns nothing (it gives no access to the front element - it just removes it). </span><span class="koboSpan" id="kobo.464.2">Both of these functions should not be called if the queue is empty - there is no error checking, but the result </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">is undefined.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">Finally, there is the third function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">empty()</span></strong><span class="koboSpan" id="kobo.468.1">; it returns false if the queue is not empty, and then we can call </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">front()</span></strong><span class="koboSpan" id="kobo.470.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">pop()</span></strong><span class="koboSpan" id="kobo.472.1">. </span><span class="koboSpan" id="kobo.472.2">If we decorate them with locking, we will be able to write code like </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.474.1">
locking_queue&lt;int&gt; q;
q.push(5);
... </span><span class="koboSpan" id="kobo.474.2">sometime later in the program ...
</span><span class="koboSpan" id="kobo.474.3">if (!q.empty()) {
  int i = q.front();
  q.pop();
}</span></pre>
<p><span class="koboSpan" id="kobo.475.1">Each function is thread-safe by itself. </span><span class="koboSpan" id="kobo.475.2">The entire combination of them is not. </span><span class="koboSpan" id="kobo.475.3">It is important to understand why. </span><span class="koboSpan" id="kobo.475.4">First, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">q.empty()</span></strong><span class="koboSpan" id="kobo.477.1">. </span><span class="koboSpan" id="kobo.477.2">Let’s assume that it returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">false</span></strong><span class="koboSpan" id="kobo.479.1">, so we know there is at least one element on the queue. </span><span class="koboSpan" id="kobo.479.2">We go on to access it on the next line by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">q.front()</span></strong><span class="koboSpan" id="kobo.481.1">, which returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">5</span></strong><span class="koboSpan" id="kobo.483.1">. </span><span class="koboSpan" id="kobo.483.2">But this is just one of many threads in the program. </span><span class="koboSpan" id="kobo.483.3">Another thread is going through the same code at the same time (enabling this behavior is the point of the exercise). </span><span class="koboSpan" id="kobo.483.4">That thread, too, calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">q.empty()</span></strong><span class="koboSpan" id="kobo.485.1"> and also gets </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">false</span></strong><span class="koboSpan" id="kobo.487.1"> - as we just said, there is an element in the queue, and we have done nothing to remove it yet. </span><span class="koboSpan" id="kobo.487.2">The second thread also calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">q.front()</span></strong><span class="koboSpan" id="kobo.489.1"> and gets </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">5</span></strong><span class="koboSpan" id="kobo.491.1"> as well. </span><span class="koboSpan" id="kobo.491.2">That is already a problem - two threads each tried to take an element from the queue, but got the same one instead. </span><span class="koboSpan" id="kobo.491.3">But it gets worse - our first thread now calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">q.pop()</span></strong><span class="koboSpan" id="kobo.493.1"> and removes </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">5</span></strong><span class="koboSpan" id="kobo.495.1"> from the queue. </span><span class="koboSpan" id="kobo.495.2">The queue is now empty, but the second thread does not know about this - it called </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">q.empty()</span></strong><span class="koboSpan" id="kobo.497.1"> earlier. </span><span class="koboSpan" id="kobo.497.2">Therefore, the second thread now calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">q.pop()</span></strong><span class="koboSpan" id="kobo.499.1"> as well, this time on an empty queue. </span><span class="koboSpan" id="kobo.499.2">The best-case scenario here is that the program will crash </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">right away.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">We have just seen a</span><a id="_idIndexMarker925"/><span class="koboSpan" id="kobo.502.1"> specific case of a general problem - a sequence of actions, each of which is thread-safe, but is not thread-safe as a whole. </span><span class="koboSpan" id="kobo.502.2">In fact, this </span><em class="italic"><span class="koboSpan" id="kobo.503.1">locking queue</span></em><span class="koboSpan" id="kobo.504.1"> is entirely useless, and there is no way to write thread-safe code with it. </span><span class="koboSpan" id="kobo.504.2">What we need is a single thread-safe function that performs the entire transaction under one lock, as a single uninterruptible action (such transactions are called </span><strong class="bold"><span class="koboSpan" id="kobo.505.1">atomic</span></strong><span class="koboSpan" id="kobo.506.1">). </span><span class="koboSpan" id="kobo.506.2">The transaction, in our case, is the removal of the front element if it’s present, and some kind of error diagnostic if it’s not. </span><span class="koboSpan" id="kobo.506.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">std::queue</span></strong><span class="koboSpan" id="kobo.508.1"> interface does not provide such a </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">transactional API.</span></span></p>
<p><span class="koboSpan" id="kobo.510.1">So, now, we need a new pattern - one that transforms the existing interface of a class to our needs for a different interface. </span><span class="koboSpan" id="kobo.510.2">This cannot be done with the decorator pattern, but this is exactly the problem that the Adapter pattern solves. </span><span class="koboSpan" id="kobo.510.3">Now that we have agreed that we need a different interface, we just have to decide what it should be. </span><span class="koboSpan" id="kobo.510.4">Our single new </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">pop()</span></strong><span class="koboSpan" id="kobo.512.1"> member function should do all of this - if the queue is not empty, it should remove the first element from the queue and return it, by copy or move, to the caller. </span><span class="koboSpan" id="kobo.512.2">If the queue is empty, it should not alter the state of the queue at all, but should somehow notify the caller that the queue was empty. </span><span class="koboSpan" id="kobo.512.3">One way to do this is to return two values - the element itself (if there is one) and a Boolean value that tells us whether the queue was empty or not. </span><span class="koboSpan" id="kobo.512.4">Here is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">pop()</span></strong><span class="koboSpan" id="kobo.514.1"> part of the locking queue, which is now an adapter, not </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">a decorator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.516.1">
// Example 11
template &lt;typename T&gt; class locking_queue {
  ... </span><span class="koboSpan" id="kobo.516.2">the push() is unchanged ...
</span><span class="koboSpan" id="kobo.516.3">  bool pop(value_type&amp; value) {
    lock_guard l(m_);
    if (q_.empty()) return false;
    value = std::move(q_.front());
    q_.pop();
    return true;
  }
  private:
  std::queue&lt;T&gt; q_;
  mutex m_;
};</span></pre>
<p><span class="koboSpan" id="kobo.517.1">Note that we do</span><a id="_idIndexMarker926"/><span class="koboSpan" id="kobo.518.1"> not need to change </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">push()</span></strong><span class="koboSpan" id="kobo.520.1"> - the single function call already does everything we need, so that part of the interface is just forwarded one-to-one by our adapter. </span><span class="koboSpan" id="kobo.520.2">This version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">pop()</span></strong><span class="koboSpan" id="kobo.522.1"> returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">true</span></strong><span class="koboSpan" id="kobo.524.1"> if it removed an element from the queue, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">false</span></strong><span class="koboSpan" id="kobo.526.1"> otherwise. </span><span class="koboSpan" id="kobo.526.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">true</span></strong><span class="koboSpan" id="kobo.528.1"> is returned, the element is saved into the provided argument, but if </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">false</span></strong><span class="koboSpan" id="kobo.530.1"> is returned, the argument is unchanged. </span><span class="koboSpan" id="kobo.530.2">If the element type </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">T</span></strong><span class="koboSpan" id="kobo.532.1"> is move-assignable, a move will be used instead </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">of copy.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">This is, of course, not the only possible interface for such an atomic </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">pop()</span></strong><span class="koboSpan" id="kobo.536.1">. </span><span class="koboSpan" id="kobo.536.2">Another way would be to return both the element and the Boolean value as a pair. </span><span class="koboSpan" id="kobo.536.3">One significant difference is that there is now no way to leave the element unchanged - it’s the return value and it always has to be something. </span><span class="koboSpan" id="kobo.536.4">The natural way is to default-construct the element if there isn’t one on the queue (which implies a restriction on the element type </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">T</span></strong><span class="koboSpan" id="kobo.538.1"> - it has to </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">be default-constructible).</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">In C++17, the better alternative is to return </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">std::optional</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.544.1">
// Example 12
template &lt;typename T&gt; class locking_queue {
  ... </span><span class="koboSpan" id="kobo.544.2">the push() is unchanged ...
</span><span class="koboSpan" id="kobo.544.3">  std::optional&lt;value_type&gt; pop() {
    lock_guard l(m_);
    if (q_.empty()) return std::nullopt;
    value_type value = std::move(q_.front());
    q_.pop();
    return { value };
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.545.1">Depending on the application code that needs this queue, one of the interfaces may be preferable, and so there are other ways to design it as well. </span><span class="koboSpan" id="kobo.545.2">In all cases, we end up with two member functions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">push()</span></strong><span class="koboSpan" id="kobo.547.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">pop()</span></strong><span class="koboSpan" id="kobo.549.1">, that are protected by the same mutex. </span><span class="koboSpan" id="kobo.549.2">Now, any number of threads can execute any combination of these operations at the same time, and the behavior is well-defined. </span><span class="koboSpan" id="kobo.549.3">This means that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">locking_queue</span></strong><span class="koboSpan" id="kobo.551.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">is thread-safe.</span></span></p>
<p><span class="koboSpan" id="kobo.553.1">Converting an object from its current interface to the interface needed by a particular application, without </span><a id="_idIndexMarker927"/><span class="koboSpan" id="kobo.554.1">rewriting the object itself, is the purpose and use of the Adapter pattern. </span><span class="koboSpan" id="kobo.554.2">All kinds of interfaces may have to be converted, and so there are many different types of adapters. </span><span class="koboSpan" id="kobo.554.3">We will lear</span><a id="_idTextAnchor763"/><span class="koboSpan" id="kobo.555.1">n</span><a id="_idTextAnchor764"/><span class="koboSpan" id="kobo.556.1"> about some of them in the </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">next section.</span></span></p>
<h2 id="_idParaDest-293"><a id="_idTextAnchor765"/><span class="koboSpan" id="kobo.558.1">Function adapters</span></h2>
<p><span class="koboSpan" id="kobo.559.1">We have</span><a id="_idIndexMarker928"/><span class="koboSpan" id="kobo.560.1"> just seen </span><a id="_idIndexMarker929"/><span class="koboSpan" id="kobo.561.1">a class adapter that changes the interface of a class. </span><span class="koboSpan" id="kobo.561.2">Another kind of interface is a function (a member or a non-member function). </span><span class="koboSpan" id="kobo.561.3">A function has certain arguments, but we may want to call it with a different set of arguments. </span><span class="koboSpan" id="kobo.561.4">This would need an adapter. </span><span class="koboSpan" id="kobo.561.5">One common application of such adapters is known as currying one (or more) of the function’s arguments. </span><span class="koboSpan" id="kobo.561.6">All it means is that we have a function of several arguments, and we fix the value of one of these arguments, so we don’t have to specify it on every call. </span><span class="koboSpan" id="kobo.561.7">One example would be if we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">f(int i, int j)</span></strong><span class="koboSpan" id="kobo.563.1">, but we want </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">g(i)</span></strong><span class="koboSpan" id="kobo.565.1">, which is the same as </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">f(i, 5)</span></strong><span class="koboSpan" id="kobo.567.1">, only without typing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">5</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.569.1">every time.</span></span></p>
<p><span class="koboSpan" id="kobo.570.1">Here is a more interesting example that we are actually going to work our way through and implement an adapter. </span><span class="koboSpan" id="kobo.570.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">std::sort</span></strong><span class="koboSpan" id="kobo.572.1"> function takes an iterator range (the sequence to sort), but it can also be called with three arguments - the third one is the comparison object (by default, </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">std::less</span></strong><span class="koboSpan" id="kobo.574.1"> is used, which, in turn, calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">operator&lt;()</span></strong><span class="koboSpan" id="kobo.576.1"> on the objects </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">being sorted).</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">We want something else now - we want to compare floating-point numbers </span><em class="italic"><span class="koboSpan" id="kobo.579.1">fuzzily</span></em><span class="koboSpan" id="kobo.580.1">, with tolerance - if the two numbers </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">x</span></strong><span class="koboSpan" id="kobo.582.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">y</span></strong><span class="koboSpan" id="kobo.584.1"> are close enough to each other, then we don’t consider one to be less than the other. </span><span class="koboSpan" id="kobo.584.2">Only when </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">x</span></strong><span class="koboSpan" id="kobo.586.1"> is much less than </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">y</span></strong><span class="koboSpan" id="kobo.588.1"> do we want to enforce the sorted order where </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">x</span></strong><span class="koboSpan" id="kobo.590.1"> comes </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">before </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">y</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">Here is our</span><a id="_idIndexMarker930"/><span class="koboSpan" id="kobo.595.1"> comparison</span><a id="_idIndexMarker931"/><span class="koboSpan" id="kobo.596.1"> functor (a </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">callable object):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.598.1">
// Example 13
struct much_less {
  template &lt;typename T&gt;
  bool operator()(T x, T y) {
    return x &lt; y &amp;&amp; std::abs(x - y) &gt; tolerance);
  }
  static constexpr double tolerance = 0.2;
};</span></pre>
<p><span class="koboSpan" id="kobo.599.1">This comparison object can be used with a </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">standard sort:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.601.1">
std::vector&lt;double&gt; v;
std::sort(v.begin(), v.end(), much_less());</span></pre>
<p><span class="koboSpan" id="kobo.602.1">However, if we need this kind of sort often, we may want to curry the last argument and make ourselves an adapter that has just two arguments, the iterators, and the sorting function implied. </span><span class="koboSpan" id="kobo.602.2">Here is such an adapter - it is </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">very simple:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.604.1">
// Example 13
template&lt;typename RandomIt&gt;
  void sort_much_less(RandomIt first, RandomIt last) {
  std::sort(first, last, much_less());
}</span></pre>
<p><span class="koboSpan" id="kobo.605.1">Now, we can call a sort function with </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">two arguments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.607.1">
// Example 13
std::vector&lt;double&gt; v;
sort_much_less(v.begin(), v.end());</span></pre>
<p><span class="koboSpan" id="kobo.608.1">Now, if we often call sort in this manner to sort the entire container, we may want to change the interface once again and make </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">another adapter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.610.1">
// Example 14
template&lt;typename Container&gt; void sort_much_less(Container&amp;
   c) {
std::sort(c.begin(), c.end(), much_less());
}</span></pre>
<p><span class="koboSpan" id="kobo.611.1">In C++20, </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">std::sort</span></strong><span class="koboSpan" id="kobo.613.1"> and other STL functions have variants that accept ranges; they are a</span><a id="_idIndexMarker932"/><span class="koboSpan" id="kobo.614.1"> generalization </span><a id="_idIndexMarker933"/><span class="koboSpan" id="kobo.615.1">of our container adapter. </span><span class="koboSpan" id="kobo.615.2">Now, the code in our program looks </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">even simpler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.617.1">
// Example 14
std::vector&lt;double&gt; v;
sort_much_less(v);</span></pre>
<p><span class="koboSpan" id="kobo.618.1">It is important to point out that C++14 provides an alternative for writing such simple adapters that should, in general, be preferred; we can use a lambda expression, </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.620.1">
// Example 15
auto sort_much_less = [](auto first, auto last) {
  return std::sort(first, last, much_less());
};</span></pre>
<p><span class="koboSpan" id="kobo.621.1">Of course, the comparison function much_less() is itself a callable, so it could be a </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">lambda too:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.623.1">
// Example 15a
auto sort_much_less = [](auto first, auto last) {
  return std::sort(first, last,
    [](auto x, auto y) {
      static constexpr double tolerance = 0.2;
      return x &lt; y &amp;&amp; std::abs(x - y) &gt; tolerance;
    }); };</span></pre>
<p><span class="koboSpan" id="kobo.624.1">The container adapter is just as easy </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">to write:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.626.1">
// Example 16
auto sort_much_less = [](auto&amp; container) {
  return std::sort(container.begin(), container.end(),
                   much_less());
};</span></pre>
<p><span class="koboSpan" id="kobo.627.1">Note that you</span><a id="_idIndexMarker934"/><span class="koboSpan" id="kobo.628.1"> cannot </span><a id="_idIndexMarker935"/><span class="koboSpan" id="kobo.629.1">have both of these in the same program under the same name - lambda expressions cannot be </span><em class="italic"><span class="koboSpan" id="kobo.630.1">overloaded</span></em><span class="koboSpan" id="kobo.631.1"> in this manner; they are actually not functions at all, but rather objects (you can create an overload set from lambdas, as was shown in </span><a href="B19262_02.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.632.1">Chapter 2</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.633.1">, Class and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.634.1">Function Templates</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">Coming back to the matter of calling a function with some arguments fixed, or bound, to constant values, we should say that this is such a common need that the C++ standard library provides a standard customizable adapter for this purpose, </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">std::bind</span></strong><span class="koboSpan" id="kobo.638.1">. </span><a id="_idTextAnchor766"/><span class="koboSpan" id="kobo.639.1">Here is an example that shows us how it </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">is used:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.641.1">
// Example 17
using namespace std::placeholders; // For _1, _2 etc
int f3(int i, int j, int k) { return i + j + k; }
auto f2 = std::bind(f3, _1, _2, 42);
auto f1 = std::bind(f3, 5, _1, 7);
f2(2, 6);     // Returns 50
f1(3);     // Returns 15</span></pre>
<p><span class="koboSpan" id="kobo.642.1">This standard adapter has its own </span><em class="italic"><span class="koboSpan" id="kobo.643.1">mini-language</span></em><span class="koboSpan" id="kobo.644.1"> - the first argument to </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">std::bind</span></strong><span class="koboSpan" id="kobo.646.1"> is the function to be bound, while the rest are its arguments, in order. </span><span class="koboSpan" id="kobo.646.2">The arguments that should be bound are replaced by the specified values. </span><span class="koboSpan" id="kobo.646.3">The arguments that should remain free are replaced by the placeholders </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">_1</span></strong><span class="koboSpan" id="kobo.648.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">_2</span></strong><span class="koboSpan" id="kobo.650.1">, and so on (not necessarily in that order; that is, we can also change the order of the arguments). </span><span class="koboSpan" id="kobo.650.2">The returned value is of an unspecified type and has to be captured using </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">auto</span></strong><span class="koboSpan" id="kobo.652.1">. </span><span class="koboSpan" id="kobo.652.2">The only thing we know about the return value is that it can be called as a function with as many arguments as there are placeholders. </span><span class="koboSpan" id="kobo.652.3">It can also be used as a function in any context that expects a callable, for example, in </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">another </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">std::bind</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.656.1">
// Example 17
...
</span><span class="koboSpan" id="kobo.656.2">auto f1 = std::bind(f3, 5, _1, 7);
auto f0 = std::bind(f1, 3);
f1(3);    // Returns 15
f0();         // Also returns 15</span></pre>
<p><span class="koboSpan" id="kobo.657.1">However, these</span><a id="_idIndexMarker936"/><span class="koboSpan" id="kobo.658.1"> objects </span><a id="_idIndexMarker937"/><span class="koboSpan" id="kobo.659.1">are callables, not functions, and you will discover that if you try to assign one of them to a </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">function pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.661.1">
// Example 17
int (*p3)(int, int, int) = f3;    // OK
int (*p1)(int) = f1;            // Does not compile</span></pre>
<p><span class="koboSpan" id="kobo.662.1">In contrast, lambdas can be converted to function pointers if they have </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">no captures:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.664.1">
auto l1 = [](int i) { return f3(5, i, 7); }
int (*p1)(int) = l1;            // OK</span></pre>
<p><span class="koboSpan" id="kobo.665.1">As useful as </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">std::bind</span></strong><span class="koboSpan" id="kobo.667.1"> is, it does not free us from the need to learn how to write our own function adapters - its greatest limitation is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">std::bind</span></strong><span class="koboSpan" id="kobo.669.1"> cannot bind template functions. </span><span class="koboSpan" id="kobo.669.2">We cannot write </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.671.1">
auto sort_much_less = std::bind(std::sort, _1, _2, much_less()); // No!</span></pre>
<p><span class="koboSpan" id="kobo.672.1">This does not compile. </span><span class="koboSpan" id="kobo.672.2">Inside a template, we can bind the specific instantiation of it, but, at least in our sorting example, this really does not buy </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">us anything:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.674.1">
template&lt;typename RandomIt&gt;
void sort_much_less(RandomIt first, RandomIt last) {
  auto f = std::bind(std::sort&lt;RandomIt, much_less&gt;,
                     _1, _2, much_less());
  f(first, last, much_less());
}</span></pre>
<p><span class="koboSpan" id="kobo.675.1">As we mentioned at the beginning of this section, decorators can be seen as a special case of the </span><a id="_idIndexMarker938"/><span class="koboSpan" id="kobo.676.1">Adapter</span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.677.1"> pattern. </span><span class="koboSpan" id="kobo.677.2">Sometimes, the distinction is not so much in a particular application of the pattern but in how we choose to </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">view it.</span></span></p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor767"/><span class="koboSpan" id="kobo.679.1">Adapter or Decorator</span></h2>
<p><span class="koboSpan" id="kobo.680.1">Until now, we</span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.681.1"> described </span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.682.1">the Decorator as a pattern we use to augment an existing interface, while the Adapter is used to convert (adapt) an interface for integration with code that expects a different interface. </span><span class="koboSpan" id="kobo.682.2">The distinction is not </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">always clear.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">For example, let us consider a simple class that adapts the result of the system call </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">std::time</span></strong><span class="koboSpan" id="kobo.686.1"> to a printable date format (</span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">std::chrono</span></strong><span class="koboSpan" id="kobo.688.1"> provides this functionality, but it makes for an easy-to-follow example). </span><span class="koboSpan" id="kobo.688.2">The function </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">std::time</span></strong><span class="koboSpan" id="kobo.690.1"> returns a value of the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">std::time_t</span></strong><span class="koboSpan" id="kobo.692.1"> which is an integer containing the time in seconds since some standard moment in the past that is called the “start of the epoch.” </span><span class="koboSpan" id="kobo.692.2">Another system function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">localtime</span></strong><span class="koboSpan" id="kobo.694.1">, converts this value to a struct that contains the date elements: year, month, and day (also hours, minutes, etc). </span><span class="koboSpan" id="kobo.694.2">The calendar calculations, in general, are rather non-trivial (which is why </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">std::chrono</span></strong><span class="koboSpan" id="kobo.696.1"> is not as simple as we might wish) but for now, let us assume that the system library does the right thing and all we have to do is print the date in the right format. </span><span class="koboSpan" id="kobo.696.2">For example, here is how to print the current date in the </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">US format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.698.1">
const std::time_t now = std::time(nullptr);
const tm local_tm = *localtime(&amp;now);
cout &lt;&lt; local_tm.tm_mon + 1 &lt;&lt; "/" &lt;&lt;
        local_tm.tm_mday &lt;&lt; "/" &lt;&lt;
        local_tm.tm_year + 1900;</span></pre>
<p><span class="koboSpan" id="kobo.699.1">We want to create an adapter that converts a time in seconds to the date in a particular format and lets us print it; we will need separate adapters for the US format (month first), European format (day first), and ISO format (</span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">year first).</span></span></p>
<p><span class="koboSpan" id="kobo.701.1">The implementation</span><a id="_idIndexMarker942"/><span class="koboSpan" id="kobo.702.1"> of</span><a id="_idIndexMarker943"/><span class="koboSpan" id="kobo.703.1"> the adapter is </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">pretty straightforward:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.705.1">
// Example 18
class USA_Date {
  public:
  explicit USA_Date(std::time_t t) : t_(t) {}
  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                                  const USA_Date&amp; d) {
    const tm local_tm = *localtime(&amp;d.t_);
    out &lt;&lt; local_tm.tm_mon + 1 &lt;&lt; "/" &lt;&lt;
           local_tm.tm_mday &lt;&lt; "/" &lt;&lt;
           local_tm.tm_year + 1900;
    return out;
  }
  private:
  const std::time_t t_;
};</span></pre>
<p><span class="koboSpan" id="kobo.706.1">The other two date formats are similar except for the order in which we print the fields. </span><span class="koboSpan" id="kobo.706.2">In fact, they are so similar that we may want to refactor the code to avoid typing three almost identical classes. </span><span class="koboSpan" id="kobo.706.3">The easiest way to do this is to use a template and encode the field order in a “format code” which specifies the order in which we print the day (field 0), month (field 1), and year (field 2). </span><span class="koboSpan" id="kobo.706.4">For example, “format” 210 means year, then month, then day – the ISO </span><a id="_idIndexMarker944"/><span class="koboSpan" id="kobo.707.1">date</span><a id="_idIndexMarker945"/><span class="koboSpan" id="kobo.708.1"> format. </span><span class="koboSpan" id="kobo.708.2">The format code can be an integer </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">template parameter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.710.1">
// Example 19
template &lt;size_t F&gt; class Date {
  public:
  explicit Date(std::time_t t) : t_(t) {}
  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                                  const Date&amp; d) {
    const tm local_tm = *localtime(&amp;d.t_);
    const int t[3] = { local_tm.tm_mday,
                       local_tm.tm_mon + 1,
                       local_tm.tm_year + 1900 };
    constexpr size_t i1 = F/100;
    constexpr size_t i2 = (F - i1*100)/10;
    constexpr size_t i3 = F - i1*100 - i2*10;
    static_assert(i1 &gt;= 0 &amp;&amp; i1 &lt;= 2 &amp;&amp; ..., "Bad format");
    out &lt;&lt; t[i1] &lt;&lt; "/" &lt;&lt; t[i2] &lt;&lt; "/" &lt;&lt; t[i3];
    return out;
  }
  private:
  const std::time_t t_;
};
using USA_Date = Date&lt;102&gt;;
using European_Date = Date&lt;12&gt;;
using ISO_Date = Date&lt;210&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.711.1">Our little wrapper adapts a type (an integer) to be used in the code that expects dates in a particular format. </span><span class="koboSpan" id="kobo.711.2">Or does it decorate the integer with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">operator&lt;&lt;()</span></strong><span class="koboSpan" id="kobo.713.1">? </span><span class="koboSpan" id="kobo.713.2">The best answer is … whichever one is more helpful to you to think about your particular problem. </span><span class="koboSpan" id="kobo.713.3">It is important to remember the purpose of speaking in the language of the patterns in the first place: we do it to have a compact and commonly understood way to describe our software problems and the solutions we choose. </span><span class="koboSpan" id="kobo.713.4">When multiple patterns appear to yield similar results, the description you choose lets you focus on the aspect that is most important </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">to you.</span></span></p>
<p><span class="koboSpan" id="kobo.715.1">So far, we have considered only adapters that convert runtime interfaces, which are the interfaces we call when the program is executed. </span><span class="koboSpan" id="kobo.715.2">However, C++ has compile-time interfaces as well - one of the prime examples that we considered in the last chapter was policy-based </span><a id="_idIndexMarker946"/><span class="koboSpan" id="kobo.716.1">design. </span><span class="koboSpan" id="kobo.716.2">These </span><a id="_idIndexMarker947"/><span class="koboSpan" id="kobo.717.1">interfaces are not always exactly what we need them to</span><a id="_idTextAnchor768"/> <a id="_idTextAnchor769"/><span class="koboSpan" id="kobo.718.1">be, so we have to learn to write compile-time </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">adapters next.</span></span></p>
<h2 id="_idParaDest-295"><a id="_idTextAnchor770"/><span class="koboSpan" id="kobo.720.1">Compile-time adapters</span></h2>
<p><span class="koboSpan" id="kobo.721.1">In </span><a href="B19262_16.xhtml#_idTextAnchor739"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.722.1">Chapter 16</span></em></span></a><span class="koboSpan" id="kobo.723.1">,</span><em class="italic"><span class="koboSpan" id="kobo.724.1"> Adapters and Decorators</span></em><span class="koboSpan" id="kobo.725.1">, we learned about policies, which are building blocks for</span><a id="_idIndexMarker948"/><span class="koboSpan" id="kobo.726.1"> classes - they let the programmer</span><a id="_idIndexMarker949"/><span class="koboSpan" id="kobo.727.1"> customize the implementation for a particular behavior. </span><span class="koboSpan" id="kobo.727.2">As an example, we can implement this policy-based smart pointer that automatically deletes the object it owns. </span><span class="koboSpan" id="kobo.727.3">The policy is the particular implementation of </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">the deletion:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.729.1">
// Chapter 15, Example 08
template &lt;typename T,
          template &lt;typename&gt; class DeletionPolicy =
                                    DeleteByOperator&gt;
class SmartPtr {
  public:
  explicit SmartPtr(T* p = nullptr,
    const DeletionPolicy&lt;T&gt;&amp; del_policy =
                             DeletionPolicy&lt;T&gt;())
  : p_(p), deletion_policy_(deletion_policy)
  {}
  ~SmartPtr() {
    deletion_policy_(p_);
  }
  ... </span><span class="koboSpan" id="kobo.729.2">pointer interface ...
</span><span class="koboSpan" id="kobo.729.3">  private:
  T* p_;
  DeletionPolicy&lt;T&gt; deletion_policy_;
};</span></pre>
<p><span class="koboSpan" id="kobo.730.1">Note that the deletion policy is itself a template - this is a </span><em class="italic"><span class="koboSpan" id="kobo.731.1">template</span></em><span class="koboSpan" id="kobo.732.1"> parameter. </span><span class="koboSpan" id="kobo.732.2">The default deletion policy is to use </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">operator delete</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.735.1">
template &lt;typename T&gt; struct DeleteByOperator {
  void operator()(T* p) const {
    delete p;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.736.1">However, for</span><a id="_idIndexMarker950"/><span class="koboSpan" id="kobo.737.1"> objects</span><a id="_idIndexMarker951"/><span class="koboSpan" id="kobo.738.1"> allocated on a user-given heap, we need a different deletion policy that returns the memory to </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">that heap:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.740.1">
template &lt;typename T&gt; struct DeleteHeap {
  explicit DeleteHeap(MyHeap&amp; heap) : heap_(heap) {}
  void operator()(T* p) const {
    p-&gt;~T();
    heap_.deallocate(p);
  }
  private:
  MyHeap&amp; heap_;
};</span></pre>
<p><span class="koboSpan" id="kobo.741.1">Then we have to create a policy object to use with </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">the pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.743.1">
MyHeap H;
SmartPtr&lt;int, DeleteHeap&lt;int&gt;&gt; p(new int, H);</span></pre>
<p><span class="koboSpan" id="kobo.744.1">This policy is not very flexible, however - it can handle heaps of only one type - </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">MyHeap</span></strong><span class="koboSpan" id="kobo.746.1">. </span><span class="koboSpan" id="kobo.746.2">We can make the policy more general if we make the heap type the second template parameter. </span><span class="koboSpan" id="kobo.746.3">As long as the heap has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">deallocate()</span></strong><span class="koboSpan" id="kobo.748.1"> member function to return memory to it, we can use any heap class with </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">this policy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.750.1">
// Example 20
template &lt;typename T, typename Heap&gt; struct DeleteHeap {
  explicit DeleteHeap(Heap&amp; heap) : heap_(heap) {}
  void operator()(T* p) const {
    p-&gt;~T();
    heap_.deallocate(p);
  }
  private:
  Heap&amp; heap_;
};</span></pre>
<p><span class="koboSpan" id="kobo.751.1">Of course, if we</span><a id="_idIndexMarker952"/><span class="koboSpan" id="kobo.752.1"> have </span><a id="_idIndexMarker953"/><span class="koboSpan" id="kobo.753.1">a heap class that uses another name for this member function, we can use a class adapter to make that class work with our policy, too. </span><span class="koboSpan" id="kobo.753.2">But we have a larger problem - our policy does not work with our smart pointer. </span><span class="koboSpan" id="kobo.753.3">The following code does </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">not compile:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.755.1">
SmartPtr&lt;int, DeletelHeap&gt; p; // Does not compile</span></pre>
<p><span class="koboSpan" id="kobo.756.1">The reason is again the interface mismatch, only now it is a different kind of interface – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">template &lt;typename T, template &lt;typename&gt; class DeletionPolicy&gt; class SmartPtr {};</span></strong><span class="koboSpan" id="kobo.758.1"> template expects the second argument to be a template with one type parameter. </span><span class="koboSpan" id="kobo.758.2">Instead, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">DeleteHeap</span></strong><span class="koboSpan" id="kobo.760.1"> template with two type parameters. </span><span class="koboSpan" id="kobo.760.2">This is just like trying to call a function that has one parameter but uses two arguments - it won’t work. </span><span class="koboSpan" id="kobo.760.3">We need an adapter to convert our two-parameter template into a one-parameter one, and we have to fix the second argument to a particular heap type (but we do not need to rewrite the policy if we have multiple heap types, we just need to write several adapters). </span><span class="koboSpan" id="kobo.760.4">We can create this adapter, </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">DeleteMyHeap</span></strong><span class="koboSpan" id="kobo.762.1">, using inheritance (and remembering to bring the constructors of the base class into the derived adapter </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">class scope):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.764.1">
// Example 20
template &lt;typename T&gt;
struct DeleteMyHeap : public DeleteHeap&lt;T, MyHeap&gt; {
  using DeleteHeap&lt;T, MyHeap&gt;::DeleteHeap;
};</span></pre>
<p><span class="koboSpan" id="kobo.765.1">We could do the same using the </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">template alias:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.767.1">
// Example 21
template &lt;typename T&gt;
using DeleteMyHeap = DeleteHeap&lt;T, MyHeap&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.768.1">This first version is, obviously, much longer. </span><span class="koboSpan" id="kobo.768.2">However, we have to learn both ways of writing</span><a id="_idIndexMarker954"/><span class="koboSpan" id="kobo.769.1"> template</span><a id="_idIndexMarker955"/><span class="koboSpan" id="kobo.770.1"> adapters because the template alias has one major limitation. </span><span class="koboSpan" id="kobo.770.2">To illustrate it, let’s consider another example where an adapter is needed. </span><span class="koboSpan" id="kobo.770.3">We will begin by implementing a stream insertion operator for any STL-compliant sequence container whose elements have such an operator defined. </span><span class="koboSpan" id="kobo.770.4">It is a simple </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">function template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.772.1">
// Example 22
template &lt;template &lt;typename&gt; class Container, typename T&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                         const Container&lt;T&gt;&amp; c) {
  bool first = true;
  for (auto x : c) {
  if (!first) out &lt;&lt; ", ";
    first = false;
    out &lt;&lt; x;
  }
  return out;
}</span></pre>
<p><span class="koboSpan" id="kobo.773.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">template</span></strong><span class="koboSpan" id="kobo.775.1"> function has two type parameters, the container type and the element type. </span><span class="koboSpan" id="kobo.775.2">The container is itself a template with one type parameter. </span><span class="koboSpan" id="kobo.775.3">The compiler deduces both the container type and the element type from the second function argument (the first argument in any </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">operator&lt;&lt;()</span></strong><span class="koboSpan" id="kobo.777.1"> is always the stream). </span><span class="koboSpan" id="kobo.777.2">We can test our insertion operator on a </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">simple container:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.779.1">
// Example 22
template &lt;typename T&gt; class Buffer {
  public:
  explicit Buffer(size_t N) : N_(N), buffer_(new T[N_]) {}
  ~Buffer() { delete [] buffer_; }
  T* begin() const { return buffer_; }
  T* end() const { return buffer_ + N_; }
  ...
</span><span class="koboSpan" id="kobo.779.2">  private:
  const size_t N_;
  T* const buffer_;
};
Buffer&lt;int&gt; buffer(10);
... </span><span class="koboSpan" id="kobo.779.3">fill the buffer ...
</span><span class="koboSpan" id="kobo.779.4">cout &lt;&lt; buffer; // Prints all elements of the buffer</span></pre>
<p><span class="koboSpan" id="kobo.780.1">But this is just </span><a id="_idIndexMarker956"/><span class="koboSpan" id="kobo.781.1">a</span><a id="_idIndexMarker957"/><span class="koboSpan" id="kobo.782.1"> toy container and is not very useful. </span><span class="koboSpan" id="kobo.782.2">What we really want is to print elements of a real container, such </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">std::vector</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.786.1">
std::vector&lt;int&gt; v;
... </span><span class="koboSpan" id="kobo.786.2">add some values to v ...
</span><span class="koboSpan" id="kobo.786.3">cout &lt;&lt; v;</span></pre>
<p><span class="koboSpan" id="kobo.787.1">Unfortunately, this code does not compile. </span><span class="koboSpan" id="kobo.787.2">The reason is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">std::vector</span></strong><span class="koboSpan" id="kobo.789.1"> is not really a template with one type parameter, even though we used it as such. </span><span class="koboSpan" id="kobo.789.2">It has two parameters - the second is the allocator type. </span><span class="koboSpan" id="kobo.789.3">There is a default for this allocator, which is why we can write </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">std::vector&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.791.1"> and it compiles. </span><span class="koboSpan" id="kobo.791.2">But, even with this default argument, this is still a template with two parameters, while our stream insertion operator is declared to accept container templates with only one parameter. </span><span class="koboSpan" id="kobo.791.3">Again, we can solve the problem by writing an adapter (most STL containers are used with the default allocator anyway). </span><span class="koboSpan" id="kobo.791.4">The easiest way to write this adapter is with </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">an alias:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.793.1">
template &lt;typename T&gt; using vector1 = std::vector&lt;T&gt;;
vector1&lt;int&gt; v;
...
</span><span class="koboSpan" id="kobo.793.2">cout &lt;&lt; v; // Does not compile either</span></pre>
<p><span class="koboSpan" id="kobo.794.1">Unfortunately, this does not compile either, and now we can show the template alias limitation that we alluded to earlier - template aliases are not used in template argument type deduction. </span><span class="koboSpan" id="kobo.794.2">When the compiler attempts to figure out the template argument types for the call of </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">operator&lt;&lt;()</span></strong><span class="koboSpan" id="kobo.796.1"> with the arguments </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">cout</span></strong><span class="koboSpan" id="kobo.798.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">v</span></strong><span class="koboSpan" id="kobo.800.1">, the template </span><a id="_idIndexMarker958"/><span class="koboSpan" id="kobo.801.1">alias </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">vector1</span></strong><span class="koboSpan" id="kobo.803.1"> is </span><em class="italic"><span class="koboSpan" id="kobo.804.1">invisible</span></em><span class="koboSpan" id="kobo.805.1">. </span><span class="koboSpan" id="kobo.805.2">In this case, we </span><a id="_idIndexMarker959"/><span class="koboSpan" id="kobo.806.1">have to use a derived </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">class adapter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.808.1">
// Example 22
template &lt;typename T&gt;
struct vector1 : public std::vector&lt;T&gt; {
  using std::vector&lt;T&gt;::vector;
};
vector1&lt;int&gt; v;
...
</span><span class="koboSpan" id="kobo.808.2">cout &lt;&lt; v;</span></pre>
<p><span class="koboSpan" id="kobo.809.1">By the way, if you paid attention to the previous chapter, you may realize that we already encountered the problem of extra parameters to the template template parameters, and solved it by declaring these parameters as </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">variadic templates:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.811.1">
// Example 23
template &lt;typename T,
  template &lt;typename, typename...&gt; class Container,
  typename... </span><span class="koboSpan" id="kobo.811.2">Args&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                         const Container&lt;T, Args...&gt;&amp; c) {
  ...
</span><span class="koboSpan" id="kobo.811.3">}</span></pre>
<p><span class="koboSpan" id="kobo.812.1">Now our </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">operator&lt;&lt;()</span></strong><span class="koboSpan" id="kobo.814.1"> can print any container, so we no longer need to worry about adapters, right? </span><span class="koboSpan" id="kobo.814.2">Not quite: one of the containers we still cannot print is </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">std::array</span></strong><span class="koboSpan" id="kobo.816.1"> which is a class template with one type and one non-type parameter. </span><span class="koboSpan" id="kobo.816.2">We could declare an overload just to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">this case:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.818.1">
// Example 23
template &lt;typename T,
  template &lt;typename, size_t&gt; class Container, size_t N&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                         const Container&lt;T, N&gt;&amp; c) {
  ...
</span><span class="koboSpan" id="kobo.818.2">}</span></pre>
<p><span class="koboSpan" id="kobo.819.1">But we may</span><a id="_idIndexMarker960"/><span class="koboSpan" id="kobo.820.1"> have</span><a id="_idIndexMarker961"/><span class="koboSpan" id="kobo.821.1"> yet another kind of container that does not fit either of these templates (whether because it has to or simply because it is part of legacy code that was written differently). </span><span class="koboSpan" id="kobo.821.2">Then, we have to use an </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">adapter again.</span></span></p>
<p><span class="koboSpan" id="kobo.823.1">We have now seen how we can implement decorators to augment class and function interfaces with the desired behavior, and how to create adapters when the existing interface is not suitable for a particular application. </span><span class="koboSpan" id="kobo.823.2">Decorator, and, even more so, Adapter, are very general and versatile patterns that can be used to solve many problems. </span><span class="koboSpan" id="kobo.823.3">It should come as no surprise that, often, a problem can be solved in more than one way, so there is a</span><a id="_idTextAnchor771"/> <a id="_idTextAnchor772"/><span class="koboSpan" id="kobo.824.1">choice of patterns to use. </span><span class="koboSpan" id="kobo.824.2">In the next section, we will see one </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">such case.</span></span></p>
<h1 id="_idParaDest-296"><a id="_idTextAnchor773"/><span class="koboSpan" id="kobo.826.1">Adapter versus policy</span></h1>
<p><span class="koboSpan" id="kobo.827.1">The adapter and</span><a id="_idIndexMarker962"/><span class="koboSpan" id="kobo.828.1"> the policy (or strategy) patterns are</span><a id="_idIndexMarker963"/><span class="koboSpan" id="kobo.829.1"> some of the more general patterns, and C++ adds generic programming capabilities to these patterns. </span><span class="koboSpan" id="kobo.829.2">This tends to extend their usability and sometimes blurs the lines between the patterns. </span><span class="koboSpan" id="kobo.829.3">The patterns themselves are defined very distinctly - policies provide custom implementations while adapters change the interface and add functionality to the existing interface (the latter is a decorator aspect, but, as we have seen, most decorators are implemented as adapters). </span><span class="koboSpan" id="kobo.829.4">We also saw in the last chapter that C++ broadens the capabilities of policy-based design; in particular, policies in C++ can add or remove parts of the interface as well as control the implementation. </span><span class="koboSpan" id="kobo.829.5">So, while patterns are different, there is significant overlap in the types of problems they can be used for. </span><span class="koboSpan" id="kobo.829.6">It is instructive to compare the two approaches when a problem is, broadly speaking, amenable to both. </span><span class="koboSpan" id="kobo.829.7">For this exercise, we will consider the problem of designing a custom </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">value type.</span></span></p>
<p><span class="koboSpan" id="kobo.831.1">A value type, to put it simply, is a type that behaves mostly like an </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">int</span></strong><span class="koboSpan" id="kobo.833.1">. </span><span class="koboSpan" id="kobo.833.2">Often, these types are numbers. </span><span class="koboSpan" id="kobo.833.3">While we have a set of built-in types for that, we may want to operate on rational numbers, complex numbers, tensors, matrices, or numbers that have units associated with them (meters, grams, and so on). </span><span class="koboSpan" id="kobo.833.4">These value types support a set of operations such as arithmetic operations, comparisons, assignments, and copying. </span><span class="koboSpan" id="kobo.833.5">Depending on what the value represents, we may need only a limited subset of these operations - for example, we may need to support addition and multiplication for matrices, but no division, and comparing matrices for anything other than equality probably doesn’t make sense in most cases. </span><span class="koboSpan" id="kobo.833.6">Similarly, we probably don’t want to allow the addition of meters </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">to grams.</span></span></p>
<p><span class="koboSpan" id="kobo.835.1">More generally, there is often a desire to have a numeric type with a limited interface - we would like it if the operations that we do not wish to allow for the quantity represented by such numbers did not compile. </span><span class="koboSpan" id="kobo.835.2">This way, a program with an invalid operation simply cannot be written. </span><span class="koboSpan" id="kobo.835.3">To be general, our design has to allow us to build the interface piece by piece. </span><span class="koboSpan" id="kobo.835.4">For example, we may want a value that is comparable for equality, ordered (has the less-than operation defined), and addable, but without multiplication or division. </span><span class="koboSpan" id="kobo.835.5">This seems like a problem that is tailor-made for the Decorator (or, more generally, Adapter) pattern: decorators can add behaviors like comparison operator or addition operator. </span><span class="koboSpan" id="kobo.835.6">On the other hand, creating a type with a set of capabilities</span><a id="_idIndexMarker964"/><span class="koboSpan" id="kobo.836.1"> configured</span><a id="_idIndexMarker965"/><span class="koboSpan" id="kobo.837.1"> by plugging in the right policies is exactly what the Policy pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">is for.</span></span></p>
<h2 id="_idParaDest-297"><a id="_idTextAnchor774"/><span class="koboSpan" id="kobo.839.1">Adapter solution</span></h2>
<p><span class="koboSpan" id="kobo.840.1">Let us examine the</span><a id="_idIndexMarker966"/><span class="koboSpan" id="kobo.841.1"> Adapter solution first. </span><span class="koboSpan" id="kobo.841.2">We will start with a basic value type that supports almost nothing in its interface, and then we can add the desired capabilities, one </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">by one.</span></span></p>
<p><span class="koboSpan" id="kobo.843.1">Here is our initial </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">Value</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.845.1">class template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.846.1">
// Example 24
template &lt;typename T&gt; class Value {
  public:
  using basic_type = T;
  using value_type = Value;
  explicit Value() : val_(T()) {}
  explicit Value(T v) : val_(v) {}
  Value(const Value&amp;) = default;
  Value&amp; operator=(const Value&amp;) = default;
  Value&amp; operator=(basic_type rhs) {
    val_ = rhs;
    return *this;
  }
  protected:
  T val_ {};
};</span></pre>
<p><span class="koboSpan" id="kobo.847.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">Value</span></strong><span class="koboSpan" id="kobo.849.1"> is copyable and assignable, both from the underlying type such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">int</span></strong><span class="koboSpan" id="kobo.851.1"> and from another </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">Value</span></strong><span class="koboSpan" id="kobo.853.1">. </span><span class="koboSpan" id="kobo.853.2">We could have moved some of those capabilities into adapters as well if we wanted to have non-copyable values, but you will find this an easy change after making your way through the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">the chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.855.1">For convenience, we will also make our Value printable (in any real situation you would likely want this to be a separate and configurable capability, but it makes the examples simpler without taking anything </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">important away).</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.857.1">
// Example 24
template &lt;typename T&gt; class Value {
  public:
  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                                  Value x) {
    out &lt;&lt; x.val_;
    return out;
  }
  friend std::istream&amp; operator&gt;&gt;(std::istream&amp; in,
                                  Value&amp; x) {
    in &gt;&gt; x.val_;
    return in;
  }
  ...
</span><span class="koboSpan" id="kobo.857.2">};</span></pre>
<p><span class="koboSpan" id="kobo.858.1">We use the </span><em class="italic"><span class="koboSpan" id="kobo.859.1">friend factory</span></em><span class="koboSpan" id="kobo.860.1">, which </span><a id="_idIndexMarker967"/><span class="koboSpan" id="kobo.861.1">was described in </span><a href="B19262_12.xhtml#_idTextAnchor562"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.862.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.863.1">, </span><em class="italic"><span class="koboSpan" id="kobo.864.1">Friend Factory</span></em><span class="koboSpan" id="kobo.865.1">, to generate these functions. </span><span class="koboSpan" id="kobo.865.2">So far, all we can do with our Value is to initialize it, maybe assign it to another value, and </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">print it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.867.1">
// Example 24
using V = Value&lt;int&gt;;
V i, j(5), k(3);
i = j;
std::cout &lt;&lt; i;     // Prints 5</span></pre>
<p><span class="koboSpan" id="kobo.868.1">There is nothing else we can do with this class - no comparisons for equality or inequality, no arithmetic operations. </span><span class="koboSpan" id="kobo.868.2">However, we can create an adapter that adds the </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">comparison interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.870.1">
// Example 24
template &lt;typename V&gt; class Comparable : public V {
  public:
  using V::V;
  using V::operator=;
  using value_type = typename V::value_type;
  using basic_type = typename value_type::basic_type;
  Comparable(value_type v) : V(v) {}
  friend bool operator==(Comparable lhs, Comparable rhs) {
    return lhs.val_ == rhs.val_;
  }
  friend bool operator==(Comparable lhs, basic_type rhs) {
    return lhs.val_ == rhs;
  }
  friend bool operator==(basic_type lhs, Comparable rhs) {
    return lhs == rhs.val_;
  }
  ... </span><span class="koboSpan" id="kobo.870.2">same for the operator!= ...
</span><span class="koboSpan" id="kobo.870.3">};</span></pre>
<p><span class="koboSpan" id="kobo.871.1">This is a class </span><a id="_idIndexMarker968"/><span class="koboSpan" id="kobo.872.1">adapter - it is derived from the class it is augmenting with new capabilities, so it inherits all of its interface and adds some more - the complete set of comparison operators. </span><span class="koboSpan" id="kobo.872.2">Note that it is common to use pass-by-value instead of reference when dealing with value types (passing by reference to </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">const</span></strong><span class="koboSpan" id="kobo.874.1"> isn’t wrong either, and some compilers may optimize either version to the same </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">end result).</span></span></p>
<p><span class="koboSpan" id="kobo.876.1">We are familiar with the way these adapters </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">are used:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.878.1">
using V = Comparable&lt;Value&lt;int&gt;&gt;;
V i(3), j(5);
i == j; // False
i == 3; // True
5 == j; // Also true</span></pre>
<p><span class="koboSpan" id="kobo.879.1">That is one capability. </span><span class="koboSpan" id="kobo.879.2">What about some more? </span><span class="koboSpan" id="kobo.879.3">No problem - the </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">Ordered</span></strong><span class="koboSpan" id="kobo.881.1"> adapter can be written very </span><a id="_idIndexMarker969"/><span class="koboSpan" id="kobo.882.1">similarly, only it provides the operators </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">&lt;</span></strong><span class="koboSpan" id="kobo.884.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">&lt;=</span></strong><span class="koboSpan" id="kobo.886.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">&gt;</span></strong><span class="koboSpan" id="kobo.888.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">&gt;=</span></strong><span class="koboSpan" id="kobo.890.1"> (or, in C++20, </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">operator </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">&lt;=&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.894.1">
// Example 24
template &lt;typename V&gt; class Ordered : public V {
  public:
  using V::V;
  using V::operator=;
  using value_type = typename V::value_type;
  using basic_type = typename value_type::basic_type;
  Ordered(value_type v) : V(v) {}
  friend bool operator&lt;(Ordered lhs, Ordered rhs) {
    return lhs.val_ &lt; rhs.val_;
  }
  friend bool operator&lt;(basic_type lhs, Ordered rhs) {
    return lhs &lt; rhs.val_;
  }
  friend bool operator&lt;(Ordered lhs, basic_type rhs) {
    return lhs.val_ &lt; rhs;
  }
  ... </span><span class="koboSpan" id="kobo.894.2">same for the other operators ...
</span><span class="koboSpan" id="kobo.894.3">};</span></pre>
<p><span class="koboSpan" id="kobo.895.1">We can combine the two adapters - as we say, they are composable, and they work in </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">any order:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.897.1">
using V = Ordered&lt;Comparable&lt;Value&lt;int&gt;&gt;&gt;;
// Or Comparable&lt;Ordered&lt;...&gt;
V i(3), j(5);
i == j; // False
i &lt;= 3; // True</span></pre>
<p><span class="koboSpan" id="kobo.898.1">Some operations, or capabilities, require more work. </span><span class="koboSpan" id="kobo.898.2">If our value type is numeric, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">Value&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.900.1">, we will want some arithmetic operations like addition and multiplication. </span><span class="koboSpan" id="kobo.900.2">Here is a </span><a id="_idIndexMarker970"/><span class="koboSpan" id="kobo.901.1">decorator that enables addition </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">and subtraction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.903.1">
// Example 24
template &lt;typename V&gt; class Addable : public V {
  public:
  using V::V;
  using V::operator=;
  using value_type = typename V::value_type;
  using basic_type = typename value_type::basic_type;
  Addable(value_type v) : V(v) {}
  friend Addable operator+(Addable lhs, Addable rhs) {
    return Addable(lhs.val_ + rhs.val_);
  }
  friend Addable operator+(Addable lhs, basic_type rhs) {
    return Addable(lhs.val_ + rhs);
  }
  friend Addable operator+(basic_type lhs, Addable rhs) {
    return Addable(lhs + rhs.val_);
  }
  ... </span><span class="koboSpan" id="kobo.903.2">same for the operator- ...
</span><span class="koboSpan" id="kobo.903.3">};</span></pre>
<p><span class="koboSpan" id="kobo.904.1">The decorator is trivial </span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">to use:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.906.1">
using V = Addable&lt;Value&lt;int&gt;&gt;;
V i(5), j(3), k(7);
k = i + j; // 8</span></pre>
<p><span class="koboSpan" id="kobo.907.1">We can also combine </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">Addable</span></strong><span class="koboSpan" id="kobo.909.1"> with </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">other decorators:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.911.1">
using V = Addable&lt;Ordered&lt;Value&lt;int&gt;&gt;&gt;;
V i(5), j(3), k(7);
if (k - 1 &lt; i + j) { ... </span><span class="koboSpan" id="kobo.911.2">yes it is ... </span><span class="koboSpan" id="kobo.911.3">}</span></pre>
<p><span class="koboSpan" id="kobo.912.1">But we have a problem that so far has been hidden only by good luck. </span><span class="koboSpan" id="kobo.912.2">We could have just as </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">easily written:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.914.1">
using V = Ordered&lt;Addable&lt;Value&lt;int&gt;&gt;&gt;;
V i(5), j(3), k(7);
if (k - 1 &lt; i + j) { ... </span><span class="koboSpan" id="kobo.914.2">}</span></pre>
<p><span class="koboSpan" id="kobo.915.1">There should be no</span><a id="_idIndexMarker971"/><span class="koboSpan" id="kobo.916.1"> difference whatsoever between this example and the previous one. </span><span class="koboSpan" id="kobo.916.2">Instead, we get a compilation error: there is no valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">operator&lt;</span></strong><span class="koboSpan" id="kobo.918.1"> to be used in the last line. </span><span class="koboSpan" id="kobo.918.2">The problem here is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">i + j</span></strong><span class="koboSpan" id="kobo.920.1"> expression uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">operator+()</span></strong><span class="koboSpan" id="kobo.922.1"> that comes from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">Addable</span></strong><span class="koboSpan" id="kobo.924.1"> adapter, and this operator returns an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">Addable&lt;Value&lt;int&gt;&gt;</span></strong><span class="koboSpan" id="kobo.926.1">. </span><span class="koboSpan" id="kobo.926.2">The comparison operator expects the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">Ordered&lt;Addable&lt;Value&lt;int&gt;&gt;&gt;</span></strong><span class="koboSpan" id="kobo.928.1">, and will not accept the “partial” type (there is no implicit conversion from a base class to the derived one). </span><span class="koboSpan" id="kobo.928.2">The unsatisfactory solution is to require that </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">Addable</span></strong><span class="koboSpan" id="kobo.930.1"> is always the top decorator. </span><span class="koboSpan" id="kobo.930.2">Not only it just feels wrong, but it also doesn’t get us very far: the next decorator we will want is </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">Multipliable</span></strong><span class="koboSpan" id="kobo.932.1"> and it is going to have the same problem. </span><span class="koboSpan" id="kobo.932.2">When something is both </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">Addable</span></strong><span class="koboSpan" id="kobo.934.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">Multipliable</span></strong><span class="koboSpan" id="kobo.936.1"> we can’t have both be </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">on top.</span></span></p>
<p><span class="koboSpan" id="kobo.938.1">Note that we had no problems with comparison operators returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">bool</span></strong><span class="koboSpan" id="kobo.940.1">, but once we have to return the decorated type itself, which is what </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">operator+()</span></strong><span class="koboSpan" id="kobo.942.1"> does, the composability breaks down. </span><span class="koboSpan" id="kobo.942.2">To solve this problem, every operator that returns the decorated type has to return the original (outermost) type. </span><span class="koboSpan" id="kobo.942.3">For example, if our value type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">Ordered&lt;Addable&lt;Value&lt;int&gt;&gt;&gt;</span></strong><span class="koboSpan" id="kobo.944.1">, the result of adding two values should have the same type. </span><span class="koboSpan" id="kobo.944.2">The problem, of course, is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">operator+()</span></strong><span class="koboSpan" id="kobo.946.1"> is provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">Addable</span></strong><span class="koboSpan" id="kobo.948.1"> decorator which knows only about </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">Addable</span></strong><span class="koboSpan" id="kobo.950.1"> and its base classes. </span><span class="koboSpan" id="kobo.950.2">We need an intermediate class in the hierarchy (</span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">Addable&lt;...&gt;</span></strong><span class="koboSpan" id="kobo.952.1">) to return objects of its derived type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">Ordered&lt;Addable&lt;...&gt;&gt;</span></strong><span class="koboSpan" id="kobo.954.1">). </span><span class="koboSpan" id="kobo.954.2">This is a very common design problem, and there is a pattern for it: the Curiously Recurring Template Pattern, or CRTP (see the eponymous </span><a href="B19262_08.xhtml#_idTextAnchor360"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.955.1">Chapter 8</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.956.1">, The Curiously Recurring Template Pattern</span></em><span class="koboSpan" id="kobo.957.1">). </span><span class="koboSpan" id="kobo.957.2">Applying this pattern to our decorators takes some recursive thinking. </span><span class="koboSpan" id="kobo.957.3">We will introduce the two main ideas, then we just have to wade through a fairly large </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">coding example.</span></span></p>
<p><span class="koboSpan" id="kobo.959.1">First of all, every decorator is going to have two template parameters. </span><span class="koboSpan" id="kobo.959.2">The first one is the same as before: it is the next decorator in the chain, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">Value&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.961.1"> at the end of the chain (of course, the pattern is not limited to </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">int</span></strong><span class="koboSpan" id="kobo.963.1">, but we’re simplifying our examples by staying with the same base type throughout). </span><span class="koboSpan" id="kobo.963.2">The second parameter is going to be the outermost type; we will call it the “final value type.” </span><span class="koboSpan" id="kobo.963.3">Thus, all of our decorators are going to be declared </span><span class="No-Break"><span class="koboSpan" id="kobo.964.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.965.1">
template &lt;typename V, typename FV&gt; class Ordered : ...</span></pre>
<p><span class="koboSpan" id="kobo.966.1">But in our code, we still want </span><span class="No-Break"><span class="koboSpan" id="kobo.967.1">to write</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.968.1">
using V = Ordered&lt;Addable&lt;Value&lt;int&gt;&gt;&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.969.1">This means we need a</span><a id="_idIndexMarker972"/><span class="koboSpan" id="kobo.970.1"> default value for the second template parameter. </span><span class="koboSpan" id="kobo.970.2">This value can be any type that we’re not going to use elsewhere in our decorators; </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">void</span></strong><span class="koboSpan" id="kobo.972.1"> will do nicely. </span><span class="koboSpan" id="kobo.972.2">We will also need a partial template specialization for this default type since, if the final value type is not specified explicitly, we have to somehow figure out what </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">it is:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.974.1">
template &lt;typename V, typename FV = void&gt; class Ordered;
template &lt;typename V&gt; class Ordered&lt;V, void&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.975.1">Now we’re going to walk through our “nested” type </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">Ordered&lt;Addable&lt;Value&lt; int&gt;&gt;&gt;</span></strong><span class="koboSpan" id="kobo.977.1"> step by step. </span><span class="koboSpan" id="kobo.977.2">At the outer layer, we can think of it as </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">Ordered&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.979.1"> where </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">T</span></strong><span class="koboSpan" id="kobo.981.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">Addable&lt;Value&lt;int&gt;&gt;</span></strong><span class="koboSpan" id="kobo.983.1">. </span><span class="koboSpan" id="kobo.983.2">Since we did not specify the second type parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">FV</span></strong><span class="koboSpan" id="kobo.985.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">Ordered</span></strong><span class="koboSpan" id="kobo.987.1"> template, we are going to get the default value </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">void</span></strong><span class="koboSpan" id="kobo.989.1"> and the template instantiation </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">Ordered&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.991.1"> is going to use the partial specialization of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">Ordered</span></strong><span class="koboSpan" id="kobo.993.1"> template. </span><span class="koboSpan" id="kobo.993.2">Even thought we don’t have the “final value type” </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">FV</span></strong><span class="koboSpan" id="kobo.995.1"> specified, we know what that is: it’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">Ordered&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.997.1"> itself.</span></span></p>
<p><span class="koboSpan" id="kobo.998.1">Now we need to figure out the base class to inherit from. </span><span class="koboSpan" id="kobo.998.2">Since every decorator inherits from the type it decorates, it should be </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">T</span></strong><span class="koboSpan" id="kobo.1000.1"> which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">Addable&lt;U&gt;</span></strong><span class="koboSpan" id="kobo.1002.1"> (where </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">U</span></strong><span class="koboSpan" id="kobo.1004.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">Value&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.1006.1">). </span><span class="koboSpan" id="kobo.1006.2">But that’s not going to work: we need to pass the correct final value type into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">Addable</span></strong><span class="koboSpan" id="kobo.1008.1">. </span><span class="koboSpan" id="kobo.1008.2">So we should inherit from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">Addable&lt;U, FV&gt;</span></strong><span class="koboSpan" id="kobo.1010.1"> where </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">FV</span></strong><span class="koboSpan" id="kobo.1012.1"> is the final value type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">Ordered&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1014.1">. </span><span class="koboSpan" id="kobo.1014.2">Unfortunately, we do not have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">Addable&lt;U, FV&gt;</span></strong><span class="koboSpan" id="kobo.1016.1"> written in the code: we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">Addable&lt;U&gt;</span></strong><span class="koboSpan" id="kobo.1018.1">. </span><span class="koboSpan" id="kobo.1018.2">What we need is to somehow figure out the type that would have been generated by the same template </span><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">Addable</span></strong><span class="koboSpan" id="kobo.1020.1"> but with a different second type argument (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">Ordered&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1022.1"> instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">default </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">void</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1026.1">This is a very common problem in C++ templates, and it has an equally common solution: template rebinding. </span><span class="koboSpan" id="kobo.1026.2">Every one of our decorator templates needs to define the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">template alias:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1028.1">
template &lt;typename V, typename FV = void&gt;
class Ordered : public ... </span><span class="koboSpan" id="kobo.1028.2">some base class ... </span><span class="koboSpan" id="kobo.1028.3">{
  public:
  template &lt;typename FV1&gt; using rebind = Ordered&lt;V, FV1&gt;;
};</span></pre>
<p><span class="koboSpan" id="kobo.1029.1">Now, given the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">T</span></strong><span class="koboSpan" id="kobo.1031.1">, which is an instantiation of one of the decorator templates, we can find out the type </span><a id="_idIndexMarker973"/><span class="koboSpan" id="kobo.1032.1">that would have been produced by the same template but with a different second template argument </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">FV</span></strong><span class="koboSpan" id="kobo.1034.1">: it’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">T::template rebind&lt;FV&gt;</span></strong><span class="koboSpan" id="kobo.1036.1">. </span><span class="koboSpan" id="kobo.1036.2">That is what our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1037.1">Ordered&lt;V&gt;</span></strong><span class="koboSpan" id="kobo.1038.1"> needs to inherit from to pass the correct final value type to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">next decorator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1040.1">
// Example 25
template &lt;typename V, typename FV = void&gt;
class Ordered : public V::template rebind&lt;FV&gt; { ... </span><span class="koboSpan" id="kobo.1040.2">};</span></pre>
<p><span class="koboSpan" id="kobo.1041.1">This class template says that given a type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">Ordered&lt;T, FV&gt;</span></strong><span class="koboSpan" id="kobo.1043.1"> we are going to inherit from the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">T</span></strong><span class="koboSpan" id="kobo.1045.1"> rebound to the same final value type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">FV</span></strong><span class="koboSpan" id="kobo.1047.1"> and ignore the second template argument of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">T</span></strong><span class="koboSpan" id="kobo.1049.1">. </span><span class="koboSpan" id="kobo.1049.2">The exception from this is the outermost type, where the template parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">FV</span></strong><span class="koboSpan" id="kobo.1051.1"> is void but we know what the final value type should be, so we can rebind to </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">that type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1053.1">
// Example 25
template &lt;typename V&gt; class Ordered&lt;V, void&gt; :
  public V::template rebind&lt;Ordered&lt;V&gt;&gt; { ... </span><span class="koboSpan" id="kobo.1053.2">};</span></pre>
<p><span class="koboSpan" id="kobo.1054.1">Note the syntax, with the keyword </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">template</span></strong><span class="koboSpan" id="kobo.1056.1">: some compilers will accept </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">V:: rebind&lt;Ordered&lt;V&gt;&gt;</span></strong><span class="koboSpan" id="kobo.1058.1"> but this is wrong, the standard requires this </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">exact syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.1060.1">Now we can put everything together. </span><span class="koboSpan" id="kobo.1060.2">In the general case where our decorator is somewhere in the </span><a id="_idIndexMarker974"/><span class="koboSpan" id="kobo.1061.1">middle of the decorator chain, we must pass the final value type to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1062.1">base class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1063.1">
// Example 25
template &lt;typename V, typename FV = void&gt;
class Ordered : public V::template rebind&lt;FV&gt; {
  using base_t = typename V::template rebind&lt;FV&gt;;
  public:
  using base_t::base_t;
  using base_t::operator=;
  template &lt;typename FV1&gt; using rebind = Ordered&lt;V, FV1&gt;;
  using value_type = typename base_t::value_type;
  using basic_type = typename value_type::basic_type;
  explicit Ordered(value_type v) : base_t(v) {}
  friend bool operator&lt;(FV lhs, FV rhs) {
    return lhs.val_ &lt; rhs.val_;
  }
  ... </span><span class="koboSpan" id="kobo.1063.2">the rest of the operators ...
</span><span class="koboSpan" id="kobo.1063.3">};</span></pre>
<p><span class="koboSpan" id="kobo.1064.1">The type alias </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">base_t</span></strong><span class="koboSpan" id="kobo.1066.1"> is introduced for convenience, it makes writing using statements easier. </span><span class="koboSpan" id="kobo.1066.2">Note that we need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">typename</span></strong><span class="koboSpan" id="kobo.1068.1"> keyword before any type that depends on the template parameters; we did not need this keyword to specify the base class because the base class is always a type, so writing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">typename</span></strong><span class="koboSpan" id="kobo.1070.1"> would </span><span class="No-Break"><span class="koboSpan" id="kobo.1071.1">be redundant.</span></span></p>
<p><span class="koboSpan" id="kobo.1072.1">The special case of the outermost type where the final value type is not specified and defaults to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">void</span></strong><span class="koboSpan" id="kobo.1074.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.1075.1">very similar:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1076.1">
// Example 25
template &lt;typename V&gt; class Ordered&lt;V, void&gt;
  : public V::template rebind&lt;Ordered&lt;V&gt;&gt; {
  using base_t = typename V::template rebind&lt;Ordered&gt;;
  public:
  using base_t::base_t;
  using base_t::operator=;
  template &lt;typename FV1&gt; using rebind = Ordered&lt;V, FV1&gt;;
  using value_type = typename base_t::value_type;
  using basic_type = typename value_type::basic_type;
  explicit Ordered(value_type v) : base_t(v) {}
  friend bool operator&lt;(Ordered lhs, Ordered rhs) {
    return lhs.val_ &lt; rhs.val_;
  }
  ... </span><span class="koboSpan" id="kobo.1076.2">the rest of the operators ...
</span><span class="koboSpan" id="kobo.1076.3">};</span></pre>
<p><span class="koboSpan" id="kobo.1077.1">The specialization differs</span><a id="_idIndexMarker975"/><span class="koboSpan" id="kobo.1078.1"> from the general case in two ways. </span><span class="koboSpan" id="kobo.1078.2">In addition to the base class, the parameters of the operators cannot be of the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">FV</span></strong><span class="koboSpan" id="kobo.1080.1"> since it is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1081.1">void</span></strong><span class="koboSpan" id="kobo.1082.1">. </span><span class="koboSpan" id="kobo.1082.2">Instead, we must use the type of the class generated by the template, which inside the template definition can be referred to simply as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">Ordered</span></strong><span class="koboSpan" id="kobo.1084.1"> (the name of the template, when used inside the class, refers to the specific instantiation – you do not need to repeat the </span><span class="No-Break"><span class="koboSpan" id="kobo.1085.1">template arguments).</span></span></p>
<p><span class="koboSpan" id="kobo.1086.1">For decorators whose operators return a value, we need to make sure to always use the correct final value type for the return type. </span><span class="koboSpan" id="kobo.1086.2">In the general case, this is the second template </span><span class="No-Break"><span class="koboSpan" id="kobo.1087.1">parameter </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">FV</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1089.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1090.1">
// Example 25
template &lt;typename V, typename FV = void&gt; class Addable :
  public V::template rebind&lt;FV&gt; {
  friend FV operator+(FV lhs, FV rhs) {
    return FV(lhs.val_ + rhs.val_);
  }
  ...
</span><span class="koboSpan" id="kobo.1090.2">};</span></pre>
<p><span class="koboSpan" id="kobo.1091.1">In the specialization for the outermost decorator, the final value type is the </span><span class="No-Break"><span class="koboSpan" id="kobo.1092.1">decorator itself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1093.1">
// Example 25
template &lt;typename V&gt; class Addable&lt;V, void&gt; :
  public V::template rebind&lt;FV&gt; {
  friend Addable operator+(Addable lhs,Addable rhs) {
    return Addable(lhs.val_ + rhs.val_);
  }
  ...
</span><span class="koboSpan" id="kobo.1093.2">};</span></pre>
<p><span class="koboSpan" id="kobo.1094.1">We must apply this technique to every decorator template. </span><span class="koboSpan" id="kobo.1094.2">Now we can compose the decorators in any order</span><a id="_idIndexMarker976"/><span class="koboSpan" id="kobo.1095.1"> and define value types with any subset of </span><span class="No-Break"><span class="koboSpan" id="kobo.1096.1">available operations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1097.1">
// Example 25
using V = Comparable&lt;Ordered&lt;Addable&lt;Value&lt;int&gt;&gt;&gt;&gt;;
// Addable&lt;Ordered&lt;Comparable&lt;Value&lt;int&gt;&gt;&gt;&gt; also OK
V i, j(5), k(3);
i = j; j = 1;
i == j;         // OK – Comparable
i &gt; j;        // OK – Ordered
i + j == 7 – k;    // OK – Comparable and Addable
i*j;             // Not Multipliable – does not compile</span></pre>
<p><span class="koboSpan" id="kobo.1098.1">So far, all of our decorators added member or non-member operators to the class. </span><span class="koboSpan" id="kobo.1098.2">We can also add member functions and even constructors. </span><span class="koboSpan" id="kobo.1098.3">The latter is useful if we want to add a conversion. </span><span class="koboSpan" id="kobo.1098.4">For example, we can add an implicit conversion from the underlying type (as written, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">Value&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1100.1"> is not implicitly constructible from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">T</span></strong><span class="koboSpan" id="kobo.1102.1">). </span><span class="koboSpan" id="kobo.1102.2">The conversion decorator follows the same pattern as all the other decorators but adds an implicit </span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1">converting constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1104.1">
// Example 25
template &lt;typename V, typename FV = void&gt;
class ImplicitFrom : public V::template rebind&lt;FV&gt; {
  ...
</span><span class="koboSpan" id="kobo.1104.2">  explicit ImplicitFrom(value_type v) : base_t(v) {}
  ImplicitFrom(basic_type rhs) : base_t(rhs) {}
};
template &lt;typename V&gt; class ImplicitFrom&lt;V, void&gt; :
  public V::template rebind&lt;ImplicitFrom&lt;V&gt;&gt; {
  ...
</span><span class="koboSpan" id="kobo.1104.3">  explicit ImplicitFrom(value_type v) : base_t(v) {}
  ImplicitFrom(basic_type rhs) : base_t(rhs) {}
};</span></pre>
<p><span class="koboSpan" id="kobo.1105.1">Now we can use implicit </span><a id="_idIndexMarker977"/><span class="koboSpan" id="kobo.1106.1">conversions to our value type, for example, when </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">calling functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1108.1">
using V = ImplicitFrom&lt;Ordered&lt;Addable&lt;Value&lt;int&gt;&gt;&gt;&gt;;
void f(V v);
f(3);</span></pre>
<p><span class="koboSpan" id="kobo.1109.1">If you want an implicit conversion to the underlying type, you can use a very similar adapter but instead of the constructor, it adds the </span><span class="No-Break"><span class="koboSpan" id="kobo.1110.1">conversion operator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1111.1">
// Example 25
template &lt;typename V, typename FV = void&gt;
class ImplicitTo : public V::template rebind&lt;FV&gt; {
  ...
</span><span class="koboSpan" id="kobo.1111.2">  explicit ImplicitTo(value_type v) : base_t(v) {}
  operator basic_type(){ return this-&gt;val_; }
  operator const basic_type() const { return this-&gt;val_; }
};
template &lt;typename V&gt; class ImplicitTo&lt;V, void&gt; :
  public V::template rebind&lt;ImplicitTo&lt;V&gt;&gt; {
  ...
</span><span class="koboSpan" id="kobo.1111.3">  explicit ImplicitTo(value_type v) : base_t(v) {}
  operator basic_type(){ return this-&gt;val_; }
  operator const basic_type() const { return this-&gt;val_; }
};</span></pre>
<p><span class="koboSpan" id="kobo.1112.1">This allows us to do the conversion in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">opposite direction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1114.1">
using V = ImplicitTo&lt;Ordered&lt;Addable&lt;Value&lt;int&gt;&gt;&gt;&gt;;
void f(int i);
V i(3);
f(i);</span></pre>
<p><span class="koboSpan" id="kobo.1115.1">This design gets the job done, there aren’t any particular problems with it, other than the complexity of writing the adapters themselves: the recursive application of CRTP tends to send your</span><a id="_idIndexMarker978"/><span class="koboSpan" id="kobo.1116.1"> brain into infinite recursion until you get used to thinking about this kind of template adapters. </span><span class="koboSpan" id="kobo.1116.2">The other alternative is a policy-based </span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">value type.</span></span></p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor775"/><span class="koboSpan" id="kobo.1118.1">Policy solution</span></h2>
<p><span class="koboSpan" id="kobo.1119.1">We are now going to look </span><a id="_idIndexMarker979"/><span class="koboSpan" id="kobo.1120.1">at a somewhat different form of the policy-based design compared to what we saw in </span><a href="B19262_15.xhtml#_idTextAnchor689"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1121.1">Chapter 15</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.1122.1">, Policy-Based Design</span></em><span class="koboSpan" id="kobo.1123.1">. </span><span class="koboSpan" id="kobo.1123.2">It is not as general, but when it works, it can provide all the advantages of the policies, in particular, the composability, without some of the problems. </span><span class="koboSpan" id="kobo.1123.3">The problem remains the same: create a custom value type with a set of operations we can control. </span><span class="koboSpan" id="kobo.1123.4">This problem can be tackled with the standard </span><span class="No-Break"><span class="koboSpan" id="kobo.1124.1">policy-based approach:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1125.1">
template &lt;typename T, typename AdditionPolicy,
                      typename ComparisonPolicy,
                      typename OrderPolicy,
                      typename AssignmentPolicy, ... </span><span class="koboSpan" id="kobo.1125.2">&gt;
class Value { ... </span><span class="koboSpan" id="kobo.1125.3">};</span></pre>
<p><span class="koboSpan" id="kobo.1126.1">This implementation runs into the entire set of drawbacks of policy-based design - the policy list is long, all policies must be spelled out, and there aren’t any good defaults; the policies are positional, so the type declaration requires careful counting of commas, and, as the new policies are added, any semblance of a meaningful order of policies disappears. </span><span class="koboSpan" id="kobo.1126.2">Note that we did not mention the problem of different sets of policies creating different types - in this case, this is not a drawback, but the design intent. </span><span class="koboSpan" id="kobo.1126.3">If we want a type with support for addition and a similar type but without addition, these have to be </span><span class="No-Break"><span class="koboSpan" id="kobo.1127.1">different types.</span></span></p>
<p><span class="koboSpan" id="kobo.1128.1">Ideally, we would like to just list the policies for the properties we want our value to have - I want a value type based on integers that support addition, multiplication, and assignment, but nothing else. </span><span class="koboSpan" id="kobo.1128.2">After all, we did this with the Adapter pattern, so we would not settle for anything less now. </span><span class="koboSpan" id="kobo.1128.3">As it turns out, there is a way to </span><span class="No-Break"><span class="koboSpan" id="kobo.1129.1">accomplish this.</span></span></p>
<p><span class="koboSpan" id="kobo.1130.1">First, let’s think of what such a policy might look like. </span><span class="koboSpan" id="kobo.1130.2">For example, the policy that enables addition should inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">operator+()</span></strong><span class="koboSpan" id="kobo.1132.1"> into the public interface of the class (and maybe also </span><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">operator+=()</span></strong><span class="koboSpan" id="kobo.1134.1">). </span><span class="koboSpan" id="kobo.1134.2">The policy that makes the value assignable should inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">operator=()</span></strong><span class="koboSpan" id="kobo.1136.1">. </span><span class="koboSpan" id="kobo.1136.2">We </span><a id="_idIndexMarker980"/><span class="koboSpan" id="kobo.1137.1">have seen enough of such policies to know how they are implemented - they have to be base classes, publicly inherited, and they need to know what the derived class is and cast it to its type, so they have to </span><span class="No-Break"><span class="koboSpan" id="kobo.1138.1">use CRTP:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1139.1">
template &lt;
  typename T,    // The base type (like int)
  typename V&gt;    // The derived class
struct Incrementable {
  V operator++() {
    V&amp; v = static_cast&lt;V&amp;&gt;(*this);
    ++v.val_;     // The value inside the derived class
    return v;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.1140.1">Now, we need to give some thought to the use of these policies in the primary template. </span><span class="koboSpan" id="kobo.1140.2">First of all, we want to support the unknown number of policies, in any order. </span><span class="koboSpan" id="kobo.1140.3">This brings </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">variadic</span></strong><span class="koboSpan" id="kobo.1142.1"> templates to mind. </span><span class="koboSpan" id="kobo.1142.2">However, to use CRTP, the template parameters have to be templates themselves. </span><span class="koboSpan" id="kobo.1142.3">Then, we want to inherit from an instantiation of each of these templates, however many there are. </span><span class="koboSpan" id="kobo.1142.4">What we need is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">variadic</span></strong><span class="koboSpan" id="kobo.1144.1"> template with a template template </span><span class="No-Break"><span class="koboSpan" id="kobo.1145.1">parameter pack:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1146.1">
// Example 26
template &lt;typename T,
          template &lt;typename, typename&gt; class ... </span><span class="koboSpan" id="kobo.1146.2">Policies&gt;
class Value :
  public Policies&lt;T, Value&lt;T, Policies ... </span><span class="koboSpan" id="kobo.1146.3">&gt;&gt; ...
</span><span class="koboSpan" id="kobo.1146.4">{ ... </span><span class="koboSpan" id="kobo.1146.5">};</span></pre>
<p><span class="koboSpan" id="kobo.1147.1">The preceding declaration introduces a class template called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">Value</span></strong><span class="koboSpan" id="kobo.1149.1">, with at least one parameter that is a type, plus zero or more template policies, which themselves have two type parameters (in C++17, we can also write </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">typename ... </span><span class="koboSpan" id="kobo.1150.2">Policies</span></strong><span class="koboSpan" id="kobo.1151.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1152.1">class ... </span><span class="koboSpan" id="kobo.1152.2">Policies</span></strong><span class="koboSpan" id="kobo.1153.1">). </span><span class="koboSpan" id="kobo.1153.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1154.1">Value</span></strong><span class="koboSpan" id="kobo.1155.1"> class instantiates these templates with the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1156.1">T</span></strong><span class="koboSpan" id="kobo.1157.1"> and</span><a id="_idIndexMarker981"/><span class="koboSpan" id="kobo.1158.1"> itself and inherits publicly from all </span><span class="No-Break"><span class="koboSpan" id="kobo.1159.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.1160.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">Value</span></strong><span class="koboSpan" id="kobo.1162.1"> class template should contain the interface that we want to be common for all our value types. </span><span class="koboSpan" id="kobo.1162.2">The rest will have to come from policies. </span><span class="koboSpan" id="kobo.1162.3">Let’s make the values copyable, assignable, and printable </span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1">by default:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1164.1">
// Example 26
template &lt;typename T,
          template &lt;typename, typename&gt; class ... </span><span class="koboSpan" id="kobo.1164.2">Policies&gt;
class Value :
  public Policies&lt;T, Value&lt;T, Policies ... </span><span class="koboSpan" id="kobo.1164.3">&gt;&gt; ...
</span><span class="koboSpan" id="kobo.1164.4">{
  public:
  using base_type = T;
  explicit Value() = default;
  explicit Value(T v) : val_(v) {}
  Value(const Value&amp; rhs) : val_(rhs.val_) {}
  Value&amp; operator=(Value rhs) {
    val_ = rhs.val_;
    return *this;
  }
  Value&amp; operator=(T rhs) { val_ = rhs; return *this; }
  friend std::ostream&amp;
  operator&lt;&lt;(std::ostream&amp; out, Value x) {
    out &lt;&lt; x.val_; return out;
  }
  friend std::istream&amp;
    operator&gt;&gt;(std::istream&amp; in, Value&amp; x) {
    in &gt;&gt; x.val_; return in;
  }
  private:
  T val_ {};
};</span></pre>
<p><span class="koboSpan" id="kobo.1165.1">Again, we use the </span><em class="italic"><span class="koboSpan" id="kobo.1166.1">friend factor</span></em><span class="koboSpan" id="kobo.1167.1">y from </span><a href="B19262_12.xhtml#_idTextAnchor562"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1168.1">Chapter 12</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.1169.1">, Friend Factory, </span></em><span class="koboSpan" id="kobo.1170.1">to generate the </span><span class="No-Break"><span class="koboSpan" id="kobo.1171.1">stream operators.</span></span></p>
<p><span class="koboSpan" id="kobo.1172.1">Before we can indulge</span><a id="_idIndexMarker982"/><span class="koboSpan" id="kobo.1173.1"> ourselves in implementing all of the policies, there is one more hurdle to overcome. </span><span class="koboSpan" id="kobo.1173.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">val_</span></strong><span class="koboSpan" id="kobo.1175.1"> value is private in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">Value</span></strong><span class="koboSpan" id="kobo.1177.1"> class, and we like it this way. </span><span class="koboSpan" id="kobo.1177.2">However, the policies need to access and modify it. </span><span class="koboSpan" id="kobo.1177.3">In the past, we solved this problem by making each policy that needed such access into a friend. </span><span class="koboSpan" id="kobo.1177.4">This time, we don’t even know the names of the policies we may have. </span><span class="koboSpan" id="kobo.1177.5">After working through the preceding declaration of the parameter pack expansion as a set of base classes, the reader may reasonably expect us to pull a rabbit out of the hat and somehow declare friendship to the entire parameter pack. </span><span class="koboSpan" id="kobo.1177.6">Unfortunately, the standard offers no such way. </span><span class="koboSpan" id="kobo.1177.7">The best solution we can suggest is to provide a set of accessor functions that should be called only by the policies, but there is no good way to enforce that (a name, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">policy_accessor_do_not_call()</span></strong><span class="koboSpan" id="kobo.1179.1">, might go some way to suggest that the user code should stay away from it, but the ingenuity of the programmer knows no bounds, and such hints are not </span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1">universally respected):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1181.1">
// Example 26
template &lt;typename T,
          template &lt;typename, typename&gt; class ... </span><span class="koboSpan" id="kobo.1181.2">Policies&gt;
class Value :
  public Policies&lt;T, Value&lt;T, Policies ... </span><span class="koboSpan" id="kobo.1181.3">&gt;&gt; ...
</span><span class="koboSpan" id="kobo.1181.4">{
  public:
  ...
</span><span class="koboSpan" id="kobo.1181.5">  T get() const { return val_; }
  T&amp; get() { return val_; }
  private:
  T val_ {};
};</span></pre>
<p><span class="koboSpan" id="kobo.1182.1">To create a value type</span><a id="_idIndexMarker983"/><span class="koboSpan" id="kobo.1183.1"> with a restricted set of operations, we have to instantiate this template with a list of policies we want, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">nothing else:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1185.1">
// Example 26
using V = Value&lt;int, Addable, Incrementable&gt;;
V v1(0), v2(1);
v1++; // Incrementable - OK
V v3(v1 + v2); // Addable - OK
v3 *= 2; // No multiplication policies - won't compile</span></pre>
<p><span class="koboSpan" id="kobo.1186.1">The number and the type of policies we can implement are limited mostly by the need at hand (or imagination), but here are some examples that demonstrate adding different kinds of operations to </span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1">the class.</span></span></p>
<p><span class="koboSpan" id="kobo.1188.1">First of all, we can implement the aforementioned </span><strong class="source-inline"><span class="koboSpan" id="kobo.1189.1">Incrementable</span></strong><span class="koboSpan" id="kobo.1190.1"> policy that provides the two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">++</span></strong><span class="koboSpan" id="kobo.1192.1"> operators, postfix </span><span class="No-Break"><span class="koboSpan" id="kobo.1193.1">and prefix:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1194.1">
// Example 26
template &lt;typename T, typename V&gt; struct Incrementable {
  V operator++() {
    V&amp; v = static_cast&lt;V&amp;&gt;(*this);
    ++(v.get());
    return v;
  }
  V operator++(int) {
    V&amp; v = static_cast&lt;V&amp;&gt;(*this);
    return V(v.get()++);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.1195.1">We can make a</span><a id="_idIndexMarker984"/><span class="koboSpan" id="kobo.1196.1"> separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">Decrementable</span></strong><span class="koboSpan" id="kobo.1198.1"> policy for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1199.1">--</span></strong><span class="koboSpan" id="kobo.1200.1"> operators, or have one policy for both if it makes sense for our type. </span><span class="koboSpan" id="kobo.1200.2">Also, if want to increment by some value other than one, then we need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1201.1">+=</span></strong><span class="koboSpan" id="kobo.1202.1"> operators </span><span class="No-Break"><span class="koboSpan" id="kobo.1203.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1204.1">
// Example 26
template &lt;typename T, typename V&gt; struct Incrementable {
  V&amp; operator+=(V val) {
    V&amp; v = static_cast&lt;V&amp;&gt;(*this);
    v.get() += val.get();
    return v;
  }
  V&amp; operator+=(T val) {
    V&amp; v = static_cast&lt;V&amp;&gt;(*this);
    v.get() += val;
    return v;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.1205.1">The preceding policy provides two versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1206.1">operator+=()</span></strong><span class="koboSpan" id="kobo.1207.1"> - one accepts the increment of the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">Value</span></strong><span class="koboSpan" id="kobo.1209.1"> type, and the other of the foundation type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">T</span></strong><span class="koboSpan" id="kobo.1211.1">. </span><span class="koboSpan" id="kobo.1211.2">This is not a requirement, and we could implement an increment by values of some other types as needed. </span><span class="koboSpan" id="kobo.1211.3">We can even have several versions of the increment policy, as long as only one is used (the compiler would let us know if we were introducing incompatible overloads of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1212.1">same operator).</span></span></p>
<p><span class="koboSpan" id="kobo.1213.1">We can add the operators </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">*=</span></strong><span class="koboSpan" id="kobo.1215.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1216.1">/=</span></strong><span class="koboSpan" id="kobo.1217.1"> in a similar manner. </span><span class="koboSpan" id="kobo.1217.2">Adding binary operators such as comparison operators or addition and multiplication is a little different - these operators have to be non-member functions to allow for type conversions on the first argument. </span><span class="koboSpan" id="kobo.1217.3">Again, the </span><a id="_idIndexMarker985"/><span class="koboSpan" id="kobo.1218.1">friend factory pattern comes in handy. </span><span class="koboSpan" id="kobo.1218.2">Let’s start with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">comparison operators:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1220.1">
// Example 26
template &lt;typename T, typename V&gt; struct ComparableSelf {
  friend bool operator==(V lhs, V rhs) {
    return lhs.get() == rhs.get();
  }
  friend bool operator!=(V lhs, V rhs) {
    return lhs.get() != rhs.get();
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.1221.1">When instantiated, this template generates two non-member non-template functions, that is, the comparison operators for variables of the type of the specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">Value</span></strong><span class="koboSpan" id="kobo.1223.1"> class, the one that is instantiated. </span><span class="koboSpan" id="kobo.1223.2">We may also want to allow comparisons with the foundation type (such </span><span class="No-Break"><span class="koboSpan" id="kobo.1224.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1225.1">int</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1226.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1227.1">
template &lt;typename T, typename V&gt; struct ComparableValue {
  friend bool operator==(V lhs, T rhs) {
    return lhs.get() == rhs;
  }
  friend bool operator==(T lhs, V rhs) {
    return lhs == rhs.get();
  }
  friend bool operator!=(V lhs, T rhs) {
    return lhs.get() != rhs;
  }
  friend bool operator!=(T lhs, V rhs) {
    return lhs != rhs.get();
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.1228.1">More often than not, we will likely want both types of comparison at the same time. </span><span class="koboSpan" id="kobo.1228.2">We could simply put them both into the same policy and not worry about separating them, or we could create a</span><a id="_idIndexMarker986"/><span class="koboSpan" id="kobo.1229.1"> combined policy from the two we </span><span class="No-Break"><span class="koboSpan" id="kobo.1230.1">already have:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1231.1">
// Example 26
template &lt;typename T, typename V&gt;
struct Comparable : public ComparableSelf&lt;T, V&gt;,
                    public ComparableValue&lt;T, V&gt; {};</span></pre>
<p><span class="koboSpan" id="kobo.1232.1">In the previous section, we combined all comparisons in a single adapter from the beginning. </span><span class="koboSpan" id="kobo.1232.2">Here, we use a slightly different approach just to illustrate different options for controlling class interfaces with policies or adapters (both solutions offer the same options). </span><span class="koboSpan" id="kobo.1232.3">The addition and multiplication operators are created by similar policies. </span><span class="koboSpan" id="kobo.1232.4">They are also friend non-template non-member functions. </span><span class="koboSpan" id="kobo.1232.5">The only difference is the return value type - they return the object itself, </span><span class="No-Break"><span class="koboSpan" id="kobo.1233.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1234.1">
// Example 26
template &lt;typename T, typename V&gt; struct Addable {
  friend V operator+(V lhs, V rhs) {
    return V(lhs.get() + rhs.get());
  }
  friend V operator+(V lhs, T rhs) {
    return V(lhs.get() + rhs);
  }
  friend V operator+(T lhs, V rhs) {
    return V(lhs + rhs.get());
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.1235.1">As you can see, the problem of returning the “final value type” that we struggled with while writing adapters does not exist here: the derived class that is passed into each policy is the value </span><span class="No-Break"><span class="koboSpan" id="kobo.1236.1">type itself.</span></span></p>
<p><span class="koboSpan" id="kobo.1237.1">Explicit or implicit conversion operators for conversions to the base type can be added just </span><span class="No-Break"><span class="koboSpan" id="kobo.1238.1">as easily:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1239.1">
// Example 26
template &lt;typename T, typename V&gt;
struct ExplicitConvertible {
  explicit operator T() {
    return static_cast&lt;V*&gt;(this)-&gt;get();
  }
  explicit operator const T() const {
    return static_cast&lt;const V*&gt;(this)-&gt;get();
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.1240.1">This approach, at first </span><a id="_idIndexMarker987"/><span class="koboSpan" id="kobo.1241.1">glance, seems to solve most of the drawbacks of the traditional policy-based types. </span><span class="koboSpan" id="kobo.1241.2">The order of the policies does not matter - we can specify only the ones we want and not worry about the other ones - what’s not to like? </span><span class="koboSpan" id="kobo.1241.3">There are, however, two fundamental limitations. </span><span class="koboSpan" id="kobo.1241.4">First of all, the policy-based class cannot refer to any policy by name. </span><span class="koboSpan" id="kobo.1241.5">There is no longer a slot for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">DeletionPolicy</span></strong><span class="koboSpan" id="kobo.1243.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1244.1">AdditionPolicy</span></strong><span class="koboSpan" id="kobo.1245.1">. </span><span class="koboSpan" id="kobo.1245.2">There are no convention-enforced policy interfaces, such as the deletion policy having to be callable. </span><span class="koboSpan" id="kobo.1245.3">The entire process of binding the policies into a single type is implicit; it’s just a superposition </span><span class="No-Break"><span class="koboSpan" id="kobo.1246.1">of interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.1247.1">Therefore, we are limited in what we can do using these policies - we can inject public member functions and non-member functions - even add private data members - but we cannot provide an implementation for an aspect of behavior that’s determined and limited by the primary policy-based class. </span><span class="koboSpan" id="kobo.1247.2">As such, this is not an implementation of the Strategy pattern - we are composing the interface, and, perforce, the implementation, at will, not customizing a specific algorithm (which is why we deferred the demonstration of this alternative policy-based design pattern until </span><span class="No-Break"><span class="koboSpan" id="kobo.1248.1">this chapter).</span></span></p>
<p><span class="koboSpan" id="kobo.1249.1">The second, closely related, limitation is that there are no default policies. </span><span class="koboSpan" id="kobo.1249.2">The missing policies are just that, missing. </span><span class="koboSpan" id="kobo.1249.3">There is nothing in their place. </span><span class="koboSpan" id="kobo.1249.4">The default behavior is always the absence of any behavior. </span><span class="koboSpan" id="kobo.1249.5">In the traditional policy-based design, each policy slot has to be filled. </span><span class="koboSpan" id="kobo.1249.6">If there is a reasonable default, it can be specified, and then that is the policy unless the user overrides it (for example, the default deletion policy uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1250.1">operator delete</span></strong><span class="koboSpan" id="kobo.1251.1">). </span><span class="koboSpan" id="kobo.1251.2">If there is no default, the compiler won’t let us omit the policy - we have to give an argument to </span><span class="No-Break"><span class="koboSpan" id="kobo.1252.1">the template.</span></span></p>
<p><span class="koboSpan" id="kobo.1253.1">The consequences of</span><a id="_idIndexMarker988"/><span class="koboSpan" id="kobo.1254.1"> these limitations reach farther than you may think at first glance. </span><span class="koboSpan" id="kobo.1254.2">For example, it may be tempting to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1255.1">enable_if</span></strong><span class="koboSpan" id="kobo.1256.1"> technique we saw in </span><a href="B19262_15.xhtml#_idTextAnchor689"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1257.1">Chapter 15</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.1258.1">, Policy-Based Design,</span></em><span class="koboSpan" id="kobo.1259.1"> instead of injecting public member functions through the base class. </span><span class="koboSpan" id="kobo.1259.2">Then, we could have a default behavior that is enabled if none of the other options are. </span><span class="koboSpan" id="kobo.1259.3">But it won’t work here. </span><span class="koboSpan" id="kobo.1259.4">We can certainly create a policy that is targeted for use </span><span class="No-Break"><span class="koboSpan" id="kobo.1260.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1261.1">enable_if</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1262.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1263.1">
template &lt;typename T, typename V&gt; struct Addable {
  constexpr bool adding_enabled = true;
};</span></pre>
<p><span class="koboSpan" id="kobo.1264.1">But there is no way to use it - we can’t use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1265.1">AdditionPolicy::adding_enabled</span></strong><span class="koboSpan" id="kobo.1266.1"> because there is no </span><strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">AdditionPolicy</span></strong><span class="koboSpan" id="kobo.1268.1"> - all policy slots are unnamed. </span><span class="koboSpan" id="kobo.1268.2">The other option would be to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">Value::adding_enabled</span></strong><span class="koboSpan" id="kobo.1270.1"> - the addition policy is a base class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">Value</span></strong><span class="koboSpan" id="kobo.1272.1">, and, therefore, all of its data members are visible in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">Value</span></strong><span class="koboSpan" id="kobo.1274.1"> class. </span><span class="koboSpan" id="kobo.1274.2">The only problem is that it does not work - at the point where this expression is evaluated by the compiler (in the definition of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">Value</span></strong><span class="koboSpan" id="kobo.1276.1"> type as the template parameter for the CRTP policies), </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">Value</span></strong><span class="koboSpan" id="kobo.1278.1"> is an incomplete type and we cannot access its data members yet. </span><span class="koboSpan" id="kobo.1278.2">We could evaluate </span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">policy_name::adding_enabled</span></strong><span class="koboSpan" id="kobo.1280.1"> if we knew what the policy name was. </span><span class="koboSpan" id="kobo.1280.2">But that knowledge is exactly what we gave up in trade for not having to specify the entire list </span><span class="No-Break"><span class="koboSpan" id="kobo.1281.1">of policies.</span></span></p>
<p><span class="koboSpan" id="kobo.1282.1">While not, strictly speaking, an application of the Strategy pattern, the alternative to the policy-based design that we have just learned about can be attractive when the policies are primarily used to control a set of supported operations. </span><span class="koboSpan" id="kobo.1282.2">While discussing the guidelines for policy-based design, we have mentioned that it is rarely worth it to use a policy slot just to provide the additional safe</span><a id="_idTextAnchor776"/><span class="koboSpan" id="kobo.1283.1">ty of the restricted interface. </span><span class="koboSpan" id="kobo.1283.2">For such situations, this alternative approach should be kept </span><span class="No-Break"><span class="koboSpan" id="kobo.1284.1">in mind.</span></span></p>
<p><span class="koboSpan" id="kobo.1285.1">Overall, we can see that both patterns have their advantages and drawbacks: adapters rely on a more complex form of CRTP while the “slot-less” policies we just saw require us to compromise the encapsulation (we have to expose the value to the policies using something like our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1286.1">get()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1287.1"> methods).</span></span></p>
<p><span class="koboSpan" id="kobo.1288.1">Such is the nature of the problems we have to solve as software engineers - once a problem becomes complex enough, it can be solved, frequently using more than one design, and each approach has its own advantages and limitations. </span><span class="koboSpan" id="kobo.1288.2">There is no way we can compare every two patterns that can be used to create two very different designs that address </span><a id="_idIndexMarker989"/><span class="koboSpan" id="kobo.1289.1">the same need, at least not in a book of any finite size. </span><span class="koboSpan" id="kobo.1289.2">By presenting and analyzing these examples, we hope to equip the reader with the understanding and insight </span><a id="_idTextAnchor777"/><a id="_idTextAnchor778"/><span class="koboSpan" id="kobo.1290.1">that will be helpful in evaluating similarly complex and varied design options for </span><span class="No-Break"><span class="koboSpan" id="kobo.1291.1">real-life problems.</span></span></p>
<h1 id="_idParaDest-299"><a id="_idTextAnchor779"/><span class="koboSpan" id="kobo.1292.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1293.1">We have studied two of the most commonly used patterns - not just in C++, but in software design in general. </span><span class="koboSpan" id="kobo.1293.2">The Adapter pattern offers an approach to solving a wide class of design challenges. </span><span class="koboSpan" id="kobo.1293.3">These challenges have only the most general property in common - given a class, a function, or a software component that provides certain functionality, we must solve a particular problem, and build a solution for a different, related problem. </span><span class="koboSpan" id="kobo.1293.4">The decorator pattern is, in many ways, a subset of the Adapter pattern, which is restricted to augmenting the existing interface of the class of a function with </span><span class="No-Break"><span class="koboSpan" id="kobo.1294.1">new behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.1295.1">We have seen that the interface conversion and modification done by the adapters and decorators can be applied to interfaces at every stage of the program’s life - while the most common use is to modify runtime interfaces so that a class can be used in a different context, there are also compile-time adapters for generic code that allow us to use a class as a building block or a component of a larger, more </span><span class="No-Break"><span class="koboSpan" id="kobo.1296.1">complex, class.</span></span></p>
<p><span class="koboSpan" id="kobo.1297.1">The Adapter pattern can be applied to many very different design challenges. </span><span class="koboSpan" id="kobo.1297.2">The varied nature of these challenges and the generality of the pattern itself often mean that an alternative solution is possible. </span><span class="koboSpan" id="kobo.1297.3">Such alternatives often use a completely different approach - an entirely different design pattern - but end up providing similar behavior. </span><span class="koboSpan" id="kobo.1297.4">The difference lies in trade-offs, additional conditions, and limitations imposed by the chosen approach to the design, and the possibilities of extending the solution in different ways. </span><span class="koboSpan" id="kobo.1297.5">To this end, this chapter offers a comparison of two very different design approaches to the same problem, complete with an evaluation of the strengths and drawbacks of </span><span class="No-Break"><span class="koboSpan" id="kobo.1298.1">both options.</span></span></p>
<p><span class="koboSpan" id="kobo.1299.1">The next, penultimate, chapter introduces a pattern that is large, complex, and has several</span><a id="_idTextAnchor780"/> <a id="_idTextAnchor781"/><span class="koboSpan" id="kobo.1300.1">interacting components - an appropriate pattern to be left for our grand finale - the </span><span class="No-Break"><span class="koboSpan" id="kobo.1301.1">Visitor pattern.</span></span></p>
<h1 id="_idParaDest-300"><a id="_idTextAnchor782"/><span class="koboSpan" id="kobo.1302.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1303.1">What is the </span><span class="No-Break"><span class="koboSpan" id="kobo.1304.1">Adapter pattern?</span></span></li>
<li><span class="koboSpan" id="kobo.1305.1">What is the decorator pattern and how does it differ from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1306.1">Adapter pattern?</span></span></li>
<li><span class="koboSpan" id="kobo.1307.1">The classic OOP implementation of the decorator pattern is usually not recommended in C++. </span><span class="No-Break"><span class="koboSpan" id="kobo.1308.1">Why not?</span></span></li>
<li><span class="koboSpan" id="kobo.1309.1">When should the C++ class decorator use inheritance </span><span class="No-Break"><span class="koboSpan" id="kobo.1310.1">or composition?</span></span></li>
<li><span class="koboSpan" id="kobo.1311.1">When should the C++ class adapter use inheritance </span><span class="No-Break"><span class="koboSpan" id="kobo.1312.1">or composition?</span></span></li>
<li><span class="koboSpan" id="kobo.1313.1">C++ provides a general function adapter for currying function arguments, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">std::bind</span></strong><span class="koboSpan" id="kobo.1315.1">. </span><span class="koboSpan" id="kobo.1315.2">What are </span><span class="No-Break"><span class="koboSpan" id="kobo.1316.1">its limitations?</span></span></li>
<li><span class="koboSpan" id="kobo.1317.1">C++11 provides template aliases that can be used as adapters. </span><span class="koboSpan" id="kobo.1317.2">What are </span><span class="No-Break"><span class="koboSpan" id="kobo.1318.1">their limitations?</span></span></li>
<li><span class="koboSpan" id="kobo.1319.1">Both the adapter and policy patterns can be used to add or modify the public interface of a class. </span><span class="koboSpan" id="kobo.1319.2">Give some reasons for preferring one over </span><span class="No-Break"><span class="koboSpan" id="kobo.1320.1">the other.</span></span></li>
</ol>
</div>
</body></html>