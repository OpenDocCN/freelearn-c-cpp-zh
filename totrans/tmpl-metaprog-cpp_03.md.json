["```cpp\ntemplate <typename T>\n```", "```cpp\nT add(T const a, T const b)\n```", "```cpp\n{\n```", "```cpp\n   return a + b;\n```", "```cpp\n}\n```", "```cpp\nauto a = add(42, 21);\n```", "```cpp\nauto a = add<int>(42, 21);\n```", "```cpp\nauto a = add<>(42, 21);\n```", "```cpp\nint add(const int a, const int b)\n```", "```cpp\n{\n```", "```cpp\n  return a + b;\n```", "```cpp\n}\n```", "```cpp\nauto b = add<short>(42, 21);\n```", "```cpp\nshort add(const short a, const int b)\n```", "```cpp\n{\n```", "```cpp\n  return static_cast<short>(a + b);\n```", "```cpp\n}\n```", "```cpp\nauto d = add(41.0, 21);\n```", "```cpp\nauto d = add<double>(41.0, 21);\n```", "```cpp\nclass foo\n```", "```cpp\n{\n```", "```cpp\n   int value;\n```", "```cpp\npublic:\n```", "```cpp\n   explicit foo(int const i):value(i)\n```", "```cpp\n   { }\n```", "```cpp\n   explicit operator int() const { return value; }\n```", "```cpp\n};\n```", "```cpp\nauto f = add(foo(42), foo(41));\n```", "```cpp\nfoo operator+(foo const a, foo const b)\n```", "```cpp\n{\n```", "```cpp\n  return foo((int)a + (int)b);\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename Input, typename Predicate>\n```", "```cpp\nint count_if(Input start, Input end, Predicate p)\n```", "```cpp\n{\n```", "```cpp\n   int total = 0;\n```", "```cpp\n   for (Input i = start; i != end; i++)\n```", "```cpp\n   {\n```", "```cpp\n      if (p(*i))\n```", "```cpp\n         total++;\n```", "```cpp\n   }\n```", "```cpp\n   return total;\n```", "```cpp\n}\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   int arr[]{ 1,1,2,3,5,8,11 };\n```", "```cpp\n   int odds = count_if(\n```", "```cpp\n                 std::begin(arr), std::end(arr), \n```", "```cpp\n                 [](int const n) { return n % 2 == 1; });\n```", "```cpp\n   std::cout << odds << '\\n';\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nclass wrapper\n```", "```cpp\n{\n```", "```cpp\npublic:\n```", "```cpp\n   wrapper(T const v): value(v)\n```", "```cpp\n   { }\n```", "```cpp\n   T const& get() const { return value; }\n```", "```cpp\nprivate:\n```", "```cpp\n   T value;\n```", "```cpp\n};\n```", "```cpp\nwrapper a(42);           // wraps an int\n```", "```cpp\nwrapper<int> b(42);      // wraps an int\n```", "```cpp\nwrapper<short> c(42);    // wraps a short\n```", "```cpp\nwrapper<double> d(42.0); // wraps a double\n```", "```cpp\nwrapper e(\"42\");         // wraps a char const *\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nclass wrapper;\n```", "```cpp\nvoid use_foo(wrapper<int>* ptr);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nclass wrapper;                       // OK\n```", "```cpp\nvoid use_wrapper(wrapper<int>* ptr); // OK\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   wrapper<int> a(42);            // error, incomplete type\n```", "```cpp\n   use_wrapper(&a);\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nclass wrapper\n```", "```cpp\n{\n```", "```cpp\n   // template definition\n```", "```cpp\n};\n```", "```cpp\nvoid use_wrapper(wrapper<int>* ptr)\n```", "```cpp\n{\n```", "```cpp\n   std::cout << ptr->get() << '\\n';\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nclass composition\n```", "```cpp\n{\n```", "```cpp\npublic:\n```", "```cpp\n   T add(T const a, T const b)\n```", "```cpp\n   {\n```", "```cpp\n      return a + b;\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ncomposition<int> c;\n```", "```cpp\nc.add(41, 21);\n```", "```cpp\nclass composition\n```", "```cpp\n{\n```", "```cpp\npublic:\n```", "```cpp\n   template <typename T>\n```", "```cpp\n   T add(T const a, T const b)\n```", "```cpp\n   {\n```", "```cpp\n      return a + b;\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ncomposition c;\n```", "```cpp\nc.add<int>(41, 21);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nclass wrapper\n```", "```cpp\n{\n```", "```cpp\npublic:\n```", "```cpp\n   wrapper(T const v) :value(v)\n```", "```cpp\n   {}\n```", "```cpp\n   T const& get() const { return value; }\n```", "```cpp\n   template <typename U>\n```", "```cpp\n   U as() const\n```", "```cpp\n   {\n```", "```cpp\n      return static_cast<U>(value);\n```", "```cpp\n   }\n```", "```cpp\nprivate:\n```", "```cpp\n   T value;\n```", "```cpp\n};\n```", "```cpp\nwrapper<double> a(42.0);\n```", "```cpp\nauto d = a.get();       // double\n```", "```cpp\nauto n = a.as<int>();   // int\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nclass wrapper { /* ... */ };\n```", "```cpp\ntemplate <typename T = int>\n```", "```cpp\nclass wrapper { /* ... */ };\n```", "```cpp\ntemplate <typename>\n```", "```cpp\nclass wrapper;\n```", "```cpp\ntemplate <typename = int>\n```", "```cpp\nclass wrapper;\n```", "```cpp\ntemplate <typename... T>\n```", "```cpp\nclass wrapper { /* ... */ };\n```", "```cpp\ntemplate <WrappableType T>\n```", "```cpp\nclass wrapper { /* ... */ };\n```", "```cpp\ntemplate <WrappableType T = int>\n```", "```cpp\nclass wrapper { /* ... */ };\n```", "```cpp\ntemplate <WrappableType... T>\n```", "```cpp\nclass wrapper { /* ... */ };\n```", "```cpp\ntemplate <int V>\n```", "```cpp\nclass foo { /*...*/ };\n```", "```cpp\ntemplate <int V = 42>\n```", "```cpp\nclass foo { /*...*/ };\n```", "```cpp\ntemplate <int... V>\n```", "```cpp\nclass foo { /*...*/ };\n```", "```cpp\ntemplate <typename T, size_t S>\n```", "```cpp\nclass buffer\n```", "```cpp\n{\n```", "```cpp\n   T data_[S];\n```", "```cpp\npublic:\n```", "```cpp\n   constexpr T const * data() const { return data_; }\n```", "```cpp\n   constexpr T& operator[](size_t const index)\n```", "```cpp\n   {\n```", "```cpp\n      return data_[index];\n```", "```cpp\n   }\n```", "```cpp\n   constexpr T const & operator[](size_t const index) const\n```", "```cpp\n   {\n```", "```cpp\n      return data_[index];\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nbuffer<int, 10> b1;\n```", "```cpp\nbuffer<int, 2*5> b2;\n```", "```cpp\nstatic_assert(std::is_same_v<decltype(b1), decltype(b2)>);\n```", "```cpp\nbuffer<int, 3*5> b3;\n```", "```cpp\ntemplate <typename T, size_t S>\n```", "```cpp\nclass buffer\n```", "```cpp\n{\n```", "```cpp\n   T data_[S];\n```", "```cpp\npublic:\n```", "```cpp\n   constexpr T* data() const { return data_; }\n```", "```cpp\n   constexpr T& operator[](size_t const index)\n```", "```cpp\n   {\n```", "```cpp\n      return data_[index];\n```", "```cpp\n   }\n```", "```cpp\n   constexpr T const & operator[](size_t const index) const\n```", "```cpp\n   {\n```", "```cpp\n      return data_[index];\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate<>\n```", "```cpp\nclass buffer<int, 10>\n```", "```cpp\n{\n```", "```cpp\n  int data_[10];\n```", "```cpp\npublic: \n```", "```cpp\n  constexpr int * data() const;\n```", "```cpp\n  constexpr int & operator[](const size_t index); \n```", "```cpp\n  constexpr const int & operator[](\n```", "```cpp\n    const size_t index) const;\n```", "```cpp\n};\n```", "```cpp\ntemplate<>\n```", "```cpp\nclass buffer<int, 15>\n```", "```cpp\n{\n```", "```cpp\n  int data_[15]; \n```", "```cpp\npublic: \n```", "```cpp\n  constexpr int * data() const;\n```", "```cpp\n  constexpr int & operator[](const size_t index);\n```", "```cpp\n  constexpr const int & operator[](\n```", "```cpp\n    const size_t index) const;\n```", "```cpp\n};\n```", "```cpp\nstatic_assert(!std::is_same_v<decltype(b1), decltype(b3)>);\n```", "```cpp\nstruct device\n```", "```cpp\n{\n```", "```cpp\n   virtual void output() = 0;\n```", "```cpp\n   virtual ~device() {}\n```", "```cpp\n};\n```", "```cpp\ntemplate <void (*action)()>\n```", "```cpp\nstruct smart_device : device\n```", "```cpp\n{\n```", "```cpp\n   void output() override\n```", "```cpp\n   {\n```", "```cpp\n      (*action)();\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nvoid say_hello_in_english()\n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"Hello, world!\\n\";\n```", "```cpp\n}\n```", "```cpp\nvoid say_hello_in_spanish()\n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"Hola mundo!\\n\";\n```", "```cpp\n}\n```", "```cpp\nauto w1 =\n```", "```cpp\n   std::make_unique<smart_device<&say_hello_in_english>>();\n```", "```cpp\nw1->output();\n```", "```cpp\nauto w2 =\n```", "```cpp\n   std::make_unique<smart_device<&say_hello_in_spanish>>();\n```", "```cpp\nw2->output();\n```", "```cpp\nstatic_assert(!std::is_same_v<decltype(w1), decltype(w2)>);\n```", "```cpp\nstd::unique_ptr<device> w1 = \n```", "```cpp\n   std::make_unique<smart_device<&say_hello_in_english>>();\n```", "```cpp\nw1->output();\n```", "```cpp\nstd::unique_ptr<device> w2 = \n```", "```cpp\n   std::make_unique<smart_device<&say_hello_in_spanish>>();\n```", "```cpp\nw2->output();\n```", "```cpp\nstatic_assert(std::is_same_v<decltype(w1), decltype(w2)>);\n```", "```cpp\ntemplate <typename Command, void (Command::*action)()>\n```", "```cpp\nstruct smart_device : device\n```", "```cpp\n{\n```", "```cpp\n   smart_device(Command& command) : cmd(command) {}\n```", "```cpp\n   void output() override\n```", "```cpp\n   {\n```", "```cpp\n      (cmd.*action)();\n```", "```cpp\n   }\n```", "```cpp\nprivate:\n```", "```cpp\n   Command& cmd;\n```", "```cpp\n};\n```", "```cpp\nstruct hello_command\n```", "```cpp\n{\n```", "```cpp\n   void say_hello_in_english()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"Hello, world!\\n\";\n```", "```cpp\n   }\n```", "```cpp\n   void say_hello_in_spanish()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"Hola mundo!\\n\";\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nhello_command cmd;\n```", "```cpp\nauto w1 = std::make_unique<\n```", "```cpp\n   smart_device<hello_command, \n```", "```cpp\n      &hello_command::say_hello_in_english>>(cmd);\n```", "```cpp\nw1->output();\n```", "```cpp\nauto w2 = std::make_unique<\n```", "```cpp\n   smart_device<hello_command, \n```", "```cpp\n      &hello_command::say_hello_in_spanish>>(cmd);\n```", "```cpp\nw2->output();\n```", "```cpp\ntemplate <auto x>\n```", "```cpp\nstruct foo\n```", "```cpp\n{ /* … */ };\n```", "```cpp\nfoo<42>   f1;  // foo<int>\n```", "```cpp\nfoo<42.0> f2;  // foo<double> in C++20, error for older \n```", "```cpp\n               // versions\n```", "```cpp\nfoo<\"42\"> f3;  // error\n```", "```cpp\ntemplate<size_t N>\n```", "```cpp\nstruct string_literal\n```", "```cpp\n{\n```", "```cpp\n   constexpr string_literal(const char(&str)[N])\n```", "```cpp\n   {\n```", "```cpp\n      std::copy_n(str, N, value);\n```", "```cpp\n   }\n```", "```cpp\n   char value[N];\n```", "```cpp\n};\n```", "```cpp\ntemplate <string_literal x>\n```", "```cpp\nstruct foo\n```", "```cpp\n{\n```", "```cpp\n};\n```", "```cpp\ntemplate<auto... x>\n```", "```cpp\nstruct foo\n```", "```cpp\n{ /* ... */ };\n```", "```cpp\nfoo<42, 42.0, false, 'x'> f;\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nclass simple_wrapper\n```", "```cpp\n{\n```", "```cpp\npublic:\n```", "```cpp\n   T value;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nclass fancy_wrapper\n```", "```cpp\n{\n```", "```cpp\npublic:\n```", "```cpp\n   fancy_wrapper(T const v) :value(v)\n```", "```cpp\n   {\n```", "```cpp\n   }\n```", "```cpp\n   T const& get() const { return value; }\n```", "```cpp\n   template <typename U>\n```", "```cpp\n   U as() const\n```", "```cpp\n   {\n```", "```cpp\n      return static_cast<U>(value);\n```", "```cpp\n   }\n```", "```cpp\nprivate:\n```", "```cpp\n   T value;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T, typename U, \n```", "```cpp\n          template<typename> typename W = fancy_wrapper>\n```", "```cpp\nclass wrapping_pair\n```", "```cpp\n{\n```", "```cpp\npublic:\n```", "```cpp\n   wrapping_pair(T const a, U const b) :\n```", "```cpp\n      item1(a), item2(b)\n```", "```cpp\n   {\n```", "```cpp\n   }\n```", "```cpp\n   W<T> item1;\n```", "```cpp\n   W<U> item2;\n```", "```cpp\n};   \n```", "```cpp\nwrapping_pair<int, double> p1(42, 42.0);\n```", "```cpp\nstd::cout << p1.item1.get() << ' '\n```", "```cpp\n          << p1.item2.get() << '\\n';\n```", "```cpp\nwrapping_pair<int, double, simple_wrapper> p2(42, 42.0);\n```", "```cpp\nstd::cout << p2.item1.value << ' '\n```", "```cpp\n          << p2.item2.value << '\\n';\n```", "```cpp\ntemplate <typename T = int>\n```", "```cpp\nclass foo { /*...*/ };\n```", "```cpp\ntemplate <typename T = int, typename U = double>\n```", "```cpp\nclass bar { /*...*/ };\n```", "```cpp\ntemplate <typename T = int, typename U>\n```", "```cpp\nclass bar { };   // error\n```", "```cpp\ntemplate <typename T = int, typename U>\n```", "```cpp\nvoid func() {}   // OK\n```", "```cpp\ntemplate <typename T, typename U = double>\n```", "```cpp\nstruct foo;\n```", "```cpp\ntemplate <typename T = int, typename U>\n```", "```cpp\nstruct foo;\n```", "```cpp\ntemplate <typename T, typename U>\n```", "```cpp\nstruct foo\n```", "```cpp\n{\n```", "```cpp\n   T a;\n```", "```cpp\n   U b;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T = int, typename U = double>\n```", "```cpp\nstruct foo\n```", "```cpp\n{\n```", "```cpp\n   T a;\n```", "```cpp\n   U b;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T = int, typename U>\n```", "```cpp\nstruct foo;  // error, U does not have a default argument\n```", "```cpp\ntemplate <typename T, typename U = double>\n```", "```cpp\nstruct foo;\n```", "```cpp\ntemplate <typename T = int>\n```", "```cpp\nstruct foo;\n```", "```cpp\ntemplate <typename T = int> // error redefinition\n```", "```cpp\n                            // of default parameter\n```", "```cpp\nstruct foo {};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct foo\n```", "```cpp\n{\n```", "```cpp\nprotected:\n```", "```cpp\n   using value_type = T;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T, typename U = typename T::value_type>\n```", "```cpp\nstruct bar\n```", "```cpp\n{\n```", "```cpp\n   using value_type = U;\n```", "```cpp\n};\n```", "```cpp\nbar<foo<int>> x;\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct foo\n```", "```cpp\n{\n```", "```cpp\n  void f() {}\n```", "```cpp\n};\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n  foo<int> x;\n```", "```cpp\n}\n```", "```cpp\ntemplate<>\n```", "```cpp\nstruct foo<int>\n```", "```cpp\n{\n```", "```cpp\n  inline void f();\n```", "```cpp\n};\n```", "```cpp\ntemplate<>\n```", "```cpp\nstruct foo<int>\n```", "```cpp\n{\n```", "```cpp\n  inline void f() { }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct foo\n```", "```cpp\n{\n```", "```cpp\n  void f() {}\n```", "```cpp\n  void g() {int a = \"42\";}\n```", "```cpp\n};\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n  foo<int> x;\n```", "```cpp\n  x.f();\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct foo\n```", "```cpp\n{\n```", "```cpp\n  void f() {}\n```", "```cpp\n  void g() {}\n```", "```cpp\n};\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n  foo<int>* p;\n```", "```cpp\n  foo<int> x;\n```", "```cpp\n  foo<double>* q;\n```", "```cpp\n}\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n  foo<int>* p;\n```", "```cpp\n  foo<int> x;\n```", "```cpp\n  foo<double>* q;\n```", "```cpp\n  x.f();\n```", "```cpp\n  q->g();\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct control\n```", "```cpp\n{};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct button : public control<T>\n```", "```cpp\n{};\n```", "```cpp\nvoid show(button<int>* ptr)\n```", "```cpp\n{\n```", "```cpp\n   control<int>* c = ptr;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct foo\n```", "```cpp\n{\n```", "```cpp\n   static T data;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T> T foo<T>::data = 0;\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   foo<int> a;\n```", "```cpp\n   foo<double> b;\n```", "```cpp\n   foo<double> c;\n```", "```cpp\n   std::cout << a.data << '\\n'; // 0\n```", "```cpp\n   std::cout << b.data << '\\n'; // 0\n```", "```cpp\n   std::cout << c.data << '\\n'; // 0\n```", "```cpp\n   b.data = 42;\n```", "```cpp\n   std::cout << a.data << '\\n'; // 0\n```", "```cpp\n   std::cout << b.data << '\\n'; // 42\n```", "```cpp\n   std::cout << c.data << '\\n'; // 42\n```", "```cpp\n}\n```", "```cpp\n    template class-key template-name <argument-list>\n    ```", "```cpp\n    template return-type name<argument-list>(parameter-list);\n    template return-type name(parameter-list);\n    ```", "```cpp\nnamespace ns\n```", "```cpp\n{\n```", "```cpp\n   template <typename T>\n```", "```cpp\n   struct wrapper\n```", "```cpp\n   {\n```", "```cpp\n      T value;\n```", "```cpp\n   };\n```", "```cpp\n   template struct wrapper<int>;       // [1]\n```", "```cpp\n}\n```", "```cpp\ntemplate struct ns::wrapper<double>;   // [2]\n```", "```cpp\nint main() {}\n```", "```cpp\nnamespace ns\n```", "```cpp\n{\n```", "```cpp\n   template <typename T>\n```", "```cpp\n   T add(T const a, T const b)\n```", "```cpp\n   {\n```", "```cpp\n      return a + b;\n```", "```cpp\n   }\n```", "```cpp\n   template int add(int, int);           // [1]\n```", "```cpp\n}\n```", "```cpp\ntemplate double ns::add(double, double); // [2]\n```", "```cpp\nint main() { }\n```", "```cpp\nnamespace ns\n```", "```cpp\n{\n```", "```cpp\n   template <typename T>\n```", "```cpp\n   struct wrapper { T value; };\n```", "```cpp\n}\n```", "```cpp\nusing namespace ns;\n```", "```cpp\ntemplate struct wrapper<double>;   // error\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nclass foo\n```", "```cpp\n{\n```", "```cpp\n   struct bar {};\n```", "```cpp\n   T f(bar const arg)\n```", "```cpp\n   {\n```", "```cpp\n      return {};\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate int foo<int>::f(foo<int>::bar);\n```", "```cpp\n    extern template class-key template-name <argument-list>\n    ```", "```cpp\n    extern template return-type name<argument-list>(parameter-list);\n    extern template return-type name(parameter-list);\n    ```", "```cpp\n// wrapper.h\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   T data;\n```", "```cpp\n}; \n```", "```cpp\nextern template wrapper<int>;   // [1]\n```", "```cpp\n// source1.cpp\n```", "```cpp\n#include \"wrapper.h\"\n```", "```cpp\n#include <iostream>\n```", "```cpp\ntemplate wrapper<int>;          // [2]\n```", "```cpp\nvoid f()\n```", "```cpp\n{\n```", "```cpp\n   ext::wrapper<int> a{ 42 };\n```", "```cpp\n   std::cout << a.data << '\\n';\n```", "```cpp\n}\n```", "```cpp\n// source2.cpp\n```", "```cpp\n#include \"wrapper.h\"\n```", "```cpp\n#include <iostream>\n```", "```cpp\nvoid g()\n```", "```cpp\n{\n```", "```cpp\n   wrapper<int> a{ 100 };\n```", "```cpp\n   std::cout << a.data << '\\n';\n```", "```cpp\n}\n```", "```cpp\n// main.cpp\n```", "```cpp\n#include \"wrapper.h\"\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   wrapper<int> a{ 0 };\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct is_floating_point\n```", "```cpp\n{\n```", "```cpp\n   constexpr static bool value = false;\n```", "```cpp\n};\n```", "```cpp\ntemplate <>\n```", "```cpp\nstruct is_floating_point<float>\n```", "```cpp\n{\n```", "```cpp\n   constexpr static bool value = true;\n```", "```cpp\n};\n```", "```cpp\ntemplate <>\n```", "```cpp\nstruct is_floating_point<double>\n```", "```cpp\n{\n```", "```cpp\n   constexpr static bool value = true;\n```", "```cpp\n};\n```", "```cpp\ntemplate <>\n```", "```cpp\nstruct is_floating_point<long double>\n```", "```cpp\n{\n```", "```cpp\n   constexpr static bool value = true;\n```", "```cpp\n};\n```", "```cpp\nstd::cout << is_floating_point<int>::value         << '\\n';\n```", "```cpp\nstd::cout << is_floating_point<float>::value       << '\\n';\n```", "```cpp\nstd::cout << is_floating_point<double>::value      << '\\n';\n```", "```cpp\nstd::cout << is_floating_point<long double>::value << '\\n';\n```", "```cpp\nstd::cout << is_floating_point<std::string>::value << '\\n';\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct foo\n```", "```cpp\n{\n```", "```cpp\n   static T value;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T> T foo<T>::value = 0;\n```", "```cpp\ntemplate <> int foo<int>::value = 42;\n```", "```cpp\nfoo<double> a, b;  // a.value=0, b.value=0\n```", "```cpp\nfoo<int> c;        // c.value=42\n```", "```cpp\na.value = 100;     // a.value=100, b.value=100, c.value=42\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct is_floating_point;\n```", "```cpp\ntemplate <>\n```", "```cpp\nstruct is_floating_point<float>\n```", "```cpp\n{\n```", "```cpp\n   constexpr static bool value = true;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct is_floating_point\n```", "```cpp\n{\n```", "```cpp\n   constexpr static bool value = false;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename>\n```", "```cpp\nstruct foo {};    // primary template\n```", "```cpp\ntemplate <>\n```", "```cpp\nstruct foo<int>;  // explicit specialization declaration\n```", "```cpp\nfoo<double> a; // OK\n```", "```cpp\nfoo<int>* b;   // OK\n```", "```cpp\nfoo<int> c;    // error, foo<int> incomplete type\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct foo {};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid func(foo<T>) \n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"primary template\\n\";\n```", "```cpp\n}\n```", "```cpp\ntemplate<>\n```", "```cpp\nvoid func(foo<int>) \n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"int specialization\\n\";\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid func(T a)\n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"primary template\\n\";\n```", "```cpp\n}\n```", "```cpp\ntemplate <>\n```", "```cpp\nvoid func(int a = 0) // error: default argument not allowed\n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"int specialization\\n\";\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T, typename U>\n```", "```cpp\nvoid func(T a, U b)\n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"primary template\\n\";\n```", "```cpp\n}\n```", "```cpp\ntemplate <>\n```", "```cpp\nvoid func(int a, int b)\n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"int-int specialization\\n\";\n```", "```cpp\n}\n```", "```cpp\ntemplate <>\n```", "```cpp\nvoid func(int a, double b)\n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"int-double specialization\\n\";\n```", "```cpp\n}\n```", "```cpp\nfunc(1, 2);      // int-int specialization\n```", "```cpp\nfunc(1, 2.0);    // int-double specialization\n```", "```cpp\nfunc(1.0, 2.0);  // primary template\n```", "```cpp\ntemplate <typename T, int S>\n```", "```cpp\nstruct collection\n```", "```cpp\n{\n```", "```cpp\n   void operator()()\n```", "```cpp\n   { std::cout << \"primary template\\n\"; }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct collection<T, 10>\n```", "```cpp\n{\n```", "```cpp\n   void operator()()\n```", "```cpp\n   { std::cout << \"partial specialization <T, 10>\\n\"; }\n```", "```cpp\n};\n```", "```cpp\ntemplate <int S>\n```", "```cpp\nstruct collection<int, S>\n```", "```cpp\n{ \n```", "```cpp\n   void operator()()\n```", "```cpp\n   { std::cout << \"partial specialization <int, S>\\n\"; }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T, int S>\n```", "```cpp\nstruct collection<T*, S>\n```", "```cpp\n{ \n```", "```cpp\n   void operator()()\n```", "```cpp\n   { std::cout << \"partial specialization <T*, S>\\n\"; }\n```", "```cpp\n};\n```", "```cpp\ncollection<char, 42> a;  // primary template\n```", "```cpp\ncollection<int,  42> b;  // partial specialization <int, S>\n```", "```cpp\ncollection<char, 10> c;  // partial specialization <T, 10>\n```", "```cpp\ncollection<int*, 20> d;  // partial specialization <T*, S>\n```", "```cpp\ncollection<int,   10> e; // error: collection<T,10> or \n```", "```cpp\n                         //        collection<int,S>\n```", "```cpp\ncollection<char*, 10> f; // error: collection<T,10> or \n```", "```cpp\n                         //        collection<T*,S>\n```", "```cpp\n    template <int A, int B> struct foo {};\n    template <int A> struct foo<A, A> {};     // OK\n    template <int A> struct foo<A, A + 1> {}; // error\n    ```", "```cpp\ntemplate <typename T, size_t S>\n```", "```cpp\nstd::ostream& pretty_print(std::ostream& os, \n```", "```cpp\n                           std::array<T, S> const& arr)\n```", "```cpp\n{\n```", "```cpp\n   os << '[';\n```", "```cpp\n   if (S > 0)\n```", "```cpp\n   {\n```", "```cpp\n      size_t i = 0;\n```", "```cpp\n      for (; i < S - 1; ++i)\n```", "```cpp\n         os << arr[i] << ',';\n```", "```cpp\n      os << arr[S-1];\n```", "```cpp\n   }\n```", "```cpp\n   os << ']';\n```", "```cpp\n   return os;\n```", "```cpp\n}\n```", "```cpp\nstd::array<int, 9> arr {1, 1, 2, 3, 5, 8, 13, 21};\n```", "```cpp\npretty_print(std::cout, arr);  // [1,1,2,3,5,8,13,21]\n```", "```cpp\nstd::array<char, 9> str;\n```", "```cpp\nstd::strcpy(str.data(), \"template\");\n```", "```cpp\npretty_print(std::cout, str);  // [t,e,m,p,l,a,t,e]\n```", "```cpp\ntemplate <size_t S>\n```", "```cpp\nstd::ostream& pretty_print(std::ostream& os, \n```", "```cpp\n                           std::array<char, S> const& arr)\n```", "```cpp\n{\n```", "```cpp\n   os << '[';\n```", "```cpp\n   for (auto const& e : arr)\n```", "```cpp\n      os << e;\n```", "```cpp\n   os << ']';\n```", "```cpp\n   return os;\n```", "```cpp\n}\n```", "```cpp\nstd::array<char, 9> str;\n```", "```cpp\nstd::strcpy(str.data(), \"template\");\n```", "```cpp\npretty_print(std::cout, str);  // [template]\n```", "```cpp\ntemplate<class T>\n```", "```cpp\nconstexpr T PI = T(3.1415926535897932385L);\n```", "```cpp\nconstexpr double PI = 3.1415926535897932385L;\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nT sphere_volume(T const r)\n```", "```cpp\n{\n```", "```cpp\n   return 4 * PI * r * r * r / 3;\n```", "```cpp\n}\n```", "```cpp\nfloat v1 = sphere_volume(42.0f); // warning\n```", "```cpp\ndouble v2 = sphere_volume(42.0); // OK\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct PI\n```", "```cpp\n{\n```", "```cpp\n   static const T value;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T> \n```", "```cpp\nconst T PI<T>::value = T(3.1415926535897932385L);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nT sphere_volume(T const r)\n```", "```cpp\n{\n```", "```cpp\n   return 4 * PI<T>::value * r * r * r / 3;\n```", "```cpp\n}\n```", "```cpp\ntemplate<class T>\n```", "```cpp\nconstexpr T PI = T(3.1415926535897932385L);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nT sphere_volume(T const r)\n```", "```cpp\n{\n```", "```cpp\n   return 4 * PI<T> * r * r * r / 3;\n```", "```cpp\n}\n```", "```cpp\ntemplate<typename T> \n```", "```cpp\nconstexpr T SEPARATOR = '\\n';\n```", "```cpp\ntemplate<> \n```", "```cpp\nconstexpr wchar_t SEPARATOR<wchar_t> = L'\\n';\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstd::basic_ostream<T>& show_parts(\n```", "```cpp\n   std::basic_ostream<T>& s, \n```", "```cpp\n   std::basic_string_view<T> const& str)\n```", "```cpp\n{\n```", "```cpp\n   using size_type = \n```", "```cpp\n      typename std::basic_string_view<T>::size_type;\n```", "```cpp\n   size_type start = 0;\n```", "```cpp\n   size_type end;\n```", "```cpp\n   do\n```", "```cpp\n   {\n```", "```cpp\n      end = str.find(SEPARATOR<T>, start);\n```", "```cpp\n      s << '[' << str.substr(start, end - start) << ']' \n```", "```cpp\n        << SEPARATOR<T>;\n```", "```cpp\n      start = end+1;\n```", "```cpp\n   } while (end != std::string::npos);\n```", "```cpp\n   return s;\n```", "```cpp\n}\n```", "```cpp\nshow_parts<char>(std::cout, \"one\\ntwo\\nthree\");\n```", "```cpp\nshow_parts<wchar_t>(std::wcout, L\"one line\");\n```", "```cpp\nstruct math_constants\n```", "```cpp\n{\n```", "```cpp\n   template<class T>\n```", "```cpp\n   static constexpr T PI = T(3.1415926535897932385L);\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nT sphere_volume(T const r)\n```", "```cpp\n{\n```", "```cpp\n   return 4 * math_constants::PI<T> *r * r * r / 3;\n```", "```cpp\n}\n```", "```cpp\nstruct math_constants\n```", "```cpp\n{\n```", "```cpp\n   template<class T>\n```", "```cpp\n   static const T PI;\n```", "```cpp\n};\n```", "```cpp\ntemplate<class T>\n```", "```cpp\nconst T math_constants::PI = T(3.1415926535897932385L);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct is_floating_point\n```", "```cpp\n{\n```", "```cpp\n   constexpr static bool value = false;\n```", "```cpp\n};\n```", "```cpp\nstd::cout << is_floating_point<float>::value << '\\n';\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\ninline constexpr bool is_floating_point_v = \n```", "```cpp\n   is_floating_point<T>::value;\n```", "```cpp\nstd::cout << is_floating_point_v<float> << '\\n';\n```", "```cpp\ntypedef int index_t;\n```", "```cpp\ntypedef std::vector<\n```", "```cpp\n           std::pair<int, std::string>> NameValueList;\n```", "```cpp\ntypedef int (*fn_ptr)(int, char);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct foo\n```", "```cpp\n{\n```", "```cpp\n   typedef T value_type;\n```", "```cpp\n};\n```", "```cpp\nusing index_t = int;\n```", "```cpp\nusing NameValueList = \n```", "```cpp\n   std::vector<std::pair<int, std::string>>;\n```", "```cpp\nusing fn_ptr = int(*)(int, char);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct foo\n```", "```cpp\n{\n```", "```cpp\n   using value_type = T;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nusing customer_addresses_t = \n```", "```cpp\n   std::map<int, std::vector<T>>;            // [1]\n```", "```cpp\nstruct delivery_address_t {};\n```", "```cpp\nstruct invoice_address_t {};\n```", "```cpp\nusing customer_delivery_addresses_t =\n```", "```cpp\n   customer_addresses_t<delivery_address_t>; // [2]\n```", "```cpp\nusing customer_invoice_addresses_t =\n```", "```cpp\n   customer_addresses_t<invoice_address_t>;  // [3]\n```", "```cpp\ntemplate <typename T, size_t S>\n```", "```cpp\nusing list_t = std::vector<T>;\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nusing list_t<T, 1> = T;\n```", "```cpp\ntemplate <typename T, size_t S>\n```", "```cpp\nstruct list\n```", "```cpp\n{\n```", "```cpp\n   using type = std::vector<T>;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct list<T, 1>\n```", "```cpp\n{\n```", "```cpp\n   using type = T;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T, size_t S>\n```", "```cpp\nusing list_t = typename list<T, S>::type;\n```", "```cpp\nstatic_assert(std::is_same_v<list_t<int, 1>, int>);\n```", "```cpp\nstatic_assert(std::is_same_v<list_t<int, 2>, std::vector<int>>);\n```", "```cpp\nint arr[] = { 1,6,3,8,4,2,9 };\n```", "```cpp\nstd::sort(\n```", "```cpp\n   std::begin(arr), std::end(arr),\n```", "```cpp\n   [](int const a, int const b) {return a > b; });\n```", "```cpp\nint pivot = 5;\n```", "```cpp\nauto count = std::count_if(\n```", "```cpp\n   std::begin(arr), std::end(arr),\n```", "```cpp\n   [pivot](int const a) {return a > pivot; });\n```", "```cpp\nstruct __lambda_1\n```", "```cpp\n{\n```", "```cpp\n   inline bool operator()(const int a, const int b) const\n```", "```cpp\n   {\n```", "```cpp\n      return a > b;\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nstruct __lambda_2\n```", "```cpp\n{\n```", "```cpp\n   __lambda_2(int & _pivot) : pivot{_pivot}\n```", "```cpp\n   {} \n```", "```cpp\n   inline bool operator()(const int a) const\n```", "```cpp\n   {\n```", "```cpp\n      return a > pivot;\n```", "```cpp\n   }\n```", "```cpp\nprivate: \n```", "```cpp\n   int pivot;\n```", "```cpp\n};\n```", "```cpp\nauto l1 = [](int a) {return a + a; };  // C++11, regular \n```", "```cpp\n                                       // lambda\n```", "```cpp\nauto l2 = [](auto a) {return a + a; }; // C++14, generic \n```", "```cpp\n                                       // lambda\n```", "```cpp\nauto l3 = []<typename T>(T a) \n```", "```cpp\n          { return a + a; };   // C++20, template lambda\n```", "```cpp\nauto v1 = l1(42);                      // OK\n```", "```cpp\nauto v2 = l1(42.0);                    // warning\n```", "```cpp\nauto v3 = l1(std::string{ \"42\" });     // error\n```", "```cpp\nauto v5 = l2(42);                      // OK\n```", "```cpp\nauto v6 = l2(42.0);                    // OK\n```", "```cpp\nauto v7 = l2(std::string{\"42\"});       // OK\n```", "```cpp\nauto v8 = l3(42);                      // OK\n```", "```cpp\nauto v9 = l3(42.0);                    // OK\n```", "```cpp\nauto v10 = l3(std::string{ \"42\" });    // OK\n```", "```cpp\nstruct __lambda_3\n```", "```cpp\n{\n```", "```cpp\n   template<typename T1>\n```", "```cpp\n   inline auto operator()(T1 a) const\n```", "```cpp\n   {\n```", "```cpp\n     return a + a;\n```", "```cpp\n   }\n```", "```cpp\n   template<>\n```", "```cpp\n   inline int operator()(int a) const\n```", "```cpp\n   {\n```", "```cpp\n     return a + a;\n```", "```cpp\n   }\n```", "```cpp\n   template<>\n```", "```cpp\n   inline double operator()(double a) const\n```", "```cpp\n   {\n```", "```cpp\n     return a + a;\n```", "```cpp\n   }\n```", "```cpp\n   template<>\n```", "```cpp\n   inline std::string operator()(std::string a) const\n```", "```cpp\n   {\n```", "```cpp\n     return std::operator+(a, a);\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nauto l1 = [](int a, int b) {return a + b; };\n```", "```cpp\nauto l2 = [](auto a, auto b) {return a + b; };\n```", "```cpp\nauto l3 = []<typename T, typename U>(T a, U b) \n```", "```cpp\n          { return a + b; };\n```", "```cpp\nauto v1 = l1(42, 1);                    // OK\n```", "```cpp\nauto v2 = l1(42.0, 1.0);                // warning\n```", "```cpp\nauto v3 = l1(std::string{ \"42\" }, '1'); // error\n```", "```cpp\nauto v4 = l2(42, 1);                    // OK\n```", "```cpp\nauto v5 = l2(42.0, 1);                  // OK\n```", "```cpp\nauto v6 = l2(std::string{ \"42\" }, '1'); // OK\n```", "```cpp\nauto v7 = l2(std::string{ \"42\" }, std::string{ \"1\" }); // OK \n```", "```cpp\nauto v8 = l3(42, 1);                    // OK\n```", "```cpp\nauto v9 = l3(42.0, 1);                  // OK\n```", "```cpp\nauto v10 = l3(std::string{ \"42\" }, '1'); // OK\n```", "```cpp\nauto v11 = l3(std::string{ \"42\" }, std::string{ \"42\" }); // OK \n```", "```cpp\nstruct __lambda_4\n```", "```cpp\n{\n```", "```cpp\n   template<typename T1, typename T2>\n```", "```cpp\n   inline auto operator()(T1 a, T2 b) const\n```", "```cpp\n   {\n```", "```cpp\n     return a + b;\n```", "```cpp\n   }\n```", "```cpp\n   template<>\n```", "```cpp\n   inline int operator()(int a, int b) const\n```", "```cpp\n   {\n```", "```cpp\n     return a + b;\n```", "```cpp\n   }\n```", "```cpp\n   template<>\n```", "```cpp\n   inline double operator()(double a, int b) const\n```", "```cpp\n   {\n```", "```cpp\n     return a + static_cast<double>(b);\n```", "```cpp\n   }\n```", "```cpp\n   template<>\n```", "```cpp\n   inline std::string operator()(std::string a, \n```", "```cpp\n                                 char b) const\n```", "```cpp\n   {\n```", "```cpp\n     return std::operator+(a, b);\n```", "```cpp\n   }\n```", "```cpp\n   template<>\n```", "```cpp\n   inline std::string operator()(std::string a, \n```", "```cpp\n                                 std::string b) const\n```", "```cpp\n   {\n```", "```cpp\n     return std::operator+(a, b);\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nauto l5 = []<typename T>(T a, T b) { return a + b; };\n```", "```cpp\nauto v1 = l5(42, 1);        // OK\n```", "```cpp\nauto v2 = l5(42, 1.0);      // error\n```", "```cpp\nauto v4 = l5(42.0, 1.0);    // OK\n```", "```cpp\nauto v5 = l5(42, false);    // error\n```", "```cpp\nauto v6 = l5(std::string{ \"42\" }, std::string{ \"1\" }); // OK \n```", "```cpp\nauto v6 = l5(std::string{ \"42\" }, '1'); // error               \n```", "```cpp\nauto l4 = [](auto a, decltype(a) b) {return a + b; };\n```", "```cpp\nauto v1 = l4(42.0, 1);                  // OK\n```", "```cpp\nauto v2 = l4(42, 1.0);                  // warning\n```", "```cpp\nauto v3 = l4(std::string{ \"42\" }, '1'); // error\n```", "```cpp\nauto l = []<typename T, size_t N>(\n```", "```cpp\n            std::array<T, N> const& arr) \n```", "```cpp\n{ \n```", "```cpp\n   return std::accumulate(arr.begin(), arr.end(), \n```", "```cpp\n                          static_cast<T>(0));\n```", "```cpp\n};\n```", "```cpp\nauto v1 = l(1);                           // error\n```", "```cpp\nauto v2 = l(std::array<int, 3>{1, 2, 3}); // OK\n```", "```cpp\nstruct __lambda_5\n```", "```cpp\n{\n```", "```cpp\n   template<typename T, size_t N>\n```", "```cpp\n   inline auto operator()(\n```", "```cpp\n      const std::array<T, N> & arr) const\n```", "```cpp\n   {\n```", "```cpp\n     return std::accumulate(arr.begin(), arr.end(), \n```", "```cpp\n                            static_cast<T>(0));\n```", "```cpp\n   }\n```", "```cpp\n   template<>\n```", "```cpp\n   inline int operator()(\n```", "```cpp\n      const std::array<int, 3> & arr) const\n```", "```cpp\n   {\n```", "```cpp\n     return std::accumulate(arr.begin(), arr.end(), \n```", "```cpp\n                            static_cast<int>(0));\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nstd::function<int(int)> factorial;\n```", "```cpp\nfactorial = [&factorial](int const n) {\n```", "```cpp\n   if (n < 2) return 1;\n```", "```cpp\n      else return n * factorial(n - 1);\n```", "```cpp\n};\n```", "```cpp\nfactorial(5);\n```", "```cpp\nauto factorial = [](auto f, int const n) {\n```", "```cpp\n   if (n < 2) return 1;\n```", "```cpp\n   else return n * f(f, n - 1);\n```", "```cpp\n};\n```", "```cpp\nfactorial(factorial, 5);\n```", "```cpp\nstruct __lambda_6\n```", "```cpp\n{\n```", "```cpp\n   template<class T1>\n```", "```cpp\n   inline auto operator()(T1 f, const int n) const\n```", "```cpp\n   {\n```", "```cpp\n     if(n < 2) return 1;\n```", "```cpp\n     else return n * f(f, n - 1);\n```", "```cpp\n   }\n```", "```cpp\n   template<>\n```", "```cpp\n   inline int operator()(__lambda_6 f, const int n) const\n```", "```cpp\n   {\n```", "```cpp\n     if(n < 2) return 1;\n```", "```cpp\n     else return n * f.operator()(__lambda_6(f), n - 1);\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\n__lambda_6 factorial = __lambda_6{};\n```", "```cpp\nfactorial(factorial, 5);\n```"]