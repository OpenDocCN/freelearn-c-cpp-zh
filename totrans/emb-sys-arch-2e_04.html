<html><head></head><body>
<div id="_idContainer026">
<h1 class="chapter-number" id="_idParaDest-86"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-87"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.2.1">The Boot-Up Procedure</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Now that the mechanisms, tools, and methodologies are in place, it is finally time to start looking at the procedures required to run the software on the target. </span><span class="koboSpan" id="kobo.3.2">Booting up an embedded system is a process that often requires knowledge of the specific system and the mechanisms in play. </span><span class="koboSpan" id="kobo.3.3">Depending on the target, there are a few indications we need to look for in the manual to find out what the system expects from the developer to successfully boot executables from the flash memory. </span><span class="koboSpan" id="kobo.3.4">This chapter will focus on the description of the boot process, with emphasis on the case of the Cortex-M microcontroller, which we decided to use as a reference platform. </span><span class="koboSpan" id="kobo.3.5">In particular, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.5.1">The interrupt </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">vector table</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.7.1">Memory layout</span></span></li>
<li><span class="koboSpan" id="kobo.8.1">Building and running the </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">boot code</span></span></li>
<li><span class="koboSpan" id="kobo.10.1">Multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">boot stages</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.12.1">By the end of this chapter, you will have an overview of main-loop </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">embedded development.</span></span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.14.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.15.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">at </span></span><a href="https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter4"><span class="No-Break"><span class="koboSpan" id="kobo.17.1">https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter4</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.18.1">.</span></span></p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.19.1">The interrupt vector table</span></h1>
<p><span class="koboSpan" id="kobo.20.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">interrupt vector table</span></strong><span class="koboSpan" id="kobo.22.1">, often abbreviated to </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">IVT</span></strong><span class="koboSpan" id="kobo.24.1"> or simply </span><strong class="bold"><span class="koboSpan" id="kobo.25.1">IV</span></strong><span class="koboSpan" id="kobo.26.1">, is an array of pointers</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.27.1"> to functions associated by the CPU to handle specific </span><em class="italic"><span class="koboSpan" id="kobo.28.1">exceptions</span></em><span class="koboSpan" id="kobo.29.1">, such as faults, system service requests from the application, and interrupt requests from peripherals. </span><span class="koboSpan" id="kobo.29.2">The IVT is usually located at the beginning of the binary image and thus is stored starting from the lowest address in the </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">flash memory.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">An interrupt request from a hardware component or peripheral will force the CPU to abruptly suspend the execution and execute the function at the associated position in the vector. </span><span class="koboSpan" id="kobo.31.2">For this reason, these functions are called </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">interrupt service routines</span></strong><span class="koboSpan" id="kobo.33.1"> (or simply </span><strong class="bold"><span class="koboSpan" id="kobo.34.1">ISRs</span></strong><span class="koboSpan" id="kobo.35.1">). </span><span class="koboSpan" id="kobo.35.2">Runtime </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.36.1">exceptions and faults can be handled in the same way as hardware interrupts, so special service routines are associated with internal CPU triggers through the </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">same table.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">The order of the ISRs enumerated in the vector, and their exact positions depend on the CPU architecture, the microcontroller model, and the peripherals supported. </span><span class="koboSpan" id="kobo.38.2">Each interrupt line corresponds to a predefined interrupt number and, depending on the microcontroller features, may be assigned </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">a priority.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">In a Cortex-M microcontroller, the first 16 positions in memory are reserved for storing the pointers to system handlers, which are architecture-dependent, and associated to different types of CPU runtime exceptions. </span><span class="koboSpan" id="kobo.40.2">The lowest address is used to store the initial value of the stack pointer, and the next 15 positions are reserved for system services and fault handlers. </span><span class="koboSpan" id="kobo.40.3">However, some of these positions are reserved and not connected to any event. </span><span class="koboSpan" id="kobo.40.4">The </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.41.1">system exceptions that can be handled using separate service routines in a Cortex-M CPU are </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.43.1">Reset</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.44.1">Non-Maskable </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.45.1">Interrupt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.46.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.47.1">NMI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">)</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.49.1">Hard fault</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.50.1">Memory exception</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.51.1">Bus fault</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.52.1">Usage fault</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.53.1">Supervisor call</span></span></li>
<li><span class="koboSpan" id="kobo.54.1">Debug </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">monitor event</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.56.1">PendSV call</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.57.1">System tick</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.58.1">The order of the hardware interrupts, starting from position 16, depends on the microcontroller configuration and, thus, on the specific silicon model, as the interrupt configuration refers to specific components, interfaces, and external </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">peripheral activities.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">A fully populated </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.61.1">vector of external interrupt handlers for STM32F407 and LM3S targets can be found in this book’s </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">code reposito</span><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.63.1">ry.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.64.1">Startup code</span></h2>
<p><span class="koboSpan" id="kobo.65.1">In order to boot a</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.66.1"> workable system, we need to define the interrupt vector and associate pointers with defined functions. </span><span class="koboSpan" id="kobo.66.2">A typical startup code file for our reference platform places the interrupt vector in a dedicated section using the GCC </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">section</span></strong><span class="koboSpan" id="kobo.68.1"> attribute. </span><span class="koboSpan" id="kobo.68.2">As the section will be put at the beginning of the image, we must define our interrupt vector starting with the reserved space for the initial stack pointer, followed by the system </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">exception handlers.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">The zeros correspond to the positions of the </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">reserved/unused slots:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.72.1">
__attribute__ ((section(".isr_vector")))
void (* const IV[])(void) =
{
  (void (*)(void))(END_STACK),
  isr_reset,
  isr_nmi,
  isr_hard_fault,
  isr_mem_fault,
  isr_bus_fault,
  isr_usage_fault,
  0, 0, 0, 0,
  isr_svc,
  isr_dbgmon,
  0,
  isr_pendsv,
  isr_systick,</span></pre>
<p><span class="koboSpan" id="kobo.73.1">From this position on, we define the interrupt lines for the external peripherals </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.75.1">
  isr_uart0,
  isr_ethernet,
  /* … many more external interrupts follow */
};</span></pre>
<p><span class="koboSpan" id="kobo.76.1">The startup code must also include the implementation of every symbol referenced in the array. </span><span class="koboSpan" id="kobo.76.2">The handler can be defined as </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">void</span></strong><span class="koboSpan" id="kobo.78.1"> procedures with no arguments, in the same format as the signature of </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">the IV:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.80.1">
void isr_bus_fault(void) {
  /* Bus error. </span><span class="koboSpan" id="kobo.80.2">Panic! </span><span class="koboSpan" id="kobo.80.3">*/
  while(1);
}</span></pre>
<p><span class="koboSpan" id="kobo.81.1">The interrupt handler in this example never returns, as a result of an unrecoverable bus error, and hangs </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.82.1">the system forever. </span><span class="koboSpan" id="kobo.82.2">Empty interrupt handlers can be associated to both system and external interrupts using weak symbols that can be overridden in the device driver modules by simply defining them again in the relevant </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">code sec</span><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.84.1">tion.</span></span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.85.1">Reset handler</span></h2>
<p><span class="koboSpan" id="kobo.86.1">When the microcontroller is </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.87.1">powered on, it starts the </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.88.1">execution from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">reset</span></strong><span class="koboSpan" id="kobo.90.1"> handler. </span><span class="koboSpan" id="kobo.90.2">This is a special ISR that does not return but rather performs initialization of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">.data</span></strong><span class="koboSpan" id="kobo.92.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">.bss</span></strong><span class="koboSpan" id="kobo.94.1"> sections, and then calls the entry point of the application. </span><span class="koboSpan" id="kobo.94.2">The initialization of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">.data</span></strong><span class="koboSpan" id="kobo.96.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">.bss</span></strong><span class="koboSpan" id="kobo.98.1"> sections consists of copying the initial value of the variables in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">.data</span></strong><span class="koboSpan" id="kobo.100.1"> section in flash onto the actual section in RAM where variables are accessed at runtime and filling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">.bss</span></strong><span class="koboSpan" id="kobo.102.1"> section in RAM with zeros so that the initial value of static symbols is guaranteed to be zero as per </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">C convention.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">The source and destination addresses of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">.data</span></strong><span class="koboSpan" id="kobo.106.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">.bss</span></strong><span class="koboSpan" id="kobo.108.1"> sections in RAM are computed by the linker when generating the binary image and exported as pointers using the linker script. </span><span class="koboSpan" id="kobo.108.2">The implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">isr_reset</span></strong><span class="koboSpan" id="kobo.110.1"> may look similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.112.1">
void isr_reset(void)
{
  unsigned int *src, *dst;
  src = (unsigned int *) &amp;_stored_data;
  dst = (unsigned int *) &amp;_start_data;
  while (dst != (unsigned int *)&amp;_end_data) {
    *dst = *src;
    dst++;
    src++;
  }
  dst = &amp;_start_bss;
  while (dst != (unsigned int *)&amp;_end_bss) {
    *dst = 0;
    dst++;
  }
  main();
}</span></pre>
<p><span class="koboSpan" id="kobo.113.1">Once the </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.114.1">variables in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">.bss</span></strong><span class="koboSpan" id="kobo.116.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">.data</span></strong><span class="koboSpan" id="kobo.118.1"> sections </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.119.1">have been initialized, it is finally possible to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">main</span></strong><span class="koboSpan" id="kobo.121.1"> function, which is the entry point of the application. </span><span class="koboSpan" id="kobo.121.2">The application code ensures that </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">main</span></strong><span class="koboSpan" id="kobo.123.1"> never returns by implementing an </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">infin</span><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.125.1">ite loop.</span></span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.126.1">Allocating the stack</span></h2>
<p><span class="koboSpan" id="kobo.127.1">In order to</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.128.1"> comply </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.129.1">with the </span><strong class="bold"><span class="koboSpan" id="kobo.130.1">application binary interface</span></strong><span class="koboSpan" id="kobo.131.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.132.1">ABI</span></strong><span class="koboSpan" id="kobo.133.1">) of the CPU, it is required to assign space in memory for the execution stack. </span><span class="koboSpan" id="kobo.133.2">This can be done in different ways, but usually, it is preferable to mark the end of the stack space in the linker script and associate the stack space to a specific area in RAM, not in use by </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">any section.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">The address obtained through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">END_STACK</span></strong><span class="koboSpan" id="kobo.137.1"> symbol, exported by the linker script, points to the end of an unused area in RAM. </span><span class="koboSpan" id="kobo.137.2">As mentioned earlier, its value must be stored at the beginning of the vector table, at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">0</span></strong><span class="koboSpan" id="kobo.139.1"> in our case, just before the IV. </span><span class="koboSpan" id="kobo.139.2">The address of the end of the stack has to be constant and cannot be calculated at runtime because the IV content is stored in the flash memory and thus cannot be modified </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">later on.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">Properly sizing the execution stack in memory is a delicate task that includes the assessment of the whole code base, keeping in mind stack usage from local variables and the depth of the call trace at any time during the execution. </span><span class="koboSpan" id="kobo.141.2">The analysis of all the factors related to stack usage and troubleshooting will be part of a wider topic that is covered in the next chapter. </span><span class="koboSpan" id="kobo.141.3">Our simple startup code provided here has a stack size that is big enough to contain the local variables and the function call stack, as it is mapped by the linker script </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.142.1">as far as possible from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">.bss</span></strong><span class="koboSpan" id="kobo.144.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">.data</span></strong><span class="koboSpan" id="kobo.146.1"> sections. </span><span class="koboSpan" id="kobo.146.2">Further aspects of the placement of the stack are considered in </span><a href="B18730_05.xhtml#_idTextAnchor149"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.147.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.148.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.149.1">Memory</span><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.150.1"> Management</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.152.1">Fault handlers</span></h2>
<p><span class="koboSpan" id="kobo.153.1">Fault-related </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.154.1">events are triggered by the CPU in</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.155.1"> the case of execution errors or policy violations. </span><span class="koboSpan" id="kobo.155.2">The CPU is able to detect a number of runtime errors, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.157.1">Attempting to execute code outside the memory areas marked </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">as executable</span></span></li>
<li><span class="koboSpan" id="kobo.159.1">Fetching data or the next instruction to execute from an </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">invalid location</span></span></li>
<li><span class="koboSpan" id="kobo.161.1">Illegal loading or storing using an </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">unaligned address</span></span></li>
<li><span class="koboSpan" id="kobo.163.1">Division </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">by zero</span></span></li>
<li><span class="koboSpan" id="kobo.165.1">Trying to access unavailable </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">coprocessor functionalities</span></span></li>
<li><span class="koboSpan" id="kobo.167.1">Attempting to read/write/execute outside the memory areas allowed for the current </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">running mode</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.169.1">Some core microcontrollers support different types of exceptions depending on the type of error. </span><span class="koboSpan" id="kobo.169.2">The Cortex-M3/M4 can distinguish between bus errors, usage faults, memory access violations, and generic faults, triggering the related exception. </span><span class="koboSpan" id="kobo.169.3">In other, smaller systems, fewer details are available on the type of </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">runtime error.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Very often, a fault will make the system unusable or unable to continue the execution due to the CPU register values or the stack being corrupted. </span><span class="koboSpan" id="kobo.171.2">In some cases, even placing a breakpoint inside the exception handler is not sufficient to detect the cause of the problem, making debugging harder. </span><span class="koboSpan" id="kobo.171.3">Some CPUs support extended information on the cause of the fault, which is available through memory-mapped registers after the exception occurs. </span><span class="koboSpan" id="kobo.171.4">In the case of the Cortex-M3/M4, this information is available through the </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">Configurable Fault Status Register</span></strong><span class="koboSpan" id="kobo.173.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.174.1">CFSR</span></strong><span class="koboSpan" id="kobo.175.1">), which</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.176.1"> is mapped at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">0xE000ED28</span></strong><span class="koboSpan" id="kobo.178.1"> on all </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">Cortex-M3/M4 CPUs.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">Memory violations may be non-fatal if the corresponding exception handler implements some kind of recovery strategy and can be useful to detect and react to the fault at runtime, which is</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.181.1"> especially useful in multithreaded</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.182.1"> environments, as we will see in more detail in </span><a href="B18730_09.xhtml#_idTextAnchor311"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.183.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.184.1">, </span><em class="italic"><span class="koboSpan" id="kobo.185.1">Distributed Systems and </span><a id="_idTextAnchor127"/></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.186.1">IoT Architecture</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">.</span></span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.188.1">Memory layout</span></h1>
<p><span class="koboSpan" id="kobo.189.1">The linker</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.190.1"> script, as we already know, contains the instructions for the linker on how to assemble the components of an embedded system. </span><span class="koboSpan" id="kobo.190.2">More specifically, it describes the sections mapped in memory and how they are deployed into the flash and the RAM of the target, as in the example provided in </span><a href="B18730_02.xhtml#_idTextAnchor055"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.191.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.192.1">, </span><em class="italic"><span class="koboSpan" id="kobo.193.1">Work Environment and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.194.1">Workflow Optimization</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">In most embedded devices, and in particular our reference platform, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">.text</span></strong><span class="koboSpan" id="kobo.198.1"> output section in the linker script, which contains all the executable code, should also include the special input section dedicated to storing the IV at the very beginning of the </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">executable image.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">We integrate the linker script by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">.isr_vector</span></strong><span class="koboSpan" id="kobo.202.1"> section at the beginning of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">.text</span></strong><span class="koboSpan" id="kobo.204.1"> output section before the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.206.1">
.text :
{
  *(.isr_vector)
  *(.text*)
  *(.rodata*)
} &gt; FLASH</span></pre>
<p><span class="koboSpan" id="kobo.207.1">Defining a read-only area in flash, which is dedicated to the vector table, is the only strict requirement for our system to boot up properly, as the address of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">isr_reset</span></strong><span class="koboSpan" id="kobo.209.1"> function is retrieved by the CPU at boot time from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">0x04</span></strong><span class="koboSpan" id="kobo.211.1"> address </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">in memory.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">Right after the definition for the text and read-only areas in flash, the linker script should export the value of the current address, which is the beginning of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">.data</span></strong><span class="koboSpan" id="kobo.215.1"> output section stored in flash. </span><span class="koboSpan" id="kobo.215.2">This section contains the initial value of all the global and static variables that have been initialized in the code. </span><span class="koboSpan" id="kobo.215.3">In the example linker script, the beginning of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">.data</span></strong><span class="koboSpan" id="kobo.217.1"> section is marked by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">_stored_data</span></strong><span class="koboSpan" id="kobo.219.1"> linker script variable, </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
_stored_data = .;</span></pre>
<p><span class="koboSpan" id="kobo.222.1">The data section </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.223.1">will eventually be mapped in RAM, but its initialization is done manually in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">isr_reset</span></strong><span class="koboSpan" id="kobo.225.1"> function by copying the content from flash to the actual region designated to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">.data</span></strong><span class="koboSpan" id="kobo.227.1"> section in RAM. </span><span class="koboSpan" id="kobo.227.2">The linker script provides a mechanism to separate</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.228.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.229.1">Virtual Memory Address</span></strong><span class="koboSpan" id="kobo.230.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.231.1">VMA</span></strong><span class="koboSpan" id="kobo.232.1">) and </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.233.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.234.1">Load Memory Address</span></strong><span class="koboSpan" id="kobo.235.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.236.1">LMA</span></strong><span class="koboSpan" id="kobo.237.1">) for a section, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">AT</span></strong><span class="koboSpan" id="kobo.239.1"> keyword in the definition of the section. </span><span class="koboSpan" id="kobo.239.2">If no </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">AT</span></strong><span class="koboSpan" id="kobo.241.1"> keyword is specified, the LMA is, by default, set to the same address as the VMA. </span><span class="koboSpan" id="kobo.241.2">In our case, the VMA of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">.data</span></strong><span class="koboSpan" id="kobo.243.1"> input section is in RAM and exported using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">_start_data</span></strong><span class="koboSpan" id="kobo.245.1"> pointer, which will be used by </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">isr_vector</span></strong><span class="koboSpan" id="kobo.247.1"> as the destination address when copying the values of the symbols stored from flash. </span><span class="koboSpan" id="kobo.247.2">The LMA of </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">.data</span></strong><span class="koboSpan" id="kobo.249.1">, though, is located in the flash memory, so we set the LMA address to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">_stored_data</span></strong><span class="koboSpan" id="kobo.251.1"> pointer in flash, while defining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">.data</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.253.1">output section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.254.1">
.data : AT (_stored_data)
{
  _start_data = .;
  *(.data*)
  . </span><span class="koboSpan" id="kobo.254.2">= ALIGN(4);
  _end_data = .;
} &gt; RAM</span></pre>
<p><span class="koboSpan" id="kobo.255.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">.bss</span></strong><span class="koboSpan" id="kobo.257.1">, there is no LMA, as no data is stored in the image for this section. </span><span class="koboSpan" id="kobo.257.2">When including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">.bss</span></strong><span class="koboSpan" id="kobo.259.1"> output section, its VMA will automatically be set to the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">.data</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.261.1">output section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.262.1">
.bss :
{
  _start_bss = .;
  *(.bss*)
  . </span><span class="koboSpan" id="kobo.262.2">= ALIGN(4);
  _end_bss = .;
  _end = .;
} &gt; RAM</span></pre>
<p><span class="koboSpan" id="kobo.263.1">Finally, in this design, the </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.264.1">linker is expected to provide the initial value for the execution stack. </span><span class="koboSpan" id="kobo.264.2">Using the highest address in memory is a common choice for a single-threaded application, even though, as discussed in the next chapter, this may cause problems in the case of stack overflow. </span><span class="koboSpan" id="kobo.264.3">For this example, however, this is an acceptable solution, and we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">END_STACK</span></strong><span class="koboSpan" id="kobo.266.1"> symbol by adding the following line to the </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">linker script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
END_STACK = ORIGIN(RAM) + LENGTH(RAM);</span></pre>
<p><span class="koboSpan" id="kobo.269.1">To better understand where each symbol will be placed in memory, variable definitions can be added to the startup file in different places within the code. </span><span class="koboSpan" id="kobo.269.2">This way, we can check the locations where the variables are stored in memory when running the executable in the debugger for the first time. </span><span class="koboSpan" id="kobo.269.3">Supposing that we have variables stored in both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">.data</span></strong><span class="koboSpan" id="kobo.271.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">.bss</span></strong><span class="koboSpan" id="kobo.273.1"> output sections, the memory layout for the example startup code may look like </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.275.1"><img alt="Figure 4.1 – Memory layout in the example startup code" src="image/B18730_04_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.276.1">Figure 4.1 – Memory layout in the example startup code</span></p>
<p><span class="koboSpan" id="kobo.277.1">When the </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.278.1">executable is linked, the symbols are automatically set at compile time to indicate the beginning and the end of each section in memory. </span><span class="koboSpan" id="kobo.278.2">In our case, variables indicating the beginning and the end of each section are automatically assigned to the right value, depending on the size of the sections that the linker will include when creating the executable. </span><span class="koboSpan" id="kobo.278.3">Since the size of each section is known at compile time, the linker is able to identify those situations where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">.text</span></strong><span class="koboSpan" id="kobo.280.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">.data</span></strong><span class="koboSpan" id="kobo.282.1"> sections do not fit into the flash, and a linker error is generated at the end of the build. </span><span class="koboSpan" id="kobo.282.2">Creating a map file is useful for checking the size and the location of each symbol. </span><span class="koboSpan" id="kobo.282.3">In our boot-up example code, here is how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">.text</span></strong><span class="koboSpan" id="kobo.284.1"> section appears within the </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">map file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
.text 0x0000000000000000 0x168
0x0000000000000000 _start_text = .
</span><span class="koboSpan" id="kobo.286.2">*(.isr_vector)
.isr_vector 0x0000000000000000 0xf0 startup.o
0x0000000000000000 IV
*(.text*)
.text 0x00000000000000f0 0x78 startup.o
0x00000000000000f0 isr_reset
0x0000000000000134 isr_fault
0x000000000000013a isr_empty
0x0000000000000146 main</span></pre>
<p><span class="koboSpan" id="kobo.287.1">Similarly, we can find the boundaries of each section, exported by the linker script at </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">compile time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.289.1">
0x0000000000000000 _start_text = .
</span><span class="koboSpan" id="kobo.289.2">0x0000000000000168 _end_text = .
</span><span class="koboSpan" id="kobo.289.3">0x0000000020000000 _start_data = .
</span><span class="koboSpan" id="kobo.289.4">0x0000000020000004 _end_data = .
</span><span class="koboSpan" id="kobo.289.5">0x0000000020000004 _start_bss = .
</span><span class="koboSpan" id="kobo.289.6">0x0000000020000328 _end_bss = .
</span><span class="koboSpan" id="kobo.289.7">0x0000000020000328 _end = .</span></pre>
<p><span class="koboSpan" id="kobo.290.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">.rodata</span></strong><span class="koboSpan" id="kobo.292.1"> input section, which is empty in this minimalist example, is mapped in the flash memory area, in between </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">.text</span></strong><span class="koboSpan" id="kobo.294.1"> and the data LMA. </span><span class="koboSpan" id="kobo.294.2">This is reserved for constant symbols because constants do not have to be mapped in RAM. </span><span class="koboSpan" id="kobo.294.3">It is advisable to enforce the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">const</span></strong><span class="koboSpan" id="kobo.296.1"> C modifier when defining constant symbols because RAM is often our most precious </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.297.1">resource, and in some cases, even sparing a few bytes of writable memory by moving constant symbols to the flash can make a difference in the project development, as flash memory is usually much bigger, and its usage can be easily dete</span><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.298.1">rmined at </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">linking time.</span></span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.300.1">Building and running the boot code</span></h1>
<p><span class="koboSpan" id="kobo.301.1">The example</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.302.1"> provided</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.303.1"> here is one of the simplest executable images that can be run on the target. </span><span class="koboSpan" id="kobo.303.2">To assemble, compile, and link everything together, we can use a simple makefile that automates all the steps and allows us to focus on our software </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">life cycle.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">When the image is ready, we can transfer it to the real target or alternatively, </span><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.306.1">run it using </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">an emulator.</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.308.1">The makefile</span></h2>
<p><span class="koboSpan" id="kobo.309.1">A very basic makefile</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.310.1"> to build our startup application describes the</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.311.1"> final target (</span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">image.bin</span></strong><span class="koboSpan" id="kobo.313.1">) and the intermediate steps required to build it. </span><span class="koboSpan" id="kobo.313.2">Makefile syntax is, in general, very vast, and covering all the functions provided by </span><strong class="bold"><span class="koboSpan" id="kobo.314.1">Make</span></strong><span class="koboSpan" id="kobo.315.1"> is outside the scope of this book. </span><span class="koboSpan" id="kobo.315.2">However, the few concepts explained here should be sufficient to get up and running on automating the </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">build process.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">Defining the targets for our makefile, in this case, is quite simple. </span><span class="koboSpan" id="kobo.317.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">startup.c</span></strong><span class="koboSpan" id="kobo.319.1"> source file, containing the IV, some exception handlers, and the main and the global variables we used in the example, can be compiled and assembled into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">startup.o</span></strong><span class="koboSpan" id="kobo.321.1"> object file. </span><span class="koboSpan" id="kobo.321.2">The linker uses the indications provided in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">target.ld</span></strong><span class="koboSpan" id="kobo.323.1"> linker script to deploy the symbols in the correct sections, producing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">.elf</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.325.1">executable image.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">objcopy</span></strong><span class="koboSpan" id="kobo.328.1"> is used to transform the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">.elf</span></strong><span class="koboSpan" id="kobo.330.1"> executable into a binary image, which can be transferred to the target or run </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">using QEMU:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.332.1"><img alt="Figure 4.2 – Build steps and dependencies" src="image/B18730_04_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.333.1">Figure 4.2 – Build steps and dependencies</span></p>
<p><span class="koboSpan" id="kobo.334.1">The makefile should contain a few configuration variables to describe the toolchain. </span><span class="koboSpan" id="kobo.334.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">=</span></strong><span class="koboSpan" id="kobo.336.1"> assignment operator allows you to set values for the variables when invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">make</span></strong><span class="koboSpan" id="kobo.338.1"> command. </span><span class="koboSpan" id="kobo.338.2">Some of these variables are implicitly used as default during compilation and linking. </span><span class="koboSpan" id="kobo.338.3">It is common practice to define the toolchain prefix using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">CROSS_COMPILE</span></strong><span class="koboSpan" id="kobo.340.1"> variable and use that as a prefix for the tools involved in the </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">build process:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.342.1">
CROSS_COMPILE=arm-none-eabi-
CC=$(CROSS_COMPILE)gcc
LD=$(CROSS_COMPILE)ld
OBJCOPY=$(CROSS_COMPILE)objcopy</span></pre>
<p><span class="koboSpan" id="kobo.343.1">Changing the default cross compiler for this project can be done by running </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">make</span></strong><span class="koboSpan" id="kobo.345.1"> and assigning a different value to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">CROSS_COMPILE</span></strong><span class="koboSpan" id="kobo.347.1"> environment variable. </span><span class="koboSpan" id="kobo.347.2">All the names of the tools are prefixed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">CROSS_COMPILE</span></strong><span class="koboSpan" id="kobo.349.1"> variable expansion so that the build steps will use the components from the given toolchain. </span><span class="koboSpan" id="kobo.349.2">In the same way, we can define our </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.350.1">default</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.351.1"> flags for the compiler and </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">the linker:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.353.1">
CFLAGS=-mcpu=cortex-m3 -mthumb -g -ggdb -Wall -Wno-main
LDFLAGS=-T target.ld -gc-sections -nostdlib -Map=image.map</span></pre>
<p><span class="koboSpan" id="kobo.354.1">When invoked with no arguments, Make builds the first target defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">image.bin</span></strong><span class="koboSpan" id="kobo.356.1"> makefile. </span><span class="koboSpan" id="kobo.356.2">A new target for </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">image.bin</span></strong><span class="koboSpan" id="kobo.358.1"> can be defined </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.360.1">
image.bin: image.elf
 $(OBJCOPY) -O binary $^ $@</span></pre>
<p><span class="koboSpan" id="kobo.361.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">$@</span></strong><span class="koboSpan" id="kobo.363.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">$^</span></strong><span class="koboSpan" id="kobo.365.1"> variables will be replaced in the recipe with the target and the list of dependencies, respectively. </span><span class="koboSpan" id="kobo.365.2">This means that, in the example, the makefile will process the recipe </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.367.1">
arm-none-eabi-objcopy -O binary image.elf image.bin</span></pre>
<p><span class="koboSpan" id="kobo.368.1">This is the command we need to produce a raw binary image from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">elf</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.371.1"> executable.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">Similarly, we can define the recipe for </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">image.elf</span></strong><span class="koboSpan" id="kobo.374.1">, which is the linking step, depending on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">startup.o</span></strong><span class="koboSpan" id="kobo.376.1"> compiled object file, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">linker script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.378.1">
image.elf: startup.o target.ld
 $(LD) $(LDFLAGS) startup.o -o $@</span></pre>
<p><span class="koboSpan" id="kobo.379.1">In this case, we are not going to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">$^</span></strong><span class="koboSpan" id="kobo.381.1"> variable for the list of dependencies, as the recipe includes the linker script in the linker command line using </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">LDFLAGS</span></strong><span class="koboSpan" id="kobo.383.1">. </span><span class="koboSpan" id="kobo.383.2">The recipe for the linking step will be expanded by </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">main</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.385.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.386.1">
arm-none-eabi-ld -T target.ld -gc-sections -nostdlib -Map=image.map startup.o -o image.elf</span></pre>
<p><span class="koboSpan" id="kobo.387.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">-nostdlib</span></strong><span class="koboSpan" id="kobo.389.1"> ensures that no default C libraries are linked automatically to the project, among those available in the toolchain, that would, by default, be linked in to produce the executables. </span><span class="koboSpan" id="kobo.389.2">This ensures that no symbols are </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">automatically pulled.</span></span></p>
<p><span class="koboSpan" id="kobo.391.1">The last step for resolving dependencies is compiling the source code into the object file. </span><span class="koboSpan" id="kobo.391.2">This is done in a makefile implicit recipe that eventually gets translated to the following when using the project </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">default values:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.393.1">
arm-none-eabi-gcc -c -o startup.o startup.c -mcpu=cortex-m3 -mthumb -g -ggdb -Wall -Wno-main</span></pre>
<p><span class="koboSpan" id="kobo.394.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">-mcpu=cortex-m3</span></strong><span class="koboSpan" id="kobo.396.1"> flag ensures that the code produced is compatible with Cortex-M targets from Cortex-M3 onward. </span><span class="koboSpan" id="kobo.396.2">The same binary can, in fact, eventually be run on any Cortex-M3, M4, or M7 target, and it is generic until we do not decide to use any CPU-specific feature, or define hardware interrupt handlers, as the order of those depends on the </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">specific microcontroller.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">By defining a </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">clean</span></strong><span class="koboSpan" id="kobo.400.1"> target, at any point in time, it is possible to start over from a clean slate, by removing the intermediate targets and the final image and running </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">make</span></strong><span class="koboSpan" id="kobo.402.1"> again. </span><span class="koboSpan" id="kobo.402.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">clean</span></strong><span class="koboSpan" id="kobo.404.1"> target is also often included in the same makefile. </span><span class="koboSpan" id="kobo.404.2">In our example, it looks </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.406.1">
clean:
 rm -f image.bin image.elf *.o image.map</span></pre>
<p><span class="koboSpan" id="kobo.407.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">clean</span></strong><span class="koboSpan" id="kobo.409.1"> target </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.410.1">usually </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.411.1">has no dependencies. </span><span class="koboSpan" id="kobo.411.2">Running </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">make clean</span></strong><span class="koboSpan" id="kobo.413.1"> removes all the intermediate and final targets as instructed in the recipe, leaving the sources an</span><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.414.1">d the linker </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">script untouched.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.416.1">Running the application</span></h2>
<p><span class="koboSpan" id="kobo.417.1">Once the</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.418.1"> image is built, we can run it on a real target or using </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">qemu-system-arm</span></strong><span class="koboSpan" id="kobo.420.1">, as explained in </span><a href="B18730_02.xhtml#_idTextAnchor055"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.421.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.422.1">, </span><em class="italic"><span class="koboSpan" id="kobo.423.1">Work Environment and Workflow Optimization</span></em><span class="koboSpan" id="kobo.424.1">. </span><span class="koboSpan" id="kobo.424.2">Since the application will produce no output while running on the emulator, to investigate more about the actual behavior of the software, we need to attach a debugger to it. </span><span class="koboSpan" id="kobo.424.3">When running the emulator, </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">qemu-system-arm</span></strong><span class="koboSpan" id="kobo.426.1"> must be invoked with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">-S</span></strong><span class="koboSpan" id="kobo.428.1"> option, meaning stop, so that it will not start the execution until the debugger is connected. </span><span class="koboSpan" id="kobo.428.2">Since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">CFLAGS</span></strong><span class="koboSpan" id="kobo.430.1"> variable in the previous step contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">-g</span></strong><span class="koboSpan" id="kobo.432.1"> option, all the symbol names will be kept in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">.elf</span></strong><span class="koboSpan" id="kobo.434.1"> executable so that the debugger can follow the execution through the code line by line, placing breakpoints and checking the values for </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">the variables.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">Following the procedures step by step and comparing addresses and values with those in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">.map</span></strong><span class="koboSpan" id="kobo.438.1"> files</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.439.1"> can be helpful in understanding what is happening and how the context changes t</span><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.440.1">hrough the entire </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">boot sequence.</span></span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.442.1">Multiple boot stages</span></h1>
<p><span class="koboSpan" id="kobo.443.1">Booting a target</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.444.1"> through a bootloader is useful in several cases. </span><span class="koboSpan" id="kobo.444.2">In a real-life scenario, being able to update the running software on devices in a remote location means that developers are able to fix bugs and introduce new features after the first version of the embedded system has </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">been deployed.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">This represents a huge advantage for maintenance when a bug is discovered in the field, or when the software has to be re-engineered to adapt to changes in requirements. </span><span class="koboSpan" id="kobo.446.2">Bootloaders may implement automatic remote upgrades and other useful features, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.448.1">Loading of the application image from an </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">external storage</span></span></li>
<li><span class="koboSpan" id="kobo.450.1">Verification of the integrity of the application image </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">before boot</span></span></li>
<li><span class="koboSpan" id="kobo.452.1">Failover mechanisms in case of a </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">corrupted application</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.454.1">Multiple bootloaders can be chained to perform a multiple-stage boot sequence. </span><span class="koboSpan" id="kobo.454.2">This allows you to have separate software images for the multiple boot stages, which can be uploaded to the flash independently. </span><span class="koboSpan" id="kobo.454.3">A first-stage boot, when present, is usually very simple and used to simply select the entry point for the next stage. </span><span class="koboSpan" id="kobo.454.4">However, in some cases, early stages benefit from slightly more complex designs to implement software upgrade mechanisms or other features. </span><span class="koboSpan" id="kobo.454.5">The example proposed here shows the separation between two boot stages, achieved using the functionalities available in many Cortex-M processors. </span><span class="koboSpan" id="kobo.454.6">The only purpose of this simple bootloader is to initialize the system for </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.455.1">booting </span><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.456.1">the application in the </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">next stage.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.458.1">Bootloader</span></h2>
<p><span class="koboSpan" id="kobo.459.1">The first-stage</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.460.1"> bootloader starts up as a normal standalone </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.461.1">application. </span><span class="koboSpan" id="kobo.461.2">Its IV must be located at the beginning of the flash, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">reset</span></strong><span class="koboSpan" id="kobo.463.1"> handler initializes the associated </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">.data</span></strong><span class="koboSpan" id="kobo.465.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">.bss</span></strong><span class="koboSpan" id="kobo.467.1"> memory sections, like in a normal single-stage boot. </span><span class="koboSpan" id="kobo.467.2">A partition at the beginning of the flash should be reserved for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">.text</span></strong><span class="koboSpan" id="kobo.469.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">.data</span></strong><span class="koboSpan" id="kobo.471.1"> bootloader sections. </span><span class="koboSpan" id="kobo.471.2">To do so, the linker script for the bootloader will only include the beginning of the flash memory, and that of the application will have an offset of the </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">same size.</span></span></p>
<p><span class="koboSpan" id="kobo.473.1">The bootloader and the application will, in fact, be built into two separate binaries. </span><span class="koboSpan" id="kobo.473.2">This way, the two linker scripts can have the same name for sections, and differ only by the description of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">FLASH</span></strong><span class="koboSpan" id="kobo.475.1"> partition in the linker memory. </span><span class="koboSpan" id="kobo.475.2">Nevertheless, the method suggested next is only one of the possible configurations: a more complex setup may benefit from exporting the full geometry using the start addresses and sizes of all </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">the partitions.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">If we want to reserve 4 KB for the bootloader partition, we can hardcode the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">FLASH</span></strong><span class="koboSpan" id="kobo.479.1"> area in the bootloader linker script </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.481.1">
FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 0x00001000</span></pre>
<p><span class="koboSpan" id="kobo.482.1">Similarly, the linker script of the application has an offset in the origin, hardcoded to the size of the bootloader, so that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">.text</span></strong><span class="koboSpan" id="kobo.484.1"> output section of the application always starts at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">0x1000</span></strong><span class="koboSpan" id="kobo.486.1"> address. </span><span class="koboSpan" id="kobo.486.2">From the application point of view, the whole </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">FLASH</span></strong><span class="koboSpan" id="kobo.488.1"> area starts from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">0x00001000</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.490.1"> address:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.491.1">
FLASH (rx) : ORIGIN = 0x00001000, LENGTH = 0x0003F000</span></pre>
<p><span class="koboSpan" id="kobo.492.1">The geometry of the flash, in this case, would be </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.494.1"><img alt="Figure 4.3 – Layout of the flash content, showing the sections of both ﻿the bootloader and the application" src="image/B18730_04_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.495.1">Figure 4.3 – Layout of the flash content, showing the sections of both the bootloader and the application</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.496.1">Bootloader</span></strong><span class="koboSpan" id="kobo.497.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.498.1">Application</span></strong><span class="koboSpan" id="kobo.499.1"> run </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.500.1">separate code and can define their own IV based on the handler that will be used in the respective stage. </span><span class="koboSpan" id="kobo.500.2">The simplest example of a working bootloader can be realized by hardcoding the address of the application and jumping to the entry point, being the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">reset</span></strong><span class="koboSpan" id="kobo.502.1"> handler in the IV of the application stored with offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">4</span></strong><span class="koboSpan" id="kobo.504.1"> inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">vector table.</span></span></p>
<p><span class="koboSpan" id="kobo.506.1">The application may enforce its own memory layout. </span><span class="koboSpan" id="kobo.506.2">At startup, it will be able to initialize the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">.data</span></strong><span class="koboSpan" id="kobo.508.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">.bss</span></strong><span class="koboSpan" id="kobo.510.1"> sections according to the new geometry and even define a new initial stack pointer and IV. </span><span class="koboSpan" id="kobo.510.2">The bootloader can obtain these two pointers by reading the first two words of the IV stored at </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">address </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">0x1000</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.514.1">
uint32_t app_end_stack = (*((uint32_t *)(APP_OFFSET)));
void (* app_entry)(void);
app_entry = (void *)(*((uint32_t *)(APP_OFFSET + 4)));</span></pre>
<p><span class="koboSpan" id="kobo.515.1">Before jumping to the entry point of the application, we want to reset the main execution stack pointer to the end address of the stack. </span><span class="koboSpan" id="kobo.515.2">Since MSP is a special-purpose CPU register in</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.516.1"> the ARMv7-M architecture, it can only be written using the</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.517.1"> assembly instruction </span><strong class="bold"><span class="koboSpan" id="kobo.518.1">move special from register</span></strong><span class="koboSpan" id="kobo.519.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.520.1">msr</span></strong><span class="koboSpan" id="kobo.521.1">). </span><span class="koboSpan" id="kobo.521.2">The</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.522.1"> following code is inlined in the bootloader to set the correct application stack pointer to the value stored in flash at the beginning of the </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">application image:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.524.1">
asm volatile("msr msp, %0" ::"r"(app_end_stack));</span></pre>
<p><span class="koboSpan" id="kobo.525.1">In Cortex-M3 and other, more powerful, 32-bit Cortex-M CPUs, a control register is present within the system control block area, which can be used to specify an offset for the vector table at runtime. </span><span class="koboSpan" id="kobo.525.2">This is </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.526.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.527.1">Vector Table Offset Register</span></strong><span class="koboSpan" id="kobo.528.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.529.1">VTOR</span></strong><span class="koboSpan" id="kobo.530.1">), which is located at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">0xE000ED08</span></strong><span class="koboSpan" id="kobo.532.1">. </span><span class="koboSpan" id="kobo.532.2">Writing the application offset to this register means that, from that moment, the new IV is in place, and the interrupt handlers defined in the application will be executed </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">upon exceptions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
uint32_t * VTOR = (uint32_t *)0xE000ED08;
*VTOR = (uint32_t *)(APP_OFFSET);</span></pre>
<p><span class="koboSpan" id="kobo.535.1">When this mechanism is not available, like in Cortex-M0 microcontrollers, which do not have a VTOR, the application will still share the interrupt vector with the bootloader after it is started. </span><span class="koboSpan" id="kobo.535.2">To provide a different set of interrupt handlers, the relevant function pointers can be stored in a different area of the flash, and the bootloader can check whether the application had been started or not at every interrupt, and in case it was, call the respective handler from the table in the </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">application space.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">When handling pointers to interrupt handlers and other exception routines, it is important to consider that an exception can occur at any time while running the code, especially if the bootloader has enabled peripherals or activated timers in the CPU. </span><span class="koboSpan" id="kobo.537.2">To prevent unpredictable jumps to interrupt routine, it is advisable to disable all the interrupts while the pointers are </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">being updated.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">The instruction set provides mechanisms to temporarily mask all the interrupts. </span><span class="koboSpan" id="kobo.539.2">While running with the interrupt globally disabled, the execution cannot be interrupted by any exception, excluding NMI. </span><span class="koboSpan" id="kobo.539.3">In Cortex-M, interrupts can be temporarily disabled by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">cpsid i</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.541.1">assembly statement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.542.1">
asm volatile ("cpsid i");</span></pre>
<p><span class="koboSpan" id="kobo.543.1">To enable the interrupt again, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">cpsie i</span></strong><span class="koboSpan" id="kobo.545.1"> instruction </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">is used:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.547.1">
asm volatile ("cpsie i");</span></pre>
<p><span class="koboSpan" id="kobo.548.1">Running code with interrupts disabled should be done as much as strictly necessary, and not done only in special cases where other solutions are not available because it impacts the latency of the entire system. </span><span class="koboSpan" id="kobo.548.2">In this special case, it is used to ensure that no service routines are invoked while the IV is </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">being relocated.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">The last action performed by the bootloader in its short life is a direct jump to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">reset</span></strong><span class="koboSpan" id="kobo.552.1"> handler in the application IV. </span><span class="koboSpan" id="kobo.552.2">Since the function will never return, and a brand-new stack space has been just allocated, we force an unconditional jump by setting the value CPU program counter register to start executing from the address of </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">app_entry</span></strong><span class="koboSpan" id="kobo.554.1">, which is pointed to </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">isr_reset</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.558.1">
asm volatile("mov pc, %0" :: "r"(app_entry));</span></pre>
<p><span class="koboSpan" id="kobo.559.1">In our</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.560.1"> example, this</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.561.1"> function will never return, since we replaced the execution stack pointer value. </span><span class="koboSpan" id="kobo.561.2">This is compatible with the behavior foreseen by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">reset</span></strong><span class="koboSpan" id="kobo.563.1"> handler, which will, in turn, jum</span><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.564.1">p to the main function in </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">the application.</span></span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.566.1">Building the image</span></h2>
<p><span class="koboSpan" id="kobo.567.1">Since the two</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.568.1"> executables will be built in separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">.elf</span></strong><span class="koboSpan" id="kobo.570.1"> files, there are mechanisms to join the content of the two partitions together into a single image, to upload to the target, or to use in the emulator. </span><span class="koboSpan" id="kobo.570.2">The bootloader partition can be filled with zeros up to its size by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">--pad-to</span></strong><span class="koboSpan" id="kobo.572.1"> option of </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">objcopy</span></strong><span class="koboSpan" id="kobo.574.1"> when converting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">.elf</span></strong><span class="koboSpan" id="kobo.576.1"> executable into the binary image. </span><span class="koboSpan" id="kobo.576.2">Wearing the flash can be reduced by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">0xFF</span></strong><span class="koboSpan" id="kobo.578.1"> value to fill the padding area, which can be obtained by passing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">--gap-</span></strong><span class="koboSpan" id="kobo.580.1"> option </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">fill=0xFF</span></strong><span class="koboSpan" id="kobo.582.1">. </span><span class="koboSpan" id="kobo.582.2">The resultant image  </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">bootloader.bin</span></strong><span class="koboSpan" id="kobo.584.1"> will be exactly </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">4096</span></strong><span class="koboSpan" id="kobo.586.1"> bytes so that the application image can be concatenated at the end of it. </span><span class="koboSpan" id="kobo.586.2">The steps to compose an image containing the two partitions are </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.588.1">
$ arm-none-eabi-objcopy -O binary --pad-to=4096 --gap-fill=0xFF bootloader.elf bootloader.bin
$ arm-none-eabi-objcopy -O binary app.elf app.bin
$ cat bootloader.bin app.bin &gt; image.bin</span></pre>
<p><span class="koboSpan" id="kobo.589.1">Looking at the resultant </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">image.bin</span></strong><span class="koboSpan" id="kobo.591.1"> file with a hexadecimal editor, it should be possible to identify the end of the bootloader within the first partition by recognizing the zero pattern that is used by </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">objdump</span></strong><span class="koboSpan" id="kobo.593.1"> as padding, and the application code starting at </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">address </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">0x1000</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.597.1">By aligning the application offset to the start of a physical page in flash instead, it is even possible to upload the two images in separate steps, allowing you, for instance, to upgrade the application code, </span><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.598.1">leaving the bootloader </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">partition untouched.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.600.1">Debugging a multi-stage system</span></h2>
<p><span class="koboSpan" id="kobo.601.1">The separation </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.602.1">between two or more stages implies</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.603.1"> that the symbols of the two executables are linked into different </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">.elf</span></strong><span class="koboSpan" id="kobo.605.1"> files. </span><span class="koboSpan" id="kobo.605.2">Debugging using both sets of symbols is still possible, but the symbols from both </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">.elf</span></strong><span class="koboSpan" id="kobo.607.1"> files must be loaded in the debugger in two steps. </span><span class="koboSpan" id="kobo.607.2">When the debugger is executed using the symbols from the bootloader, by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">bootloader.elf</span></strong><span class="koboSpan" id="kobo.609.1"> file as an argument, or using the file command from the GDB command line, the symbols of the bootloader are loaded in the symbol table for the debugging session. </span><span class="koboSpan" id="kobo.609.2">To add the symbols from the application </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">.elf</span></strong><span class="koboSpan" id="kobo.611.1"> file, we can add the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">.elf</span></strong><span class="koboSpan" id="kobo.613.1"> at a later stage </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">add-symbol-file</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.617.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">add-symbol-file</span></strong><span class="koboSpan" id="kobo.619.1"> directive, unlike </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">file</span></strong><span class="koboSpan" id="kobo.621.1">, ensures that the symbols of a second executable are loaded without overwriting the ones previously loaded and allows you to specify the address where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">.text</span></strong><span class="koboSpan" id="kobo.623.1"> section starts. </span><span class="koboSpan" id="kobo.623.2">In the system composed in this example, there is no clash between the two sets of symbols, as the two partitions do not share any area on the flash. </span><span class="koboSpan" id="kobo.623.3">The debugger can continue the execution normally and still have all the symbols available after the bootloader jumps to the application </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">entry point:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.625.1">&gt; add-symbol-file app.elf</span></strong><span class="koboSpan" id="kobo.626.1">
add symbol table from file "app.elf"(y or n) y
Reading symbols from app.elf...done.</span></pre>
<p><span class="koboSpan" id="kobo.627.1">Sharing the same names for sections and symbols between the two executables is legal, as the two executables are self-contained and not linked together. </span><span class="koboSpan" id="kobo.627.2">The debugger is aware of duplicate names when we refer to a symbol by its name during debugging. </span><span class="koboSpan" id="kobo.627.3">For example, if we place a breakpoint on </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">main</span></strong><span class="koboSpan" id="kobo.629.1"> and we have correctly loaded the symbols from both</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.630.1"> executables, the breakpoint will</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.631.1"> be set on </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">both locations:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.633.1">&gt; b main</span></strong><span class="koboSpan" id="kobo.634.1">
Breakpoint 1 at 0x14e: main. </span><span class="koboSpan" id="kobo.634.2">(2 locations)
</span><strong class="bold"><span class="koboSpan" id="kobo.635.1">&gt; info b</span></strong><span class="koboSpan" id="kobo.636.1">
Num Type Disp Enb Address What
1 breakpoint keep y &lt;MULTIPLE&gt;
1.1 y 0x0000014e in main at startup_bl.c:53
1.2 y 0x00001158 in main at startup.c:53</span></pre>
<p><span class="koboSpan" id="kobo.637.1">Separate boot stages are completely isolated from each other and do not share any executable code. </span><span class="koboSpan" id="kobo.637.2">For this reason, software distributed with different licenses, even if not compatible with each other, can run in separate boot stages. </span><span class="koboSpan" id="kobo.637.3">As seen in the example, the two software images can use the same symbol names without creating conflicts, as they would have been running on two </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">separate systems.</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">In some cases, however, multiple boot stages may have functionalities in common that can be implemented using the same library. </span><span class="koboSpan" id="kobo.639.2">Unfortunately, there is no simple way to access the symbols of the library from separate software images. </span><span class="koboSpan" id="kobo.639.3">The mechanism described in the next example provides access to shared libraries between the two stages by </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.640.1">st</span><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.641.1">oring the symbols needed only </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.642.1">once in </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">the flash.</span></span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.644.1">Shared libraries</span></h2>
<p><span class="koboSpan" id="kobo.645.1">Suppose that there</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.646.1"> is a small library providing general-purpose</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.647.1"> utilities or device drivers, which is in use by both the bootloader and the application. </span><span class="koboSpan" id="kobo.647.2">Even when the footprint is small, it is preferable not to have duplicate definitions of the same functions in the flash memory. </span><span class="koboSpan" id="kobo.647.3">The library can instead be linked in a dedicated section of the bootloader and referred to in a later stage. </span><span class="koboSpan" id="kobo.647.4">In our preceding two-stage example, we can safely place the API function pointers in an array starting at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">0x400</span></strong><span class="koboSpan" id="kobo.649.1">, which is past the end of the interrupt vector we are currently using. </span><span class="koboSpan" id="kobo.649.2">In a real project, the offset must be high enough to be after the actual vector table in memory. </span><span class="koboSpan" id="kobo.649.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">.utils</span></strong><span class="koboSpan" id="kobo.651.1"> input section is placed in the linker script in between the vector table and the start of </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">.text</span></strong><span class="koboSpan" id="kobo.653.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">the bootloader:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.655.1">
.text :
{
  _start_text = .;
  KEEP(*(.isr_vector))
  . </span><span class="koboSpan" id="kobo.655.2">= 0x400;
  KEEP(*(.utils))
  *(.text*)
  *(.rodata*)
  . </span><span class="koboSpan" id="kobo.655.3">= ALIGN(4);
  _end_text = .;
} &gt; FLASH</span></pre>
<p><span class="koboSpan" id="kobo.656.1">The actual function definitions can be placed in a different source file and linked in the bootloader. </span><span class="koboSpan" id="kobo.656.2">What is actually in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">.utils</span></strong><span class="koboSpan" id="kobo.658.1"> section is a table containing the pointers to the actual address of the functions inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">.text</span></strong><span class="koboSpan" id="kobo.660.1"> bootloader </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">output section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.662.1">
__attribute__((section(".utils"),used))
 static void *utils_interface[4] = {
   (void *)(utils_open),
   (void *)(utils_write),
   (void *)(utils_read),
   (void *)(utils_close)
};</span></pre>
<p><span class="koboSpan" id="kobo.663.1">The layout of the bootloader now has this extra </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">.utils</span></strong><span class="koboSpan" id="kobo.665.1"> section, aligned at address </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">0x400</span></strong><span class="koboSpan" id="kobo.667.1">, containing a table with the pointers to the library functions that are meant to be exported for use from </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">other stages:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.669.1"><img alt="Figure 4.4 – Bootloader partition with the .utils section" src="image/B18730_04_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.670.1">Figure 4.4 – Bootloader partition with the .utils section</span></p>
<p><span class="koboSpan" id="kobo.671.1">The application expects to find the function table at the </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">given address:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.673.1">
static void **utils_interface = (void**)(0x00000400);</span></pre>
<p><span class="koboSpan" id="kobo.674.1">The address of</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.675.1"> the </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.676.1">single functions that have been stored in the bootloader is now available, but there is no information about the signature of these functions. </span><span class="koboSpan" id="kobo.676.2">For this reason, the application can only access the API properly if the pointers are converted to match the expected function signature. </span><span class="koboSpan" id="kobo.676.3">An inline wrapper can then be provided so that the application code can access the </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">function directly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.678.1">
static inline int utils_read(void *buf, int size) {
  int (*do_read)(void*, int) = (int (*)(void*,int))
    (utils_interface[2]);
  return do_read(buf, size);
}</span></pre>
<p><span class="koboSpan" id="kobo.679.1">In this case, the contract is implicitly shared between the two modules, and the correspondence between the function signatures is not checked at compile time, nor is the validity of the function pointer stored in flash. </span><span class="koboSpan" id="kobo.679.2">On the other hand, it is a valid approach to avoid binary code duplication and might be an effective way to reduce flash usage by</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.680.1"> sharing</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.681.1"> symbols across </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">separate contexts.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.683.1">Remote firmware updates</span></h2>
<p><span class="koboSpan" id="kobo.684.1">One of the </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.685.1">reasons to include a bootloader in an embedded system design is often to provide a mechanism to update the running application from a remote location. </span><span class="koboSpan" id="kobo.685.2">As mentioned in the previous chapter, a reliable update mechanism is often a critical requirement for vulnerability management. </span><span class="koboSpan" id="kobo.685.3">On rich embedded systems running Linux, bootloaders are often equipped with their own TCP/IP stacks, network device drivers, and protocol-specific implementations to transfer kernel and filesystem updates autonomously. </span><span class="koboSpan" id="kobo.685.4">On smaller embedded systems, it is often convenient to assign this task to the application, which is in most cases already using similar communication channels for other functional purposes. </span><span class="koboSpan" id="kobo.685.5">Once the new firmware has been downloaded and stored in any non-volatile memory support (for example, in a partition at the end of the flash memory), a bootloader could implement a mechanism to install the received update by overwriting the previous firmware in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.686.1">Application</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.687.1"> partition.</span></span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.688.1">Secure boot</span></h2>
<p><span class="koboSpan" id="kobo.689.1">Many projects</span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.690.1"> require a mechanism to prevent the execution of unauthorized or altered firmware that could have been compromised intentionally by an attacker in an attempt to take control of the system. </span><span class="koboSpan" id="kobo.690.2">This is a task for secure bootloaders, which use cryptography to verify the authenticity of a signature calculated on the content of the firmware image on board. </span><span class="koboSpan" id="kobo.690.3">Secure bootloaders implementing such mechanisms rely on a trust anchor to store a public key and require the use of a manifest that must be attached to the firmware image file. </span><span class="koboSpan" id="kobo.690.4">The manifest contains the signature that has been created by the owner of the private key associated with the public key stored in the device. </span><span class="koboSpan" id="kobo.690.5">Cryptographic signature verification is a very effective method to prevent unauthorized firmware updates, both from remote locations and from </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">physical attacks.</span></span></p>
<p><span class="koboSpan" id="kobo.692.1">Implementing a secure bootloader from scratch is a considerable amount of work. </span><span class="koboSpan" id="kobo.692.2">A few open source projects provide a mechanism to sign and verify images using cryptography algorithms. </span><strong class="bold"><span class="koboSpan" id="kobo.693.1">wolfBoot</span></strong><span class="koboSpan" id="kobo.694.1"> is a secure </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.695.1">bootloader providing integrity and authenticity checks of the current firmware and the candidates for update installations. </span><span class="koboSpan" id="kobo.695.2">It provides a fail-safe mechanism to swap the two firmware partitions’ content during the update installation, to provide a backup in case of failed execution of the newly updated image. </span><span class="koboSpan" id="kobo.695.3">The bootloader comes with tools to generate the signature and attach the manifest to the file to be </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.696.1">transferred to the device, and a </span><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.697.1">wide range of configurable options, ciphers, </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">and features.</span></span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.699.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.700.1">Understanding the boot procedure is a key step toward the development of an embedded system. </span><span class="koboSpan" id="kobo.700.2">We have seen how to boot straight into the bare-metal application, and we have examined the structures involved in a multi-stage system boot, such as separate linker scripts with different entry points, the relocation of IVs via CPU registers, and shared code sections </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">across stages.</span></span></p>
<p><span class="koboSpan" id="kobo.702.1">In the next chapter, we will explore mechanisms and approaches for memory management that represent the most important factor to take into account while developing safe and reliable </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">embedded systems.</span></span></p>
</div>
</body></html>