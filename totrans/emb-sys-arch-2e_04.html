<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-86"><a id="_idTextAnchor115"/>4</h1>
<h1 id="_idParaDest-87"><a id="_idTextAnchor116"/>The Boot-Up Procedure</h1>
<p>Now that the mechanisms, tools, and methodologies are in place, it is finally time to start looking at the procedures required to run the software on the target. Booting up an embedded system is a process that often requires knowledge of the specific system and the mechanisms in play. Depending on the target, there are a few indications we need to look for in the manual to find out what the system expects from the developer to successfully boot executables from the flash memory. This chapter will focus on the description of the boot process, with emphasis on the case of the Cortex-M microcontroller, which we decided to use as a reference platform. In particular, we will cover the following topics:</p>
<ul>
<li>The interrupt vector table</li>
<li>Memory layout</li>
<li>Building and running the boot code</li>
<li>Multiple boot stages</li>
</ul>
<p>By the end of this chapter, you will have an overview of main-loop embedded development.</p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor117"/>Technical requirements</h1>
<p>You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter4">https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter4</a>.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor118"/>The interrupt vector table</h1>
<p>The <strong class="bold">interrupt vector table</strong>, often abbreviated to <strong class="bold">IVT</strong> or simply <strong class="bold">IV</strong>, is an array of pointers<a id="_idIndexMarker243"/> to functions associated by the CPU to handle specific <em class="italic">exceptions</em>, such as faults, system service requests from the application, and interrupt requests from peripherals. The IVT is usually located at the beginning of the binary image and thus is stored starting from the lowest address in the flash memory.</p>
<p>An interrupt request from a hardware component or peripheral will force the CPU to abruptly suspend the execution and execute the function at the associated position in the vector. For this reason, these functions are called <strong class="bold">interrupt service routines</strong> (or simply <strong class="bold">ISRs</strong>). Runtime <a id="_idIndexMarker244"/>exceptions and faults can be handled in the same way as hardware interrupts, so special service routines are associated with internal CPU triggers through the same table.</p>
<p>The order of the ISRs enumerated in the vector, and their exact positions depend on the CPU architecture, the microcontroller model, and the peripherals supported. Each interrupt line corresponds to a predefined interrupt number and, depending on the microcontroller features, may be assigned a priority.</p>
<p>In a Cortex-M microcontroller, the first 16 positions in memory are reserved for storing the pointers to system handlers, which are architecture-dependent, and associated to different types of CPU runtime exceptions. The lowest address is used to store the initial value of the stack pointer, and the next 15 positions are reserved for system services and fault handlers. However, some of these positions are reserved and not connected to any event. The <a id="_idIndexMarker245"/>system exceptions that can be handled using separate service routines in a Cortex-M CPU are as follows:</p>
<ul>
<li>Reset</li>
<li><strong class="bold">Non-Maskable </strong><strong class="bold">Interrupt</strong> (<strong class="bold">NMI</strong>)</li>
<li>Hard fault</li>
<li>Memory exception</li>
<li>Bus fault</li>
<li>Usage fault</li>
<li>Supervisor call</li>
<li>Debug monitor event</li>
<li>PendSV call</li>
<li>System tick</li>
</ul>
<p>The order of the hardware interrupts, starting from position 16, depends on the microcontroller configuration and, thus, on the specific silicon model, as the interrupt configuration refers to specific components, interfaces, and external peripheral activities.</p>
<p>A fully populated <a id="_idIndexMarker246"/>vector of external interrupt handlers for STM32F407 and LM3S targets can be found in this book’s code reposito<a id="_idTextAnchor119"/>ry.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor120"/>Startup code</h2>
<p>In order to boot a<a id="_idIndexMarker247"/> workable system, we need to define the interrupt vector and associate pointers with defined functions. A typical startup code file for our reference platform places the interrupt vector in a dedicated section using the GCC <code>section</code> attribute. As the section will be put at the beginning of the image, we must define our interrupt vector starting with the reserved space for the initial stack pointer, followed by the system exception handlers.</p>
<p>The zeros correspond to the positions of the reserved/unused slots:</p>
<pre class="source-code">
__attribute__ ((section(".isr_vector")))
void (* const IV[])(void) =
{
  (void (*)(void))(END_STACK),
  isr_reset,
  isr_nmi,
  isr_hard_fault,
  isr_mem_fault,
  isr_bus_fault,
  isr_usage_fault,
  0, 0, 0, 0,
  isr_svc,
  isr_dbgmon,
  0,
  isr_pendsv,
  isr_systick,</pre>
<p>From this position on, we define the interrupt lines for the external peripherals as follows:</p>
<pre class="source-code">
  isr_uart0,
  isr_ethernet,
  /* … many more external interrupts follow */
};</pre>
<p>The startup code must also include the implementation of every symbol referenced in the array. The handler can be defined as <code>void</code> procedures with no arguments, in the same format as the signature of the IV:</p>
<pre class="source-code">
void isr_bus_fault(void) {
  /* Bus error. Panic! */
  while(1);
}</pre>
<p>The interrupt handler in this example never returns, as a result of an unrecoverable bus error, and hangs <a id="_idIndexMarker248"/>the system forever. Empty interrupt handlers can be associated to both system and external interrupts using weak symbols that can be overridden in the device driver modules by simply defining them again in the relevant code sec<a id="_idTextAnchor121"/>tion.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor122"/>Reset handler</h2>
<p>When the microcontroller is <a id="_idIndexMarker249"/>powered on, it starts the <a id="_idIndexMarker250"/>execution from the <code>reset</code> handler. This is a special ISR that does not return but rather performs initialization of the <code>.data</code> and <code>.bss</code> sections, and then calls the entry point of the application. The initialization of the <code>.data</code> and <code>.bss</code> sections consists of copying the initial value of the variables in the <code>.data</code> section in flash onto the actual section in RAM where variables are accessed at runtime and filling the <code>.bss</code> section in RAM with zeros so that the initial value of static symbols is guaranteed to be zero as per C convention.</p>
<p>The source and destination addresses of the <code>.data</code> and <code>.bss</code> sections in RAM are computed by the linker when generating the binary image and exported as pointers using the linker script. The implementation of <code>isr_reset</code> may look similar to the following:</p>
<pre class="source-code">
void isr_reset(void)
{
  unsigned int *src, *dst;
  src = (unsigned int *) &amp;_stored_data;
  dst = (unsigned int *) &amp;_start_data;
  while (dst != (unsigned int *)&amp;_end_data) {
    *dst = *src;
    dst++;
    src++;
  }
  dst = &amp;_start_bss;
  while (dst != (unsigned int *)&amp;_end_bss) {
    *dst = 0;
    dst++;
  }
  main();
}</pre>
<p>Once the <a id="_idIndexMarker251"/>variables in the <code>.bss</code> and <code>.data</code> sections <a id="_idIndexMarker252"/>have been initialized, it is finally possible to call the <code>main</code> function, which is the entry point of the application. The application code ensures that <code>main</code> never returns by implementing an infin<a id="_idTextAnchor123"/>ite loop.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor124"/>Allocating the stack</h2>
<p>In order to<a id="_idIndexMarker253"/> comply <a id="_idIndexMarker254"/>with the <strong class="bold">application binary interface</strong> (<strong class="bold">ABI</strong>) of the CPU, it is required to assign space in memory for the execution stack. This can be done in different ways, but usually, it is preferable to mark the end of the stack space in the linker script and associate the stack space to a specific area in RAM, not in use by any section.</p>
<p>The address obtained through the <code>END_STACK</code> symbol, exported by the linker script, points to the end of an unused area in RAM. As mentioned earlier, its value must be stored at the beginning of the vector table, at address <code>0</code> in our case, just before the IV. The address of the end of the stack has to be constant and cannot be calculated at runtime because the IV content is stored in the flash memory and thus cannot be modified later on.</p>
<p>Properly sizing the execution stack in memory is a delicate task that includes the assessment of the whole code base, keeping in mind stack usage from local variables and the depth of the call trace at any time during the execution. The analysis of all the factors related to stack usage and troubleshooting will be part of a wider topic that is covered in the next chapter. Our simple startup code provided here has a stack size that is big enough to contain the local variables and the function call stack, as it is mapped by the linker script <a id="_idIndexMarker255"/>as far as possible from the <code>.bss</code> and <code>.data</code> sections. Further aspects of the placement of the stack are considered in <a href="B18730_05.xhtml#_idTextAnchor149"><em class="italic">Chapter 5</em></a>, <em class="italic">Memory<a id="_idTextAnchor125"/> Management</em>.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor126"/>Fault handlers</h2>
<p>Fault-related <a id="_idIndexMarker256"/>events are triggered by the CPU in<a id="_idIndexMarker257"/> the case of execution errors or policy violations. The CPU is able to detect a number of runtime errors, such as the following:</p>
<ul>
<li>Attempting to execute code outside the memory areas marked as executable</li>
<li>Fetching data or the next instruction to execute from an invalid location</li>
<li>Illegal loading or storing using an unaligned address</li>
<li>Division by zero</li>
<li>Trying to access unavailable coprocessor functionalities</li>
<li>Attempting to read/write/execute outside the memory areas allowed for the current running mode</li>
</ul>
<p>Some core microcontrollers support different types of exceptions depending on the type of error. The Cortex-M3/M4 can distinguish between bus errors, usage faults, memory access violations, and generic faults, triggering the related exception. In other, smaller systems, fewer details are available on the type of runtime error.</p>
<p>Very often, a fault will make the system unusable or unable to continue the execution due to the CPU register values or the stack being corrupted. In some cases, even placing a breakpoint inside the exception handler is not sufficient to detect the cause of the problem, making debugging harder. Some CPUs support extended information on the cause of the fault, which is available through memory-mapped registers after the exception occurs. In the case of the Cortex-M3/M4, this information is available through the <code>0xE000ED28</code> on all Cortex-M3/M4 CPUs.</p>
<p>Memory violations may be non-fatal if the corresponding exception handler implements some kind of recovery strategy and can be useful to detect and react to the fault at runtime, which is<a id="_idIndexMarker259"/> especially useful in multithreaded<a id="_idIndexMarker260"/> environments, as we will see in more detail in <a href="B18730_09.xhtml#_idTextAnchor311"><em class="italic">Chapter 9</em></a>, <em class="italic">Distributed Systems and <a id="_idTextAnchor127"/></em><em class="italic">IoT Architecture</em>.</p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor128"/>Memory layout</h1>
<p>The linker<a id="_idIndexMarker261"/> script, as we already know, contains the instructions for the linker on how to assemble the components of an embedded system. More specifically, it describes the sections mapped in memory and how they are deployed into the flash and the RAM of the target, as in the example provided in <a href="B18730_02.xhtml#_idTextAnchor055"><em class="italic">Chapter 2</em></a>, <em class="italic">Work Environment and </em><em class="italic">Workflow Optimization</em>.</p>
<p>In most embedded devices, and in particular our reference platform, the <code>.text</code> output section in the linker script, which contains all the executable code, should also include the special input section dedicated to storing the IV at the very beginning of the executable image.</p>
<p>We integrate the linker script by adding the <code>.isr_vector</code> section at the beginning of the <code>.text</code> output section before the rest of the code:</p>
<pre class="source-code">
.text :
{
  *(.isr_vector)
  *(.text*)
  *(.rodata*)
} &gt; FLASH</pre>
<p>Defining a read-only area in flash, which is dedicated to the vector table, is the only strict requirement for our system to boot up properly, as the address of the <code>isr_reset</code> function is retrieved by the CPU at boot time from the <code>0x04</code> address in memory.</p>
<p>Right after the definition for the text and read-only areas in flash, the linker script should export the value of the current address, which is the beginning of the <code>.data</code> output section stored in flash. This section contains the initial value of all the global and static variables that have been initialized in the code. In the example linker script, the beginning of the <code>.data</code> section is marked by the <code>_stored_data</code> linker script variable, as follows:</p>
<pre class="source-code">
_stored_data = .;</pre>
<p>The data section <a id="_idIndexMarker262"/>will eventually be mapped in RAM, but its initialization is done manually in the <code>isr_reset</code> function by copying the content from flash to the actual region designated to the <code>.data</code> section in RAM. The linker script provides a mechanism to separate<a id="_idIndexMarker263"/> the <code>AT</code> keyword in the definition of the section. If no <code>AT</code> keyword is specified, the LMA is, by default, set to the same address as the VMA. In our case, the VMA of the <code>.data</code> input section is in RAM and exported using the <code>_start_data</code> pointer, which will be used by <code>isr_vector</code> as the destination address when copying the values of the symbols stored from flash. The LMA of <code>.data</code>, though, is located in the flash memory, so we set the LMA address to the <code>_stored_data</code> pointer in flash, while defining the <code>.data</code> output section:</p>
<pre class="source-code">
.data : AT (_stored_data)
{
  _start_data = .;
  *(.data*)
  . = ALIGN(4);
  _end_data = .;
} &gt; RAM</pre>
<p>For <code>.bss</code>, there is no LMA, as no data is stored in the image for this section. When including the <code>.bss</code> output section, its VMA will automatically be set to the end of the <code>.data</code> output section:</p>
<pre class="source-code">
.bss :
{
  _start_bss = .;
  *(.bss*)
  . = ALIGN(4);
  _end_bss = .;
  _end = .;
} &gt; RAM</pre>
<p>Finally, in this design, the <a id="_idIndexMarker265"/>linker is expected to provide the initial value for the execution stack. Using the highest address in memory is a common choice for a single-threaded application, even though, as discussed in the next chapter, this may cause problems in the case of stack overflow. For this example, however, this is an acceptable solution, and we define the <code>END_STACK</code> symbol by adding the following line to the linker script:</p>
<pre class="source-code">
END_STACK = ORIGIN(RAM) + LENGTH(RAM);</pre>
<p>To better understand where each symbol will be placed in memory, variable definitions can be added to the startup file in different places within the code. This way, we can check the locations where the variables are stored in memory when running the executable in the debugger for the first time. Supposing that we have variables stored in both the <code>.data</code> and <code>.bss</code> output sections, the memory layout for the example startup code may look like the following:</p>
<div><div><img alt="Figure 4.1 – Memory layout in the example startup code" src="img/B18730_04_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Memory layout in the example startup code</p>
<p>When the <a id="_idIndexMarker266"/>executable is linked, the symbols are automatically set at compile time to indicate the beginning and the end of each section in memory. In our case, variables indicating the beginning and the end of each section are automatically assigned to the right value, depending on the size of the sections that the linker will include when creating the executable. Since the size of each section is known at compile time, the linker is able to identify those situations where the <code>.text</code> and <code>.data</code> sections do not fit into the flash, and a linker error is generated at the end of the build. Creating a map file is useful for checking the size and the location of each symbol. In our boot-up example code, here is how the <code>.text</code> section appears within the map file:</p>
<pre class="source-code">
.text 0x0000000000000000 0x168
0x0000000000000000 _start_text = .
*(.isr_vector)
.isr_vector 0x0000000000000000 0xf0 startup.o
0x0000000000000000 IV
*(.text*)
.text 0x00000000000000f0 0x78 startup.o
0x00000000000000f0 isr_reset
0x0000000000000134 isr_fault
0x000000000000013a isr_empty
0x0000000000000146 main</pre>
<p>Similarly, we can find the boundaries of each section, exported by the linker script at compile time:</p>
<pre class="source-code">
0x0000000000000000 _start_text = .
0x0000000000000168 _end_text = .
0x0000000020000000 _start_data = .
0x0000000020000004 _end_data = .
0x0000000020000004 _start_bss = .
0x0000000020000328 _end_bss = .
0x0000000020000328 _end = .</pre>
<p>The <code>.rodata</code> input section, which is empty in this minimalist example, is mapped in the flash memory area, in between <code>.text</code> and the data LMA. This is reserved for constant symbols because constants do not have to be mapped in RAM. It is advisable to enforce the <code>const</code> C modifier when defining constant symbols because RAM is often our most precious <a id="_idIndexMarker267"/>resource, and in some cases, even sparing a few bytes of writable memory by moving constant symbols to the flash can make a difference in the project development, as flash memory is usually much bigger, and its usage can be easily dete<a id="_idTextAnchor129"/>rmined at linking time.</p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor130"/>Building and running the boot code</h1>
<p>The example<a id="_idIndexMarker268"/> provided<a id="_idIndexMarker269"/> here is one of the simplest executable images that can be run on the target. To assemble, compile, and link everything together, we can use a simple makefile that automates all the steps and allows us to focus on our software life cycle.</p>
<p>When the image is ready, we can transfer it to the real target or alternatively, <a id="_idTextAnchor131"/>run it using an emulator.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor132"/>The makefile</h2>
<p>A very basic makefile<a id="_idIndexMarker270"/> to build our startup application describes the<a id="_idIndexMarker271"/> final target (<code>image.bin</code>) and the intermediate steps required to build it. Makefile syntax is, in general, very vast, and covering all the functions provided by <strong class="bold">Make</strong> is outside the scope of this book. However, the few concepts explained here should be sufficient to get up and running on automating the build process.</p>
<p>Defining the targets for our makefile, in this case, is quite simple. The <code>startup.c</code> source file, containing the IV, some exception handlers, and the main and the global variables we used in the example, can be compiled and assembled into a <code>startup.o</code> object file. The linker uses the indications provided in the <code>target.ld</code> linker script to deploy the symbols in the correct sections, producing the <code>.elf</code> executable image.</p>
<p>Finally, <code>objcopy</code> is used to transform the <code>.elf</code> executable into a binary image, which can be transferred to the target or run using QEMU:</p>
<div><div><img alt="Figure 4.2 – Build steps and dependencies" src="img/B18730_04_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Build steps and dependencies</p>
<p>The makefile should contain a few configuration variables to describe the toolchain. The <code>=</code> assignment operator allows you to set values for the variables when invoking the <code>make</code> command. Some of these variables are implicitly used as default during compilation and linking. It is common practice to define the toolchain prefix using the <code>CROSS_COMPILE</code> variable and use that as a prefix for the tools involved in the build process:</p>
<pre class="source-code">
CROSS_COMPILE=arm-none-eabi-
CC=$(CROSS_COMPILE)gcc
LD=$(CROSS_COMPILE)ld
OBJCOPY=$(CROSS_COMPILE)objcopy</pre>
<p>Changing the default cross compiler for this project can be done by running <code>make</code> and assigning a different value to the <code>CROSS_COMPILE</code> environment variable. All the names of the tools are prefixed by the <code>CROSS_COMPILE</code> variable expansion so that the build steps will use the components from the given toolchain. In the same way, we can define our <a id="_idIndexMarker272"/>default<a id="_idIndexMarker273"/> flags for the compiler and the linker:</p>
<pre class="source-code">
CFLAGS=-mcpu=cortex-m3 -mthumb -g -ggdb -Wall -Wno-main
LDFLAGS=-T target.ld -gc-sections -nostdlib -Map=image.map</pre>
<p>When invoked with no arguments, Make builds the first target defined in the <code>image.bin</code> makefile. A new target for <code>image.bin</code> can be defined as follows:</p>
<pre class="source-code">
image.bin: image.elf
 $(OBJCOPY) -O binary $^ $@</pre>
<p>The <code>$@</code> and <code>$^</code> variables will be replaced in the recipe with the target and the list of dependencies, respectively. This means that, in the example, the makefile will process the recipe as follows:</p>
<pre class="console">
arm-none-eabi-objcopy -O binary image.elf image.bin</pre>
<p>This is the command we need to produce a raw binary image from the <code>.</code><code>elf</code> executable.</p>
<p>Similarly, we can define the recipe for <code>image.elf</code>, which is the linking step, depending on the <code>startup.o</code> compiled object file, and the linker script:</p>
<pre class="source-code">
image.elf: startup.o target.ld
 $(LD) $(LDFLAGS) startup.o -o $@</pre>
<p>In this case, we are not going to use the <code>$^</code> variable for the list of dependencies, as the recipe includes the linker script in the linker command line using <code>LDFLAGS</code>. The recipe for the linking step will be expanded by <code>main</code> as follows:</p>
<pre class="console">
arm-none-eabi-ld -T target.ld -gc-sections -nostdlib -Map=image.map startup.o -o image.elf</pre>
<p>Using <code>-nostdlib</code> ensures that no default C libraries are linked automatically to the project, among those available in the toolchain, that would, by default, be linked in to produce the executables. This ensures that no symbols are automatically pulled.</p>
<p>The last step for resolving dependencies is compiling the source code into the object file. This is done in a makefile implicit recipe that eventually gets translated to the following when using the project default values:</p>
<pre class="console">
arm-none-eabi-gcc -c -o startup.o startup.c -mcpu=cortex-m3 -mthumb -g -ggdb -Wall -Wno-main</pre>
<p>Using the <code>-mcpu=cortex-m3</code> flag ensures that the code produced is compatible with Cortex-M targets from Cortex-M3 onward. The same binary can, in fact, eventually be run on any Cortex-M3, M4, or M7 target, and it is generic until we do not decide to use any CPU-specific feature, or define hardware interrupt handlers, as the order of those depends on the specific microcontroller.</p>
<p>By defining a <code>clean</code> target, at any point in time, it is possible to start over from a clean slate, by removing the intermediate targets and the final image and running <code>make</code> again. The <code>clean</code> target is also often included in the same makefile. In our example, it looks as follows:</p>
<pre class="source-code">
clean:
 rm -f image.bin image.elf *.o image.map</pre>
<p>The <code>clean</code> target <a id="_idIndexMarker274"/>usually <a id="_idIndexMarker275"/>has no dependencies. Running <code>make clean</code> removes all the intermediate and final targets as instructed in the recipe, leaving the sources an<a id="_idTextAnchor133"/>d the linker script untouched.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor134"/>Running the application</h2>
<p>Once the<a id="_idIndexMarker276"/> image is built, we can run it on a real target or using <code>qemu-system-arm</code>, as explained in <a href="B18730_02.xhtml#_idTextAnchor055"><em class="italic">Chapter 2</em></a>, <em class="italic">Work Environment and Workflow Optimization</em>. Since the application will produce no output while running on the emulator, to investigate more about the actual behavior of the software, we need to attach a debugger to it. When running the emulator, <code>qemu-system-arm</code> must be invoked with the <code>-S</code> option, meaning stop, so that it will not start the execution until the debugger is connected. Since the <code>CFLAGS</code> variable in the previous step contains the <code>-g</code> option, all the symbol names will be kept in the <code>.elf</code> executable so that the debugger can follow the execution through the code line by line, placing breakpoints and checking the values for the variables.</p>
<p>Following the procedures step by step and comparing addresses and values with those in the <code>.map</code> files<a id="_idIndexMarker277"/> can be helpful in understanding what is happening and how the context changes t<a id="_idTextAnchor135"/>hrough the entire boot sequence.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor136"/>Multiple boot stages</h1>
<p>Booting a target<a id="_idIndexMarker278"/> through a bootloader is useful in several cases. In a real-life scenario, being able to update the running software on devices in a remote location means that developers are able to fix bugs and introduce new features after the first version of the embedded system has been deployed.</p>
<p>This represents a huge advantage for maintenance when a bug is discovered in the field, or when the software has to be re-engineered to adapt to changes in requirements. Bootloaders may implement automatic remote upgrades and other useful features, such as the following:</p>
<ul>
<li>Loading of the application image from an external storage</li>
<li>Verification of the integrity of the application image before boot</li>
<li>Failover mechanisms in case of a corrupted application</li>
</ul>
<p>Multiple bootloaders can be chained to perform a multiple-stage boot sequence. This allows you to have separate software images for the multiple boot stages, which can be uploaded to the flash independently. A first-stage boot, when present, is usually very simple and used to simply select the entry point for the next stage. However, in some cases, early stages benefit from slightly more complex designs to implement software upgrade mechanisms or other features. The example proposed here shows the separation between two boot stages, achieved using the functionalities available in many Cortex-M processors. The only purpose of this simple bootloader is to initialize the system for <a id="_idIndexMarker279"/>booting <a id="_idTextAnchor137"/>the application in the next stage.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor138"/>Bootloader</h2>
<p>The first-stage<a id="_idIndexMarker280"/> bootloader starts up as a normal standalone <a id="_idIndexMarker281"/>application. Its IV must be located at the beginning of the flash, and the <code>reset</code> handler initializes the associated <code>.data</code> and <code>.bss</code> memory sections, like in a normal single-stage boot. A partition at the beginning of the flash should be reserved for the <code>.text</code> and <code>.data</code> bootloader sections. To do so, the linker script for the bootloader will only include the beginning of the flash memory, and that of the application will have an offset of the same size.</p>
<p>The bootloader and the application will, in fact, be built into two separate binaries. This way, the two linker scripts can have the same name for sections, and differ only by the description of the <code>FLASH</code> partition in the linker memory. Nevertheless, the method suggested next is only one of the possible configurations: a more complex setup may benefit from exporting the full geometry using the start addresses and sizes of all the partitions.</p>
<p>If we want to reserve 4 KB for the bootloader partition, we can hardcode the <code>FLASH</code> area in the bootloader linker script as follows:</p>
<pre class="source-code">
FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 0x00001000</pre>
<p>Similarly, the linker script of the application has an offset in the origin, hardcoded to the size of the bootloader, so that the <code>.text</code> output section of the application always starts at the <code>0x1000</code> address. From the application point of view, the whole <code>FLASH</code> area starts from the <code>0x00001000</code> address:</p>
<pre class="source-code">
FLASH (rx) : ORIGIN = 0x00001000, LENGTH = 0x0003F000</pre>
<p>The geometry of the flash, in this case, would be the following:</p>
<div><div><img alt="Figure 4.3 – Layout of the flash content, showing the sections of both ﻿the bootloader and the application" src="img/B18730_04_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Layout of the flash content, showing the sections of both the bootloader and the application</p>
<p><code>reset</code> handler in the IV of the application stored with offset <code>4</code> inside the vector table.</p>
<p>The application may enforce its own memory layout. At startup, it will be able to initialize the new <code>.data</code> and <code>.bss</code> sections according to the new geometry and even define a new initial stack pointer and IV. The bootloader can obtain these two pointers by reading the first two words of the IV stored at address <code>0x1000</code>:</p>
<pre class="source-code">
uint32_t app_end_stack = (*((uint32_t *)(APP_OFFSET)));
void (* app_entry)(void);
app_entry = (void *)(*((uint32_t *)(APP_OFFSET + 4)));</pre>
<p>Before jumping to the entry point of the application, we want to reset the main execution stack pointer to the end address of the stack. Since MSP is a special-purpose CPU register in<a id="_idIndexMarker283"/> the ARMv7-M architecture, it can only be written using the<a id="_idIndexMarker284"/> assembly instruction <strong class="bold">move special from register</strong> (<strong class="bold">msr</strong>). The<a id="_idIndexMarker285"/> following code is inlined in the bootloader to set the correct application stack pointer to the value stored in flash at the beginning of the application image:</p>
<pre class="source-code">
asm volatile("msr msp, %0" ::"r"(app_end_stack));</pre>
<p>In Cortex-M3 and other, more powerful, 32-bit Cortex-M CPUs, a control register is present within the system control block area, which can be used to specify an offset for the vector table at runtime. This is <a id="_idIndexMarker286"/>the <code>0xE000ED08</code>. Writing the application offset to this register means that, from that moment, the new IV is in place, and the interrupt handlers defined in the application will be executed upon exceptions:</p>
<pre class="source-code">
uint32_t * VTOR = (uint32_t *)0xE000ED08;
*VTOR = (uint32_t *)(APP_OFFSET);</pre>
<p>When this mechanism is not available, like in Cortex-M0 microcontrollers, which do not have a VTOR, the application will still share the interrupt vector with the bootloader after it is started. To provide a different set of interrupt handlers, the relevant function pointers can be stored in a different area of the flash, and the bootloader can check whether the application had been started or not at every interrupt, and in case it was, call the respective handler from the table in the application space.</p>
<p>When handling pointers to interrupt handlers and other exception routines, it is important to consider that an exception can occur at any time while running the code, especially if the bootloader has enabled peripherals or activated timers in the CPU. To prevent unpredictable jumps to interrupt routine, it is advisable to disable all the interrupts while the pointers are being updated.</p>
<p>The instruction set provides mechanisms to temporarily mask all the interrupts. While running with the interrupt globally disabled, the execution cannot be interrupted by any exception, excluding NMI. In Cortex-M, interrupts can be temporarily disabled by using the <code>cpsid i</code> assembly statement:</p>
<pre class="source-code">
asm volatile ("cpsid i");</pre>
<p>To enable the interrupt again, the <code>cpsie i</code> instruction is used:</p>
<pre class="source-code">
asm volatile ("cpsie i");</pre>
<p>Running code with interrupts disabled should be done as much as strictly necessary, and not done only in special cases where other solutions are not available because it impacts the latency of the entire system. In this special case, it is used to ensure that no service routines are invoked while the IV is being relocated.</p>
<p>The last action performed by the bootloader in its short life is a direct jump to the <code>reset</code> handler in the application IV. Since the function will never return, and a brand-new stack space has been just allocated, we force an unconditional jump by setting the value CPU program counter register to start executing from the address of <code>app_entry</code>, which is pointed to by <code>isr_reset</code>:</p>
<pre class="source-code">
asm volatile("mov pc, %0" :: "r"(app_entry));</pre>
<p>In our<a id="_idIndexMarker287"/> example, this<a id="_idIndexMarker288"/> function will never return, since we replaced the execution stack pointer value. This is compatible with the behavior foreseen by the <code>reset</code> handler, which will, in turn, jum<a id="_idTextAnchor139"/>p to the main function in the application.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor140"/>Building the image</h2>
<p>Since the two<a id="_idIndexMarker289"/> executables will be built in separate <code>.elf</code> files, there are mechanisms to join the content of the two partitions together into a single image, to upload to the target, or to use in the emulator. The bootloader partition can be filled with zeros up to its size by using the <code>--pad-to</code> option of <code>objcopy</code> when converting the <code>.elf</code> executable into the binary image. Wearing the flash can be reduced by using the <code>0xFF</code> value to fill the padding area, which can be obtained by passing the <code>--gap-</code> option <code>fill=0xFF</code>. The resultant image  <code>bootloader.bin</code> will be exactly <code>4096</code> bytes so that the application image can be concatenated at the end of it. The steps to compose an image containing the two partitions are the following:</p>
<pre class="console">
$ arm-none-eabi-objcopy -O binary --pad-to=4096 --gap-fill=0xFF bootloader.elf bootloader.bin
$ arm-none-eabi-objcopy -O binary app.elf app.bin
$ cat bootloader.bin app.bin &gt; image.bin</pre>
<p>Looking at the resultant <code>image.bin</code> file with a hexadecimal editor, it should be possible to identify the end of the bootloader within the first partition by recognizing the zero pattern that is used by <code>objdump</code> as padding, and the application code starting at address <code>0x1000</code>.</p>
<p>By aligning the application offset to the start of a physical page in flash instead, it is even possible to upload the two images in separate steps, allowing you, for instance, to upgrade the application code, <a id="_idTextAnchor141"/>leaving the bootloader partition untouched.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor142"/>Debugging a multi-stage system</h2>
<p>The separation <a id="_idIndexMarker290"/>between two or more stages implies<a id="_idIndexMarker291"/> that the symbols of the two executables are linked into different <code>.elf</code> files. Debugging using both sets of symbols is still possible, but the symbols from both <code>.elf</code> files must be loaded in the debugger in two steps. When the debugger is executed using the symbols from the bootloader, by adding the <code>bootloader.elf</code> file as an argument, or using the file command from the GDB command line, the symbols of the bootloader are loaded in the symbol table for the debugging session. To add the symbols from the application <code>.elf</code> file, we can add the corresponding <code>.elf</code> at a later stage using <code>add-symbol-file</code>.</p>
<p>The <code>add-symbol-file</code> directive, unlike <code>file</code>, ensures that the symbols of a second executable are loaded without overwriting the ones previously loaded and allows you to specify the address where the <code>.text</code> section starts. In the system composed in this example, there is no clash between the two sets of symbols, as the two partitions do not share any area on the flash. The debugger can continue the execution normally and still have all the symbols available after the bootloader jumps to the application entry point:</p>
<pre class="source-code">
<strong class="bold">&gt; add-symbol-file app.elf</strong>
add symbol table from file "app.elf"(y or n) y
Reading symbols from app.elf...done.</pre>
<p>Sharing the same names for sections and symbols between the two executables is legal, as the two executables are self-contained and not linked together. The debugger is aware of duplicate names when we refer to a symbol by its name during debugging. For example, if we place a breakpoint on <code>main</code> and we have correctly loaded the symbols from both<a id="_idIndexMarker292"/> executables, the breakpoint will<a id="_idIndexMarker293"/> be set on both locations:</p>
<pre class="source-code">
<strong class="bold">&gt; b main</strong>
Breakpoint 1 at 0x14e: main. (2 locations)
<strong class="bold">&gt; info b</strong>
Num Type Disp Enb Address What
1 breakpoint keep y &lt;MULTIPLE&gt;
1.1 y 0x0000014e in main at startup_bl.c:53
1.2 y 0x00001158 in main at startup.c:53</pre>
<p>Separate boot stages are completely isolated from each other and do not share any executable code. For this reason, software distributed with different licenses, even if not compatible with each other, can run in separate boot stages. As seen in the example, the two software images can use the same symbol names without creating conflicts, as they would have been running on two separate systems.</p>
<p>In some cases, however, multiple boot stages may have functionalities in common that can be implemented using the same library. Unfortunately, there is no simple way to access the symbols of the library from separate software images. The mechanism described in the next example provides access to shared libraries between the two stages by <a id="_idIndexMarker294"/>st<a id="_idTextAnchor143"/>oring the symbols needed only <a id="_idIndexMarker295"/>once in the flash.</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor144"/>Shared libraries</h2>
<p>Suppose that there<a id="_idIndexMarker296"/> is a small library providing general-purpose<a id="_idIndexMarker297"/> utilities or device drivers, which is in use by both the bootloader and the application. Even when the footprint is small, it is preferable not to have duplicate definitions of the same functions in the flash memory. The library can instead be linked in a dedicated section of the bootloader and referred to in a later stage. In our preceding two-stage example, we can safely place the API function pointers in an array starting at address <code>0x400</code>, which is past the end of the interrupt vector we are currently using. In a real project, the offset must be high enough to be after the actual vector table in memory. The <code>.utils</code> input section is placed in the linker script in between the vector table and the start of <code>.text</code> in the bootloader:</p>
<pre class="source-code">
.text :
{
  _start_text = .;
  KEEP(*(.isr_vector))
  . = 0x400;
  KEEP(*(.utils))
  *(.text*)
  *(.rodata*)
  . = ALIGN(4);
  _end_text = .;
} &gt; FLASH</pre>
<p>The actual function definitions can be placed in a different source file and linked in the bootloader. What is actually in the <code>.utils</code> section is a table containing the pointers to the actual address of the functions inside the <code>.text</code> bootloader output section:</p>
<pre class="source-code">
__attribute__((section(".utils"),used))
 static void *utils_interface[4] = {
   (void *)(utils_open),
   (void *)(utils_write),
   (void *)(utils_read),
   (void *)(utils_close)
};</pre>
<p>The layout of the bootloader now has this extra <code>.utils</code> section, aligned at address <code>0x400</code>, containing a table with the pointers to the library functions that are meant to be exported for use from other stages:</p>
<div><div><img alt="Figure 4.4 – Bootloader partition with the .utils section" src="img/B18730_04_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Bootloader partition with the .utils section</p>
<p>The application expects to find the function table at the given address:</p>
<pre class="source-code">
static void **utils_interface = (void**)(0x00000400);</pre>
<p>The address of<a id="_idIndexMarker298"/> the <a id="_idIndexMarker299"/>single functions that have been stored in the bootloader is now available, but there is no information about the signature of these functions. For this reason, the application can only access the API properly if the pointers are converted to match the expected function signature. An inline wrapper can then be provided so that the application code can access the function directly:</p>
<pre class="source-code">
static inline int utils_read(void *buf, int size) {
  int (*do_read)(void*, int) = (int (*)(void*,int))
    (utils_interface[2]);
  return do_read(buf, size);
}</pre>
<p>In this case, the contract is implicitly shared between the two modules, and the correspondence between the function signatures is not checked at compile time, nor is the validity of the function pointer stored in flash. On the other hand, it is a valid approach to avoid binary code duplication and might be an effective way to reduce flash usage by<a id="_idIndexMarker300"/> sharing<a id="_idIndexMarker301"/> symbols across separate contexts.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor145"/>Remote firmware updates</h2>
<p>One of the <a id="_idIndexMarker302"/>reasons to include a bootloader in an embedded system design is often to provide a mechanism to update the running application from a remote location. As mentioned in the previous chapter, a reliable update mechanism is often a critical requirement for vulnerability management. On rich embedded systems running Linux, bootloaders are often equipped with their own TCP/IP stacks, network device drivers, and protocol-specific implementations to transfer kernel and filesystem updates autonomously. On smaller embedded systems, it is often convenient to assign this task to the application, which is in most cases already using similar communication channels for other functional purposes. Once the new firmware has been downloaded and stored in any non-volatile memory support (for example, in a partition at the end of the flash memory), a bootloader could implement a mechanism to install the received update by overwriting the previous firmware in the <strong class="bold">Application</strong> partition.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor146"/>Secure boot</h2>
<p>Many projects<a id="_idIndexMarker303"/> require a mechanism to prevent the execution of unauthorized or altered firmware that could have been compromised intentionally by an attacker in an attempt to take control of the system. This is a task for secure bootloaders, which use cryptography to verify the authenticity of a signature calculated on the content of the firmware image on board. Secure bootloaders implementing such mechanisms rely on a trust anchor to store a public key and require the use of a manifest that must be attached to the firmware image file. The manifest contains the signature that has been created by the owner of the private key associated with the public key stored in the device. Cryptographic signature verification is a very effective method to prevent unauthorized firmware updates, both from remote locations and from physical attacks.</p>
<p>Implementing a secure bootloader from scratch is a considerable amount of work. A few open source projects provide a mechanism to sign and verify images using cryptography algorithms. <strong class="bold">wolfBoot</strong> is a secure <a id="_idIndexMarker304"/>bootloader providing integrity and authenticity checks of the current firmware and the candidates for update installations. It provides a fail-safe mechanism to swap the two firmware partitions’ content during the update installation, to provide a backup in case of failed execution of the newly updated image. The bootloader comes with tools to generate the signature and attach the manifest to the file to be <a id="_idIndexMarker305"/>transferred to the device, and a <a id="_idTextAnchor147"/>wide range of configurable options, ciphers, and features.</p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor148"/>Summary</h1>
<p>Understanding the boot procedure is a key step toward the development of an embedded system. We have seen how to boot straight into the bare-metal application, and we have examined the structures involved in a multi-stage system boot, such as separate linker scripts with different entry points, the relocation of IVs via CPU registers, and shared code sections across stages.</p>
<p>In the next chapter, we will explore mechanisms and approaches for memory management that represent the most important factor to take into account while developing safe and reliable embedded systems.</p>
</div>
</body></html>