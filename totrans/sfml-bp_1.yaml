- en: Chapter 1. Preparing the Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 准备环境
- en: Through this book, I will try to teach you some elements to build video games
    using the SFML library. Each chapter will cover a different topic, and will require
    knowledge from the previous one.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这本书，我将尝试教你一些使用SFML库构建视频游戏的基本元素。每一章都会涵盖一个不同的主题，并且需要掌握前一章的知识。
- en: 'In this first chapter, we will cover basics points needed for the future such
    as:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍未来所需的基础要点，例如：
- en: Installing a compiler for C++11
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装C++11的编译器
- en: Installing CMake
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装CMake
- en: Installing SFML 2.2
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装SFML 2.2
- en: Building a minimal SFML project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个最小的SFML项目
- en: Before getting started, let's talk about each technology and why we will use
    them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们谈谈每种技术以及为什么我们会使用它们。
- en: C++11
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++11
- en: The C++ programming language is a very powerful tool and has really great performance,
    but it is also really complex, even after years of practice. It allows us to program
    at both a low and high level. It's useful to make some optimizations on our program
    such as having the ability to directly manipulate memory. Building software utilizing
    C++ libraries allows us to work at a higher level and when performance is crucial,
    at a low level. Moreover, the C/C++ compilers are very efficient at optimizing
    code. The result is that, right now, C++ is the most powerful language in terms
    of speed, and thanks to the zero cost abstraction, you are not paying for what
    you don't use, or for the abstraction you are provided.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: C++编程语言是一个非常强大的工具，具有真正出色的性能，但它也非常复杂，即使经过多年的实践也是如此。它允许我们在低级和高级进行编程。它有助于对我们的程序进行一些优化，例如直接操作内存的能力。利用C++库构建软件使我们能够在高级别工作，当性能至关重要时，在低级别工作。此外，C/C++编译器在优化代码方面非常高效。结果是，目前，C++在速度方面是最强大的语言，多亏了零成本抽象，你不会为不使用的内容或提供的抽象付费。
- en: 'I''ll try to use this language in a modern way, using the object-oriented approach.
    Sometimes, I''ll bypass this approach to use the C way for optimizations. So do
    not be shocked to see some "old school code". Moreover, all the main compilers
    now support the standard language released in 2011, so we can use it everywhere
    without any trouble. This version adds some really useful features in the language
    that will be used in this book, such as the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我会尝试以现代的方式使用这种语言，采用面向对象的方法。有时，我会绕过这种方法，使用C语言的方式进行优化。所以，当你看到一些“老式代码”时，请不要感到惊讶。此外，现在所有的主流编译器都支持2011年发布的标准语言，因此我们可以毫无困难地使用它。这个版本在语言中添加了一些非常实用的功能，这些功能将在本书中使用，例如以下内容：
- en: 'Keywords are one such important feature. The following are a few of them:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字是这样一个重要特性。以下是一些例子：
- en: '`auto`: This automatically detects the type of the new variable. It is really
    useful for the instantiation of iterators. The auto keyword already existed in
    the past, but has been deprecated for a long time, and its meaning has now changed.'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto`：这个关键字可以自动检测新变量的类型。对于迭代器的实例化来说，它非常有用。`auto`关键字过去就已经存在，但已经废弃很长时间了，其含义现在已改变。'
- en: '`nullptr`: This is a new keyword introducing a strong type for the old NULL
    value. You can always use NULL, but it''s preferable to use `nullptr`, which is
    any pointer type with 0 as the value.'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr`：这是一个引入旧NULL值强类型的全新关键字。你总是可以使用NULL，但最好使用`nullptr`，它是指针类型，其值为0。'
- en: '`override` and `final`: These two keywords already exist in some languages
    such as Java. These are simple indications not only for the compiler but also
    for the programmer, but don''t specify what they indicate. Don''t hesitate to
    use them. You can take a look to the documentation of them here [http://en.cppreference.com/w/cpp/language/override](http://en.cppreference.com/w/cpp/language/override)
    and [http://en.cppreference.com/w/cpp/language/final](http://en.cppreference.com/w/cpp/language/final).'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override`和`final`：这两个关键字已经存在于一些语言中，如Java。这些关键字不仅对编译器，也对程序员有简单的指示意义，但并不指定它们指示的内容。不要犹豫使用它们。你可以查看它们的文档[http://en.cppreference.com/w/cpp/language/override](http://en.cppreference.com/w/cpp/language/override)和[http://en.cppreference.com/w/cpp/language/final](http://en.cppreference.com/w/cpp/language/final)。'
- en: 'The range-based `for` loops is a new kind of loop in the language `foreach`.
    Moreover, you can use the new `auto` keyword to reduce your code drastically.
    The following syntax is very simple:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于范围的`for`循环是语言`foreach`中的一种新循环类型。此外，你可以使用新的`auto`关键字来大幅度减少你的代码。以下语法非常简单：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, `table` is a container (vector and list) and `var` is a reference
    to the stored variable. Using `&` allows us to modify the variable contained inside
    the table and avoids copies.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，`table` 是一个容器（vector 和 list），而 `var` 是存储变量的引用。使用 `&` 允许我们修改表内包含的变量，并避免复制。
- en: C++11 introduces the smart pointers. There are multiple pointers corresponding
    to their different possible utilizations. Take a look at the official documentation,
    this which is really interesting. The main idea is to manage the memory and delete
    the object created at runtime when no more reference on it exists, so that you
    do not have to delete it yourself or ensure that no double free corruptions are
    made. A smart pointer created on the stack has the advantages of being both fast
    and automatically deleted when the method / code block ends. But it is important
    to know that a strong use of this pointer, more especially `shared_ptr`, will
    reduce the execution speed of your program, so use them carefully.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++11 引入了智能指针。有多个指针对应于它们不同的可能用途。查看官方文档，这真的很有趣。主要思想是管理内存，当没有更多引用时，在运行时删除创建的对象，这样你就不必自己删除它或确保没有发生双重释放损坏。在栈上创建的智能指针具有速度快且在方法/代码块结束时自动删除的优点。但重要的是要知道，对这种指针的强烈使用，尤其是
    `shared_ptr`，会降低程序的执行速度，所以请谨慎使用。
- en: 'The lambda expression or anonymous function is a new type introduced with a
    particular syntax. You can now create functions, for example, as a parameter of
    another function. This is really useful for callback. In the past, functor was
    used to achieve this kind of comportment. An example of functor and lambda is
    as follows:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式或匿名函数是一种引入了特定语法的全新类型。现在，你可以创建函数，例如，将其作为另一个函数的参数。这对于回调来说非常有用。在过去，我们使用函数对象（functor）来实现这种行为。以下是一个函数对象和
    Lambda 的示例：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you already know the use of the variadics function with the ellipse operator
    (`...`), this notion should trouble you, as the usage of it is different. The
    variadics template is just the amelioration of template with any number of parameters
    using the ellipse operator. A good example for this is the tuple class. A tuple
    contains any number of values of any type known at compile time. Without the variadics
    template, it was not really possible to build this class, but now it is really
    easy. By the way, the tuple class was introduced in C++11\. There are several
    other features, such as threads, pair, and so on.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你已经熟悉了使用省略号运算符（`...`）的变长参数函数，那么这个概念可能会让你感到困惑，因为它的用法是不同的。变长模板只是使用省略号运算符对任何数量的参数进行优化的模板。一个很好的例子是元组类。元组可以包含编译时已知的任何类型和数量的值。如果没有变长模板，实际上无法构建此类，但现在这变得非常简单。顺便说一下，元组类是在
    C++11 中引入的。还有其他一些特性，如线程、对等、等等。
- en: SFML
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFML
- en: '**SFML** stands for **Simple and Fast Multimedia Library**. This is a framework
    written in C++ and is based on OpenGL for its graphical rendering part. This name
    describes its aim pretty well, that is, to have a user-friendly interface (API),
    to deliver high performance, and to be as portable as possible. The SFML library
    is divided into five modules, which are compiled in a separated file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**SFML** 代表 **Simple and Fast Multimedia Library**。这是一个用 C++ 编写的框架，其图形渲染部分基于
    OpenGL。这个名字很好地描述了其目标，即拥有一个用户友好的界面（API），提供高性能，并且尽可能便携。SFML 库分为五个模块，这些模块分别编译到单独的文件中：'
- en: '**System**: This is the main module, and is required by all others. It provides
    clocks, threads, and two or three dimensions with all their logics (mathematics
    operations).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统（System）**：这是主要模块，所有其他模块都需要它。它提供了时钟、线程以及所有二维和三维的逻辑（数学运算）。'
- en: '**Window**: This module allows the application to interact with the user by
    managing windows and the inputs from the mouse, keyboard, and joystick.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**窗口（Window）**：此模块允许应用程序通过管理窗口以及来自鼠标、键盘和游戏手柄的输入与用户交互。'
- en: '**Graphics**: This module allows the user to use all the graphical basic elements
    such as textures, shapes, texts, colors, shaders, and more.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形（Graphics）**：此模块允许用户使用所有基本的图形元素，如纹理、形状、文本、颜色、着色器等。'
- en: '**Audio**: This module allows the user to use some sound. Thanks to this, we
    will be able to play some themes, music, and sounds.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频（Audio）**：此模块允许用户使用一些声音。多亏了它，我们将能够播放一些主题、音乐和声音。'
- en: '**Network**: This module manages not only socket and type safe transfers but
    also HTTP and FTP protocols. It''s also very useful to communicate between different
    programs.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**: 此模块不仅管理套接字和类型安全的传输，还管理HTTP和FTP协议。它对于在不同程序之间进行通信也非常有用。'
- en: Each module used by our programs will need to be linked to them at compile time.
    We don't need to link them all if it's not necessary. This book will cover each
    module, but not all the SFML classes. I recommend you take a look at the SFML
    documentation at [http://www.sfml-dev.org/documentation.php](http://www.sfml-dev.org/documentation.php),
    as it's very interesting and complete. Every module and class is well described
    in different sections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序使用的每个模块在编译时都需要与它们链接。如果不需要，我们不需要链接它们。本书将涵盖每个模块，但不会涵盖所有SFML类。我建议您查看SFML文档[http://www.sfml-dev.org/documentation.php](http://www.sfml-dev.org/documentation.php)，因为它非常有趣且内容完整。每个模块和类都在不同的部分中得到了很好的描述。
- en: Now that the main technologies have been presented, let's install all that we
    need to use them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经介绍了主要技术，让我们安装使用它们所需的所有内容。
- en: Installation of a C++11 compiler
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装C++11编译器
- en: As mentioned previously, we will use C++11, so we need a compiler for it. For
    each operating system, there are several options; choose the one you prefer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用C++11，因此我们需要为其安装编译器。对于每个操作系统，都有几个选项；选择您喜欢的。
- en: For Linux users
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于Linux用户
- en: 'If you are a Linux user, you probably already have GCC/G++ installed. In this
    case, check whether your version is 4.8 or later. Otherwise, you can install GCC/G++
    (version 4.8+) or Clang (version 3.4+) using your favorite packet manager. Under
    Debian based distribution (such as Ubuntu and Mint), use the command line:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Linux用户，您可能已经安装了GCC/G++。在这种情况下，请检查您的版本是否为4.8或更高版本。否则，您可以使用您喜欢的包管理器安装GCC/G++（版本4.8+）或Clang（版本3.4+）。在基于Debian的发行版（如Ubuntu和Mint）下，使用以下命令行：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For Mac users
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于Mac用户
- en: If you are a Mac user, you can use Clang (3.4+). This is the default compiler
    under Mac OS X.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Mac用户，您可以使用Clang (3.4+)。这是Mac OS X下的默认编译器。
- en: For Windows users
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于Windows用户
- en: Finally, if you are a Windows user, you can use Visual Studio (2013), Mingw-gcc
    (4.8+), or Clang (3.4+) by downloading them. I suggest you not use Visual Studio,
    because it's not 100 percent standard compliant, even for the C99, and instead
    use another IDE such as Code::Blocks (see the following paragraph).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您是Windows用户，您可以通过下载来使用Visual Studio (2013)、Mingw-gcc (4.8+)或Clang (3.4+)。我建议您不要使用Visual
    Studio，因为它对于C99标准并不完全兼容，而是使用另一个IDE，例如Code::Blocks（见下一段）。
- en: For all users
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于所有用户
- en: I assume that in both cases, you have been able to install a compiler and configure
    your system to use it (by adding it to the system path). If you have not been
    able to do this, another solution is to install an IDE like Code::Blocks, which
    has the advantage of being installed with a default compiler, is compatible with
    C++11, and doesn't require any system configuration.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设在两种情况下，您都已经能够安装编译器并配置系统以使用它（通过将其添加到系统路径）。如果您无法做到这一点，另一种解决方案是安装一个像Code::Blocks这样的IDE，它具有以下优点：默认安装编译器，与C++11兼容，且不需要任何系统配置。
- en: I will choose the IDE option with Code::Blocks for the rest of the book, because
    it does not depend on a specific operating system and everyone will be able to
    navigate. You can download it at [http://www.codeblocks.org/downloads/26](http://www.codeblocks.org/downloads/26).
    The installation is really easy; you just have to follow the wizard.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本书的其余部分选择带有Code::Blocks的IDE选项，因为它不依赖于特定的操作系统，每个人都能导航。您可以在[http://www.codeblocks.org/downloads/26](http://www.codeblocks.org/downloads/26)下载它。安装非常简单；您只需按照向导操作即可。
- en: Installing CMake
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装CMake
- en: CMake is a really useful tool that manages the build process in any operating
    system and in a compiler-independent manner. This configuration is really simple.
    We will need it to build the SFML (if you choose this installation solution) and
    to build all the future projects of this book. Using CMake gives us a cross-platform
    solution. We will need version 2.8 or later of CMake. Currently, the last stable
    version is 3.0.2.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: CMake是一个非常实用的工具，它以编译器无关的方式管理任何操作系统中的构建过程。此配置非常简单。我们将需要它来构建SFML（如果您选择此安装方案）以及构建本书的所有未来项目。使用CMake为我们提供了一个跨平台解决方案。我们需要CMake的2.8或更高版本。目前，最后一个稳定版本是3.0.2。
- en: For Linux users
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于Linux用户
- en: 'If you use a Linux system, you can install CMake and its GUI using your packet
    manager. For example, under Debian, use this command line:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Linux系统，您可以使用包管理器安装CMake及其GUI。例如，在Debian下，使用以下命令行：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For other operating systems
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于其他操作系统
- en: You can download the CMake binary for your system at [http://www.cmake.org/download/](http://www.cmake.org/download/).
    Follow the wizard, and that's it. CMake is now installed and ready to be used.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://www.cmake.org/download/](http://www.cmake.org/download/)下载适合你系统的CMake二进制文件。按照向导操作，然后安装完成。CMake现在已安装并准备好使用。
- en: Installing SFML 2.2
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装SFML 2.2
- en: There are two ways to get the SFML library. The easier way is to download the
    prebuilt version, which can be found at [http://sfml-dev.org/download/sfml/2.2/](http://sfml-dev.org/download/sfml/2.2/),
    but ensure that the version you download is compatible with your compiler.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 获取SFML库有两种方法。更简单的方法是下载预构建版本，可以在[http://sfml-dev.org/download/sfml/2.2/](http://sfml-dev.org/download/sfml/2.2/)找到，但请确保你下载的版本与你的编译器兼容。
- en: The second option is to compile the library yourself. This option is preferable
    to the previous one to avoid any trouble.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是自行编译库。与之前的方法相比，这种方法更可取，可以避免任何麻烦。
- en: Building SFML yourself
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自行编译SFML
- en: Compiling SFML is not as difficult as we might think, and is within the reach
    of everyone. First of all, we will need to install some dependencies.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 编译SFML并不像我们想象的那么困难，对每个人来说都是可行的。首先，我们需要安装一些依赖项。
- en: Installing dependencies
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装依赖项
- en: 'SFML depends on a few libraries. Before starting to compile it, make sure that
    you have all the dependencies installed along with their development files. Here
    is the list of dependencies:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: SFML依赖于几个库。在开始编译之前，请确保你已经安装了所有依赖项及其开发文件。以下是依赖项列表：
- en: '`pthread`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread`'
- en: '`opengl`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opengl`'
- en: '`xlib`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xlib`'
- en: '`xrandr`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xrandr`'
- en: '`freetype`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`freetype`'
- en: '`glew`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glew`'
- en: '`jpeg`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jpeg`'
- en: '`sndfile`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sndfile`'
- en: '`openal`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openal`'
- en: Linux
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux
- en: 'On Linux, we will need to install the development versions of each of these
    libraries. The exact names of the packages depend on each distribution, but here
    is the command line for Debian:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，我们需要安装这些库的开发版本。包的确切名称取决于每个发行版，但这里是为Debian的命令行：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Other operating systems
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他操作系统
- en: On Windows and Mac OS X, all the needed dependencies are provided directly with
    SFML, so you don't have to download or install anything. Compilation will work
    out of the box.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows和Mac OS X上，所有需要的依赖项都直接由SFML提供，因此你不需要下载或安装任何东西。编译将直接完成。
- en: Compilation of SFML
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SFML的编译
- en: 'As mentioned previously, the SFML compilation is really simple. We just need
    to use CMake, by following these steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，SFML的编译过程非常简单。我们只需按照以下步骤使用CMake：
- en: Download the source code at [http://sfml-dev.org/download/sfml/2.2/](http://sfml-dev.org/download/sfml/2.2/)
    and extract it.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[http://sfml-dev.org/download/sfml/2.2/](http://sfml-dev.org/download/sfml/2.2/)下载源代码并解压。
- en: Open CMake and specify the source code directory and the build directory. By
    convention, the build directory is called `build` and is at the root level of
    the source directory.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开CMake，指定源代码目录和构建目录。按照惯例，构建目录称为`build`，位于源目录的根级别。
- en: Press the **Configure** button, and select **Code::Blocks** with the right option
    for your system.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**配置**按钮，并选择适合你系统的**Code::Blocks**。
- en: 'Under Linux, choose **Unix Makefiles**. It should look like this:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Linux下，选择**Unix Makefiles**。它应该看起来像这样：
- en: '![Compilation of SFML](img/8477OS_01_01.jpg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![SFML的编译](img/8477OS_01_01.jpg)'
- en: 'Under Windows, choose **MinGW Makefiles**. It should look like this:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Windows下，选择**MinGW Makefiles**。它应该看起来像这样：
- en: '![Compilation of SFML](img/8477OS_01_02.jpg)'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![SFML的编译](img/8477OS_01_02.jpg)'
- en: And finally, press the **Generate** button. You'll have an output like this:![Compilation
    of SFML](img/8477OS_01_03.jpg)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**生成**按钮。你会得到如下输出：![SFML的编译](img/8477OS_01_03.jpg)
- en: 'Now the Code::Blocks file is built, and can be found in your build directory.
    Open it with Code::Blocks and click on the **Build** button. All the binary files
    will be built and put in the `build/lib` directory. At this point, you have several
    files with an extension that depend on your system. They are as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Code::Blocks文件已构建，可以在你的构建目录中找到。用Code::Blocks打开它，并点击**构建**按钮。所有二进制文件都将构建并放置在`build/lib`目录中。此时，你将有一些依赖于你系统的文件。如下所示：
- en: '`libsfml-system`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libsfml-system`'
- en: '`libsfml-window`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libsfml-window`'
- en: '`libsfml-graphics`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libsfml-graphics`'
- en: '`libsfml-audio`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libsfml-audio`'
- en: '`libsfml-network`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libsfml-network`'
- en: Each file corresponds to a different SFML module that will be needed to run
    our future games.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件对应于一个不同的SFML模块，这些模块将是我们未来游戏运行所需的。
- en: Now it's time to configure our system to be able to find them. All that we need
    to do is add the `build/lib` directory to our system path.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候配置我们的系统以便能够找到它们了。我们所需做的只是将 `build/lib` 目录添加到我们的系统路径中。
- en: Linux
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Linux
- en: 'To compile in Linux, first open a terminal and run the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Linux 中编译，首先打开一个终端并运行以下命令：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following command will install the binary files under `/usr/local/lib/`
    and the headers files in `/usr/local/include/SFML/`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在 `/usr/local/lib/` 下安装二进制文件，并在 `/usr/local/include/SFML/` 中安装头文件：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By default, `/usr/local/` is in your system path, so no more manipulations are
    required.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`/usr/local/` 已在您的系统路径中，因此无需进行更多操作。
- en: Windows
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Windows
- en: 'On Windows, you will need to add to your system path, the `/build/lib/` directory,
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，您需要按照以下方式将 `/build/lib/` 目录添加到您的系统路径中：
- en: Go to the **Advanced** tab in **System Properties**, and click on the **Environment
    Variables** button:![Windows](img/8477OS_01_04.jpg)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **系统属性** 的 **高级** 选项卡中，点击 **环境变量** 按钮：![Windows](img/8477OS_01_04.jpg)
- en: Then, select **Path** in the **System variables** table and click on the **Edit...**
    button:![Windows](img/8477OS_01_05.jpg)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 **系统变量** 表中选中 **路径**，并点击 **编辑...** 按钮：![Windows](img/8477OS_01_05.jpg)
- en: Now edit the **Variable value** input text, add `;C:\your\path\to\SFML-2.2\build\lib`,
    and then validate it by clicking on **OK** in all the open windows:![Windows](img/8477OS_01_06.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编辑 **变量值** 输入文本，添加 `;C:\your\path\to\SFML-2.2\build\lib`，然后通过在所有打开的窗口中点击 **确定**
    来验证它：![Windows](img/8477OS_01_06.jpg)
- en: At this point, your system is configured to find the SFML `dll` modules.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的系统已配置为查找 SFML `dll` 模块。
- en: Code::Blocks and SFML
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Code::Blocks 和 SFML
- en: 'Now that your system is configured to find the SFML binary files, it''s time
    for us to configure Code::Blocks and finally test whether everything is fine with
    your fresh installation. To do so, follow these steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的系统已配置为查找 SFML 二进制文件，是时候配置 Code::Blocks 并最终测试您的全新安装是否一切正常了。为此，请按照以下步骤操作：
- en: Run Code::Blocks, go to **File** | **New** | **Project**, and then choose **Console
    Application**.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Code::Blocks，转到 **文件** | **新建** | **项目**，然后选择 **控制台应用程序**。
- en: Click on **GO**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **GO**。
- en: Choose **C++** as the programming language, and follow the instructions until
    the project is created. A default `main.cpp` file is now created with a typical
    `Hello world` program. Try to build and run it to check whether your compiler
    is correctly detected.![Code::Blocks and SFML](img/8477OS_01_07.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **C++** 作为编程语言，并按照说明操作，直到创建项目。现在已创建一个包含典型 `Hello world` 程序的默认 `main.cpp`
    文件。尝试构建并运行它以检查您的编译器是否正确检测到。![Code::Blocks 和 SFML](img/8477OS_01_07.jpg)
- en: 'If everything works correctly, you will have a new window created that has
    a `Hello world!` message, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，将创建一个新窗口，其中包含 `Hello world!` 消息，如下所示：
- en: '![Code::Blocks and SFML](img/8477OS_01_08.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![Code::Blocks 和 SFML](img/8477OS_01_08.jpg)'
- en: If you have this output, everything is fine. In any other case, make sure you
    have followed all the steps for the installations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到这个输出，那么一切正常。在任何其他情况下，请确保您已遵循所有安装步骤。
- en: 'Now we will configure Code::Blocks to find the SFML library, and ask it to
    link with our program at the end of the compilation. To do this, perform the following
    steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将配置 Code::Blocks 以查找 SFML 库，并在编译结束时将其链接到我们的程序。为此，请执行以下步骤：
- en: Go to **Project** | **Build options** and select your project at the root level
    (not debug or release).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 **项目** | **构建选项** 并在根级别选择您的项目（不是调试或发布）。
- en: Go to **Search directories**. Here we have to add the path where the compiler
    and the linker can find the SFML.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 **搜索目录**。在这里，我们必须添加编译器和链接器可以找到 SFML 的路径。
- en: For the compiler, add your SFML folder.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于编译器，添加您的 SFML 文件夹。
- en: For the linker, add the `build/lib` folder, as follows:![Code::Blocks and SFML](img/8477OS_01_09.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于链接器，添加 `build/lib` 文件夹，如下所示：![Code::Blocks 和 SFML](img/8477OS_01_09.jpg)
- en: 'Now we need to ask the linker which libraries our project needs. All our future
    SFML projects will need the System, Window, and Graphics modules, so we will add
    them:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要让链接器知道我们的项目需要哪些库。我们所有的未来 SFML 项目都需要系统、窗口和图形模块，因此我们将添加它们：
- en: Go to the **Linker settings** tab.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 **链接器设置** 选项卡。
- en: Add `-lsfml-system`, `-lsfml-window` and `-lsfml-graphics` in the **Other linker
    options** column.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **其他链接器选项** 列表中添加 `-lsfml-system`、`-lsfml-window` 和 `-lsfml-graphics`。
- en: Now click on **OK**.![Code::Blocks and SFML](img/8477OS_01_10.jpg)
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击 **确定**。![Code::Blocks 和 SFML](img/8477OS_01_10.jpg)
- en: Good news, all the configurations are now finished. We will eventually need
    to add a library to the linker in the future (audio, network), but that's it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息，所有的配置现在都已经完成。我们最终可能需要在链接器中添加一个库（音频、网络），但仅此而已。
- en: A minimal example
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个最小示例
- en: 'It''s now time for us to test the SFML with a very basic example. This application
    will show us the window as in the following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们用一个非常基本的示例来测试 SFML 的时候了。这个应用程序将展示如下截图中的窗口：
- en: '![A minimal example](img/8477OS_01_11.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![一个最小示例](img/8477OS_01_11.jpg)'
- en: 'The following code snippet brings about this window:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段生成了这个窗口：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All that this application does is to create a window with a width and height
    of 400 pixels and its title is `01_Introduction`. Then a blue circle with a radius
    of 150 pixels is created, and is drawn while the window is open. Finally, the
    user events are checked on each loop. Here we verify if the close event has been
    asked (close the button or click *Alt* + *F4*), or if the user has pressed the
    *Esc* button on his keyboard. In both case, we close the window, that will result
    to the program exit.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序所做的一切就是创建一个宽度和高度为 400 像素的窗口，其标题为 `01_Introduction`。然后创建一个半径为 150 像素的蓝色圆圈，并在窗口打开时绘制。最后，在每次循环中检查用户事件。在这里，我们验证是否请求了关闭事件（关闭按钮或点击
    *Alt* + *F4*），或者用户是否按下了键盘上的 *Esc* 按钮。在两种情况下，我们都会关闭窗口，这将导致程序退出。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we covered which technologies we will use and why to use them.
    We also learned the installation of the C++11 compiler on different environments,
    we learned about installing CMake and how this will help us build the SFML projects
    in this book. Then we installed SFML 2.2, and followed on to build a very basic
    SFML application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了我们将使用哪些技术以及为什么使用它们。我们还学习了在不同环境中安装 C++11 编译器，了解了如何安装 CMake 以及它将如何帮助我们构建本书中的
    SFML 项目。然后我们安装了 SFML 2.2，并继续构建了一个非常基本的 SFML 应用程序。
- en: In the next chapter we will gain knowledge on how to structure a game, manage
    user inputs, and keep trace of our resources.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解如何构建游戏结构，管理用户输入，并跟踪我们的资源。
