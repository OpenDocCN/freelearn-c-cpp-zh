- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Indirect Addressing – References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will examine how to utilize references in C++. References can often,
    but not always, be used as an alternative to pointers for indirect addressing.
    Though you have prior experience with indirect addressing from our last chapter
    using pointers, we will start at the beginning to understand C++ references.
  prefs: []
  type: TYPE_NORMAL
- en: References, like pointers, are a language feature you must be able to utilize
    with ease. Many other languages use references for indirect addressing without
    requiring the thorough understanding that C++ imposes to correctly utilize both
    pointers and references. Just as with pointers, you will see references frequently
    used throughout code from other programmers. You may be pleased that using references
    will provide notational ease when writing applications compared to pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, references cannot be used as a substitute for pointers in all
    situations requiring indirect addressing. Therefore, a thorough understanding
    of indirect addressing using both pointers and references is a necessity in C++
    to create successful and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter will be to complement your understanding of indirect
    addressing using pointers with knowing how to use C++ references as an alternative.
    Understanding both techniques of indirect addressing will enable you to be a better
    programmer, to easily understand and modify others’ code, as well as to write
    original, mature, and competent C++ code yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reference basics – declaring, initializing, accessing, and referencing existing
    objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using references with functions as arguments and as return values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `const` qualifier with references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding underlying implementation, and when references cannot be utilized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how to declare, initialize,
    and access references; you will understand how to reference existing objects in
    memory. You will be able to use references as arguments to functions, and understand
    how they may be used as return values from functions.
  prefs: []
  type: TYPE_NORMAL
- en: You will also fathom how the `const` qualifier may apply to references as variables
    and be utilized with both a function’s parameters and return type. You will be
    able to distinguish when references can be used in lieu of pointers, and in which
    situations they cannot provide a substitute for pointers. These skills will be
    necessary in order to move forward with the next chapters in the book successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter04](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter04).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in this chapter can be found in the subdirectory `Chapter04`
    in a file named `Chp4-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3ptaMRK](https://bit.ly/3ptaMRK).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding reference basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will revisit reference basics as well as introduce operators
    applicable to references, such as the reference operator `&`. We will employ the
    reference operator (`&`) to establish a reference to the existing variable. Like
    pointer variables, reference variables refer to memory that is defined elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Using reference variables allows us to use a more straightforward notation than
    the notation that pointers use when using indirectly accessed memory. Many programmers
    appreciate the clarity in the notation of a reference versus a pointer variable.
    But, behind the scenes, memory must always be properly allocated and released;
    some portion of memory that is referenced may come from the heap. The programmer
    will undoubtedly need to deal with pointers for some portion of their overall
    code.
  prefs: []
  type: TYPE_NORMAL
- en: We will discern when references and pointers are interchangeable, and when they
    are not. Let’s get started with the basic notation for declaring and using reference
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring, initializing, and accessing references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s begin with the meaning of a reference variable. A C++ `&`. A reference
    must be initialized (at declaration) and may never be assigned to reference another
    object. The reference and the initializer must be of the same type. Since the
    reference and the object being referenced share the same memory, either variable
    may be used to modify the contents of the shared memory location.
  prefs: []
  type: TYPE_NORMAL
- en: A reference variable, behind the scenes, can be compared to a pointer variable
    in that it holds the address of the variable that it is referencing. Unlike a
    pointer variable, any usage of the reference variable automatically dereferences
    the variable to go to the address that it contains; the dereference operator `*`
    is simply not needed with references. Dereferencing is automatic and implied with
    each use of a reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example illustrating reference basics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we first declare and initialize `int x = 10;` and
    then declare and allocate `int *p = new int;`. We then assign the integer value
    `20` to `*p.`
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare and initialize two reference variables, `refInt1` and `refInt2`.
    In the first reference declaration and initialization, `int &refInt1 = x;`, we
    establish `refInt1` to refer to the variable `x`. It helps to read the reference
    declaration from right to left. Here, we are saying to use `x` to initialize `refInt1`,
    which is a reference (`&`) to an integer. Notice that both the initializer, `x`,
    is an integer and that `refInt1` is declared to be a reference to an integer;
    their types match. This is important. The code will not compile if the types differ.
    Likewise, the declaration and initialization `int &refInt2 = *p;` also establishes
    `refInt2` as a reference to an integer. Which one? The one pointed to by `p`.
    This is why `p` is dereferenced using `*` to go to the integer itself.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we print out `x`, `*p`, `refInt1`, and `refInt2`; we can verify that `x`
    and `refInt1` have the same value of `10`, and `*p` and `refInt2` also have the
    same value of `20`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, using the original variables, we increment both `x` and `*p` by one. Not
    only does this increment the values of `x` and `*p`, but the values of `refInt1`
    and `refInt2`. Repeating the printing of these four values, we again notice that
    `x` and `refInt1` have the value of `11`, while `*p` and `refInt2` have the value
    of `21`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the reference variables to increment the shared memory. We increment
    both `refInt1` and `*refint2` by one and this also increments the values of the
    original variables `x` and `*p`. This is because the memory is one and the same
    between the original variable and the reference to that variable. That is, the
    reference can be thought of as an alias to the original variable. We conclude
    the program by again printing out the four variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Remember, a reference variable must be initialized to the variable it will refer
    to. The reference may never be assigned to another variable. More precisely, we
    cannot rebind the reference to another entity. The reference and its initializer
    must be the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a handle on how to declare simple references, let’s take a
    more complete look at referencing existing objects, such as those to user defined
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing existing objects of user defined types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Should a reference to an object of a `struct` or `class` type be defined, the
    object being referenced is simply accessed using the `.` (member selection) operator.
    Again, it is not necessary (such as it is with pointers) to first use the dereference
    operator to go to the object being referenced before choosing the desired member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example in which we reference a user defined type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the first part of this program, we define a user defined type, `Student`,
    using a `class`. Next, we declare a variable `s1` of type `Student` using `Student
    s1;`. Now, we declare and initialize a reference to a `Student` using `Student
    &sRef = s1;`. Here, we declare `sRef` to reference a specific `Student`, namely
    `s1`. Notice that both `s1` is of type `Student` and the reference type of `sRef`
    is also that of type `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we load some initial data into `s1.name` and `s1.gpa` using two simple
    assignments. Consequently, this alters the value of `sRef` since `s1` and `sRef`
    refer to the same memory. That is, `sRef` is an alias for `s1`.
  prefs: []
  type: TYPE_NORMAL
- en: We print out various data members for `s1` and `sRef` and notice that they contain
    the same values.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we load new values into `sRef.name` and `sRef.gpa` using assignments. Similarly,
    we print out various data members for `s1` and `sRef` and notice that again, the
    values for both have changed. Again, we can see that they reference the same memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output to accompany this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now move forward with our understanding of references by considering their
    usage in functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using references with functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have minimally demonstrated references by using them to establish
    an alias for an existing variable. Instead, let’s put forth a meaningful use of
    references, such as when they are used in function calls. We know most functions
    in C++ will take arguments, and we have seen many examples in the previous chapters
    illustrating function prototypes and function definitions. Now, let’s augment
    our understanding of functions by passing references as arguments to functions,
    and using references as return values from functions.
  prefs: []
  type: TYPE_NORMAL
- en: Passing references as arguments to functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: References may be used as arguments to functions to achieve call-by-reference,
    rather than call-by-value, parameter passing. References can alleviate the need
    for pointer notation in the scope of the function in question as well as in the
    call to that function. Object or `.` (member selection) notation is used to access
    `struct` or `class` members for formal parameters that are references.
  prefs: []
  type: TYPE_NORMAL
- en: In order to modify the contents of a variable passed as an argument to a function,
    a reference (or pointer) to that argument must be used as a function parameter.
    Just as with a pointer, when a reference is passed to a function, a copy of the
    address representing the reference is passed to the function. However, within
    the function, any usage of a formal parameter that is a reference will automatically
    and implicitly be dereferenced, allowing the user to use object rather than pointer
    notation. As with passing a pointer variable, passing a reference variable to
    a function will allow the memory referenced by that parameter to be modified.
  prefs: []
  type: TYPE_NORMAL
- en: When examining a function call (apart from its prototype), it will not be obvious
    whether an object passed to that function is passed by value or by reference.
    That is, whether the entire object will be copied on the stack or whether a reference
    to that object will instead be passed on the stack. This is because object notation
    is used when manipulating references, and the function calls for these two scenarios
    will use the same syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Diligent use of function prototypes will solve the mystery of what a function
    definition looks like and whether its arguments are objects or references to objects.
    Remember, a function definition may be defined in a separate file from any calls
    to that function, and not be easily available to view. Note that this ambiguity
    does not come up with pointers specified in a function call; it is immediately
    obvious that an address is being sent to a function based on how the variable
    is declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a few minutes to understand an example illustrating passing references
    as arguments to functions. Here, we will begin by examining three functions, which
    contribute to the following full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Examining the previous functions, notice that `AddOne(int &arg)` takes a reference
    to an `int` as a formal parameter, while `AddOne(int *arg)` takes a pointer to
    an `int` as a formal parameter. These functions are overloaded. The types of their
    actual parameters will determine which version is called.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s consider `Display(int &arg)`. This function takes a reference to an
    integer. Notice that object (not pointer) notation is used to print `arg` within
    this function’s definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s examine the remainder of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice the function prototypes at the top of this program segment. They will
    match the function definitions in the previous segment of code. Now, in the `main()`
    function, we declare and initialize `int x = 10;` and declare a pointer `int *y;`.
    We allocate the memory for `y` using `new()` and then assign a value by dereferencing
    the pointer with `*y = 15;`. We print out the respective values of `x` and `*y`
    as a baseline using successive calls to `Display()`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call `AddOne(x)` followed by `AddOne(*y)`. Variable `x` is declared
    to be an integer and `*y` refers to the integer pointed to by `y`. In both cases,
    we are passing integers as actual parameters to the version of the overloaded
    function with the signature `void AddOne(int &);`. In both cases, the formal parameters
    will be changed in the function, as we are passing by reference. We can verify
    this when their respective values are next printed using successive calls to `Display()`.
    Note that in the function call `AddOne(x);`, the reference to the actual parameter
    `x` is established by the formal parameter `arg` (in the function’s parameter
    list) at the time of the function call.
  prefs: []
  type: TYPE_NORMAL
- en: In comparison, we then call `AddOne(&x);` followed by `AddOne(y);`. In both
    cases, we are calling the overloaded version of this function with the signature
    `void AddOne(int *);`. In each case, we are passing a copy of an address as the
    actual parameter to the function. Naturally, `&x` is the address of variable `x`,
    so this works. Likewise, `y` itself is an address – it is declared as a pointer
    variable. We again verify that their respective values are again changed with
    two calls to `Display()`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, in each call to `Display()`, we pass an object of type `int`. Looking
    at the function call alone, we cannot determine whether this function will take
    an `int` as an actual parameter (which would imply the value could not be changed),
    or an `int &` as an actual parameter (which would imply that the value could be
    modified). Either of these is a possibility. However, by looking at the function
    prototype, we can clearly see that this function takes an `int &` as a parameter,
    and from this, we understand that the parameter may likely be modified. This is
    one of the many reasons function prototypes are helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for the full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s add to our discussion of using references with functions by using
    references as return values from functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using references as return values from functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions may return references to data via their return statements. We will
    see a requirement to return data by reference when we overload operators for user
    defined types in [*Chapter 12*](B19087_12.xhtml#_idTextAnchor526), *Friends and
    Operator Overloading*. With operator overloading, returning a value from a function
    using a pointer will not be an option to preserve the operator’s original syntax.
    We must return a reference (or a reference qualified with `const`); this will
    also allow overloaded operators to enjoy cascaded use. Additionally, understanding
    how to return objects by reference will be useful as we explore the C++ Standard
    Template Library in [*Chapter 14*](B19087_14.xhtml#_idTextAnchor595), *Understanding
    STL Basics*.
  prefs: []
  type: TYPE_NORMAL
- en: When returning a reference via the return statement of a function, be sure that
    the memory that is referred to will persist after the function call is completed.
    Do **not** return a reference to a local variable defined on the stack within
    the function; this memory will be popped off the stack the moment the function
    completes.
  prefs: []
  type: TYPE_NORMAL
- en: Since we cannot return a reference to a local variable within the function,
    and since returning a reference to an external variable is pointless, you may
    ask where the data that we return a reference to will reside. This data will inevitably
    be on the heap. Heap memory will exist past the extent of the function call. In
    most circumstances, the heap memory will have been allocated elsewhere; however,
    on rare occasions, the memory may have been allocated within this function. In
    this unusual situation, you must remember to relinquish the allocated heap memory
    when it is no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting heap memory through a reference (versus pointer) variable will require
    you to use the address-of operator, `&`, to pass the required address to operator
    `delete()`. Even though reference variables contain the address of the object
    they are referencing, the use of a reference identifier is always in its dereferenced
    state. It is **rare** that the need may arise to delete memory using a reference
    variable; we will discuss a meaningful (yet rare) example in [*Chapter 10*](B19087_10.xhtml#_idTextAnchor454),
    *Implementing Association, Aggregation, and Composition*.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The following example illustrates syntactically how to return a reference from
    a function, which you will utilize when we overload operators to allow their cascaded
    use, for example. However, it is not recommended to use references to return newly
    allocated heap memory (in most cases, the heap memory will have been allocated
    elsewhere). It is a common convention to use references to signal to other programmers
    that there is no need for memory management for that variable. Nevertheless, rare
    scenarios for such deletions via references may be seen in existing code (as with
    the aforementioned rare usage with associations), so it is useful to see how such
    a rare deletion may be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example to illustrate the mechanics of using a reference as a
    return value from a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex4.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we see `int &CreateId();` prototyped towards the top of the
    program. This tells us that `CreateId()` will return a reference to an integer.
    The return value must be used to initialize a variable of type `int &`.
  prefs: []
  type: TYPE_NORMAL
- en: Toward the bottom of the program, we see the function definition for `CreateId()`.
    Notice that this function first declares a `static` counter, which is initialized
    exactly once to `100`. Because this local variable is `static`, it will preserve
    its value from function call to function call. We then increment this counter
    by one a few lines later. The static variable, `count`, will be used as a basis
    to generate a unique ID.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in `CreateId()`, we allocate space for an integer on the heap and point
    to it using the local variable `memory`. We then load `*memory` with the value
    of `count` and then increase `count` for the next time we enter this function.
    We then use `*memory` as the return value of this function. Notice that `*memory`
    is an integer (the one pointed to on the heap by the variable `memory`). When
    we return it from the function, it is returned as a reference to that integer.
    When returning a reference from a function, always ensure that the memory that
    is referenced exists beyond the extent of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at our `main()` function. Here, we initialize a reference variable
    `id1` with the return value of our first call to `CreateId()` in the following
    function call and initialization: `int &id1 = CreateId();`. Note that the reference
    `id1` must be initialized when it is declared, and we have met that requirement
    with the aforementioned line of code.'
  prefs: []
  type: TYPE_NORMAL
- en: We repeat this process with `id2`, initializing this reference with the return
    value of `CreateId()`. We then print both `id1` and `id2`. By printing both `id1`
    and `id2`, you can see that each ID variable has its own memory and maintains
    its own data values.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we must remember to deallocate the memory that `CreateId()` allocated
    on our behalf. We must use operator `delete()`. Wait, operator `delete()` expects
    a pointer to the memory that will be deleted. Variables `id1` and `id2` are both
    references, not pointers. True, they each contain an address because each is inherently
    implemented as a pointer, but any use of their respective identifiers is always
    in a dereferenced state. To circumvent this dilemma, we simply take the address
    of reference variables `id1` and `id2` prior to calling `delete()`, such as `delete
    &id1;`. It is **rare** that you would need to delete memory via a reference variable,
    but now you know how to do so should the need arise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand how references can be used within parameters to functions
    and as return values from functions, let’s move forward by examining further reference
    nuances.
  prefs: []
  type: TYPE_NORMAL
- en: Using the const qualifier with references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `const` qualifier can be used to qualify the data in which references are
    initialized or *refer to*. We can also use `const` qualified references as arguments
    to functions and as return values from functions.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that a reference is implemented as a constant
    pointer in C++. That is, the address contained within the reference variable is
    a fixed address. This explains why a reference variable must be initialized to
    the object to which it will refer, and may not later be updated using an assignment.
    This also explains why constant qualifying the reference itself (and not just
    the data that it refers to) does not make sense. This variety of `const` qualification
    is already implied with its underlying implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at these various scenarios using `const` with references.
  prefs: []
  type: TYPE_NORMAL
- en: Using references to constant objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `const` qualifier can be used to indicate that the data to which references
    are initialized are unmodifiable. In this fashion, the alias always refers to
    a fixed piece of memory, and the value of that variable may not be changed using
    the alias itself. The reference, once specified as constant, implies that neither
    the reference nor its value may be changed. Again, the reference itself may not
    be changed due to its underlying implementation as a constant qualified pointer.
    A `const` qualified reference may not be used as an *l-value* in any assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Recall, an **l-value** is a value that can be modified and that occurs on the
    left-hand side of an assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s introduce a simple example to understand the situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex5.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, notice that we declare `int x = 5;` and then we establish
    a constant reference to that integer with the declaration: `const int &refInt
    = x;`. Next, we print out both values for a baseline and notice that they are
    identical. This makes sense; they reference the same integer memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the commented-out piece of code, `//refInt = 6;`, we try to modify
    the data that the reference refers to. Because `refInt` is qualified as `const`,
    this is illegal; this is the reason why we commented out this line of code.
  prefs: []
  type: TYPE_NORMAL
- en: However, on the following line of code, we assign `x` a value of `7`. Since
    `refInt` refers to this same memory, its value will also be modified. Wait, isn’t
    `refInt` constant? Yes, by qualifying `refInt` as `const`, we are indicating that
    its value will not be modified using the identifier `refInt`. This memory can
    still be modified using `x`.
  prefs: []
  type: TYPE_NORMAL
- en: But wait, isn’t this a problem? No, if `refInt` truly wants to refer to something
    unmodifiable, it can instead initialize itself with a `const int`, not an `int`.
    This subtle point is something to remember in C++ so you can write code for exactly
    the scenario you intend to have, understanding the significance and consequences
    of each choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s see a variation on the `const` qualification theme.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers to constant objects as function arguments and as return types
    from functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `const` qualification with function parameters cannot just allow the speed
    of passing an argument by reference, but the safety of passing an argument by
    value. It is a useful feature in C++.
  prefs: []
  type: TYPE_NORMAL
- en: A function that takes a reference to an object as a parameter often has less
    overhead than a comparable version of the function that takes a copy of an object
    as a parameter. This most notably occurs when the object type that would be otherwise
    copied on the stack is large. Passing a reference as a formal parameter is speedier,
    yet permits the actual parameter to be potentially modified in the scope of the
    function. Passing a reference to a constant object as a function argument provides
    both speed and safety for the argument in question. The reference qualified as
    `const` in the parameter list simply may not be an *l-value* in the scope of the
    function in question.
  prefs: []
  type: TYPE_NORMAL
- en: The same benefit of `const` qualified references exists for the return value
    from a function. Constant qualifying the data referenced insists that the caller
    of the function must also store the return value in a reference to a constant
    object, ensuring the object may not be modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex6.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first define a simple `struct` `collection` with data members
    `x` and `y`. Next, we prototype `Update(collection &);` and `Print(const collection
    &);`. Notice that `Print()` constant qualifies the data being referenced as the
    input parameter. This means that this function will enjoy the speed of passing
    this parameter by reference, and the safety of passing the parameter by value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice, towards the end of the program, we see the definitions for both `Update()`
    and `Print()`. Both take references as arguments, however, the parameter to `Print()`
    is constant qualified: `void Print(const collection &);`. Notice that both functions
    use the `.` (member selection) notation within each function body to access the
    relevant data members.'
  prefs: []
  type: TYPE_NORMAL
- en: In `main()`, we declare two variables, `collect1` of type `collection`, and
    `collect2`, which is a pointer to a `collection` (and whose memory is subsequently
    allocated). We call `Update()` for both `collect1` and `*collect2`, and in each
    case, a reference to the applicable object is passed to the `Update()` function.
    In the case of `collect2`, which is a pointer variable, the actual parameter must
    first dereference `*collect2` to go to the object being referenced before calling
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in `main()`, we call `Print()` successively for both `collect1` and
    `*collect2`. Here, `Print()` will reference each object serving as a formal parameter
    as constant qualified referenced data, ensuring that no modifications of either
    input parameter are possible within the scope of the `Print()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have an understanding of when `const` qualified references are useful,
    let’s take a look at when we can use references in lieu of pointers, and when
    we cannot.
  prefs: []
  type: TYPE_NORMAL
- en: Realizing underlying implementation and restrictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: References can ease the notation required for indirect referencing. However,
    there are situations in which references simply cannot take the place of pointers.
    To understand these situations, it is useful to review the underlying implementation
    of a reference in C++.
  prefs: []
  type: TYPE_NORMAL
- en: References are implemented as constant pointers, hence they must be initialized.
    Once initialized, references may not refer to a different object (though the value
    of the object being referenced can be changed).
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the implementation, let’s consider a sample reference declaration:
    `int &intVar = x;`. From an implementation aspect, it is as though the former
    variable declaration is instead declared as `int *const intVar = &x;`. Note that
    the `&` symbol shown on the left-hand side of an initialization takes on the meaning
    of reference, whereas the `&` symbol shown on the right-hand side of an initialization
    or assignment implies address-of. These two declarations illustrate how a reference
    is defined versus its underlying implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Even though a reference is implemented as a constant pointer, the usage of the
    reference variable is as if the underlying constant pointer has been dereferenced.
    For this reason, you cannot initialize a reference with a `nullptr` – not only
    can a `nullptr` not be dereferenced but since references can only be initialized
    and not reset, the opportunity would be lost to establish the reference variable
    to refer to a meaningful object. This also holds true for references to pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s understand in which situations we cannot use references.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding when we must use pointers instead of references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on the underlying implementation of references (as `const` pointers),
    most of the restrictions for reference usage make sense. For example, references
    to references are generally not allowed; each level of indirection would need
    to be initialized upfront and that often takes multiple steps, such as when using
    pointers. However, we will see `&&`) in [*Chapter 15*](B19087_15.xhtml#_idTextAnchor655),
    *Testing Classes and Components*, where we will examine various *move* operations.
    Arrays of references are also not permitted (each element would need to be initialized
    immediately); nonetheless, arrays of pointers are always an option. Also, pointers
    to references are not permitted; however, references to pointers are permitted
    (as are pointers to pointers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the mechanics of an interesting allowable reference case
    that we have not yet explored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex7.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we declare `int *ptr;` and then allocate the memory for `ptr`
    (consolidated on one line). We then assign a value of `20` to `*p`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare `int *&refPtr = ptr;`, which is a reference to a pointer of
    type `int`. It helps to read the declaration from right to left. As such, we use
    `ptr` to initialize `refPtr`, which is a reference to a pointer to an `int`. In
    this case, the two types match; `ptr` is a pointer to an `int`, so `refPtr` must
    also then reference a pointer to an `int`. We then print out the value of both
    `*ptr` and `*refPtr` and can see that they are the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this example, we have seen yet another interesting use of references. We
    also understand the restrictions placed upon using references, all of which are
    driven by their underlying implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned numerous aspects of C++ references. We have
    taken the time to understand reference basics, such as declaring and initializing
    reference variables to existing objects, as well as how to access reference components
    for basic and user defined types.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to utilize references in a meaningful fashion with functions,
    both as input parameters and as a return value. We have also seen when it is reasonable
    to apply the `const` qualifier to references, as well as seen how this concept
    can be combined with parameters and return values from functions. Lastly, we have
    seen the underlying implementation of references. This has helped explain some
    of the restrictions references encompass, as well as understand which cases of
    indirect addressing will require the use of pointers instead of references.
  prefs: []
  type: TYPE_NORMAL
- en: As with pointers, all of the skills using references from this chapter will
    be used freely in the upcoming chapters. C++ allows programmers to have a more
    convenient notation for indirect addressing using references; however, programmers
    are expected to utilize either for indirect addressing with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you are now ready to move forward to [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222),
    *Exploring Classes in Detail*, in which we begin the object-oriented features
    of C++. This is what we have been waiting for; let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modify and augment your C++ program from [*Chapter 3*](B19087_03.xhtml#_idTextAnchor118),
    *Indirect Addressing – Pointers*, *Question 1* as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overload your `ReadData()` function with a version that accepts a `Student &`
    parameter to allow `firstName`, `lastName`, `currentCourseEnrolled`, and `gpa`
    to be entered from the keyboard within the function.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the `Print()` function that takes a `Student` from your previous solution
    to instead take a `const` `Student &` as a parameter for `Print()`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create variables of type `Student` and of type `Student *` in `main()`. Now,
    call the various versions of `ReadData()`, and `Print()`. Do the pointer variables
    necessarily need to call the versions of these functions that accept pointers,
    and do the non-pointer variables necessarily need to call the versions of these
    functions that accept references? Why or why not?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 2: Implementing Object-Oriented Concepts in C++'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this part is to understand how to implement OO designs using both
    C++ language features and proven programming techniques. C++ can be used for many
    paradigms of coding; programmers must strive to program in an OO fashion in C++
    (it’s not automatic). This is the largest section of the book, as understanding
    how to map language features and implementation techniques to OO concepts is paramount.
  prefs: []
  type: TYPE_NORMAL
- en: The initial chapter in this section explores classes in great detail, beginning
    by describing the OO concepts of encapsulation and information hiding. Language
    features such as member functions, the `this` pointer, access regions in detail,
    constructors in detail (including the copy constructor, the member initialization
    list, and in-class initialization), destructor, qualifiers on member functions
    (`const`, `static`, and `inline`), and qualifiers on data members (`const` and
    `static`) are examined in depth.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter in this section tackles single inheritance basics with the
    OO concepts of generalization and specialization, detailing inherited constructors
    through the member initialization list, the order of construction and destruction,
    and understanding inherited access regions. Final classes are explored. This chapter
    pushes deeper by exploring public versus protected and private base classes and
    how these language features change the OO meaning of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: The subsequent chapter delves into the OO concept of polymorphism with respect
    to understanding the concept as well as its implementation in C++ using virtual
    functions. The `virtual`, `override`, and `final` keywords are explored. Dynamic
    binding of an operation to a specific method is examined. The virtual function
    table is explored to explain runtime binding.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter explains abstract classes in detail, pairing the OO concept
    with its implementation using pure virtual functions. The OO concept of an interface
    (not explicitly in C++) is introduced and a method for implementation is reviewed.
    Casting up and down the inheritance hierarchy completes this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter explores multiple inheritance and the potential issues that
    may arise from using this feature. Virtual base classes are detailed as well as
    the OO concept of a discriminator to help determine whether multiple inheritance
    is the best design for a given scenario or if another may exist.
  prefs: []
  type: TYPE_NORMAL
- en: The final chapter in this section introduces the concepts of association, aggregation,
    and composition and how to implement these common object relationships using pointers
    or references, sets of pointers, or embedded objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B19087_05.xhtml#_idTextAnchor222), *Exploring Classes in Detail*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19087_06.xhtml#_idTextAnchor314), *Implementing Hierarchies
    with Single Inheritance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19087_07.xhtml#_idTextAnchor366), *Utilizing Dynamic Binding
    through Polymorphism*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19087_08.xhtml#_idTextAnchor399), *Mastering Abstract Classes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19087_09.xhtml#_idTextAnchor426), *Exploring Multiple Inheritance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19087_10.xhtml#_idTextAnchor454), *Implementing Association,
    Aggregation, and Composition*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Implementing Object-Oriented Concepts in C++'
  prefs: []
  type: TYPE_NORMAL
