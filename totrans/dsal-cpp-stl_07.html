<html><head></head><body>
		<div><h1 id="_idParaDest-235" class="chapter-number"><a id="_idTextAnchor235"/>7</h1>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor236"/>Advanced Ordered Associative Container Usage</h1>
			<p>Associative containers in C++ allow developers to manage data in ways that align more naturally with real-world scenarios, such as using keys to retrieve values. This chapter gets into both ordered and unordered associative containers, their unique attributes, and ideal application environments. For the intermediate C++ developer, understanding when to use a map over an unordered map or the nuances between a set and a multiset can be pivotal in optimizing performance, memory usage, and data retrieval speed. Furthermore, mastering best practices will empower developers to write efficient, maintainable, and bug-free code, ensuring containers serve their purpose effectively in diverse application contexts.</p>
			<p>In essence, ordered associative containers, with their strict order and unique (or, sometimes, not so unique) elements, provide powerful tools in the C++ developer’s arsenal. They are tailor-made for scenarios that involve relationships, ordering, and uniqueness. Understanding their characteristics and use cases is the first step in leveraging their full potential.</p>
			<p>This chapter provides a reference for the following containers:</p>
			<ul>
				<li><code>std::set</code></li>
				<li><code>std::map</code></li>
				<li><code>std::multiset</code></li>
				<li><code>std::multimap</code></li>
			</ul>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor237"/>Technical requirements</h1>
			<p>The code in this chapter can be found on GitHub:</p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</a></p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor238"/>std::set</h1>
			<p>At its heart, a <code>std::set</code> container<a id="_idIndexMarker401"/> is a collection of unique elements where each element follows a strict order. You can think of it as a club where each member is distinct and all have a particular rank. The container ensures that no two elements are the same, making it exceptionally useful in situations where duplicates are not desired.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor239"/>Purpose and suitability</h2>
			<p><code>std::set</code> is an <a id="_idIndexMarker402"/>associative container designed to store a sorted set of unique objects of type <code>Key</code>. Its strengths are as follows:</p>
			<ul>
				<li>Ensuring all elements are unique</li>
				<li>Automatically sorting elements as they are inserted</li>
			</ul>
			<p>It is <a id="_idIndexMarker403"/>particularly suitable in the following scenarios:</p>
			<ul>
				<li>When duplicate elements are not desired</li>
				<li>When the ordering of elements matters</li>
				<li>When frequent lookups and insertions are anticipated</li>
			</ul>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor240"/>Ideal use cases</h2>
			<p>The following are <a id="_idIndexMarker404"/>some ideal use cases of <code>std::set</code>:</p>
			<ul>
				<li><code>std::set</code> naturally enforces this. For instance, it will be useful when collecting a list of unique student IDs or product codes.</li>
				<li><code>std::set</code> keeps its elements in a sorted order as per the comparison criteria. It’s beneficial when you require data to be inherently sorted, such as when maintaining a leaderboard where scores are continuously inserted but should always be in order.</li>
				<li><code>std::set</code> offers logarithmic time complexity for lookups. This makes it apt for scenarios where frequent <a id="_idIndexMarker405"/>membership checks are necessary – for instance, checking if a particular user is part of a VIP list.</li>
				<li><code>std::set</code> can be invaluable. It’s particularly useful in situations where you might want to find common elements between two collections or determine which elements are exclusive to one set.</li>
				<li><code>std::set</code> container can be used to keep track of these times. Given its ordered nature, you can swiftly determine the next event or if a particular time slot is already booked.</li>
			</ul>
			<p>It’s worth noting that while <code>std::set</code> is adept at these tasks, it is crucial to evaluate the specific requirements of the problem at hand. If ordering is not essential and you primarily need quick insertions, deletions, and lookups without regard for order, <code>std::unordered_set</code> might be a more suitable choice.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor241"/>Performance</h2>
			<p>The <a id="_idIndexMarker406"/>algorithmic performance of <code>std::set</code> is characterized as follows:</p>
			<ul>
				<li><strong class="bold">Insertion</strong>: Typically <em class="italic">O(log n)</em> due to the balanced binary search tree structure</li>
				<li><strong class="bold">Deletion</strong>: <em class="italic">O(log n)</em> for individual elements</li>
				<li><strong class="bold">Access (finding elements)</strong>: <em class="italic">O(log n)</em></li>
				<li><code>std::vector</code> due to the tree structure</li>
			</ul>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor242"/>Memory management</h2>
			<p>Internally, <code>std::set</code> uses<a id="_idIndexMarker407"/> a tree structure, typically a balanced binary search tree. Memory allocation can be influenced using custom allocators.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor243"/>Thread safety</h2>
			<p>Similar<a id="_idIndexMarker408"/> to <code>std::vector</code>, concurrent reads are safe, but modifications or a combination of reads and modifications necessitate external synchronization.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor244"/>Extensions and variants</h2>
			<p>The C++ <code>std::multiset</code> (which allows <a id="_idIndexMarker409"/>repeated elements) and <code>std::unordered_set</code> (a hash table, providing average <em class="italic">O(1)</em> insert/find at the cost of no ordering).</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor245"/>Sorting and searching complexity</h2>
			<p>The <a id="_idIndexMarker410"/>sorting and search complexity is characterized as follows:</p>
			<ul>
				<li><strong class="bold">Sorting</strong>: Elements are automatically sorted upon insertion</li>
				<li><code>find</code> member function</li>
			</ul>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor246"/>Special interface and member functions</h2>
			<p>Some<a id="_idIndexMarker411"/> handy <a id="_idIndexMarker412"/>member functions to note are as follows:</p>
			<ul>
				<li><code>emplace</code>: Insert elements in place</li>
				<li><code>count</code>: Return the number of elements (always 0 or 1 in a set)</li>
				<li><code>lower_bound</code> and <code>upper_bound</code>: Provide bounds for a specific key</li>
			</ul>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor247"/>Comparisons</h2>
			<p>In <a id="_idIndexMarker413"/>contrast to <code>std::vector</code>, <code>std::set</code> excels in ensuring uniqueness and maintaining order but may not be optimal for frequent random access or if order isn’t a concern.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor248"/>Interactions with algorithms</h2>
			<p>Given its <a id="_idIndexMarker414"/>bidirectional iterators, many STL algorithms are compatible with <code>std::set</code>. However, algorithms requiring random access might not be ideal.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor249"/>Exceptions</h2>
			<p>No exceptions<a id="_idIndexMarker415"/> are thrown due to capacity issues since <code>std::set</code> does not have a fixed capacity. Exceptions can arise from allocators during memory allocation.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor250"/>Customization</h2>
			<p><code>std::set</code> allows <a id="_idIndexMarker416"/>custom allocators for memory management. You can also provide a custom comparator to define how a set’s elements are ordered.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor251"/>Example</h2>
			<p><code>std::set</code> is a <a id="_idIndexMarker417"/>sorted associative container that contains unique elements. It is typically used to represent a collection where the existence of an element is more important than the number of times it appears. The following code is an example illustrating best practices when using <code>std::set</code>:</p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
int main() {
  std::set&lt;int&gt; numbers = {5, 3, 8, 1, 4};
  auto [position, wasInserted] = numbers.insert(6);
  if (wasInserted) {
    std::cout &lt;&lt; "6 was inserted into the set.\n";
  }
  auto result = numbers.insert(5);
  if (!result.second) {
    std::cout &lt;&lt; "5 is already in the set.\n";
  }
  if (numbers.find(3) != numbers.end()) {
    std::cout &lt;&lt; "3 is in the set.\n";
  }
  numbers.erase(1);
  std::cout &lt;&lt; "Elements in the set:";
  for (int num : numbers) { std::cout &lt;&lt; ' ' &lt;&lt; num; }
  std::cout &lt;&lt; '\n';
  std::set&lt;int&gt; moreNumbers = {9, 7, 2};
  numbers.merge(moreNumbers);
  std::cout &lt;&lt; "After merging:";
  for (int num : numbers) { std::cout &lt;&lt; ' ' &lt;&lt; num; }
  std::cout &lt;&lt; '\n';
  if (numbers.count(2)) {
    std::cout &lt;&lt; "2 exists in the set.\n";
  }
  std::set&lt;std::string, bool (*)(const std::string &amp;,
                                 const std::string &amp;)&gt;
      caseInsensitiveSet{[](const std::string &amp;lhs,
                            const std::string &amp;rhs) {
        return std::lexicographical_compare(
            lhs.begin(), lhs.end(), rhs.begin(), rhs.end(),
            [](char a, char b) {
              return std::tolower(a) &lt; std::tolower(b);
            });
      }};
  caseInsensitiveSet.insert("Hello");
  if (!caseInsensitiveSet.insert("hello").second) {
    std::cout &lt;&lt; "Duplicate insertion (case-insensitive) "
                 "detected.\n";
  }
  return 0;
}</pre>			<p>Here is <a id="_idIndexMarker418"/>the example output:</p>
			<pre class="console">
6 was inserted into the set.
5 is already in the set.
3 is in the set.
Elements in the set: 3 4 5 6 8
After merging: 2 3 4 5 6 7 8 9
2 exists in the set.
Duplicate insertion (case-insensitive) detected.</pre>			<p>In this example, we did the following:</p>
			<ul>
				<li>We demonstrated basic <code>std::set</code> operations such as insertion, finding an element, and erasing.</li>
				<li>We showcased how a set inherently sorts its elements and how to iterate over them.</li>
				<li>The use of the <code>merge</code> function was illustrated to merge another set into our primary set.</li>
				<li>The <code>count</code> method was used to check for the existence of an element in a set, which can only be 0 or 1 due to the uniqueness constraint.</li>
				<li>Lastly, we used a custom comparator to create a case-insensitive set of strings.</li>
			</ul>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor252"/>Best practices</h2>
			<p>Let us explore <a id="_idIndexMarker419"/>the best practices of using <code>std::set</code>:</p>
			<ul>
				<li><code>std::set</code>, access time is not constant as in <code>std::vector</code> or <code>std::array</code>. Due to its tree-based structure, element retrieval typically takes logarithmic time. When designing algorithms, factor this in.</li>
				<li><code>std::set</code> container, it is immutable. Altering it directly via an iterator could breach the set’s internal ordering. If modification is imperative, erase the old element and insert its updated version.</li>
				<li><code>std::unordered_set</code>. Thanks to<a id="_idIndexMarker420"/> its hash-based design, it frequently trumps <code>std::set</code> in performance metrics, barring worst-case scenarios.</li>
				<li><code>emplace</code> to create elements right within a set. This technique forestalls unnecessary object copying or movement.</li>
				<li><strong class="bold">Navigate element alterations</strong>: Direct tinkering of set elements is a no-go. The best approach when you need a modification is a two-step process: remove the original and introduce its altered counterpart.</li>
				<li><code>find</code> method is your go-to for determining if an element resides in a set. It’s more succinct and expressive than <code>count</code> in the context of <code>std::set</code>, given a set’s unique element nature.</li>
				<li><code>std::is_sorted</code>.</li>
				<li><code>std::set</code> is not intrinsically thread-safe. If concurrent access by multiple threads is anticipated, guard the set with synchronization primitives such as <code>std::mutex</code> or consider using concurrent containers provided by certain C++ libraries.</li>
				<li><code>std::set</code> container, remember that the <a id="_idIndexMarker421"/>elements are sorted. This can often obviate the need for additional sorting operations that you might apply on other containers.</li>
				<li><code>std::vector</code>, <code>std::set</code> doesn’t support <code>reserve</code> or <code>capacity</code> operations. The tree grows as elements are added. For efficiency, when removing elements, consider occasional <code>shrink_to_fit</code> operations available in some implementations.</li>
			</ul>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor253"/>std::map</h1>
			<p>A <a id="_idIndexMarker422"/>sibling to the <code>std::set</code> container, <code>std::map</code> is about relationships. It connects unique keys to specific values, forming a pair. In layman’s terms, imagine a dictionary where each word (key) has a unique definition (value).</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor254"/>Purpose and suitability</h2>
			<p><code>std::map</code> is an <a id="_idIndexMarker423"/>ordered associative container that stores key-value pairs, ensuring unique keys. Its underlying data structure is typically a balanced binary tree (such as a <strong class="bold">red-black tree</strong> (<strong class="bold">RBT</strong>)). The main advantages include the following:</p>
			<ul>
				<li>Logarithmic access, insertion, and deletion times</li>
				<li>Maintaining key-value pairs in sorted order by keys</li>
			</ul>
			<p>Use <code>std::map</code> in the <a id="_idIndexMarker424"/>following scenarios:</p>
			<ul>
				<li>When you need to associate values with unique keys</li>
				<li>When maintaining the order of keys is important</li>
				<li>When frequent access, insertion, or deletion operations are required, and they need to be efficient</li>
			</ul>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor255"/>Ideal use cases</h2>
			<p>The following are <a id="_idIndexMarker425"/>some ideal use cases of <code>std::map</code>:</p>
			<ul>
				<li><code>std::map</code> shines when associating unique keys with specific values. For example, it is useful when mapping a person’s name (unique key) to their contact details or a word to its definition.</li>
				<li><code>std::map</code> container can associate different configuration keys with their respective values, ensuring easy retrieval and modification of settings.</li>
				<li><strong class="bold">Student record system</strong>: Educational institutions might maintain a record system where student IDs (ensured to be unique) act as keys, mapping to comprehensive student profiles comprising names, courses, grades, and other details.</li>
				<li><code>std::map</code> can associate distinct items with their occurrence counts, ensuring efficient updates and retrievals.</li>
				<li><code>std::map</code> container for this purpose ensures that terms are sorted and can be efficiently accessed or updated.</li>
				<li><code>std::map</code> can serve as a cache, mapping input values to their computed results.</li>
				<li><code>std::map</code> inherently maintains its elements in sorted order based on its keys, it is apt for scenarios where operations dependent on this order are frequent – for example, fetching the <em class="italic">top 10</em> or <em class="italic">lowest 5</em> based on some criteria.</li>
			</ul>
			<p>Always consider <a id="_idIndexMarker426"/>the specific needs of your problem. While <code>std::map</code> offers ordering and unique key-value association, if ordering isn’t required, <code>std::unordered_map </code>might be a more performance-efficient alternative due to its average constant-time complexity for most operations.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor256"/>Performance</h2>
			<p>The algorithmic <a id="_idIndexMarker427"/>performance of <code>std::map</code> is characterized as follows:</p>
			<ul>
				<li><strong class="bold">Insertion</strong>: <em class="italic">O(log n)</em></li>
				<li><strong class="bold">Deletion</strong>: <em class="italic">O(log n)</em></li>
				<li><strong class="bold">Access</strong>: <em class="italic">O(log n)</em> to locate a key</li>
				<li><strong class="bold">Memory overhead</strong>: Generally higher than hash-based counterparts due to tree-based structure</li>
			</ul>
			<p>The primary trade-off is balancing memory overhead with the efficiency of ordered operations and the flexibility of key-value pair manipulation.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor257"/>Memory management</h2>
			<p><code>std::map</code> efficiently <a id="_idIndexMarker428"/>manages its memory internally, ensuring balanced trees. However, specific behavior can be influenced by custom allocators, allowing for more control.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor258"/>Thread safety</h2>
			<p>Concurrent<a id="_idIndexMarker429"/> reads are safe. However, concurrent writes or mixed read-writes require external synchronization, such as utilizing mutexes.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor259"/>Extensions and variants</h2>
			<p><code>std::multimap</code> allows <a id="_idIndexMarker430"/>multiple values per key, whereas <code>std::unordered_map </code>offers a hash-table-based alternative without ordering but with potential <em class="italic">O(1)</em> average access times.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor260"/>Sorting and searching complexity</h2>
			<p>The<a id="_idIndexMarker431"/> sorting and search complexity is characterized as follows:</p>
			<ul>
				<li><code>std::map</code> inherently maintains sorting</li>
				<li><strong class="bold">Searching</strong>: <em class="italic">O(log n)</em></li>
			</ul>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor261"/>Special interface and member functions</h2>
			<p>Some<a id="_idIndexMarker432"/> handy <a id="_idIndexMarker433"/>member functions to note are as follows:</p>
			<ul>
				<li><code>emplace</code>: Directly constructs a key-value pair in place</li>
				<li><code>at</code>: Throws an exception if the key doesn’t exist</li>
				<li><code>operator[]</code>: Accesses or creates a value for a given key</li>
				<li><code>lower_bound</code> and <code>upper_bound</code>: Provide iterators pointing to positions relative to a key</li>
			</ul>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor262"/>Comparisons</h2>
			<p>Compared<a id="_idIndexMarker434"/> to <code>std::unordered_map</code>, <code>std::map</code> excels in scenarios where key order matters or when the dataset might grow and shrink frequently. For situations demanding raw performance and where the order is insignificant, <code>std::unordered_map</code> might be preferable.</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor263"/>Interactions with algorithms</h2>
			<p>While <a id="_idIndexMarker435"/>many STL algorithms can work with <code>std::map</code>, its bidirectional iterators limit its compatibility with algorithms requiring random access.</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor264"/>Exceptions</h2>
			<p>Operations <a id="_idIndexMarker436"/>such as <code>at()</code> can throw out-of-range exceptions. Most operations on <code>std::map</code> provide strong exception safety, ensuring the map remains unchanged if an exception is thrown.</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor265"/>Customization</h2>
			<p>You<a id="_idIndexMarker437"/> can provide custom comparators to dictate the order of keys or use custom allocators to influence memory management.</p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor266"/>Example</h2>
			<p>In <code>std::map</code>, keys are <a id="_idIndexMarker438"/>sorted and unique, making it easy to find specific entries. The following code is an example illustrating best practices when using <code>std::map</code>:</p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
int main() {
  std::map&lt;std::string, int&gt; ageMap = {
      {"Lisa", 25}, {"Corbin", 30}, {"Aaron", 22}};
  ageMap["Kristan"] = 28;
  ageMap.insert_or_assign("Lisa", 26);
  if (ageMap.find("Corbin") != ageMap.end()) {
    std::cout &lt;&lt; "Corbin exists in the map.\n";
  }
  ageMap["Aaron"] += 1;
  std::cout &lt;&lt; "Age records:\n";
  for (const auto &amp;[name, age] : ageMap) {
    std::cout &lt;&lt; name &lt;&lt; ": " &lt;&lt; age &lt;&lt; '\n';
  }
  ageMap.erase("Corbin");
  if (ageMap.count("Regan") == 0) {
    std::cout &lt;&lt; "Regan does not exist in the map.\n";
  }
  std::map&lt;std::string, int,
           bool (*)(const std::string &amp;,
                    const std::string &amp;)&gt;
      customOrderMap{[](const std::string &amp;lhs,
                        const std::string &amp;rhs) {
        return lhs &gt; rhs; // reverse lexicographic order
      }};
  customOrderMap["Lisa"] = 25;
  customOrderMap["Corbin"] = 30;
  customOrderMap["Aaron"] = 22;
  std::cout &lt;&lt; "Custom ordered map:\n";
  for (const auto &amp;[name, age] : customOrderMap) {
    std::cout &lt;&lt; name &lt;&lt; ": " &lt;&lt; age &lt;&lt; '\n';
  }
  return 0;
}</pre>			<p>Here is the<a id="_idIndexMarker439"/> example output:</p>
			<pre class="console">
Corbin exists in the map.
Age records:
Aaron: 23
Corbin: 30
Kristan: 28
Lisa: 26
Regan does not exist in the map.
Custom ordered map:
Lisa: 25
Corbin: 30
Aaron: 22</pre>			<p>In this example, we did the following:</p>
			<ul>
				<li>We<a id="_idIndexMarker440"/> demonstrated the basic operations of <code>std::map</code>, such as insertion, modification, checking for the existence of a key, and iterating over its elements.</li>
				<li>We used structured bindings (C++17) to restructure the key-value pairs when iterating.</li>
				<li>We illustrated the use of <code>count</code> to check if a key exists in the map.</li>
				<li>We created a custom-ordered map by providing a custom comparator that sorts the keys in reverse lexicographical order.</li>
			</ul>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor267"/>Best practices</h2>
			<p>Let us explore the<a id="_idIndexMarker441"/> best practices of using <code>std::map</code>:</p>
			<ul>
				<li><code>std::map</code>, the key remains constant for the lifetime of that element. Modifying it directly is not allowed. Should you need to update the key, the correct approach is to remove the old key-value pair and insert a new one with the desired key.</li>
				<li><code>std::unordered_map</code>. Its hash table-based implementation may offer faster average-time complexities for many operations compared to the RBT of <code>std::map</code>, reducing potential overhead.</li>
				<li><code>emplace</code> method, which constructs the element in place within the map, avoiding temporary object creation and unnecessary copies. When paired with tools such as <code>std::make_pair</code> or <code>std::piecewise_construct</code>, it optimizes performance for insertions.</li>
				<li><code>operator[]</code> method, though convenient, can be a double-edged sword. If the specified key does not exist, it inserts the key with a default-initialized value into the map. When you wish to only query, without potential insertions, use the <code>find</code> method instead. The <code>find</code> method returns an iterator to the element if found and to the <code>end()</code> method if not.</li>
				<li><code>std::map</code> might not always fit the use case. You can customize the order by providing a comparator when defining the map. Ensure this comparator enforces a strict weak ordering to maintain the integrity of the map’s internal structures.</li>
				<li><code>std::map</code> container, synchronization becomes imperative. Consider using <code>std::mutex</code> or other STL synchronization primitives to lock access during write operations, preserving data consistency.</li>
				<li><code>count</code> method for a direct count result. For a map, this will always return <code>0</code> or <code>1</code>, making it a fast way to check membership.</li>
				<li><code>erase</code> operation invalidates the iterator. Use the returned iterator from <code>erase</code> to continue operations safely.</li>
				<li><code>std::map</code> offers range methods such as <code>equal_range</code>, which can return the bounds of a subrange of elements with keys equivalent to a given key. Utilize them for efficient subrange manipulations.</li>
				<li><code>std::map</code> supports custom allocators. This allows for better control over allocation and deallocation processes.</li>
			</ul>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor268"/>std::multiset</h1>
			<p>While a <code>std::set</code> container<a id="_idIndexMarker443"/> prides itself on its exclusivity, <code>std::multiset</code> is a bit more accommodating. It still maintains order, but it allows multiple elements to have the same value. This container is like a club where members have ranks, but there’s room for more than one member at each rank.</p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor269"/>Purpose and suitability</h2>
			<p><code>std::multiset</code> is an <a id="_idIndexMarker444"/>associative container that stores sorted elements and allows multiple occurrences of an element. Its key strengths are as follows:</p>
			<ul>
				<li>Maintaining a sorted order of elements</li>
				<li>Allowing duplicates</li>
				<li>Offering logarithmic time complexity for insertion, deletion, and search</li>
			</ul>
			<p>It’s particularly<a id="_idIndexMarker445"/> suitable in the following scenarios:</p>
			<ul>
				<li>When duplicate values need to be retained</li>
				<li>When you require elements to always remain sorted</li>
				<li>When random access is not a necessity</li>
			</ul>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor270"/>Ideal use cases</h2>
			<p>The following <a id="_idIndexMarker446"/>are some ideal use cases for <code>std::multiset</code>:</p>
			<ul>
				<li><code>std::multiset</code> container is beneficial. It allows for the storage of duplicate values while maintaining them in a sorted order.</li>
				<li><code>std::multiset</code> container is invaluable due to its inherent sorted nature and its ability to accommodate repeated numbers.</li>
				<li><code>std::multiset</code> container can help in efficiently <a id="_idIndexMarker447"/>managing and tracking these selections, especially when a popular session is chosen multiple times.</li>
				<li><code>std::multiset</code> container can represent such items, allowing easy tracking and replenishment based on demand.</li>
				<li><code>std::map</code>) maps terms to documents, a <code>std::multiset</code> container can be used to keep track of how frequently terms appear across multiple documents, even if some terms are common and appear repeatedly.</li>
				<li><code>std::multiset</code> to manage events or points efficiently, especially when multiple events share the same position.</li>
				<li><code>std::multiset</code> shines.</li>
			</ul>
			<p>Remember, while <code>std::multiset</code> is designed to handle multiple instances of the same value in a sorted manner, if the sorted property isn’t essential and you want to keep track of multiple items, structures such as <code>std::unordered_multiset</code> can be more performance-efficient in some cases due to hash-based implementations.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor271"/>Performance</h2>
			<p>The<a id="_idIndexMarker448"/> algorithmic performance of <code>std::multiset</code> is characterized as follows:</p>
			<ul>
				<li><strong class="bold">Insertion</strong>: <em class="italic">O(log n)</em></li>
				<li><strong class="bold">Deletion</strong>: <em class="italic">O(log n)</em></li>
				<li><strong class="bold">Access</strong>: Elements are accessed in <em class="italic">O(log </em><em class="italic">n)</em> time</li>
				<li><strong class="bold">Memory overhead</strong>: Overhead is present due to internal balancing (typically implemented as a balanced binary search tree)</li>
			</ul>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor272"/>Memory management</h2>
			<p><code>std::multiset</code> does not dynamically resize like <code>std::vector</code>. Instead, it uses dynamic<a id="_idIndexMarker449"/> memory allocation for nodes as elements are inserted. Allocators can influence node memory management.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor273"/>Thread safety</h2>
			<p>Concurrent <a id="_idIndexMarker450"/>reads are safe. However, modifications (insertions or deletions) require external synchronization. Utilizing mutexes or other synchronization primitives is recommended for concurrent writes.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor274"/>Extensions and variants</h2>
			<p><code>std::set</code> is a direct <a id="_idIndexMarker451"/>variant that disallows duplicates. There’s also <code>std::unordered_multiset</code>, which offers average constant-time complexity for operations but does not maintain order.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor275"/>Sorting and searching complexity</h2>
			<p>The <a id="_idIndexMarker452"/>sorting and search complexity is characterized as follows:</p>
			<ul>
				<li><strong class="bold">Sorting</strong>: Elements are always sorted; thus, no sort operation is required</li>
				<li><strong class="bold">Searching</strong>: <em class="italic">O(log n)</em> due to its tree-based nature</li>
			</ul>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor276"/>Special interface and member functions</h2>
			<p>While it <a id="_idIndexMarker453"/>provides<a id="_idIndexMarker454"/> regular functions (<code>insert</code>, <code>erase</code>, <code>find</code>), some handy ones include the following:</p>
			<ul>
				<li><code>count</code>: Returns the total number of elements matching a specified key</li>
				<li><code>equal_range</code>: Provides range (iterators) of all instances of an element</li>
			</ul>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor277"/>Comparisons</h2>
			<p>Against <code>std::set</code>, <code>std::multiset</code> allows duplicates but at the cost of slightly increased <a id="_idIndexMarker455"/>memory. Against sequence containers such as <code>std::vector</code>, it maintains sorted order but doesn’t offer constant-time access.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor278"/>Interactions with algorithms</h2>
			<p>Algorithms <a id="_idIndexMarker456"/>that benefit from sorted data (such as binary searches or set operations) work well with <code>std::multiset</code>. Those requiring random access or frequent reordering might not be suitable.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor279"/>Exceptions</h2>
			<p>Memory <a id="_idIndexMarker457"/>allocation failures can throw exceptions. Most <code>std::multiset</code> operations provide strong exception-safety guarantees.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor280"/>Customization</h2>
			<p>In <code>std::multiset</code>, customization<a id="_idIndexMarker458"/> entails the following:</p>
			<ul>
				<li>Custom allocators can be used to control memory allocation.</li>
				<li>Custom comparators can be provided to dictate the order of element storage.</li>
			</ul>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor281"/>Example</h2>
			<p><code>std::multiset</code> is a <a id="_idIndexMarker459"/>container that can store multiple keys, including duplicate keys. The keys are always sorted from the lowest key to the highest. <code>std::multiset</code> is typically used in situations where you need to maintain a sorted set of elements, and duplicates are allowed.</p>
			<p>The following code is an example of using <code>std::multiset</code>, demonstrating some of its unique features and best practices:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;set&gt;
#include &lt;string&gt;
int main() {
  std::multiset&lt;int&gt; numbers = {5, 3, 8, 5, 3, 9, 4};
  numbers.insert(6);
  numbers.insert(5); // Inserting another duplicate
  for (int num : numbers) { std::cout &lt;&lt; num &lt;&lt; ' '; }
  std::cout &lt;&lt; '\n';
  std::cout &lt;&lt; "Number of 5s: " &lt;&lt; numbers.count(5)
            &lt;&lt; '\n';
  auto [begin, end] = numbers.equal_range(5);
  for (auto it = begin; it != end; ++it) {
    std::cout &lt;&lt; *it &lt;&lt; ' ';
  }
  std::cout &lt;&lt; '\n';
  numbers.erase(5);
  std::multiset&lt;std::string, std::greater&lt;&gt;&gt; words = {
      "apple", "banana", "cherry", "apple"};
  for (const auto &amp;word : words) {
    std::cout &lt;&lt; word &lt;&lt; ' ';
  }
  std::cout &lt;&lt; '\n';
  std::multiset&lt;int&gt; dataset = {1, 2, 3, 4, 5,
                                6, 7, 8, 9, 10};
  const auto start = dataset.lower_bound(4);
  const auto stop = dataset.upper_bound(7);
  std::copy(start, stop,
            std::ostream_iterator&lt;int&gt;(std::cout, " "));
  std::cout &lt;&lt; '\n';
  return 0;
}</pre>			<p>Here is the example output:</p>
			<pre class="console">
3 3 4 5 5 5 6 8 9
Number of 5s: 3
5 5 5
cherry banana apple apple
4 5 6 7</pre>			<p>Key takeaways <a id="_idIndexMarker460"/>from the preceding example are as follows:</p>
			<ul>
				<li><code>std::multiset</code> automatically sorts keys.</li>
				<li>It can store duplicate keys, and this property can be utilized for certain algorithms or storage patterns where duplicates are meaningful.</li>
				<li>Using <code>equal_range</code> is a best practice to find all instances of a key. This method returns both the beginning and the end iterators, covering all instances of the key.</li>
				<li>Custom comparators, such as <code>std::greater&lt;&gt;</code>, can be used to reverse the default ordering.</li>
				<li><code>lower_bound</code> and <code>upper_bound</code> can be used for efficient range queries.</li>
			</ul>
			<p>Remember, if you don’t need to store duplicates, then <code>std::set</code> is a more appropriate choice.</p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor282"/>Best practices</h2>
			<p>Let us explore <a id="_idIndexMarker461"/>the best practices of using <code>std::multiset</code>:</p>
			<ul>
				<li><code>std::multiset</code> to prevent undue overhead. Instead, favor <code>std::set</code>, which inherently manages unique elements and can be more efficient.</li>
				<li><code>std::multiset</code> doesn’t offer the same constant-time access that <code>std::vector</code> provides. Accessing elements is logarithmic in complexity due to the underlying <a id="_idIndexMarker462"/>tree-based data structure.</li>
				<li><code>std::multiset</code> to hold duplicate elements can lead to elevated memory usage, especially when those duplicates are numerous. It’s crucial to analyze memory requirements and ensure the container’s suitability for the application.</li>
				<li><code>std::multiset</code>, ensure that it imposes a strict weak ordering. Any inconsistency in ordering can lead to undefined behavior. Test the comparator rigorously to confirm its reliability.</li>
				<li><code>find</code> and <code>count</code> member functions. They offer a more efficient and direct way to perform such checks.</li>
				<li><code>std::multiset</code>, clearly outline the reasons for needing duplicate entries. If the rationale isn’t strong, or duplicates don’t benefit your application logic significantly, consider using <code>std::set</code>.</li>
			</ul>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor283"/>std::multimap</h1>
			<p>Extending the<a id="_idIndexMarker463"/> principles of <code>std::map</code>, the <code>std::multimap</code> container allows for one key to be associated with multiple values. It’s like a dictionary where a word might have several related definitions.</p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor284"/>Purpose and suitability</h2>
			<p><code>std::multimap</code> is an<a id="_idIndexMarker464"/> associative container within the STL. Its distinguishing features are as follows:</p>
			<ul>
				<li>Storing key-value pairs</li>
				<li>Allowing multiple values with the same key</li>
				<li>Storing elements in a sorted manner, as determined by the key</li>
			</ul>
			<p>It’s particularly<a id="_idIndexMarker465"/> suitable in the following scenarios:</p>
			<ul>
				<li>When you need to maintain a collection with non-unique keys</li>
				<li>When you want sorted access based on keys</li>
				<li>When key-value mapping is paramount</li>
			</ul>
			<p>Choose <code>std::multimap</code> when you expect multiple values under the same key. If unique keys are necessary, you might want to look into <code>std::map</code>.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor285"/>Ideal use cases</h2>
			<p>The following are<a id="_idIndexMarker466"/> some ideal use cases of <code>std::multimap</code>:</p>
			<ul>
				<li><code>std::multimap</code>, you can associate one key with several values.</li>
				<li><code>std::multimap</code> container can effectively map these multiple meanings.</li>
				<li><code>std::multimap</code> container can associate a destination (key) with various flight details or times (values).</li>
				<li><code>std::multimap</code>, one can easily keep track of all events for a specific date.</li>
				<li><code>std::multimap</code> can be handy, especially when weights or other data associated with the edges are required.</li>
				<li><code>std::multimap</code> container.</li>
				<li><code>std::multimap</code> container is apt for such use cases.</li>
				<li><code>std::multimap</code> helps in organizing and retrieving media based on tags efficiently.</li>
			</ul>
			<p>Remember that <code>std::multimap</code> is a go-to when one-to-many relationships are prevalent. However, if order and sorting aren’t crucial and efficient retrieval is more important, considering structures such as <code>std::unordered_multimap</code> can be beneficial due to their hash-based nature.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor286"/>Performance</h2>
			<p>The <a id="_idIndexMarker468"/>algorithmic performance of std::multimap is characterized as follows:</p>
			<ul>
				<li><strong class="bold">Insertion</strong>: Logarithmic <em class="italic">O(log n)</em> in most cases</li>
				<li><strong class="bold">Deletion</strong>: Logarithmic <em class="italic">O(log </em><em class="italic">n)</em> generally</li>
				<li><strong class="bold">Access</strong>: <em class="italic">O(log n)</em> for specific keys</li>
				<li><strong class="bold">Memory overhead</strong>: It is a bit higher due to maintaining the tree-based structure and potential balancing</li>
			</ul>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor287"/>Memory management</h2>
			<p><code>std::multimap</code> internally<a id="_idIndexMarker469"/> employs a tree structure, typically an RBT. Thus, memory allocation and balancing operations can occur. Allocators can influence its memory handling.</p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor288"/>Thread safety</h2>
			<p>Multiple reads<a id="_idIndexMarker470"/> are safe. However, writes or combinations of reads and writes require external synchronization. Using tools such as mutexes is advisable.</p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor289"/>Extensions and variants</h2>
			<p>For <a id="_idIndexMarker471"/>hash-table-based key-value mapping, consider <code>std::unordered_multimap</code>. For unique key-value mapping, <code>std::map</code> is more appropriate.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor290"/>Sorting and searching complexity</h2>
			<p>The<a id="_idIndexMarker472"/> sorting and search complexity is characterized as follows:</p>
			<ul>
				<li><strong class="bold">Sorting</strong>: Sorting is inherent, as elements are maintained in key order</li>
				<li><strong class="bold">Searching</strong>: <em class="italic">O(log n)</em> to locate a specific key</li>
			</ul>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor291"/>Special interface and member functions</h2>
			<p>Standard <a id="_idIndexMarker473"/>functions<a id="_idIndexMarker474"/> such as <code>insert</code>, <code>erase</code>, and <code>find</code> are available. The following are also available:</p>
			<ul>
				<li><code>count</code>: Returns the number of elements with a particular key</li>
				<li><code>equal_range</code>: Retrieves the range of elements with a specific key</li>
			</ul>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor292"/>Comparisons</h2>
			<p>Against <code>std::unordered_multimap</code>, <code>std::multimap</code> offers ordered access but might <a id="_idIndexMarker475"/>have a slightly higher overhead due to its tree-based nature.</p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor293"/>Interactions with algorithms</h2>
			<p>Since <code>std::multimap</code> maintains<a id="_idIndexMarker476"/> ordered access, algorithms that benefit from sorted data (such as <code>std::set_intersection</code>) can be useful. However, remember that data is key-ordered.</p>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor294"/>Exceptions</h2>
			<p>Trying<a id="_idIndexMarker477"/> to access non-existent keys or out-of-bound scenarios can throw exceptions. Most operations are strongly exception-safe, ensuring the container remains valid even if an exception is thrown.</p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor295"/>Customization</h2>
			<p>Custom<a id="_idIndexMarker478"/> allocators can refine memory management. <code>std::multimap</code> also allows custom comparators to dictate the ordering of keys.</p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor296"/>Example</h2>
			<p><code>std::multimap</code> is a <a id="_idIndexMarker479"/>container that maintains a collection of key-value pairs, where multiple pairs can have the same key. The keys in <code>std::multimap</code> are always sorted.</p>
			<p>The following code is an example of using <code>std::multimap</code>, demonstrating some of its unique features and best practices:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
int main() {
  std::multimap&lt;std::string, int&gt; grades;
  grades.insert({"John", 85});
  grades.insert({"Corbin", 78});
  grades.insert({"Regan", 92});
  grades.insert({"John", 90}); // John has another grade
  for (const auto &amp;[name, score] : grades) {
    std::cout &lt;&lt; name &lt;&lt; " scored " &lt;&lt; score &lt;&lt; '\n';
  }
  std::cout &lt;&lt; '\n';
  std::cout &lt;&lt; "John's grade count:"
            &lt;&lt; grades.count("John") &lt;&lt; '\n';
  auto [begin, end] = grades.equal_range("John");
  for (auto it = begin; it != end; ++it) {
    std::cout &lt;&lt; it-&gt;first &lt;&lt; " scored " &lt;&lt; it-&gt;second
              &lt;&lt; '\n';
  }
  std::cout &lt;&lt; '\n';
  grades.erase("John");
  std::multimap&lt;std::string, int, std::greater&lt;&gt;&gt;
      reverseGrades = {{"Mandy", 82},
                       {"Mandy", 87},
                       {"Aaron", 90},
                       {"Dan", 76}};
  for (const auto &amp;[name, score] : reverseGrades) {
    std::cout &lt;&lt; name &lt;&lt; " scored " &lt;&lt; score &lt;&lt; '\n';
  }
  return 0;
}</pre>			<p>Here is the <a id="_idIndexMarker480"/>example output:</p>
			<pre class="console">
Corbin scored 78
John scored 85
John scored 90
Regan scored 92
John's grade count:2
John scored 85
John scored 90
Mandy scored 82
Mandy scored 87
Dan scored 76
Aaron scored 90</pre>			<p>Key takeaways<a id="_idIndexMarker481"/> from the preceding code are as follows:</p>
			<ul>
				<li><code>std::multimap</code> automatically sorts keys.</li>
				<li>It can store multiple key-value pairs with the same key.</li>
				<li>Using <code>equal_range</code> is a best practice to find all instances of a key. This method returns both the beginning and the end iterators, covering all instances of the key.</li>
				<li><code>grades.count("John")</code> efficiently counts the number of key-value pairs with the specified key.</li>
				<li>Custom comparators, such as <code>std::greater&lt;&gt;</code>, can change the ordering from the default ascending order to descending.</li>
			</ul>
			<p>A <code>std::multimap</code> container is useful when you need a dictionary-like data structure that supports duplicate keys. If duplicates aren’t needed, <code>std::map</code> would be a more appropriate choice.</p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor297"/>Best practices</h2>
			<p>Let us<a id="_idIndexMarker482"/> explore the best practices of using <code>std::multimap</code>:</p>
			<ul>
				<li><code>std::multimap</code>. The access complexity is logarithmic, attributed to its tree-based underpinning.</li>
				<li><code>std::multimap</code> are unique, as in <code>std::map</code>. A <code>std::multimap</code> container permits multiple entries for a single key. If your application demands unique keys, then <code>std::map</code> is the appropriate choice.</li>
				<li><code>std::multimap</code> is the inherent sorted nature of its elements based on the keys. Exploit this characteristic to your advantage, especially when performing operations that benefit from ordered data, such as range searches or ordered merges.</li>
				<li><code>std::unordered_multimap</code> might be a more fitting alternative due to its hashing mechanism. However, it is worth noting that worst-case performance and memory overheads can differ.</li>
				<li><code>find</code> or <code>count</code>. It helps prevent potential pitfalls and ensure robust code.</li>
				<li><strong class="bold">Use custom comparators for tailored sorting</strong>: Should you have a specific ordering requirement that deviates from the default, use custom comparators. Ensure that your comparator enforces a strict weak ordering to guarantee consistent and defined behavior of the multimap.</li>
				<li><code>equal_range</code> member function. It provides a range (beginning and end iterators) of all elements with a particular key, enabling efficient iteration over those specific elements.</li>
				<li><code>std::multimap</code> can become inefficient with large datasets, especially if frequent insertions <a id="_idIndexMarker483"/>and deletions are commonplace. In such scenarios, evaluate the structure’s performance and consider alternatives or optimization strategies.</li>
			</ul>
		</div>
	</body></html>