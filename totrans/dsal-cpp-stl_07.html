<html><head></head><body>
		<div id="_idContainer021">
			<h1 id="_idParaDest-235" class="chapter-number"><a id="_idTextAnchor235"/>7</h1>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor236"/>Advanced Ordered Associative Container Usage</h1>
			<p>Associative containers in C++ allow developers to manage data in ways that align more naturally with real-world scenarios, such as using keys to retrieve values. This chapter gets into both ordered and unordered associative containers, their unique attributes, and ideal application environments. For the intermediate C++ developer, understanding when to use a map over an unordered map or the nuances between a set and a multiset can be pivotal in optimizing performance, memory usage, and data retrieval speed. Furthermore, mastering best practices will empower developers to write efficient, maintainable, and bug-free code, ensuring containers serve their purpose effectively in diverse <span class="No-Break">application contexts.</span></p>
			<p>In essence, ordered associative containers, with their strict order and unique (or, sometimes, not so unique) elements, provide powerful tools in the C++ developer’s arsenal. They are tailor-made for scenarios that involve relationships, ordering, and uniqueness. Understanding their characteristics and use cases is the first step in leveraging their <span class="No-Break">full potential.</span></p>
			<p>This chapter provides a reference for the <span class="No-Break">following containers:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">std::set</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">std::map</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">std::multiset</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">std::multimap</strong></span></li>
			</ul>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor237"/>Technical requirements</h1>
			<p>The code in this chapter can be found <span class="No-Break">on GitHub:</span></p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL"><span class="No-Break">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</span></a></p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor238"/>std::set</h1>
			<p>At its heart, a <strong class="source-inline">std::set</strong> container<a id="_idIndexMarker401"/> is a collection of unique elements where each element follows a strict order. You can think of it as a club where each member is distinct and all have a particular rank. The container ensures that no two elements are the same, making it exceptionally useful in situations where duplicates are <span class="No-Break">not desired.</span></p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor239"/>Purpose and suitability</h2>
			<p><strong class="source-inline">std::set</strong> is an <a id="_idIndexMarker402"/>associative container designed to store a sorted set of unique objects of type <strong class="source-inline">Key</strong>. Its strengths are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Ensuring all elements <span class="No-Break">are unique</span></li>
				<li>Automatically sorting elements as they <span class="No-Break">are inserted</span></li>
			</ul>
			<p>It is <a id="_idIndexMarker403"/>particularly suitable in the <span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When duplicate elements are <span class="No-Break">not desired</span></li>
				<li>When the ordering of <span class="No-Break">elements matters</span></li>
				<li>When frequent lookups and insertions <span class="No-Break">are anticipated</span></li>
			</ul>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor240"/>Ideal use cases</h2>
			<p>The following are <a id="_idIndexMarker404"/>some ideal use cases <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::set</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Unique collection</strong>: If you need to maintain a collection of items where duplicates are not allowed, <strong class="source-inline">std::set</strong> naturally enforces this. For instance, it will be useful when collecting a list of unique student IDs or <span class="No-Break">product codes.</span></li>
				<li><strong class="bold">Ordered data</strong>: <strong class="source-inline">std::set</strong> keeps its elements in a sorted order as per the comparison criteria. It’s beneficial when you require data to be inherently sorted, such as when maintaining a leaderboard where scores are continuously inserted but should always be <span class="No-Break">in order.</span></li>
				<li><strong class="bold">Membership checks</strong>: Due to its tree-based nature, <strong class="source-inline">std::set</strong> offers logarithmic time complexity for lookups. This makes it apt for scenarios where frequent <a id="_idIndexMarker405"/>membership checks are necessary – for instance, checking if a particular user is part of a <span class="No-Break">VIP list.</span></li>
				<li><strong class="bold">Set operations</strong>: When working with mathematical set operations such as union, intersection, or difference, <strong class="source-inline">std::set</strong> can be invaluable. It’s particularly useful in situations where you might want to find common elements between two collections or determine which elements are exclusive to <span class="No-Break">one set.</span></li>
				<li><strong class="bold">Event scheduling</strong>: For applications that deal with events scheduled at different times, a <strong class="source-inline">std::set</strong> container can be used to keep track of these times. Given its ordered nature, you can swiftly determine the next event or if a particular time slot is <span class="No-Break">already booked.</span></li>
			</ul>
			<p>It’s worth noting that while <strong class="source-inline">std::set</strong> is adept at these tasks, it is crucial to evaluate the specific requirements of the problem at hand. If ordering is not essential and you primarily need quick insertions, deletions, and lookups without regard for order, <strong class="source-inline">std::unordered_set</strong> might be a more <span class="No-Break">suitable choice.</span></p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor241"/>Performance</h2>
			<p>The <a id="_idIndexMarker406"/>algorithmic performance of <strong class="source-inline">std::set</strong> is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Insertion</strong>: Typically <em class="italic">O(log n)</em> due to the balanced binary search <span class="No-Break">tree structure</span></li>
				<li><strong class="bold">Deletion</strong>: <em class="italic">O(log n)</em> for <span class="No-Break">individual elements</span></li>
				<li><strong class="bold">Access (finding elements)</strong>: <span class="No-Break"><em class="italic">O(log n)</em></span></li>
				<li><strong class="bold">Memory overhead</strong>: Generally higher than <strong class="source-inline">std::vector</strong> due to the <span class="No-Break">tree structure</span></li>
			</ul>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor242"/>Memory management</h2>
			<p>Internally, <strong class="source-inline">std::set</strong> uses<a id="_idIndexMarker407"/> a tree structure, typically a balanced binary search tree. Memory allocation can be influenced using <span class="No-Break">custom allocators.</span></p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor243"/>Thread safety</h2>
			<p>Similar<a id="_idIndexMarker408"/> to <strong class="source-inline">std::vector</strong>, concurrent reads are safe, but modifications or a combination of reads and modifications necessitate <span class="No-Break">external synchronization.</span></p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor244"/>Extensions and variants</h2>
			<p>The C++ <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>) also offers <strong class="source-inline">std::multiset</strong> (which allows <a id="_idIndexMarker409"/>repeated elements) and <strong class="source-inline">std::unordered_set</strong> (a hash table, providing average <em class="italic">O(1)</em> insert/find at the cost of <span class="No-Break">no ordering).</span></p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor245"/>Sorting and searching complexity</h2>
			<p>The <a id="_idIndexMarker410"/>sorting and search complexity is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Sorting</strong>: Elements are automatically sorted <span class="No-Break">upon insertion</span></li>
				<li><strong class="bold">Searching</strong>: <em class="italic">O(log n)</em> with the <strong class="source-inline">find</strong> <span class="No-Break">member function</span></li>
			</ul>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor246"/>Special interface and member functions</h2>
			<p>Some<a id="_idIndexMarker411"/> handy <a id="_idIndexMarker412"/>member functions to note are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">emplace</strong>: Insert elements <span class="No-Break">in place</span></li>
				<li><strong class="source-inline">count</strong>: Return the number of elements (always 0 or 1 in <span class="No-Break">a set)</span></li>
				<li><strong class="source-inline">lower_bound</strong> and <strong class="source-inline">upper_bound</strong>: Provide bounds for a <span class="No-Break">specific key</span></li>
			</ul>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor247"/>Comparisons</h2>
			<p>In <a id="_idIndexMarker413"/>contrast to <strong class="source-inline">std::vector</strong>, <strong class="source-inline">std::set</strong> excels in ensuring uniqueness and maintaining order but may not be optimal for frequent random access or if order isn’t <span class="No-Break">a concern.</span></p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor248"/>Interactions with algorithms</h2>
			<p>Given its <a id="_idIndexMarker414"/>bidirectional iterators, many STL algorithms are compatible with <strong class="source-inline">std::set</strong>. However, algorithms requiring random access might not <span class="No-Break">be ideal.</span></p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor249"/>Exceptions</h2>
			<p>No exceptions<a id="_idIndexMarker415"/> are thrown due to capacity issues since <strong class="source-inline">std::set</strong> does not have a fixed capacity. Exceptions can arise from allocators during <span class="No-Break">memory allocation.</span></p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor250"/>Customization</h2>
			<p><strong class="source-inline">std::set</strong> allows <a id="_idIndexMarker416"/>custom allocators for memory management. You can also provide a custom comparator to define how a set’s elements <span class="No-Break">are ordered.</span></p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor251"/>Example</h2>
			<p><strong class="source-inline">std::set</strong> is a <a id="_idIndexMarker417"/>sorted associative container that contains unique elements. It is typically used to represent a collection where the existence of an element is more important than the number of times it appears. The following code is an example illustrating best practices when <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::set</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
int main() {
  std::set&lt;int&gt; numbers = {5, 3, 8, 1, 4};
  auto [position, wasInserted] = numbers.insert(6);
  if (wasInserted) {
    std::cout &lt;&lt; "6 was inserted into the set.\n";
  }
  auto result = numbers.insert(5);
  if (!result.second) {
    std::cout &lt;&lt; "5 is already in the set.\n";
  }
  if (numbers.find(3) != numbers.end()) {
    std::cout &lt;&lt; "3 is in the set.\n";
  }
  numbers.erase(1);
  std::cout &lt;&lt; "Elements in the set:";
  for (int num : numbers) { std::cout &lt;&lt; ' ' &lt;&lt; num; }
  std::cout &lt;&lt; '\n';
  std::set&lt;int&gt; moreNumbers = {9, 7, 2};
  numbers.merge(moreNumbers);
  std::cout &lt;&lt; "After merging:";
  for (int num : numbers) { std::cout &lt;&lt; ' ' &lt;&lt; num; }
  std::cout &lt;&lt; '\n';
  if (numbers.count(2)) {
    std::cout &lt;&lt; "2 exists in the set.\n";
  }
  std::set&lt;std::string, bool (*)(const std::string &amp;,
                                 const std::string &amp;)&gt;
      caseInsensitiveSet{[](const std::string &amp;lhs,
                            const std::string &amp;rhs) {
        return std::lexicographical_compare(
            lhs.begin(), lhs.end(), rhs.begin(), rhs.end(),
            [](char a, char b) {
              return std::tolower(a) &lt; std::tolower(b);
            });
      }};
  caseInsensitiveSet.insert("Hello");
  if (!caseInsensitiveSet.insert("hello").second) {
    std::cout &lt;&lt; "Duplicate insertion (case-insensitive) "
                 "detected.\n";
  }
  return 0;
}</pre>			<p>Here is <a id="_idIndexMarker418"/>the <span class="No-Break">example output:</span></p>
			<pre class="console">
6 was inserted into the set.
5 is already in the set.
3 is in the set.
Elements in the set: 3 4 5 6 8
After merging: 2 3 4 5 6 7 8 9
2 exists in the set.
Duplicate insertion (case-insensitive) detected.</pre>			<p>In this example, we did <span class="No-Break">the following:</span></p>
			<ul>
				<li>We demonstrated basic <strong class="source-inline">std::set</strong> operations such as insertion, finding an element, <span class="No-Break">and erasing.</span></li>
				<li>We showcased how a set inherently sorts its elements and how to iterate <span class="No-Break">over them.</span></li>
				<li>The use of the <strong class="source-inline">merge</strong> function was illustrated to merge another set into our <span class="No-Break">primary set.</span></li>
				<li>The <strong class="source-inline">count</strong> method was used to check for the existence of an element in a set, which can only be 0 or 1 due to the <span class="No-Break">uniqueness constraint.</span></li>
				<li>Lastly, we used a custom comparator to create a case-insensitive set <span class="No-Break">of strings.</span></li>
			</ul>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor252"/>Best practices</h2>
			<p>Let us explore <a id="_idIndexMarker419"/>the best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::set</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Understand access patterns</strong>: In <strong class="source-inline">std::set</strong>, access time is not constant as in <strong class="source-inline">std::vector</strong> or <strong class="source-inline">std::array</strong>. Due to its tree-based structure, element retrieval typically takes logarithmic time. When designing algorithms, factor <span class="No-Break">this in.</span></li>
				<li><strong class="bold">Understand its immutable nature</strong>: Once an element enters a <strong class="source-inline">std::set</strong> container, it is immutable. Altering it directly via an iterator could breach the set’s internal ordering. If modification is imperative, erase the old element and insert its <span class="No-Break">updated version.</span></li>
				<li><strong class="bold">Set selection criteria</strong>: If order significance doesn’t resonate with your use case, especially with voluminous data, lean toward <strong class="source-inline">std::unordered_set</strong>. Thanks to<a id="_idIndexMarker420"/> its hash-based design, it frequently trumps <strong class="source-inline">std::set</strong> in performance metrics, barring <span class="No-Break">worst-case scenarios.</span></li>
				<li><strong class="bold">Leverage in-place construction</strong>: Minimize overheads by using <strong class="source-inline">emplace</strong> to create elements right within a set. This technique forestalls unnecessary object copying <span class="No-Break">or movement.</span></li>
				<li><strong class="bold">Navigate element alterations</strong>: Direct tinkering of set elements is a no-go. The best approach when you need a modification is a two-step process: remove the original and introduce its <span class="No-Break">altered counterpart.</span></li>
				<li><strong class="bold">Check presence efficiently</strong>: The <strong class="source-inline">find</strong> method is your go-to for determining if an element resides in a set. It’s more succinct and expressive than <strong class="source-inline">count</strong> in the context of <strong class="source-inline">std::set</strong>, given a set’s unique <span class="No-Break">element nature.</span></li>
				<li><strong class="bold">Beware of comparator pitfalls</strong>: When supplying custom comparators, ensure they impose a strict weak ordering. A faulty comparator can disrupt a set’s internal balance, leading to erratic behavior. Always validate custom comparators against the standard library’s requirements using tools such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">std::is_sorted</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Address multithreading concerns:</strong> <strong class="source-inline">std::set</strong> is not intrinsically thread-safe. If concurrent access by multiple threads is anticipated, guard the set with synchronization primitives such as <strong class="source-inline">std::mutex</strong> or consider using concurrent containers provided by certain <span class="No-Break">C++ libraries.</span></li>
				<li><strong class="bold">Iteration insights</strong>: When iterating over a <strong class="source-inline">std::set</strong> container, remember that the <a id="_idIndexMarker421"/>elements are sorted. This can often obviate the need for additional sorting operations that you might apply on <span class="No-Break">other containers.</span></li>
				<li><strong class="bold">Size and capacity</strong>: Unlike <strong class="source-inline">std::vector</strong>, <strong class="source-inline">std::set</strong> doesn’t support <strong class="source-inline">reserve</strong> or <strong class="source-inline">capacity</strong> operations. The tree grows as elements are added. For efficiency, when removing elements, consider occasional <strong class="source-inline">shrink_to_fit</strong> operations available in <span class="No-Break">some implementations.</span></li>
			</ul>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor253"/>std::map</h1>
			<p>A <a id="_idIndexMarker422"/>sibling to the <strong class="source-inline">std::set</strong> container, <strong class="source-inline">std::map</strong> is about relationships. It connects unique keys to specific values, forming a pair. In layman’s terms, imagine a dictionary where each word (key) has a unique <span class="No-Break">definition (value).</span></p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor254"/>Purpose and suitability</h2>
			<p><strong class="source-inline">std::map</strong> is an <a id="_idIndexMarker423"/>ordered associative container that stores key-value pairs, ensuring unique keys. Its underlying data structure is typically a balanced binary tree (such as a <strong class="bold">red-black tree</strong> (<strong class="bold">RBT</strong>)). The main advantages include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Logarithmic access, insertion, and <span class="No-Break">deletion times</span></li>
				<li>Maintaining key-value pairs in sorted order <span class="No-Break">by keys</span></li>
			</ul>
			<p>Use <strong class="source-inline">std::map</strong> in the <a id="_idIndexMarker424"/><span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When you need to associate values with <span class="No-Break">unique keys</span></li>
				<li>When maintaining the order of keys <span class="No-Break">is important</span></li>
				<li>When frequent access, insertion, or deletion operations are required, and they need to <span class="No-Break">be efficient</span></li>
			</ul>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor255"/>Ideal use cases</h2>
			<p>The following are <a id="_idIndexMarker425"/>some ideal use cases <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::map</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Dictionary or phonebook</strong>: As with traditional dictionaries or phonebooks, <strong class="source-inline">std::map</strong> shines when associating unique keys with specific values. For example, it is useful when mapping a person’s name (unique key) to their contact details or a word to <span class="No-Break">its definition.</span></li>
				<li><strong class="bold">Configuration settings</strong>: When building software with configurable options, a <strong class="source-inline">std::map</strong> container can associate different configuration keys with their respective values, ensuring easy retrieval and modification <span class="No-Break">of settings.</span></li>
				<li><strong class="bold">Student record system</strong>: Educational institutions might maintain a record system where student IDs (ensured to be unique) act as keys, mapping to comprehensive student profiles comprising names, courses, grades, and <span class="No-Break">other details.</span></li>
				<li><strong class="bold">Frequency counter</strong>: When analyzing data, particularly in fields such as text processing or data analytics, it is common to determine the frequency of unique items. In such scenarios, <strong class="source-inline">std::map</strong> can associate distinct items with their occurrence counts, ensuring efficient updates <span class="No-Break">and retrievals.</span></li>
				<li><strong class="bold">Inverted index</strong>: An inverted index maps terms or keywords to a list of documents or locations in which they appear. It is commonly used in search engines and databases. Using a <strong class="source-inline">std::map</strong> container for this purpose ensures that terms are sorted and can be efficiently accessed <span class="No-Break">or updated.</span></li>
				<li><strong class="bold">Caching mechanisms</strong>: In systems where expensive computations are done repeatedly, caching the results for specific inputs can save time. <strong class="source-inline">std::map</strong> can serve as a cache, mapping input values to their <span class="No-Break">computed results.</span></li>
				<li><strong class="bold">Order-based operations</strong>: Since <strong class="source-inline">std::map</strong> inherently maintains its elements in sorted order based on its keys, it is apt for scenarios where operations dependent on this order are frequent – for example, fetching the <em class="italic">top 10</em> or <em class="italic">lowest 5</em> based on <span class="No-Break">some criteria.</span></li>
			</ul>
			<p>Always consider <a id="_idIndexMarker426"/>the specific needs of your problem. While <strong class="source-inline">std::map</strong> offers ordering and unique key-value association, if ordering isn’t required, <strong class="source-inline">std::unordered_map </strong>might be a more performance-efficient alternative due to its average constant-time complexity for <span class="No-Break">most operations.</span></p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor256"/>Performance</h2>
			<p>The algorithmic <a id="_idIndexMarker427"/>performance of <strong class="source-inline">std::map</strong> is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Insertion</strong>: <span class="No-Break"><em class="italic">O(log n)</em></span></li>
				<li><strong class="bold">Deletion</strong>: <span class="No-Break"><em class="italic">O(log n)</em></span></li>
				<li><strong class="bold">Access</strong>: <em class="italic">O(log n)</em> to locate <span class="No-Break">a key</span></li>
				<li><strong class="bold">Memory overhead</strong>: Generally higher than hash-based counterparts due to <span class="No-Break">tree-based structure</span></li>
			</ul>
			<p>The primary trade-off is balancing memory overhead with the efficiency of ordered operations and the flexibility of key-value <span class="No-Break">pair manipulation.</span></p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor257"/>Memory management</h2>
			<p><strong class="source-inline">std::map</strong> efficiently <a id="_idIndexMarker428"/>manages its memory internally, ensuring balanced trees. However, specific behavior can be influenced by custom allocators, allowing for <span class="No-Break">more control.</span></p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor258"/>Thread safety</h2>
			<p>Concurrent<a id="_idIndexMarker429"/> reads are safe. However, concurrent writes or mixed read-writes require external synchronization, such as <span class="No-Break">utilizing mutexes.</span></p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor259"/>Extensions and variants</h2>
			<p><strong class="source-inline">std::multimap</strong> allows <a id="_idIndexMarker430"/>multiple values per key, whereas <strong class="source-inline">std::unordered_map </strong>offers a hash-table-based alternative without ordering but with potential <em class="italic">O(1)</em> average <span class="No-Break">access times.</span></p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor260"/>Sorting and searching complexity</h2>
			<p>The<a id="_idIndexMarker431"/> sorting and search complexity is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Sorting</strong>: Being ordered, <strong class="source-inline">std::map</strong> inherently <span class="No-Break">maintains sorting</span></li>
				<li><strong class="bold">Searching</strong>: <span class="No-Break"><em class="italic">O(log n)</em></span></li>
			</ul>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor261"/>Special interface and member functions</h2>
			<p>Some<a id="_idIndexMarker432"/> handy <a id="_idIndexMarker433"/>member functions to note are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">emplace</strong>: Directly constructs a key-value pair <span class="No-Break">in place</span></li>
				<li><strong class="source-inline">at</strong>: Throws an exception if the key <span class="No-Break">doesn’t exist</span></li>
				<li><strong class="source-inline">operator[]</strong>: Accesses or creates a value for a <span class="No-Break">given key</span></li>
				<li><strong class="source-inline">lower_bound</strong> and <strong class="source-inline">upper_bound</strong>: Provide iterators pointing to positions relative to <span class="No-Break">a key</span></li>
			</ul>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor262"/>Comparisons</h2>
			<p>Compared<a id="_idIndexMarker434"/> to <strong class="source-inline">std::unordered_map</strong>, <strong class="source-inline">std::map</strong> excels in scenarios where key order matters or when the dataset might grow and shrink frequently. For situations demanding raw performance and where the order is insignificant, <strong class="source-inline">std::unordered_map</strong> might <span class="No-Break">be preferable.</span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor263"/>Interactions with algorithms</h2>
			<p>While <a id="_idIndexMarker435"/>many STL algorithms can work with <strong class="source-inline">std::map</strong>, its bidirectional iterators limit its compatibility with algorithms requiring <span class="No-Break">random access.</span></p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor264"/>Exceptions</h2>
			<p>Operations <a id="_idIndexMarker436"/>such as <strong class="source-inline">at()</strong> can throw out-of-range exceptions. Most operations on <strong class="source-inline">std::map</strong> provide strong exception safety, ensuring the map remains unchanged if an exception <span class="No-Break">is thrown.</span></p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor265"/>Customization</h2>
			<p>You<a id="_idIndexMarker437"/> can provide custom comparators to dictate the order of keys or use custom allocators to influence <span class="No-Break">memory management.</span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor266"/>Example</h2>
			<p>In <strong class="source-inline">std::map</strong>, keys are <a id="_idIndexMarker438"/>sorted and unique, making it easy to find specific entries. The following code is an example illustrating best practices when <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::map</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
int main() {
  std::map&lt;std::string, int&gt; ageMap = {
      {"Lisa", 25}, {"Corbin", 30}, {"Aaron", 22}};
  ageMap["Kristan"] = 28;
  ageMap.insert_or_assign("Lisa", 26);
  if (ageMap.find("Corbin") != ageMap.end()) {
    std::cout &lt;&lt; "Corbin exists in the map.\n";
  }
  ageMap["Aaron"] += 1;
  std::cout &lt;&lt; "Age records:\n";
  for (const auto &amp;[name, age] : ageMap) {
    std::cout &lt;&lt; name &lt;&lt; ": " &lt;&lt; age &lt;&lt; '\n';
  }
  ageMap.erase("Corbin");
  if (ageMap.count("Regan") == 0) {
    std::cout &lt;&lt; "Regan does not exist in the map.\n";
  }
  std::map&lt;std::string, int,
           bool (*)(const std::string &amp;,
                    const std::string &amp;)&gt;
      customOrderMap{[](const std::string &amp;lhs,
                        const std::string &amp;rhs) {
        return lhs &gt; rhs; // reverse lexicographic order
      }};
  customOrderMap["Lisa"] = 25;
  customOrderMap["Corbin"] = 30;
  customOrderMap["Aaron"] = 22;
  std::cout &lt;&lt; "Custom ordered map:\n";
  for (const auto &amp;[name, age] : customOrderMap) {
    std::cout &lt;&lt; name &lt;&lt; ": " &lt;&lt; age &lt;&lt; '\n';
  }
  return 0;
}</pre>			<p>Here is the<a id="_idIndexMarker439"/> <span class="No-Break">example output:</span></p>
			<pre class="console">
Corbin exists in the map.
Age records:
Aaron: 23
Corbin: 30
Kristan: 28
Lisa: 26
Regan does not exist in the map.
Custom ordered map:
Lisa: 25
Corbin: 30
Aaron: 22</pre>			<p>In this example, we did <span class="No-Break">the following:</span></p>
			<ul>
				<li>We<a id="_idIndexMarker440"/> demonstrated the basic operations of <strong class="source-inline">std::map</strong>, such as insertion, modification, checking for the existence of a key, and iterating over <span class="No-Break">its elements.</span></li>
				<li>We used structured bindings (C++17) to restructure the key-value pairs <span class="No-Break">when iterating.</span></li>
				<li>We illustrated the use of <strong class="source-inline">count</strong> to check if a key exists in <span class="No-Break">the map.</span></li>
				<li>We created a custom-ordered map by providing a custom comparator that sorts the keys in reverse <span class="No-Break">lexicographical order.</span></li>
			</ul>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor267"/>Best practices</h2>
			<p>Let us explore the<a id="_idIndexMarker441"/> best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::map</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Immutable key principle</strong>: Once a key-value pair is inserted into <strong class="source-inline">std::map</strong>, the key remains constant for the lifetime of that element. Modifying it directly is not allowed. Should you need to update the key, the correct approach is to remove the old key-value pair and insert a new one with the <span class="No-Break">desired key.</span></li>
				<li><strong class="bold">Select appropriate containers</strong>: If maintaining the order of the key-value pairs is not a requirement, consider leveraging <strong class="source-inline">std::unordered_map</strong>. Its hash table-based implementation may offer faster average-time complexities for many operations compared to the RBT of <strong class="source-inline">std::map</strong>, reducing <span class="No-Break">potential overhead.</span></li>
				<li><strong class="bold">Efficient insertions with emplace</strong>: Utilize the <strong class="source-inline">emplace</strong> method, which constructs the element in place within the map, avoiding temporary object creation and unnecessary copies. When paired with tools such as <strong class="source-inline">std::make_pair</strong> or <strong class="source-inline">std::piecewise_construct</strong>, it optimizes performance <span class="No-Break">for insertions.</span></li>
				<li><strong class="bold">Safe key access</strong>: The <strong class="source-inline">operator[]</strong> method, though convenient, can be a double-edged sword. If the specified key does not exist, it inserts the key with a default-initialized value into the map. When you wish to only query, without potential insertions, use the <strong class="source-inline">find</strong> method instead. The <strong class="source-inline">find</strong> method returns an iterator to the element if found and to the <strong class="source-inline">end()</strong> method <span class="No-Break">if not.</span></li>
				<li><strong class="bold">Custom sorting with comparators</strong>: The default sorting of <strong class="source-inline">std::map</strong> might not always fit the use case. You can customize the order by providing a comparator when defining the map. Ensure this comparator enforces a strict weak ordering to maintain the integrity of the map’s <span class="No-Break">internal structures.</span></li>
				<li><strong class="bold">Concurrency and synchronization</strong>: In environments where multiple threads<a id="_idIndexMarker442"/> access a <strong class="source-inline">std::map</strong> container, synchronization becomes imperative. Consider using <strong class="source-inline">std::mutex</strong> or other STL synchronization primitives to lock access during write operations, preserving <span class="No-Break">data consistency.</span></li>
				<li><strong class="bold">Efficient membership checks</strong>: When validating whether a key exists, use the <strong class="source-inline">count</strong> method for a direct count result. For a map, this will always return <strong class="source-inline">0</strong> or <strong class="source-inline">1</strong>, making it a fast way to <span class="No-Break">check membership.</span></li>
				<li><strong class="bold">Iterators and erasure</strong>: When erasing elements using iterators, remember that the <strong class="source-inline">erase</strong> operation invalidates the iterator. Use the returned iterator from <strong class="source-inline">erase</strong> to continue <span class="No-Break">operations safely.</span></li>
				<li><strong class="bold">Range operations</strong>: For bulk operations, <strong class="source-inline">std::map</strong> offers range methods such as <strong class="source-inline">equal_range</strong>, which can return the bounds of a subrange of elements with keys equivalent to a given key. Utilize them for efficient <span class="No-Break">subrange manipulations.</span></li>
				<li><strong class="bold">Memory management with allocators</strong>: If specific memory management behaviors are required, remember that <strong class="source-inline">std::map</strong> supports custom allocators. This allows for better control over allocation and <span class="No-Break">deallocation processes.</span></li>
			</ul>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor268"/>std::multiset</h1>
			<p>While a <strong class="source-inline">std::set</strong> container<a id="_idIndexMarker443"/> prides itself on its exclusivity, <strong class="source-inline">std::multiset</strong> is a bit more accommodating. It still maintains order, but it allows multiple elements to have the same value. This container is like a club where members have ranks, but there’s room for more than one member at <span class="No-Break">each rank.</span></p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor269"/>Purpose and suitability</h2>
			<p><strong class="source-inline">std::multiset</strong> is an <a id="_idIndexMarker444"/>associative container that stores sorted elements and allows multiple occurrences of an element. Its key strengths are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Maintaining a sorted order <span class="No-Break">of elements</span></li>
				<li><span class="No-Break">Allowing duplicates</span></li>
				<li>Offering logarithmic time complexity for insertion, deletion, <span class="No-Break">and search</span></li>
			</ul>
			<p>It’s particularly<a id="_idIndexMarker445"/> suitable in the <span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When duplicate values need to <span class="No-Break">be retained</span></li>
				<li>When you require elements to always <span class="No-Break">remain sorted</span></li>
				<li>When random access is not <span class="No-Break">a necessity</span></li>
			</ul>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor270"/>Ideal use cases</h2>
			<p>The following <a id="_idIndexMarker446"/>are some ideal use cases <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">std::multiset</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Ranking systems</strong>: In scenarios such as gaming leaderboards or student grade systems where multiple entities might have identical scores or grades, a <strong class="source-inline">std::multiset</strong> container is beneficial. It allows for the storage of duplicate values while maintaining them in a <span class="No-Break">sorted order.</span></li>
				<li><strong class="bold">Statistics calculations</strong>: When working with a set of numerical data and needing to compute the median, mode, or other statistics, a <strong class="source-inline">std::multiset</strong> container is invaluable due to its inherent sorted nature and its ability to accommodate <span class="No-Break">repeated numbers.</span></li>
				<li><strong class="bold">Event management</strong>: In events where attendees can select multiple time slots or sessions they’re interested in, a <strong class="source-inline">std::multiset</strong> container can help in efficiently <a id="_idIndexMarker447"/>managing and tracking these selections, especially when a popular session is chosen <span class="No-Break">multiple times.</span></li>
				<li><strong class="bold">Inventory management</strong>: In businesses, certain items can be more popular and purchased more frequently. A <strong class="source-inline">std::multiset</strong> container can represent such items, allowing easy tracking and replenishment based <span class="No-Break">on demand.</span></li>
				<li><strong class="bold">Document term frequency</strong>: In text processing or search engine scenarios, while an inverted index (such as with <strong class="source-inline">std::map</strong>) maps terms to documents, a <strong class="source-inline">std::multiset</strong> container can be used to keep track of how frequently terms appear across multiple documents, even if some terms are common and <span class="No-Break">appear repeatedly.</span></li>
				<li><strong class="bold">Spatial data structures</strong>: In computational geometry or graphics, structures such as sweep line algorithms use <strong class="source-inline">std::multiset</strong> to manage events or points efficiently, especially when multiple events share the <span class="No-Break">same position.</span></li>
				<li><strong class="bold">Handling collisions</strong>: In scenarios where collisions (identical values from different sources) are expected and need to be retained for further processing, <span class="No-Break"><strong class="source-inline">std::multiset</strong></span><span class="No-Break"> shines.</span></li>
			</ul>
			<p>Remember, while <strong class="source-inline">std::multiset</strong> is designed to handle multiple instances of the same value in a sorted manner, if the sorted property isn’t essential and you want to keep track of multiple items, structures such as <strong class="source-inline">std::unordered_multiset</strong> can be more performance-efficient in some cases due to <span class="No-Break">hash-based implementations.</span></p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor271"/>Performance</h2>
			<p>The<a id="_idIndexMarker448"/> algorithmic performance of <strong class="source-inline">std::multiset</strong> is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Insertion</strong>: <span class="No-Break"><em class="italic">O(log n)</em></span></li>
				<li><strong class="bold">Deletion</strong>: <span class="No-Break"><em class="italic">O(log n)</em></span></li>
				<li><strong class="bold">Access</strong>: Elements are accessed in <em class="italic">O(log </em><span class="No-Break"><em class="italic">n)</em></span><span class="No-Break"> time</span></li>
				<li><strong class="bold">Memory overhead</strong>: Overhead is present due to internal balancing (typically implemented as a balanced binary <span class="No-Break">search tree)</span></li>
			</ul>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor272"/>Memory management</h2>
			<p><strong class="source-inline">std::multiset</strong> does not dynamically resize like <strong class="source-inline">std::vector</strong>. Instead, it uses dynamic<a id="_idIndexMarker449"/> memory allocation for nodes as elements are inserted. Allocators can influence node <span class="No-Break">memory management.</span></p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor273"/>Thread safety</h2>
			<p>Concurrent <a id="_idIndexMarker450"/>reads are safe. However, modifications (insertions or deletions) require external synchronization. Utilizing mutexes or other synchronization primitives is recommended for <span class="No-Break">concurrent writes.</span></p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor274"/>Extensions and variants</h2>
			<p><strong class="source-inline">std::set</strong> is a direct <a id="_idIndexMarker451"/>variant that disallows duplicates. There’s also <strong class="source-inline">std::unordered_multiset</strong>, which offers average constant-time complexity for operations but does not <span class="No-Break">maintain order.</span></p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor275"/>Sorting and searching complexity</h2>
			<p>The <a id="_idIndexMarker452"/>sorting and search complexity is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Sorting</strong>: Elements are always sorted; thus, no sort operation <span class="No-Break">is required</span></li>
				<li><strong class="bold">Searching</strong>: <em class="italic">O(log n)</em> due to its <span class="No-Break">tree-based nature</span></li>
			</ul>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor276"/>Special interface and member functions</h2>
			<p>While it <a id="_idIndexMarker453"/>provides<a id="_idIndexMarker454"/> regular functions (<strong class="source-inline">insert</strong>, <strong class="source-inline">erase</strong>, <strong class="source-inline">find</strong>), some handy ones include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">count</strong>: Returns the total number of elements matching a <span class="No-Break">specified key</span></li>
				<li><strong class="source-inline">equal_range</strong>: Provides range (iterators) of all instances of <span class="No-Break">an element</span></li>
			</ul>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor277"/>Comparisons</h2>
			<p>Against <strong class="source-inline">std::set</strong>, <strong class="source-inline">std::multiset</strong> allows duplicates but at the cost of slightly increased <a id="_idIndexMarker455"/>memory. Against sequence containers such as <strong class="source-inline">std::vector</strong>, it maintains sorted order but doesn’t offer <span class="No-Break">constant-time access.</span></p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor278"/>Interactions with algorithms</h2>
			<p>Algorithms <a id="_idIndexMarker456"/>that benefit from sorted data (such as binary searches or set operations) work well with <strong class="source-inline">std::multiset</strong>. Those requiring random access or frequent reordering might not <span class="No-Break">be suitable.</span></p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor279"/>Exceptions</h2>
			<p>Memory <a id="_idIndexMarker457"/>allocation failures can throw exceptions. Most <strong class="source-inline">std::multiset</strong> operations provide strong <span class="No-Break">exception-safety guarantees.</span></p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor280"/>Customization</h2>
			<p>In <strong class="source-inline">std::multiset</strong>, customization<a id="_idIndexMarker458"/> entails <span class="No-Break">the following:</span></p>
			<ul>
				<li>Custom allocators can be used to control <span class="No-Break">memory allocation.</span></li>
				<li>Custom comparators can be provided to dictate the order of <span class="No-Break">element storage.</span></li>
			</ul>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor281"/>Example</h2>
			<p><strong class="source-inline">std::multiset</strong> is a <a id="_idIndexMarker459"/>container that can store multiple keys, including duplicate keys. The keys are always sorted from the lowest key to the highest. <strong class="source-inline">std::multiset</strong> is typically used in situations where you need to maintain a sorted set of elements, and duplicates <span class="No-Break">are allowed.</span></p>
			<p>The following code is an example of using <strong class="source-inline">std::multiset</strong>, demonstrating some of its unique features and <span class="No-Break">best practices:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;set&gt;
#include &lt;string&gt;
int main() {
  std::multiset&lt;int&gt; numbers = {5, 3, 8, 5, 3, 9, 4};
  numbers.insert(6);
  numbers.insert(5); // Inserting another duplicate
  for (int num : numbers) { std::cout &lt;&lt; num &lt;&lt; ' '; }
  std::cout &lt;&lt; '\n';
  std::cout &lt;&lt; "Number of 5s: " &lt;&lt; numbers.count(5)
            &lt;&lt; '\n';
  auto [begin, end] = numbers.equal_range(5);
  for (auto it = begin; it != end; ++it) {
    std::cout &lt;&lt; *it &lt;&lt; ' ';
  }
  std::cout &lt;&lt; '\n';
  numbers.erase(5);
  std::multiset&lt;std::string, std::greater&lt;&gt;&gt; words = {
      "apple", "banana", "cherry", "apple"};
  for (const auto &amp;word : words) {
    std::cout &lt;&lt; word &lt;&lt; ' ';
  }
  std::cout &lt;&lt; '\n';
  std::multiset&lt;int&gt; dataset = {1, 2, 3, 4, 5,
                                6, 7, 8, 9, 10};
  const auto start = dataset.lower_bound(4);
  const auto stop = dataset.upper_bound(7);
  std::copy(start, stop,
            std::ostream_iterator&lt;int&gt;(std::cout, " "));
  std::cout &lt;&lt; '\n';
  return 0;
}</pre>			<p>Here is the <span class="No-Break">example output:</span></p>
			<pre class="console">
3 3 4 5 5 5 6 8 9
Number of 5s: 3
5 5 5
cherry banana apple apple
4 5 6 7</pre>			<p>Key takeaways <a id="_idIndexMarker460"/>from the preceding example are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">std::multiset</strong> automatically <span class="No-Break">sorts keys.</span></li>
				<li>It can store duplicate keys, and this property can be utilized for certain algorithms or storage patterns where duplicates <span class="No-Break">are meaningful.</span></li>
				<li>Using <strong class="source-inline">equal_range</strong> is a best practice to find all instances of a key. This method returns both the beginning and the end iterators, covering all instances of <span class="No-Break">the key.</span></li>
				<li>Custom comparators, such as <strong class="source-inline">std::greater&lt;&gt;</strong>, can be used to reverse the <span class="No-Break">default ordering.</span></li>
				<li><strong class="source-inline">lower_bound</strong> and <strong class="source-inline">upper_bound</strong> can be used for efficient <span class="No-Break">range queries.</span></li>
			</ul>
			<p>Remember, if you don’t need to store duplicates, then <strong class="source-inline">std::set</strong> is a more <span class="No-Break">appropriate choice.</span></p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor282"/>Best practices</h2>
			<p>Let us explore <a id="_idIndexMarker461"/>the best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::multiset</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Select the appropriate set type</strong>: If the dataset doesn’t necessitate duplicate values, avoid using <strong class="source-inline">std::multiset</strong> to prevent undue overhead. Instead, favor <strong class="source-inline">std::set</strong>, which inherently manages unique elements and can be <span class="No-Break">more efficient.</span></li>
				<li><strong class="bold">Understand access characteristics</strong>: Remember that <strong class="source-inline">std::multiset</strong> doesn’t offer the same constant-time access that <strong class="source-inline">std::vector</strong> provides. Accessing elements is logarithmic in complexity due to the underlying <a id="_idIndexMarker462"/>tree-based <span class="No-Break">data structure.</span></li>
				<li><strong class="bold">Account for memory consumption</strong>: The ability of <strong class="source-inline">std::multiset</strong> to hold duplicate elements can lead to elevated memory usage, especially when those duplicates are numerous. It’s crucial to analyze memory requirements and ensure the container’s suitability for <span class="No-Break">the application.</span></li>
				<li><strong class="bold">Custom comparator considerations</strong>: When employing a custom comparator for sorting elements within <strong class="source-inline">std::multiset</strong>, ensure that it imposes a strict weak ordering. Any inconsistency in ordering can lead to undefined behavior. Test the comparator rigorously to confirm <span class="No-Break">its reliability.</span></li>
				<li><strong class="bold">Leverage member functions for element queries</strong>: Instead of manually iterating over the multiset to check for an element’s existence, take advantage of the <strong class="source-inline">find</strong> and <strong class="source-inline">count</strong> member functions. They offer a more efficient and direct way to perform <span class="No-Break">such checks.</span></li>
				<li><strong class="bold">Be decisive about duplicates</strong>: Before opting for <strong class="source-inline">std::multiset</strong>, clearly outline the reasons for needing duplicate entries. If the rationale isn’t strong, or duplicates don’t benefit your application logic significantly, consider <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::set</strong></span><span class="No-Break">.</span></li>
			</ul>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor283"/>std::multimap</h1>
			<p>Extending the<a id="_idIndexMarker463"/> principles of <strong class="source-inline">std::map</strong>, the <strong class="source-inline">std::multimap</strong> container allows for one key to be associated with multiple values. It’s like a dictionary where a word might have several <span class="No-Break">related definitions.</span></p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor284"/>Purpose and suitability</h2>
			<p><strong class="source-inline">std::multimap</strong> is an<a id="_idIndexMarker464"/> associative container within the STL. Its distinguishing features are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Storing <span class="No-Break">key-value pairs</span></li>
				<li>Allowing multiple values with the <span class="No-Break">same key</span></li>
				<li>Storing elements in a sorted manner, as determined by <span class="No-Break">the key</span></li>
			</ul>
			<p>It’s particularly<a id="_idIndexMarker465"/> suitable in the <span class="No-Break">following scenarios:</span></p>
			<ul>
				<li>When you need to maintain a collection with <span class="No-Break">non-unique keys</span></li>
				<li>When you want sorted access based <span class="No-Break">on keys</span></li>
				<li>When key-value mapping <span class="No-Break">is paramount</span></li>
			</ul>
			<p>Choose <strong class="source-inline">std::multimap</strong> when you expect multiple values under the same key. If unique keys are necessary, you might want to look <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">std::map</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor285"/>Ideal use cases</h2>
			<p>The following are<a id="_idIndexMarker466"/> some ideal use cases <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::multimap</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Multiple entries per key</strong>: Consider a business directory where a single business name (key) might have multiple branches or phone numbers (values). Using <strong class="source-inline">std::multimap</strong>, you can associate one key with <span class="No-Break">several values.</span></li>
				<li><strong class="bold">Multi-language dictionary</strong>: In a language translation application, a single word in one language might have multiple translations in another. A <strong class="source-inline">std::multimap</strong> container can effectively map these <span class="No-Break">multiple meanings.</span></li>
				<li><strong class="bold">Airport flight schedules</strong>: Airports can have multiple flights departing to the same destination at different times. A <strong class="source-inline">std::multimap</strong> container can associate a destination (key) with various flight details or <span class="No-Break">times (values).</span></li>
				<li><strong class="bold">Event scheduling</strong>: For event managers, a particular date (key) might have several <a id="_idIndexMarker467"/>events or tasks. Using <strong class="source-inline">std::multimap</strong>, one can easily keep track of all events for a <span class="No-Break">specific date.</span></li>
				<li><strong class="bold">Graph representations</strong>: In computational structures, a node in a graph might be connected to multiple other nodes. Representing such relationships using <strong class="source-inline">std::multimap</strong> can be handy, especially when weights or other data associated with the edges <span class="No-Break">are required.</span></li>
				<li><strong class="bold">Course enrollment systems</strong>: In educational institutions, a single course (key) can have multiple enrolled students or multiple instructors (values). This system can be easily managed using a <span class="No-Break"><strong class="source-inline">std::multimap</strong></span><span class="No-Break"> container.</span></li>
				<li><strong class="bold">Patient record systems</strong>: In healthcare, a specific doctor (key) might see multiple patients or have several appointments (values) on a particular day. A <strong class="source-inline">std::multimap</strong> container is apt for such <span class="No-Break">use cases.</span></li>
				<li><strong class="bold">Media tagging systems</strong>: In media libraries, a particular tag or category (key) can be associated with multiple songs, videos, or photos (values). Using <strong class="source-inline">std::multimap</strong> helps in organizing and retrieving media based on <span class="No-Break">tags efficiently.</span></li>
			</ul>
			<p>Remember that <strong class="source-inline">std::multimap</strong> is a go-to when one-to-many relationships are prevalent. However, if order and sorting aren’t crucial and efficient retrieval is more important, considering structures such as <strong class="source-inline">std::unordered_multimap</strong> can be beneficial due to their <span class="No-Break">hash-based nature.</span></p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor286"/>Performance</h2>
			<p>The <a id="_idIndexMarker468"/>algorithmic performance of std::multimap is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Insertion</strong>: Logarithmic <em class="italic">O(log n)</em> in <span class="No-Break">most cases</span></li>
				<li><strong class="bold">Deletion</strong>: Logarithmic <em class="italic">O(log </em><span class="No-Break"><em class="italic">n)</em></span><span class="No-Break"> generally</span></li>
				<li><strong class="bold">Access</strong>: <em class="italic">O(log n)</em> for <span class="No-Break">specific keys</span></li>
				<li><strong class="bold">Memory overhead</strong>: It is a bit higher due to maintaining the tree-based structure and <span class="No-Break">potential balancing</span></li>
			</ul>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor287"/>Memory management</h2>
			<p><strong class="source-inline">std::multimap</strong> internally<a id="_idIndexMarker469"/> employs a tree structure, typically an RBT. Thus, memory allocation and balancing operations can occur. Allocators can influence its <span class="No-Break">memory handling.</span></p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor288"/>Thread safety</h2>
			<p>Multiple reads<a id="_idIndexMarker470"/> are safe. However, writes or combinations of reads and writes require external synchronization. Using tools such as mutexes <span class="No-Break">is advisable.</span></p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor289"/>Extensions and variants</h2>
			<p>For <a id="_idIndexMarker471"/>hash-table-based key-value mapping, consider <strong class="source-inline">std::unordered_multimap</strong>. For unique key-value mapping, <strong class="source-inline">std::map</strong> is <span class="No-Break">more appropriate.</span></p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor290"/>Sorting and searching complexity</h2>
			<p>The<a id="_idIndexMarker472"/> sorting and search complexity is characterized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Sorting</strong>: Sorting is inherent, as elements are maintained in <span class="No-Break">key order</span></li>
				<li><strong class="bold">Searching</strong>: <em class="italic">O(log n)</em> to locate a <span class="No-Break">specific key</span></li>
			</ul>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor291"/>Special interface and member functions</h2>
			<p>Standard <a id="_idIndexMarker473"/>functions<a id="_idIndexMarker474"/> such as <strong class="source-inline">insert</strong>, <strong class="source-inline">erase</strong>, and <strong class="source-inline">find</strong> are available. The following are <span class="No-Break">also available:</span></p>
			<ul>
				<li><strong class="source-inline">count</strong>: Returns the number of elements with a <span class="No-Break">particular key</span></li>
				<li><strong class="source-inline">equal_range</strong>: Retrieves the range of elements with a <span class="No-Break">specific key</span></li>
			</ul>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor292"/>Comparisons</h2>
			<p>Against <strong class="source-inline">std::unordered_multimap</strong>, <strong class="source-inline">std::multimap</strong> offers ordered access but might <a id="_idIndexMarker475"/>have a slightly higher overhead due to its <span class="No-Break">tree-based nature.</span></p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor293"/>Interactions with algorithms</h2>
			<p>Since <strong class="source-inline">std::multimap</strong> maintains<a id="_idIndexMarker476"/> ordered access, algorithms that benefit from sorted data (such as <strong class="source-inline">std::set_intersection</strong>) can be useful. However, remember that data <span class="No-Break">is key-ordered.</span></p>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor294"/>Exceptions</h2>
			<p>Trying<a id="_idIndexMarker477"/> to access non-existent keys or out-of-bound scenarios can throw exceptions. Most operations are strongly exception-safe, ensuring the container remains valid even if an exception <span class="No-Break">is thrown.</span></p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor295"/>Customization</h2>
			<p>Custom<a id="_idIndexMarker478"/> allocators can refine memory management. <strong class="source-inline">std::multimap</strong> also allows custom comparators to dictate the ordering <span class="No-Break">of keys.</span></p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor296"/>Example</h2>
			<p><strong class="source-inline">std::multimap</strong> is a <a id="_idIndexMarker479"/>container that maintains a collection of key-value pairs, where multiple pairs can have the same key. The keys in <strong class="source-inline">std::multimap</strong> are <span class="No-Break">always sorted.</span></p>
			<p>The following code is an example of using <strong class="source-inline">std::multimap</strong>, demonstrating some of its unique features and <span class="No-Break">best practices:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
int main() {
  std::multimap&lt;std::string, int&gt; grades;
  grades.insert({"John", 85});
  grades.insert({"Corbin", 78});
  grades.insert({"Regan", 92});
  grades.insert({"John", 90}); // John has another grade
  for (const auto &amp;[name, score] : grades) {
    std::cout &lt;&lt; name &lt;&lt; " scored " &lt;&lt; score &lt;&lt; '\n';
  }
  std::cout &lt;&lt; '\n';
  std::cout &lt;&lt; "John's grade count:"
            &lt;&lt; grades.count("John") &lt;&lt; '\n';
  auto [begin, end] = grades.equal_range("John");
  for (auto it = begin; it != end; ++it) {
    std::cout &lt;&lt; it-&gt;first &lt;&lt; " scored " &lt;&lt; it-&gt;second
              &lt;&lt; '\n';
  }
  std::cout &lt;&lt; '\n';
  grades.erase("John");
  std::multimap&lt;std::string, int, std::greater&lt;&gt;&gt;
      reverseGrades = {{"Mandy", 82},
                       {"Mandy", 87},
                       {"Aaron", 90},
                       {"Dan", 76}};
  for (const auto &amp;[name, score] : reverseGrades) {
    std::cout &lt;&lt; name &lt;&lt; " scored " &lt;&lt; score &lt;&lt; '\n';
  }
  return 0;
}</pre>			<p>Here is the <a id="_idIndexMarker480"/><span class="No-Break">example output:</span></p>
			<pre class="console">
Corbin scored 78
John scored 85
John scored 90
Regan scored 92
John's grade count:2
John scored 85
John scored 90
Mandy scored 82
Mandy scored 87
Dan scored 76
Aaron scored 90</pre>			<p>Key takeaways<a id="_idIndexMarker481"/> from the preceding code are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">std::multimap</strong> automatically <span class="No-Break">sorts keys.</span></li>
				<li>It can store multiple key-value pairs with the <span class="No-Break">same key.</span></li>
				<li>Using <strong class="source-inline">equal_range</strong> is a best practice to find all instances of a key. This method returns both the beginning and the end iterators, covering all instances of <span class="No-Break">the key.</span></li>
				<li><strong class="source-inline">grades.count("John")</strong> efficiently counts the number of key-value pairs with the <span class="No-Break">specified key.</span></li>
				<li>Custom comparators, such as <strong class="source-inline">std::greater&lt;&gt;</strong>, can change the ordering from the default ascending order <span class="No-Break">to descending.</span></li>
			</ul>
			<p>A <strong class="source-inline">std::multimap</strong> container is useful when you need a dictionary-like data structure that supports duplicate keys. If duplicates aren’t needed, <strong class="source-inline">std::map</strong> would be a more <span class="No-Break">appropriate choice.</span></p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor297"/>Best practices</h2>
			<p>Let us<a id="_idIndexMarker482"/> explore the best practices of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">std::multimap</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Understand access time</strong>: Do not expect constant-time access from <strong class="source-inline">std::multimap</strong>. The access complexity is logarithmic, attributed to its <span class="No-Break">tree-based underpinning.</span></li>
				<li><strong class="bold">Recognize it is distinctly different from std::map</strong>: It’s essential not to mistakenly assume that keys in <strong class="source-inline">std::multimap</strong> are unique, as in <strong class="source-inline">std::map</strong>. A <strong class="source-inline">std::multimap</strong> container permits multiple entries for a single key. If your application demands unique keys, then <strong class="source-inline">std::map</strong> is the <span class="No-Break">appropriate choice.</span></li>
				<li><strong class="bold">Harness its sorted property</strong>: One of the strengths of <strong class="source-inline">std::multimap</strong> is the inherent sorted nature of its elements based on the keys. Exploit this characteristic to your advantage, especially when performing operations that benefit from ordered data, such as range searches or <span class="No-Break">ordered merges.</span></li>
				<li><strong class="bold">Contemplate on order significance</strong>: If maintaining the order of elements is not a paramount requirement, and you prioritize average-case performance, <strong class="source-inline">std::unordered_multimap</strong> might be a more fitting alternative due to its hashing mechanism. However, it is worth noting that worst-case performance and memory overheads <span class="No-Break">can differ.</span></li>
				<li><strong class="bold">Verify key existence prior to access</strong>: Before retrieving values associated with a key, ensure the key’s presence in the multimap. This can be accomplished using member functions such as <strong class="source-inline">find</strong> or <strong class="source-inline">count</strong>. It helps prevent potential pitfalls and ensure <span class="No-Break">robust code.</span></li>
				<li><strong class="bold">Use custom comparators for tailored sorting</strong>: Should you have a specific ordering requirement that deviates from the default, use custom comparators. Ensure that your comparator enforces a strict weak ordering to guarantee consistent and defined behavior of <span class="No-Break">the multimap.</span></li>
				<li><strong class="bold">Efficiently handle multiple values for a key</strong>: When dealing with a key with multiple associated values, use the <strong class="source-inline">equal_range</strong> member function. It provides a range (beginning and end iterators) of all elements with a particular key, enabling efficient iteration over those <span class="No-Break">specific elements.</span></li>
				<li><strong class="bold">Beware of large datasets</strong>: As with any tree-based structure, <strong class="source-inline">std::multimap</strong> can become inefficient with large datasets, especially if frequent insertions <a id="_idIndexMarker483"/>and deletions are commonplace. In such scenarios, evaluate the structure’s performance and consider alternatives or <span class="No-Break">optimization strategies.</span></li>
			</ul>
		</div>
	</body></html>