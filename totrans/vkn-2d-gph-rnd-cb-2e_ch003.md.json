["```cpp\n{\n  “name”: “ lightweightvk “,\n  “source”: {\n    “type”: “git”,\n    “url”: “ https://github.com/corporateshark/lightweightvk.git “,\n    “revision”: “1.0”\n  }\n}\n```", "```cpp\n#define VK_ASSERT(func) {                                          \\\n    const VkResult vk_assert_result = func;                        \\\n    if (vk_assert_result != VK_SUCCESS) {                          \\\n      LLOGW(“Vulkan API call failed: %s:%i\\n  %s\\n  %s\\n”,         \\\n                    __FILE__, __LINE__, #func,                     \\\n                    ivkGetVulkanResultString(vk_assert_result));   \\\n      assert(false);                                               \\\n    }                                                              \\\n  }\n```", "```cpp\n#define VK_ASSERT_RETURN(func) {                                   \\\n    const VkResult vk_assert_result = func;                        \\\n    if (vk_assert_result != VK_SUCCESS) {                          \\\n      LLOGW(“Vulkan API call failed: %s:%i\\n  %s\\n  %s\\n”,         \\\n                    __FILE__, __LINE__, #func,                     \\\n                    ivkGetVulkanResultString(vk_assert_result));   \\\n      assert(false);                                               \\\n      return getResultFromVkResult(vk_assert_result);              \\\n    }                                                              \\\n  }\n```", "```cpp\nint main(void) {\n  minilog::initialize(nullptr, { .threadNames = false });\n  int width  = 960;\n  int height = 540;\n  GLFWwindow* window = lvk::initWindow(\n    “Simple example”, width, height);\n  std::unique_ptr<lvk::IContext> ctx =\n    lvk::createVulkanContextWithSwapchain(window, width, height, {});\n```", "```cpp\n while (!glfwWindowShouldClose(window)) {\n    glfwPollEvents();\n    glfwGetFramebufferSize(window, &width, &height);\n    if (!width || !height) continue;\n    lvk::ICommandBuffer& buf = device->acquireCommandBuffer();\n    ctx->submit(buf, ctx->getCurrentSwapchainTexture());\n  }\n```", "```cpp\n ctx.reset();\n  glfwDestroyWindow(window);\n  glfwTerminate();\n  return 0;\n}\n```", "```cpp\nstd::unique_ptr<lvk::IContext> createVulkanContextWithSwapchain(\n  GLFWwindow* window, uint32_t width, uint32_t height,\n  const lvk::vulkan::VulkanContextConfig& cfg,\n  lvk::HWDeviceType preferredDeviceType = lvk::HWDeviceType_Discrete) {\n  std::unique_ptr<vulkan::VulkanContext> ctx;\n#if defined(_WIN32)\n  ctx = std::make_unique<vulkan::VulkanContext>(\n    cfg, (void*)glfwGetWin32Window(window));\n#elif defined(__linux__)\n  ctx = std::make_unique<vulkan::VulkanContext>(\n    cfg, (void*)glfwGetX11Window(window), (void*)glfwGetX11Display());\n#else\n#  error Unsupported OS\n#endif\n```", "```cpp\n std::vector<HWDeviceDesc> devices;\n  Result res = ctx->queryDevices(preferredDeviceType, devices);\n  if (devices.empty()) {\n    if (preferredDeviceType == HWDeviceType_Discrete) {\n      res = ctx->queryDevices(HWDeviceType_Integrated, devices);\n    }\n    if (preferredDeviceType == HWDeviceType_Integrated) {\n      res = ctx->queryDevices(HWDeviceType_Discrete, devices);\n    }\n  }\n```", "```cpp\n if (!res.isOk() || devices.empty()) return nullptr;\n  res = ctx->initContext(devices[0]);\n  if (!res.isOk()) return nullptr;\n```", "```cpp\n if (width > 0 && height > 0) {\n    res = ctx->initSwapchain(width, height);\n    if (!res.isOk()) return nullptr;\n  }\n  return std::move(ctx);\n}\n```", "```cpp\nvoid VulkanContext::createInstance() {\n  vkInstance_ = VK_NULL_HANDLE;\n  const char* instanceExtensionNames[] = {\n    VK_KHR_SURFACE_EXTENSION_NAME,\n    VK_EXT_DEBUG_UTILS_EXTENSION_NAME,\n#if defined(_WIN32)\n    VK_KHR_WIN32_SURFACE_EXTENSION_NAME,\n#elif defined(__linux__)\n    VK_KHR_XLIB_SURFACE_EXTENSION_NAME,\n#endif     VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME\n  };\n```", "```cpp\n const uint32_t numInstanceExtensions = config_.enableValidation ?\n    (uint32_t)LVK_ARRAY_NUM_ELEMENTS(instanceExtensionNames) :\n    (uint32_t)LVK_ARRAY_NUM_ELEMENTS(instanceExtensionNames) - 1;\n  const VkValidationFeatureEnableEXT validationFeaturesEnabled[] = {\n    VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT };\n  const VkValidationFeaturesEXT features = {\n    .sType = VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,\n    .pNext = nullptr,\n    .enabledValidationFeatureCount = config_.enableValidation ?\n      LVK_ARRAY_NUM_ELEMENTS(validationFeaturesEnabled) : 0u,\n    .pEnabledValidationFeatures = config_.enableValidation ?\n      validationFeaturesEnabled : nullptr,\n  };\n```", "```cpp\n const VkApplicationInfo appInfo = {\n    .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,\n    .pNext = nullptr,\n    .pApplicationName = “LVK/Vulkan”,\n    .applicationVersion = VK_MAKE_VERSION(1, 0, 0),\n    .pEngineName = “LVK/Vulkan”,\n    .engineVersion = VK_MAKE_VERSION(1, 0, 0),\n    .apiVersion = VK_API_VERSION_1_3,\n  };\n```", "```cpp\n const VkInstanceCreateInfo ci = {\n    .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,\n    .pNext = config_.enableValidation ? &features : nullptr,\n    .flags = 0,\n    .pApplicationInfo = &appInfo,\n    .enabledLayerCount = config_.enableValidation ?\n      LVK_ARRAY_NUM_ELEMENTS(kDefaultValidationLayers) : 0,\n    .ppEnabledLayerNames = config_.enableValidation ?\n      kDefaultValidationLayers : nullptr,\n    .enabledExtensionCount = numInstanceExtensions,\n    .ppEnabledExtensionNames = instanceExtensionNames,\n  };\n  VK_ASSERT(vkCreateInstance(&ci, nullptr, &vkInstance_));\n  volkLoadInstance(vkInstance_);\n```", "```cpp\n uint32_t count = 0;\n  VK_ASSERT(vkEnumerateInstanceExtensionProperties(\n    nullptr, &count, nullptr));\n  std::vector<VkExtensionProperties> allInstanceExtensions(count);\n  VK_ASSERT(vkEnumerateInstanceExtensionProperties(\n    nullptr, &count, allInstanceExtensions.data()));\n  LLOGL(“\\nVulkan instance extensions:\\n”);\n  for (const auto& extension : allInstanceExtensions) {\n    LLOGL(“  %s\\n”, extension.extensionName);\n  }\n}\n```", "```cpp\nlvk::Result VulkanContext::queryDevices(HWDeviceType deviceType,\n  std::vector<HWDeviceDesc>& outDevices) {\n  outDevices.clear();\n  uint32_t deviceCount = 0;\n  VK_ASSERT_RETURN(\n    vkEnumeratePhysicalDevices(vkInstance_, &deviceCount, nullptr));\n  std::vector<VkPhysicalDevice> vkDevices(deviceCount);\n  VK_ASSERT_RETURN(vkEnumeratePhysicalDevices(\n    vkInstance_, &deviceCount, vkDevices.data()));\n```", "```cpp\nenum HWDeviceType {\n  HWDeviceType_Discrete = 1,\n  HWDeviceType_External = 2,\n  HWDeviceType_Integrated = 3,\n  HWDeviceType_Software = 4,\n};\n  const HWDeviceType desiredDeviceType = deviceType;\n  for (uint32_t i = 0; i < deviceCount; ++i) {\n    VkPhysicalDevice physicalDevice = vkDevices[i];\n    VkPhysicalDeviceProperties deviceProperties;\n    vkGetPhysicalDeviceProperties(physicalDevice, &deviceProperties);\n    const HWDeviceType deviceType =\n      convertVulkanDeviceTypeToIGL(deviceProperties.deviceType);\n    if (desiredDeviceType != HWDeviceType_Software &&         desiredDeviceType != deviceType) continue;\n    outDevices.push_back(\n      {.guid = (uintptr_t)vkDevices[i], .type = deviceType});\n    strcpy(outDevices.back().name, deviceProperties.deviceName);\n  }\n  if (outDevices.empty()) return Result(RuntimeError,\n    “No Vulkan devices matching your criteria”);\n  return Result();\n}\n```", "```cpp\nlvk::Result VulkanContext::initContext(const HWDeviceDesc& desc) {\n  vkPhysicalDevice_ = (VkPhysicalDevice)desc.guid;\n  vkGetPhysicalDeviceFeatures2(vkPhysicalDevice_, &vkFeatures10_);\n  vkGetPhysicalDeviceProperties2(\n    vkPhysicalDevice_, &vkPhysicalDeviceProperties2_);\n  const uint32_t apiVersion =\n    vkPhysicalDeviceProperties2_.properties.apiVersion;\n  LLOGL(“Vulkan physical device: %s\\n”,\n    vkPhysicalDeviceProperties2_.properties.deviceName);\n  LLOGL(“           API version: %i.%i.%i.%i\\n”,\n        VK_API_VERSION_MAJOR(apiVersion),\n        VK_API_VERSION_MINOR(apiVersion),\n        VK_API_VERSION_PATCH(apiVersion),\n        VK_API_VERSION_VARIANT(apiVersion));\n  LLOGL(“           Driver info: %s %s\\n”,\n        vkPhysicalDeviceDriverProperties_.driverName,\n        vkPhysicalDeviceDriverProperties_.driverInfo);\n```", "```cpp\n uint32_t count = 0;\n  vkEnumerateDeviceExtensionProperties(\n    vkPhysicalDevice_, nullptr, &count, nullptr);\n  std::vector<VkExtensionProperties>     allPhysicalDeviceExtensions(count);\n  vkEnumerateDeviceExtensionProperties(vkPhysicalDevice_, nullptr,\n    &count, allPhysicalDeviceExtensions.data());\n  LLOGL(“Vulkan physical device extensions:\\n”);\n  for (const auto& ext : allPhysicalDeviceExtensions) {\n    LLOGL(“  %s\\n”, ext.extensionName);\n  }\n```", "```cpp\nstruct DeviceQueues {\n  const static uint32_t INVALID = 0xFFFFFFFF;\n  uint32_t graphicsQueueFamilyIndex = INVALID;\n  uint32_t computeQueueFamilyIndex = INVALID;\n  VkQueue graphicsQueue = VK_NULL_HANDLE;\n  VkQueue computeQueue = VK_NULL_HANDLE;\n};\n  deviceQueues_.graphicsQueueFamilyIndex =\n      lvk::findQueueFamilyIndex(vkPhysicalDevice_,\n      VK_QUEUE_GRAPHICS_BIT);\n  deviceQueues_.computeQueueFamilyIndex =\n      lvk::findQueueFamilyIndex(vkPhysicalDevice_,\n      VK_QUEUE_COMPUTE_BIT);\n  const float queuePriority = 1.0f;\n  const VkDeviceQueueCreateInfo ciQueue[2] = {\n    {   .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,\n        .queueFamilyIndex = deviceQueues_.graphicsQueueFamilyIndex,\n        .queueCount = 1,\n        .pQueuePriorities = &queuePriority, },\n    {   .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,\n        .queueFamilyIndex = deviceQueues_.computeQueueFamilyIndex,\n        .queueCount = 1,\n        .pQueuePriorities = &queuePriority, },\n  };\n```", "```cpp\n const uint32_t numQueues =\n    ciQueue[0].queueFamilyIndex == ciQueue[1].queueFamilyIndex ? 1:2;\n```", "```cpp\n const char* deviceExtensionNames[] = {\n    VK_KHR_SWAPCHAIN_EXTENSION_NAME,\n  };\n```", "```cpp\n VkPhysicalDeviceFeatures deviceFeatures10 = {\n      .geometryShader = VK_TRUE,\n      .multiDrawIndirect = VK_TRUE,\n      .drawIndirectFirstInstance = VK_TRUE,\n      .depthBiasClamp = VK_TRUE,\n      .fillModeNonSolid = VK_TRUE,\n      .textureCompressionBC = VK_TRUE,\n  };\n  VkPhysicalDeviceVulkan11Features deviceFeatures11 = {\n      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES,\n      .storageBuffer16BitAccess = VK_TRUE,\n      .shaderDrawParameters = VK_TRUE,\n  };\n  VkPhysicalDeviceVulkan12Features deviceFeatures12 = {\n      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES,\n      .pNext = &deviceFeatures11,\n      .descriptorIndexing = VK_TRUE,\n      .shaderSampledImageArrayNonUniformIndexing = VK_TRUE,\n      .descriptorBindingSampledImageUpdateAfterBind = VK_TRUE,\n      .descriptorBindingStorageImageUpdateAfterBind = VK_TRUE,\n      .descriptorBindingUpdateUnusedWhilePending = VK_TRUE,\n      .descriptorBindingPartiallyBound = VK_TRUE,\n      .descriptorBindingVariableDescriptorCount = VK_TRUE,\n      .runtimeDescriptorArray = VK_TRUE,\n      .uniformBufferStandardLayout = VK_TRUE,\n      .timelineSemaphore = VK_TRUE,\n      .bufferDeviceAddress = VK_TRUE,\n  };\n  VkPhysicalDeviceVulkan13Features deviceFeatures13 = {\n      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES,\n      .pNext = &deviceFeatures12,\n      .subgroupSizeControl = VK_TRUE,\n      .synchronization2 = VK_TRUE,\n      .dynamicRendering = VK_TRUE,\n      .maintenance4 = VK_TRUE,\n  };\n```", "```cpp\n std::vector<VkExtensionProperties> props;\n  getDeviceExtensionProps(vkPhysicalDevice_, props);\n  for (const char* layer : kDefaultValidationLayers)\n    getDeviceExtensionProps(vkPhysicalDevice_, props, layer);\n  std::string missingExtensions;\n  for (const char* ext : deviceExtensionNames)\n    if (!hasExtension(ext, props))\n      missingExtensions += “\\n   “ + std::string(ext);\n  if (!missingExtensions.empty()) {\n    MINILOG_LOG_PROC(minilog::FatalError,\n      “Missing Vulkan device extensions: %s\\n”,\n      missingExtensions.c_str());\n    return Result(Result::Code::RuntimeError);\n  }\n```", "```cpp\n {\n    std::string missingFeatures;\n#define CHECK_VULKAN_FEATURE(                       \\\n  reqFeatures, availFeatures, feature, version)     \\\n  if ((reqFeatures.feature == VK_TRUE) &&           \\\n      (availFeatures.feature == VK_FALSE))          \\\n        missingFeatures.append(“\\n   “ version “ .” #feature);\n#define CHECK_FEATURE_1_0(feature)                               \\\n  CHECK_VULKAN_FEATURE(deviceFeatures10, vkFeatures10_.features, \\\n  feature, “1.0 “);\n    CHECK_FEATURE_1_0(robustBufferAccess);\n    CHECK_FEATURE_1_0(fullDrawIndexUint32);\n    CHECK_FEATURE_1_0(imageCubeArray);\n    … // omitted a lot of other Vulkan 1.0 features here\n#undef CHECK_FEATURE_1_0\n#define CHECK_FEATURE_1_1(feature)                      \\\n  CHECK_VULKAN_FEATURE(deviceFeatures11, vkFeatures11_, \\\n    feature, “1.1 “);\n    CHECK_FEATURE_1_1(storageBuffer16BitAccess);\n    CHECK_FEATURE_1_1(uniformAndStorageBuffer16BitAccess);\n    CHECK_FEATURE_1_1(storagePushConstant16);\n    … // omitted a lot of other Vulkan 1.1 features here\n#undef CHECK_FEATURE_1_1\n#define CHECK_FEATURE_1_2(feature)                      \\\n  CHECK_VULKAN_FEATURE(deviceFeatures12, vkFeatures12_, \\\n  feature, “1.2 “);\n    CHECK_FEATURE_1_2(samplerMirrorClampToEdge);\n    CHECK_FEATURE_1_2(drawIndirectCount);\n    CHECK_FEATURE_1_2(storageBuffer8BitAccess);\n    … // omitted a lot of other Vulkan 1.2 features here\n#undef CHECK_FEATURE_1_2\n#define CHECK_FEATURE_1_3(feature)                      \\\n  CHECK_VULKAN_FEATURE(deviceFeatures13, vkFeatures13_, \\\n  feature, “1.3 “);\n    CHECK_FEATURE_1_3(robustImageAccess);\n    CHECK_FEATURE_1_3(inlineUniformBlock);\n    … // omitted a lot of other Vulkan 1.3 features here\n#undef CHECK_FEATURE_1_3\n    if (!missingFeatures.empty()) {\n      MINILOG_LOG_PROC(minilog::FatalError,\n        “Missing Vulkan features: %s\\n”, missingFeatures.c_str());\n      return Result(Result::Code::RuntimeError);\n    }\n  }\n```", "```cpp\n const VkDeviceCreateInfo ci = {\n      .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,\n      .pNext = &deviceFeatures13,\n      .queueCreateInfoCount = numQueues,\n      .pQueueCreateInfos = ciQueue,\n      .enabledLayerCount =\n        LVK_ARRAY_NUM_ELEMENTS(kDefaultValidationLayers),\n      .ppEnabledLayerNames = kDefaultValidationLayers,\n      .enabledExtensionCount = \n        LVK_ARRAY_NUM_ELEMENTS(deviceExtensionNames),\n      .ppEnabledExtensionNames = deviceExtensionNames,\n      .pEnabledFeatures = &deviceFeatures10,\n  };\n  VK_ASSERT_RETURN(vkCreateDevice(\n    vkPhysicalDevice_, &ci, nullptr, &vkDevice_));\n  volkLoadDevice(vkDevice_);\n  vkGetDeviceQueue(vkDevice_, deviceQueues_.graphicsQueueFamilyIndex,\n    0, &deviceQueues_.graphicsQueue);\n  vkGetDeviceQueue(vkDevice_, deviceQueues_.computeQueueFamilyIndex,\n    0, &deviceQueues_.computeQueue);\n  … // other code in initContext() is unrelated to this recipe\n}\n```", "```cpp\nvoid VulkanContext::querySurfaceCapabilities() {\n   const VkFormat depthFormats[] = {\n     VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT,\n     VK_FORMAT_D16_UNORM_S8_UINT, VK_FORMAT_D32_SFLOAT,\n     VK_FORMAT_D16_UNORM};\n  for (const auto& depthFormat : depthFormats) {\n    VkFormatProperties formatProps;\n    vkGetPhysicalDeviceFormatProperties(\n      vkPhysicalDevice_, depthFormat, &formatProps);\n    if (formatProps.optimalTilingFeatures)\n      deviceDepthFormats_.push_back(depthFormat);\n  }\n```", "```cpp\n vkGetPhysicalDeviceSurfaceCapabilitiesKHR(\n    vkPhysicalDevice_, vkSurface_, &deviceSurfaceCaps_);\n  uint32_t formatCount;\n  vkGetPhysicalDeviceSurfaceFormatsKHR(\n    vkPhysicalDevice_, vkSurface_, &formatCount, nullptr);\n  if (formatCount) {\n    deviceSurfaceFormats_.resize(formatCount);\n    vkGetPhysicalDeviceSurfaceFormatsKHR(vkPhysicalDevice_,\n      vkSurface_, &formatCount, deviceSurfaceFormats_.data());\n  }\n```", "```cpp\n uint32_t presentModeCount;\n  vkGetPhysicalDeviceSurfacePresentModesKHR(vkPhysicalDevice_,\n    vkSurface_, &presentModeCount, nullptr);\n  if (presentModeCount) {\n    devicePresentModes_.resize(presentModeCount);\n    vkGetPhysicalDeviceSurfacePresentModesKHR(vkPhysicalDevice_,\n    vkSurface_, &presentModeCount, devicePresentModes_.data());\n  }\n}\n```", "```cpp\nVkSurfaceFormatKHR chooseSwapSurfaceFormat(   const std::vector<VkSurfaceFormatKHR>& formats,\n  lvk::ColorSpace colorSpace) {\n  const VkSurfaceFormatKHR preferred = colorSpaceToVkSurfaceFormat(\n    colorSpace, isNativeSwapChainBGR(formats));\n  for (const auto& fmt : formats)\n    if (fmt.format == preferred.format &&         fmt.colorSpace == preferred.colorSpace) return fmt;\n```", "```cpp\n for (const auto& fmt : formats) {\n    if (fmt.format == preferred.format) return fmt;\n  }\n  return formats[0];\n}\n```", "```cpp\nVkBool32 queueFamilySupportsPresentation = VK_FALSE;\nvkGetPhysicalDeviceSurfaceSupportKHR(ctx.getVkPhysicalDevice(),\n  ctx.deviceQueues_.graphicsQueueFamilyIndex, ctx.vkSurface_,\n  &queueFamilySupportsPresentation));\nIGL_ASSERT(queueFamilySupportsPresentation == VK_TRUE);\n```", "```cpp\nVkImageUsageFlags chooseUsageFlags(   VkPhysicalDevice pd, VkSurfaceKHR surface, VkFormat format)\n{\n  VkImageUsageFlags usageFlags = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |\n                                 VK_IMAGE_USAGE_TRANSFER_DST_BIT |\n                                 VK_IMAGE_USAGE_TRANSFER_SRC_BIT;\n  VkSurfaceCapabilitiesKHR caps;\n  vkGetPhysicalDeviceSurfaceCapabilitiesKHR(pd, surface, &caps);\n  const bool isStorageSupported =\n    (caps.supportedUsageFlags & VK_IMAGE_USAGE_STORAGE_BIT) > 0;\n  VkFormatProperties props;\n  vkGetPhysicalDeviceFormatProperties(pd, format, &props);\n  const bool isTilingOptimalSupported =\n    (props.optimalTilingFeatures & VK_IMAGE_USAGE_STORAGE_BIT) > 0;\n  if (isStorageSupported && isTilingOptimalSupported) {\n    usageFlags |= VK_IMAGE_USAGE_STORAGE_BIT;\n  }\n  return usageFlags;\n}\n```", "```cpp\nVkPresentModeKHR chooseSwapPresentMode(   const std::vector<VkPresentModeKHR>& modes) {\n#if defined(__linux__)\n  if (std::find(modes.cbegin(), modes.cend(),\n      VK_PRESENT_MODE_IMMEDIATE_KHR) != modes.cend())\n    return VK_PRESENT_MODE_IMMEDIATE_KHR;\n#endif // __linux__\n  if (std::find(modes.cbegin(), modes.cend(),\n      VK_PRESENT_MODE_MAILBOX_KHR) != modes.cend())\n    return VK_PRESENT_MODE_MAILBOX_KHR;\n  return VK_PRESENT_MODE_FIFO_KHR;\n}\n```", "```cpp\nuint32_t chooseSwapImageCount(const VkSurfaceCapabilitiesKHR& caps) {\n  const uint32_t desired = caps.minImageCount + 1;\n  const bool exceeded = caps.maxImageCount > 0 &&                         desired > caps.maxImageCount;\n  return exceeded ? caps.maxImageCount : desired;\n}\n```", "```cpp\nconst VkImageUsageFlags usageFlags = chooseUsageFlags(\n  ctx.getVkPhysicalDevice(), ctx.vkSurface_, surfaceFormat_.format);\nconst VkSwapchainCreateInfoKHR ci = {\n  .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,\n  .surface = ctx.vkSurface_,\n  .minImageCount = chooseSwapImageCount(ctx.deviceSurfaceCaps_),\n  .imageFormat = surfaceFormat_.format,\n  .imageColorSpace = surfaceFormat_.colorSpace,\n  .imageExtent = {.width = width, .height = height},\n  .imageArrayLayers = 1,\n  .imageUsage = usageFlags,\n  .imageSharingMode = VK_SHARING_MODE_EXCLUSIVE,\n  .queueFamilyIndexCount = 1,\n  .pQueueFamilyIndices = &ctx.deviceQueues_.graphicsQueueFamilyIndex,\n  .preTransform = ctx.deviceSurfaceCaps_.currentTransform,\n  .compositeAlpha = VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR,\n  .presentMode = chooseSwapPresentMode(ctx.devicePresentModes_),\n  .clipped = VK_TRUE,\n  .oldSwapchain = VK_NULL_HANDLE,\n};\nvkCreateSwapchainKHR(device_, &ci, nullptr, &swapchain_);\n```", "```cpp\nvkGetSwapchainImagesKHR(\n  device_, swapchain_, &numSwapchainImages_, nullptr);\nstd::vector<VkImage> swapchainImages(numSwapchainImages_);\nvkGetSwapchainImagesKHR(\n  device_, swapchain_, &numSwapchainImages_, swapchainImages.data());\n```", "```cpp\nconst VkDebugUtilsMessengerCreateInfoEXT ci = {\n  .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,\n  .messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |\n                     VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT |\n                     VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |\n                     VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,\n  .messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |\n                 VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |\n                 VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,\n  .pfnUserCallback = &vulkanDebugCallback,\n  .pUserData = this,\n};\nvkCreateDebugUtilsMessengerEXT(\n  vkInstance_, &ci, nullptr, &vkDebugUtilsMessenger_);\n```", "```cpp\nVKAPI_ATTR VkBool32 VKAPI_CALL\nvulkanDebugCallback(   VkDebugUtilsMessageSeverityFlagBitsEXT msgSeverity,\n  VkDebugUtilsMessageTypeFlagsEXT msgType,\n  const VkDebugUtilsMessengerCallbackDataEXT* cbData,\n  void* userData) {\n  if (msgSeverity < VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT)\n    return VK_FALSE;\n  const bool isError =\n   (msgSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) != 0;\n  char errorName[128] = {};\n  int object = 0;\n  void* handle = nullptr;\n  char typeName[128] = {};\n  void* messageID = nullptr;\n  if (sscanf(cbData->pMessage,\n        “Validation Error : [ %127s ] Object %i: handle = %p, “         “type = %127s | MessageID = %p”,\n        errorName, &object, &handle, typeName, messageID) >= 2) {\n    const char* message = strrchr(cbData->pMessage, ‘|’) + 1;\n    LLOGL(“%sValidation layer:\\n Validation Error: %s \\n Object %i: “           “handle = %p, type = %s\\n MessageID = %p \\n%s \\n”,\n      isError ? “\\nERROR:\\n” : ““,\n      errorName, object, handle, typeName, messageID, message);\n  } else {\n    LLOGL(“%sValidation layer:\\n%s\\n”, isError ? “\\nERROR:\\n” : ““,\n      cbData->pMessage);\n  }\n  if (isError) {\n    VulkanContext* ctx =\n      static_cast<lvk::vulkan::VulkanContext*>(userData);\n    if (ctx->config_.terminateOnValidationError) {\n      IGL_ASSERT(false);\n      std::terminate();\n    }\n  }\n  return VK_FALSE;\n}\n```", "```cpp\nlvkSetDebugObjectName(vkDevice_, VK_OBJECT_TYPE_DEVICE,\n   (uint64_t)vkDevice_, “Device: VulkanContext::vkDevice_”));\n```", "```cpp\nVkResult ivkSetDebugObjectName(VkDevice device, VkObjectType type,\n  uint64_t handle, const char* name) {\n  if (!name || !*name) return VK_SUCCESS;\n  const VkDebugUtilsObjectNameInfoEXT ni = {\n      .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,\n      .objectType = type,\n      .objectHandle = handle,\n      .pObjectName = name,\n  };\n  return vkSetDebugUtilsObjectNameEXT(device, &ni);\n}\n```", "```cpp\n while (!glfwWindowShouldClose(window)) {\n    glfwPollEvents();\n    glfwGetFramebufferSize(window, &width, &height);\n    if (!width || !height) continue;\n    lvk::ICommandBuffer& buf = ctx->acquireCommandBuffer();\n    ctx->submit(buf, ctx->getCurrentSwapchainTexture());\n  }\n```", "```cpp\nstruct SubmitHandle {\n  uint32_t bufferIndex_ = 0;\n  uint32_t submitId_ = 0;\n  SubmitHandle() = default;\n  explicit SubmitHandle(uint64_t handle) :\n    bufferIndex_(uint32_t(handle & 0xffffffff)),\n    submitId_(uint32_t(handle >> 32)) {}\n  bool empty() const { return submitId_ == 0; }\n  uint64_t handle() const   { return (uint64_t(submitId_) << 32) + bufferIndex_; }\n};\n```", "```cpp\nstruct CommandBufferWrapper {\n  VkCommandBuffer cmdBuf_ = VK_NULL_HANDLE;\n  VkCommandBuffer cmdBufAllocated_ = VK_NULL_HANDLE;\n  SubmitHandle handle_ = {};\n  VkFence fence_ = VK_NULL_HANDLE;\n  VkSemaphore semaphore_ = VK_NULL_HANDLE;\n  bool isEncoding_ = false;\n};\n```", "```cpp\nclass VulkanImmediateCommands final {\n public:\n   static constexpr uint32_t kMaxCommandBuffers = 64;\n  VulkanImmediateCommands(\n    VkDevice device, uint32_t queueFamilyIdx, const char* debugName);\n  ~VulkanImmediateCommands();\n```", "```cpp\n const CommandBufferWrapper& acquire();\n  SubmitHandle submit(const CommandBufferWrapper& wrapper);\n```", "```cpp\n void waitSemaphore(VkSemaphore semaphore);\n  VkSemaphore acquireLastSubmitSemaphore();\n```", "```cpp\n SubmitHandle getLastSubmitHandle() const;\n  bool isReady(SubmitHandle handle) const;\n  void wait(SubmitHandle handle);\n  void waitAll();\n```", "```cpp\n private:\n  void purge();\n  VkDevice device_ = VK_NULL_HANDLE;\n  VkQueue queue_ = VK_NULL_HANDLE;\n  VkCommandPool commandPool_ = VK_NULL_HANDLE;\n  uint32_t queueFamilyIndex_ = 0;\n  const char* debugName_ = ““;\n  CommandBufferWrapper buffers_[kMaxCommandBuffers];\n  SubmitHandle lastSubmitHandle_ = SubmitHandle();\n  VkSemaphore lastSubmitSemaphore_ = VK_NULL_HANDLE;\n  VkSemaphore waitSemaphore_ = VK_NULL_HANDLE;\n  uint32_t numAvailableCommandBuffers_ = kMaxCommandBuffers;\n  uint32_t submitCounter_ = 1;\n};\n```", "```cpp\nlvk::VulkanImmediateCommands::VulkanImmediateCommands(VkDevice device,\n  uint32_t queueFamilyIndex, const char* debugName) :\n  device_(device), queueFamilyIndex_(queueFamilyIndex),\n  debugName_(debugName)\n{\n  vkGetDeviceQueue(device, queueFamilyIndex, 0, &queue_);\n  const VkCommandPoolCreateInfo ci = {\n      .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,\n      .flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT |\n               VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,\n      .queueFamilyIndex = queueFamilyIndex,\n  };\n  VK_ASSERT(vkCreateCommandPool(device, &ci, nullptr, &commandPool_));\n```", "```cpp\n const VkCommandBufferAllocateInfo ai = {\n      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,\n      .commandPool = commandPool_,\n      .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,\n      .commandBufferCount = 1,\n  };\n  for (uint32_t i = 0; i != kMaxCommandBuffers; i++) {\n    auto& buf = buffers_[i];\n    buf.semaphore_ = lvk::createSemaphore(device, semaphoreName);\n    buf.fence_ = lvk::createFence(device, fenceName);\n    VK_ASSERT(\n      vkAllocateCommandBuffers(device, &ai, &buf.cmdBufAllocated_));\n    buffers_[i].handle_.bufferIndex_ = i;\n  }\n}\n```", "```cpp\nlvk::VulkanImmediateCommands::~VulkanImmediateCommands() {\n  waitAll();\n  for (auto& buf : buffers_) {\n    vkDestroyFence(device_, buf.fence_, nullptr);\n    vkDestroySemaphore(device_, buf.semaphore_, nullptr);\n  }\n  vkDestroyCommandPool(device_, commandPool_, nullptr);\n}\n```", "```cpp\nconst lvk::VulkanImmediateCommands::CommandBufferWrapper&   lvk::VulkanImmediateCommands::acquire()\n{\n  while (!numAvailableCommandBuffers_) purge();\n```", "```cpp\n VulkanImmediateCommands::CommandBufferWrapper* current = nullptr;\n  for (auto& buf : buffers_) {\n    if (buf.cmdBuf_ == VK_NULL_HANDLE) {\n      current = &buf;\n      break;\n    }\n  }\n  current->handle_.submitId_ = submitCounter_;\n  numAvailableCommandBuffers_--;\n  current->cmdBuf_ = current->cmdBufAllocated_;\n  current->isEncoding_ = true;\n```", "```cpp\n const VkCommandBufferBeginInfo bi = {\n      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,\n      .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,\n  };\n  VK_ASSERT(vkBeginCommandBuffer(current->cmdBuf_, &bi));\n  return *current;\n}\n```", "```cpp\nvoid lvk::VulkanImmediateCommands::purge() {\n  for (CommandBufferWrapper& buf : buffers_) {\n    if (buf.cmdBuf_ == VK_NULL_HANDLE || buf.isEncoding_)\n      continue;\n    const VkResult result =\n      vkWaitForFences(device_, 1, &buf.fence_, VK_TRUE, 0);\n    if (result == VK_SUCCESS) {\n      VK_ASSERT(vkResetCommandBuffer(\n        buf.cmdBuf_, VkCommandBufferResetFlags{0}));\n      VK_ASSERT(vkResetFences(device_, 1, &buf.fence_));\n      buf.cmdBuf_ = VK_NULL_HANDLE;\n      numAvailableCommandBuffers_++;\n    }\n  }\n}\n```", "```cpp\nSubmitHandle lvk::VulkanImmediateCommands::submit(\n  const CommandBufferWrapper& wrapper) {\n  VK_ASSERT(vkEndCommandBuffer(wrapper.cmdBuf_));\n```", "```cpp\n const VkPipelineStageFlags waitStageMasks[] = {\n    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,\n    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT };\n  VkSemaphore waitSemaphores[] = { VK_NULL_HANDLE, VK_NULL_HANDLE };\n  uint32_t numWaitSemaphores = 0;\n  if (waitSemaphore_)\n    waitSemaphores[numWaitSemaphores++] = waitSemaphore_;\n  if (lastSubmitSemaphore_)\n    waitSemaphores[numWaitSemaphores++] = lastSubmitSemaphore_;\n```", "```cpp\n const VkSubmitInfo si = {\n      .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,\n      .waitSemaphoreCount = numWaitSemaphores,\n      .pWaitSemaphores = waitSemaphores,\n      .pWaitDstStageMask = waitStageMasks,\n      .commandBufferCount = 1u,\n      .pCommandBuffers = &wrapper.cmdBuf_,\n      .signalSemaphoreCount = 1u,\n      .pSignalSemaphores = &wrapper.semaphore_,\n  };\n  VK_ASSERT(vkQueueSubmit(queue_, 1u, &si, wrapper.fence_));\n  lastSubmitSemaphore_ = wrapper.semaphore_;\n  lastSubmitHandle_ = wrapper.handle_;\n```", "```cpp\n waitSemaphore_ = VK_NULL_HANDLE;\n  const_cast<CommandBufferWrapper&>(wrapper).isEncoding_ = false;\n  submitCounter_++;\n  if (!submitCounter_) submitCounter_++;\n  return lastSubmitHandle_;\n}\n```", "```cpp\nbool VulkanImmediateCommands::isReady(const SubmitHandle handle) const {\n  if (handle.empty()) return true;\n```", "```cpp\n const CommandBufferWrapper& buf = buffers_[handle.bufferIndex_];\n  if (buf.cmdBuf_ == VK_NULL_HANDLE) return true;\n```", "```cpp\n if (buf.handle_.submitId_ != handle.submitId_)  return true;\n  return vkWaitForFences(device_, 1, &buf.fence_, VK_TRUE, 0) ==\n    VK_SUCCESS;\n}\n```", "```cpp\nvoid lvk::VulkanImmediateCommands::wait(const SubmitHandle handle) {\n  if (isReady(handle)) return;\n  if (!LVK_VERIFY(!buffers_[handle.bufferIndex_].isEncoding_)) return;\n  VK_ASSERT(vkWaitForFences(device_, 1, \n    &buffers_[handle.bufferIndex_].fence_, VK_TRUE, UINT64_MAX));\n  purge();\n}\n```", "```cpp\nvoid lvk::VulkanImmediateCommands::waitAll() {\n  VkFence fences[kMaxCommandBuffers];\n  uint32_t numFences = 0;\n  for (const auto& buf : buffers_) {\n    if (buf.cmdBuf_ != VK_NULL_HANDLE && !buf.isEncoding_)\n      fences[numFences++] = buf.fence_;\n  }\n  if (numFences) VK_ASSERT(vkWaitForFences(\n    device_, numFences, fences, VK_TRUE, UINT64_MAX));\n  purge();\n}\n```", "```cpp\n while (!glfwWindowShouldClose(window)) {\n    glfwPollEvents();\n    glfwGetFramebufferSize(window, &width, &height);\n    if (!width || !height) continue;\n    lvk::ICommandBuffer& buf = ctx->acquireCommandBuffer();\n    ctx->submit(buf, ctx->getCurrentSwapchainTexture());\n  }\n```", "```cpp\nICommandBuffer& VulkanContext::acquireCommandBuffer() {\n  LVK_ASSERT_MSG(!pimpl_->currentCommandBuffer_.ctx_,\n    “Cannot acquire more than 1 command buffer simultaneously”);\n  pimpl_->currentCommandBuffer_ = CommandBuffer(this);\n  return pimpl_->currentCommandBuffer_;\n}\n```", "```cpp\nvoid VulkanContext::submit(\n  const lvk::ICommandBuffer& commandBuffer, TextureHandle present) {\n  vulkan::CommandBuffer* vkCmdBuffer =\n    const_cast<vulkan::CommandBuffer*>(\n      static_cast<const vulkan::CommandBuffer*>(&commandBuffer));\n  if (present) {\n    // … do proper layout transitioning for the image …\n  }\n```", "```cpp\n const bool shouldPresent = hasSwapchain() && present;\n  if (shouldPresent) {\n    immediate_->waitSemaphore(swapchain_->acquireSemaphore_);\n  }\n```", "```cpp\n vkCmdBuffer->lastSubmitHandle_ =\n    immediate_->submit(*vkCmdBuffer->wrapper_);\n  if (shouldPresent) {\n    swapchain_->present(immediate_->acquireLastSubmitSemaphore());\n  }\n```", "```cpp\n processDeferredTasks();\n  pimpl_->currentCommandBuffer_ = {};\n}\n```", "```cpp\nctx->createShaderModule(\n  { codeVS, lvk::Stage_Vert, “Shader Module: main (vert)” })\nctx->createShaderModule(\n  { codeFS, lvk::Stage_Frag, “Shader Module: main (frag)” })\n```", "```cpp\nstruct ShaderModuleDesc {\n  ShaderStage stage = Stage_Frag;\n  const char* data = nullptr;\n  size_t dataSize = 0;\n  const char* debugName = ““;\n  ShaderModuleDesc(const char* source, lvk::ShaderStage stage,\n    const char* debugName) : stage(stage), data(source),\n    debugName(debugName) {}\n  ShaderModuleDesc(const void* data, size_t dataLength,\n    lvk::ShaderStage stage, const char* debugName) :\n    stage(stage), data(static_cast<const char*>(data)),\n    dataSize(dataLength), debugName(debugName) {}\n};\n```", "```cpp\nlvk::Holder<lvk::ShaderModuleHandle>   VulkanContext::createShaderModule(const ShaderModuleDesc& desc)\n{\n  VkShaderModule sm = desc.dataSize ?\n    // binary SPIR-V\n    createShaderModule(desc.data, desc.dataSize, desc.debugName) :\n    // textual GLSL\n    createShaderModule(desc.stage, desc.data, desc.debugName);\n  return {this, shaderModulesPool_.create(std::move(sm))};\n}\n```", "```cpp\nVkShaderModule VulkanContext::createShaderModule(const void* data,\n  size_t length, const char* debugName, Result* outResult) const {\n  VkShaderModule vkShaderModule = VK_NULL_HANDLE;\n  const VkShaderModuleCreateInfo ci = {\n      .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,\n      .codeSize = length,\n      .pCode = (const uint32_t*)data,\n  };\n  vkCreateShaderModule(vkDevice_, &ci, nullptr, &vkShaderModule);\n  return vkShaderModule;\n}\n```", "```cpp\nstd::unique_ptr<lvk::IContext> ctx =\n  lvk::createVulkanContextWithSwapchain(window, width, height, {});\n```", "```cpp\nlvk::Holder<lvk::RenderPipelineHandle> rpTriangle =\n  ctx->createRenderPipeline({\n    .smVert = ctx->createShaderModule(\n      { codeVS, lvk::Stage_Vert, “Shader Module: vert” }).release(),\n    .smFrag = ctx->createShaderModule(\n      { codeFS, lvk::Stage_Frag, “Shader Module: frag” }).release(),\n    .color  = { { .format = ctx->getSwapchainFormat() } },\n});\n```", "```cpp\nwhile (!glfwWindowShouldClose(window)) {\n  glfwPollEvents();\n  glfwGetFramebufferSize(window, &width, &height);\n  if (!width || !height) continue;\n  lvk::ICommandBuffer& buf = ctx->acquireCommandBuffer();\n```", "```cpp\n buf.cmdBeginRendering(\n    {.color = {{ .loadOp = LoadOp_Clear, .clearColor = {1,1,1,1}}}},\n    {.color = {{ .texture = ctx->getCurrentSwapchainTexture() }}});\n```", "```cpp\n buf.cmdBindRenderPipeline(rpTriangle);\n  buf.cmdDraw(lvk::Primitive_Triangle, 0, 3);\n  buf.cmdEndRendering();\n  ctx->submit(buf, ctx->getCurrentSwapchainTexture());\n}\n```", "```cpp\n#version 460\nlayout (location=0) out vec3 color;\nconst vec2 pos[3] = vec2[3](\n  vec2(-0.6, -0.4), vec2(0.6, -0.4), vec2(0.0, 0.6) );\nconst vec3 col[3] = vec3[3](\n  vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0) );\nvoid main() {\n  gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\n  color = col[gl_VertexIndex];\n}\n```", "```cpp\n#version 460\nlayout (location=0) in vec3 color;\nlayout (location=0) out vec4 out_FragColor;\nvoid main() {\n  out_FragColor = vec4(color, 1.0);\n}\n```", "```cpp\nstruct RenderPipelineDesc final {\n  VertexInput vertexInput;\n  ShaderModuleHandle smVert;\n  ShaderModuleHandle smGeom;\n  ShaderModuleHandle smFrag;\n  const char* entryPointVert = “main”;\n  const char* entryPointFrag = “main”;\n  const char* entryPointGeom = “main”;\n```", "```cpp\n ColorAttachment color[LVK_MAX_COLOR_ATTACHMENTS] = {};\n  uint32_t getNumColorAttachments() const {\n    uint32_t n = 0;\n    while (n < LVK_MAX_COLOR_ATTACHMENTS &&       color[n].format != Format_Invalid) n++;\n    return n;\n  }\n```", "```cpp\n Format depthFormat = Format_Invalid;\n  Format stencilFormat = Format_Invalid;\n  CullMode cullMode = lvk::CullMode_None;\n  WindingMode frontFaceWinding = lvk::WindingMode_CCW;\n  PolygonMode polygonMode = lvk::PolygonMode_Fill;\n  StencilState backFaceStencil = {};\n  StencilState frontFaceStencil = {};\n  uint32_t samplesCount = 1u;\n  const char* debugName = ““;\n};\n```", "```cpp\nclass RenderPipelineState final {\n  RenderPipelineDesc desc_;\n  uint32_t numBindings_ = 0;\n  uint32_t numAttributes_ = 0;\n```", "```cpp\n VkVertexInputBindingDescription\n    vkBindings_[VertexInput::LVK_VERTEX_BUFFER_MAX] = {};\n  VkVertexInputAttributeDescription\n    vkAttributes_[VertexInput::LVK_VERTEX_ATTRIBUTES_MAX] = {};\n  VkDescriptorSetLayout lastVkDescriptorSetLayout_ = VK_NULL_HANDLE;\n  VkShaderStageFlags shaderStageFlags_ = 0;\n  VkPipelineLayout pipelineLayout_ = VK_NULL_HANDLE;\n  VkPipeline pipeline_ = VK_NULL_HANDLE;\n};\n```", "```cpp\nVulkanContext::createRenderPipeline(\n  const RenderPipelineDesc& desc, Result* outResult)\n{\n  const bool hasColorAttachments = desc.getNumColorAttachments() > 0;\n  const bool hasDepthAttachment = desc.depthFormat != Format_Invalid;\n  const bool hasAnyAttachments =\n    hasColorAttachments || hasDepthAttachment;\n  if (!LVK_VERIFY(hasAnyAttachments)) return {};\n  if (!LVK_VERIFY(desc.smVert.valid())) return {};\n  if (!LVK_VERIFY(desc.smFrag.valid())) return {};\n  RenderPipelineState rps = {.desc_ = desc};\n```", "```cpp\n const lvk::VertexInput& vstate = rps.desc_.vertexInput;\n  bool bufferAlreadyBound[VertexInput::LVK_VERTEX_BUFFER_MAX] = {};\n  rps.numAttributes_ = vstate.getNumAttributes();\n  for (uint32_t i = 0; i != rps.numAttributes_; i++) {\n    const auto& attr = vstate.attributes[i];\n    rps.vkAttributes_[i] = { .location = attr.location,\n                             .binding = attr.binding,\n                             .format =\n                               vertexFormatToVkFormat(attr.format),\n                             .offset = (uint32_t)attr.offset };\n    if (!bufferAlreadyBound[attr.binding]) {\n      bufferAlreadyBound[attr.binding] = true;\n      rps.vkBindings_[rps.numBindings_++] = {\n        .binding = attr.binding,\n        .stride = vstate.inputBindings[attr.binding].stride,\n        .inputRate = VK_VERTEX_INPUT_RATE_VERTEX };\n    }\n  }\n  return {this, renderPipelinesPool_.create(std::move(rps))};\n}\n```", "```cpp\nVkPipeline VulkanContext::getVkPipeline(RenderPipelineHandle handle)\n{\n  lvk::RenderPipelineState* rps = renderPipelinesPool_.get(handle);\n  if (!rps) return VK_NULL_HANDLE;\n```", "```cpp\n if (rps->lastVkDescriptorSetLayout_ != vkDSL_) {\n    deferredTask(std::packaged_task<void()>(\n      [device = getVkDevice(), pipeline = rps->pipeline_]() {\n        vkDestroyPipeline(device, pipeline, nullptr); }));\n    deferredTask(std::packaged_task<void()>(\n      [device = getVkDevice(), layout = rps->pipelineLayout_]() {\n        vkDestroyPipelineLayout(device, layout, nullptr); }));\n    rps->pipeline_ = VK_NULL_HANDLE;\n    rps->lastVkDescriptorSetLayout_ = vkDSL_;\n  }\n```", "```cpp\n if (rps->pipeline_ != VK_NULL_HANDLE) {\n    return rps->pipeline_;\n  }\n```", "```cpp\n VkPipelineLayout layout = VK_NULL_HANDLE;\n  VkPipeline pipeline = VK_NULL_HANDLE;\n  const RenderPipelineDesc& desc = rps->desc_;\n  const uint32_t numColorAttachments = desc_.getNumColorAttachments();\n  VkPipelineColorBlendAttachmentState\n    colorBlendAttachmentStates[LVK_MAX_COLOR_ATTACHMENTS] = {};\n  VkFormat colorAttachmentFormats[LVK_MAX_COLOR_ATTACHMENTS] = {};\n  for (uint32_t i = 0; i != numColorAttachments; i++) {\n    const auto& attachment = desc_.color[i];\n    colorAttachmentFormats[i] = formatToVkFormat(attachment.format);\n```", "```cpp\n if (!attachment.blendEnabled) {\n      colorBlendAttachmentStates[i] =\n        VkPipelineColorBlendAttachmentState{\n          .blendEnable = VK_FALSE,\n          .srcColorBlendFactor = VK_BLEND_FACTOR_ONE,\n          .dstColorBlendFactor = VK_BLEND_FACTOR_ZERO,\n          .colorBlendOp = VK_BLEND_OP_ADD,\n          .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE,\n          .dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO,\n          .alphaBlendOp = VK_BLEND_OP_ADD,\n          .colorWriteMask = VK_COLOR_COMPONENT_R_BIT |\n                            VK_COLOR_COMPONENT_G_BIT |\n                            VK_COLOR_COMPONENT_B_BIT |\n                            VK_COLOR_COMPONENT_A_BIT,\n      };\n    } else {\n      colorBlendAttachmentStates[i] =\n        VkPipelineColorBlendAttachmentState{\n          .blendEnable = VK_TRUE,\n          .srcColorBlendFactor = blendFactorToVkBlendFactor(\n            attachment.srcRGBBlendFactor),\n          .dstColorBlendFactor = blendFactorToVkBlendFactor(\n            attachment.dstRGBBlendFactor),\n          .colorBlendOp = blendOpToVkBlendOp(attachment.rgbBlendOp),\n          .srcAlphaBlendFactor = blendFactorToVkBlendFactor(\n            attachment.srcAlphaBlendFactor),\n          .dstAlphaBlendFactor = blendFactorToVkBlendFactor(\n            attachment.dstAlphaBlendFactor),\n          .alphaBlendOp = blendOpToVkBlendOp(attachment.alphaBlendOp),\n          .colorWriteMask = VK_COLOR_COMPONENT_R_BIT |\n                            VK_COLOR_COMPONENT_G_BIT | \n                            VK_COLOR_COMPONENT_B_BIT |\n                            VK_COLOR_COMPONENT_A_BIT,\n      };\n    }\n  }\n```", "```cpp\n const VkShaderModule* vert =\n    ctx_->shaderModulesPool_.get(desc_.smVert);\n  const VkShaderModule* geom =\n    ctx_->shaderModulesPool_.get(desc_.smGeom);\n  const VkShaderModule* frag =\n    ctx_->shaderModulesPool_.get(desc_.smFrag);\n```", "```cpp\n VkSpecializationMapEntry entries[\n    SpecializationConstantDesc::LVK_SPECIALIZATION_CONSTANTS_MAX] ={};\n  const VkSpecializationInfo si =\n    lvk::getPipelineShaderStageSpecializationInfo(\n      desc.specInfo, entries);\n```", "```cpp\n const VkDescriptorSetLayout dsls[] =\n      { vkDSL_, vkDSL_, vkDSL_, vkDSL_ };\n    const VkPushConstantRange range = {\n      .stageFlags = rps->shaderStageFlags_,\n      .offset = 0,\n      .size = pushConstantsSize,\n    };\n    const VkPipelineLayoutCreateInfo ci = {\n      .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,\n      .setLayoutCount = (uint32_t)LVK_ARRAY_NUM_ELEMENTS(dsls),\n      .pSetLayouts = dsls,\n      .pushConstantRangeCount = pushConstantsSize ? 1u : 0u,\n      .pPushConstantRanges = pushConstantsSize ? &range : nullptr,\n  };\n  VK_ASSERT(vkCreatePipelineLayout(vkDevice_, &ci, nullptr, &layout));\n```", "```cpp\n#define UPDATE_PUSH_CONSTANT_SIZE(sm, bit) if (sm) { \\\n  pushConstantsSize = std::max(pushConstantsSize,    \\\n  sm->pushConstantsSize);                            \\\n  rps->shaderStageFlags_ |= bit; }\nrps->shaderStageFlags_ = 0;\nuint32_t pushConstantsSize = 0;\nUPDATE_PUSH_CONSTANT_SIZE(vertModule, VK_SHADER_STAGE_VERTEX_BIT);\nUPDATE_PUSH_CONSTANT_SIZE(tescModule,\n  VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT);\nUPDATE_PUSH_CONSTANT_SIZE(teseModule,\n  VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT);\nUPDATE_PUSH_CONSTANT_SIZE(geomModule, VK_SHADER_STAGE_GEOMETRY_BIT);\nUPDATE_PUSH_CONSTANT_SIZE(fragModule, VK_SHADER_STAGE_FRAGMENT_BIT);\n#undef UPDATE_PUSH_CONSTANT_SIZE\n```", "```cpp\n lvk::vulkan::VulkanPipelineBuilder()\n      // from Vulkan 1.0\n      .dynamicState(VK_DYNAMIC_STATE_VIEWPORT)\n      .dynamicState(VK_DYNAMIC_STATE_SCISSOR)\n      .dynamicState(VK_DYNAMIC_STATE_DEPTH_BIAS)\n      .dynamicState(VK_DYNAMIC_STATE_BLEND_CONSTANTS)\n      // from Vulkan 1.3 \n      .dynamicState(VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE)\n      .dynamicState(VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE)\n      .dynamicState(VK_DYNAMIC_STATE_DEPTH_COMPARE_OP)\n      .dynamicState(VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE)\n      .primitiveTopology(dynamicState.getTopology())\n      .depthBiasEnable(dynamicState.depthBiasEnable_)\n      .depthCompareOp(dynamicState.getDepthCompareOp())\n      .depthWriteEnable(dynamicState.depthWriteEnable_)\n      .rasterizationSamples(\n        getVulkanSampleCountFlags(desc_.samplesCount))\n      .polygonMode(polygonModeToVkPolygonMode(desc_.polygonMode))\n      .stencilStateOps(VK_STENCIL_FACE_FRONT_BIT,\n        stencilOpToVkStencilOp(\n          desc_.frontFaceStencil.stencilFailureOp),\n        stencilOpToVkStencilOp(\n          desc_.frontFaceStencil.depthStencilPassOp),\n        stencilOpToVkStencilOp(\n          desc_.frontFaceStencil.depthFailureOp),\n        compareOpToVkCompareOp(\n          desc_.frontFaceStencil.stencilCompareOp))\n      .stencilStateOps(VK_STENCIL_FACE_BACK_BIT,\n        stencilOpToVkStencilOp(\n          desc_.backFaceStencil.stencilFailureOp),\n        stencilOpToVkStencilOp(\n          desc_.backFaceStencil.depthStencilPassOp),\n        stencilOpToVkStencilOp(\n          desc_.backFaceStencil.depthFailureOp),\n        compareOpToVkCompareOp(\n          desc_.backFaceStencil.stencilCompareOp))\n      .stencilMasks(VK_STENCIL_FACE_FRONT_BIT, 0xFF,\n        desc_.frontFaceStencil.writeMask,\n        desc_.frontFaceStencil.readMask)\n      .stencilMasks(VK_STENCIL_FACE_BACK_BIT, 0xFF,\n        desc_.backFaceStencil.writeMask,\n        desc_.backFaceStencil.readMask)\n```", "```cpp\n .shaderStage(lvk::getPipelineShaderStageCreateInfo(\n        VK_SHADER_STAGE_VERTEX_BIT,\n        vertModule->sm, desc.entryPointVert, &si))\n      .shaderStage(lvk::getPipelineShaderStageCreateInfo(\n        VK_SHADER_STAGE_FRAGMENT_BIT,\n        fragModule->sm, desc.entryPointFrag, &si))\n      .shaderStage(geomModule ? lvk::getPipelineShaderStageCreateInfo(\n        VK_SHADER_STAGE_GEOMETRY_BIT,\n        geomModule->sm, desc.entryPointGeom, &si)\n        : VkPipelineShaderStageCreateInfo{.module = VK_NULL_HANDLE})\n      .cullMode(cullModeToVkCullMode(desc_.cullMode))\n      .frontFace(windingModeToVkFrontFace(desc_.frontFaceWinding))\n      .vertexInputState(vertexInputStateCreateInfo_)\n      .colorBlendAttachmentStates(colorBlendAttachmentStates)\n      .colorAttachmentFormats(colorAttachmentFormats)\n      .depthAttachmentFormat(formatToVkFormat(desc_.depthFormat))\n      .stencilAttachmentFormat(formatToVkFormat(desc_.stencilFormat))\n```", "```cpp\n .build(\n        vkDevice_, pipelineCache_, layout, &pipeline, desc.debugName);\n  rps->pipeline_ = pipeline;\n  rps->pipelineLayout_ = layout;\n  return pipeline;\n}\n```", "```cpp\nVkResult VulkanPipelineBuilder::build(VkDevice device,\n                                      VkPipelineCache pipelineCache,\n                                      VkPipelineLayout pipelineLayout,\n                                      VkPipeline* outPipeline,\n                                      const char* debugName)\n{\n  const VkPipelineDynamicStateCreateInfo dynamicState = {\n      .sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,\n      .dynamicStateCount = (uint32_t)dynamicStates_.size(),\n      .pDynamicStates = dynamicStates_.data(),\n  };\n```", "```cpp\n const VkPipelineViewportStateCreateInfo viewportState = {\n      .sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,\n      .viewportCount = 1,\n      .pViewports = nullptr,\n      .scissorCount = 1,\n      .pScissors = nullptr,\n  };\n```", "```cpp\n const VkPipelineColorBlendStateCreateInfo colorBlendState = {\n      .sType =\n        VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,\n      .logicOpEnable = VK_FALSE,\n      .logicOp = VK_LOGIC_OP_COPY,\n      .attachmentCount = uint32_t(colorBlendAttachmentStates_.size()),\n      .pAttachments = colorBlendAttachmentStates_.data(),\n  };\n  const VkPipelineRenderingCreateInfo renderingInfo = {\n      .sType = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR,\n      .pNext = nullptr,\n      .colorAttachmentCount =\n        (uint32_t)colorAttachmentFormats_.size(),\n      .pColorAttachmentFormats = colorAttachmentFormats_.data(),\n      .depthAttachmentFormat = depthAttachmentFormat_,\n      .stencilAttachmentFormat = stencilAttachmentFormat_,\n  };\n```", "```cpp\n const VkGraphicsPipelineCreateInfo ci = {\n      .sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,\n      .pNext = &renderingInfo,\n      .flags = 0,\n      .stageCount = (uint32_t)shaderStages_.size(),\n      .pStages = shaderStages_.data(),\n      .pVertexInputState = &vertexInputState_,\n      .pInputAssemblyState = &inputAssembly_,\n      .pTessellationState = nullptr,\n      .pViewportState = &viewportState,\n      .pRasterizationState = &rasterizationState_,\n      .pMultisampleState = &multisampleState_,\n      .pDepthStencilState = &depthStencilState_,\n      .pColorBlendState = &colorBlendState,\n      .pDynamicState = &dynamicState,\n      .layout = pipelineLayout,\n      .renderPass = VK_NULL_HANDLE,\n      .subpass = 0,\n      .basePipelineHandle = VK_NULL_HANDLE,\n      .basePipelineIndex = -1,\n  };\n  const auto result = vkCreateGraphicsPipelines(\n    device, pipelineCache, 1, &ci, nullptr, outPipeline);\n  numPipelinesCreated_++;\n}\n```"]