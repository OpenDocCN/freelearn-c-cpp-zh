# 使用享元模式共享对象

我们在第七章“使用对象池提高性能”中学习了对象池，并且知道它们对于避免由于动态内存分配导致的游戏性能下降非常有用。但是，我们还可以采取其他步骤来减少我们最初使用的内存量。

在创建项目时，你经常会遇到想要在屏幕上同时显示许多对象的情况。尽管在过去几年中计算机变得更为强大，但它们仍然无法独立处理屏幕上的数千个复杂游戏对象。

为了完成这一壮举，程序员需要考虑如何减轻程序内存负担。使用享元模式，我们将对象的公共部分抽象出来，并仅与每个实例的独特数据（如位置和当前健康）共享。

# 章节概述

在本章中，我们将构建一个由两部分组成的粒子系统：粒子本身，它将是一个简单的结构体，以及包含系统数据的粒子系统类。

我们将构建两种不同类型的粒子系统：一种可以自行移动的爆炸，以及一种在玩家飞船位置生成的静态粒子系统。我们还将探讨两种处理系统数据的方法。第一种是每个粒子系统都包含其自己的系统数据副本。然后，在学习了享元模式之后，我们将使用它来构建可以分配使用文件或代码的独立系统数据类。然后，每个粒子系统将简单地引用它所需的系统数据实例。

# 你的目标

本章将分为几个主题。它将包含从开始到结束的简单步骤。以下是我们的任务大纲：

+   粒子的介绍

+   在 Mach5 中实现粒子

+   为什么内存仍然是一个问题

+   享元模式的介绍

+   转换到粒子系统

# 粒子的介绍

在游戏开发中，你可能听说过粒子。它们通常是小型 2D 精灵或简单的 3D 模型，创建目的是为了模拟*模糊*事物，如火焰、爆炸和烟雾轨迹，以增加项目的视觉效果。这种视觉效果有时被称为*汁液感*。独立开发者*马丁·约纳森*和*佩特里·普霍*使其流行起来，使游戏*汁液感*更强，使其更具可玩性，并增加了玩家通过玩游戏获得的反馈。

这通常是在游戏开发后期为了完善项目并增加更多反馈而进行的工作，但它是一个很好的例子，说明了我们为什么想要在屏幕上同时显示许多事物。

更多关于“juiciness”（生动性）的信息，以及观看 Martin 和 Petri 在 GDC 关于此主题的演讲，请查看[`www.gamasutra.com/view/news/178938/Video_Is_your_game_juicy_enough.php`](http://www.gamasutra.com/view/news/178938/Video_Is_your_game_juicy_enough.php)。

这些物体之所以如此简单，是因为它们被生成数百次，有时甚至数千次，而且这个过程反复进行。

# 在 Mach5 中实现粒子

既然我们已经知道了粒子的概念，让我们将它们放入 Mach5 中，以便我们可以得到一个它们如何工作的例子。我们将创建粒子来跟随我们的飞船，使其移动方式类似于烟雾轨迹。这将是一个展示屏幕上粒子示例的好方法，但为了展示内容，我们首先需要将一个新的原型引入到游戏中。

为了做到这一点，打开本章的`Example Code`文件夹，并将`particle.tga`文件拖入你的 Visual Studio 项目的`EngineTest/Textures`文件夹中。

之后，打开`EngineTest/ArcheTypes`文件夹，创建一个名为`Particle.ini`的新文本文件，并填写以下信息：

```cpp
posX   = 0 
posY   = 0 
velX   = 0 
velY   = 0 
scaleX = 2.5 
scaleY = 2.5 
rot    = 0 
rotVel = 0 
components =  GfxComponent ParticleComponent 

[GfxComponent] 
texture = particle.tga 
drawSpace = world 

```

之后，我们需要 Mach5 引擎支持我们的新对象，因此转到`EngineTest`文件夹，然后双击`PreBuild.bat`文件。`M5ArcheTypes.h`文件将被更新以包含我们的粒子：

```cpp
//! AutoGenerated enum based on archetype ini file names   
enum M5ArcheTypes {   
AT_Bullet,  
AT_Particle,  
AT_Player,  
AT_Raider,  
AT_Splash,  
AT_INVALID  
}; 

```

太好了！现在我们已经将物体放入了游戏中，但仍有一个问题需要解决，那就是添加粒子组件。由于这个组件并不专属于我们的游戏，让我们转到 Core/Components 过滤器，并创建一个新的过滤器，命名为`ParticleComp`。从那里，创建两个新的文件，`ParticleComponent.h`和`ParticleComponent.cpp`，确保它们的路径设置为`Mach5-master\EngineTest\EngineTest\Source\`文件夹。

在`.h`文件中，使用以下代码：

```cpp
/******************************************************************************/ 
/*! 
\file   ParticleComponent.h 
\author John Doran 
\par    email: john@johnpdoran.com 
\par    Mach5 Game Engine 
\date   2016/12/06 

Used to display a single particle on the screen. 
*/ 
/******************************************************************************/ 
#ifndef PARTICLE_COMPONENT_H 
#define PARTICLE_COMPONENT_H 

#include "Core\M5Component.h" 
#include "Core\M5Vec2.h" 

class ParticleComponent : public M5Component 
{ 
public: 
  ParticleComponent(); 
  virtual void Update(float dt); 
  virtual M5Component* Clone(void); 
  virtual void FromFile(M5IniFile& iniFile); 
  bool activated; 
  float lifeTime; 
  float endScale; 
private: 
  M5Vec2 startScale; 
  float lifeLeft; 
  float Lerp(float start, float end, float fraction); 
}; 

#endif // !PARTICLE_COMPONENT_H 

```

这个类看起来与其他我们过去添加的组件相似，但这次我们增加了一个`startScale`属性来跟踪物体在其生命周期开始时的规模，以及一个`endScale`属性来作为改变规模的修饰符。我们还有一个`lifeTime`，它将是我们移除该物体之前它应该存在的时长，以及`lifeLeft`，它将是我们移除该物体之前它还剩多少时长。最后，由于我们将改变规模，我们添加了另一个函数`Lerp`，用于在起始值和结束值之间进行线性插值。

在`.cpp`文件中，使用以下代码：

```cpp
/******************************************************************************/ 
/*! 
\file   ParticleComponent.cpp 
\author John Doran 
\par    email: john@johnpdoran.com 
\par    Mach5 Game Engine 
\date   2016/12/06 

Particle system component. Allows you to draw many particles on the screen. 
*/ 
/******************************************************************************/ 
#include "ParticleComponent.h" 
#include "Core\M5Gfx.h" 
#include "Core\M5Math.h" 
#include "Core\M5Object.h" 
#include "EngineTest\M5ObjectPool.h" 
#include "Core\GfxComponent.h" 
#include "Core\M5IniFile.h" 

/******************************************************************************/ 
/*! 
Construtor for ParticleSystem component.  Sets default values 
*/ 
/******************************************************************************/ 
ParticleComponent::ParticleComponent() : 
  M5Component(CT_ParticleComponent) 
{ 
} 

/******************************************************************************/ 
/*! 
Takes care of the particle system, decrease lifetime and adjust scaling. 
Will mark for destruction if needed. 

\param [in] dt 
The time in seconds since the last frame. 
*/ 
/******************************************************************************/ 
void ParticleComponent::Update(float dt) 
{ 
  // Decrease our life by the change in time this frame  
    // (dt stands for delta time) 
  lifeLeft -= dt; 

  // Change our size based on where we want it to be 
  float currentPercentage = 1 - (lifeLeft / lifeTime); 
  m_pObj->scale.x = Lerp(startScale.x, 
     startScale.x * endScale, currentPercentage); 

  m_pObj->scale.y = Lerp(startScale.y, 
     startScale.y * endScale, currentPercentage); 

  // If there is no life left, destroy our object 
  if (lifeLeft <= 0) 
  { 
    m_pObj->isDead = true; 
  } 

} 

```

这段代码将通过使用`Lerp`函数在起始和结束规模之间进行插值来修改物体的规模。我们还将修改粒子的剩余寿命，如果没有剩余寿命，则标记粒子以供删除：

```cpp
/******************************************************************************/ 
/*! 
Will give you the percentage of the fraction from start to end 

\param [in] start 
What value to start from 

\param [in] end 
What value to end from 

\param [in] fraction 
What percentage of the way are we are from start to finish 

*/ 
/******************************************************************************/ 
float ParticleComponent::Lerp(float start, float end, float fraction) 
{ 
  return start + fraction * (end - start); 
} 

```

**线性插值**（**Lerp**）允许我们使用 `fraction` 属性来获取 `start` 和 `end` 之间的值，以确定过渡进行到多远。如果 `fraction` 是 `0`，我们将得到 `start` 的值。如果我们给出 `1`，我们将得到 `end` 的值。如果是 `.5`，那么我们将得到 `start` 和 `end` 之间的中点。

更多关于插值（包括线性插值）的信息，请查看 *Keith Maggio* 在 [`keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/`](https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/) 主题上的笔记。

```cpp
/******************************************************************************/ 
/*! 
Clones the current component and updates it with the correct information. 

\return 
A new component that is a clone of this one 
*/ 
/******************************************************************************/ 
M5Component * ParticleComponent::Clone(void) 
{ 
  ParticleComponent * pNew = new ParticleComponent; 
  pNew->m_pObj = m_pObj; 
  pNew->startScale = m_pObj->scale; 
  pNew->lifeTime = lifeTime; 
  pNew->lifeLeft = lifeTime; 
  pNew->endScale = endScale; 
  return pNew; 
} 

```

`Clone` 函数允许我们创建该对象的副本。它将创建该组件的新版本，我们将使用当前拥有的值来初始化新组件的值。这在 Mach5 引擎创建新游戏对象时被使用：

```cpp
/******************************************************************************/ 
/*! 
Reads in data from a preloaded ini file. 

\param [in] iniFile 
The preloaded inifile to read from. 
*/ 
/******************************************************************************/ 
void ParticleComponent::FromFile(M5IniFile& iniFile) 
{ 
  // Get our life time value 
  std::string lifeTimeText; 
  iniFile.SetToSection("ParticleComponent"); 
  iniFile.GetValue("lifeTime", lifeTimeText); 

  // Convert the string into a float 
  lifeTime = std::stof(lifeTimeText); 
  lifeLeft = lifeTime; 

  // Then do the same for endScale 
  std::string endScaleText; 
  iniFile.GetValue("endScale", endScaleText); 
  endScale = std::stof(endScaleText); 

} 

```

就像之前一样，`FromFile` 函数将读取我们之前创建的 `ini` 文件，并使用其中的值来设置该组件的属性。在我们的例子中，这里我们设置了 `lifeTime`、`lifeLeft` 和 `endScale`。

最后，让我们开始将这些对象放入我们的游戏中。打开 `PlayerInputComponent.cpp` 文件，并在 `Update` 函数的顶部添加以下内容：

```cpp
M5Object* particle = M5ObjectManager::CreateObject(AT_Particle); 

particle->pos = m_pObj->pos; 

```

这将在每一帧中产生一个粒子，并且其位置与我们的飞船相同。现在，如果我们运行游戏，我们应该能看到一些酷炫的东西！我们可以在以下屏幕截图中看到：

![图片](img/00057.jpeg)

如您所见，我们的飞船现在后面跟着一条轨迹。每个部分都是一个粒子！

# 为什么内存仍然是一个问题

我们目前展示的粒子系统在某些计算机上可能运行得足够好，但请注意，我们创建的大量变量在初始化后永远不会改变其数据。通常在编程中，我们会将不会改变的变量标记为 `const`，但我们不会在读取文件之前设置变量。我们可能将变量设置为静态的，但也有可能我们将来可能想要有更多的粒子系统，我不想为每个系统创建一个原型。

如果我们继续产生许多粒子，它所占据的内存将增加，我们将浪费宝贵的空间在内存中，这些空间本可以用于其他目的。为了解决这个问题，我们将采用享元模式。

# 享元模式简介

四大设计模式指出，享元是一个可以在多个上下文中同时使用的共享对象。类似于拳击中的轻量级拳击类别，我们可以在系统的不同地方同时使用一个更轻的对象。

虽然现在使用得不是很频繁，但在内存受限的场景中，享元模式可以非常有帮助。

Flyweight 将由两部分组成：内部状态和外部状态。内部状态是可以共享的部分。外部状态基于其使用的上下文进行修改，因此不能共享。

让我们通过一个 UML 图来更仔细地看看：

![图片](img/00058.jpeg)

我们有 **FlyweightFactory** 类，用于管理 Flyweight。每次我们请求一个时，我们要么提供一个已经创建的，要么自己创建一个新的。

**Flyweight** 对象本身具有所需类型的数据，只要它不会根据我们正在处理的对象而改变。

最后，我们有 **ConcreteFlyweight**，它充当我们的外部信息，可以通过 **FlyweightFactory** 访问和使用 **Flyweight**。

# 转向 ParticleSystems

因此，考虑到这一点，我们将做的是将每个粒子将共享的信息分开，我们将称之为 `ParticleSystem`：

```cpp
// Abstract class for us to derive from 
class ParticleSystem 
{ 
public: 
  float lifeTime; 
  M5Vec2 startScale; 
  float endScale; 

  // Pure virtual functions 
  virtual void Init(M5Object * object) = 0; 
  virtual void Update(M5Object * object, float dt, float lifeLeft) = 0; 

  float Lerp(float start, float end, float fraction); 

}; 

```

这个类充当我们的内部状态，它是共享的。由于对象的起始比例、结束比例和寿命永远不会改变，因此这些变量共享而不是每个对象都有自己的变量是有意义的。在我们的上一个例子中，我们只有一个粒子系统，但我们可能希望有更多的能力，而且当我们开始使用它时，Flyweight 模式的某些好处变得更加明显。这就是为什么我们给了这个类两个虚拟函数：`Init` 和 `Update`。我们可以让外部状态调用这些函数，给函数提供关于我们正在处理的具体对象的信息，然后我们可以使用这些属性来修改它。

# 创建不同的系统类型

除了我们当前不动的系统类型外，让我们添加一种新的粒子系统类型。让我们称它为 `Moving`，而我们之前的类型为 `Static`。为了区分这两种类型，让我们添加一个 `enum`：

```cpp
enum ParticleType 
{ 
  PS_Static, 
  PS_Moving 
}; 

```

我们现在可以通过删除之前创建的变量，并包括我们希望使用的 `ParticleSystem` 类型的引用来修改原始的 `ParticleComponent` 类：

```cpp
class ParticleComponent : public M5Component 
{ 
public: 
  ParticleComponent(); 
  virtual void Update(float dt); 
  virtual M5Component* Clone(void); 
  virtual void FromFile(M5IniFile& iniFile); 
  bool activated; 
  float lifeLeft; 

private: 
  ParticleType particleType; 
}; 

```

`ParticleComponent` 类充当我们的外部状态，持有关于剩余时间以及来自 `M5Component` 类的属性的信息，例如我们想要创建的对象的引用。

在这一点上，我们需要创建两个类来引用这些：

```cpp
class StaticParticleSystem : public ParticleSystem 
{ 
  void Init(M5Object * obj);     

  void Update(M5Object *, float, float); 

}; 

class MovingParticleSystem : public ParticleSystem 
{ 
  void Init(M5Object * obj); 

  void Update(M5Object *, float, float); 

}; 

```

# 开发 ParticleFactory

我们需要一种方式让我们的 `ParticleComponent` 访问这些信息。考虑到这一点，我们将利用我们在 第五章 中学到的工厂设计模式，即通过工厂方法模式解耦代码，并创建一个 `ParticleFactory` 类：

```cpp
class ParticleFactory 
{ 
public: 
  static int objectCount; 
  static std::map<ParticleType, ParticleSystem *> particleSystems; 

  // Getting our Flyweight 
  static ParticleSystem & GetParticleSystem(ParticleType type); 
  ~ParticleFactory(); 
}; 

```

这个`ParticleFactory`类是我们用来管理这些 Flyweights 的创建，并确保如果对象已经位于我们的 map 中，我们将返回它。否则，我们将创建一个新的对象以便能够访问它。我还添加了一个`objectCount`变量，帮助我们了解当前存在多少对象，并验证没有内存泄漏发生。

`ParticleSystems`变量是 map 类型，这实际上是我最喜欢的`stl`容器之一，可以被认为是*关联数组*。换句话说，您不需要记住数字来访问数组的特定索引，您可以使用不同的类型，例如`string`，或者在这种情况下，使用`enum`。

更多关于 map 容器的信息，请查看[`www.cprogramming.com/tutorial/stl/stlmap.html`](http://www.cprogramming.com/tutorial/stl/stlmap.html)。

然后，我们需要定义两个静态变量：

```cpp
#include <map> 

// Define our static variables 
int ParticleFactory::objectCount = 0; 
std::map<ParticleType, ParticleSystem *> ParticleFactory::particleSystems; 

```

# 使用`ParticleFactory`

接下来，我们需要调整我们之前创建的粒子原型和组件以反映这些更改。

首先，我们想要更改我们的`.ini`文件。由于`Particle`对象适用于所有粒子类型，我们不会在那里设置属性，而是设置一个基类型供我们使用：

```cpp
posX   = 0 
posY   = 0 
velX   = 0 
velY   = 0 
scaleX = 2.5 
scaleY = 2.5 
rot    = 0 
rotVel = 0 
components =  GfxComponent ParticleComponent 

[GfxComponent] 
texture = particle.tga 
drawSpace = world 

[ParticleComponent] 
type = Moving 

```

这简化了粒子对象本身，但这是出于好原因。我们现在将更新`ParticleComponent`类的代码如下：

```cpp
/******************************************************************************/ 
/*! 
Construtor for ParticleSystem component.  Sets default values 
*/ 
/******************************************************************************/ 
ParticleComponent::ParticleComponent() : 
  M5Component(CT_ParticleComponent) 
{ 
} 

/******************************************************************************/ 
/*! 
Takes care of the particle system, decrease lifetime and adjust scaling. 
Will mark for destruction if needed. 

\param [in] dt 
The time in seconds since the last frame. 
*/ 
/******************************************************************************/ 
void ParticleComponent::Update(float dt) 
{ 
  // Decrease our life by the change in time this frame (delta time, dt) 
  lifeLeft -= dt; 

  ParticleFactory::GetParticleSystem(particleType).Update(m_pObj, dt, lifeLeft); 

  // If there is no life left, destroy our object 
  if (lifeLeft <= 0) 
  { 
    m_pObj->isDead = true; 
  } 

} 

```

在这种情况下，您会注意到，我们不是在这里修改缩放和/或移动，而是使用`ParticleFactory`根据`particleType`属性来更新我们的代码：

```cpp
/******************************************************************************/ 
/*! 
Clones the current component and updates it with the correct information. 

\return 
A new component that is a clone of this one 
*/ 
/******************************************************************************/ 
M5Component * ParticleComponent::Clone(void) 
{ 
  ParticleComponent * pNew = new ParticleComponent; 
  pNew->m_pObj = m_pObj; 
  pNew->particleType = particleType; 

  ParticleSystem & system = 
     ParticleFactory::GetParticleSystem(particleType); 
  system.Init(pNew->m_pObj); 
  pNew->lifeLeft = system.lifeTime; 
  return pNew; 
} 

```

在这里，我们根据工厂中粒子的类型调用`Init`函数：

```cpp
/******************************************************************************/ 
/*! 
Reads in data from a preloaded ini file. 

\param [in] iniFile 
The preloaded inifile to read from. 
*/ 
/******************************************************************************/ 
void ParticleComponent::FromFile(M5IniFile& iniFile) 
{ 
  // Get our initial particle type 
  std::string particleTypeText; 
  iniFile.SetToSection("ParticleComponent"); 
  iniFile.GetValue("type", particleTypeText); 

  if (particleTypeText == "Static") 
  { 
    particleType = PS_Static; 
  } 
  else if(particleTypeText == "Moving") 
  { 
    particleType = PS_Moving; 
  } 

} 

```

我们现在将根据`ini`文件上的标记来设置我们的粒子类型。

但是，当然，现在我们正在使用`GetParticleSystem`函数，我们需要为我们的代码实现它以便编译：

```cpp
/******************************************************************************/ 
/*! 
Used to get our Flyweight object and access the shared properties of the  
particles. 

\param type 
What kind of particle we want to get access to 

*/ 
/******************************************************************************/ 
ParticleSystem & ParticleFactory::GetParticleSystem(ParticleType type) 
{ 
  // If our object exists, return it 
  if (particleSystems.find(type) != particleSystems.end()) 
  { 
    return  *particleSystems[type]; 
  } 

  ParticleSystem * newSystem = nullptr; 

  // Otherwise, let's create one 
  switch (type) 
  { 
  case PS_Static: 
    newSystem = new StaticParticleSystem(); 
    newSystem->endScale = 0; 
    newSystem->lifeTime = 1.5; 
    newSystem->startScale = M5Vec2(2.5, 2.5); 

    particleSystems[PS_Static] = newSystem; 

    objectCount++; 
    break; 

  case PS_Moving: 
    newSystem = new MovingParticleSystem(); 
    newSystem->endScale = 0; 
    newSystem->lifeTime = 1.5; 
    newSystem->startScale = M5Vec2(2.5, 2.5); 
    particleSystems[PS_Moving] = newSystem; 
    objectCount++; 
    break; 
  } 

  return *newSystem; 

} 

```

在这个脚本中，我们使用了之前提到的`particleSystems` map。我们首先做的事情是检查 map 中是否有包含我们的`ParticleType`的对象。如果没有，那么我们需要创建一个。在这种情况下，我添加了一个`switch`语句，它将根据`case`语句中提到的值分配不同的值，但您也可以以类似读取原型的文件的方式轻松地从文本文件中读取这些值。您会注意到我们正在调用`new`来创建这些，因此我们还需要调用`delete`以避免任何内存泄漏。为了实现这一点，我为`ParticleFactory`类添加了一个析构函数：

```cpp
/******************************************************************************/ 
/*! 
Deconstructor for the ParticleFactory. Removes all of the elements in ourparticleSystems map 

*/ 
/******************************************************************************/ 
ParticleFactory::~ParticleFactory() 
{ 
  for (auto iterator = particleSystems.begin();  
     iterator != particleSystems.end();  
     iterator++)  
  { 
    // iterator->first = key 
    // iterator->second = value 
    delete iterator->second; 
  } 

} 

```

最后，我们需要为我们的不同`ParticleSystems`编写实现：

```cpp
/******************************************************************************/ 
/*! 
Will give you the percentage of the fraction from start to end 

\param start 
What value to start from 

\param end 
What value to end from 

\param fraction 
What percentage of the way we are from start to finish 

*/ 
/******************************************************************************/ 
float ParticleSystem::Lerp(float start, float end, float fraction) 
{ 
  return start + fraction * (end - start); 
} 

```

`Lerp`函数对两种粒子类型都做同样的事情，所以它保持原样是好的：

```cpp
/******************************************************************************/ 
/*! 
Used to initialize the particle system and set any parameters needed 

\param obj 
A reference to the object 

*/ 
/******************************************************************************/ 
void StaticParticleSystem::Init(M5Object * obj) 
{ 
  obj->vel = M5Vec2(0, 0); 
} 

/******************************************************************************/ 
/*! 
Used to update the particle system. Called once per frame 

\param m_pObj 
A reference to the object 

\param dt 
Amount of time that has passed since the previous frame 

\param lifeLeft 
The amount of lifetime the object has left 

*/ 
/******************************************************************************/ 
void StaticParticleSystem::Update(M5Object * m_pObj, 
   float /*dt*/, float lifeLeft) 
{ 
  // Change our size based on where we want it to be 
  float currentPercentage = 1 - (lifeLeft / lifeTime); 
  m_pObj->scale.x = Lerp(startScale.x, 
     startScale.x * endScale, currentPercentage); 
  m_pObj->scale.y = Lerp(startScale.y, 
     startScale.y * endScale, currentPercentage); 
} 

```

`Init`和`Update`函数的静态版本将只设置我们的速度为`0`，这样我们就不会移动：

```cpp
/******************************************************************************/ 
/*! 
Used to initialize the particle system and set any parameters needed 

\param obj 
A reference to the object 

*/ 
/******************************************************************************/ 
void MovingParticleSystem::Init(M5Object * obj) 
{ 
  obj->vel = M5Vec2(M5Random::GetFloat(-1, 1), 
     M5Random::GetFloat(-1, 1)) * 10; 
} 

/******************************************************************************/ 
/*! 
Used to update the particle system. Called once per frame 

\param m_pObj 
A reference to the object 

\param dt 
Amount of time that has passed since the previous frame 

\param lifeLeft 
The amount of lifetime the object has left 

*/ 
/******************************************************************************/ 
void MovingParticleSystem::Update(M5Object * m_pObj, float /*dt*/, float lifeLeft) 
{ 
  // Change our size based on where we want it to be 
  float currentPercentage = 1 - (lifeLeft / lifeTime); 
  m_pObj->scale.x = Lerp(startScale.x, 
     startScale.x * endScale, currentPercentage); 
  m_pObj->scale.y = Lerp(startScale.y, 
     startScale.y * endScale, currentPercentage); 
} 

```

对于我们的运动粒子系统，我们将速度设置为*x*轴和*y*轴上的随机数，从而产生一个漂亮的爆炸效果！

现在，我们不再每次都创建数据的副本，而将有一个副本供我们访问，如下面的截图所示：

![图片](img/00059.jpeg)

在游戏过程中，你会发现我们现在有一个新的粒子系统正在运行，并且它的工作相当出色。

# 摘要

在本章的整个过程中，我们学习了粒子以及如何利用它们来提升我们的游戏项目的品质。我们学习了如何在 Mach5 引擎中实现粒子系统，然后学习了 Flyweight 模式以及如何有效地使用它来减少项目中的内存使用。我们还看到了如何通过使用工厂模式来实现这一点，同时使创建新的粒子系统类型变得更加容易。考虑到这一点，未来在需要时，将更容易拆分保持一致性的程序部分，并且只创建额外的变量！

在接下来的章节中，我们将深入探讨图形以及理解我们的代码如何影响移动和动画游戏对象所需的概念。
