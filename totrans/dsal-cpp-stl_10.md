# 10

# 高级容器视图使用

在本质上，视图是非拥有范围，这意味着它们提供了对其他数据结构的视图（因此得名），而不拥有底层数据。这使得它们非常轻量级和多功能。使用视图，您可以在不复制数据的情况下对数据进行各种操作，确保高效的代码，最大化性能并最小化开销。

本章重点介绍以下容器：

+   `std::span`

+   `std::mdspan`

# 技术要求

本章中的代码可以在 GitHub 上找到：

[`github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL`](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)

# std::span

`std::span`是 C++20 中引入的一个模板类，它提供对连续元素序列的视图，类似于轻量级、非拥有引用。它表示对某些连续存储的视图，例如数组或向量的部分，而不拥有底层数据。

`std::span`的主要目的是安全且高效地将数据数组传递给函数，而无需显式传递大小，因为大小信息封装在`std::span`对象中。它可以被认为是一个更安全、更灵活的替代方案，用于原始指针和大小或指针和长度参数传递。

## 目的和适用性

`std::span`是对连续序列的非拥有视图，通常是一个数组或另一个容器的片段。它是一种轻量级、灵活且安全地引用此类序列的方法，确保没有多余的复制。

`std::span`最适合以下场景：

+   当需要临时数据视图时

+   当底层数据的所有权由其他地方管理时

+   当您想避免不必要的数据复制但仍需要随机访问时

考虑使用`std::span`向函数提供对数据部分的访问，而不授予所有权。

## 理想的使用场景

以下是一些`std::span`的理想使用场景：

+   **处理数据段**：解析大型数据块的一个子段，例如处理网络缓冲区中的头信息

+   **函数接口**：授予函数对数据的视图，而不转移所有权或风险资源泄露

+   **数据视图**：快速且安全地提供对数据源的多重视图，而不复制源数据

## 性能

`std::span`的算法性能如下所述：

+   `std::span`不拥有其数据

+   **删除**：不适用

+   **访问**：*O(1)*，就像直接数组访问一样

+   **内存开销**：最小，因为它本质上只持有指针和大小

记住，`std::span`的性能主要源于其非拥有特性。

## 内存管理

`std::span`不进行任何分配。它只是引用其他地方拥有的内存。因此，关于内存行为的主要关注点与底层数据相关，而不是 span 本身。

## 线程安全

通过范围进行多个并发读取是安全的。然而，与任何数据结构一样，并发写入或写入-读取组合需要同步。

## 扩展和变体

`std::span` 在 `std::string_view` 中是独特的，它提供了一个类似的观点概念，它们针对特定的数据类型。

## 排序和搜索复杂度

排序不能直接应用于 `std::span`，因为它不拥有其数据。然而，使用适当的 STL 算法进行搜索对于未排序序列是 *O(n)*，对于排序数据是 *O(log n)*。

## 接口和成员函数

此类别中的关键函数包括以下内容：

+   `size()`: 返回元素数量

+   `data()`: 提供对底层数据的访问

+   `subspan()`: 从当前范围生成另一个范围

## 比较操作

与 `std::vector` 或 `std::array` 相比，`std::span` 不管理或拥有数据。它提供了一种安全地查看这些容器（或其他）部分的方法，而不需要复制。

## 与算法的交互

需要访问（而不是结构修改）的 STL 算法可以无缝地与 `std::span` 交互。那些需要插入或删除的应该避免使用。

## 异常

超出范围的操作可能会触发异常。在整个生命周期内，始终确保底层数据的有效性。

## 自定义

由于 `std::span` 的非拥有性质，通常不会使用分配器、比较器或哈希函数对其进行自定义。

## 示例

让我们看看一个示例，演示如何使用 `std::span` 来处理 **用户数据报协议**（**UDP**）包的头部。

UDP 头通常包括以下内容：

+   **源端口**: 2 字节

+   **目标端口**: 2 字节

+   **长度**: 2 字节

+   **校验和**: 2 字节

我们将创建一个简单的结构来表示头部，然后我们将使用 `std::span` 来处理包含 UDP 数据包头部和数据的缓冲区。让我们探索以下代码：

```cpp
#include <cstdint>
#include <iostream>
#include <span>
struct UDPHeader {
  uint16_t srcPort{0};
  uint16_t destPort{0};
  uint16_t length{0};
  uint16_t checksum{0};
  void display() const {
    std::cout << "Source Port: " << srcPort << "\n"
              << "Destination Port: " << destPort << "\n"
              << "Length: " << length << "\n"
              << "Checksum: " << checksum << "\n";
  }
};
void processUDPPacket(std::span<const uint8_t> packet) {
  if (packet.size() < sizeof(UDPHeader)) {
    std::cerr << "Invalid packet size!\n";
    return;
  }
  auto headerSpan = packet.subspan(0, sizeof(UDPHeader));
  const UDPHeader &header =
      *reinterpret_cast<const UDPHeader *>(
          headerSpan.data());
  header.display();
  auto dataSpan = packet.subspan(sizeof(UDPHeader));
  std::cout << "Data size: " << dataSpan.size()
            << " bytes\n";
}
int main() {
  uint8_t udpPacket[] = {0x08, 0x15, // Source port
                         0x09, 0x16, // Destination port
                         0x00, 0x10, // Length
                         0x12, 0x34, // Checksum
                         // Some data
                         0x01, 0x02, 0x03, 0x04, 0x05,
                         0x06};
  processUDPPacket(udpPacket);
  return 0;
}
```

这里是示例输出：

```cpp
Source Port: 5384
Destination Port: 5641
Length: 4096
Checksum: 13330
Data size: 6 bytes
```

上一段代码的关键点如下：

+   我们定义一个 `UDPHeader` 结构来表示头部字段。

+   在 `processUDPPacket` 函数中，我们使用 `std::span` 来处理缓冲区。

+   我们为头部创建一个 `subspan` 并将其重新解释为 `UDPHeader` 结构。

+   缓冲区的剩余部分是数据，我们使用另一个 `subspan` 来处理。

`std::span` 提供了对连续对象序列的视图，使其适合安全地访问内存区域，例如网络缓冲区，而不拥有底层数据。

## 最佳实践

让我们探索使用 `std::span` 的最佳实践：

+   `std::span` 的生命周期超过了范围本身。这是避免悬垂引用的关键。

+   `std::span` 不是一个拥有数据的容器。它只提供数据的视图，与像 `std::vector` 这样的管理其数据的容器不同。

+   `std::span` 视图。这种联合反映意味着在整个范围的生存周期内必须保持数据完整性。

+   谨慎使用 `std::span`。始终确保 span 的持续时间短于或等于底层数据的生命周期。

+   函数接口中使用 `std::span` 以防止不必要的数据复制。这可以优化性能，尤其是在处理大数据块时。

+   `std::span`。利用 `size()` 等函数进行边界验证。

+   `std::span` 在原始指针和长度对上。它提供了一个类型安全、更易读的替代方案，减少了常见指针错误的风险。

+   `std::span` 用于抽象数据段。当程序的不同组件或函数需要访问不同的数据部分而没有完整所有权时，特别有益。

+   `std::span` 提供随机访问迭代器，与大多数 STL 算法兼容。然而，在使用可能期望数据所有权或超出 `std::span` 范围的突变能力的算法时要小心。

+   `std::span`，鉴于其直接的反射属性。

# std::mdspan

`std::mdspan`，在 C++23 标准中引入，是一个多维 span 模板类，它将 `std::span` 的概念扩展到多个维度。它提供了一个多维连续元素序列的视图，而不拥有底层数据。此类对于数值计算和操作多维数据结构的算法（如矩阵和张量）非常有用。

## 目的和适用性

`std::mdspan` 是 C++ STL 中的多维 span。它是一个多维数组的非拥有视图，提供高效的访问和操作。

其优势如下：

+   表示和访问多维数据而不拥有它

+   促进与其他语言和库的互操作性，这些语言和库与多维数组一起工作。

`std::mdspan` 在以下场景中尤其适用：

+   当你必须与其他库或 API 中的多维数据一起工作而不进行复制时

+   当你需要对多维数据集进行索引和切片的灵活性时。

## 理想用例

以下是一些 `std::mdspan` 的理想用例：

+   **图像处理**：访问 2D 图像中的像素或 3D 视频流中的帧

+   **科学计算**：在矩阵格式中操作数据以进行数学计算

+   **数据处理**：高效地重新索引、切片或重塑多维数据集

+   **互操作性**：与其他管理多维数据结构的语言或库进行接口

## 性能

`std::mdspan` 的算法性能如下：

+   **访问**：通常对任何位置为 *O(1)*。

+   `std::mdspan` 只提供现有数据的视图。

+   `std::mdspan` 本身。

## 内存管理

由于 `std::mdspan` 不拥有其数据，它不控制内存分配或释放。确保在 `mdspan` 生命周期内底层数据保持有效。

## 线程安全

与 `std::span` 类似，多个并发读取是安全的，但写入或混合读取和写入需要外部同步。

## 扩展和变体

`std::span` 可以看作是 1D 变体。虽然 `std::span` 提供了线性数据的视图，但 `std::mdspan` 将此概念扩展到多维数据。

## 排序和搜索复杂度

由于其本质，排序和搜索不是 `std::mdspan` 的固有属性。外部算法需要根据其多维特性进行适配。

## 特殊接口和成员函数

`std::mdspan` 提供以下特殊接口和成员函数：

+   `extent`：返回给定维度的尺寸

+   `strides`：提供每个维度中连续项目之间的元素数量

+   `rank`：给出维度数

## 比较

与原始多维数组或指针相比，`std::mdspan` 提供了一个更安全、更灵活的接口，尽管没有数据所有权。

## 与算法的交互

虽然许多 STL 算法是为线性数据结构设计的，但特定的算法，尤其是针对多维数据的自定义算法，可以适配以与 `std::mdspan` 一起工作。

## 异常

由于其非拥有性质，通过已失效的 `std::mdspan`（如果底层数据被销毁）访问数据是未定义的行为，并且不会抛出标准异常。始终确保数据的有效性。

## 定制

`std::mdspan` 可以使用布局策略进行定制，以定义数据存储模式。

## 最佳实践

让我们探索使用 `std::mdspan` 的最佳实践：

+   `std::mdspan` 是一个非拥有视图。确保您永远不会错误地将它视为拥有数据的容器。这种疏忽可能会引入悬垂引用和未定义的行为。

+   `std::mdspan`。理解和调整这些方面可以优化您的数据访问模式，使它们更符合缓存友好。

+   `std::mdspan` 的布局与预期约定可以防止微妙的错误和低效。

+   `std::mdspan` 指针在整个跨度生命周期内保持有效。避免在 `std::mdspan` 引用底层数据时，底层数据被销毁或超出作用域的情况。

+   **显式布局指定**：当与不同的库一起工作时，尤其是与 C++ STL 外部的库一起工作时，明确预期的数据布局。这种清晰度可以防止歧义并确保一致的数据解释。

+   将 `std::mdspan` 作为参数。这种选择提供了对悬垂引用（与原始指针相比）的安全性，并且在多维数据操作方面具有更高的表达性。

+   `std::mdspan`。虽然 `std::mdspan` 提供了一定程度的类型安全性，但越界访问仍然会导致未定义的行为。考虑使用 `extents` 等函数来确认维度。

+   `std::mdspan` 使用布局策略来解释底层数据，以用于高级用例。这种灵活性在需要非标准数据排列或针对特定硬件架构进行优化时尤其有价值。

+   `std::span` 和 `std::mdspan` 本身并不保证底层数据的线程安全性。如果预期会有多线程访问，请确保底层数据结构或其操作是线程安全的。

+   由于 `std::mdspan` 具有多维性质，它并不自然地适合所有 STL 算法，但您仍然可以在数据的扁平视图或单个切片上使用许多算法。熟悉 STL 算法可以帮助您避免重复造轮子。

# 第三部分：精通 STL 算法

在本部分中，您将获得对 C++ STL 算法骨架的稳健理解。我们通过基本算法建立基础，强调排序、搜索和元素比较，这些对于高效的数据操作至关重要。然后我们深入 STL 的变革力量，通过复制、移动、填充和生成操作，揭示最优数据操作的技术，同时强调现代惯用术语如**返回值优化（RVO）**的重要性。

接下来，我们探讨数值操作，从简单的求和到复杂的内积，并将我们的关注点扩展到基于范围的运算，强调其在现代 C++ 中的重要性。随后的章节转向通过分区、堆操作和排列来结构化地处理数据集，展示了它们在数据组织和分析中的关键作用。

最后，我们通过介绍范围的概念来总结，这是 STL 的一次进化，它为算法操作带来了更丰富和高效的途径。我们分析了基于范围的排序和搜索算法的优势和最佳实践，并倡导在当代 C++ 开发中采用这些算法。最佳实践贯穿始终，为您提供了使用 STL 算法编写干净、高效和可维护代码的清晰路径。

本部分包含以下章节：

+   *第十一章*：基本算法和搜索

+   *第十二章*：操作和转换

+   *第十三章*：数值和基于范围的运算

+   *第十四章*：排列、分区和堆

+   *第十五章*：带有范围的现代 STL
