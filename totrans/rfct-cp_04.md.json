["```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <assert>\nenum class StorageType {\n    Disk,\n    Remote\n};\nclass DataSaver {\npublic:\n    DataSaver(StorageType storage_type) : storage_type_(storage_type) {}\n    void save_data(const std::string& data) const {\n        switch (storage_type_) {\n            case StorageType::Disk:\n                save_to_disk(data);\n                break;\n            case StorageType::Remote:\n                save_to_remote(data);\n                break;\n            default:\n                assert(false && “Unknown storage type.”);\n        }\n    }\n    void set_storage_type(StorageType storage_type) {\n        storage_type_ = storage_type;\n    }\nprivate:\n    void save_to_disk(const std::string& data) const {\n        // saving to disk\n    }\n    void save_to_remote(const std::string& data) const {\n        // saving data to a remote storage service.\n    }\n    StorageType storage_type_;\n};\nint main() {\n    DataSaver disk_data_saver(StorageType::Disk);\n    disk_data_saver.save_data(“Save this data to disk.”);\n    DataSaver remote_data_saver(StorageType::Remote);\n    remote_data_saver.save_data(“Save this data to remote storage.”);\n    // Switch the storage type at runtime.\n    disk_data_saver.set_storage_type(StorageType::Remote);\n    disk_data_saver.save_data(“Save this data to remote storage after switching storage type.”);\n    return 0;\n}\n```", "```cpp\nclass SaveStrategy {\npublic:\n    virtual ~SaveStrategy() {}\n    virtual void save_data(const std::string& data) const = 0;\n};\n```", "```cpp\nclass DiskSaveStrategy : public SaveStrategy {\npublic:\n    void save_data(const std::string& data) const override {\n        // ...\n    }\n};\nclass RemoteSaveStrategy : public SaveStrategy {\npublic:\n    void save_data(const std::string& data) const override {\n        // ...\n    }\n};\n```", "```cpp\nclass DataSaver {\npublic:\n    DataSaver(std::unique_ptr<SaveStrategy> save_strategy)\n        : save_strategy_(std::move(save_strategy)) {}\n    void save_data(const std::string& data) const {\n        save_strategy_->save_data(data);\n    }\n    void set_save_strategy(std::unique_ptr<SaveStrategy> save_strategy) {\n        save_strategy_ = std::move(save_strategy);\n    }\nprivate:\n    std::unique_ptr<SaveStrategy> save_strategy_;\n};\n```", "```cpp\nint main() {\n    DataSaver disk_data_saver(std::make_unique<DiskSaveStrategy>());\n    disk_data_saver.save_data(“Save this data to disk.”);\n    DataSaver remote_data_saver(std::make_unique<RemoteSaveStrategy>());\n    remote_data_saver.save_data(“Save this data to remote storage.”);\n    // Switch the saving strategy at runtime.\n    disk_data_saver.set_save_strategy(std::make_unique<RemoteSaveStrategy>());\n    disk_data_saver.save_data(“Save this data to remote storage after switching strategy.”);\n    return 0;\n}\n```", "```cpp\nclass CsvParser {\npublic:\n    void parse_file(const std::string& file_path) {\n        std::ifstream file(file_path);\n        if (!file) {\n            std::cerr << “Error opening file: “ << file_path << std::endl;\n            return;\n        }\n        std::string line;\n        while (std::getline(file, line)) {\n            process_line(line);\n        }\n        file.close();\n        post_process();\n    }\nprivate:\n    void process_line(const std::string& line) {\n        // Implement the CSV-specific parsing logic.\n        std::cout << “Processing CSV line: “ << line << std::endl;\n    }\n    void post_process() {\n        std::cout << “CSV parsing completed.” << std::endl;\n    }\n};\nclass JsonParser {\npublic:\n    void parse_file(const std::string& file_path) {\n        std::ifstream file(file_path);\n        if (!file) {\n            std::cerr << “Error opening file: “ << file_path << std::endl;\n            return;\n        }\n        std::string line;\n        while (std::getline(file, line)) {\n            process_line(line);\n        }\n        file.close();\n        post_process();\n    }\nprivate:\n    void process_line(const std::string& line) {\n        // Implement the JSON-specific parsing logic.\n        std::cout << “Processing JSON line: “ << line << std::endl;\n    }\n    void post_process() {\n        std::cout << “JSON parsing completed.” << std::endl;\n    }\n};\n```", "```cpp\nclass FileParser {\npublic:\n    void parse_file(const std::string& file_path) {\n        std::ifstream file(file_path);\n        if (!file) {\n            std::cerr << “Error opening file: “ << file_path << std::endl;\n            return;\n        }\n        std::string line;\n        while (std::getline(file, line)) {\n            process_line(line);\n        }\n        file.close();\n        post_process();\n    }\nprotected:\n    virtual void process_line(const std::string& line) = 0;\n    virtual void post_process() = 0;\n};\n```", "```cpp\nclass CsvParser : public FileParser {\nprotected:\n    void process_line(const std::string& line) override {\n        // Implement the CSV-specific parsing logic.\n        std::cout << “Processing CSV line: “ << line << std::endl;\n    }\n    void post_process() override {\n        std::cout << “CSV parsing completed.” << std::endl;\n    }\n};\nclass JsonParser : public FileParser {\nprotected:\n    void process_line(const std::string& line) override {\n        // Implement the JSON-specific parsing logic.\n        std::cout << “Processing JSON line: “ << line << std::endl;\n    }\n    void post_process() override {\n        std::cout << “JSON parsing completed.” << std::endl;\n    }\n};\n```", "```cpp\nint main() {\n    CsvParser csv_parser;\n    csv_parser.parse_file(“data.csv”);\n    JsonParser json_parser;\n    json_parser.parse_file(“data.json”);\n    return 0;\n}\n```", "```cpp\nclass Dashboard {\npublic:\n    void update(int speed, int rpm) {\n        // display the current speed\n    }\n};\nclass Controller {\npublic:\n    void update(int speed, int rpm) {\n        // Adjust car’s behavior based on the speed and RPM.\n    }\n};\nclass Engine {\npublic:\n    void set_dashboard(Dashboard* dashboard) {\n        dashboard_ = dashboard;\n    }\n    void set_controller(Controller* controller) {\n        controller_ = controller;\n    }\n    void set_measurements(int speed, int rpm) {\n        speed_ = speed;\n        rpm_ = rpm;\n        measurements_changed();\n    }\nprivate:\n    void measurements_changed() {\n        dashboard_->update(_speed, rpm_);\n        controller_->update(_speed, rpm_);\n    }\n    int speed_;\n    int rpm_;\n    Dashboard* dashboard_;\n    Controller* controller_;\n};\nint main() {\n    Engine engine;\n    engine.set_measurements(80, 3000);\n    return 0;\n}\n```", "```cpp\nclass Observer {\npublic:\n    virtual ~Observer() {}\n    virtual void update(int speed, int rpm) = 0;\n};\nclass Dashboard : public Observer {\npublic:\n    void update(int speed, int rpm) override {\n        // display the current speed\n    }\n};\nclass Controller : public Observer {\npublic:\n    void update(int speed, int rpm) override {\n        // Adjust car’s behavior based on the speed and RPM.\n    }\n};\nclass Engine {\npublic:\n    void register_observer(Observer* observer) {\n        observers_.push_back(observer);\n    }\n    void remove_observer(Observer* observer) {\n        observers_.erase(std::remove(_observers.begin(), observers_.end(), observer), observers_.end());\n    }\n    void set_measurements(int speed, int rpm) {\n        speed_ = speed;\n        rpm_ = rpm;\n        notify_observers();\n    }\nprivate:\n    void notify_observers() {\n        for (auto observer : observers_) {\n            observer->update(_speed, _rpm);\n        }\n    }\n    std::vector<Observer*> observers_;\n    int speed_;\n    int rpm_;\n};\n```", "```cpp\nint main() {\n    Engine engine;\n    Dashboard dashboard;\n    Controller controller;\n    // Register observers\n    engine.register_observer(&dashboard);\n    engine.register_observer(&controller);\n    // Update measurements\n    engine.set_measurements(80, 3000);\n    // Remove an observer\n    engine.remove_observer(&dashboard);\n    // Update measurements again\n    engine.set_measurements(100, 3500);\n    return 0;\n}\n```", "```cpp\n#include <boost/statechart/state_machine.hpp>\n#include <boost/statechart/simple_state.hpp>\n#include <boost/statechart/transition.hpp>\n#include <iostream>\nnamespace sc = boost::statechart;\n```", "```cpp\nstruct EventJobSubmitted : sc::event< EventJobSubmitted > {};\nstruct EventJobQueued : sc::event< EventJobQueued > {};\nstruct EventJobRunning : sc::event< EventJobRunning > {};\nstruct EventJobCompleted : sc::event< EventJobCompleted > {};\nstruct EventJobFailed : sc::event< EventJobFailed > {};\n```", "```cpp\nstruct Submitted;\nstruct Queued;\nstruct Running;\nstruct Completed;\nstruct Failed;\nstruct Submitted : sc::simple_state< Submitted, Job > {\n    typedef sc::transition< EventJobQueued, Queued > reactions;\n    Submitted() { std::cout << “Job Submitted\\n”; }\n};\nstruct Queued : sc::simple_state< Queued, Job > {\n    typedef sc::transition< EventJobRunning, Running > reactions;\n    Queued() { std::cout << “Job Queued\\n”; }\n};\nstruct Running : sc::simple_state< Running, Job > {\n    typedef boost::mpl::list<\n        sc::transition< EventJobCompleted, Completed >,\n        sc::transition< EventJobFailed, Failed >\n    > reactions;\n    Running() { std::cout << “Job Running\\n”; }\n};\nstruct Completed : sc::simple_state< Completed, Job > {\n    Completed() { std::cout << “Job Completed\\n”; }\n};\nstruct Failed : sc::simple_state< Failed, Job > {\n    Failed() { std::cout << “Job Failed\\n”; }\n};\n```", "```cpp\nstruct Job : sc::state_machine< Job, Submitted > {};\n```", "```cpp\nint main() {\n    Job my_job;\n    my_job.initiate();\n    my_job.process_event(EventJobQueued());\n    my_job.process_event(EventJobRunning());\n    my_job.process_event(EventJobCompleted());\n    return 0;\n}\n```", "```cpp\nJob Submitted\nJob Queued\nJob Running\nJob Completed\n```", "```cpp\nstruct EventJobUpdate : sc::event< EventJobUpdate > {\n    EventJobUpdate(bool is_complete) : is_complete(is_complete) {}\n    bool is_complete;\n};\n```", "```cpp\nstruct Running : sc::simple_state< Running, Job > {\n    typedef sc::custom_reaction< EventJobUpdate > reactions;\n    sc::result react(const EventJobUpdate& event) {\n        if (event.is_complete) {\n            return transit<Completed>();\n        } else {\n            return transit<Failed>();\n        }\n    }\n    Running() { std::cout << “Job Running\\n”; }\n};\n```", "```cpp\nint main() {\n    Job my_job;\n    my_job.initiate();\n    my_job.process_event(EventJobQueued());\n    my_job.process_event(EventJobRunning());\n    my_job.process_event(EventJobUpdate(true)); // The job is complete.\n    return 0;\n}\n```", "```cpp\nJob Submitted\nJob Queued\nJob Running\nJob Completed\n```", "```cpp\nmy_job.process_event(EventJobUpdate(false)); // The job is not complete.\n```", "```cpp\nJob Submitted\nJob Queued\nJob Running\nJob Failed\n```", "```cpp\nstruct EventJobFinished : sc::event< EventJobFinished > {};\n```", "```cpp\nstruct Completed : sc::simple_state< Completed, Job > {\n    Completed() {\n        std::cout << “Job Completed\\n”;\n        context< Job >().outermost_context().process_event(EventJobFinished());\n    }\n};\nstruct Failed : sc::simple_state< Failed, Job > {\n    Failed() {\n        std::cout << “Job Failed\\n”;\n        context< Job >().outermost_context().process_event(EventJobFinished());\n    }\n};\n```", "```cpp\nstruct ProcessingJobs : sc::state< ProcessingJobs, System, Job > {\n    typedef sc::custom_reaction< EventJobFinished > reactions;\n    sc::result react(const EventJobFinished&) {\n        std::cout << “Job Finished\\n”;\n        return transit<Idle>();\n    }\n    ProcessingJobs(my_context ctx) : my_base(ctx) {\n        std::cout << “System Processing Jobs\\n”;\n        context< System >().process_event(EventJobSubmitted());\n    }\n};\n```", "```cpp\nint main() {\n    System my_system;\n    my_system.initiate();\n    return 0;\n}\n```", "```cpp\nSystem Idle\nSystem Processing Jobs\nJob Submitted\nJob Queued\nJob Running\nJob Completed\nJob Finished\nSystem Idle\n```", "```cpp\nclass Database {\npublic:\n    static Database& get_instance() {\n        static Database instance;\n        return instance;\n    }\n    template<typename T>\n    std::optional<T> get(const Id& id) const;\n    template<typename T>\n    void save(const T& data);\nprivate:\n    Database() {} // Private constructor\n    Database(const Database&) = delete; // Delete copy constructor\n    Database& operator=(const Database&) = delete; // Delete copy assignment operator\n};\nclass OrderManager {\npublic:\n  void addOrder(const Order& order) {\n    auto db = Database::get_instance();\n    // check order validity\n    // notify other components about the new order, etc\n    db.save(order);\n  }\n};\n```", "```cpp\nclass OrderManager {\n  public:\n  OrderManager(Database& db);\n  // the rest of the code is the same\n};\nint main() {\n  auto db = Database{};\n  auto order_manager = OrderManager{db};\n}\n```", "```cpp\nint main() {\n  auto db = Database::get_instance();\n  auto order_manager = OrderManager{db};\n}\n```", "```cpp\nclass ECommerceSystem {\npublic:\n    // Product management\n    void add_product(int id, const std::string& name, uint64_t price) {\n        products_[id] = {name, price};\n    }\n    void remove_product(int id) {\n        products_.erase(id);\n    }\n    void update_product(int id, const std::string& name, uint64_t price) {\n        products_[id] = {name, price};\n    }\n    void list_products() {\n        // print the list of products\n    }\n    // Cart management\n    void add_to_cart(int product_id, int quantity) {\n        cart_[product_id] += quantity;\n    }\n    void remove_from_cart(int product_id) {\n        cart_.erase(product_id);\n    }\n    void update_cart(int product_id, int quantity) {\n        cart_[product_id] = quantity;\n    }\n    uint64_t calculate_cart_total() {\n        uint64_t total = 0;\n        for (const auto& item : cart_) {\n            total += products_[item.first].second * item.second;\n        }\n        return total;\n    }\n    // Order management\n    void place_order() {\n        // Process payment, update inventory, send confirmation email, etc.\n        // ...\n        cart_.clear();\n    }\n    // Persistence\n    void save_to_file(const std::string& file_name) {\n        // serializing the state to a file\n    }\n    void load_from_file(const std::string& file_name) {\n        // loading a file and parsing it\n    }\nprivate:\n    std::map<int, std::pair<std::string, uint64_t>> products_;\n    std::map<int, int> cart_;\n};\n```", "```cpp\nclass ProductManager {\npublic:\n    void add_product(int id, const std::string& name, uint64_t price) {\n        products_[id] = {name, price};\n    }\n    void remove_product(int id) {\n        products_.erase(id);\n    }\n    void update_product(int id, const std::string& name, uint64_t price) {\n        products_[id] = {name, price};\n    }\n    std::pair<std::string, uint64_t> get_product(int id) {\n        return products_[id];\n    }\n    void list_products() {\n        // print the list of products\n    }\nprivate:\n    std::map<int, std::pair<std::string, uint64_t>> products_;\n};\nclass CartManager {\npublic:\n    void add_to_cart(int product_id, int quantity) {\n        cart_[product_id] += quantity;\n    }\n    void remove_from_cart(int product_id) {\n        cart_.erase(product_id);\n    }\n    void update_cart(int product_id, int quantity) {\n        cart_[product_id] = quantity;\n    }\n    std::map<int, int> get_cart_contents() {\n        return cart_;\n    }\n    void clear_cart() {\n        cart_.clear();\n    }\nprivate:\n    std::map<int, int> cart_;\n};\nclass OrderManager {\npublic:\n    OrderManager(ProductManager& product_manager, CartManager& cart_manager)\n        : product_manager_(product_manager), cart_manager_(cart_manager) {}\n    uint64_t calculate_cart_total() {\n        // calculate cart’s total the same as before\n    }\n    void place_order() {\n        // Process payment, update inventory, send confirmation email, etc.\n        // ...\n        cart_manager_.clear_cart();\n    }\nprivate:\n    ProductManager& product_manager_;\n    CartManager& cart_manager_;\n};\nclass PersistenceManager {\npublic:\n    PersistenceManager(ProductManager& product_manager)\n        : product_manager_(product_manager) {}\n    void save_to_file(const std::string& file_name) {\n      // saving\n    }\n    void load_from_file(const std::string& file_name) {\n      // loading\n    }\nprivate:\n    ProductManager& product_manager_;\n};\n```", "```cpp\n// include the new classes\nclass ECommerce {\npublic:\n    void add_product(int id, const std::string& name, uint64_t price) {\n        product_manager_.add_product(id, name, price);\n    }\n    void remove_product(int id) {\n        product_manager_.remove_product(id);\n    }\n    void update_product(int id, const std::string& name, uint64_t price) {\n        product_manager_.update_product(id, name, price);\n    }\n    void list_products() {\n        product_manager_.list_products();\n    }\n    void add_to_cart(int product_id, int quantity) {\n        cart_manager_.add_to_cart(product_id, quantity);\n    }\n    void remove_from_cart(int product_id) {\n        cart_manager_.remove_from_cart(product_id);\n    }\n    void update_cart(int product_id, int quantity) {\n        cart_manager_.update_cart(product_id, quantity);\n    }\n    uint64_t calculate_cart_total() {\n        return order_manager_.calculate_cart_total();\n    }\n    void place_order() {\n        order_manager_.place_order();\n    }\n    void save_to_file(const std::string& filename) {\n        persistence_manager_.save_to_file(filename);\n    }\n    void load_from_file(const std::string& filename) {\n        persistence_manager_.load_from_file(filename);\n    }\nprivate:\n    ProductManager product_manager_;\n    CartManager cart_manager_;\n    OrderManager order_manager_{product_manager_, cart_manager_};\n    PersistenceManager persistence_manager_{product_manager_};\n};\nint main() {\n    ECommerce e_commerce;\n    e_commerce.add_product(1, “Laptop”, 999.99);\n    e_commerce.add_product(2, “Smartphone”, 699.99);\n    e_commerce.add_product(3, “Headphones”, 99.99);\n    e_commerce.list_products();\n    e_commerce.add_to_cart(1, 1); // Add 1 Laptop to the cart\n    e_commerce.add_to_cart(3, 2); // Add 2 Headphones to the cart\n    uint64_t cart_total = e_commerce.calculate_cart_total();\n    std::cout << “Cart Total: $” << cart_total << std::endl;\n    e_commerce.place_order();\n    std::cout << “Order placed successfully!” << std::endl;\n    e_commerce.save_to_file(“products.txt”);\n    e_commerce.remove_product(1);\n    e_commerce.remove_product(2);\n    e_commerce.remove_product(3);\n    std::cout << “Loading products from file...” << std::endl;\n    e_commerce.load_from_file(“products.txt”);\n    e_commerce.list_products();\n    return 0;\n}\n```", "```cpp\n#include <cstddef>\n#include <algorithm>\n// Actually sending the data\nvoid do_send(const std::uint8_t* data, size_t size);\nvoid send(const std::uint8_t* data, size_t size) {\n    for (std::size_t position = 0; position < size;) {\n        std::size_t length = std::min(size_t{256}, size - position);  // 256 is a magic number\n        do_send(data + position, position + length);\n        position += length;\n    }\n}\n```", "```cpp\n#include <cstddef>\n#include <algorithm>\nconstexpr std::size_t MAX_DATA_TO_SEND = 256;  // Named constant replaces magic number\n// Actually sending the data\nvoid do_send(const std::uint8_t* data, size_t size);\nvoid send(const std::uint8_t* data, size_t size) {\n    for (std::size_t position = 0; position < size;) {\n        std::size_t length = std::min(MAX_DATA_TO_SEND, size - position);  // Use the named constant\n        do_send(data + position, position + length);\n        position += length;\n    }\n}\n```", "```cpp\n#include <pthread.h>\n#include <iostream>\nvoid* calculate(void* arg) {\n    int* result = new int(0);\n    for (int i = 0; i < 10000; ++i)\n        *result += i;\n    pthread_exit(result);\n}\nint main() {\n    pthread_t thread;\n    if (pthread_create(&thread, nullptr, calculate, nullptr)) {\n        std::cerr << “Error creating thread\\n”;\n        return 1;\n    }\n    int* result = nullptr;\n    if (pthread_join(thread, (void**)&result)) {\n        std::cerr << “Error joining thread\\n”;\n        return 2;\n    }\n    std::cout << “Result: “ << *result << ‘\\n’;\n    delete result;\n    return 0;\n}\n```", "```cpp\n#include <future>\n#include <iostream>\nint calculate() {\n    int result = 0;\n    for (int i = 0; i < 10000; ++i)\n        result += i;\n    return result;\n}\nint main() {\n    std::future<int> future = std::async(std::launch::async, calculate);\n    try {\n        int result = future.get();\n        std::cout << “Result: “ << result << ‘\\n’;\n    } catch (const std::exception& e) {\n        std::cerr << “Error: “ << e.what() << ‘\\n’;\n        return 1;\n    }\n    return 0;\n}\n```", "```cpp\n#include <vector>\n#include <iostream>\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5, 6};\n    bool has_even = false;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        if (numbers[i] % 2 == 0) {\n            has_even = true;\n            break;\n        }\n    }\n    if (has_even)\n        std::cout << “The vector contains an even number.\\n”;\n    else\n        std::cout << “The vector does not contain any even numbers.\\n”;\n    return 0;\n}\n```", "```cpp\n#include <vector>\n#include <algorithm>\n#include <iostream>\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5, 6};\n    bool has_even = std::any_of(numbers.begin(), numbers.end(),\n                                [](int n) { return n % 2 == 0; });\n    if (has_even)\n        std::cout << “The vector contains an even number.\\n”;\n    else\n        std::cout << “The vector does not contain any even numbers.\\n”;\n    return 0;\n}\n```", "```cpp std::all_of`` ```"]