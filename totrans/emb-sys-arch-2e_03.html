<html><head></head><body>
<div id="_idContainer021">
<h1 class="chapter-number" id="_idParaDest-64"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-65"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.2.1">Architectural Patterns</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Starting an embedded project from scratch means progressively stepping towards the final solution by going through all the research and development phases and considering the synergy among all the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">parts involved.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Software development needs to evolve accordingly throughout these phases. </span><span class="koboSpan" id="kobo.5.2">In order to get the best results without excessive overhead, there are a few best practices to follow and tools </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">to discover.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">This chapter describes a possible approach toward configuration-management tools and design patterns, based on real-life experiences. </span><span class="koboSpan" id="kobo.7.2">Describing this approach may help you to understand the dynamics of working in a team focused on producing an embedded device </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">or solution.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">We will discuss the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">this chapter:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Configuration management</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Source </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">code organization</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">The life cycle of an </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">embedded project</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Security considerations</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">By the end of the chapter, you will gain an overview of the architectural patterns useful for designing the system based on the specifications and the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">platform limits.</span></span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.19.1">Configuration management</span></h1>
<p><span class="koboSpan" id="kobo.20.1">When working as a team, coordination and synchronization can be optimized to improve efficiency. </span><span class="koboSpan" id="kobo.20.2">Tracking and </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.21.1">controlling the development life cycle smoothens the development flow, cutting downtime </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">and costs.</span></span></p>
<p><span class="koboSpan" id="kobo.23.1">The most important tools known to help manage the software life cycle are </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.25.1">Revision control</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.26.1">Issue tracking</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Code reviews</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.28.1">Continuous integration</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.29.1">Different options exist for the four categories. </span><span class="koboSpan" id="kobo.29.2">The source code is synchronized among developers through </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.30.1">a revision control system. </span><strong class="bold"><span class="koboSpan" id="kobo.31.1">Issue tracking systems</span></strong><span class="koboSpan" id="kobo.32.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.33.1">ITSs</span></strong><span class="koboSpan" id="kobo.34.1">) usually consist of web </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.35.1">platforms that keep track of the activities and known bugs of the system. </span><span class="koboSpan" id="kobo.35.2">Code reviews can be encouraged with specific web-based tools and enforced through rules on the revision </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">control systems.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">Continuous integration tools ensure that build and test execution tasks are scheduled to automatically execute, periodically or upon changes in the code, collecting test results and notifying the developers </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">about regression</span><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.39.1">s.</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.40.1">Revision control</span></h2>
<p><span class="koboSpan" id="kobo.41.1">No matter whether </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.42.1">you are working alone or in a large development team, properly keeping track of the development progress is extremely important. </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">Revision control</span></strong><span class="koboSpan" id="kobo.44.1"> tools allow developers to roll back failed experiments at any time with the press of a button, and visiting its history gives a clear view of how the project is evolving at </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">any time.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">revision control system</span></strong><span class="koboSpan" id="kobo.48.1">, also </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.49.1">known as a </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">version control system</span></strong><span class="koboSpan" id="kobo.51.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">VCS</span></strong><span class="koboSpan" id="kobo.53.1">, encourages </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.54.1">cooperation by making merge operations easier. </span><span class="koboSpan" id="kobo.54.2">The most updated official version is referred to as a </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">trunk</span></strong><span class="koboSpan" id="kobo.56.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">master</span></strong><span class="koboSpan" id="kobo.58.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">main</span></strong><span class="koboSpan" id="kobo.60.1"> branch, depending on the VCS in use. </span><span class="koboSpan" id="kobo.60.2">VCSs offer, among other things, fine-grained access control and authorship attribution down to a </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">single commit.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">One of the most modern and widely used open source VCSs is Git. </span><span class="koboSpan" id="kobo.62.2">Originally created as the VCS for the Linux kernel, Git offers a range of features but, most importantly, provides a flexible mechanism to allow switching among different versions and feature branches quickly and reliably and facilitates the integration of conflicting modifications in </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">the code.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.64.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.65.1">Git terminology is used in this </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.66.1">book when describing specific activities related to </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">the VCS.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">commit</span></strong><span class="koboSpan" id="kobo.70.1"> is a VCS action that </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.71.1">results in a new version of the repository. </span><span class="koboSpan" id="kobo.71.2">The repository keeps track of the sequence of commits and the changes introduced in each version in a </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">hierarchical structure:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.73.1">Branch</span></strong><span class="koboSpan" id="kobo.74.1">: A linear sequence of commits is </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">a branch.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.76.1">HEAD</span></strong><span class="koboSpan" id="kobo.77.1">: The latest version in a branch is </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">called HEAD.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.79.1">master</span></strong><span class="koboSpan" id="kobo.80.1">: Git refers to the main development branch as a master. </span><span class="koboSpan" id="kobo.80.2">The master branch is the main focus of the development. </span><span class="koboSpan" id="kobo.80.3">Bug fixes and minor changes may be committed directly to </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">the master.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.82.1">Feature branches</span></strong><span class="koboSpan" id="kobo.83.1">: These are created for self-contained tasks in progressing and ongoing experiments, which will eventually be merged into the master. </span><span class="koboSpan" id="kobo.83.2">When not abused, feature </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.84.1">branches are a perfect fit when working in a smaller sub-team on a task and can simplify the code review process, allowing developers to work simultaneously on separate branches, and concentrate the validation of completed tasks as single </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.85.1">merge</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.86.1"> requests.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.87.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.88.1">merge operation</span></strong><span class="koboSpan" id="kobo.89.1"> consists of joining together two versions from two different branches that may have diverged </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.90.1">and present conflict in the code throughout the development. </span><span class="koboSpan" id="kobo.90.2">Some merges are trivial and are automatically resolved by the VCS, while others may require </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">manual fixing.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">Using meaningful and verbose commit messages improves the readability of the history of the repository and can </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.93.1">help to track regressions later on. </span><strong class="bold"><span class="koboSpan" id="kobo.94.1">Tags</span></strong><span class="koboSpan" id="kobo.95.1"> can be used to track intermediate versions that are released </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">and di</span><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.97.1">stributed.</span></span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.98.1">Tracking activities</span></h2>
<p><span class="koboSpan" id="kobo.99.1">Keeping track of </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.100.1">activities and tasks can be simplified by using ITS. </span><span class="koboSpan" id="kobo.100.2">Some tools can be directly linked to the revision control system so that tasks can be linked to specific commits in the repository and vice versa. </span><span class="koboSpan" id="kobo.100.3">This is, in general, a good idea, as it is possible to have a good overview of what has been changed to accomplish a </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">specific task.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">At first, tasking out the specifications into short activities facilitates the approach to development. </span><span class="koboSpan" id="kobo.102.2">Ideally, tasks are as small as possible and may be grouped by category. </span><span class="koboSpan" id="kobo.102.3">Later on, priorities can be set based on intermediate goals and taking into account the availability of the final hardware. </span><span class="koboSpan" id="kobo.102.4">Tasks created should be grouped into intermediate milestones, which some tools refer to as blueprints, so that the overall progress towards an intermediate deliverable can be measured based on the progress made on </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">single tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">ITS can be used to </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.105.1">track actual issues in the project. </span><span class="koboSpan" id="kobo.105.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">bug report</span></strong><span class="koboSpan" id="kobo.107.1"> should be extensive enough for other developers to understand the symptoms and </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.108.1">reproduce the behavior that proves that there is a defect in the code. </span><span class="koboSpan" id="kobo.108.2">Ideally, final users and early adopters should be able to add new issues to the tracking system, so the tracking system can be used to track all communication with the development team. </span><span class="koboSpan" id="kobo.108.3">Community-based open source projects should provide a publicly accessible ITS interface </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">to users.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">Bug-fixing activities generally get a higher priority than development tasks, except in a few cases, for instance, when the bug is the effect of a temporary approximation done by an intermediate </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.111.1">prototype, which is expected to be fixed in the next iteration. </span><span class="koboSpan" id="kobo.111.2">When a bug affects the behavior of the system, which was proven to work beforehand, it must be marked as a regression. </span><span class="koboSpan" id="kobo.111.3">This is important because regressions can usually be handled differently than normal bugs, as it is possible to track them down to a single commit using revision </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">control tools.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.113.1">Repository control</span></strong><span class="koboSpan" id="kobo.114.1"> platforms provide several tools, including source code history browsing and the issue-tracking </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.115.1">features described earlier. </span><span class="koboSpan" id="kobo.115.2">GitLab is a free and open source implementation of such repository control platforms, which can be installed to run as a self-hosted solution. </span><span class="koboSpan" id="kobo.115.3">Community projects are often hosted on social coding platforms, such as GitHub, which aim to facilitate contributions to open source and free </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">sof</span><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.117.1">tware projects.</span></span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.118.1">Code reviews</span></h2>
<p><span class="koboSpan" id="kobo.119.1">Often integrated </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.120.1">into ITS tools, </span><strong class="bold"><span class="koboSpan" id="kobo.121.1">code reviews</span></strong><span class="koboSpan" id="kobo.122.1"> facilitate team cooperation by encouraging the critical analysis of the changes proposed to the code base, which can be useful to detect potential issues before the proposed changes make it to the master branch. </span><span class="koboSpan" id="kobo.122.2">Depending on the project requirements, code reviews may be recommended, or even enforced by the team, to increase the quality of the code and early detection of defects by </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">human inspection.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">When properly integrated with the VCS, it is possible to set a threshold of mandatory positive reviews from other members of the team before the commit is considered for merging. </span><span class="koboSpan" id="kobo.124.2">It is possible to mandate the review of every single commit in the master branch, using tools such as </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">Gerrit</span></strong><span class="koboSpan" id="kobo.126.1">, integrated with the VCS. </span><span class="koboSpan" id="kobo.126.2">Depending on the size of the contribution, this </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.127.1">mechanism can introduce some unnecessary overhead, so, in most cases, it may be more appropriate to group the changes introduced by a branch altogether to facilitate the </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.128.1">review when the branch is proposed for merging into the master. </span><span class="koboSpan" id="kobo.128.2">Mechanisms based on merge requests give the reviewers an overview of the changes introduced during the entire development of the modification proposed. </span><span class="koboSpan" id="kobo.128.3">In the case of open source projects that accept external contributions, code reviews are a necessary step to validate the changes coming from less trusted contributors, or in general, from outside the team of maintainers. </span><span class="koboSpan" id="kobo.128.4">Code reviews are the most powerful tool to prevent malicious code that may be disguised and could not be detected by automatic test and code </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">a</span><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.130.1">nalysis utilities.</span></span></p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.131.1">Continuous integration</span></h2>
<p><span class="koboSpan" id="kobo.132.1">As previously mentioned, the test-driven approach is crucial in an embedded environment. </span><span class="koboSpan" id="kobo.132.2">Automating tests is the </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.133.1">best way to promptly detect regressions, and defects in general, while the development is ongoing. </span><span class="koboSpan" id="kobo.133.2">Using an </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.134.1">automation server, such as </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">Jenkins</span></strong><span class="koboSpan" id="kobo.136.1">, it is possible to plan several actions, or </span><em class="italic"><span class="koboSpan" id="kobo.137.1">jobs</span></em><span class="koboSpan" id="kobo.138.1">, to run responsively (such as at every commit), periodically (such as every Tuesday at 1 a.m.), or manually, upon user requests. </span><span class="koboSpan" id="kobo.138.2">Here are a few examples of jobs that can be automated to improve the efficiency of an </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">embedded project:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.140.1">Unit tests on the </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">development machine</span></span></li>
<li><span class="koboSpan" id="kobo.142.1">System </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">validation tests</span></span></li>
<li><span class="koboSpan" id="kobo.144.1">Functional tests on a </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">simulated environment</span></span></li>
<li><span class="koboSpan" id="kobo.146.1">Functional tests on a physical </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">target platform</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.148.1">Stability tests</span></span></li>
<li><span class="koboSpan" id="kobo.149.1">Static </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">code analysis</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.151.1">Generating documentation</span></span></li>
<li><span class="koboSpan" id="kobo.152.1">Tagging, versioning, </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">and packaging</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.154.1">The desired level of quality must be decided during design, and test cases must be coded accordingly. </span><span class="koboSpan" id="kobo.154.2">Unit test code coverage can be measured using </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">gcov</span></strong><span class="koboSpan" id="kobo.156.1"> upon each test execution. </span><span class="koboSpan" id="kobo.156.2">Some projects intended for life-critical applications may require a very high percentage of coverage for </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.157.1">unit tests, but writing a complete set of tests for a complex system has a great impact on the total programming effort and may increase the cost of the development significantly, so researching the right balance between efficiency and quality is advisable in </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">most cases.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">A different approach has to be taken with functional tests. </span><span class="koboSpan" id="kobo.159.2">All the functionalities implemented on the target should be tested, and tests prepared in advance should be used to define performance indicators and acceptance thresholds. </span><span class="koboSpan" id="kobo.159.3">Functional tests should be run in an </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.160.1">environment that is as close as possible to the real use case scenario in all those cases where it is impossible to recreate the full use case on the target system</span><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.161.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">its surroundings.</span></span></p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.163.1">Source code organization</span></h1>
<p><span class="koboSpan" id="kobo.164.1">The code base should contain all the source code, third-party libraries, data, scripts, and automation needed to </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.165.1">build the final image. </span><span class="koboSpan" id="kobo.165.2">It is a good idea to keep self-contained libraries in separate directories so that they can be easily updated to newer versions by replacing the subdirectory. </span><span class="koboSpan" id="kobo.165.3">Makefiles and other scripts can be placed in the project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">root directory.</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">Application code should be short and synthetic and access the modules abstracting the macro functionalities. </span><span class="koboSpan" id="kobo.167.2">Functional modules should describe a process while hiding the details of the underlying implementation, such as reading data from a sensor after it has been properly sampled and processed. </span><span class="koboSpan" id="kobo.167.3">Aiming for small, self-contained, and adequately abstracted modules also makes the components of the architecture easier to test. </span><span class="koboSpan" id="kobo.167.4">Keeping the majority of the logic for the application components separated from their hardware-specific implementation improves portability across different platforms and allows us to change the peripherals and the interfaces used on the target even during the development </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.168.1">phase. </span><span class="koboSpan" id="kobo.168.2">Abstracting too much, though, impacts costs, in terms of development effort and resources needed, so the right balan</span><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.169.1">ce should </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">be researched.</span></span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.171.1">Hardware abstraction</span></h2>
<p><span class="koboSpan" id="kobo.172.1">General-purpose prototyping platforms are built and distributed by silicon manufacturers to </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.173.1">evaluate microcontrollers and peripherals, so part of the software development may often be performed on these devices even before the design of the final </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">product begins.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">The software that can be run on the evaluation board is usually distributed as a reference implementation, in the form of source code or proprietary precompiled libraries. </span><span class="koboSpan" id="kobo.175.2">These libraries can be configured and adapted for the final target, to be used as reference hardware abstraction from the beginning, and their settings updated to match changes in the </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">hardware configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">On our reference target, support for the hardware components of a generic Cortex-M microcontroller is </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.178.1">provided in the form of a library called </span><strong class="bold"><span class="koboSpan" id="kobo.179.1">Cortex Microcontroller Software Interface Standard</span></strong><span class="koboSpan" id="kobo.180.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.181.1">CMSIS</span></strong><span class="koboSpan" id="kobo.182.1">), distributed by ARM as a reference implementation. </span><span class="koboSpan" id="kobo.182.2">Silicon manufacturers derive their specific hardware abstractions by extending CMSIS. </span><span class="koboSpan" id="kobo.182.3">An application linked to a target-specific hardware abstraction can access peripherals through its specific API calls and core MCU functionalities </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">through CMSIS.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">For code to be portable across different MCUs in the same family, drivers may require an additional level of abstraction on top of the vendor-specific API calls. </span><span class="koboSpan" id="kobo.184.2">If the HAL implements multiple targets, it can provide the same API to access generic features across multiple platforms, hiding the hardware-specific implementation under </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">the hood.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">The goal of CMSIS and </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.187.1">other free software alternatives, such as </span><strong class="bold"><span class="koboSpan" id="kobo.188.1">libopencm3</span></strong><span class="koboSpan" id="kobo.189.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.190.1">unicore-mx</span></strong><span class="koboSpan" id="kobo.191.1">, is to group all the generic Cortex-M abstractions and the vendor-specific </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.192.1">code for the most common Cortex-M silicon manufacturers while masking the difference among platform-specific calls when controlling the system and </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">the peripherals.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">Regardless of the hardware abstraction, some of the code required at the earliest stage of the boot is very specific to each target the software is intended to run on. </span><span class="koboSpan" id="kobo.194.2">Each platform has its own specific address space segmentation, interrupt vector, and configuration register displacement. </span><span class="koboSpan" id="kobo.194.3">This means that while working on code that is supposed to be portable among different platforms, makefiles and scripts automating the build must be configurable to link using the correct startup code and </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">linker configurations.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">The examples contained in this book do not depend on any specific hardware abstraction, as they </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.197.1">aim to introduce the control of the system components by directly interacting with the system registers and implementing platform-specific device drivers while focusing on the interaction</span><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.198.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">hardware component.</span></span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.200.1">Middleware</span></h2>
<p><span class="koboSpan" id="kobo.201.1">Some of the features may already have a well-known solution that has been previously implemented by </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.202.1">a single developer, a community, or an enterprise. </span><span class="koboSpan" id="kobo.202.2">Solutions may be generic, perhaps designed for a different platform, or even come from outside the </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">embedded world.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">In any case, it is always worth looking for libraries for any data transformation, protocol implementation, or subsystem model that might already have been coded and is waiting to be integrated into </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">our project.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">Several open source libraries and software components are ready to be included in embedded projects, allowing us to implement a broader set of functionalities. </span><span class="koboSpan" id="kobo.206.2">Integrating components from open source projects is particularly useful for delivering standard functionalities. </span><span class="koboSpan" id="kobo.206.3">There is a vast choice of well-established open source implementations designed for embedded devices that can be easily integrated into embedded projects, including the </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">following examples:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.208.1">Real-time </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">operating systems</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.210.1">Cryptography libraries</span></span></li>
<li><span class="koboSpan" id="kobo.211.1">TCP/IP, 6LoWPAN, </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.212.1">and other </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">network protocols</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.214.1">Transport Layer Security</span></strong><span class="koboSpan" id="kobo.215.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.216.1">TLS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">) libraries</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.218.1">Filesystems</span></span></li>
<li><span class="koboSpan" id="kobo.219.1">IoT message </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">queue protocols</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.221.1">Parsers</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.222.1">Some components from these categories are described in more detail later in </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">Basing the software upon an operating system allows us to manage memory areas and thread execution. </span><span class="koboSpan" id="kobo.224.2">In this case, threads execute independently from each other, and it is even possible to implement memory separation among threads and between running threads and the kernel. </span><span class="koboSpan" id="kobo.224.3">This approach is advisable when the complexity of the design increases or when there are well-known blocking points in the modules that cannot be redesigned. </span><span class="koboSpan" id="kobo.224.4">Other libraries usually require multithreading support if an operating system is used, which can be enabled at </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">compile time.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">The decision of integrating </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.227.1">third-party libraries must be evaluated by measuring the resources needed, in terms of code size and memory used, to perform specific tasks on the target platform. </span><span class="koboSpan" id="kobo.227.2">As the whole firmware is distributed as a single executable file, all the licenses of the components must be compatible, and the integration must not violate the license terms </span><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.228.1">of any of its </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">single components.</span></span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.230.1">Application code</span></h2>
<p><span class="koboSpan" id="kobo.231.1">The role of the application code is to coordinate, from the highest layer in the project design, all the </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.232.1">modules involved, and orchestrate the heuristics of the system. </span><span class="koboSpan" id="kobo.232.2">A clean main module that is well-designed allows us to keep a clear view of all the macroscopic blocks of the system, how they are related to each other, and the execution timing of the </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">various components.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">Bare-metal applications are built around a main endless loop function, which is in charge of distributing the CPU time among the entry points of the underlying libraries and drivers. </span><span class="koboSpan" id="kobo.234.2">The execution happens sequentially, so the code cannot be suspended except by interrupt handlers. </span><span class="koboSpan" id="kobo.234.3">For this reason, all the functions and library calls invoked from the main loop are supposed to return as fast as possible because stall points hidden inside other modules may compromise the system’s reactivity, or even block them forever, with the risk of never returning to the main loop. </span><span class="koboSpan" id="kobo.234.4">Ideally, in a bare-metal system, every component is designed to interact with the main loop using the event-driven paradigm, with the main loop constantly waiting for events and mechanisms to register callbacks to wake up the application on </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">specific events.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">The advantage of the bare-metal, single-thread approach is that synchronization among threads is not needed, all the memory is accessible by any function in the code, and it is not necessary to implement complex mechanisms, such as context and execution model switches. </span><span class="koboSpan" id="kobo.236.2">Some basic synchronization mechanisms, however, could still be required when interrupts are on and the flow of execution can be interrupted by external events at any point to execute a </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">specific handler.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">If multiple tasks are meant to run on top of an operating system, each task should be confined as much as possible within its own module and explicitly export its start function and public variables as global symbols. </span><span class="koboSpan" id="kobo.238.2">In this case, tasks can sleep and call blocking functions, which should implement the OS-specific </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">blocking mechanisms.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">Thanks to the flexibility of the Cortex-M CPU, there are different degrees of threads and process separation that can be activated on </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">The CPU offers multiple tools to facilitate the development of multithreading systems with separation among tasks, multiple execution modes, kernel-specific registers, privilege separation, and memory-segmentation techniques. </span><span class="koboSpan" id="kobo.242.2">These options allow architects to define complex systems, more oriented to general-purpose applications, which offer privilege </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.243.1">separation and memory segmentation among processes, but also smaller, simpler, more straightforward systems, which do not need these as they are generally designed for a </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">single purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">Selecting an executing model that is based on non-privileged threads results in a much more complex implementation of the context changes in the system, and may impact the latency of the real-time operations, which is why bare-metal, single-threaded solutions are still preferred for most </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">real-time applications.</span></span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.247.1">Security considerations</span></h1>
<p><span class="koboSpan" id="kobo.248.1">One of the most important aspects to consider when designing a new system is security. </span><span class="koboSpan" id="kobo.248.2">Depending on the characteristics of the system, the requirements, and the evaluation of the risks, different countermeasures may be appropriate. </span><span class="koboSpan" id="kobo.248.3">Security-enhancing features are often a mix of hardware and software efforts to provide specific protections against </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">known attacks.</span></span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.250.1">Vulnerability management</span></h2>
<p><span class="koboSpan" id="kobo.251.1">Software components </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.252.1">keep evolving as new features are introduced, and defects are fixed along the way. </span><span class="koboSpan" id="kobo.252.2">Some of the defects that are discovered and fixed in a later version may impact the security of the system running outdated software if proper action is not taken promptly. </span><span class="koboSpan" id="kobo.252.3">Once vulnerabilities in third-party components are fully disclosed to the public, it is no longer a good choice to keep running </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">outdated code.</span></span></p>
<p><span class="koboSpan" id="kobo.254.1">Older versions with known defects running on public networks have an increased possibility of becoming the attack surface for attempts to damage the system, take control of the software execution, or steal important data. </span><span class="koboSpan" id="kobo.254.2">The best response is prepared very early during the design of the system and consists of planning remote updates using procedures that fit the specific use case, security requirements, and </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">safety levels.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">When using third-party </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.257.1">libraries, it is appropriate to follow the development of their latest versions and fully understand the impact of the defects that are fixed, especially when those are marked as </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">security issues.</span></span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.259.1">Software cryptography</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.260.1">Cryptography</span></strong><span class="koboSpan" id="kobo.261.1"> algorithms should be used when appropriate, for example, to encrypt data stored locally or in </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.262.1">transit between two </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.263.1">systems, authenticate a remote actor on the network, or verify that data has not been altered and comes from a </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">trusted source.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">Good cryptography is always based on open, transparent standards so that the security of the system depends solely on the security of the keys, according to the Kerckhoff principle formulated by the Dutch cryptographer Auguste Kerckhoff in the 19</span><span class="superscript"><span class="koboSpan" id="kobo.266.1">th</span></span><span class="koboSpan" id="kobo.267.1"> century, rather than on secret mechanisms, with the (false) hope that its implementation will never be disclosed or reverse engineered. </span><span class="koboSpan" id="kobo.267.2">Although this last statement should be obvious to whoever has some confidence with the concept of information security, in the past many embedded systems have adopted </span><em class="italic"><span class="koboSpan" id="kobo.268.1">security by obscurity</span></em><span class="koboSpan" id="kobo.269.1">, as a bad practice of taking shortcuts in the attempt to circumvent the restrictions posed by the lack of appropriate resources to run well-established cryptography primitives on older </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">hardware architectures.</span></span></p>
<p><span class="koboSpan" id="kobo.271.1">Nowadays, embedded cryptography libraries exist, capable of running the same latest standard algorithms used in PCs and servers in microcontroller-based systems, which meanwhile are becoming more powerful and fit for running the (often CPU-hungry) cryptography math primitives. </span><span class="koboSpan" id="kobo.271.2">A complete cryptography library offers a ready-to-use implementation of, typically, three families </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">of algorithms:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.273.1">Asymmetric cryptography</span></strong><span class="koboSpan" id="kobo.274.1"> (RSA, ECC) is based on a pair of keys, private and public, associated </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.275.1">with each other. </span><span class="koboSpan" id="kobo.275.2">Besides one-way encryption, these algorithms provide other mechanisms, such as authenticating a signature and deriving secondary keys starting from two key pairs, for example, to use as a shared secret by both endpoints communicating over an </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">untrusted medium.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.277.1">Symmetric cryptography</span></strong><span class="koboSpan" id="kobo.278.1"> (AES, ChaCha20) is mostly adopted for bidirectional encryption </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.279.1">using the same pre-shared secret key in </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">both directions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.281.1">Hash algorithms</span></strong><span class="koboSpan" id="kobo.282.1"> (SHA) provide an </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.283.1">injective digest calculation and are often used to verify that data has not </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">been altered.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.285.1">A complete set of algorithms, optimized for embedded systems, is provided by wolfCrypt, the </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.286.1">cryptography engine distributed as part of wolfSSL, a professionally maintained open source library that also includes transport layer security protocols, which will be further explained in </span><a href="B18730_09.xhtml#_idTextAnchor311"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.287.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.288.1">, </span><em class="italic"><span class="koboSpan" id="kobo.289.1">Distributed Systems and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.290.1">IoT Architecture</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.292.1">Hardware cryptography</span></h2>
<p><span class="koboSpan" id="kobo.293.1">Taking security aspects under consideration from the very beginning of the design process is important </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.294.1">to prematurely identify software and hardware components needed to implement the correct mechanisms. </span><span class="koboSpan" id="kobo.294.2">Simply adding a cryptography library does not guarantee an increased level of security in the system unless all the requirements are fulfilled, which often implies some participation from specific </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">hardware components.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">Some algorithms require random values with high entropy, which is often hard to obtain on microcontrollers </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.297.1">without the help of specific hardware, such as </span><strong class="bold"><span class="koboSpan" id="kobo.298.1">True Random Number </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.299.1">Generators</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.300.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.301.1">TRNGs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">Other public-key-based cryptography requires trust anchor storage, which means a memory location that cannot be modified at runtime by an attacker, and usually relies on some non-volatile memory features that may be present on the flash memory controller. </span><span class="koboSpan" id="kobo.303.2">Finally, to store secret keys, hardware assistance can be needed to provide a secure vault that </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.304.1">can only be accessed by privileged code or, in some cases, is never accessible from software and is only allowed to be used in combination with hardware cryptography engines that are coupled with </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">secure storage.</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.306.1">Running untrusted code</span></h2>
<p><span class="koboSpan" id="kobo.307.1">As embedded systems become more complex and the code memory increases, it is not unusual to see </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.308.1">software components from multiple sources integrated into a single firmware image. </span><span class="koboSpan" id="kobo.308.2">Some systems may even provide a software development kit that runs custom code provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">Others may have an interface that allows you to execute code from a remote location. </span><span class="koboSpan" id="kobo.310.2">In all these cases, it would be appropriate to consider separation mechanisms to prevent accidental (or intentional) access to memory areas or peripherals that should not be reachable by actors with </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">lower capabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">Most microcontrollers provide two levels of execution privileges, and on some platforms, it is possible to divide the addressable memory space according to those privileges through context switching in the OS. </span><span class="koboSpan" id="kobo.312.2">Newer generations of microcontrollers provide TEEs to strictly enforce memory boundaries based</span><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.313.1"> on the execution level of the </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">current stage.</span></span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.315.1">The life cycle of an embedded project</span></h1>
<p><span class="koboSpan" id="kobo.316.1">Modern development frameworks suggest splitting the work into smaller action points and marking </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.317.1">milestones through the project development while producing intermediate working deliverables. </span><span class="koboSpan" id="kobo.317.2">Each deliverable focuses on giving a prototype of the entire system, with the missing features temporarily replaced using </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">dummy code.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">These recommendations seem particularly effective for embedded projects. </span><span class="koboSpan" id="kobo.319.2">In an environment where every error could be fatal to the entire system, working on small action points, one </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.320.1">at a time, is an efficient way to promptly identify defects and regressions while working on the code base, provided that a </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">Continuous Integration</span></strong><span class="koboSpan" id="kobo.322.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.323.1">CI</span></strong><span class="koboSpan" id="kobo.324.1">) mechanism is in place from the early stages of the development. </span><span class="koboSpan" id="kobo.324.2">Intermediate milestones should be as frequent as possible, and for this reason, it is advisable to create a prototype of the final system as soon as possible in the development phase. </span><span class="koboSpan" id="kobo.324.3">This has to be taken into account when actions are identified, prioritized, and distributed to </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">the team.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">Once the steps to reach the goal are defined, we need to find the optimal sequence to produce working prototypes for the intermediate milestones. </span><span class="koboSpan" id="kobo.326.2">The dependencies among the development actions are taken into account to sort the priorities for the assignments of </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">the work.</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">A progressive understanding of the system behavior and hardware constraints may change the view on the system’s architecture while it is under development, as unexpected issues are faced. </span><span class="koboSpan" id="kobo.328.2">Changing specifications as a reaction to measurements and evaluations performed on </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.329.1">the intermediate prototype may require a major code rework. </span><span class="koboSpan" id="kobo.329.2">Throwing away consistent parts of the project to replace them with a new, improved design is often beneficial for the quality of the project and may result </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.330.1">in improved productivity in the later stages. </span><span class="koboSpan" id="kobo.330.2">This process, known as </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">refactoring</span></strong><span class="koboSpan" id="kobo.332.1">, must not be seen as a development overhead whenever it is aimed at improving the design and behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">Finally, the process of creating system software includes defining a clear API for the applications to interact with the system in the desired way. </span><span class="koboSpan" id="kobo.334.2">Embedded systems provide specific APIs to access system resources most of the time; however, some operating systems and libraries may provide POSIX-like interfaces to access functionalities. </span><span class="koboSpan" id="kobo.334.3">In any case, the API is the entry point for the system interfaces and m</span><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.335.1">ust be designed for usability and </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">well documented.</span></span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.337.1">Defining project steps</span></h2>
<p><span class="koboSpan" id="kobo.338.1">When analyzing specifications, defining the required steps, and assigning priorities, several factors may </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.339.1">have to be taken into account. </span><span class="koboSpan" id="kobo.339.2">Consider designing an air quality monitor device with a PM10 air quality serial sensor, which collects the hourly measurements into the internal flash, then transmits all the statistics daily to a gateway using a wireless transceiver. </span><span class="koboSpan" id="kobo.339.3">The target system is a custom board based on Cortex-M MCU, which is adequately sized to run the final software. </span><span class="koboSpan" id="kobo.339.4">The final hardware design will not be available until some real-life measurements are done on the transceiver transmitting data to </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">the gateway.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">The list of steps to be performed to reach the final goal resulting from these specifications may look </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.343.1">Boot a minimal system on the target (empty </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">main loop).</span></span></li>
<li><span class="koboSpan" id="kobo.345.1">Set up serial port </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">0</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.347.1">for logging.</span></span></li>
<li><span class="koboSpan" id="kobo.348.1">Set up serial port </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">1</span></strong><span class="koboSpan" id="kobo.350.1"> for the communication to </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">the sensor.</span></span></li>
<li><span class="koboSpan" id="kobo.352.1">Set up </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">a timer.</span></span></li>
<li><span class="koboSpan" id="kobo.354.1">Write the PM10 </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">sensor driver.</span></span></li>
<li><span class="koboSpan" id="kobo.356.1">Create an application that wakes up every hour and reads from </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">the sensor.</span></span></li>
<li><span class="koboSpan" id="kobo.358.1">Write a flash submodule to </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">store/restore measurements.</span></span></li>
<li><span class="koboSpan" id="kobo.360.1">Set up an SPI port to communicate to the </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">radio chip.</span></span></li>
<li><span class="koboSpan" id="kobo.362.1">Write the </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">radio driver.</span></span></li>
<li><span class="koboSpan" id="kobo.364.1">Implement a </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.365.1">protocol to communicate with </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">the gateway.</span></span></li>
<li><span class="koboSpan" id="kobo.367.1">Every 24 measurements, the application sends daily measurements to </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">the gateway.</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.369.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.370.1">Some of the steps may depend on others, so there are constraints on the order of execution. </span><span class="koboSpan" id="kobo.370.2">Some of these dependencies can be removed by using simulators </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">or emulators.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">For example, we might want to implement the communication protocol without having a working radio only if there is a way to test the protocol against the agent running on the gateway by using a simulated radio channel on the gateway itself. </span><span class="koboSpan" id="kobo.372.2">Keeping the modules self-contained and with a minimal set of API calls exposed to the outside makes it easier to detach the single modules to run and test them on different architectures, and under a controlled environm</span><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.373.1">ent, before integrating them into the </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">target system.</span></span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.375.1">Prototyping</span></h2>
<p><span class="koboSpan" id="kobo.376.1">As it is part of the </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.377.1">specifications, we know that we should prioritize the activities related to the radio communication to allow the hardware team to progress on the design, so in this case, the first prototype must do </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">the following:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.379.1">Boot a minimal system on the target (empty </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">main loop).</span></span></li>
<li><span class="koboSpan" id="kobo.381.1">Set up serial port </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">0</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.383.1">for logging.</span></span></li>
<li><span class="koboSpan" id="kobo.384.1">Set up an SPI port to communicate to the </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">radio chip.</span></span></li>
<li><span class="koboSpan" id="kobo.386.1">Write the </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">radio driver.</span></span></li>
<li><span class="koboSpan" id="kobo.388.1">Set up </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">the timer.</span></span></li>
<li><span class="koboSpan" id="kobo.390.1">Write the main application to test the radio channel (sending raw packets at </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">regular intervals).</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.392.1">This first prototype will already start to look like the final device, even if it does not yet know how to communicate with the sensor. </span><span class="koboSpan" id="kobo.392.2">Some test cases can already be implemented to run on a mock gateway, checking that messages are received </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">and valid.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">Moving ahead to the next prototype definition, we can start to add a few additional features. </span><span class="koboSpan" id="kobo.394.2">Real sensor readings are not necessary to progress on the protocol with the gateway, as it is possible to use made-up, </span><em class="italic"><span class="koboSpan" id="kobo.395.1">synthetic</span></em><span class="koboSpan" id="kobo.396.1"> test values that reproduce a specific behavior instead. </span><span class="koboSpan" id="kobo.396.2">This allows us to progress on other tasks when the real hardware is </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">not available.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">Whether the development team is adopting pure agile software development or is working with a different methodology, fast prototyping in an embedded development environment allows responding faster to the uncertainties on the path, which often depend on the behavior of the hardware and the actions that need to be taken in </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">the software.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">Providing workable intermediate deliverables is a common practice in embedded development teams, which directly derives from agile methodologies. </span><span class="koboSpan" id="kobo.400.2">Agile software development foresees the delivery of working software regularly and within short intervals of time. </span><span class="koboSpan" id="kobo.400.3">Like in the preceding example, an intermediate prototype does not have to implement all the logic of the final software image but instead must be used to prove concepts, make </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.401.1">measurements, or pr</span><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.402.1">ovide examples on top of a reduced part of </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">the system.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.404.1">Refactoring</span></h2>
<p><span class="koboSpan" id="kobo.405.1">Too often considered a drastic remedy for a failure, refactoring is actually a healthy practice that improves </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.406.1">the software while the system takes its final shape, and the support for software components and peripherals evolves </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">Refactoring works better if all the tests are up and running on the old code. </span><span class="koboSpan" id="kobo.408.2">Unit tests should be adapted to the new function signatures while redesigning the module internals. </span><span class="koboSpan" id="kobo.408.3">On the other hand, existing functional tests for the module being refactored should not change if the API of the module stays unchanged and will provide continuous feedback about the status and the accuracy of the process as long as the interface toward other modules remains </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">Smaller portions of the code base are exponentially easier to refactor than larger ones, which gives us yet another reason to keep each module small and dedicated to a specific function on the system. </span><span class="koboSpan" id="kobo.410.2">Progressing through intermediate deliverable prototypes implies constant alterations in the application code, which should require less effort when the subsystems are designed to be independ</span><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.411.1">ent of each other and from the application </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">code itself.</span></span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.413.1">API and documentation</span></h2>
<p><span class="koboSpan" id="kobo.414.1">We all know that a book should not be judged by its cover. </span><span class="koboSpan" id="kobo.414.2">However, a system can often be judged by its API, which may reveal many aspects of the internal implementation and the design choices of the </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.415.1">system architects. </span><span class="koboSpan" id="kobo.415.2">A clear, readable, and easy-to-understand API is one of the most important features of an embedded system. </span><span class="koboSpan" id="kobo.415.3">Application developers expect to understand how to access functionalities quickly and to use the system in the most efficient way possible. </span><span class="koboSpan" id="kobo.415.4">The API represents the </span><em class="italic"><span class="koboSpan" id="kobo.416.1">contract</span></em><span class="koboSpan" id="kobo.417.1"> between the system and the applications, and for this reason, it must be designed beforehand and modified as little as possible, if at all, while the development moves towards the </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">final delivery.</span></span></p>
<p><span class="koboSpan" id="kobo.419.1">Some interfaces in the API may describe complex subsystems and abstract more elaborate characteristics, so it is always a good idea to provide adequate documentation to help application developers move around and exploit all the system capabilities. </span><span class="koboSpan" id="kobo.419.2">There are different ways to provide documentation along with the code, either distributing user </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.420.1">manuals in the repository as separate files or including the explanation of the different interfaces directly in </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">The amount of comments in the code is not an indicator of quality. </span><span class="koboSpan" id="kobo.422.2">Comments tend to </span><em class="italic"><span class="koboSpan" id="kobo.423.1">age</span></em><span class="koboSpan" id="kobo.424.1"> whenever the code they refer to gets modified because of the possibility that the developer forgets to update the comment to match the new behavior in the code. </span><span class="koboSpan" id="kobo.424.2">Moreover, not all code needs to be commented; good habits, such as keeping functions short and low in complexity or using expressive symbol names, would make code comments redundant in most cases, as the code can </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">explain itself.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">There are exceptions for lines of code that contain complex calculations, bit shifting, elaborate conditions, or side effects that are not easy to spot when reading the code for the first time. </span><span class="koboSpan" id="kobo.426.2">Some portions of code may also require a description at the beginning, for example, those functions with multiple return values and specific error handling. </span><span class="koboSpan" id="kobo.426.3">Switch/case statements not containing the break instruction between two cases must always have a comment to indicate that the fall-through is intended and not </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">a mistake.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">They should also possibly explain why some actions are grouped between two or more cases. </span><span class="koboSpan" id="kobo.428.2">Adding superfluous </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.429.1">comments that do </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.430.1">not provide any valuable explanation of the code only contributes to making the code harder </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">to read.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">On the other hand, describing the behavior of a module with a separate editor and tools requires dedication, as all the documentation must be updated every time there are significant changes in the code, and the developers are asked to switch the focus away from the </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">actual code.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">Usually, the important part to document is the description of the contract mentioned previously, enumerating and explaining the functions and the variables that the applications and the other components involved can access at runtime. </span><span class="koboSpan" id="kobo.434.2">Since these declarations can be grouped within header files, it is possible to describe the entire contract by adding extended comments on top of the declaration of each </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">exported symbol.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">Software tools exist that convert </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.437.1">these comments into formatted documentation. </span><span class="koboSpan" id="kobo.437.2">A popular example is </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">Doxygen</span></strong><span class="koboSpan" id="kobo.439.1">, a free and open source document-generation tool that parses comments matching a specific syntax in the whole code base to produce hypertexts, structured PDF manuals, and many other formats. </span><span class="koboSpan" id="kobo.439.2">If the documentation is in the code base, updating and keeping track of its results is easier and less invasive for </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.440.1">the developers’ workflow. </span><span class="koboSpan" id="kobo.440.2">Integrating the </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.441.1">generation of the documentation on the automation server can provide a freshly generated copy of the </span><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.442.1">manuals for all the APIs at every commit on the </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">master branch.</span></span></p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.444.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.445.1">The methodologies that have been proposed are meant as an example of reference patterns used to design and manage the development of embedded projects. </span><span class="koboSpan" id="kobo.445.2">While it is possible that some of the patterns described may not apply to all projects, the goal of this chapter is to encourage embedded architects to look for improvements in the process that may result in a more efficient and less expensive software life cycle. </span><span class="koboSpan" id="kobo.445.3">Finally, we analyzed the possibility of increasing security by adding appropriate processes and components when required by the </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">use case.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">In the next chapter, we shall analyze what happens at boot time inside the embedded system, and how to prepare a bootable application using a simple, bare-metal, </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">main-loop approach.</span></span></p>
</div>
</body></html>