- en: Chapter 1. Playing with LLVM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 玩转 LLVM
- en: The LLVM Compiler infrastructure project, started in 2000 in University of Illinois,
    was originally a research project to provide modern, SSA based compilation technique
    for arbitrary static and dynamic programming languages. Now it has grown to be
    an umbrella project with many sub projects within it, providing a set of reusable
    libraries having well defined interfaces.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 编译器基础设施项目始于 2000 年的伊利诺伊大学，最初是一个研究项目，旨在为任意静态和动态编程语言提供基于现代、SSA 的编译技术。现在它已经发展成为一个包含许多子项目的母项目，提供了一组具有良好定义接口的可重用库。
- en: 'LLVM is implemented in C++ and the main crux of it is the LLVM core libraries
    it provides. These libraries provide us with opt tool, the target independent
    optimizer, and code generation support for various target architectures. There
    are other tools which make use of core libraries, but our main focus in the book
    will be related to the three mentioned above. These are built around LLVM Intermediate
    Representation (LLVM IR), which can almost map all the high-level languages. So
    basically, to use LLVM''s optimizer and code generation technique for code written
    in a certain programming language, all we need to do is write a frontend for a
    language that takes the high level language and generates LLVM IR. There are already
    many frontends available for languages such as C, C++, Go, Python, and so on.
    We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 使用 C++ 实现，其核心是它提供的 LLVM 核心库。这些库为我们提供了 opt 工具，即目标无关的优化器，以及针对各种目标架构的代码生成支持。还有其他一些工具使用了核心库，但本书的主要关注点将是上述提到的三个。这些工具围绕
    LLVM 中间表示（LLVM IR）构建，几乎可以映射所有高级语言。所以基本上，要使用 LLVM 的优化器和代码生成技术来处理某种编程语言编写的代码，我们只需要编写一个前端，该前端将高级语言转换为
    LLVM IR。对于 C、C++、Go、Python 等语言，已经有许多前端可用。在本章中，我们将涵盖以下主题：
- en: Modular design and collection of libraries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化设计和库集合
- en: Getting familiar with LLVM IR
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉 LLVM IR
- en: LLVM Tools and using them at command line
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行使用 LLVM 工具
- en: Modular design and collection of libraries
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化设计和库集合
- en: The most important thing about LLVM is that it is designed as a collection of
    libraries. Let's understand these by taking the example of LLVM optimizer opt.
    There are many different optimization passes that the optimizer can run. Each
    of these passes is written as a C++ class derived from the `Pass` class of LLVM.
    Each of the written passes can be compiled into a **.o** file and subsequently
    they are archived into a **.a** library. This library will contain all the passes
    for `opt` tool. All the passes in this library are loosely coupled, that is they
    mention explicitly the dependencies on other passes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 LLVM 最重要的是它被设计为一个库集合。让我们通过 LLVM 优化器 opt 的例子来理解这些。优化器可以运行许多不同的优化过程。每个过程都作为从
    LLVM 的 `Pass` 类派生出的 C++ 类来编写。每个编写的过程都可以编译成一个 **.o** 文件，随后它们被归档到一个 **.a** 库中。这个库将包含
    `opt` 工具的所有过程。这个库中的所有过程都是松散耦合的，也就是说，它们明确地说明了对其他过程的依赖。
- en: When the optimizer is ran, the LLVM `PassManager` uses the explicitly mentioned
    dependency information and runs the passes in optimal way. The library based design
    allows the implementer to choose the order in which passes will execute and also
    choose which passes are to be executed based on the requirements. Only the passes
    that are required are linked to the final application, not the entire optimizer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当优化器运行时，LLVM `PassManager` 使用明确提到的依赖信息，并以最佳方式运行过程。基于库的设计允许实现者选择过程的执行顺序，也可以根据需求选择要执行的过程。只有所需的过程会被链接到最终的应用程序，而不是整个优化器。
- en: The following figure demonstrates how each pass can be linked to a specific
    object file within a specific library. In the following figure, the **PassA**
    references **LLVMPasses.a** for **PassA.o**, whereas the custom pass refers to
    a different library **MyPasses.a** for the **MyPass.o** object file.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了每个过程如何链接到特定库中的特定对象文件。在下面的图中，**PassA** 引用了 **LLVMPasses.a** 以便为 **PassA.o**，而自定义过程则引用了不同的库
    **MyPasses.a** 以便为 **MyPass.o** 对象文件。
- en: '![Modular design and collection of libraries](img/00002.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![模块化设计和库集合](img/00002.jpeg)'
- en: The code generator also makes use of this modular design like the **Optimizer**,
    for splitting the code generation into individual passes, namely, instruction
    selection, register allocation, scheduling, code layout optimization, and assembly
    emission.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成器也像**优化器**一样利用这种模块化设计，将代码生成分割成单独的传递，即指令选择、寄存器分配、调度、代码布局优化和汇编输出。
- en: In each of the following phases mentioned there are some common things for almost
    every target, such as an algorithm for assigning physical registers available
    to virtual registers even though the set of registers for different targets vary.
    So, the compiler writer can modify each of the passes mentioned above and create
    custom target-specific passes. The use of the `tablegen` tool helps in achieving
    this using table description `.td` files for specific architectures. We will discuss
    how this happens later in the book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下提到的每个阶段中，几乎每个目标都有一些共同点，例如为虚拟寄存器分配物理寄存器的算法，尽管不同目标的寄存器集合各不相同。因此，编译器编写者可以修改上述提到的每个传递，并创建自定义的目标特定传递。使用`tablegen`工具通过特定架构的表格描述`.td`文件来实现这一点。我们将在本书的后面讨论这是如何发生的。
- en: Another capability that arises out of this is the ability to easily pinpoint
    a bug to a particular pass in the optimizer. A tool name `Bugpoint` makes use
    of this capability to automatically reduce the test case and pinpoint the pass
    that is causing the bug.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点产生的另一个能力是能够轻松地将错误定位到优化器中的特定传递。一个名为`Bugpoint`的工具利用这一能力来自动缩减测试用例并定位导致错误的传递。
- en: Getting familiar with LLVM IR
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉LLVM IR
- en: LLVM **Intermediate Representation** (**IR**) is the heart of the LLVM project.
    In general every compiler produces an intermediate representation on which it
    runs most of its optimizations. For a compiler targeting multiple-source languages
    and different architectures the important decision while selecting an IR is that
    it should neither be of very high-level, as in very closely attached to the source
    language, nor it should be very low-level, as in close to the target machine instructions.
    LLVM IR aims to be a universal IR of a kind, by being at a low enough level that
    high-level ideas may be cleanly mapped to it. Ideally the LLVM IR should have
    been target-independent, but it is not so because of the inherent target dependence
    in some of the programming languages itself. For example, when using standard
    C headers in a Linux system, the header files itself are target dependent, which
    may specify a particular type to an entity so that it matches the system calls
    of the particular target architecture.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM **中间表示**（**IR**）是LLVM项目的核心。一般来说，每个编译器都会生成一个中间表示，在其上运行大多数优化。对于针对多种源语言和不同架构的编译器，在选择IR时的重要决策是它既不应非常高级，如非常接近源语言，也不应非常低级，如接近目标机器指令。LLVM
    IR旨在成为一种通用的IR，通过足够低的级别，使得高级思想可以干净地映射到它。理想情况下，LLVM IR应该是目标无关的，但由于某些编程语言本身固有的目标依赖性，它并非如此。例如，当在Linux系统中使用标准C头文件时，头文件本身是目标相关的，它可能指定一个特定类型给实体，以便它与特定目标架构的系统调用相匹配。
- en: 'Most of the LLVM tools revolve around this Intermediate Representation. The
    frontends of different languages generate this IR from the high-level source language.
    The optimizer tool of LLVM runs on this generated IR to optimize the code for
    better performance and the code generator makes use of this IR for target specific
    code generation. This IR has three equivalent forms:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数LLVM工具都围绕这个中间表示展开。不同语言的接口生成这种IR从高级源语言。LLVM的优化器工具运行在这个生成的IR上以优化代码以获得更好的性能，代码生成器利用这个IR进行目标特定的代码生成。这种IR有三种等效形式：
- en: An in-memory compiler IR
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存中的编译器IR
- en: An on-disk bitcode representation
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘上的位码表示
- en: A Human readable form (LLVM Assembly)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人类可读形式（LLVM汇编）
- en: Now let's take an example to see how this LLVM IR looks like. We will take a
    small C code and convert it into LLVM IR using clang and try to understand the
    details of LLVM IR by mapping it back to the source language.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过一个例子来看看LLVM IR是如何看起来。我们将取一小段C代码，并使用clang将其转换为LLVM IR，然后通过将其映射回源语言来理解LLVM
    IR的细节。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use the clang frontend with the following options to convert it to LLVM IR:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下选项的clang前端将其转换为LLVM IR：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now let's look at the IR generated and see what it is all about. You can see
    the very first line giving the ModuleID, that it defines the LLVM module for `add.c`
    file. An LLVM module is a top–level data structure that has the entire contents
    of the input LLVM file. It consists of functions, global variables, external function
    prototypes, and symbol table entries.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看生成的 IR，看看它究竟是什么。你可以看到第一行给出了 ModuleID，它定义了 `add.c` 文件的 LLVM 模块。LLVM
    模块是一个顶层数据结构，包含了整个输入 LLVM 文件的内容。它由函数、全局变量、外部函数原型和符号表条目组成。
- en: 'The following lines show the target data layout and target triple from which
    we can know that the target is x86_64 processor with Linux running on it. The
    `datalayout` string tells us what is the endianess of machine (''`e`'' meaning
    little endian), and the name mangling (`m : e` denotes elf type). Each specification
    is separated by ''`–`''and each following spec gives information about the type
    and size of that type. For example, `i64:64` says 64 bit integer is of 64 bits.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '以下几行显示了目标数据布局和目标三元组，我们可以从中知道目标是运行 Linux 的 x86_64 处理器。`datalayout` 字符串告诉我们机器的字节序（''`e`''
    表示小端字节序），以及名称修饰（`m : e` 表示 elf 类型）。每个规范由 ''`–`'' 分隔，每个后续规范都提供了有关该类型及其大小的信息。例如，`i64:64`
    表示 64 位整数是 64 位。'
- en: Then we have a global variable `globvar`. In LLVM IR all globals start with
    '`@`' and all local variables start with '`%`'. There are two main reasons why
    the variables are prefixed with these symbols. The first one being, the compiler
    won't have to bother about a name clash with reserved words, the other being that
    the compiler can come up quickly with a temporary name without having to worry
    about a conflict with symbol table conflicts. This second property is useful for
    representing the IR in **static single assignment** (**SSA**) from where each
    variable is assigned only a single time and every use of a variable is preceded
    by its definition. So, while converting a normal program to SSA form, we create
    a new temporary name for every redefinition of a variable and limit the range
    of earlier definition till this redefinition.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一个全局变量 `globvar`。在 LLVM IR 中，所有全局变量都以 '`@`' 开头，所有局部变量都以 '`%`' 开头。变量前缀这些符号有两个主要原因。第一个原因是，编译器不必担心与保留字发生名称冲突，另一个原因是编译器可以快速生成一个临时名称，而无需担心与符号表冲突。这个第二个特性对于将
    IR 表示为 **静态单赋值**（**SSA**）非常有用，其中每个变量只被赋值一次，每个变量的使用都紧随其定义。因此，在将普通程序转换为 SSA 形式时，我们为每个变量的重新定义创建一个新的临时名称，并限制早期定义的范围直到这个重新定义。
- en: LLVM views global variables as pointers, so an explicit dereference of the global
    variable using load instruction is required. Similarly, to store a value, an explicit
    store instruction is required.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 将全局变量视为指针，因此需要使用加载指令显式地解引用全局变量。同样，要存储一个值，也需要使用显式存储指令。
- en: 'Local variables have two categories:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量分为两类：
- en: '**Register allocated local variables**: These are the temporaries and allocated
    virtual registers. The virtual registers are allocated physical registers during
    the code generation phase which we will see in a later chapter of the book. They
    are created by using a new symbol for the variable like:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寄存器分配的局部变量**：这些是临时变量和分配的虚拟寄存器。在代码生成阶段，虚拟寄存器会被分配到物理寄存器中，我们将在本书的后续章节中看到这一点。它们是通过为变量使用新的符号来创建的：'
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Stack allocated local variables**: These are created by allocating variables
    on the stack frame of a currently executing function, using the `alloca` instruction.
    The `alloca` instruction gives a pointer to the allocated type and explicit use
    of load and store instructions is required to access and store the value.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈分配的局部变量**：这些是通过在当前执行函数的栈帧上分配变量，使用 `alloca` 指令创建的。`alloca` 指令提供了一个指向分配类型的指针，需要显式使用加载和存储指令来访问和存储值。'
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now let's see how the `add` function is represented in LLVM IR. `define i32
    @add(i32 %a)` is very similar to how functions are declared in C. It specifies
    the function returns integer type `i32` and takes an integer argument. Also, the
    function name is preceded by '`@`', meaning it has global visibility.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看在 LLVM IR 中 `add` 函数是如何表示的。`define i32 @add(i32 %a)` 与 C 语言中函数的声明非常相似。它指定了函数返回整数类型
    `i32` 并接受一个整数参数。此外，函数名前有一个 '`@`' 符号，意味着它具有全局可见性。
- en: Within the function is actual processing for functionality. Some important things
    to note here are that LLVM uses a three-address instruction, that is a data processing
    instruction, which has two source operands and places the result in a separate
    destination operand (`%4 = add i32 %2, %3`). Also the code is in SSA form, that
    is each value in the IR has a single assignment which defines the value. This
    is useful for a number of optimizations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内部是实际的功能处理。在此处需要注意的一些重要事项是，LLVM 使用三地址指令，即数据处理指令，它有两个源操作数并将结果放置在单独的目标操作数中（`%4
    = add i32 %2, %3`）。此外，代码是 SSA 形式，即 IR 中的每个值都有一个单独的赋值定义了该值。这对于许多优化非常有用。
- en: The attributes string that follows in the generated IR specifies the function
    attributes which are very similar to C++ attributes. These attributes are for
    the function that has been defined. For each function defined there is a set of
    attributes defined in the LLVM IR.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的 IR 中跟随的属性字符串指定了函数属性，这些属性与 C++ 属性非常相似。这些属性是为已定义的函数设置的。对于每个定义的函数，在 LLVM IR
    中都有一组属性定义。
- en: The code that follows the attributes is for the `ident` directive that identifies
    the module and compiler version.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 属性之后的代码是为 `ident` 指令设置的，该指令用于标识模块和编译器版本。
- en: LLVM tools and using them in the command line
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLVM 工具及其在命令行中的使用。
- en: Until now, we have understood what LLVM IR (human readable form) is and how
    it can be used to represent a high-level language. Now, we will take a look at
    some of the tools that LLVM provides so that we can play around with this IR converting
    to other formats and back again to the original form. Let's take a look at these
    tools one by one along with examples.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了 LLVM IR（可读形式）是什么以及它是如何用来表示高级语言的。现在，我们将查看一些 LLVM 提供的工具，这样我们就可以对这个
    IR 进行格式转换，并再次转换回原始形式。让我们逐一查看这些工具，并附带示例。
- en: '**llvm-as**: This is the LLVM assembler that takes LLVM IR in assembly form
    (human readable) and converts it to bitcode format. Use the preceding `add.ll`
    as an example to convert it into bitcode. To know more about the LLVM Bitcode
    file format refer to [http://llvm.org/docs/BitCodeFormat.html](http://llvm.org/docs/BitCodeFormat.html)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**llvm-as**: 这是 LLVM 汇编器，它将汇编形式的 LLVM IR（可读）转换为位码格式。使用前面的 `add.ll` 作为示例将其转换为位码。要了解更多关于
    LLVM 位码文件格式，请参阅 [http://llvm.org/docs/BitCodeFormat.html](http://llvm.org/docs/BitCodeFormat.html)。'
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To view the content of this bitcode file, a tool such as `hexdump` can be used.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要查看此位码文件的内容，可以使用 `hexdump` 等工具。
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**llvm-dis**: This is the LLVM disassembler. It takes a bitcode file as input
    and outputs the llvm assembly.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**llvm-dis**: 这是 LLVM 反汇编器。它接受位码文件作为输入，并输出 llvm 汇编。'
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you check `add.ll` and compare it with the previous version, it will be the
    same as the previous one.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你检查 `add.ll` 并与之前的版本进行比较，它将与之前的版本相同。
- en: '**llvm-link**: llvm-link links two or more llvm bitcode files and outputs one
    llvm bitcode file. To view a demo write a `main.c` file that calls the function
    in the `add.c` file.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**llvm-link**: llvm-link 将两个或多个 llvm 位码文件链接起来，并输出一个 llvm 位码文件。要查看演示，请编写一个 `main.c`
    文件，该文件调用 `add.c` 文件中的函数。'
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Convert the C source code to LLVM bitcode format using the following command.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下命令将 C 源代码转换为 LLVM 位码格式。
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now link `main.bc` and `add.bc` to generate `output.bc`.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在将 `main.bc` 和 `add.bc` 链接起来生成 `output.bc`。
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**lli**: lli directly executes programs in LLVM bitcode format using a just-in-time
    compiler or interpreter, if one is available for the current architecture. lli
    is not like a virtual machine and cannot execute IR of different architecture
    and can only interpret for host architecture. Use the bitcode format file generated
    by llvm-link as input to lli. It will display the output on the standard output.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lli**: lli 使用即时编译器或解释器直接执行 LLVM 位码格式的程序，如果当前架构有可用的解释器。lli 不像虚拟机，不能执行不同架构的
    IR，只能为宿主架构进行解释。使用由 llvm-link 生成的位码格式文件作为 lli 的输入。它将在标准输出上显示输出。'
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**llc**: llc is the static compiler. It compiles LLVM inputs (assembly form/
    bitcode form) into assembly language for a specified architecture. In the following
    example it takes the `output.bc` file generated by llvm-link and generates the
    assembly file `output.s`.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**llc**: llc 是一个静态编译器。它将 LLVM 输入（汇编形式/位码形式）编译成指定架构的汇编语言。在以下示例中，它将由 llvm-link
    生成的 `output.bc` 文件转换为汇编文件 `output.s`。'
- en: '[PRE11]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's look at the content of the `output.s` assembly, specifically the two functions
    of the generated code, which is very similar to what a native assembler would
    have generated.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们来看看`output.s`汇编的内容，特别是生成的代码的两个函数，这与本地汇编器生成的代码非常相似。
- en: '[PRE12]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`function inlining`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`函数内联`'
- en: '`**instcombine**`**: for combining redundant instructions**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**instcombine**`**: 用于合并冗余指令**'
- en: '****licm**: loop invariant code motion**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****licm**: 循环不变量代码移动**'
- en: '****tailcallelim**: Tail Call elimination**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****tailcallelim**: 尾调用消除**'
- en: '**Note**'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '**Before going ahead we must note that all the tools mentioned in this chapter
    are meant for compiler writers. An end user can directly use clang for compilation
    of C code without converting the C code into intermediate representation**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**在继续之前，我们必须注意，本章中提到的所有工具都是为编译器编写者准备的。最终用户可以直接使用clang编译C代码，而无需将C代码转换为中间表示形式**'
- en: '**Tip**'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '****Downloading the example code****'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '****下载示例代码**'
- en: '**You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**您可以从[http://www.packtpub.com](http://www.packtpub.com)上的账户下载示例代码文件，以获取您购买的所有Packt
    Publishing书籍。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。**'
- en: '**# Summary'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**# 摘要**'
- en: 'In this chapter, we looked into the modular design of LLVM: How it is used
    in the opt tool of LLVM, and how it is applicable across LLVM core libraries.
    Then we took a look into LLVM intermediate representation, and how various entities
    (variables, functions etc.) of a language are mapped to LLVM IR. In the last section,
    we discussed about some of the important LLVM tools, and how they can be used
    to transform the LLVM IR from one form to another.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了LLVM的模块化设计：它在LLVM的opt工具中的应用，以及它在LLVM核心库中的应用。然后我们查看LLVM中间表示，以及语言的各种实体（变量、函数等）如何映射到LLVM
    IR。在最后一节中，我们讨论了一些重要的LLVM工具，以及如何使用它们将LLVM IR从一种形式转换为另一种形式。
- en: In the next chapter, we will see how we can write a frontend for a language
    that can output LLVM IR using the LLVM machinery.**
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何使用LLVM工具编写一个可以输出LLVM IR的语言前端。**
