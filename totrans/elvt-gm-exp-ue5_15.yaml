- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Exploring Collectibles, Power-Ups, and Pickups
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索收集品、增强效果和拾取物
- en: In the previous chapter, you created the player projectile and used `Anim Notifies`
    to spawn the player projectile during the `Throw` animation. The player projectile
    will serve as the player’s main offensive gameplay mechanic to use against the
    enemies throughout the level. Due to the combination of default `Anim Notifies`
    provided by UE5 and your own custom `Anim_ProjectileNotify` class, the player
    projectile mechanic looks and feels great.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你创建了玩家投射物并使用 `Anim Notifies` 在 `Throw` 动画期间生成玩家投射物。玩家投射物将作为玩家在整个关卡中对抗敌人的主要攻击游戏机制。由于
    UE5 提供的默认 `Anim Notifies` 和你自己的自定义 `Anim_ProjectileNotify` 类的组合，玩家投射物机制看起来和感觉都非常好。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to create and integrate UI elements using the **Unreal Motion Graphics**
    (**UMG**) UI Designer system within UE5.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 UE5 中使用 **Unreal Motion Graphics** （**UMG**） UI 设计器系统创建和集成 UI 元素。
- en: Use the lessons learned from this project to create an interesting power-up
    that will increase the players’ movement speed and jump height.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本项目中学到的知识来创建一个有趣的增强效果，该效果将提高玩家的移动速度和跳跃高度。
- en: How to use inheritance in C++ to derive multiple classes from one parent base
    class for both collectibles and power-ups. You will also be adding visual and
    audio elements to both the collectible and the power-up so that they are more
    polished.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 C++ 中的继承来从一个父基类派生出多个类，用于收集品和增强效果。你还将为收集品和增强效果添加视觉和音频元素，使它们更加完善。
- en: How to use `URotatingMovementComponent` to add rotation to actors in a very
    optimized and straightforward way.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `URotatingMovementComponent` 以非常优化和直接的方式为演员添加旋转。
- en: By the end of this chapter, you will have the finished **SuperSideScroller**
    game project, complete with coin collectibles and a corresponding UI to track
    the number of coins collected, a new potion power-up that increases the player’s
    movement speed and jump height, as well as a base class in which to derive potentially
    new power-ups and collectibles for the game.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将拥有完成的 **SuperSideScroller** 游戏项目，包括金币收集品和相应的 UI 来跟踪收集到的金币数量，一个新的增强效果药水，它可以提高玩家的移动速度和跳跃高度，以及一个基类，从中可以派生出游戏中的潜在新增强效果和收集品。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following technical requirements:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下技术要求：
- en: Unreal Engine 5 installed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装 Unreal Engine 5
- en: Visual Studio 2019 installed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装 Visual Studio 2019
- en: Unreal Engine 4.27 installed
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装 Unreal Engine 4.27
- en: Let’s begin this chapter by learning more about `URotatingMovementComponent`,
    which we will use for our collectibles.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个章节开始，更深入地了解 `URotatingMovementComponent`，我们将用它来处理我们的收集品。
- en: 'The project for this chapter can be found in the Chapter15 folder of the code
    bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的项目可以在本书代码包的 Chapter15 文件夹中找到，可以在此处下载：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。
- en: Understanding URotatingMovementComponent
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 URotatingMovementComponent
- en: '`URotatingMovementComponent` is one of a few movement components that exists
    within UE5\. You are already familiar with `CharacterMovementComponent` and `ProjectileMovementComponent`
    from the `RotatingMovementComponent` is just that – another movement component.
    As a refresher, movement components allow different types of movements to occur
    on actors, or characters, that they belong to.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`URotatingMovementComponent` 是存在于 UE5 中的一少数几个运动组件之一。你已经熟悉了 `CharacterMovementComponent`
    和 `ProjectileMovementComponent`，而 `RotatingMovementComponent` 正是另一个运动组件。作为复习，运动组件允许对它们所属的演员或角色执行不同类型的运动。'
- en: Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`CharacterMovementComponent`, which allows you to control the movement parameters
    of your character, such as their movement speed and jump height, was covered in
    [*Chapter 10*](B18531_10.xhtml#_idTextAnchor199), *Creating the SuperSideScroller
    Game*, when you created the `ProjectileMovementComponent`, which allows you to
    add projectile-based movement functionality to actors, such as speed and gravity,
    was covered in [*Chapter 14*](B18531_14.xhtml#_idTextAnchor298), *Spawning the
    Player Projectile*, when you developed the player projectile.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '`RotatingMovementComponent` is a very simple movement component compared to
    `CharacterMovementComponent` and that’s because it only involves rotating the
    actor that `RotatingMovementComponent` is a part of; nothing more. `RotatingMovementComponent`
    continuously rotates a component based on the defined `Rotation Rate`, pivot translation,
    and the option to use rotation in local space or world space. Additionally, `RotatingMovementComponent`
    is much more efficient compared to other methods of rotating an actor, such as
    through `Event Tick` or `Timelines` within Blueprints.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about movement components can be found here: [https://docs.unrealengine.com/en-US/Engine/Components/Movement/index.xhtml#rotatingmovementcomponent](https://docs.unrealengine.com/en-US/Engine/Components/Movement/index.xhtml#rotatingmovementcomponent).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: We will be using `RotatingMovementComponent` to allow the coin collectible and
    potion power-up to rotate in place along the *Z*-axis. This rotation will draw
    the player’s attention to the collectible and give them a visual cue that the
    collectible is important.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a better understanding of `RotatingMovementComponent`, let’s
    move on and create the `PickableActor_Base` class, which is what the coin collectible
    and the potion power-up will derive from.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.01 – creating the PickableActor_Base class and adding URotatingMovementComponent
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will be creating the `PickableActor_Base` actor class,
    which will be used as the base class that both the collectible coin and potion
    power-up will derive from. You will also create a Blueprint class from this C++
    base class to preview how `URotatingMovementComponent` works. Follow these steps
    to complete this exercise:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: You have performed many of the following steps numerous times throughout the
    **SuperSideScroller** game project, so there will be limited screenshots to help
    guide you. Only when introducing a new concept will there be an accompanying screenshot.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Inside the UE5 editor, click the **Tools** option at the top of the editor and
    then choose **New C++ Class**.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Choose Parent Class** window, select the **Actor** option, and then
    click the **Next** button at the bottom of this window.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this class `PickableActor_Base` and leave the default `Path` directory
    as-is. Then, select the **Create Class** button at the bottom of this window.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After selecting the `PickableActor_Base` class.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, `Actor` classes provide you with the `virtual void Tick(float DeltaTime)
    override;` function declaration inside the header file. For the `PickableActor_Base`
    class, we will not require the `Tick` function, so remove this function declaration
    from the `PickableActor_Base.h` header file.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`Actor`类在头文件中为你提供了`virtual void Tick(float DeltaTime) override;`函数声明。对于`PickableActor_Base`类，我们不需要`Tick`函数，因此请从`PickableActor_Base.h`头文件中移除此函数声明。
- en: 'Next, you will need to remove the function from the `PickableActor_Base.cpp`
    file; otherwise, you will receive a compile error. In this source file, find and
    remove the following code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要从`PickableActor_Base.cpp`文件中移除该函数；否则，你将收到编译错误。在此源文件中找到并移除以下代码：
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In many cases, the use of the `Tick()` function for movement updates can lead
    to performance issues as the `Tick()` function is called every single frame. Instead,
    try using `Gameplay Timer` functions to perform certain updates at specified intervals,
    rather than on each frame. You can learn more about `Gameplay Timers` here: [https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/](https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，由于`Tick()`函数在每一帧都会被调用，因此使用`Tick()`函数进行移动更新可能会导致性能问题。相反，尝试使用`Gameplay
    Timer`函数在指定间隔执行某些更新，而不是在每一帧上。你可以在[https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/](https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/)了解更多关于`Gameplay
    Timers`的信息。
- en: 'Now, it is time to add the components that the `PickableActor_Base` class requires.
    Let’s start with `USphereComponent`, which you will use to detect overlap collision
    with the player. Add the following code underneath the `Protected` access modifier
    inside the `PickableActor_Base.h` header file:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候添加`PickableActor_Base`类所需的组件了。让我们从`USphereComponent`开始，你将使用它来检测与玩家的重叠碰撞。在`PickableActor_Base.h`头文件中的`Protected`访问修饰符下方添加以下代码：
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The declaration of `USphereComponent` should be very familiar to you by now;
    we’ve done this in previous chapters, such as [*Chapter 14*](B18531_14.xhtml#_idTextAnchor298),
    *Spawning the Player Projectile*, when we created the `PlayerProjectile` class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，`USphereComponent`的声明应该对你来说非常熟悉了；我们之前在创建`PlayerProjectile`类时已经在前面的章节中这样做过，例如在[*第14章*](B18531_14.xhtml#_idTextAnchor298)，*生成玩家投射物*。
- en: 'Next, add the following code underneath the declaration of `USphereComponent`
    to create a new `UStaticMeshComponent`. This will be used to visually represent
    either the coin collectible or the potion power-up:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`USphereComponent`声明下方添加以下代码以创建一个新的`UStaticMeshComponent`。这将用于视觉上表示硬币收集品或药水增强效果：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, add the following code underneath the declaration of `UStaticMeshComponent`
    to create a new `URotatingMovementComponent`. This will be used to give the collectible
    coin and potion power-up simple rotational movement:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`UStaticMeshComponent`声明下方添加以下代码以创建一个新的`URotatingMovementComponent`。这将用于给收集品硬币和药水增强效果提供简单的旋转运动：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that you have the components declared inside the `PickableActor_Base.h`
    header file, navigate to the `PickableActor_Base.cpp` source file so that you
    can add the required `#include` statements for these added components. Add the
    following lines after `#include “PickableActor_Base.h”`, at the top of the source
    file:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经在`PickableActor_Base.h`头文件中声明了组件，请导航到`PickableActor_Base.cpp`源文件，以便为这些添加的组件添加所需的`#include`语句。在源文件顶部`#include
    “PickableActor_Base.h”`之后添加以下行：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that you have the necessary `#include` files for the components, you can
    add the necessary code to initialize these components within the `APickableActor_Base::APickableActor_Base()`
    constructor function:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经有了组件所需的`#include`文件，你可以在`APickableActor_Base::APickableActor_Base()`构造函数中添加初始化这些组件的必要代码：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'First, initialize the `USphereComponent` component variable, `CollisionComp`,
    by adding the following code to `APickableActor_Base::APickableActor_Base()`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过在`APickableActor_Base::APickableActor_Base()`中添加以下代码来初始化`USphereComponent`组件变量`CollisionComp`：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, initialize `USphereComponent` with a default sphere radius of `30.0f`
    by adding the following code underneath the code provided in the previous step:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过在上一步骤提供的代码下方添加以下代码来使用默认球体半径`30.0f`初始化`USphereComponent`：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since the player character needs to overlap with this component, you will need
    to add the following code so that, by default, `USphereComponent` has the collision
    settings for `Overlap All Dynamic`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于玩家角色需要与此组件重叠，你需要添加以下代码，以便默认情况下 `USphereComponent` 具有对 `Overlap All Dynamic`
    的碰撞设置：
- en: '[PRE8]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Lastly, `CollisionComp USphereComponent` should be the root component of this
    actor. Add the following code to assign this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`CollisionComp USphereComponent` 应该是这个演员的根组件。添加以下代码以分配此组件：
- en: '[PRE9]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that `CollisionComp USphereComponent` has been initialized, let’s do the
    same for `MeshComp UStaticMeshComponent`. Add the following code. After, we’ll
    discuss what the code is doing for us:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`CollisionComp USphereComponent` 已经初始化，让我们对 `MeshComp UStaticMeshComponent`
    做同样的操作。添加以下代码。之后，我们将讨论代码为我们做了什么：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first line initializes `MeshComp UStaticMeshComponent` using the `CreateDefaultSubobject()`
    template function. Next, you are attaching `MeshComp` to the root component, which
    you made for `CollisionComp`, using the `AttachTo()` function. Lastly, `MeshComp
    UStaticMeshComponent` should not have any collision by default, so you are using
    the `SetCollisionEnabled()` function and passing in the `ECollisionEnable::NoCollision`
    enumerator value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用 `CreateDefaultSubobject()` 模板函数初始化 `MeshComp UStaticMeshComponent`。接下来，你使用
    `AttachTo()` 函数将 `MeshComp` 附接到为 `CollisionComp` 创建的根组件上。最后，`MeshComp UStaticMeshComponent`
    默认情况下不应有任何碰撞，因此你使用 `SetCollisionEnabled()` 函数并传入 `ECollisionEnable::NoCollision`
    枚举值。
- en: 'Lastly, we can initialize `URotatingMovementComponent RotationComp` by adding
    the following code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过添加以下代码来初始化 `URotatingMovementComponent RotationComp`：
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With all the components initialized, compile the C++ code and return to the
    UE5 editor. After compilation succeeds, you can start creating a Blueprint class
    for `PickableActor_Base`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有组件初始化完成后，编译 C++ 代码并返回到 UE5 编辑器。编译成功后，你可以开始为 `PickableActor_Base` 创建蓝图类。
- en: In the `PickableItems` by *right-clicking* on the `Content` folder and selecting
    the **New Folder** option.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PickableItems` 中，通过 *右键单击* `Content` 文件夹并选择 **新建文件夹** 选项。
- en: In the `PickableItems` folder, *right-click* and select `PickableActor_Base`
    class and *left-click* **Select** to create a new Blueprint.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PickableItems` 文件夹中，*右键单击* 并选择 `PickableActor_Base` 类，然后 *左键单击* **选择** 以创建一个新的蓝图。
- en: Name this Blueprint `BP_PickableActor_Base` and *double-left-click* the Blueprint
    to open it.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此蓝图命名为 `BP_PickableActor_Base` 并 *双击* 蓝图以打开它。
- en: 'In the `Shape_Cone` static mesh to the `Static Mesh` parameter in the **Details**
    panel. Please refer to the following screenshot:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Details** 面板的 `Shape_Cone` 静态网格的 `Static Mesh` 参数中。请参考以下截图：
- en: '![Figure 15.1 – The Shape_Cone mesh assigned to MeshComp StaticMeshComponent
    ](img/Figure_15.01_B18531.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.1 – 分配给 MeshComp StaticMeshComponent 的 Shape_Cone 网格](img/Figure_15.01_B18531.jpg)'
- en: Figure 15.1 – The Shape_Cone mesh assigned to MeshComp StaticMeshComponent
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 – 分配给 MeshComp StaticMeshComponent 的 Shape_Cone 网格
- en: Next, select **RotationComp URotatingMovementComponent** and find the **Rotation
    Rate** parameter in the **Rotating Component** category of the **Details** panel.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择 **RotationComp URotatingMovementComponent** 并在 **Details** 面板的 **Rotating
    Component** 类别中找到 **Rotation Rate** 参数。
- en: 'Set **Rotation Rate** to the following values:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Rotation Rate** 设置为以下值：
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These values determine how fast the actor will rotate along each axis per second.
    This means that the cone-shaped actor will rotate along each axis at 100 degrees
    per second on each axis.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值决定了演员每秒沿每个轴旋转的速度。这意味着锥形演员将沿每个轴以每秒 100 度的速度旋转。
- en: Compile the `PickableActor_Base` Blueprint and add this actor to your level.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译 `PickableActor_Base` 蓝图并将此演员添加到你的关卡中。
- en: 'Now, if you use `PIE` and look at the `PickableActor_Base` actor in the level,
    you will see that it is rotating. Please refer to the following screenshot:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你使用 `PIE` 并查看关卡中的 `PickableActor_Base` 演员角色，你会看到它在旋转。请参考以下截图：
- en: '![Figure 15.2 – The BP_PickableActor_Base rotating in place ](img/Figure_15.02_B18531.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.2 – BP_PickableActor_Base 在原地旋转](img/Figure_15.02_B18531.jpg)'
- en: Figure 15.2 – The BP_PickableActor_Base rotating in place
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 – BP_PickableActor_Base 在原地旋转
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the assets and code for this exercise here: [https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.01](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.01).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到此练习的资源和代码：[https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.01](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.01)。
- en: With this exercise complete, you’ve created the base components required for
    the `PickableActor_Base` class and learned how to implement and use `URotatingMovementComponent`.
    With the `PickableActor_Base` class ready, and with `URotatingMovementComponent`
    implemented on the Blueprint actor, we can complete the class by adding overlap
    detection functionality, destroying the collectible actor, and spawning audio
    effects when the actor is picked up by the player. In the following activity,
    you will add the remaining functionality required for the `PickableActor_Base`
    class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经创建了 `PickableActor_Base` 类所需的基本组件，并学习了如何实现和使用 `URotatingMovementComponent`。在
    `PickableActor_Base` 类准备就绪，并在蓝图角色上实现了 `URotatingMovementComponent` 之后，我们可以通过添加重叠检测功能、销毁可收集角色以及在角色被玩家拾取时生成音频效果来完成该类。在接下来的活动中，你将添加
    `PickableActor_Base` 类所需的剩余功能。
- en: Activity 15.01 – player overlap detection and spawning effects in PickableActor_Base
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 15.01 – 在 `PickableActor_Base` 中进行玩家重叠检测和生成效果
- en: 'Now that the `PickableActor_Base` class has all the required components and
    has its constructor initializing the components, it is time to add the remaining
    aspects of its functionality. These will be inherited by the coin collectible
    and potion power-up later in this chapter. This additional functionality includes
    player overlap detection, destroying the collectible actor, and spawning an audio
    effect to give feedback to the player that it has been successfully picked up.
    Perform the following steps to add functionality that allows a `USoundBase` class
    object to be played when the collectible overlaps with the player:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`PickableActor_Base` 类已经包含了所有必需的组件，并且其构造函数初始化了这些组件，是时候添加其功能的剩余部分了。这些将在本章后面的部分由金币收集物和药水增益效果继承。这些附加功能包括玩家重叠检测、销毁可收集角色，并在玩家成功拾取时生成音频效果以向玩家提供反馈。执行以下步骤以添加允许在收集物与玩家重叠时播放
    `USoundBase` 类对象的功能：
- en: Create a new function in the `PickableActor_Base` class that takes in a reference
    to the player as an input parameter. Call this function `PlayerPickedUp`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PickableActor_Base` 类中创建一个新的函数，该函数接受一个引用作为输入参数。将此函数命名为 `PlayerPickedUp`。
- en: Create a new `UFUNCTION` called `BeginOverlap()`. Make sure to include all the
    required input parameters for this function before moving on. Refer to [*Chapter
    6*](B18531_06.xhtml#_idTextAnchor134), *Setting Up Collision Objects*, where you
    used this function inside the `VictoryBox` class.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `UFUNCTION`，命名为 `BeginOverlap()`。在继续之前，确保包含此函数所需的所有输入参数。参考[*第6章*](B18531_06.xhtml#_idTextAnchor134)，*设置碰撞对象*，其中你在
    `VictoryBox` 类内部使用了此函数。
- en: Add a new `UPROPERTY()` for the `USoundBase` class and name it `PickupSound`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `USoundBase` 类添加一个新的 `UPROPERTY()`，命名为 `PickupSound`。
- en: In the `PickableActor_Base.cpp` source file, create the definitions for both
    the `BeginOverlap()` and `PlayerPickedUp()` functions.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PickableActor_Base.cpp` 源文件中，创建 `BeginOverlap()` 和 `PlayerPickedUp()` 函数的定义。
- en: Now, add the required `#include` files for the `SuperSideScroller_Player` class
    and the `GameplayStatics` class at the top of the source file.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在源文件顶部添加 `SuperSideScroller_Player` 类和 `GameplayStatics` 类所需的 `#include`
    文件。
- en: In the `BeginOverlap()` function, create a reference to the player using the
    `OtherActor` input parameter of the function.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BeginOverlap()` 函数中，使用函数的 `OtherActor` 输入参数创建玩家的引用。
- en: Next, if the player reference is valid, make a call to the `PlayerPickedUp()`
    function, passing in the player variable.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果玩家引用有效，调用 `PlayerPickedUp()` 函数，传入玩家变量。
- en: In the `PlayerPickedUp()` function, create a variable for the `UWorld*` object
    that’s returned by the `GetWorld()` function.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PlayerPickedUp()` 函数中，为 `GetWorld()` 函数返回的 `UWorld*` 对象创建一个变量。
- en: Use the `UGameplayStatics` library to spawn `PickUpSound` at the location of
    the `PickableActor_Base` actor.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `UGameplayStatics` 库在 `PickableActor_Base` 角色的位置生成 `PickUpSound`。
- en: Then, call the `Destroy()` function so that the actor gets destroyed and removed
    from the world.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用 `Destroy()` 函数，以便销毁角色并将其从世界中移除。
- en: Finally, in the `APickableActor_Base::APickableActor_Base()` constructor, bind
    the `OnComponentBeginOverlap` event of `CollisionComp` to the `BeginOverlap()`
    function.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `APickableActor_Base::APickableActor_Base()` 构造函数中，将 `CollisionComp` 的
    `OnComponentBeginOverlap` 事件绑定到 `BeginOverlap()` 函数。
- en: Download and install the `Unreal Match 3` project from the `Match_Combo` soundwave
    asset from this project into your **SuperSideScroller** project using the knowledge
    you gained in [*Chapter 14*](B18531_14.xhtml#_idTextAnchor298), *Spawning the
    Player Projectile*.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从该项目中下载并安装`Unreal Match 3`项目，使用你在[*第14章*](B18531_14.xhtml#_idTextAnchor298)，“生成玩家投射物”中获得的技能，将`Match_Combo`声音波形资产从该项目安装到你的**SuperSideScroller**项目中。
- en: Apply this sound to the `PickupSound` parameter of the `BP_PickableActor_Base`
    Blueprint.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此声音应用到`BP_PickableActor_Base`蓝图的`PickupSound`参数。
- en: Compile the Blueprint, and if one does not exist in your level, add the `BP_PickableActor_Base`
    actor to your level now.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译蓝图，如果您的关卡中不存在，现在添加`BP_PickableActor_Base`演员到您的关卡中。
- en: In `PIE`, have your character overlap with the `BP_PickableActor_Base` actor.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PIE`中，让您的角色与`BP_PickableActor_Base`演员重叠。
- en: 'Expected output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出：
- en: '![Figure 15.3 – The BP_PickableActor_Base object can be picked up by the player
    ](img/Figure_15.03_B18531.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3 – BP_PickableActor_Base对象可以被玩家拾取](img/Figure_15.03_B18531.jpg)'
- en: Figure 15.3 – The BP_PickableActor_Base object can be picked up by the player
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 – BP_PickableActor_Base对象可以被玩家拾取
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)找到。
- en: With this activity complete, you have proven your knowledge regarding how to
    add the `OnBeginOverlap()` functionality to your actor classes and how to use
    this function to perform logic for your actor. In the case of `PickableActor_Base`,
    we added logic that will spawn a custom sound and destroy the actor.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动后，你已经证明了你在如何将`OnBeginOverlap()`功能添加到你的演员类中以及如何使用此功能为你的演员执行逻辑方面的知识。在`PickableActor_Base`的情况下，我们添加了逻辑，将生成自定义声音并销毁演员。
- en: Now that the `PickableActor_Base` class is set and ready, it is time to develop
    the collectible coin and power-up potion classes that will derive from it. The
    coin collectible class will inherit from the `PickableActor_Base` class you have
    just created. It will override key functionality, such as the `PlayerPickedUp()`
    function, so that we can implement unique logic for the collectible when it’s
    picked up by the player. In addition to overriding functionality from the inherited
    parent `PickableActor_Base` class, the coin collectible class will have its own
    unique set of properties, such as its current coin value and unique pickup sound.
    We’ll create the coin collectible class together in the next exercise.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然`PickableActor_Base`类已经设置并准备好了，是时候开发继承自它的可收集硬币和增强药水类了。硬币可收集类将继承自你刚刚创建的`PickableActor_Base`类。它将覆盖关键功能，例如`PlayerPickedUp()`函数，以便我们可以在玩家拾取可收集物品时实现独特的逻辑。除了覆盖从继承的父类`PickableActor_Base`中继承的功能外，硬币可收集类还将拥有其自己独特的一组属性，例如其当前硬币价值和独特的拾取声音。我们将在下一个练习中一起创建硬币可收集类。
- en: Exercise 15.02 – creating the PickableActor_Collectable class
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 练习15.02 – 创建PickableActor_Collectable类
- en: 'In this exercise, you will be creating the `PickableActor_Collectable` class,
    which will be derived from the `PickableActor_Base` class you created in *Exercise
    15.01 – creating the PickableActor_Base class and adding URotatingMovement*, and
    finished in *Activity 15.01 – player overlap detection and spawning effects in
    PickableActor_Base*. This class will be used as the main collectible coin that
    the player can collect within the level. Follow these steps to complete this exercise:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建`PickableActor_Collectable`类，该类将继承自你在*练习15.01 – 创建PickableActor_Base类并添加URotatingMovement*中创建的`PickableActor_Base`类，并在*活动15.01
    – 在PickableActor_Base中检测玩家重叠和生成效果*中完成。这个类将用作玩家在关卡内可以收集的主要可收集硬币。按照以下步骤完成这个练习：
- en: Inside the UE5 editor, click the **Tools** option at the top of the editor and
    choose **New C++ Class**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UE5编辑器中，点击编辑器顶部的**工具**选项，然后选择**新建C++类**。
- en: From the **Choose Parent Class** window, select the **PickableActor_Base** option,
    and then click the **Next** button at the bottom of this window.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**选择父类**窗口中，选择**PickableActor_Base**选项，然后点击此窗口底部的**下一步**按钮。
- en: Name this class `PickableActor_Collectable` and leave the default `Path` directory
    as-is. Then, select the **Create Class** button at the bottom of this window.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After selecting the `PickableActor_Collectable` class.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, the `PickableActor_Collectable.h` header file has no declared functions
    or variables within its class declaration. You will need to add the override for
    the `BeginPlay()` function underneath a new `Protected Access Modifier`. Add the
    following code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The reason we are overriding the `BeginPlay()` function is that `URotatingMovementComponent`
    requires the actor to initialize and use `BeginPlay()` to correctly rotate the
    actor. Therefore, we need to create the override declaration of this function
    and create a basic definition inside the source file. First, however, we need
    to override another important function from the `PickableActor_Base` parent class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Override the `PlayerPickedUp()` function from the `PickableActor_Base` parent
    class by adding the following code under `Protected Access Modifier`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this, we are saying that we are going to use, and override, the functionality
    of the `PlayerPickedUp()` function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, create a new integer called `UPROPERTY()` that will hold the value
    that the coin collectible will have; in this case, it will have a value of `1`.
    Add the following code to do this:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are creating the integer variable that will be accessible in Blueprints
    and has a default value of `1`. If you so choose, with the `EditAnywhere UPROPERTY()`
    keyword, you can change how much a coin collectible is worth.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can move on to the `PickableActor_Collectable.cpp` source file and
    create the definition of the overridden `PlayerPickedUp()` function. Add the following
    code to the source file:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For now, we need to make a call to the `PlayerPickedUp()` parent function by
    using the `Super` keyword. Add the following code to the `PlayerPicked()` function:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The call to the parent function, which uses `Super::PlayerPickedUp(Player)`,
    will ensure that the functionality you created in the `PickableActor_Base` class
    is called. As you may recall, the `PlayerPickedUp()` function in the parent class
    makes a call to spawn the `PickupSound` sound object and destroys the actor.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the definition of the `BeginPlay()` function inside the source
    file by adding the following code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, in C++, once again make the call to the `BeginPlay()` parent function
    using the `Super` keyword. Add the following code to the `BeginPlay()` function
    inside the `PickableActor_Collectable` class:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Compile the C++ code and return to the editor.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the assets and code for this exercise at the following link: [https://packt.live/35fRN3E](https://packt.live/35fRN3E).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve successfully compiled the `PickableActor_Collectable` class,
    you have created the framework needed for the coin collectible. In the following
    activity, you will create a Blueprint from this class and finalize the coin collectible
    actor.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Activity 15.02 – finalizing the PickableActor_Collectable actor
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十五.02 – 最终化PickableActor_Collectable演员
- en: 'Now that the `PickableActor_Collectable` class has all of the necessary inherited
    functionality and unique properties it needs, it is time to create the Blueprint
    from this class and add a `Static Mesh`, update its `URotatingMovementComponent`,
    and apply a sound to the `PickUpSound` property. Perform the following steps to
    finalize the `PickableActor_Collectable` actor:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`PickableActor_Collectable`类已经拥有了所有必要的继承功能以及它需要的独特属性，是时候从这个类创建蓝图，并添加一个`Static
    Mesh`，更新其`URotatingMovementComponent`，并将声音应用到`PickUpSound`属性上了。执行以下步骤以最终化`PickableActor_Collectable`演员：
- en: From **Epic Games Launcher**, find the **Content Examples** project in the **Samples**
    tab, underneath the **Engine Feature Samples** category.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Epic Games Launcher**，在**示例**标签页下，在**引擎功能示例**类别中找到**内容示例**项目。
- en: Create and install a new project from the **Content Examples** project.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**内容示例**项目创建并安装一个新的项目。
- en: Migrate the `SM_Pickup_Coin` asset and all its referenced assets from the **Content
    Examples** project to your **SuperSideScroller** project.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SM_Pickup_Coin`资产及其所有引用的资产从**内容示例**项目迁移到你的**SuperSideScroller**项目中。
- en: Create a new folder within the `Content/PickableItems` directory in the `Collectable`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content/PickableItems`目录下的`Collectable`中创建一个新的文件夹。
- en: In this new `Collectable` folder, create a new Blueprint from the `PickableActor_Collectable`
    class that you created in *Exercise 15.02 – creating the PickableActor_Collectable
    class*. Name this new Blueprint `BP_Collectable`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新的`Collectable`文件夹中，从你在*练习十五.02 – 创建PickableActor_Collectable类*中创建的`PickableActor_Collectable`类创建一个新的蓝图。将这个新的蓝图命名为`BP_Collectable`。
- en: In this Blueprint, set the `Static Mesh` parameter of the `MeshComp` component
    to the `SM_Pickup_Coin` mesh you imported earlier in this activity.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此蓝图（Blueprint）中，将`MeshComp`组件的`Static Mesh`参数设置为之前在此活动中导入的`SM_Pickup_Coin`网格。
- en: Next, add the `Match_Combo` sound asset to the `PickupSound` parameter of the
    collectible.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`Match_Combo`声音资产添加到可收集物品的`PickupSound`参数中。
- en: Lastly, update the `RotationComp` component so that the actor rotates along
    the *Z*-axis at 90 degrees per second.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新`RotationComp`组件，使演员沿*Z*轴以每秒90度的速度旋转。
- en: Compile the Blueprint, place `BP_Collectable` in your level, and use `PIE`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译蓝图，将`BP_Collectable`放置到你的关卡中，并使用`PIE`（Playground Immediate Editor）。
- en: Overlap the player character with the `BP_Collectable` actor and observe the
    results.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将玩家角色与`BP_Collectable`演员重叠，并观察结果。
- en: 'Expected output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出：
- en: '![Figure 15.4 – The coin collectible rotates and can be overlapped by the player
    ](img/Figure_15.04_B18531.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图十五.4 – 硬币收集物品旋转，并且可以被玩家重叠](img/Figure_15.04_B18531.jpg)'
- en: Figure 15.4 – The coin collectible rotates and can be overlapped by the player
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图十五.4 – 硬币收集物品旋转，并且可以被玩家重叠
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)找到。
- en: With this activity complete, you have proven that you know how to migrate assets
    into your UE5 project and how to use and update `URotatingMovementComponent` to
    fit the needs of the coin collectible. Now that the coin collectible actor is
    complete, it is time to add functionality to the player so that the player can
    keep track of how many coins they have collected.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动后，你已经证明你知道如何将资产迁移到你的UE5项目中，以及如何使用和更新`URotatingMovementComponent`以满足硬币收集物品的需求。现在硬币收集物品演员已经完成，是时候向玩家添加功能，以便玩家可以跟踪他们收集了多少硬币。
- en: First, we will create the logic that will count the coins using `UE_LOG`. Later,
    we will implement the coin counter using the **Unreal Motion Graphics** (**UMG**)
    UI Designer system on the game’s UI.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建使用`UE_LOG`计数的逻辑。稍后，我们将使用**Unreal Motion Graphics**（**UMG**）UI设计器系统在游戏的UI上实现硬币计数器。
- en: Logging variables using UE_LOG
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UE_LOG记录变量
- en: In [*Chapter 11*](B18531_11.xhtml#_idTextAnchor222), *Working with Blend Space
    1D, Key Bindings, and State Machines*, we used and learned about the `UE_LOG`
    function to log when the player should throw the projectile. Then, we used the
    `UE_LOG` function in [*Chapter 13*](B18531_13.xhtml#_idTextAnchor268), *Creating
    and Adding the Enemy Artificial Intelligence*, to log when the player projectile
    hit an object. `UE_LOG` is a robust logging tool we can use to output important
    information from our C++ functions into the `FStrings` to display general text
    in the **Output Log** window to know that our functions were being called. Now,
    it is time to learn how to log variables to debug how many coins the player has
    collected.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 11 章*](B18531_11.xhtml#_idTextAnchor222) *使用 1D 混合空间、按键绑定和状态机* 中，我们使用了并学习了
    `UE_LOG` 函数来记录玩家何时应该投掷投射物。然后，我们在 [*第 13 章*](B18531_13.xhtml#_idTextAnchor268)
    *创建和添加敌人人工智能* 中使用 `UE_LOG` 函数来记录玩家投射物击中物体时的情况。"UE_LOG" 是一个强大的日志工具，我们可以用它将 C++
    函数中的重要信息输出到 `FStrings` 中，以在 **输出日志** 窗口中显示一般文本，以知道我们的函数正在被调用。现在，是时候学习如何记录变量来调试玩家收集了多少硬币了。
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is another useful debug function available in C++ with UE5 known as `AddOnScreenDebugMessage`.
    You can learn more about this function here: [https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.xhtml).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中还有另一个在 UE5 中可用的有用调试函数，称为 `AddOnScreenDebugMessage`。你可以在这里了解更多关于这个函数的信息：[https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.xhtml)。
- en: When creating the `FString` syntax used by the `TEXT()` macro, we can add format
    specifiers to log different types of variables. We will only be discussing how
    to add the format specifier for integer variables.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 `TEXT()` 宏使用的 `FString` 语法时，我们可以添加格式说明符来记录不同类型的变量。我们只讨论如何添加整型变量的格式说明符。
- en: Note
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more information on how to specify other variable types by reading
    the following documentation: [https://www.ue4community.wiki/Logging#Logging_an_FString](https://www.ue4community.wiki/Logging#Logging_an_FString).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过阅读以下文档了解如何指定其他变量类型：[https://www.ue4community.wiki/Logging#Logging_an_FString](https://www.ue4community.wiki/Logging#Logging_an_FString)。
- en: 'This is what `UE_LOG()` looks like when passing in `FString “Example Text”`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `UE_LOG()` 在传递 `FString “Example Text”` 时的样子：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, you have `Log Category`, `Log Verbose Level`, and the actual `FString`,
    `“Example Text”`, to display in the log. To log an integer variable, you need
    to add `%d` to your `FString` within the `TEXT()` macro, followed by the integer
    variable name outside the `TEXT()` macro, separated by a comma. Here is an example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你有 `Log Category`、`Log Verbose Level` 和实际要显示在日志中的 `FString`、“Example Text”。要记录一个整型变量，你需要在
    `TEXT()` 宏内的 `FString` 中添加 `%d`，然后在外部 `TEXT()` 宏之外添加整型变量名，两者之间用逗号隔开。以下是一个示例：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The format specifier is identified by the `%` symbol, and each variable type
    has a designated letter that corresponds with it. In the case of integers, the
    letter `d` is used, representing a digit. You will be using this method of logging
    integer variables to log the number of coin collectibles the player has in the
    next exercise.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 格式说明符由 `%` 符号标识，每种变量类型都有一个与之对应的字母。对于整型，字母 `d` 被用来表示数字。你将在下一个练习中使用这种方法来记录玩家拥有的硬币收集数量。
- en: Exercise 15.03 – tracking the number of coins for the player
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 15.03 – 跟踪玩家收集的硬币数量
- en: 'In this exercise, you will be creating the necessary properties and functions
    that will allow you to track how many coins the player collects throughout the
    level. You will use this tracking to show the player using UMG later in this chapter.
    Follow these steps to complete this exercise:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建必要的属性和函数，以便跟踪玩家在整个关卡中收集了多少硬币。你将使用这种跟踪来在本书的后面部分使用 UMG 显示玩家。按照以下步骤完成这个练习：
- en: In Visual Studio, find and open the `SuperSideScroller_Player.h` header file.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，找到并打开 `SuperSideScroller_Player.h` 头文件。
- en: 'Under `Private Access Modifier`, create a new `int` variable called `NumberofCollectables`,
    as shown here:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Private Access Modifier` 下，创建一个新的 `int` 变量，命名为 `NumberofCollectables`，如下所示：
- en: '[PRE22]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will be a private property that will keep track of the current number of
    coins the player has collected. You will be creating a public function that will
    return this integer value. We do this for safety reasons to ensure that no other
    classes can modify this value.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个私有属性，用于跟踪玩家当前收集到的金币数量。你将创建一个公共函数来返回这个整数值。我们这样做是为了安全起见，确保没有其他类可以修改这个值。
- en: 'Next, under the existing `public` access modifier, create a new `UFUNCTION()`
    using the `BlueprintPure` keyword called `GetCurrentNumberOfCollectables()`. This
    function will return an `int`. The following code adds this as an inline function:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在现有的`public`访问修饰符下，创建一个新的`UFUNCTION()`，使用`BlueprintPure`关键字，名为`GetCurrentNumberOfCollectables()`。这个函数将返回一个`int`。以下代码将其添加为一个内联函数：
- en: '[PRE23]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we are using `UFUNCTION()` and the `BlueprintPure` keyword to expose this
    function to Blueprints so that we can use it later in UMG.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`UFUNCTION()`和`BlueprintPure`关键字来将此函数暴露给Blueprints，以便我们可以在UMG中稍后使用它。
- en: 'Declare a new `void` function, under the `public` access modifier, called `IncrementNumberofCollectables()`
    that takes in a single integer parameter called `Value`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新的`void`函数，在`public`访问修饰符下，名为`IncrementNumberofCollectables()`，它接受一个名为`Value`的单个整数参数：
- en: '[PRE24]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is the main function you will use to keep track of how many coins the player
    has collected. We will also add some safety measures to ensure this value is never
    negative.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您将用来跟踪玩家收集到的金币数量的主要函数。我们还将添加一些安全措施，以确保这个值永远不会是负数。
- en: With the `IncrementNumberofCollectables()` function declared, let’s create the
    definition of this function inside the `SuperSideScroller_Player.cpp` source file.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在声明了`IncrementNumberofCollectables()`函数之后，让我们在`SuperSideScroller_Player.cpp`源文件中创建这个函数的定义。
- en: 'Write the following code to create the definition of the `IncrementNumberofCollectables`
    function:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码以创建`IncrementNumberofCollectables`函数的定义：
- en: '[PRE25]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The main case to handle here is if the integer value that’s passed into this
    function is less than or equal to `0`. In this case, we do not want to bother
    incrementing the `NumberofCollectables` variable. Add the following code to the
    `IncrementNumberofCollectables()` function:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里要处理的主要情况是传入此函数的整数值小于或等于`0`。在这种情况下，我们不想去增加`NumberofCollectables`变量。将以下代码添加到`IncrementNumberofCollectables()`函数中：
- en: '[PRE26]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This `if()` statement says that if the `value` input parameter is less than
    or equal to `0`, the function will end. With the `IncrementNumberofCollectables()`
    function returning `void`, it is perfectly okay to use the `return` keyword in
    this way.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`if()`语句表示，如果输入参数`value`小于或等于`0`，函数将结束。由于`IncrementNumberofCollectables()`函数返回`void`，因此在这种情况下使用`return`关键字是完全可行的。
- en: We’re adding this check of ensuring the `value` parameter that’s passed into
    the `IncrementNumberofCollectables()` function is neither 0 nor negative because
    it is important to establish good coding practices; this guarantees that all possible
    outcomes are handled. In an actual development environment, there could be designers
    or other programmers who attempt to use the `IncrementNumberofCollectables()`
    function and try to pass in a negative value, or a value that equals 0\. If the
    function does not take these possibilities into account, there is potential for
    bugs later on in development.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加这个检查，确保传入`IncrementNumberofCollectables()`函数的`value`参数既不是0也不是负数，因为这对于建立良好的编码实践很重要；这保证了处理了所有可能的结果。在实际的开发环境中，可能会有设计师或其他程序员尝试使用`IncrementNumberofCollectables()`函数，并尝试传入一个负值，或者等于0的值。如果函数没有考虑到这些可能性，那么在开发过程中可能会出现潜在的错误。
- en: 'Now that we’ve handled the edge case where `value` is less than or equal to
    `0`, let’s continue with the function using an `else()` statement to increase
    `NumberofCollectables`. Add the following code under the `if()` statement from
    the previous step:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们已经处理了`value`小于或等于`0`的边缘情况，让我们继续使用`else()`语句来增加`NumberofCollectables`。在上一步骤的`if()`语句下添加以下代码：
- en: '[PRE27]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, let’s log `NumberofCollectables` using `UE_LOG` and the knowledge we
    learned about logging variables. Add the following code after the `else()` statement
    to properly log `NumberofCollectables`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用`UE_LOG`和我们所学的关于记录变量的知识来记录`NumberofCollectables`。在`else()`语句之后添加以下代码以正确记录`NumberofCollectables`：
- en: '[PRE28]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this `UE_LOG()`, we are making a more robust log to track the number of
    coins. This lays out the groundwork of how the UI will work. This is because we
    will be logging the same information to the player using UMG later in this chapter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个 `UE_LOG()`，我们创建了一个更健壮的日志来跟踪硬币的数量。这为 UI 的工作方式奠定了基础。这是因为我们将在本章后面使用 UMG 将相同的信息记录到玩家那里。
- en: With `UE_LOG()` added, all we need to do is call the `IncrementNumberofCollectables()`
    function inside the `PickableActor_Collectable` class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了 `UE_LOG()` 之后，我们只需要在 `PickableActor_Collectable` 类中调用 `IncrementNumberofCollectables()`
    函数。
- en: 'In the `PickableActor_Collectable.cpp` source file, add the following header:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PickableActor_Collectable.cpp` 源文件中添加以下头文件：
- en: '[PRE29]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, inside the `PlayerPickedUp()` function, add the following function call
    before the `Super::PlayerPickedUp(Player)` line:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `PlayerPickedUp()` 函数中，在 `Super::PlayerPickedUp(Player)` 行之前添加以下函数调用：
- en: '[PRE30]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that our `PickableActor_Collectable` class is calling our player’s `IncrementNumberofCollectables`
    function, recompile the C++ code and return to the UE5 editor.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将 `PickableActor_Collectable` 类调用我们的玩家的 `IncrementNumberofCollectables`
    函数，重新编译 C++ 代码并返回到 UE5 编辑器。
- en: Within the UE5 editor, open the **Output Log** window by clicking **Window**,
    and then select **Output Log**.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 UE5 编辑器中，通过点击 **窗口**，然后选择 **输出日志** 来打开 **输出日志** 窗口。
- en: Now, add multiple `PIE`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加多个 `PIE`。
- en: When you overlap over each coin collectible, observe the **Output Log** window
    to find that each time you collect a coin, the **Output Log** window will show
    you how many coins you’ve collected.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你重叠在每个可收集的硬币上时，观察 **输出日志** 窗口，你会发现每次你收集一个硬币，**输出日志** 窗口都会显示你已经收集了多少硬币。
- en: Note
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the assets and code for this exercise here: [https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.03](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.03).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到这个练习的资源和代码：[https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.03](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.03)。
- en: With this exercise completed, you have now completed half of the work needed
    to develop the UI element of tracking the number of coins collected by the player.
    The next half will involve using the functionality developed in this activity
    inside UMG to show this information to the player on-screen. To do this, we need
    to learn more about UMG inside UE5.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你现在已经完成了开发 UI 元素以跟踪玩家收集的硬币数量的工作的一半。下一半将涉及在 UMG 中使用本活动开发的功能，在屏幕上向玩家展示这些信息。为此，我们需要更多地了解
    UE5 中的 UMG。
- en: Introducing Unreal Motion Graphics UI
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Unreal Motion Graphics UI
- en: UMG UI Designer is UE5’s main tool for creating UI menus, in-game HUD elements
    such as health bars, and other user interfaces you may want to present to the
    player.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: UMG UI 设计器是 UE5 创建 UI 菜单、游戏中的健康条等游戏内 HUD 元素和其他您希望向玩家展示的用户界面的主要工具。
- en: In the **SuperSideScroller** game, we will only be using the **Text widget**
    to construct our **Coin Collection UI** in *Exercise 15.04 – creating the Coin
    Counter UI HUD element*. We’ll learn more about the **Text widget** in the next
    section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **SuperSideScroller** 游戏中，我们将在 *练习 15.04 – 创建硬币计数器 UI HUD 元素* 中仅使用 **文本小部件**
    来构建我们的 **硬币收集 UI**。我们将在下一节中了解更多关于 **文本小部件** 的信息。
- en: Understanding the Text widget
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解文本小部件
- en: The **Text widget** is one of the simpler widgets that exists. This is because
    it only allows you to display text information to the user and customize the visuals
    of this text. Almost every single game uses text in one way or another to display
    information to its players. **Overwatch**, for example, uses a text-based UI to
    display crucial match data to its players. Without the use of text, it would be
    very difficult – maybe even impossible – to convey key pieces of statistical data
    to the player, such as total damage dealt, total time playing the game, and much
    more.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本小部件** 是存在的小部件中比较简单的一种。这是因为它只允许你向用户显示文本信息并自定义此文本的视觉效果。几乎每款游戏都会以某种方式使用文本来向玩家显示信息。例如，**守望先锋**
    使用基于文本的用户界面向玩家显示关键的比赛数据。如果没有使用文本，将很难——甚至可能不可能——向玩家传达关键统计数据，例如总伤害、游戏总时间等等。'
- en: 'The `Text Block` by default. You can customize this text by adding your text
    to the `Text` parameter of the widget. Alternatively, you can use `Function Binding`
    to display more robust text that can reference internal or external variables.
    `Function Binding` should be used whenever you need to display information that
    can change; this could be text that represents a player’s score, how much money
    the player has, or in our case, the number of coins the player has collected:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下是`文本块`。您可以通过将文本添加到小部件的`文本`参数来自定义此文本。或者，您可以使用`功能绑定`来显示更健壮的文本，该文本可以引用内部或外部变量。`功能绑定`应在需要显示可能发生变化的信息时使用；这可能代表玩家的分数、玩家拥有的金钱，或者在我们的情况下，玩家收集到的硬币数量：
- en: You will be using the `Function Binding` functionality of the `GetCurrentNumberofCollectables()`
    function you created in *Exercise 15.03 – tracking the number of coins for the
    player*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用在*练习15.03 – 跟踪玩家硬币数量*中创建的`GetCurrentNumberofCollectables()`函数的`功能绑定`功能。
- en: Now that we have the **Text widget** in the **Canvas** panel, it is time to
    position this widget where we need it to be. For this, we will take advantage
    of anchors.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在`画布`面板中有了`文本小部件`，是时候将这个小部件放置在我们需要的位置了。为此，我们将利用锚点。
- en: Anchors
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锚点
- en: Anchors are used to define where a widget’s desired location should be on the
    `Anchor` point will ensure that the widget will maintain this position with varying
    screen sizes through different platform devices such as phones, tablets, and computers.
    Without an anchor, a widget’s position can become inconsistent between different
    screen resolutions, which is never desired.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点用于定义小部件期望的位置，在`锚点`处将确保小部件在不同平台设备（如手机、平板电脑和电脑）的屏幕尺寸变化时保持此位置。如果没有锚点，小部件的位置在不同屏幕分辨率之间可能会变得不一致，这是不希望看到的。
- en: Note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about anchors, please refer to the following documentation:
    [https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors/index.xhtml](https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors/index.xhtml).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有关锚点的更多信息，请参阅以下文档：[https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors/index.xhtml](https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors/index.xhtml)。
- en: For our`Anchor` point will be at the top-left corner of the screen. You will
    also add a position offset from this `Anchor` point so that the text is more visible
    and readable to the player. Before moving on to creating our `Text` `Formatting`,
    which you will use to display the current number of collected coins to the player.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`锚点`将位于屏幕的左上角。您还将从这个`锚点`添加一个位置偏移量，以便文本对玩家来说更易于可见和阅读。在继续创建我们的`文本``格式化`之前，您将使用它来显示玩家收集到的当前硬币数量。
- en: Text formatting
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本格式化
- en: 'Much like the `UE_LOG()` macro available to us in C++, Blueprints offers a
    similar solution to display text and format it to allow custom variables to be
    added to it. The `Format Text` function takes in a single text input labeled `Format`
    and returns the `Result` text. This can be used to display information:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们C++中可用的`UE_LOG()`宏类似，蓝图提供了一个类似的解决方案来显示文本并对其进行格式化，以便添加自定义变量。`格式化文本`函数接受一个标记为`格式`的单个文本输入，并返回`结果`文本。这可以用来显示信息：
- en: '![Figure 15.5 – The Format Text function ](img/Figure_15.05_B18531.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图15.5 – 格式化文本函数](img/Figure_15.05_B18531.jpg)'
- en: Figure 15.5 – The Format Text function
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 – 格式化文本函数
- en: 'Instead of using the `%` symbol like `UE_LOG()` does, the `Format Text` function
    uses the `{}` symbols to denote arguments that can be passed into the string.
    In-between the `{}` symbols, you need to add an argument name; this can be anything
    you want, but it should be representative of what the argument is. Refer to the
    example shown in the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与`UE_LOG()`使用`%`符号不同，`格式化文本`函数使用`{}`符号来表示可以传递到字符串中的参数。在`{}`符号之间，您需要添加一个参数名称；这可以是您想要的任何内容，但它应该代表参数的内容。请参考以下截图中的示例：
- en: '![Figure 15.6 – An example integer in the Format Text function ](img/Figure_15.06_B18531.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图15.6 – 格式化文本函数中的示例整数](img/Figure_15.06_B18531.jpg)'
- en: Figure 15.6 – An example integer in the Format Text function
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 – 格式化文本函数中的示例整数
- en: The `Format Text` function only supports `Byte`, `Integer`, `Float`, `Text`,
    or `EText Gender` variable types, so if you are attempting to pass any other type
    of variable into the function as an argument, you must convert it into one of
    the supported types.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`格式化文本`函数仅支持`字节`、`整数`、`浮点`、`文本`或`EText Gender`变量类型，因此如果您尝试将任何其他类型的变量作为参数传递给该函数，您必须将其转换为支持的类型之一。'
- en: Note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `Format Text` function is also used for **Text Localization**, where you
    can support multiple languages for your game. More information about how this
    can be done in both C++ and Blueprints can be found here: [https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.xhtml](https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.xhtml).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`格式文本`功能也用于**文本本地化**，您可以为您的游戏支持多种语言。有关如何在C++和蓝图中进行此操作的更多信息，请参阅以下文档：[https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.xhtml](https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.xhtml)。'
- en: You will be using the `Format Text` function in conjunction with the `Coin Counter
    UI` widget to display the number of coins that have been collected by the player.
    You will also be using `Anchor` points to position the **Text widget** at the
    top-left corner of the screen.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用`Format Text`功能与`Coin Counter UI`小部件一起使用，以显示玩家收集到的硬币数量。您还将使用`Anchor`点将**文本小部件**定位在屏幕的左上角。
- en: Exercise 15.04 – creating the Coin Counter UI HUD element
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.04 – 创建Coin Counter UI HUD元素
- en: 'In this exercise, you will be creating the UMG UI asset, which will display
    and update the number of coins collected by the player. You will use the `GetCurrentNumberofCollectables()`
    inline function you created in *Exercise 15.02 – creating the PickableActor_Collectable
    class*, to display this value on the screen using a simple **Text widget**. Follow
    these steps to accomplish this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建UMG UI资产，该资产将显示并更新玩家收集到的硬币数量。您将使用在*练习15.02 – 创建PickableActor_Collectable类*中创建的`GetCurrentNumberofCollectables()`内联函数，通过简单的**文本小部件**在屏幕上显示此值。按照以下步骤完成此操作：
- en: Let’s start by creating a new folder inside the `UI`. Do this by *right-clicking*
    on the `Content` folder at the top of the browser directory in the editor and
    selecting **New Folder**.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在`UI`内部创建一个新文件夹开始。通过在编辑器中浏览器目录顶部的`Content`文件夹上**右键单击**，然后选择**新建文件夹**来完成此操作。
- en: Inside the new `/Content/UI` directory, *right-click* and, instead of selecting
    **Blueprint Class**, hover over the **User Interface** option at the bottom of
    this list and *left-click* the **Widget Blueprint** option.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的`/Content/UI`目录内，**右键单击**，然后在此列表底部**用户界面**选项上悬停，**左键单击****小部件蓝图**选项，而不是选择**蓝图类**。
- en: Name this new `BP_UI_CoinCollection`, and then *double-left-click* the asset
    to open the UMG editor.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此新`BP_UI_CoinCollection`重命名，然后**双击左键**资产以打开UMG编辑器。
- en: 'By default, the **Widget** panel is empty, and you will find an empty hierarchy
    on the left-hand side, as shown in the following screenshot:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，**小部件**面板是空的，您将在左侧找到一个空层次结构，如下面的截图所示：
- en: '![Figure 15.7 – The Widget panel’s empty hierarchy ](img/Figure_15.07_B18531.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图15.7 – 小部件面板的空层次结构](img/Figure_15.07_B18531.jpg)'
- en: Figure 15.7 – The Widget panel’s empty hierarchy
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7 – 小部件面板的空层次结构
- en: Above the **Hierarchy** tab is the **Palette** tab, which lists all the available
    widgets you can use inside your UI. We will only focus on the **Text widget**,
    which is listed under the **Common** category. Do not mistake this option with
    the **Rich Text Block** widget.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**标签上方是**调色板**标签，其中列出了您可以在UI中使用的所有可用小部件。我们将只关注**文本小部件**，它位于**常用**类别下。不要将此选项与**富文本块**小部件混淆。
- en: Note
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a more detailed reference regarding all the available widgets inside UMG,
    please read the following documentation from Epic Games: [https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/WidgetTypeReference/index.xhtml](https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/WidgetTypeReference/index.xhtml).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有关UMG中所有可用小部件的更详细参考，请阅读以下来自Epic Games的文档：[https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/WidgetTypeReference/index.xhtml](https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/WidgetTypeReference/index.xhtml)。
- en: If one is not automatically created, add a **Canvas Panel** widget as the base
    of the **Hierarchy** area.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有自动创建，请添加一个**画布面板**小部件作为**层次结构**区域的基座。
- en: Add the **Text** **widget** to the **UI** panel by either *left-clicking* and
    dragging the **Text widget** from the **Palette** tab to the **Hierarchy** tab
    underneath the **Canvas** panel root, or by *left-clicking* and dragging the **Text
    widget** directly into the **Canvas** panel itself in the middle of the UMG editor.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下方式将**文本****小部件**添加到**UI**面板：要么**左键单击**并从**调色板**标签拖动**文本小部件**到**画布**面板根部的**层次结构**标签下，要么**左键单击**并直接将**文本小部件**拖动到UMG编辑器中间的**画布**面板中。
- en: Before changing the text of this widget, we need to update its anchor, position,
    and font size so that it fits the needs we have for displaying the necessary information
    to the player.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改此小部件的文本之前，我们需要更新其锚点、位置和字体大小，以便它符合我们向玩家显示必要信息的需要。
- en: 'With the **Text widget** selected, you will see many options under its **Details**
    panel to customize it. The first thing to do here is anchor the **Text widget**
    to the top-left corner of the **Canvas** panel. *Left-click* on the **Anchors**
    dropdown and select the top-left anchoring option, as shown in the following screenshot:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文本小部件**后，您将在其**详细信息**面板下看到许多选项来自定义它。在这里要做的第一件事是将**文本小部件**锚定到**画布**面板的左上角。*左键点击*
    **锚点**下拉菜单并选择左上角锚定选项，如图下所示：
- en: '![Figure 15.8 – By default, there are options to anchor a widget at different
    locations on the screen ](img/Figure_15.08_B18531.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图15.8 – 默认情况下，有选项将小部件锚定在屏幕上的不同位置](img/Figure_15.08_B18531.jpg)'
- en: Figure 15.8 – By default, there are options to anchor a widget at different
    locations on the screen
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8 – 默认情况下，有选项将小部件锚定在屏幕上的不同位置
- en: Anchoring allows the widget to maintain its desired location within the **Canvas**
    panel, regardless of varying screen sizes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 锚定允许小部件在**画布**面板内保持其期望的位置，无论屏幕大小如何变化。
- en: Now that the **Text widget** is anchored to the top-left corner, we need to
    set its relative position to this anchor so that there is an offset for better
    positioning and readability of the text.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**文本小部件**已锚定到左上角，我们需要设置其相对于此锚点的相对位置，以便有偏移量以更好地定位和阅读文本。
- en: In the `Position X` and `Position Y`. Set both these parameters to `100.0f`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`位置X`和`位置Y`中，将这两个参数都设置为`100.0f`。
- en: 'Next, enable the **Size To Content** parameter so that the **Text widget**
    will automatically resize itself depending on the size of the text it is displaying,
    as shown in the following screenshot:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，启用**大小到内容**参数，以便**文本小部件**将根据显示的文本大小自动调整大小，如图下所示：
- en: '![Figure 15.9 – The Size To Content parameter will ensure that the Text widget
    won’t be cut off ](img/Figure_15.09_B18531.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图15.9 – 大小到内容参数将确保文本小部件不会被截断](img/Figure_15.09_B18531.jpg)'
- en: Figure 15.9 – The Size To Content parameter will ensure that the Text widget
    won’t be cut off
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9 – 大小到内容参数将确保文本小部件不会被截断
- en: Lastly, we must update the size of the font that’s used for the `48`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须更新用于`48`的字体大小。
- en: 'The final **Text widget** will look like this:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的**文本小部件**将看起来像这样：
- en: '![Figure 15.10 – The Text widget is now anchored to the top left of the Canvas
    panel ](img/Figure_15.10_B18531.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图15.10 – 文本小部件现在锚定在画布面板的左上角](img/Figure_15.10_B18531.jpg)'
- en: Figure 15.10 – The Text widget is now anchored to the top left of the Canvas
    panel
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10 – 文本小部件现在锚定在画布面板的左上角
- en: Now that we have the **Text** **widget** positioned and sized the way we need
    it to be, let’s add a new binding to the text so that it will automatically update
    and match the value of the number of collectibles the player has.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将**文本****小部件**定位和调整到所需的大小，让我们添加一个新的绑定到文本，以便它将自动更新并匹配玩家拥有的可收集物品数量。
- en: With the **Text** widget selected, find the **Text** parameter in its **Details**
    panel, under the **Content** category. There, you will find the **Bind** option.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文本**小部件后，在**详细信息**面板的**内容**类别下找到**文本**参数。在那里，您将找到**绑定**选项。
- en: '*Left-click* the `Function Binding` will be created automatically and be given
    the name `GetText_0`. Please refer to the following screenshot:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键点击* `函数绑定`将自动创建并命名为`GetText_0`。请参考以下截图：'
- en: '![Figure 15.11 – The new bound function of the text ](img/Figure_15.11_B18531.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图15.11 – 文本的新绑定功能](img/Figure_15.11_B18531.jpg)'
- en: Figure 15.11 – The new bound function of the text
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11 – 文本的新绑定功能
- en: Rename this function `Get Number of Collectables`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此函数重命名为`获取可收集物品数量`。
- en: 'Before continuing with this function, create a new object reference variable
    called `Player` that’s of the `SuperSideScroller_Player` type. Make this variable
    **Public** and exposable on spawn by enabling both the **Instance Editable** and
    **Expose on Spawn** parameters of the variable, as shown in the following screenshot:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续此函数之前，创建一个新的对象引用变量`Player`，其类型为`SuperSideScroller_Player`。将此变量设置为**公共**并启用其**实例可编辑**和**在生成时暴露**参数，如图下所示：
- en: '![Figure 15.12 – The Player variable with the Instance Editable and Expose
    on Spawn parameters enabled ](img/Figure_15.12_B18531.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图15.12 – 启用实例可编辑和生成时暴露参数的`Player`变量](img/Figure_15.12_B18531.jpg)'
- en: Figure 15.12 – The Player variable with the Instance Editable and Expose on
    Spawn parameters enabled
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12 – 启用实例可编辑和生成时暴露参数的`Player`变量
- en: By making the `Player` variable **Public** and exposed on spawn, you will be
    able to assign this variable when creating the widget and adding it to the screen.
    We will do this in *Exercise 15.05 – adding the coin counter UI to the player
    screen*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`Player`变量设置为**公共**并在生成时暴露，你将能够在创建小部件并将其添加到屏幕时分配此变量。我们将在*练习15.05 – 将硬币计数器UI添加到玩家屏幕*中这样做。
- en: Now that we have a reference variable to `SuperSideScroller_Player`, let’s continue
    with the `Get Number of Collectables` bind function.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了对`SuperSideScroller_Player`的引用变量，让我们继续`获取可收集物品数量`绑定函数。
- en: Add a `Player` variable to the `Get Number of Collectables` function.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Player`变量添加到`获取可收集物品数量`函数中。
- en: 'From this variable, *left-click* and drag and from the context-sensitive drop-down
    menu, and find and select the `Get Current Number of Collectables` function. Please
    refer to the following screenshot:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个变量中，*左键单击*并拖动，从上下文相关下拉菜单中，找到并选择`获取当前可收集物品数量`函数。请参考以下截图：
- en: '![Figure 15.13 – The Get Current Number of Collectables function you created
    in Exercise 15.03 ](img/Figure_15.13_B18531.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图15.13 – 你在练习15.03中创建的获取当前可收集物品数量的函数](img/Figure_15.13_B18531.jpg)'
- en: Figure 15.13 – The Get Current Number of Collectables function you created in
    Exercise 15.03
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13 – 你在练习15.03中创建的获取当前可收集物品数量的函数
- en: 'Next, *left-click* and drag out the `Return Value` text parameter of `Get Number
    of Collectables` to `Return Node`. From the context-sensitive drop-down menu,
    search for and select the **Format Text** option, as shown in the following screenshot:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，*左键单击*并拖动`获取可收集物品数量`的`返回值`文本参数到`返回节点`。从上下文相关下拉菜单中，搜索并选择**格式文本**选项，如图所示：
- en: '![Figure 15.14 – Now, we can create customized and formatted text ](img/Figure_15.14_B18531.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图15.14 – 现在，我们可以创建自定义和格式化的文本](img/Figure_15.14_B18531.jpg)'
- en: Figure 15.14 – Now, we can create customized and formatted text
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.14 – 现在，我们可以创建自定义和格式化的文本
- en: 'Within the `Format Text` function, add the following text:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`格式文本`函数中，添加以下文本：
- en: '[PRE31]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Please refer to the following screenshot:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下截图：
- en: '![Figure 15.15 – Now, there is a new input argument for the formatted text
    ](img/Figure_15.15_B18531.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图15.15 – 现在，格式化文本的新输入参数](img/Figure_15.15_B18531.jpg)'
- en: Figure 15.15 – Now, there is a new input argument for the formatted text
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15 – 现在，格式化文本有一个新的输入参数
- en: Remember that using the `{}` symbols denotes a text argument that allows you
    to pass variables into the text.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用`{}`符号表示一个文本参数，允许你将变量传递到文本中。
- en: 'Finally, connect the `Return Value` int of the `GetCurrentNumberofCollectables()`
    function to the wildcard `coins` input pin of the `Format Text` function, as shown
    here:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`GetCurrentNumberofCollectables()`函数的`返回值`int连接到`格式文本`函数的通配符`coins`输入引脚，如图所示：
- en: '![Figure 15.16 – The Text widget will update automatically based on the Get
    Current Number of Collectables function ](img/Figure_15.16_B18531.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图15.16 – 文本小部件将根据获取当前可收集物品数量的函数自动更新](img/Figure_15.16_B18531.jpg)'
- en: Figure 15.16 – The Text widget will update automatically based on the Get Current
    Number of Collectables function
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.16 – 文本小部件将根据获取当前可收集物品数量的函数自动更新
- en: Compile and save the `BP_UI_CoinCollection` widget Blueprint.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并保存`BP_UI_CoinCollection`小部件蓝图。
- en: Note
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the assets and code for this exercise here: [https://packt.live/3eQJjTU](https://packt.live/3eQJjTU).'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到此练习的资源和代码：[https://packt.live/3eQJjTU](https://packt.live/3eQJjTU)。
- en: With this exercise completed, you have created the `UI UMG` widget needed to
    display the current number of coins collected by the player. By using the `GetCurrentNumberofCollectables()`
    C++ function and the binding functionality of the **Text widget**, the UI will
    always update its value based on the number of coins collected. In the next exercise,
    we will add this UI to the player’s screen, but first, we’ll briefly learn about
    how to add and remove UMG from the player screen.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，你已经创建了显示玩家收集到的当前金币数量的 `UI UMG` 小部件。通过使用 `GetCurrentNumberofCollectables()`
    C++ 函数和 **Text 小部件**的绑定功能，UI 将始终根据收集到的金币数量更新其值。在下一个练习中，我们将把这个 UI 添加到玩家的屏幕上，但首先，我们将简要了解如何向玩家屏幕添加和移除
    UMG。
- en: Adding and creating UMG user widgets
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和创建 UMG 用户小部件
- en: Now that we have created **Coin Collection UI** in UMG, it is time to learn
    how to add and remove the UI to and from the player screen, respectively. By adding
    **Coin Collection UI** to the player screen, the UI becomes visible to the player
    and can be updated as the player collects coins.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 UMG 中创建了 **Coin Collection UI**，是时候学习如何分别将 UI 添加到和从玩家屏幕中移除了。通过将 **Coin
    Collection UI** 添加到玩家屏幕，UI 对玩家可见，并且可以在玩家收集金币时更新。
- en: 'In Blueprints, there is a function called `Create Widget`, as shown in the
    following screenshot. Without a class assigned, it will be labeled `Construct
    None`, but do not let this confuse you:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Blueprints 中，有一个名为 `Create Widget` 的函数，如下面的截图所示。如果没有分配类，它将被标记为 `Construct
    None`，但不要因此感到困惑：
- en: '![Figure 15.17 – The Create Widget function as-is by default, without a class
    applied ](img/Figure_15.17_B18531.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.17 – 默认情况下未应用类的 Create Widget 函数](img/Figure_15.17_B18531.jpg)'
- en: Figure 15.17 – The Create Widget function as-is by default, without a class
    applied
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.17 – 默认情况下未应用类的 Create Widget 函数
- en: 'This function requires the class of the `User` widget to be created and requires
    a `Player Controller` that will be referenced as the owning player of this UI.
    This function then returns the spawned user widget as its `Return Value`, where
    you can then add it to the player’s viewport using the `Add to Viewport` function.
    The `Create Widget` function only instantiates the widget object; it does not
    add this widget to the player’s screen. It is the `Add to Viewport` function that
    makes this widget visible on the player’s screen:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数需要创建 `User` 小部件的类，并需要一个 `Player Controller`，该控制器将被引用为该 UI 的拥有玩家。然后，该函数返回生成的用户小部件作为其
    `返回值`，然后你可以使用 `Add to Viewport` 函数将其添加到玩家的视图中。`Create Widget` 函数仅实例化小部件对象；它不会将此小部件添加到玩家的屏幕上。使此小部件在玩家屏幕上可见的是
    `Add to Viewport` 函数：
- en: '![Figure 15.18 – The Add to Viewport function with ZOrder ](img/Figure_15.18_B18531.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.18 – 带有 ZOrder 的 Add to Viewport 函数](img/Figure_15.18_B18531.jpg)'
- en: Figure 15.18 – The Add to Viewport function with ZOrder
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.18 – 带有 ZOrder 的 Add to Viewport 函数
- en: 'The viewport is the game screen that overlays your view of the game world,
    and it uses what is called `ZOrder` to determine the overlay depth in cases where
    multiple UI elements need to overlap above or below one another. By default, the
    `Add to Viewport` function will add the `User` widget to the screen and make it
    fill the entire screen – that is, unless the `Set Desired Size In Viewport` function
    is called to set the size that it should fill manually:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 视口是覆盖你游戏世界视图的游戏屏幕，当多个 UI 元素需要相互重叠时，它使用所谓的 `ZOrder` 来确定重叠的深度。默认情况下，`Add to Viewport`
    函数会将 `User` 小部件添加到屏幕上并使其填充整个屏幕——除非调用 `Set Desired Size In Viewport` 函数来手动设置它应该填充的大小：
- en: '![Figure 15.19 – The Size parameter determines the desired size of the passed
    in the User widget ](img/Figure_15.19_B18531.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.19 – Size 参数确定传入 User 小部件的期望大小](img/Figure_15.19_B18531.jpg)'
- en: Figure 15.19 – The Size parameter determines the desired size of the passed
    in the User widget
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.19 – Size 参数确定传入 User 小部件的期望大小
- en: 'In C++, you also have a function called `CreateWidget()`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，你还有一个名为 `CreateWidget()` 的函数：
- en: '[PRE32]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `CreateWidget()` function is available through the `UserWidget` class, which
    can be found in `/Engine/Source/Runtime/UMG/Public/Blueprint/UserWidget.h`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateWidget()` 函数通过 `UserWidget` 类提供，该类位于 `/Engine/Source/Runtime/UMG/Public/Blueprint/UserWidget.h`。'
- en: 'An example of this can be found in [*Chapter 8*](B18531_08.xhtml#_idTextAnchor168),
    *Creating User Interfaces with UMG*, where you used the `CreateWidget()` function
    to create `BP_HUDWidget`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有关示例，请参阅 [*第 8 章*](B18531_08.xhtml#_idTextAnchor168)，*使用 UMG 创建用户界面*，其中你使用了
    `CreateWidget()` 函数来创建 `BP_HUDWidget`：
- en: '[PRE33]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Refer back to [*Chapter 8*](B18531_08.xhtml#_idTextAnchor168), *Creating User
    Interfaces with UMG*, and *Exercise 8.06 – creating the health bar C++ logic*,
    for more information regarding the `CreateWidget()` function in C++.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: This function works almost identically to its Blueprint counterpart because
    it takes in the `Owning Object` parameter, much like the `Owning Player` parameter
    of the Blueprint function, and it requires the `User Widget` class to be created.
    The C++ `CreateWidget()` function also takes in an `FName` parameter to represent
    the widget’s name.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about the methods to use to add a UI to the player
    screen, let’s put this knowledge to the test. In the following exercise, you will
    be implementing the `Create Widget` and `Add to Viewport` Blueprint functions
    so that we can add the **coin collection UI** that we created in *Exercise 15.04
    – creating the Coin Counter UI HUD element*, to the player screen.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.05 – Adding Coin Counter UI to the player screen
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will be creating a new `Player Controller` class so that
    you can use the player controller to add the `BP_UI_CoinCollection` widget Blueprint
    to the player’s screen. From there, you will also create a new `Game Mode` class
    and apply this game mode to the **SuperSideScroller** project. Perform the following
    steps to complete this exercise:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: In the UE5 editor, navigate to **Tools** and then **New C++ Class**.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Choose Parent Class** dialog window, find and select the **Player
    Controller** option.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new `Player Controller` class `SuperSideScroller_Controller` and then
    click the `SuperSideScroller_Controller` class, but for now, we will stay inside
    the UE5 editor.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `MainCharacter` folder directory, create a new folder called `PlayerController`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `PlayerController` folder, *right-click* and create a new `Blueprint
    Class` using the new `SuperSideScroller_Controller` class. Please refer to the
    following screenshot:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.20 – Finding the new SuperSideScroller_Controller class to create
    a new Blueprint from ](img/Figure_15.20_B18531.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: Figure 15.20 – Finding the new SuperSideScroller_Controller class to create
    a new Blueprint from
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Name this new Blueprint `BP_SuperSideScroller_PC` and then *double-left-click*
    the asset to open it.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add the `BP_UI_CoinCollection` widget to the screen, we need to use the `Add
    to Viewport` function and the `Create Widget` function. We want the UI to be added
    to the player’s screen after the player character has been `Possessed` by the
    player controller.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* inside the Blueprint graph and, from the context-sensitive menu,
    find the **Event On Possess** option and *left-click* to add it to the graph.
    Please refer to the following screenshot:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.21 – Event On Possess  ](img/Figure_15.21_B18531.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: Figure 15.21 – Event On Possess
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The **Event On Possess** event node returns **Possessed Pawn**. We will use
    this **Possessed Pawn** to pass into our BP_UI_CoinCollection UI Widget, but first,
    we need to **Cast To the SuperSideScroller_Player** class.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-click* and drag the `Event On Possess` node from the output. Then, search
    for and find the `Cast to SuperSideScroller_Player` node. Please refer to the
    following screenshot:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.22 – We need to Cast To SuperSideScroller_Player ](img/Figure_15.22_B18531.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
- en: Figure 15.22 – We need to Cast To SuperSideScroller_Player
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Now, *right-click* and search for the `Create Widget` function to add it to
    the Blueprint graph.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the drop-down class parameter, find and assign the `BP_UI_CoinCollection`
    asset you created in *Exercise 15.04 – creating the Coin Counter UI HUD element*.
    Please refer to the following screenshot:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.23 – The Create Widget function  ](img/Figure_15.23_B18531.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: Figure 15.23 – The Create Widget function
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: After updating the `Class` parameter to the `BP_UI_CoinCollection` class, you
    will notice that the `Create Widget` function will update to show the `Player`
    variable you created, set to `Exposed on Spawn`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* in the Blueprint graph to search for and find the `Self` reference
    variable from the context-sensitive drop-down menu. Connect the `Self` object
    variable to the `Owning Player` parameter of the `Create Widget` function, as
    shown in the following screenshot:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.24 – The Owning Player input parameter is of the Player Controller
    type ](img/Figure_15.24_B18531.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: Figure 15.24 – The Owning Player input parameter is of the Player Controller
    type
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The Owning Player parameter refers to the Player Controller type that will show
    and own this UI object. Since we are adding this UI to the **SuperSideScroller_Controller**
    Blueprint, we can just use the **Self** reference variable to pass into the function.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, pass in the returned `SuperSideScroller_Player` variable from the `Cast`
    node to the `Player` input node of the `Create Widget` function. Then, connect
    the execution pins of the `Cast` node and the `Create Widget` function, as shown
    in the following screenshot:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.25 – Creating the BP_UI_CoinCollection widget ](img/Figure_15.25_B18531.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: Figure 15.25 – Creating the BP_UI_CoinCollection widget
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/blob/master/Chapter15/Images/New_25.png](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/blob/master/Chapter15/Images/New_25.png).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Upon pulling the `Create Widget` function from the `Return Value` parameter,
    search for and find the `Add to Viewport` function so that you can place it in
    the graph.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the output `Return Value` parameter of the `Create Widget` function
    to the `Target` input parameter of the `Add to Viewport` function; do not change
    the `ZOrder` parameter.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, connect the execution pins of the `Create Widget` and `Add to Viewport`
    functions, as shown here:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.26 – After creating the BP_UI_CoinCollection widget, we can add
    it to the player viewport ](img/Figure_15.26_B18531.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: Figure 15.26 – After creating the BP_UI_CoinCollection widget, we can add it
    to the player viewport
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/2UwufBd](https://packt.live/2UwufBd).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Now that the player controller adds the `BP_UI_CoinCollection` widget to the
    player’s viewport, we need to create a `GameMode` Blueprint and apply both the
    `BP_SuperSideScroller_MainCharacter` and `BP_SuperSideScroller_PC` classes to
    this game mode.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: In the `Content` folder and selecting `GameMode`.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, *right-click* and select `SuperSideScrollerGameMode` under `All Classes`.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this new `GameMode` Blueprint `BP_SuperSideScroller_GameMode`. *Double-left-click*
    this asset to open it.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `GameMode` Blueprint contains a list of classes that you can customize with
    your unique classes. For now, we will only worry about `Player Controller Class`
    and `Default Pawn Class`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Click the `BP_SuperSideScroller_PC` Blueprint you created earlier in this exercise.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click the `BP_SuperSideScroller_MainCharacter` Blueprint.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have a custom `GameMode` that utilizes our custom `Player Controller`
    and `Player Character` classes, let’s add this game mode to the `PIE` and when
    cooking builds of the project.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: From the UE5 editor, navigate to the **Edit** option at the top of the screen.
    Click this option and from the drop-down menu, find and select the **Project Settings**
    option.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left-hand side of the **Project Settings** window, you will be provided
    with a list of categories divided into sections. Under the **Project** section,
    click the **Maps & Modes** category.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Maps & Modes** section, you have a handful of parameters related to
    your project’s default maps and game mode. At the top of this section, you have
    the **Default GameMode** option. Click this dropdown to find and select the **SuperSideScroller_GameMode**
    Blueprint you created earlier in this exercise.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Changes made to the `DefaultEngine.ini` file, which can be found in your project’s
    `Config` folder. `Default GameMode` can be overwritten per level by updating the
    **GameMode Override** parameter, which can be found in the **World Settings**
    window of your level.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Close the `PIE` and start collecting coins. Observe that the **BP_UI_CoinCollection**
    widget is shown and updated each time you collect a coin, as shown in the following
    screenshot:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.27 – Now, every coin you collect will appear on the player UI ](img/Figure_15.27_B18531.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
- en: Figure 15.27 – Now, every coin you collect will appear on the player UI
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.27 – 现在，你收集到的每一枚金币都会出现在玩家 UI 上
- en: Note
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the assets and code for this exercise here: [https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.05](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.05).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到这个练习的资源和代码：[https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.05](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.05)。
- en: With this exercise complete, you have created the `UI UMG` widget needed to
    display the current number of coins collected by the player. By using the `GetCurrentNumberofCollectables()`
    C++ function and the binding functionality of the **Text widget**, the UI will
    always update its value based on the number of coins collected.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经创建了显示玩家收集到的当前金币数量的 `UI UMG` 小部件。通过使用 `GetCurrentNumberofCollectables()`
    C++ 函数和 **Text 小部件**的绑定功能，UI 将始终根据收集到的金币数量更新其值。
- en: So far, we have focused on the collectible coin and allowing players to collect
    these coins and add the total coins collected to the player’s UI. Now, we will
    focus on the potion power-up and granting movement speed and jump height increases
    to the player for a short period. To implement this functionality, we first need
    to study timers.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于可收集的硬币，允许玩家收集这些硬币并将收集到的总金币数添加到玩家的 UI 上。现在，我们将专注于药水增强效果，并在短时间内为玩家提供移动速度和跳跃高度的增加。要实现这个功能，我们首先需要研究计时器。
- en: Using timers
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计时器
- en: Timers in UE5 allow you to perform actions after a delay or every *X* number
    of seconds. In the case of the **SuperSideScroller** potion power-up, a timer
    will be used to restore the player’s movement and jump to their defaults after
    8 seconds.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: UE5 中的计时器允许你在延迟后或每 *X* 秒数后执行操作。在 **SuperSideScroller** 药水增强效果的情况下，计时器将在 8 秒后恢复玩家的移动和跳跃到默认状态。
- en: Note
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Blueprints, you can use a `Delay` node in addition to timer handles to achieve
    the same results. However, in C++, timers are the best means to achieve delays
    and reoccurring logic.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图（Blueprints）中，你可以使用 `Delay` 节点以及计时器句柄来实现相同的结果。然而，在 C++ 中，计时器是实现延迟和重复逻辑的最佳手段。
- en: 'Timers are managed by `Timer Manager`, or `FTimerManager`, which exists in
    the `UWorld` object. There are two main functions that you will be using from
    the `FTimerManager` class, called `SetTimer()` and `ClearTimer()`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器由 `Timer Manager` 或 `FTimerManager` 管理，它存在于 `UWorld` 对象中。你将主要使用 `FTimerManager`
    类中的两个函数，称为 `SetTimer()` 和 `ClearTimer()`：
- en: '[PRE34]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You may have noticed that, in both functions, there is a required `FTimerHandle`.
    This handle is used to control the timer you have set. Using this handle, you
    can pause, resume, clear, and even extend the timer.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在这两个函数中，都有一个必需的 `FTimerHandle`。这个句柄用于控制你设置的计时器。使用这个句柄，你可以暂停、恢复、清除，甚至扩展计时器。
- en: The `SetTimer()` function also has other parameters to help you customize this
    timer when initially setting it. The callback function will be called after the
    timer has been completed, and if the `InbLoop` parameter is `True`, it will continue
    to call the callback function indefinitely, until the timer has been stopped.
    The `InRate` parameter is the duration of the timer itself, while `InFirstDelay`
    is an initial delay that’s applied to the timer before it begins its timer for
    `InRate`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetTimer()` 函数还有其他参数，可以帮助你在最初设置计时器时进行自定义。计时器完成后，回调函数将被调用，如果 `InbLoop` 参数为
    `True`，则回调函数将无限期地继续调用，直到计时器被停止。`InRate` 参数是计时器本身的持续时间，而 `InFirstDelay` 是在计时器开始其
    `InRate` 持续时间的计时之前应用的一个初始延迟。'
- en: 'The header file for the `FTimerManager` class can be found here: `/Engine/Source/Runtime/Engine/Public/TimerManager.h`.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTimerManager` 类的头文件可以在以下位置找到：`/Engine/Source/Runtime/Engine/Public/TimerManager.h`。'
- en: Note
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more about timers and `FTimerHandle` by reading the documentation
    here: [https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/](https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/).'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过阅读以下文档了解更多关于计时器和 `FTimerHandle` 的信息：[https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/](https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Timers/)。
- en: In the following exercise, you will create your own `FTimerHandle` in the `SuperSideScroller_Player`
    class and use it to control how long the effects of the potion power-up last on
    the player.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.06 – adding the potion power-up behavior to the player
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will be creating the logic behind the potion power-up
    and how it will affect the player’s character. You will take advantage of timers
    and timer handles to ensure that the power-up effects only last for a short duration.
    Follow these steps to accomplish this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to and open the `SuperSideScroller_Player.h` header
    file.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under our `Private Access Modifier`, add a new variable of the `FTimerHandle`
    type and name it `PowerupHandle`:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This timer handle will be responsible for keeping track of how much time has
    elapsed since it was initiated. This will allow us to control how long the potion
    power-up’s effects will last.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a Boolean variable under our `Private Access Modifier` called `bHasPowerupActive`:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We will use this Boolean variable when updating the `Sprint()` and `StopSprinting()`
    functions to ensure we update the player’s sprint movement speed appropriately
    based on whether the power-up is active.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, declare a new void function called `IncreaseMovementPowerup()` under
    our `Public Access Modifier`:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is the function that will be called from the potion power-up class to enable
    the effects of the power-up for the player.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to create a function that handles when the power-up effects
    end. Create a function called `EndPowerup()` under `Protected Access Modifier`:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With all the necessary variables and functions declared, it’s time to start
    defining these new functions and handling the power-up effects on the player.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `SuperSideScroller_Player.cpp` source file.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, add the `#include “TimerManager.h”` header file to the top of the source
    file; we will need this class to use the timers.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the `IncreaseMovementPowerup()` function by adding the following code
    to the source file:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When this function is called, the first thing we need to do is set the `bHasPowerupActive`
    variable to `true`. Add the following code to the `IncreaseMovementPowerup()`
    function:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, add the following code to increase both the `MaxWalkSpeed` and `JumpZVelocity`
    components of the player character’s movement component:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we are changing `MaxWalkSpeed` from the default value of `300.0f` to `500.0f`.
    As you may recall, the default sprinting speed is also `500.0f`. We will address
    this later in this activity to increase the sprinting speed when the power-up
    is active.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'To take advantage of timers, we need to get a reference to the `UWorld` object.
    Add the following code:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As we’ve done many times before in this project, we’re using the `GetWorld()`
    function to get a reference to the `UWorld` object and saving this reference in
    its variable.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the reference to the `World` object and have performed a validity
    check, it is safe to use `TimerManager` to set the power-up timer. Add the following
    code within the `if()` statement shown in the previous step:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, you are using the TimerManager class to set a timer. The `SetTimer()`
    function takes in the `FTimerHandle` component to use; in this case, the `PowerupHandle`
    variable you created. Next, we need to pass in a reference to the player class
    by using the `this` keyword. Then, we need to provide the callback function to
    call after the timer has ended, which in this case is the `&ASuperSideScroller_Player::EndPowerup`
    function. `8.0f` represents the duration of the timer; feel free to adjust this
    as you see fit, but for now, 8 seconds is fine. Lastly, there is the final boolean
    parameter of the `SetTimer()` function that determines whether this timer should
    loop; in this case, it should not.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the function definition for the `EndPowerup()` function:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The first thing to do when the `EndPowerup()` function is called is set the
    `bHasPowerupActive` variable to `false`. Add the following code within the `EndPowerup()`
    function:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, change the `MaxWalkSpeed` and `JumpZVelocity` parameters of the character
    movement component back to their default values. Add the following code:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we are changing both the `MaxWalkSpeed` and `JumpZVelocity` parameters
    of the character movement component to their default values.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, to take advantage of the timers and to clear the timer to handle `PowerupHandle`,
    we need to get a reference to the `UWorld` object. Add the following code:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we can add the code to clear the timer handle’s `PowerupHandle`:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: By using the `ClearTimer()` function and passing in `PowerupHandle`, we are
    ensuring that this timer is no longer valid and will no longer affect the player.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created the functions that handle the power-up effects and
    the timer associated with the effects, we need to update both the `Sprint()` and
    `StopSprinting()` functions so that they also take into account the speed of the
    player when the power-up is active.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Sprint()` function to the following:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, we are updating the `Sprint()` function to take into account whether
    `bHasPowerupActive` is `true`. If this variable is `true`, then we increase `MaxWalkSpeed`
    while sprinting from `500.0f` to `900.0f`, as shown here:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If `bHasPowerupActive` is false, then we increase `MaxWalkSpeed` to `500.0f`,
    as we did by default.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `StopSprinting()` function to the following:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, we are updating the `StopSprinting()` function to take into account whether
    `bHasPowerupActive` is true. If this variable is true, then we set the `MaxWalkSpeed`
    value to `500.0f` instead of `300.0f`, as shown here:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If `bHasPowerupActive` is false, then we set `MaxWalkSpeed` to `300.0f`, as
    we did by default.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Finally, all we need to do is recompile the C++ code.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the assets and code for this exercise here: [https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.06](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.06).'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise complete, you have created the potion power-up effects within
    the player character. The power-up increases both the default movement speed of
    the player and increases their jump height. Moreover, the effects of the power-up
    increase the sprinting speed. By using timer handles, you were able to control
    how long the power-up effect would last.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to create the potion power-up actor so that we can have a representation
    of this power-up in the game.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Activity 15.03 – creating the potion power-up actor
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the `SuperSideScroller_Player` class handles the effects of the potion
    power-up, it’s time to create the potion power-up class and Blueprint. This activity
    aims to create the potion power-up class, inherit from the `PickableActor_Base`
    class, implement the overlapping functionality to grant the movement effects that
    you implemented in *Exercise 15.06 – adding the potion power-up behavior to the
    player*, and create the Blueprint actor for the potion power-up. Follow these
    steps to create the potion power-up class and create the potion Blueprint actor:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C++ class that inherits from the `PickableActor_Base` class and
    name this new class `PickableActor_Powerup`.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the override function declarations for both the `BeginPlay()` and `PlayerPickedUp()`
    functions.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the function definition for the `BeginPlay()` function. Within the `BeginPlay()`
    function, add the call to the parent class function of `BeginPlay()`.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the function definition for the `PlayerPickedUp()` function. Within the
    `PlayerPickedUp()` function, add the call to the `PlayerPickedUp()` parent class
    function.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add the necessary `#include` file for the `SuperSideScroller_Player` class
    so that we can reference the player class and its functions.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `PlayerPickedUp()` function, use the `Player` input parameter of the
    function itself to make the function call to `IncreaseMovementPowerup()`.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From **Epic Games Launcher**, find the **Action RPG** project from the **Samples**
    tab, under the **UE Legacy Samples** category. Use this to create and install
    a new project.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate the `A_Character_Heal_Mana_Cue` and `SM_PotionBottle` assets, as well
    as all of their referenced assets, from the **Action RPG** project to your **SuperSideScroller**
    project.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder in the `PickableItems` directory called `Powerup`. Create
    a new Blueprint within this directory based on the `PickableActor_Powerup` class
    and name this asset `BP_Powerup`.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `BP_Powerup`, update the `MeshComp` component so that it uses the `SM_PotionBottle`
    static mesh.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add `A_Character_Heal_Mana_Cue`, which you imported as the `Pickup Sound`
    parameter.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, update the `RotationComp` component so that the actor will rotate 60
    degrees per second around the `Pitch` axis (`Y` axis) and rotate 180 degrees per
    second around the `Yaw` axis (`X` axis).
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `BP_Powerup` to your level and use `PIE` to observe the results when overlapping
    with the power-up.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expected output:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.28 – The potion power-up  ](img/Figure_15.28_B18531.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
- en: Figure 15.28 – The potion power-up
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: With this activity complete, you were able to put your knowledge to the test
    in terms of creating a new C++ class that inherits from the `PickableActor_Base`
    class and overrides the `PlayerPickedUp()` function to add custom logic. By adding
    the call to the `IncreaseMovementPowerup()` function from the player class, you
    were able to add the movement power-up effects to the player when overlapping
    with the actor. Then, by using a custom mesh, material, and audio assets, you
    were able to bring the Blueprint actor to life from the `PickableActor_Powerup`
    class.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created the coin collectible and the potion power-up, we need
    to implement a new gameplay feature into the project: the `Brick` class. In games
    such as *Super Mario*, bricks contain hidden coins and power-ups for the players
    to find. These bricks also serve as a means of reaching elevated platforms and
    areas within the level. In our `Brick` class will serve the purpose of containing
    hidden coin collectibles for the player, and as a means of allowing the player
    to reach areas of the level by using the bricks as paths to access hard-to-reach
    locations. So, in the next section, we will create the `Brick` class, which needs
    to be broken to find the hidden coins.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.07 – creating the Brick class
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have created the coin collectible and the potion power-up, it is
    time to create the `Brick` class, which will contain hidden coins for the player
    to collect. The brick is the final gameplay element of the `Brick` class, which
    will be used as part of the platforming mechanic of the `Brick` class and its
    Blueprint:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: In the UE5 editor, navigate to **Tools** and then **New C++ Class**.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Actor` class.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this class `SuperSideScroller_Brick` and click **Create Class**. Visual
    Studio and Unreal Engine will recompile the code and open this class for you.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, the `SuperSideScroller_Brick` class comes with the `Tick()` function,
    but we will not need this function for the `Brick` class. Remove the function
    declaration for `Tick()` from the `SuperSideScroller_Brick.h` header file and
    remove the function definition from the `SuperSideScroller_Brick.cpp` source file
    before continuing.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'Under `Private Access Modifier` for the `SuperSideScroller_Brick.h` file, add
    the following code to declare a new `UStaticMeshComponent* UPROPERTY()` function
    to represent the brick in our game world:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SuperSideScroller_Brick.h`文件的`Private Access Modifier`下，添加以下代码来声明一个新的`UStaticMeshComponent*
    UPROPERTY()`函数，以在我们的游戏世界中表示砖块：
- en: '[PRE53]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we need to create a `UBoxComponent UPROPERTY()` that will handle the
    collision with the player character. Add the following code to add this component
    under our `Private Access Modifier`:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个`UBoxComponent UPROPERTY()`来处理与玩家角色的碰撞。将以下代码添加到我们的`Private Access
    Modifier`下以添加此组件：
- en: '[PRE54]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create the `UFUNCTION()` declaration for the `OnHit()` function under our `Private
    Access Modifier`. This will be used to determine when `UBoxComponent` is hit by
    the player:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`Private Access Modifier`下创建一个`UFUNCTION()`声明，用于`OnHit()`函数。这将用于确定当`UBoxComponent`被玩家击中时：
- en: '[PRE55]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Recall that you used the `OnHit()` function when developing the `PlayerProjectile`
    class in [*Chapter 13*](B18531_13.xhtml#_idTextAnchor268), *Creating and Adding
    the Enemy Artificial Intelligence*, for this project. Please review that chapter
    for more information about the `OnHit()` function.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 记得你在开发`PlayerProjectile`类时使用了`OnHit()`函数，这是在[*第13章*](B18531_13.xhtml#_idTextAnchor268)，*创建和添加敌人人工智能*，为此项目。请查阅该章节以获取有关`OnHit()`函数的更多信息。
- en: 'Next, create a new Boolean called `UPROPERTY()` under our `Private Access Modifier`
    using the `EditAnywhere` keyword called `bHasCollectable`:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`EditAnywhere`关键字在我们的`Private Access Modifier`下创建一个新的布尔变量`UPROPERTY()`，命名为`bHasCollectable`：
- en: '[PRE56]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This Boolean will determine whether the brick contains a coin collectible for
    the player.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布尔值将确定砖块是否包含玩家可以收集的硬币。
- en: 'Now, we need a variable that holds how many coin collectibles are available
    within this brick for the player. We will do this by creating an integer variable
    called `Collectable Value`. Make this a `UPROPERTY()`, under `Private Access Modifier`,
    with the `EditAnywhere` keyword, and give it a default value of `1`, as shown
    here:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个变量来保存这个砖块内可供玩家收集的硬币收集品的数量。我们将通过创建一个名为`Collectable Value`的整型变量来实现这一点。将其设置为`UPROPERTY()`，在`Private
    Access Modifier`下，使用`EditAnywhere`关键字，并给它一个默认值`1`，如下所示：
- en: '[PRE57]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The brick will need to contain a unique sound and particle system so that it
    has a nice layer of polish for when the brick is destroyed by the player. We’ll
    add these properties next.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 砖块需要包含独特的声音和粒子系统，以便在玩家摧毁砖块时有一个漂亮的光泽层。我们将接下来添加这些属性。
- en: Create a new `Public Access Modifier` in the `SuperSideScroller_Brick.h` header
    file.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SuperSideScroller_Brick.h`头文件中创建一个新的`Public Access Modifier`。
- en: 'Next, create a new `UPROPERTY()` using the `EditAnywhere` and `BlueprintReadOnly`
    keywords for a variable of the `USoundBase` class. Name this variable `HitSound`,
    as shown here:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的`UPROPERTY()`，使用`EditAnywhere`和`BlueprintReadOnly`关键字，用于`USoundBase`类的变量。将此变量命名为`HitSound`，如下所示：
- en: '[PRE58]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, create a new `UPROPERTY()` using the `EditAnywhere` and `BlueprintReadOnly`
    keywords for a variable of the `UParticleSystem` class. Make sure to put this
    under `Public Access Modifier` and name this variable `Explosion`, as shown here:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个新的`UPROPERTY()`，使用`EditAnywhere`和`BlueprintReadOnly`关键字，用于`UParticleSystem`类的变量。确保将其放在`Public
    Access Modifier`下，并将其命名为`Explosion`，如下所示：
- en: '[PRE59]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now that we have all the necessary properties for the `Brick` class, let’s move
    on to the `SuperSideScroller_Brick.cpp` source file, where we will initialize
    the components.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为`Brick`类添加了所有必要的属性，让我们继续到`SuperSideScroller_Brick.cpp`源文件，我们将在这里初始化组件。
- en: 'Let’s start by adding the following `#include` directories for `StaticMeshComponent`
    and `BoxComponent`. Add the following code to the `#include` list of the source
    file:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先添加以下`#include`目录，用于`StaticMeshComponent`和`BoxComponent`。将以下代码添加到源文件的`#include`列表中：
- en: '[PRE60]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'First, initialize the `BrickMesh` component by adding the following code to
    the `ASuperSideScroller_Brick::ASuperSideScroller_Brick()` constructor function:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过在`ASuperSideScroller_Brick::ASuperSideScroller_Brick()`构造函数中添加以下代码来初始化`BrickMesh`组件：
- en: '[PRE61]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, the `BrickMesh` component should have a collision so that the player
    can walk on top of it for platforming gameplay purposes. To ensure this occurs
    by default, add the following code to set the collision to `“BlockAll”`:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`BrickMesh`组件应该有一个碰撞，以便玩家可以在平台上行走。为了确保默认情况下发生这种情况，添加以下代码将碰撞设置为`“BlockAll”`：
- en: '[PRE62]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Lastly, the `BrickMesh` component will serve as the root component of the `Brick`
    actor. Add the following code to do this:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`BrickMesh`组件将作为`Brick`角色的根组件。添加以下代码来完成此操作：
- en: '[PRE63]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, add the following code to the constructor function to initialize our `BrickCollision
    UBoxComponent`:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到构造函数中以初始化我们的`BrickCollision UBoxComponent`：
- en: '[PRE64]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Just like the `BrickMesh` component, the `BrickCollision` component will also
    need to have its collision set to `“BlockAll”` to receive the `OnHit()` callback
    events we will be adding later in this exercise. Add the following code:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像`BrickMesh`组件一样，`BrickCollision`组件也需要将其碰撞设置为`“BlockAll”`以接收我们将在本练习中稍后添加的`OnHit()`回调事件。添加以下代码：
- en: '[PRE65]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, the `BrickCollision` component needs to be attached to the `BrickMesh`
    component. We can do this by adding the following code:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，需要将`BrickCollision`组件附加到`BrickMesh`组件上。我们可以通过添加以下代码来完成此操作：
- en: '[PRE66]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Before we can finish the initialization of the `BrickCollision` component,
    we need to add the function definition for the `OnHit()` function. Add the following
    definition to the source file:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们完成`BrickCollision`组件的初始化之前，我们需要添加`OnHit()`函数的定义。将以下定义添加到源文件中：
- en: '[PRE67]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now that we have defined the `OnHit()` function, we can assign the `OnComponentHit`
    callback to the `BrickCollision` component. Add the following code to the constructor
    function:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`OnHit()`函数，我们可以将`OnComponentHit`回调分配给`BrickCollision`组件。将以下代码添加到构造函数中：
- en: '[PRE68]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Compile the C++ code for the `SuperSideScroller_Brick` class and return to the
    UE5 editor.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译`SuperSideScroller_Brick`类的C++代码，并返回到UE5编辑器。
- en: In the `Content` folder and select the `Brick`.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content`文件夹中，选择`Brick`。
- en: '*Right-click* inside the `Brick` folder and select `Blueprint Class`. From
    the `All Classes` search bar in the `SuperSideScroller_Brick` class.'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Brick`文件夹内*右键单击*并选择`Blueprint Class`。在`SuperSideScroller_Brick`类中的`All Classes`搜索栏中。
- en: Name this new Blueprint `BP_Brick`, and then *double-left-click* the asset to
    open it.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新的蓝图命名为`BP_Brick`，然后*双击左键*资产以打开它。
- en: Select the `BrickMesh` component from the `Static Mesh` parameter to the `Shape_Cube`
    mesh.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Static Mesh`参数选择`BrickMesh`组件到`Shape_Cube`网格。
- en: With the `BrickMesh` component still selected, set the `Element 0` material
    parameter to `M_Brick_Clay_Beveled`. This material is provided by Epic Games by
    default when creating a new project. It can be found within the `StarterContent`
    directory, in the **Content Drawer** area.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在仍然选择`BrickMesh`组件的情况下，将`Element 0`材质参数设置为`M_Brick_Clay_Beveled`。这个材质是Epic Games在创建新项目时默认提供的。它可以在`StarterContent`目录下的**内容抽屉**区域找到。
- en: The last thing we need to do with the `BrickMesh` component is adjust its scale
    so that it fits the needs of the player character, as well as the platforming
    mechanics of the **SuperSideScroller** game project.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用`BrickMesh`组件做的最后一件事是调整其比例，使其符合玩家角色的需求，以及**SuperSideScroller**游戏项目的平台跳跃机制。
- en: 'With the `BrickMesh` component selected, make the following change to its `Scale`
    parameter:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`BrickMesh`组件的情况下，对其`Scale`参数进行以下更改：
- en: '[PRE69]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now that the `BrickMesh` component is `75%` of its normal size, the `Brick`
    actor will become more manageable for us as designers when we place the actor
    into the game world, as well as when we’re developing interesting platforming
    sections within the level.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`BrickMesh`组件的大小是正常大小的`75%`，当我们将演员放置到游戏世界中，以及当我们在这个关卡内开发有趣的平台跳跃部分时，`Brick`演员对我们设计师来说将更容易管理。
- en: The final step here is to update the location of the `BrickCollision` component
    so that it only has some of its collision sticking out from the bottom of the
    `BrickMesh` component.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的最后一步是更新`BrickCollision`组件的位置，使其只有部分碰撞从`BrickMesh`组件的底部突出。
- en: 'Select the `BrickCollision` component from the `Location` parameter to the
    following values:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Location`参数选择`BrickCollision`组件到以下值：
- en: '[PRE70]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `BrickCollision` component should now be positioned as follows:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`BrickCollision`组件现在应定位如下：'
- en: '![Figure 15.29 – Now, the BrickCollision component is just barely outside the
    BrickMesh component ](img/Figure_15.29_B18531.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![图15.29 – 现在，BrickCollision组件刚刚超出BrickMesh组件之外](img/Figure_15.29_B18531.jpg)'
- en: Figure 15.29 – Now, the BrickCollision component is just barely outside the
    BrickMesh component
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.29 – 现在，BrickCollision组件刚刚超出BrickMesh组件之外
- en: We are making this adjustment to the position of the `BrickCollision` component
    so that the player can only hit `UBoxComponent` when jumping underneath the brick.
    By making it slightly outside of the `BrickMesh` component, we can control it
    better and ensure that this component cannot be hit by the player in any other
    way.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`BrickCollision`组件的位置进行了调整，以便玩家只能在跳到砖块下方时击中`UBoxComponent`。通过将其稍微放在`BrickMesh`组件的外面，我们可以更好地控制它，并确保这个组件不会被玩家以其他方式击中。
- en: Note
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the assets and code for this exercise here: [https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.07](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.07).'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到这个练习的资源和代码：[https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.07](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.07)。
- en: With this exercise complete, you were able to create the base framework for
    the `SuperSideScroller_Brick` class and put together the Blueprint actor to represent
    the brick in the game world. By adding a cube mesh and brick material, you added
    a nice visual polish to the brick. In the following exercise, you will add the
    remaining C++ logic to the brick. This will allow the player to destroy the brick
    and obtain a collectible.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你能够创建`SuperSideScroller_Brick`类的基框架，并将蓝图演员组合起来以在游戏世界中代表砖块。通过添加立方网格和砖块材质，你为砖块增添了美观的视觉效果。在接下来的练习中，你将为砖块添加剩余的C++逻辑。这将允许玩家摧毁砖块并获得可收集物品。
- en: Exercise 15.08 – adding the Brick class’s C++ logic
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.08 – 添加砖块类的C++逻辑
- en: 'In the previous exercise, you created the base framework for the `SuperSideScroller_Brick`
    class by adding the necessary components and creating the `BP_Brick` Blueprint
    actor. In this exercise, you will add on top of the C++ code of *Exercise 15.07
    – creating the Brick class*, to grant logic to the `Brick` class. This will allow
    the brick to give players coin collectibles. Perform the following steps to accomplish
    this:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，你通过添加必要的组件并创建`BP_Brick`蓝图演员来为`SuperSideScroller_Brick`类创建基框架。在这个练习中，你将在*练习15.07
    – 创建砖块类*的C++代码基础上添加逻辑，以赋予`Brick`类功能。这将允许砖块为玩家提供金币收集物品。按照以下步骤完成此任务：
- en: 'To begin, we need to create a function that will add the collectible to the
    player. Add the following function declaration to the `SuperSideScroller_Brick.h`
    header file, under our `Private Access Modifier`:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个函数，将收集物品添加到玩家。在`SuperSideScroller_Brick.h`头文件中，在`Private Access Modifier`下添加以下函数声明：
- en: '[PRE71]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We want to pass in a reference to the `SuperSideScroller_Player` class so that
    we can call the `IncrementNumberofCollectables()` function from that class.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望传递`SuperSideScroller_Player`类的引用，以便我们可以从该类中调用`IncrementNumberofCollectables()`函数。
- en: 'Next, create a void function declaration called `PlayHitSound()` under our
    `Private Access Modifier`:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Private Access Modifier`下创建一个名为`PlayHitSound()`的void函数声明：
- en: '[PRE72]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `PlayHitSound()` function will be responsible for spawning the `HitSound`
    property you created in *Exercise 15.07 – creating the Brick class*.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayHitSound()`函数将负责生成你在*练习15.07 – 创建砖块类*中创建的`HitSound`属性。'
- en: 'Finally, create another void function declaration called `PlayHitExplosion()`
    under our `Private Access Modifier`:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`Private Access Modifier`下创建另一个名为`PlayHitExplosion()`的void函数声明：
- en: '[PRE73]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `PlayHitExplosion()` function will be responsible for spawning the `Explosion`
    property you created in *Exercise 15.07 – creating the Brick class*.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayHitExplosion()`函数将负责生成你在*练习15.07 – 创建砖块类*中创建的`Explosion`属性。'
- en: With the remaining functions needed for the `SuperSideScroller_Brick` class
    declared in the header file, let’s move on and define these functions inside the
    source file.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中声明了`SuperSideScroller_Brick`类所需的剩余函数后，让我们继续在源文件中定义这些函数。
- en: 'At the top of the `SuperSideScroller_Brick.cpp` source file, add the following
    `#include` statements to the list of `#include` directories that already exist
    for this class:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SuperSideScroller_Brick.cpp`源文件顶部，将以下`#include`语句添加到已存在的此类的`#include`目录列表中：
- en: '[PRE74]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The includes for the `World` and `GameplayStatics` classes are necessary to
    spawn both the `HitSound` and the `Explosion` effects for the brick. Including
    the `SuperSideScroller_Player` class is required to make the call to the `IncrementNumberofCollectables()`
    class function.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the function definition for the `AddCollectable()` function.
    Add the following code:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, make the call to the `IncrementNumberofCollectables()` function by using
    the `Player` function input parameter:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'For the `PlayHitSound()` function, you will need to get a reference to the
    `UWorld*` object and verify whether the `HitSound` property is valid before making
    the function call to `SpawnSoundAtLocation` from the `UGameplayStatics` class.
    This is a process you have done many times, so this is the entire function code:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Just like the `PlayHitSound()` function, the `PlayHitExplosion()` function
    will work in an almost similar way, and it’s a process you have done many times
    in this project. Add the following code to create the function definition:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: With these functions defined, let’s update the `OnHit()` function so that if
    the player does hit the `BrickCollision` component, we can spawn `HitSound` and
    `Explosion`, and also add a coin collectible to the player’s collection.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in the `OnHit()` function, create a new variable called `Player` of
    the `ASuperSideScroller_Player` type that equals `Cast` of the `OtherActor` input
    parameter of the function, as shown here:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next, we only want to continue with this function if `Player` is valid and
    `bHasCollectable` is `True`. Add the following `if()` statement:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If the conditions in the `if()` statement are met, that is when we need to
    make the calls to the `AddCollectable()`, `PlayHitSound()`, and `PlayHitExplosion()`
    functions. Make sure to also pass the `Player` variable inside the `AddCollectable()`
    function:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, add the function call to destroy the brick inside the `if()` statement:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: With the `OnHit()` function defined as we need, recompile the C++ code but do
    not return to the UE5 editor just yet.
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the VFX and SFX of the brick’s explosion, we will need to migrate assets
    from two separate projects available to us from **Epic Games Launcher**: the **Blueprints**
    project and the **Content Examples** project.'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using your knowledge from previous exercises, download and install these projects
    using Unreal Engine version 4.24\. Both projects can be found in the **Samples**
    tab, in the **UE Legacy Samples** and **UE Feature Samples** categories, respectively.
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once installed, open the `P_Pixel_Explosion` asset in the **Content Drawer**
    area.
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* this asset and select **Asset Actions**, then **Migrate**. Migrate
    this asset and all its referenced assets into your **SuperSideScroller** project.'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once this asset has been successfully migrated, close the `Blueprints` project.
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Blueprints` project, find the `Blueprints_TextPop01` asset.
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* this asset, then select **Asset Actions**, and then **Migrate**.
    Migrate this asset and all its referenced assets into your **SuperSideScroller**
    project.'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these assets migrated to your project, return to the Unreal Engine 5 editor
    of your **SuperSideScroller** project.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `Brick` folder in the `BP_Brick` asset to open it.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `HitSound` parameter to the `Blueprints_TextPop01` soundwave you imported.
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add the `P_Pixel_Explosion` particle you imported into the `Explosion`
    parameter.
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recompile the `BP_Brick` Blueprint and add two of these actors to your level.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set one of the bricks so that the `bHasCollectable` parameter is `True`; set
    the other to `False`. Please refer to the following screenshot:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.30 – This Brick actor is set to have a collectible spawn ](img/Figure_15.30_B18531.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
- en: Figure 15.30 – This Brick actor is set to have a collectible spawn
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `PIE`, observe the differences in behavior between the two brick actors
    when you attempt to hit the bottom of the brick with the character’s head when
    jumping, as shown in the following screenshot:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.31 – Now, the player can hit the brick and it will be destroyed
    ](img/Figure_15.31_B18531.jpg)'
  id: totrans-564
  prefs: []
  type: TYPE_IMG
- en: Figure 15.31 – Now, the player can hit the brick and it will be destroyed
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: When `bHasCollectable` is `True`, `SuperSideScroller_Brick` will play our `HitSound`,
    spawn the `Explosion` particle system, add a coin collectible to the player, and
    be destroyed.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the assets and code for this exercise here: [https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.08](https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter15/Exercise15.08).'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise complete, you have now finished developing the gameplay mechanics
    for the `SuperSideScroller_Brick` class can be used for both the platforming gameplay
    and the coin-collecting mechanic that we want for the game.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Now that the brick can be destroyed and hidden coins can be collected, all the
    gameplay elements that we set out to create for the **SuperSideScroller** game
    project are complete.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you put your knowledge to the test to create the remaining
    gameplay mechanics for the **SuperSideScroller** game project. Using a combination
    of C++ and Blueprints, you developed the potion power-up and coins for the player
    to collect in the level. Also, by using your knowledge from [*Chapter 14*](B18531_14.xhtml#_idTextAnchor298),
    *Spawning the Player Projectile*, you added unique audio and visual assets to
    these collectible items to add a nice layer of polish to the game.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: You learned and took advantage of the UMG UI system within UE5 to create a simple,
    yet effective, UI feedback system to display the number of coins that the player
    has collected. By using the binding feature of the `Brick` class using the knowledge
    you learned from the **SuperSideScroller** project to hide coins for the player
    so that they can collect and find them.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了并利用了UE5中的UMG UI系统来创建一个简单而有效的UI反馈系统，显示玩家收集到的硬币数量。通过使用`Brick`类的绑定功能，结合你在**SuperSideScroller**项目中学到的知识来隐藏硬币，以便玩家可以收集和找到它们。
- en: The `Animation State Machine` to handle the jumping and movement states of the
    player character. We then learned how to control the player’s movement and jump
    height using the character movement component.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Animation State Machine`来处理玩家角色的跳跃和移动状态。然后，我们学习了如何使用角色移动组件来控制玩家的移动和跳跃高度。
- en: In [*Chapter 12*](B18531_12.xhtml#_idTextAnchor247), *Animation Blending and
    Montages*, we learned more about animation blending inside `Animation Blueprints`
    by using the `Layered Blend per Bone` function and `Saved Cached Poses`. By adding
    a new `AnimSlot` for the upper body animation of the player character’s throw
    animation, we were able to have both the player movement animations and the throw
    animation blend together smoothly. In [*Chapter 13*](B18531_13.xhtml#_idTextAnchor268),
    *Creating and Adding the Enemy Artificial Intelligence*, we used the robust systems
    of behavior trees and Blackboards to develop AI behavior for the enemy. We created
    a `Task` that will allow the enemy AI to move in-between points from a custom
    Blueprint that we also developed to determine patrol points for the AI.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B18531_12.xhtml#_idTextAnchor247)，“动画混合和蒙太奇”，我们通过使用`Layered Blend
    per Bone`功能和`Saved Cached Poses`在`Animation Blueprints`中学习了更多关于动画混合的知识。通过为玩家角色投掷动画的上半身动画添加一个新的`AnimSlot`，我们能够使玩家移动动画和投掷动画平滑地混合在一起。在[*第13章*](B18531_13.xhtml#_idTextAnchor268)，“创建和添加敌人人工智能”，我们使用了行为树和黑板的强大系统来开发敌人的AI行为。我们创建了一个`Task`，允许敌人AI在自定义蓝图（我们同样开发）中移动，该蓝图用于确定AI的巡逻点。
- en: In [*Chapter 14*](B18531_14.xhtml#_idTextAnchor298), *Spawning the Player Projectile*,
    we learned how to create an `Anim Notify` and how to implement this notify in
    our `Animation Montage` for the player character’s throw to spawn the player projectile.
    Then, we learned about how to create projectiles and how to use **Projectile Movement
    Component** to have the player projectile move in the game world.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第14章*](B18531_14.xhtml#_idTextAnchor298)，“生成玩家投射物”，我们学习了如何创建一个`Anim Notify`以及如何在玩家的`Animation
    Montage`中实现这个通知，以便在玩家角色投掷时生成玩家投射物。然后，我们学习了如何创建投射物以及如何使用**投射物移动组件**使玩家投射物在游戏世界中移动。
- en: Finally, in this chapter, we learned how to create UI using the `UMG` toolset
    for the coin collectible, as well as how to manipulate our `Brick` class that
    can be used to hide coins for the player to find and collect.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在本章中，我们学习了如何使用`UMG`工具集创建用于收集硬币的UI，以及如何操作我们的`Brick`类，该类可以用来隐藏硬币供玩家寻找和收集。
- en: In the next chapter, you will learn about the basics of multiplayer, server-client
    architectures, and the gameplay framework classes used for multiplayer inside
    UE5\. You will use this knowledge to expand upon the multiplayer FPS project in
    UE5.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于多玩家、服务器-客户端架构以及UE5中用于多玩家的游戏框架类的基础知识。你将使用这些知识来扩展UE5中的多玩家FPS项目。
- en: 'This summarization only really scratches the surface of what we learned and
    accomplished in the **SuperSideScroller** project. Before you move on, here are
    some challenges for you to test your knowledge and expand upon the project:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这份总结仅仅只是触及了我们**SuperSideScroller**项目中学习和取得的成就的表面。在你继续前进之前，这里有一些挑战供你测试你的知识并扩展这个项目：
- en: Additional Challenges
  id: totrans-580
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外挑战
- en: Test your knowledge from this section by adding the following functionality
    to the SuperSideScroller project.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向SuperSideScroller项目中添加以下功能来测试你从本节学到的知识。
- en: Add a new power-up that lowers the gravity that’s applied to the player character.
    Import a custom mesh and audio assets to give this power-up a unique look compared
    to the potion power-up you made.
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的增益，降低施加给玩家角色的重力。导入自定义网格和音频资源，使这个增益与制作的药水增益有独特的视觉效果。
- en: When the player character collects 10 coins, grant the player a power-up.
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家角色收集到10个硬币时，授予玩家一个增益。
- en: Implement the functionality that allows the player to be destroyed when it’s
    overlapping with the AI. Include being able to respawn the player when this happens.
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现当玩家与AI重叠时可以摧毁玩家的功能。包括当这种情况发生时能够重新生成玩家。
- en: Add another power-up that gives immunity to the player so that they cannot be
    destroyed when they’re overlapping with an enemy. (In fact, when overlapping an
    enemy with this power-up, it could destroy the enemy.)
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个增强道具，使玩家获得免疫力，这样当他们与敌人重叠时就不会被摧毁。（实际上，当使用这个增强道具与敌人重叠时，它可能会摧毁敌人。）
- en: Using all the gameplay elements you’ve developed for the **SuperSideScroller**
    project, create a new level that takes advantage of these elements to make an
    interesting platforming arena to play in.
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用为**SuperSideScroller**项目开发的全部游戏元素，创建一个新关卡，利用这些元素制作一个有趣的平台竞技场进行游戏。
- en: Add multiple enemies with interesting patrol points to challenge the player
    when they’re navigating the area.
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加多个具有有趣巡逻点的敌人，当玩家在区域中导航时挑战他们。
- en: Place power-ups in hard-to-reach areas so that players need to improve their
    platforming skills to obtain them.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将增强道具放置在难以到达的区域，这样玩家就需要提高他们的平台跳跃技能来获取它们。
- en: Create dangerous pitfalls for the player to navigate across and add functionality
    that will destroy the player if they fall off the map.
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为玩家创建危险的陷阱，让他们在地图上穿越，并添加如果玩家掉落地图就会摧毁他们的功能。
