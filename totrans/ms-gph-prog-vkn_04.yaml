- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing a Frame Graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are introducing **frame graphs**, a new system to control
    the rendering steps for a given frame. As the name implies, we are going to organize
    the steps (passes) required to render a frame in a **Directed Acyclic Graph**
    (**DAG**). This will allow us to determine the order of execution of each pass
    and which passes can be executed in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a graph also provides us with many other benefits, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows us to automate the creation and management of render passes and frame
    buffers, as each pass defines the input resources it will read from and which
    resources it will write to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps us reduce the memory required for a frame with a technique called **memory
    aliasing**. We can determine how long a resource will be in use by analyzing the
    graph. After the resource is no longer needed, we can reuse its memory for a new
    resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we’ll be able to let the graph manage the insertion of memory barriers
    and layout transitions during its execution. Each input and output resource defines
    how it will be used (texture versus attachment, for instance), and we can infer
    its next layout with this information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In summary, in this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the structure of a frame graph and the details of our implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a topological sort to make sure the passes execute in the right
    order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the graph to drive rendering and automate resource management and layout
    transitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter4](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter4).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding frame graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the rendering in the Raptor Engine has consisted of one pass only. While
    this approach has served us well for the topics we have covered, it won’t scale
    for some of the later chapters. More importantly, it wouldn’t be representative
    of how modern rendering engines organize their work. Some games and engines implement
    hundreds of passes, and having to manually manage them can become tedious and
    error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we decided this was a good time in the book to introduce a frame graph.
    In this section, we are going to present the structure of our graph and the main
    interfaces to manipulate it in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the basic concepts of a graph.
  prefs: []
  type: TYPE_NORMAL
- en: Building a graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we present our solution and implementation for the frame graph, we would
    like to provide some of the building blocks that we are going to use throughout
    the chapter. If you’re familiar with frame graphs, or graphs in general, feel
    free to skim through this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A graph is defined by two elements: **nodes** (or vertices) and **edges**.
    Each node can be connected to one or more nodes, and each connection is defined
    by an edge.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – An edge from node A to B](img/B18395_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – An edge from node A to B
  prefs: []
  type: TYPE_NORMAL
- en: 'In the introduction of this chapter, we mentioned that a frame graph is a DAG.
    It’s important that our frame graph has these properties as otherwise, we wouldn’t
    be able to execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directed**: This means that the edges have a direction. If, for instance,
    we define an edge to go from node *A* to node *B*, we can’t use the same edge
    to go from *B* to *A*. We would need a different edge to go from *B* to *A*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Connecting A to B and B to A in a directed graph](img/B18395_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Connecting A to B and B to A in a directed graph
  prefs: []
  type: TYPE_NORMAL
- en: '**Acyclic**: This means that there can’t be any cycles in the graph. A cycle
    is introduced when we can go back to a given node after following the path from
    one of its children. If this happens, our frame graph will enter an infinite loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.3 – An example of a graph containing a cycle](img/B18395_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – An example of a graph containing a cycle
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a frame graph, each node represents a rendering pass: depth
    prepass, g-buffer, lighting, and so on. We don’t define the edges explicitly.
    Instead, each node will define a number of outputs and, if needed, a number of
    inputs. An edge is then implied when the output of a given pass is used as input
    in another pass.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – An example of a full frame graph](img/B18395_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – An example of a full frame graph
  prefs: []
  type: TYPE_NORMAL
- en: These two concepts, nodes and edges, are all that is needed to understand a
    frame graph. Next, we are going to present how we decided to encode this data
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: A data-driven approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some engines only provide a code interface to build a frame graph, while others
    let developers specify the graph in a human-readable format – JSON for example
    – so that making changes to the graph doesn’t necessarily require code changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'After some consideration, we have decided to define our graph in JSON and implement
    a parser to instantiate the classes required. There are a few reasons we opted
    for this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows us to make some changes to the graph without having to recompile the
    code. If, for instance, we want to change the size or format of a render target,
    all we have to do is make the change in the JSON definition of the graph and rerun
    the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also reorganize the graph and remove some of its nodes without making
    changes to the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s easier to understand the flow of the graph. Depending on the implementation,
    the definition of the graph in code could be spread across different code locations
    or even different files. This makes it harder to determine the graph structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s easier for non-technical contributors to make changes. The graph definition
    could also be done through a visual tool and translated into JSON. The same approach
    wouldn’t be feasible if the graph definition was done purely in code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now have a look at a node in our frame graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A node is defined by three variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This helps us identify the node during execution, and it also gives
    us a meaningful name for other elements, for instance, the render pass associated
    with this node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inputs`: This lists the inputs for this node. These are resources that have
    been produced by another node. Note that it would be an error to define an input
    that has not been produced by another node in the graph. The only exceptions are
    external resources, which are managed outside the render graph, and the user will
    have to provide them to the graph at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outputs`: These are the resources produced by a given node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have defined four different types of resources depending on their use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`attachment`: The list of attachments is used to determine the render pass
    and framebuffer composition of a given node. As you noticed in the previous example,
    attachments can be defined both for inputs and outputs. This is needed to continue
    working on a resource in multiple nodes. After we run a depth prepass, for instance,
    we want to load the depth data and use it during the g-buffer pass to avoid shading
    pixels for objects that are hidden behind other objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`texture`: This type is used to distinguish images from attachments. An attachment
    has to be part of the definition of the render pass and framebuffer for a node,
    while a texture is read during the pass and is part of a shader data definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This distinction is also important to determine which images need to be transitioned
    to a different layout and require an image barrier. We’ll cover this in more detail
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to specify the size and format of the texture here, as we had
    already done so when we first defined the resource as an output.
  prefs: []
  type: TYPE_NORMAL
- en: '`buffer`: This type represents a storage buffer that we can write to or read
    from. As with textures, we will need to insert memory barriers to ensure the writes
    from a previous pass are completed before accessing the buffer data in another
    pass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reference`: This type is used exclusively to ensure the right edges between
    nodes are computed without creating a new resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All types are quite intuitive, but we feel that the reference type deserves
    an example to better understand why we need this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this case, lighting is an input resource of the `attachment` type. When processing
    the graph, we will correctly link the node that produced the lighting resource
    to this node. However, we also need to make sure that the next node that makes
    use of the lighting resource creates a connection to this node, as otherwise,
    the node ordering would be incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we add a reference to the lighting resource in the output of
    the transparent pass. We can’t use the `attachment` type here as otherwise, we
    would double count the lighting resource in the creation of the render pass and
    framebuffer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a good understanding of the frame graph structure, it’s time
    to look at some code!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the frame graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to define the data structures that are going to
    be used throughout the chapter, namely resources and nodes. Next, we are going
    to parse the JSON definition of the graph to create resources and nodes that will
    be used for subsequent steps.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the definition of our data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Resources** define an input or an output of a node. They determine the use
    of the resource for a given node and, as we will explain later, they are used
    to define edges between the frame graph nodes. A resource is structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A resource can be either an input or an output of a node. It’s worth going
    through each field in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type`: Defines whether we are dealing with an image or a buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource_info`: Contains the details about the resource (such as size, format,
    and so on) based on `type`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`producer`: Stores a reference to the node that outputs a resource. This will
    be used to determine the edges of the graph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output_handle`: Stores the parent resource. It will become clearer later why
    we need this field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ref_count`: Will be used when computing which resources can be aliased. Aliasing
    is a technique that allows multiple resources to share the same memory. We will
    provide more details on how this works later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: Contains the name of the resource as defined in JSON. This is useful
    for debugging and also to retrieve the resource by name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we are going to look at a graph node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A node stores the list of inputs it will use during execution and the outputs
    it will produce. Each input and output is a different instance of `FrameGraphResource`.
    The `output_handle` field is used to link an input to its output resource. We
    need separate resources because their type might differ; an image might be used
    as an output attachment and then used as an input texture. This is an important
    detail that will be used to automate memory barrier placement.
  prefs: []
  type: TYPE_NORMAL
- en: A node also stores a list of the nodes it is connected to, its name, the framebuffer,
    and the render pass created according to the definition of its inputs and outputs.
    Like resources, a node also stores its name as defined on JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a node contains a pointer to the rendering implementation. We’ll discuss
    later how we link a node to its rendering pass.
  prefs: []
  type: TYPE_NORMAL
- en: These are the main data structures used to define our frame graph. We have also
    created a `FrameGraphBuilder` helper class that will be used by the `FrameGraph`
    class. The `FrameGraphBuilder` helper class contains the functionality to create
    nodes and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how these building blocks are used to define our frame graph!
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have defined the data structures that make our graph, we need to
    parse the JSON definition of the graph to fill those structures and create our
    frame graph definition. Here are the steps that need to be executed to parse the
    frame graph:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by initializing a `FrameGraphBuilder` and `FrameGraph` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we call the `parse` method to read the JSON definition of the graph and
    create the resources and nodes for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have our graph definition, we have our compile step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This step is where the magic happens. We analyze the graph to compute the edges
    between nodes, create the framebuffer and render passes for each class, and determine
    which resources can be aliased. We are going to explain each of these steps in
    detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have compiled our graph, we need to register our rendering passes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows us to test different implementations for each pass by simply swapping
    which class we register for a given pass. It’s even possible to swap these passes
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are ready to render our scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are now going to look at the `compile` and `render` methods in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing topological sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned in the preceding section, the most interesting aspects of the
    frame graph implementation are inside the `compile` method. We have abbreviated
    some of the code for clarity in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the GitHub link mentioned in the *Technical requirements* section
    of the chapter for the full implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a breakdown of the algorithm that we use to compute the edges between
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step we perform is to create the edges between nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We accomplish this by iterating through each input and retrieving the corresponding
    output resource. Note that internally, the graph stores the outputs in a map keyed
    by name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we save the details of the output in the input resource. This way we
    have direct access to this data in the input as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we create an edge between the node that produces this input and the
    node we are currently processing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the end of this loop, each node will contain the list of nodes it is connected
    to. While we currently don’t do this, at this stage, it would be possible to remove
    nodes that have no edges from the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have computed the connection between nodes, we can sort them in
    topological order. At the end of this step, we will obtain the list of nodes ordered
    to ensure that nodes that produce an output come before the nodes that make use
    of that output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a breakdown of the sorting algorithm where we have highlighted the
    most relevant sections of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sorted_node` array will contain the sorted nodes in reverse order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `visited` array will be used to mark which nodes we have already processed.
    We need to keep track of this information to avoid infinite loops:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the `stack` array is used to keep track of which nodes we still have
    to process. We need this data structure as our implementation doesn’t make use
    of recursion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The graph is traversed by using **depth-first search** (**DFS**). The code
    that follows performs exactly this task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We iterate through each node and add it to the stack. We do this to ensure
    we process all the nodes in the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then have a second loop that will be active until we have processed all
    nodes that are connected to the node we just added to the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If a node has already been visited and added to the list of sorted nodes, we
    simply remove it from the stack and continue processing other nodes. Traditional
    graph processing implementations don’t have this step.
  prefs: []
  type: TYPE_NORMAL
- en: We had to add it as a node might produce multiple outputs. These outputs, in
    turn, might link to multiple nodes, and we don’t want to add the producing node
    multiple times to the sorted node list.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the node we are currently processing has already been visited and we got
    to it in the stack, it means we processed all of its children, and it can be added
    to the list of sorted nodes. As mentioned in the following code, we also mark
    it as added so that we won’t add it multiple times to the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we first get to a node, we mark it as `visited`. As mentioned in the following
    code block, this is needed to make sure we don’t process the same node multiple
    times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the node we are processing has no edges, we continue to iterate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On the other hand, if the node is connected to other nodes, we add them to the
    stack for processing and then iterate again. If this is the first time you’ve
    seen an iterative implementation of graph traversal, it might not be immediately
    clear how it relates to the recursive implementation. We suggest going through
    the code a few times until you understand it; it’s a powerful technique that will
    come in handy at times!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step is to iterate through the sorted nodes array and add them to
    the graph nodes in reverse order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now completed the topological sorting of the graph! With the nodes sorted,
    we can now proceed to analyze the graph to identify which resources can be aliased.
  prefs: []
  type: TYPE_NORMAL
- en: Computing resource aliasing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Large frame graphs must deal with hundreds of nodes and resources. The lifetime
    of these resources might not span the full graph, and this gives us an opportunity
    to reuse memory for resources that are no longer needed. This technique is called
    **memory aliasing**, as multiple resources can point to the same memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – An example of resource lifetime across the frame](img/B18395_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – An example of resource lifetime across the frame
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we can see that the `gbuffer_colour` resource is not needed
    for the full frame, and its memory can be reused, for instance, for the `final`
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: We first need to determine the first and last nodes that use a given resource.
    Once we have the information, we can determine whether a given node can reuse
    existing memory for its resources. The code that follows implements this technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by allocating a few helper arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: They are not strictly needed by the algorithm, but they are helpful for debugging
    and ensuring our implementation doesn’t have a bug. The `allocations` array will
    track on which node a given resource was allocated.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `deallocations` array contains the node at which a given resource
    can be deallocated. Finally, `free_list` will contain the resources that have
    been freed and can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to look at the algorithm that tracks the allocations and
    deallocations of resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we loop through all the input resources and increase their reference
    count each time they are used as input. We also mark which node allocates the
    resource in the `allocations` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to iterate through all the nodes and their outputs. The code
    that follows is responsible for performing the memory allocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: For each output resource, we first check whether there are any available resources
    that can be reused. If so, we pass the free resource to the `TextureCreation`
    structure. Internally, `GpuDevice` will use the memory from this resource and
    bind it to the newly created resource. If no free resources are available, we
    proceed by creating a new resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the loop takes care of determining which resources can be
    freed and added to the free list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We iterate over the inputs one final time and decrease the reference count of
    each resource. If the reference count reaches `0`, it means this is the last node
    that uses the resource. We save the node in the `deallocations` array and add
    the resource to the free list, ready to be used for the next node we are going
    to process.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the implementation of the graph analysis. The resources we have
    created are used to create the `framebuffer` object, at which point the graph
    is ready for rendering!
  prefs: []
  type: TYPE_NORMAL
- en: We are going to cover the execution of the graph in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Driving rendering with the frame graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the graph has been analyzed, we have all the details we need for rendering.
    The following code is responsible for executing each node and ensuring all the
    resources are in the correct state for use by that node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We first iterate through all the inputs of a node. If the resource is a texture,
    we insert a barrier to transition that resource from an attachment layout (for
    use in a render pass) to a shader stage layout (for use in a fragment shader).
  prefs: []
  type: TYPE_NORMAL
- en: 'This step is important to make sure any previous writes have completed before
    we access this resource for reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Next, we iterate over the outputs of the node. Once again, we need to make sure
    the resource is in the correct state to be used as an attachment in the render
    pass. After this step, our resources are ready for rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The render targets of each node could all have different resolutions. The following
    code ensures that our scissor and viewport sizes are correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the viewport and scissor are set correctly, we call the `pre_render` method
    on each node. This allows each node to perform any operations that must happen
    outside a render pass. For instance, the render pass for the depth-of-field effect
    takes the input texture and computes the MIP maps for that resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we bind the render pass for this node, call the `render` method of
    the rendering pass that we registered for this node, and end the loop by ending
    the render pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'This concludes the code overview for this chapter! We have covered a lot of
    ground; this is a good time for a brief recap: we started with the definition
    of the main data structures used by our frame graph implementation. Next, we explained
    how the graph is parsed to compute the edges between nodes by using inputs and
    outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: Once this step is completed, we can sort the nodes in topological order to ensure
    they are executed in the correct order. We then create the resources needed to
    execute the graph and make use of memory aliasing to optimize memory usage. Finally,
    we iterate over each node for rendering, making sure that all resources are in
    the correct state for that node.
  prefs: []
  type: TYPE_NORMAL
- en: There are some features that we haven’t implemented and that could improve the
    functionality and robustness of our frame graph. For example, we should ensure
    there are no loops in the graph and that an input isn’t being produced by the
    same node it’s being used in.
  prefs: []
  type: TYPE_NORMAL
- en: For the memory aliasing implementation, we use a greedy approach and simply
    pick the first free resource that can accommodate a new resource. This can lead
    to fragmentation and suboptimal use of memory.
  prefs: []
  type: TYPE_NORMAL
- en: We encourage you to experiment with the code and improve on it!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented a frame graph to improve the management of rendering
    passes and make it easier to expand our rendering pipeline in future chapters.
    We started by covering the basic concepts, nodes and edges, that define a graph.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we gave an overview of the structure of our graph and how it’s encoded
    in JSON format. We also mentioned why we went for this approach as opposed to
    defining the graph fully in code.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part, we detailed how the graph is processed and made ready for
    execution. We gave an overview of the main data structures used for the graph,
    and covered how the graph is parsed to create nodes and resources, and how edges
    are computed. Next, we explained the topological sorting of nodes, which ensures
    they are executed in the correct order. We followed that with the memory allocation
    strategy, which allows us to reuse memory from resources that are no longer needed
    at given nodes. Finally, we provided an overview of the rendering loop and how
    we ensure that resources are in the correct state for rendering.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to take advantage of the techniques we have
    developed in the last two chapters. We are going to leverage multithreading and
    our frame graph implementation to demonstrate how to use compute and graphics
    pipelines in parallel for cloth simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our implementation has been heavily inspired by the implementation of a frame
    graph in the Frostbite engine, and we recommend watching this presentation: [https://www.gdcvault.com/play/1024045/FrameGraph-Extensible-Rendering-Architecture-in](https://www.gdcvault.com/play/1024045/FrameGraph-Extensible-Rendering-Architecture-in).'
  prefs: []
  type: TYPE_NORMAL
- en: Many other engines implement a frame graph to organize and optimize their rendering
    pipeline. We encourage you to look at other implementations and find the solution
    that best fits your needs!
  prefs: []
  type: TYPE_NORMAL
