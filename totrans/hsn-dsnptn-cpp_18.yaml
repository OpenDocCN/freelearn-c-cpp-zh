- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Patterns for Concurrency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发模式
- en: The last chapter is dedicated to a set of patterns for use in concurrent programs.
    Concurrency and C++ have a somewhat complex relationship. On the one hand, C++
    is a performance-oriented language, and concurrency is almost always employed
    to improve performance, so the two are a natural fit. Certainly, C++ was used
    to develop concurrent programs since the earliest days of the language. On the
    other hand, for a language so often used for writing concurrent programs, C++
    has a surprising dearth of constructs and features that directly address the needs
    of concurrent programming. These needs are mostly addressed by a wide range of
    community-developed libraries and, often, application-specific solutions. In this
    chapter, we will review common problems encountered in the development of concurrent
    programs and solutions that emerged from years of experience; together, these
    are the two sides of a design pattern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章专门介绍了一组用于并发程序的模式。并发与C++之间有一种相当复杂的关系。一方面，C++是一种以性能为导向的语言，并发几乎总是被用来提高性能，因此两者是自然匹配的。当然，C++从语言最早的时候就开始被用来开发并发程序了。另一方面，对于经常被用来编写并发程序的语言来说，C++在直接解决并发编程需求的结构和特性方面却出奇地缺乏。这些需求主要是由广泛的社区开发的库以及通常针对特定应用的解决方案来满足的。在本章中，我们将回顾在并发程序开发中遇到的常见问题以及多年经验中出现的解决方案；这些共同构成了设计模式的两面。
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: What is the state of concurrency support in C++?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中并发支持的现状如何？
- en: What are the main challenges of concurrency?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发的挑战主要有哪些？
- en: The challenges of data synchronization and the C++ tools to meet them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据同步的挑战以及C++工具如何应对这些挑战
- en: What is the design for concurrency?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发的设计是怎样的？
- en: What are common patterns for managing concurrent workloads in C++?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中管理并发工作负载的常见模式有哪些？
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The example code for this chapter can be found on GitHub at the following link:
    [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter18](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter18).
    Also, basic knowledge of concurrency in general as well as concurrency support
    in C++ are a pre-requisite.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在GitHub上找到，链接如下：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter18](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter18)。此外，对并发的一般知识和C++中的并发支持也是先决条件。
- en: C++ and concurrency
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++与并发
- en: The concept of concurrency was introduced into the language in C++11, but concurrent
    programs were written in C++ long before that. This chapter is not meant to be
    an introduction to concurrency or even an introduction to concurrency in C++.
    This subject is well-covered in the literature (at the time of publication of
    this book, one of the works that are both general and up-to-date is the book *C++
    Concurrency in Action* by Anthony Williams). Also, while concurrency is almost
    always used to improve performance, we will not directly address performance and
    optimization issues here; for that, you can refer to my book *The Art of Writing
    Efficient Programs*. We are going to focus on the problems that arise in the design
    of concurrent software.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 并发的概念是在C++11中引入到语言中的，但并发程序在那时之前就已经用C++编写了。本章的目的不是介绍并发，甚至也不是介绍C++中的并发。这个主题在文献中已经得到了很好的覆盖（在本书出版时，一本既全面又更新的作品是Anthony
    Williams的《C++并发实战》）。此外，虽然并发几乎总是用来提高性能，但在这里我们不会直接讨论性能和优化问题；对于这些问题，你可以参考我的书《编写高效程序的技艺》。我们将专注于并发软件设计中出现的问题。
- en: There are, broadly speaking, three types of challenges we encounter when developing
    concurrent programs. First, how to make sure the program is correct even when
    multiple threads operate on the same data concurrency? Second, how to execute
    the work of a program on multiple threads to improve the overall performance?
    Finally, how to design software in a way that allows us to reason about it, understand
    its functions, and maintain it, all with the added complexity of concurrency.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发并发程序时，从广义上讲，我们会遇到三种类型的挑战。首先，如何在多个线程同时操作同一数据的情况下确保程序的正确性？其次，如何通过多线程执行程序的工作来提高整体性能？最后，如何设计软件，使其能够让我们对其进行分析、理解其功能以及维护它，同时还要考虑到并发的复杂性。
- en: 'The first set of challenges broadly relates to data sharing and synchronization.
    We will examine the related patterns first: the program must be first and foremost
    correct, and great performance in a program that crashes or produces results that
    cannot be trusted is useless.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组挑战主要与数据共享和同步相关。我们将首先检查相关的模式：程序首先必须是正确的，在一个崩溃或产生不可信结果的程序中实现高性能是毫无用处的。
- en: Synchronization patterns
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步模式
- en: 'Synchronization patterns have one overarching purpose: to ensure correct operations
    on data shared by multiple threads. These patterns are critically important for
    the absolute majority of concurrent programs. The only programs that do not have
    any need for synchronization are the ones that execute several entirely independent
    tasks that do not involve any common data (except for, possibly, reading shared
    and immutable inputs) and produce separate results. For every other program, there
    is a need to manage some shared state, which exposes us to the danger of the dreaded
    data races. Formally, the C++ standard says that concurrent access to the same
    object (same memory location) without the appropriate synchronization that guarantees
    exclusive access for each thread results in undefined behavior. To be precise,
    the behavior is undefined if at least one thread can modify the shared data: if
    the data is never changed by any thread, then there is no possibility of a data
    race. There are design patterns that take advantage of that loophole, but let
    us start with the most widely known synchronization pattern. What comes to mind
    first when you hear about avoiding data races?'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 同步模式有一个总的目标：确保多个线程共享的数据的正确操作。这些模式对于绝大多数并发程序至关重要。唯一不需要同步的程序是那些执行几个完全独立的任务且不涉及任何公共数据（除了可能读取共享的不可变输入）并产生单独结果的程序。对于其他所有程序，都需要管理一些共享状态，这使我们面临可怕的数据竞争的风险。正式来说，C++标准指出，如果没有适当的同步来保证每个线程的独占访问，则对同一对象（同一内存位置）的并发访问会导致未定义行为。更精确地说，如果至少有一个线程可以修改共享数据，则行为是未定义的：如果数据从未被任何线程更改，则不可能发生数据竞争。有一些设计模式利用了这个漏洞，但让我们从最广为人知的同步模式开始。当你听到避免数据竞争时，首先想到的是什么？
- en: Mutex and locking patterns
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互斥锁和锁定模式
- en: 'If there is one tool for writing concurrent programs, it is a mutex. A mutex
    is used to guarantee exclusive access to the shared data accessed by multiple
    threads:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个用于编写并发程序的工具，那就是互斥锁。互斥锁用于保证多个线程访问共享数据时的独占访问：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The data-modifying operation `transmogrify()` must be guaranteed exclusive
    access to the shared data: only one thread may do this operation at any given
    time. The programmer uses a `lock()` and `unlock()`).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数据修改操作 `transmogrify()` 必须保证对共享数据的独占访问：在任何给定时间只能有一个线程执行此操作。程序员使用 `lock()` 和
    `unlock()`。
- en: 'The use of a mutex is sufficient to ensure correct access to the shared data,
    but this is hardly a good design. The first issue is that it is error-prone: if
    `transmogrify()` throws an exception, or if the programmer adds a check for the
    return value and exits the critical section early, the final `unlock()` is never
    executed and the mutex remains locked forever, thus blocking every other thread
    from ever accessing the data.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用互斥锁足以确保对共享数据的正确访问，但这几乎不是一个好的设计。第一个问题是它容易出错：如果 `transmogrify()` 抛出异常，或者如果程序员添加了对返回值的检查并提前退出关键部分，最终的
    `unlock()` 永远不会执行，互斥锁将永远锁定，从而阻止其他任何线程访问数据。
- en: 'This challenge is easily addressed by a particular application of the very
    general C++ pattern we have already seen in [*Chapter 5*](B19262_05.xhtml#_idTextAnchor199),
    *A Comprehensive Look at RAII*. All we need is an object to lock and unlock the
    mutex, and the C++ standard library already provides one, `std::lock_guard`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战可以通过对我们在 [*第5章*](B19262_05.xhtml#_idTextAnchor199) 中已经看到的非常通用的C++模式的一种特定应用来轻松解决，即
    *全面审视RAII*。我们需要的只是一个用于锁定和解锁互斥锁的对象，而C++标准库已经提供了一个，`std::lock_guard`：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The function `add()` modifies the shared variable `i` and, therefore, needs
    exclusive access; this is provided by the use of the mutex `m`. Note that if you
    run this example without the mutex, chances are you will get the correct result
    nonetheless because one of the threads will execute before the other. Sometimes
    the program will fail, and more often it won’t. This doesn’t make it correct,
    it just makes it hard to debug. You can see the race condition with the help of
    the `--sanitize=address` to enable it. Remove the mutex from `add()` (*Example
    02*), compile with TSAN, run the program, and you will see this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`add()`修改共享变量`i`，因此需要独占访问；这是通过使用互斥量`m`来实现的。请注意，如果你在没有互斥量的情况下运行此示例，你仍然可能会得到正确的结果，因为其中一个线程会在另一个线程之前执行。有时程序会失败，而更多的时候则不会。这并不意味着它是正确的，只是使得调试变得困难。你可以通过使用`--sanitize=address`来启用它，并使用`add()`中的互斥量（*示例
    02*），用TSAN编译，运行程序，你将看到以下内容：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There is a lot more information shown to help you figure out which threads have
    a data race and for which variable. This is a far more reliable way to test for
    data races than waiting for your program to fail.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了更多信息，以帮助您确定哪些线程存在数据竞争以及对于哪个变量。这是一种比等待程序失败更可靠的测试数据竞争的方法。
- en: 'In C++17, the use of `std::lock_guard` is slightly simpler since the compiler
    figures out the template argument from the constructor:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，使用`std::lock_guard`稍微简单一些，因为编译器会从构造函数中推断模板参数：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In C++20, we can use `std::jthread` instead of calling `join()` explicitly:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20中，我们可以使用`std::jthread`来代替显式调用`join()`：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that care must be taken to destroy the threads before using the result
    of the computation since the destructor now joins the thread and waits for the
    calculation to complete. Otherwise, there is another data race: the main thread
    is reading the value of `i` while it is being incremented (TSAN finds this race
    as well).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在使用计算结果之前必须小心地销毁线程，因为析构函数现在会连接线程并等待计算完成。否则，将存在另一个数据竞争：主线程在`i`值被增加时正在读取它的值（TSAN也会发现这个竞争）。
- en: The use of RAII ensures that every time a mutex is locked it is also unlocked,
    but this does not avoid other errors that can happen when using mutexes. The most
    common one is forgetting to use the mutex in the first place. The synchronization
    guarantees apply only if every thread uses the same mechanism to ensure exclusive
    access to the data. If even one thread does not use the mutex, even if it’s only
    to read the data, then the entire program is incorrect.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: RAII的使用确保每次锁定互斥量时都会解锁，但这并不能避免在使用互斥量时可能发生的其他错误。最常见的一个是忘记最初使用互斥量。同步保证仅适用于每个线程都使用相同的机制来确保对数据的独占访问。如果甚至有一个线程没有使用互斥量，即使只是读取数据，那么整个程序都是不正确的。
- en: 'A pattern was developed to prevent unsynchronized access to the shared. This
    pattern usually goes by the name “mutex-guarded” or “mutex-protected” and it has
    two key elements: first, the data that needs to be protected and the mutex that
    is used to do so are combined in the same object. Second, the design ensures that
    every access to the data is protected by the mutex. Here is the basic mutex-guarded
    class template:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 开发了一种模式来防止对共享数据的未同步访问。这个模式通常被称为“互斥量保护”或“互斥量保护”，它有两个关键元素：首先，需要保护的数据和用于此目的的互斥量被组合在同一个对象中。其次，设计确保对数据的每次访问都由互斥量保护。以下是一个基本的互斥量保护类模板：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, this template combines the mutex and the data guarded by it,
    and offers only one way to access the data: by invoking the `MutexGuarded` object
    with an arbitrary callable. This ensures that all data accesses are synchronized:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此模板将互斥量和它所保护的数据结合起来，并只提供一种访问数据的方式：通过使用任意可调用对象调用`MutexGuarded`对象。这确保了所有数据访问都是同步的：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These are the most basic versions of the patterns for the correct and reliable
    use of mutexes. In practice, the needs are often more complex, and so are the
    solutions: there are much more efficient locks than `std::mutex` (for example,
    spinlocks for guarding short computations, which you can find in my book *The
    Art of Writing Efficient Programs*), and there are also more complex locks such
    as shared and exclusive locks for efficient read-write access. Also, often we
    have to operate on several shared objects at the same time, which leads to the
    problem of safely locking multiple mutexes. Many of these problems are solved
    by more complex variations of the patterns we have just seen. Some call for an
    entirely different approach to the synchronization of data accesses, and we will
    see several of those later in this section. Finally, some data access challenges
    are better solved at a much higher level of the overall system design; this will
    also be illustrated in this chapter.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是正确和可靠使用互斥锁模式的最基本的版本。在实践中，需求通常更为复杂，因此解决方案也是如此：有比`std::mutex`更高效的锁（例如，用于保护短计算的自旋锁，你可以在我的书《编写高效程序的艺术》中找到），还有更复杂的锁，如共享锁和独占锁，用于高效的读写访问。此外，我们通常需要同时操作多个共享对象，这导致了安全锁定多个互斥锁的问题。许多这些问题都是通过我们刚刚看到的模式的更复杂变体来解决的。有些需要完全不同的数据访问同步方法，我们将在本节后面看到这些方法。最后，一些数据访问挑战在整体系统设计的更高层次上解决更好；这一点也将在本章中展示。
- en: Let us next review different approaches to data sharing that go beyond the commonly
    used mutex.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来回顾一下超越常用互斥锁的数据共享的不同方法。
- en: No sharing is the best sharing
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不共享是最好的共享
- en: While protecting shared data with a mutex does not seem that complicated, in
    reality, data races are the most common bugs in any concurrent program. While
    it may seem a useless truism to state that you cannot have data races accessing
    data you do not share, not sharing is a frequently overlooked alternative to sharing.
    To put it another way, it is often possible to redesign a program to avoid sharing
    some of the variables or to restrict access to shared data to a smaller part of
    the code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用互斥锁来保护共享数据看起来并不复杂，但实际上，数据竞争是任何并发程序中最常见的错误。虽然声称你不能访问你不共享的数据以避免数据竞争可能看似一个无用的真理，但事实上，不共享是共享的一个经常被忽视的替代方案。换句话说，通常可以重新设计程序以避免共享某些变量，或者将共享数据的访问限制在代码的较小部分。
- en: 'This idea is the basis of a design pattern that is simple to explain but often
    hard to apply because it requires thinking outside of the box – the thread-specific
    data pattern. It is also known as “thread-local data,” but the name invites confusion
    with the C++ `thread_local` keyword. To illustrate the idea, we consider this
    example: we need to count certain events that may be happening in multiple threads
    simultaneously (for this demonstration, it does not matter what is counted). We
    need the total count of these events in the entire program, so the straightforward
    approach is to have a shared count and increment it when a thread detects an event
    (in the demonstration, we count random numbers divisible by 10):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是设计模式的基础，这种模式容易解释但往往难以应用，因为它需要跳出思维定势——线程特定数据模式。它也被称为“线程局部数据”，但这个名字容易与C++的`thread_local`关键字混淆。为了说明这个想法，我们考虑以下示例：我们需要计算可能在多个线程同时发生的事件（在这个演示中，计数的内容并不重要）。我们需要整个程序中这些事件的累计计数，所以直接的方法是有一个共享计数，当线程检测到事件时（在演示中，我们计算能被10整除的随机数）：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a straightforward design; it is not the best one. Notice that while
    each thread is counting events, it does not need to know how many events were
    counted by other threads. This is not to be confused with the fact that, in our
    implementation, each thread needs to know what the current value of the count
    is so it can correctly increment it. The distinction is subtle but important and
    suggests an alternative: each thread can count its own events using a thread-specific
    count, one for each thread. None of these counts are correct, but it doesn’t matter
    as long as we can add all counts together when we need the correct total event
    count. There are several possible designs here. We can use a local count for the
    events and update the shared count once before the thread exits:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个直接的设计；它不是最好的。注意，虽然每个线程都在计数事件，但它不需要知道其他线程计数了多少事件。这并不与我们的实现中每个线程需要知道当前计数值以便正确增加它的这一事实相混淆。这种区别很微妙但很重要，并暗示了一个替代方案：每个线程可以使用线程特定的计数来计数它自己的事件，每个线程一个。这些计数都不正确，但只要我们能在需要正确的总事件计数时将所有计数相加，那就没关系了。这里有几个可能的设计。我们可以为事件使用局部计数，并在线程退出之前更新一次共享计数：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Any local (stack-allocated) variable declared in a function that is being executed
    by one or more threads is specific to each thread: there is a unique copy of this
    variable on the stack of each thread, and each thread accesses its own variable
    when they all refer to the same name `n`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个或多个线程正在执行其函数时声明的任何局部（栈分配）变量都是特定于每个线程的：每个线程的栈上都有一个唯一的变量副本，并且当它们都引用相同的名称 `n`
    时，每个线程访问它自己的变量。
- en: 'We could also give each thread a unique count variable to increment and add
    them together in the main thread after all the counting threads are finished:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以给每个线程提供一个唯一的计数变量来增加，并在所有计数线程完成后在主线程中将它们相加：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When calling this counting function on multiple threads, we have to take some
    precautions. Obviously, we should give each thread its own variable for the count
    `n`. This is not enough: due to the hardware-related effect known as “false sharing,”
    we must also ensure that the thread-specific counts are not adjacent in memory
    (a detailed description of false sharing can be found in my book *The Art of Writing*
    *Efficient Programs*):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个线程上调用这个计数函数时，我们必须采取一些预防措施。显然，我们应该给每个线程自己的计数变量 `n`。这还不够：由于称为“伪共享”的硬件相关效应，我们还必须确保线程特定的计数在内存中不是相邻的（有关伪共享的详细描述可以在我的书
    *《编写高效程序的艺术》* 中找到）：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `alignas` attribute ensures 64-byte alignment for each count variable, thus
    ensuring that there is at least 64 bytes difference between the addresses of `n1`
    and `n2` (64 is the size of the cache line on most modern CPUs, including X86
    and ARM). Note the `std::ref` wrapper that is needed for `std::thread` to invoke
    functions that use reference arguments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`alignas` 属性确保每个计数变量有 64 字节的对齐，从而确保 `n1` 和 `n2` 的地址之间至少有 64 字节的区别（64 是大多数现代
    CPU（包括 X86 和 ARM）的缓存行大小）。注意，对于 `std::thread` 来调用使用引用参数的函数，需要 `std::ref` 包装器。'
- en: The previous example reduces the need for shared data access to once per thread,
    while the last one does not have any shared data at all; the preferred solution
    depends on exactly when is the value of the total count needed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个例子将共享数据访问的需求减少到每个线程一次，而最后一个例子则完全没有共享数据；首选的解决方案取决于总计数值何时需要。
- en: 'The last example can be examined from a slightly different point of view; it
    would help to slightly rewrite it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子可以从一个稍微不同的角度来审视；稍微重写它会有所帮助：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This does not change anything of substance, but we can view the thread-specific
    counts as parts of the same data structure rather than independent variables created
    for each thread. This way of thinking leads us to another variant of the thread-specific
    data pattern: sometimes, multiple threads must operate on the same data, but it
    may be possible to partition the data and give each thread its own subset to work
    on.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有改变任何实质性的东西，但我们可以将线程特定的计数视为同一数据结构的一部分，而不是为每个线程创建的独立变量。这种思维方式引导我们到达线程特定数据模式的另一个变体：有时，多个线程必须操作相同的数据，但可能可以将数据分区，并给每个线程分配它自己的子集来工作。
- en: 'In the next example, we need to clamp each element in the vector (if an element
    exceeds the maximum value, it is replaced by this value, so the result is always
    in the range between zero and the maximum). The computation is implemented by
    this templated algorithm:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们需要对向量中的每个元素进行clamp操作（如果一个元素超过最大值，它将被替换为这个值，因此结果总是在零和最大值之间）。计算是通过以下模板算法实现的：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A production-quality implementation would ensure that the iterator arguments
    satisfy the iterator requirements and the maximum value is comparable with the
    iterator value type, but we omit all that for brevity (we had an entire chapter
    on concepts and other ways to restrict templates).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个生产质量的实现将确保迭代器参数满足迭代器要求，并且最大值可以与迭代器值类型进行比较，但我们为了简洁起见省略了所有这些（我们有一个关于概念和其他限制模板方法的整个章节）。
- en: 'The `clamp()` function can be called on any sequence, and sometimes we will
    be lucky to have separate unrelated data structures we can process independently
    on multiple threads. But to continue this example, let us say that we have only
    one vector we need to clamp. All is not lost, however, as we can process non-overlapping
    parts of it on multiple threads with no risk of data races:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`clamp()` 函数可以在任何序列上调用，有时我们可能会幸运地有可以独立在多个线程上处理的不同且无关的数据结构。但是，为了继续这个例子，让我们假设我们只有一个需要clamp的向量。然而，情况并非全无希望，因为我们可以在没有数据竞争风险的情况下，在多个线程上处理它的非重叠部分：'
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Even though the data structure in our program is shared between two threads
    and both threads modify it, this program is correct: for each vector element,
    there is only one thread that can modify it. But what about the vector object
    itself? Isn’t it shared between all threads?'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们程序中的数据结构在两个线程之间是共享的，并且两个线程都对其进行修改，但这个程序是正确的：对于每个向量元素，只有一个线程可以修改它。但是，向量对象本身呢？它不是在所有线程之间共享的吗？
- en: 'We have already highlighted that there is one case when data sharing is allowed
    without any synchronization: any number of threads can read the same variable
    as long as no other thread is modifying it. Our example takes advantage of this:
    all threads read the size of the vector and other data members of the vector object,
    but no threads change them.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经强调，有一种情况允许数据共享而不需要任何同步：只要没有其他线程正在修改它，任意数量的线程都可以读取相同的变量。我们的例子就利用了这一点：所有线程都读取向量的大小和其他向量对象的成员变量，但没有线程修改它们。
- en: 'The application of the thread-specific data pattern must be carefully thought
    through and often requires a good understanding of the data structures. We must
    be absolutely certain that none of the threads attempt to modify the variables
    they do share, such as the size and the pointer to the data that are members of
    the vector object itself. For example, if one of the threads could resize the
    vector, that would be a data race even if no two threads access the same element:
    the size of the vector is a variable that is modified by one or more threads without
    a lock.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 线程特定数据模式的运用必须经过仔细思考，通常需要很好地理解数据结构。我们必须绝对确信没有任何线程试图修改它们共享的变量，例如向量对象本身的成员变量的大小和指针。例如，如果某个线程可以调整向量的大小，即使没有两个线程访问相同的元素，这也会成为数据竞争：向量的大小是一个变量，它被一个或多个线程修改，但没有加锁。
- en: 'The last pattern we want to describe in this subsection applies when several
    threads need to modify the entire data set (so it cannot be partitioned) but the
    threads do not need to see the modifications done by other threads. Usually, this
    happens when the modifications are done as a part of the computation of some result,
    but the modified data itself is not the final result. In this case, sometimes
    the best approach is to create a thread-specific copy of the data for each thread.
    This pattern works best when such copy is a “throw-away” object: each thread needs
    to modify its copy but the result of the modifications does not need to be committed
    back to the original data structure.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们想要描述的最后一种模式适用于多个线程需要修改整个数据集（因此不能分区）但不需要看到其他线程所做的修改的情况。通常，这种情况发生在修改作为某些结果计算的一部分时，但修改后的数据本身不是最终结果。在这种情况下，有时最好的方法是为每个线程创建一个线程特定的数据副本。这种模式在副本是“一次性”对象时效果最好：每个线程都需要修改其副本，但修改的结果不需要提交回原始数据结构。
- en: 'In the following example, we use an algorithm to count unique elements in a
    vector that sorts the vector in place:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用一个算法来计算向量中唯一元素的数量，该算法在原地排序向量：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Also, when we need to count only elements that satisfy a predicate, we erase
    all other elements first (`std::erase_if` is a C++20 addition, but is easy to
    implement in a prior version of C++):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们只需要计数满足某个谓词的元素时，我们首先删除所有其他元素（`std::erase_if` 是 C++20 的新增功能，但在 C++ 的早期版本中也很容易实现）：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Both are destructive operations on a vector, but they are only means to an
    end: the altered vector can be discarded once we have our count. The simplest,
    and often the most efficient, way to compute our counts on several threads simultaneously
    is to make thread-specific copies of the vector. Actually, we did this already:
    both counting functions take the vector argument by value and, therefore, make
    a copy. Usually, this would be a mistake, but in our case, it is intentional and
    allows both functions to operate on the same vector concurrently:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种操作都是对向量的破坏性操作，但它们只是达到目的的手段：一旦我们得到了计数，就可以丢弃修改后的向量。在多个线程上同时计算我们的计数的最简单、通常也是最高效的方法是创建向量的线程特定副本。实际上，我们已经这样做了：这两个计数函数都是通过值传递向量参数，因此会创建一个副本。通常，这会是一个错误，但在这个情况下，这是故意的，并且允许这两个函数同时操作同一个向量：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Of course, there is still concurrent access to the original data, and it is
    done without a lock: both threads need to make their thread-specific copies. However,
    this falls under the exception of read-only concurrent access and is safe.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仍然存在对原始数据的并发访问，并且没有使用锁：两个线程都需要创建它们的线程特定副本。然而，这属于只读并发访问的例外情况，是安全的。
- en: In principle, avoiding data sharing when possible and using mutexes otherwise
    is sufficient to arrange race-free access to data in any program. However, this
    may not be an efficient way to accomplish this goal, and good performance is almost
    always the goal of concurrency. We will now consider several other patterns for
    concurrent access to shared data that, when applicable, can offer superior performance.
    We are going to start with synchronization primitives that go beyond a mutex and
    are specifically designed to allow threads to efficiently wait for some event.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从原则上讲，尽可能避免数据共享，在必要时使用互斥锁，就足以在任何程序中安排无竞争的数据访问。然而，这可能不是实现这一目标的最有效方式，而良好的性能几乎总是并发的目标。现在，我们将考虑几种其他用于并发访问共享数据的模式，当适用时，可以提供更好的性能。我们将从比互斥锁更高级的同步原语开始，这些原语专门设计用来允许线程高效地等待某些事件。
- en: Waiting patterns
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待模式
- en: 'Waiting is a problem that is frequently encountered in concurrent programs
    and takes many forms. We have already seen one: the mutex. Indeed, if two threads
    are trying to enter the critical section simultaneously, one of them will have
    to wait. But waiting is not the goal here, just an unfortunate side effect of
    exclusive access to the critical section. There are other situations where waiting
    is the primary objective. For example, we may have threads that are waiting for
    some event to happen. This could be a user interface thread waiting for input
    (little to no performance requirements) or a thread waiting on a network socket
    (moderate performance requirements) or even a high-performance thread such as
    a computing thread in a thread pool waiting for a task to execute (extremely high
    performance requirements). Not surprisingly, there are different implementations
    for these scenarios, but fundamentally there are two approaches: polling and notifications.
    We are going to look at notifications first.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 等待是并发程序中经常遇到的问题，它有多种形式。我们已经看到了一个：互斥锁。确实，如果有两个线程试图同时进入临界区，其中一个将不得不等待。但在这里，等待并不是目标，只是对临界区独占访问的不幸副作用。还有其他情况下，等待是主要目标。例如，我们可能有等待某些事件发生的线程。这可能是一个用户界面线程等待输入（性能要求很低）或等待网络套接字的线程（性能要求适中）或甚至是一个高性能线程，如线程池中的计算线程等待执行任务（性能要求极高）。不出所料，这些场景有不同的实现，但基本上有两种方法：轮询和通知。我们将首先探讨通知。
- en: The basic pattern for waiting for a notification is the **condition pattern**.
    It usually consists of a condition variable and a mutex. One or more threads are
    blocked waiting on the condition variable. During this time, there is one more
    thread that locks the mutex (thus guaranteeing exclusive access) and does the
    work whose completion the other threads are waiting for. Once the work is done,
    the thread that completed it must release the mutex (so other threads can access
    the shared data containing the results of this work) and notify the waiting threads
    that they can proceed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 等待通知的基本模式是**条件模式**。它通常由一个条件变量和一个互斥锁组成。一个或多个线程被阻塞等待条件变量。在这段时间里，还有一个线程锁定互斥锁（从而保证独占访问）并执行其他线程等待完成的工作。一旦工作完成，完成工作的线程必须释放互斥锁（这样其他线程就可以访问包含此工作结果的共享数据）并通知等待的线程它们可以继续。
- en: For example, in a thread pool, the waiting threads are the pool worker threads
    that are waiting for tasks to be added to the pool. Since the pool task queue
    is a shared resource, a thread needs exclusive access to push or pop tasks. A
    thread that adds one or more tasks to the queue must hold the mutex while doing
    it and then notify the worker threads that there are tasks for them to execute.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个线程池中，等待的线程是等待将任务添加到池中的池工作线程。由于池任务队列是一个共享资源，一个线程需要独占访问来推送或弹出任务。向队列添加一个或多个任务的线程必须在执行此操作时持有互斥锁，然后通知工作线程有任务要执行。
- en: 'Let us now see a very basic example of the notification pattern with just two
    threads. First, we have the main thread that starts a worker thread and then waits
    for it to produce some results:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个只有两个线程的非常基本的示例，说明通知模式。首先，我们有主线程，它启动一个工作线程，然后等待它产生一些结果：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The locking in this case is provided by `std::unique_lock`, an object that wraps
    around a mutex and has a mutex-like interface with `lock()` and `unlock()` member
    functions. The mutex is locked in the constructor and almost immediately unlocked
    by the `wait()` function when we start waiting on the condition. When the notification
    is received, `wait()` locks the mutex again before returning control to the caller.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，锁定是由`std::unique_lock`提供的，这是一个围绕互斥锁包装的对象，具有类似互斥锁的接口，具有`lock()`和`unlock()`成员函数。互斥锁在构造函数中被锁定，并在我们开始等待条件时几乎立即由`wait()`函数解锁。当接收到通知时，`wait()`在返回控制权给调用者之前再次锁定互斥锁。
- en: 'Many implementations of waiting and conditions suffer from what is known as
    spurious wake-up: wait can be interrupted even without notification. This is why
    we also check whether the results are ready, in our case, by checking the result
    count `n`: if it is still zero, there are no results, the main thread has been
    awakened in error and we can go back to waiting (note that the waiting thread
    must still acquire the mutex before `wait()` returns, so it must wait for the
    worker thread to release this mutex).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 许多等待和条件的实现都存在所谓的虚假唤醒问题：即使没有通知，等待也可以被中断。这就是为什么我们还要检查结果是否准备好，在我们的例子中，通过检查结果计数`n`：如果它仍然是零，则没有结果，主线程被错误唤醒，我们可以回到等待状态（注意，等待线程必须在`wait()`返回之前获取互斥锁，因此它必须等待工作线程释放这个互斥锁）。
- en: 'The worker thread must lock the same mutex before it can access the shared
    data, then unlock it before notifying the main thread that the work is done:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程在访问共享数据之前必须锁定相同的互斥锁，然后在通知主线程工作已完成之前解锁它：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It is not necessary to hold the mutex the entire time the worker thread is
    active: its only purpose is to protect the shared data such as the result count
    `n` in our example.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作线程活跃的整个时间内没有必要一直持有互斥锁：它的唯一目的是保护共享数据，例如我们例子中的结果计数`n`。
- en: The two synchronization primitives `std::conditional_variable` and `std::unique_lock`
    are standard C++ tools for implementing the waiting pattern with a condition.
    Just as with a mutex, there are many variations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 两个同步原语`std::conditional_variable`和`std::unique_lock`是标准C++工具，用于实现带有条件的等待模式。就像互斥锁一样，有许多变体。
- en: 'The alternative to notifications is polling. In this pattern, the waiting thread
    repeatedly checks whether some condition is met. In C++20, we can implement a
    simple example of polling wait using `std::atomic_flag` which is essentially an
    atomic boolean variable (prior to C++20 we could do the same with `std::atomic<bool>`):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通知的替代方法是轮询。在这个模式中，等待的线程反复检查是否满足某些条件。在C++20中，我们可以使用`std::atomic_flag`实现一个简单的轮询等待示例，它本质上是一个原子布尔变量（在C++20之前，我们可以用`std::atomic<bool>`做同样的事情）：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Atomic operations such as `test_and_set()` make use of **memory barriers**:
    a kind of global synchronization flag that ensures that all changes made to the
    memory before the flag is set (release) are visible to any operation on any other
    thread that is executed after the flag is tested (acquire). There is a lot more
    to these barriers, but it is outside of the scope of this book and can be found
    in many books dedicated to concurrency and efficiency.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作，例如 `test_and_set()`，利用**内存屏障**：一种全局同步标志，确保在设置（释放）该标志之前对内存所做的所有更改都对在标志测试（获取）之后执行的任何其他线程上的任何操作可见。关于这些屏障还有很多内容，但这些都超出了本书的范围，可以在许多关于并发和效率的书中找到。
- en: 'The most important difference between this and the previous example is the
    explicit polling loop for the waiting thread in *Example 12*. If the wait is long,
    this is highly inefficient since the waiting thread is busy computing (reading
    from memory) the entire time it waits. Any practical implementation would introduce
    some sleep into the wait loop, but doing so also comes at a cost: the waiting
    thread will not wake up immediately after the worker thread sets the flag but
    must finish the sleep first. These efficiency concerns are outside of the scope
    of this book; here we want to show the overall structure and the components of
    these patterns.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个示例相比，最重要的区别是等待线程在*示例12*中的显式轮询循环。如果等待时间很长，这会非常低效，因为等待线程在整个等待过程中都在忙于计算（从内存中读取）。任何实际实现都会在等待循环中引入一些睡眠，但这样做也会付出代价：等待线程不会在工作者线程设置标志后立即唤醒，而必须先完成睡眠。这些效率问题超出了本书的范围；在这里，我们想展示这些模式的整体结构和组件。
- en: 'The boundary between polling and waiting is not always clear. For example,
    for all we know, `wait()` could be implemented by polling some internal state
    of the condition variable periodically. In fact, the same atomic flag we just
    saw can be used to wait for a notification:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询和等待之间的界限并不总是清晰的。例如，据我们所知，`wait()` 可能是通过定期轮询条件变量的某些内部状态来实现的。实际上，我们刚才看到的相同的原子标志可以用来等待通知：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The call to `wait()` requires a corresponding call to `notify_one()` (or `notify_all()`
    if we have more than one thread waiting on the flag). Its implementation is almost
    certainly more efficient than our simple polling loop. After the notification
    is received and the wait is over, we check the flag to make sure it was really
    set. The standard says that this is not necessary and `std::atomic_flag::wait()`
    does not suffer from spurious wakeups, but TSAN in both GCC and Clang disagree
    (this could be a false positive in TSAN or a bug in the standard library implementation).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `wait()` 的调用需要一个相应的 `notify_one()`（或如果有多个线程在等待该标志，则为 `notify_all()`）调用。它的实现几乎肯定比我们的简单轮询循环更高效。在接收到通知并结束等待后，我们检查标志以确保它确实被设置了。标准说这不是必要的，`std::atomic_flag::wait()`
    不会遭受虚假唤醒，但GCC和Clang中的TSAN都不同意（这可能是TSAN中的假阳性或标准库实现中的错误）。
- en: 'There are many other situations where waiting is needed, and the conditions
    we need to wait for vary widely. Another common need is to wait for a certain
    number of events to occur. For example, we may have several threads producing
    results and we may need all of them to complete their share of the work before
    the main thread can proceed. This is accomplished by waiting on a barrier or a
    latch. Prior to C++20, we would need to implement these synchronization primitives
    ourselves or use a third-party library, but in C++20 they became standard:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他情况下需要等待，而我们需要等待的条件各不相同。另一个常见的需求是等待一定数量的事件发生。例如，我们可能有几个线程在生成结果，我们可能需要它们在主线程继续之前完成它们的工作份额。这是通过在屏障或闩锁上等待来实现的。在C++20之前，我们需要自己实现这些同步原语或使用第三方库，但在C++20中它们已成为标准：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The latch is initialized with the count of events to wait for. It will unlock
    when that many `count_down()` calls have been done.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 闩锁初始化为等待事件的数量。当完成这么多 `count_down()` 调用后，它将解锁。
- en: There are many other applications of waiting, but almost all waiting patterns
    fall broadly into one of the categories we have seen in this section (a specific
    implementation can have a dramatic effect on performance in a particular case,
    which is you are far more likely to see custom application-specific versions of
    these synchronization constructs than you are to find non-standard containers
    or other basic data structures).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 等待有许多其他应用，但几乎所有的等待模式都可以大致分为本节中我们看到的一种类别（特定实现可能会对特定情况下的性能产生显著影响，因此你更有可能看到这些同步构造的特定应用版本，而不是非标准容器或其他基本数据结构）。
- en: We are now going to see several examples of very specialized and very efficient
    synchronization patterns. They are not for all situations, but when they fit the
    need, they often offer the best performance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到几个非常专业且非常高效的同步模式的例子。它们并不适用于所有情况，但当它们符合需求时，它们通常提供最佳性能。
- en: Lock-free synchronization patterns
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无锁同步模式
- en: 'Most of the time, safely accessing shared data relies on mutexes. C++ also
    supports another type of synchronizing concurrent threads: atomic operations.
    Again, a detailed explanation is outside of the scope of this book, and this section
    requires some prior knowledge of the atomics.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，安全访问共享数据依赖于互斥锁。C++还支持另一种同步并发线程的类型：原子操作。同样，详细的解释超出了本书的范围，本节需要一些关于原子的先验知识。
- en: 'The basic idea is this: some data types (usually integers) have special hardware
    instructions that allow a few simple operations such as reading or writing or
    incrementing the values to be done atomically, in a single event. During this
    atomic operation, other threads cannot access the atomic variable at all, so if
    one thread performs an atomic operation, all other threads can see the same variable
    as it was before the operation or after the operation but not in the middle of
    the operation. For example, an increment is a read-modify-write operation, but
    an atomic increment is a special hardware transaction such that once the read
    began, no other thread can access the variable until the write completes. These
    atomic operations are often accompanied by memory barriers; we have used them
    already to ensure that not just atomic but all other operations on all variables
    in the program are synchronized and free from data races.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是这样的：一些数据类型（通常是整数）有特殊的硬件指令，允许一些简单的操作，如读取、写入或增加值以原子方式执行，在单个事件中完成。在原子操作期间，其他线程根本无法访问原子变量，因此如果一个线程执行原子操作，所有其他线程都可以看到操作前后相同的变量，但不能在操作过程中看到。例如，增加是一个读取-修改-写入操作，但原子增加是一个特殊的硬件事务，一旦读取开始，其他线程就无法访问变量，直到写入完成。这些原子操作通常伴随着内存屏障；我们已经在程序中使用了它们，以确保不仅仅是原子操作，所有其他操作都是同步的，并且没有数据竞争。
- en: 'The simplest but useful application of atomic operations is for counting. We
    often need to count something in programs, and in concurrent programs, we may
    need to count some events that can occur on multiple threads. If we are only interested
    in the total count after all threads are done, this is best handled by the “non-sharing”
    or thread-specific counter we saw earlier. But what if all threads need to know
    the current count as well? We can always use a mutex, but using a mutex to protect
    a simple increment of an integer is highly inefficient. C++ gives us a better
    way, the atomic counter:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作最简单但有用的应用是计数。我们经常需要在程序中计数，在并发程序中，我们可能需要计数在多个线程上可能发生的一些事件。如果我们只对所有线程完成后的事件总数感兴趣，这最好由我们之前看到的“非共享”或线程特定的计数器来处理。但如果有所有线程都需要知道当前计数的情况呢？我们总是可以使用互斥锁，但使用互斥锁来保护一个整数的简单增加是非常低效的。C++为我们提供了一种更好的方法，即原子计数器：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There is only one shared variable in this example, `count` itself. Since we
    do not have any other shared data, we have no need for memory barriers (“relaxed”
    memory order means there are no requirements on the order of accesses to other
    data). The `fetch_add()` operation is an atomic increment, it increments `count`
    by one and returns the old value of `count`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中只有一个共享变量，即`count`本身。由于我们没有其他共享数据，所以我们不需要内存屏障（“宽松”内存顺序意味着对其他数据的访问顺序没有要求）。`fetch_add()`操作是一个原子增加操作，它将`count`增加1并返回`count`的旧值。
- en: 'The atomic count can also be used to let multiple threads work on the same
    data structure without any need for locking: to do this, we need to make sure
    there is only one thread working on each element of the data structure. When used
    in this manner, the pattern is often referred to as the atomic index. In the next
    example, we have an array of data that is shared between all threads:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 原子计数也可以用来让多个线程在无需加锁的情况下对同一数据结构进行操作：为此，我们需要确保只有一个线程在处理数据结构中的每个元素。以这种方式使用时，该模式通常被称为原子索引。在下一个示例中，我们有一个所有线程共享的数据数组：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We also have an atomic index that is used by all threads that need to store
    the results of their work in the array. To do so safely, each thread increments
    an atomic index and used the pre-increment value as the index into the array.
    No two atomic increment operations can produce the same value, therefore, each
    thread gets its own array elements to work on:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个原子索引，由所有需要将工作结果存储在数组中的线程使用。为了安全地这样做，每个线程都会增加一个原子索引，并使用预增量值作为数组的索引。由于没有两个原子增量操作会产生相同的值，因此每个线程都会得到自己的数组元素来处理：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Each thread gets to initialize however many array elements it can and stops
    when it (and all other threads) fill the entire array. The main thread has to
    wait until all the work is done before accessing any of the results. This cannot
    be done with just the atomic index since it is incremented when a thread starts
    working on a particular array element, not when that thread is done with the work.
    We have to use some other synchronization mechanism to make the main thread wait
    until all the work is done, such as a latch or, in a simple case, joining the
    producer threads:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程可以初始化尽可能多的数组元素，并在它（以及所有其他线程）填满整个数组时停止。主线程必须等待所有工作完成才能访问任何结果。仅使用原子索引是无法做到这一点的，因为它是当线程开始处理特定数组元素时增加的，而不是当线程完成工作后。我们必须使用其他同步机制来使主线程等待直到所有工作完成，例如一个闩锁，或者在简单情况下，将生产者线程连接起来：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The atomic count is good when we don’t rely on the value of the count to access
    the results that are already produced. In the last example, the producer threads
    did not need access to the array elements computed by other threads, and the main
    thread waits for all threads to complete before accessing the results. Often,
    this is not the case and we need to access data as it is being produced. This
    is where memory barriers come in.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不依赖于计数值来访问已生成的结果时，原子计数是好的。在上一个示例中，生产者线程不需要访问其他线程计算出的数组元素，主线程在访问结果之前等待所有线程完成。通常情况下并非如此，我们需要在数据生成过程中访问数据。这就是内存屏障发挥作用的地方。
- en: 'The simplest but surprisingly powerful lock-free pattern that relies on memory
    barriers is known as the publishing protocol. The pattern is applicable when one
    thread is producing some data that is going to be made accessible to one or more
    other threads when it is ready. The pattern looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于内存屏障的最简单但出奇强大的无锁模式被称为发布协议。当有一个线程正在生产一些数据，当它准备好时，这些数据将被提供给一个或多个其他线程时，这种模式适用。该模式看起来是这样的：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The shared variable is an atomic pointer to the data. It is often called the
    “root” pointer because the data itself may be a complex data structure with multiple
    pointers connecting its parts. The key requirement of this pattern is that there
    is only one way to access the entire data structure and this is through the root
    pointer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 共享变量是一个指向数据的原子指针。它通常被称为“根指针”，因为数据本身可能是一个复杂的包含多个指针连接其部分的数据结构。这种模式的关键要求是只能通过根指针访问整个数据结构。
- en: The producer thread builds all the data it needs to produce. It uses a thread-specific
    pointer, usually a local variable, to access the data. No other thread can see
    the data yet because the root pointer does not point to it and the local pointer
    of the producer thread is not shared with other threads.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者线程构建它需要生产的所有数据。它使用一个线程特定的指针，通常是一个局部变量，来访问数据。由于根指针没有指向它，并且生产者线程的局部指针没有与其他线程共享，因此其他线程还看不到这些数据。
- en: Finally, when the data is complete, the producer atomically stores the pointer
    to the data in the shared root pointer. It is often said that the producer atomically
    publishes the data, hence the name of the pattern, the publishing protocol.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当数据完成时，生产者将数据指针原子地存储在共享的根指针中。通常说生产者原子地发布数据，因此这种模式被称为发布协议。
- en: 'The consumers must wait for the data to be published: as long as the root pointer
    is null, there is nothing for them to do. They wait for the root pointer to become
    non-null (the wait does not have to use polling, a notification mechanism is also
    possible). Once the data is published, the consumer threads can access it through
    the root pointer. Because there is no other synchronization, no thread can modify
    the data once it’s published (the data may contain a mutex or some other mechanism
    to allow parts of it to be modified safely).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者必须等待数据被发布：只要根指针为空，他们就没有事情可做。他们等待根指针变为非空（等待不必使用轮询，也可以使用通知机制）。一旦数据被发布，消费者线程可以通过根指针访问它。因为没有其他同步机制，一旦数据被发布，就没有线程可以修改数据（数据可能包含互斥锁或其他机制，允许其部分安全地修改）。
- en: 'The atomic variable itself is insufficient for this pattern to guarantee no
    data races: all threads access not just the atomic pointer but the memory it points
    to. This is why we needed the specific memory barriers: when publishing the data,
    the producer uses the release barrier to not only initialize the pointer atomically
    but also ensure that all memory modifications that were done before the atomic
    write operations on the pointer become visible to anyone who reads the new value
    of the pointer. The consumer uses the acquire barrier to ensure that any operation
    on the shared data that is done after the new value of the pointer is read observes
    the latest state of the shared data as it existed at the moment the data was published.
    In other words, if you read the value of the pointer and then dereference it,
    you generally do not know if you will get the latest value of the data the pointer
    points to. But if you read the pointer with the acquire barrier (and the pointer
    was written with the release barrier), then you can be sure that you will read
    (acquire) the data as it was last written (released). Together, the release and
    acquire barriers guarantee that the consumer sees the shared data exactly as it
    was seen by the producer at the moment it published the address of the data in
    the root pointer.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 原子变量本身不足以保证这种模式没有数据竞争：所有线程不仅访问原子指针，还访问它指向的内存。这就是为什么我们需要特定的内存屏障：当发布数据时，生产者使用释放屏障不仅原子地初始化指针，还确保在指针上的原子写操作之前所做的所有内存修改都对读取指针新值的任何人可见。消费者使用获取屏障确保在读取指针新值之后对共享数据的任何操作都观察到数据发布时共享数据的最新状态。换句话说，如果你读取指针的值然后解引用它，你通常不知道你是否会得到指针指向的数据的最新值。但如果你使用获取屏障读取指针（并且指针是用释放屏障写入的），那么你可以确信你会读取（获取）最后写入（发布）的数据。释放和获取屏障共同保证消费者看到的共享数据与生产者在发布根指针中数据地址时的所见完全一致。
- en: 'The same pattern can be used to publish completed elements of a larger data
    structure shared between threads. For example, we can have a producer thread publish
    how many array elements it initialized with the results:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的模式可以用来发布线程间共享的更大数据结构的完成元素。例如，我们可以有一个生产者线程发布它用结果初始化了多少个数组元素：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The idea is exactly the same as in the previous example, only instead of the
    pointer we use the index into an array. In both cases, we have one producer thread
    that computes and publishes data, and one or more consumer threads that wait for
    the data to be published. If we need multiple producers, we must use some other
    synchronization mechanism to ensure that they don’t work on the same data, such
    as the atomic index we just saw.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法与前面的例子完全相同，只是我们使用数组中的索引而不是指针。在两种情况下，我们都有一个计算并发布数据的生产者线程，以及一个或多个等待数据发布的消费者线程。如果我们需要多个生产者，我们必须使用其他同步机制来确保它们不会在相同的数据上工作，例如我们刚刚看到的原子索引。
- en: 'In a program with multiple producer and consumer threads, we often have to
    combine several synchronization patterns. In the next example, we have a large
    shared data structure organized as an array of pointers to the individual elements.
    Several producer threads fill this data structure with results; we are going to
    use the atomic index to ensure that each element is handled by only one producer:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有多个生产者和消费者线程的程序中，我们通常必须结合使用几种同步模式。在下一个例子中，我们有一个大型的共享数据结构，它组织成一个指向各个元素的指针数组。几个生产者线程用结果填充这个数据结构；我们将使用原子索引来确保每个元素只由一个生产者处理：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our producer computes the result, then fetches the current index value and,
    at the same time, increments the index so the next producer cannot get the same
    index value. The array slot `data[s]` is, therefore, uniquely reserved for this
    producer thread. This is enough to avoid sharing conflicts between producers,
    but the consumers cannot use the same index to know how many elements are already
    in the array: the index is incremented before the corresponding array element
    is initialized. For the consumers, we use the publishing protocol: each array
    element is an atomic pointer that remains null until the data is published. The
    consumers must wait for a pointer to become non-null before they can access the
    data:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的生成器计算结果，然后获取当前索引值，同时增加索引，以便下一个生成器不能获得相同的索引值。因此，数组槽`data[s]`是唯一为这个生成器线程保留的。这足以避免生产者之间的共享冲突，但消费者不能使用相同的索引来知道数组中已经有多少元素：索引在相应的数组元素初始化之前增加。对于消费者，我们使用发布协议：每个数组元素都是一个原子指针，直到数据发布之前保持为null。消费者必须在可以访问数据之前等待指针变为非null：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this example, the consumer stops as soon as it finds a data element that
    is not ready. We could continue scanning the array: some of the subsequent elements
    may be ready because they were filled by another producer thread. If we do, we
    have to somehow remember to come back to handle the elements we missed. The right
    approach depends on the problem we need to solve, of course.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，消费者一旦找到不准备好的数据元素就会停止。我们可以继续扫描数组：一些后续的元素可能已经准备好了，因为它们被另一个生产者线程填充。如果我们这样做，我们必须以某种方式记住回来处理我们遗漏的元素。正确的方法当然取决于我们需要解决的问题。
- en: The literature on lock-free programming is extensive and full of (usually) very
    complex examples. The concurrency patterns we have demonstrated are only the basic
    building blocks for more complex data structures and data synchronization protocols.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 无锁编程的文献非常丰富，充满了（通常是）非常复杂的例子。我们展示的并发模式只是更复杂数据结构和数据同步协议的基本构建块。
- en: In the next section, we will see some of the much higher-level patterns that
    are applicable to the design of such data structures or even entire programs and
    their major components.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到一些适用于此类数据结构或甚至整个程序及其主要组件设计的更高层次的模式。
- en: Concurrent design patterns and guidelines
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发设计模式和指南
- en: Designing and implementing concurrent software is hard. Even the basic patterns
    for controlling access to shared data, such as the ones we saw in the last section,
    are complex and full of subtle details. Failing to notice one of these details
    usually results in hard-to-debug data races. To simplify the task of writing concurrent
    programs, the programming community came up with several guidelines. All of them
    arise out of earlier disastrous experiences, so take these guidelines seriously.
    Central to these guidelines is the concept of thread safety guarantees.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和实现并发软件是困难的。即使是控制对共享数据访问的基本模式，如我们在上一节中看到的，也是复杂的，充满了微妙的细节。未能注意到这些细节通常会导致难以调试的数据竞争。为了简化编写并发程序的任务，编程社区提出了几项指南。所有这些指南都源于早期的灾难性经验，因此请认真对待这些指南。这些指南的核心是线程安全保证的概念。
- en: Thread safety guarantees
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全保证
- en: While this is not a pattern, it is a concept that is much broader in scope and
    one of the key design principles for any concurrent software. Every class, function,
    module, or component of a concurrent program should specify the thread safety
    guarantees it provides, as well as the guarantees it requires from the components
    it uses.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是一个模式，但这是一个范围更广的概念，并且是任何并发软件的关键设计原则之一。任何并发程序中的每个类、函数、模块或组件都应该指定它提供的线程安全保证，以及它对其使用的组件所要求的保证。
- en: 'In general, a software component can offer three levels of thread-safety guarantees:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个软件组件可以提供三个级别的线程安全保证：
- en: '**Strong thread safety guarantee**: Any number of threads can access this component
    without restrictions and without encountering undefined behavior. For a function,
    it means that any number of threads can call this function at the same time (possibly,
    with some restrictions on parameters). For a class, it means that any number of
    threads can call member functions of this class concurrently. For a larger component,
    any number of threads can operate its interfaces (again, possibly with some restrictions).
    Such components, classes, and data structures are sometimes called thread-safe.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强线程安全保证**：任何数量的线程都可以无限制地访问此组件，而不会遇到未定义的行为。对于一个函数，这意味着任何数量的线程都可以同时调用此函数（可能对参数有一些限制）。对于一个类，这意味着任何数量的线程都可以并发调用此类的成员函数。对于一个更大的组件，任何数量的线程都可以操作其接口（同样，可能有一些限制）。这样的组件、类和数据结构有时被称为线程安全。'
- en: '`const` member functions). Only one thread can modify the state of the component
    at any time, and the locking or another way of ensuring such exclusive access
    is the responsibility of the caller. Such components, classes, and data structures
    are sometimes called thread-compatible because you can build a concurrent program
    from them using the appropriate synchronization mechanisms. All STL containers
    offer this level of guarantee.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`const` 成员函数)。在任何时候，只有一个线程可以修改组件的状态，锁定或其他确保这种独占访问的方式是调用者的责任。这样的组件、类和数据结构有时被称为线程兼容，因为你可以使用适当的同步机制从它们构建并发程序。所有
    STL 容器都提供这种级别的保证。
- en: '**No thread-safety guarantee**: Such components cannot be used in a concurrent
    program at all and are sometimes called thread-hostile. These classes and functions
    often have hidden global states that cannot be accessed in a thread-safe manner.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无线程安全保证**：此类组件根本不能用于并发程序，有时被称为线程敌对。这些类和函数通常具有隐藏的全局状态，无法以线程安全的方式访问。'
- en: By designing each component to provide certain thread safety guarantees, we
    can divide the intractable problem of making the entire program thread-safe into
    a hierarchy of design challenges where the more complex components take advantage
    of the guarantees provided by the simpler ones. Central to this process is the
    notion of the transactional interface.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设计每个组件以提供一定的线程安全保证，我们可以将使整个程序线程安全这一难以处理的问题分解为一系列设计挑战，其中更复杂的组件利用简单组件提供的保证。这一过程的核心是事务接口的概念。
- en: Transactional interface design
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务接口设计
- en: 'The idea of the transactional interface design is very simple: every component
    should have an interface such that every operation is an atomic transaction. From
    the point of view of the rest of the program, the operation either has not happened
    yet or is done. No other thread can observe the state of the component during
    the operation. This can be accomplished using mutexes or any other synchronization
    scheme that fits the need – the particular implementation can influence performance
    but is not essential for correctness as long as the interface guarantees transaction
    processing.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 事务接口设计理念非常简单：每个组件都应该有一个接口，使得每个操作都是一个原子事务。从程序其他部分的角度来看，操作要么尚未发生，要么已经完成。在操作期间，没有其他线程可以观察到组件的状态。这可以通过互斥锁或其他适合需求的同步方案来实现——特定的实现可以影响性能，但只要接口保证了事务处理，它就不是正确性的关键。
- en: 'This guideline is most useful for designing data structures for concurrent
    programs. Here, it is so important that it is generally accepted that one cannot
    design a thread-safe data structure that does not offer a transactional interface
    (at least not a useful data structure). For example, we can consider a queue.
    The C++ standard library offers a `std::queue` template. As with any other STL
    container, it offers the weak guarantee: any number of threads can call `const`
    methods of the queue as long as no thread calls any non-`const` methods. Alternatively,
    any one thread can call a non-`const` method. To ensure the latter, we have to
    lock all accesses to the queue with an external mutex. If we want to pursue this
    approach, we should combine the queue and the mutex in a new class:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指南对于设计并发程序的数据结构非常有用。在这里，它如此重要，以至于普遍认为，不能设计一个不提供事务接口（至少不是一个有用的数据结构）的线程安全数据结构。例如，我们可以考虑一个队列。C++
    标准库提供了一个 `std::queue` 模板。与其他任何 STL 容器一样，它提供弱保证：只要没有线程调用任何非 `const` 方法，任意数量的线程都可以调用队列的
    `const` 方法。或者，任何单个线程都可以调用一个非 `const` 方法。为了确保后者，我们必须使用外部互斥锁锁定对队列的所有访问。如果我们想追求这种方法，我们应该将队列和互斥锁组合在一个新的类中：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To push another element onto a queue, we need to lock the mutex, since the
    `push()` member function modifies the queue:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要将另一个元素推送到队列中，我们需要锁定互斥锁，因为 `push()` 成员函数会修改队列：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This works exactly as we want it to: any number of threads can call `push()`
    and every element will be added to the queue exactly once (the order is going
    to be arbitrary if multiple calls happen simultaneously, but this is the nature
    of concurrency). We have successfully provided the strong thread safety guarantee!'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全符合我们的预期：任意数量的线程都可以调用 `push()`，每个元素将正好被添加到队列中一次（如果同时发生多个调用，顺序将是任意的，但这并发性的本质）。我们已经成功提供了强线程安全保证！
- en: 'The triumph is going to be short-lived, unfortunately. Let us see what it takes
    to pop an element from the queue. There is a member function `pop()` that removes
    the element from the queue, so we can protect it with the same mutex:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种成功将是短暂的。让我们看看从队列中弹出元素需要什么。有一个成员函数 `pop()` 可以从队列中移除元素，因此我们可以用相同的互斥锁保护它：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice that this function does not return anything: it removes the oldest element
    in the queue and destroys it, but that’s not what we need to find out what that
    element is (or was). For that, we need to use the function `front()` which returns
    a reference to the oldest element but does not modify the queue. It is a `const`
    member function, so we need to lock it only if we call any non-`const` functions
    at the same time; we are going to ignore this optimization possibility for now
    and always lock this call as well:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这个函数不返回任何内容：它移除队列中最旧的元素并销毁它，但这并不是我们需要找出该元素是什么（或曾经是什么）的原因。为此，我们需要使用返回对最旧元素引用但不修改队列的
    `front()` 函数。它是一个 `const` 成员函数，因此我们只需要在同时调用任何非 `const` 函数时锁定它；我们现在将忽略这种优化可能性，并始终锁定这个调用：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we call `front()` from multiple threads and don’t call any other functions,
    this implementation is sub-optimal, but it is not wrong.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从多个线程调用 `front()` 而不调用任何其他函数，这种实现是次优的，但并不错误。
- en: 'There is one special case we have neglected to mention: if the queue is empty,
    you should not call `pop()` or `front()` – doing so leads to undefined behavior,
    according to the standard. How do you know if it is safe to pop an element from
    the queue? You can check if the queue is empty. This is another `const` member
    function, and again we are going to over-protect it and lock every call to it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略了一个特殊情况：如果队列为空，你不应该调用 `pop()` 或 `front()` – 根据标准，这样做会导致未定义的行为。你如何知道从队列中弹出元素是否安全？你可以检查队列是否为空。这是一个另一个
    `const` 成员函数，我们再次将过度保护它并锁定对它的每个调用：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now every member function of the underlying `std::queue` is protected by a mutex.
    We can call any of them from any number of threads and be guaranteed that only
    one thread can access the queue at any time. Technically, we have achieved the
    strong guarantee. Unfortunately, it is not very useful.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，底层 `std::queue` 的每个成员函数都由互斥锁保护。我们可以从任意数量的线程中调用它们，并保证在任何时候只有一个线程可以访问队列。技术上，我们已经实现了强保证。不幸的是，这并不非常实用。
- en: 'To see why, let us consider the process of removing an element from the queue:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解原因，让我们考虑从队列中移除一个元素的过程：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This works fine on one thread, but we didn’t need a mutex for that. It still
    (mostly) works when we have two threads, one of which is pushing new elements
    onto the queue and the other one is taking them from the queue. Let us consider
    what happens when two threads try to pop one element each. First, they both call
    `empty()`. Let us assume that the queue is not empty and both calls return `true`.
    Then, they both call `front()`. Since neither thread did a `pop()` yet, both threads
    get the same front element. This is not what was supposed to happen if we want
    each thread to pop an element from the queue. Finally, both threads call `pop()`,
    and two elements are removed from the queue. One of these elements we have never
    seen and will never see again, so we lost some of the data that was enqueued.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在单线程上这工作得很好，但我们并不需要互斥锁来处理它。当我们有两个线程时，一个线程将新元素推入队列，另一个线程从队列中取出元素，它仍然（大多数情况下）可以正常工作。让我们考虑当两个线程都试图各自弹出队列中的一个元素时会发生什么。首先，它们都调用了`empty()`。假设队列不为空，并且两次调用都返回`true`。然后，它们都调用了`front()`。由于两个线程都没有调用过`pop()`，它们都得到了相同的队首元素。这不是我们想要的结果，如果我们希望每个线程都能从队列中弹出一个元素的话。最后，两个线程都调用了`pop()`，队列中移除了两个元素。其中有一个元素我们从未见过，也永远不会再见到，所以我们丢失了一些已经入队的资料。
- en: But this isn’t the only way it can go wrong. What happens if there is only one
    element on the queue? Both calls to `empty()` still return true – a queue with
    one element is not empty. Both calls to `front()` still return the (same) front
    element. The first call to `pop()` succeeds but the second one is undefined behavior
    because the queue is now empty. It is also possible that one thread calls `pop()`
    before the other thread calls `front()` but after it calls `empty()`. In this
    case, the second call to `front()` is also undefined.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是唯一可能出错的方式。如果队列中只有一个元素会发生什么？两次对`empty()`的调用仍然返回`true`——一个只有一个元素的队列不是空的。两次对`front()`的调用仍然返回（相同的）队首元素。第一次对`pop()`的调用成功，但第二次调用是未定义的行为，因为队列现在为空了。也有可能一个线程在另一个线程调用`front()`之前调用`pop()`，但在调用`empty()`之后。在这种情况下，第二次对`front()`的调用也是未定义的。
- en: 'We have a perfectly safe and a perfectly useless data structure. Clearly, a
    thread safety guarantee is not enough. We also need an interface that does not
    expose us to undefined behavior, and the only way to do this is to perform all
    three steps of the pop operation (`empty()`, `front()`, and `pop()`) in a single
    critical section, i.e., without releasing the mutex between the calls. Unless
    we want the caller to supply their own mutex, the only way to do this is to change
    the interface of our `ts_queue` class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个既安全又毫无用处的数据结构。显然，线程安全保证是不够的。我们还需要一个不会暴露我们于未定义行为的接口，而实现这一点的唯一方法是在单个临界区中执行弹出操作的所有三个步骤（`empty()`、`front()`和`pop()`），即在调用之间不释放互斥锁。除非我们希望调用者提供自己的互斥锁，否则实现这一点的唯一方法就是改变我们的`ts_queue`类的接口：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `push()` function is the same as it was before (we made the argument type
    more flexible, but this is not related to thread safety). The reason we did not
    need to change the push operation is that it is already transactional: at the
    end, the queue has one more element than it had at the beginning of the operation,
    and the state of the queue is otherwise identical. We just made it atomic by protecting
    it with a mutex (no other thread that also uses the same mutex correctly can observe
    our queue in its transitional non-invariant state).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()`函数与之前相同（我们使参数类型更加灵活，但这与线程安全无关）。我们不需要改变推送操作的原因是它已经是事务性的：在操作结束时，队列比操作开始时多了一个元素，队列的其他状态保持不变。我们只是通过互斥锁来保护它，使其原子化（没有其他正确使用相同互斥锁的线程可以观察到我们的队列在其过渡的非不变状态）。'
- en: 'The `pop()` operation is where the transactional interface looks very different.
    In order to provide a meaningful thread safety guarantee, we have to provide an
    operation that returns the front element to the caller and removes it from the
    queue atomically: no other thread should be able to see the same front element,
    therefore, we have to lock both `front()` and `pop()` on the original queue with
    the same mutex. We also have to consider the possibility that the queue is empty
    and we have no front element to return to the caller. What do we return in this
    case? If we decided to return the front element by value, we would have to default-construct
    this value (or return some other agreed-upon value that means “no element”). In
    C++17, a better way is to return a `std::optional` that holds the front element
    if there is one.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop()`操作是事务性接口看起来非常不同的地方。为了提供一个有意义的线程安全性保证，我们必须提供一个返回前端元素给调用者并从队列中原子性地移除它的操作：其他线程不应该能够看到相同的前端元素，因此，我们必须使用相同的互斥锁锁定原始队列上的`front()`和`pop()`。我们还必须考虑队列可能为空且我们没有前端元素可以返回给调用者的可能性。在这种情况下我们返回什么？如果我们决定通过值返回前端元素，我们就必须默认构造这个值（或者返回一些其他商定的值，表示“没有元素”）。在C++17中，更好的方法是返回一个包含前端元素的`std::optional`，如果有的话。'
- en: 'Now both `pop()` and `push()` are atomic and transactional: we can call both
    methods from as many threads as we want, and the results are always well-defined.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`pop()`和`push()`都是原子性和事务性的：我们可以从任意多的线程中调用这两个方法，结果总是良好定义的。
- en: 'You may wonder why didn’t `std::queue` offer this transactional interface,
    to begin with. First, STL was designed long before threads made it into the standard.
    But the other, very important, reason is that the queue interface was influenced
    by the need to provide exception safety. Exception safety is the guarantee that
    the object remains in a well-defined state if an exception is thrown. Here, the
    original queue interface does very well: `empty()` just returns the size and cannot
    throw an exception, `front()` returns the reference to the front element and also
    cannot throw, and finally `pop()` calls the destructor of the front element, which
    normally does not throw either. Of course, when accessing the front element, the
    caller’s code may throw (for example, if the caller needs to copy the front element
    to another object) but the caller is expected to handle that. In any case, the
    queue itself remains in a well-defined state.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么`std::queue`一开始没有提供这种事务性接口。首先，STL是在线程进入标准之前设计的。但另一个非常重要的原因是，队列接口受到了提供异常安全性的需求的影响。异常安全性是保证在抛出异常时对象保持良好定义状态的保证。在这里，原始的队列接口做得很好：`empty()`只是返回大小，不会抛出异常，`front()`返回前端元素的引用，也不会抛出异常，最后`pop()`调用前端元素的析构函数，这通常也不会抛出异常。当然，当访问前端元素时，调用者的代码可能会抛出异常（例如，如果调用者需要将前端元素复制到另一个对象中），但预期调用者会处理这种情况。无论如何，队列本身保持在一个良好定义的状态。
- en: 'Our thread-safe queue, however, has an exception safety problem: the code that
    copies the front element of the queue to return it to the caller is now inside
    `pop()`. If the copy constructor throws during the construction of the local `std::optional`
    variable `res`, we are probably OK. However, if an exception is thrown when the
    result is returned to the caller (which can happen by move or copy), then `pop()`
    was already done, so we are going to lose the element we just popped from the
    queue.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的线程安全队列，然而，存在一个异常安全性问题：将队列的前端元素复制以返回给调用者的代码现在位于`pop()`函数内部。如果在构造局部`std::optional`变量`res`期间抛出异常，我们可能没问题。然而，如果在将结果返回给调用者时抛出异常（这可能通过移动或复制发生），那么`pop()`操作已经完成，因此我们将丢失刚刚从队列中弹出的元素。
- en: 'This tension between thread safety and exception safety is often unavoidable
    and has to be considered when designing thread-safe data structures for concurrent
    programs. Regardless, it must be reiterated that the only way to design thread-safe
    data structures or larger modules is to ensure that every interface call is a
    complete transaction: any steps that are conditionally defined must be packaged
    into a single transactional call together with the operations that are needed
    to ensure that such conditions are met. Then, the entire call should be guarded
    by a mutex or some other way to ensure race-free exclusive access.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程安全和异常安全之间的这种紧张关系通常是不可避免的，在设计用于并发程序的线程安全数据结构时必须考虑。无论如何，必须重申，设计线程安全数据结构或更大的模块的唯一方法是要确保每个接口调用都是一个完整的交易：任何条件定义的步骤必须与确保满足这些条件所需的操作一起打包成一个单一的交易调用。然后，整个调用应该由互斥锁或其他确保无竞争的独占访问的方式保护。
- en: Designing thread-safe data structures is generally very hard, especially if
    we want good performance (and what is the point of concurrency if we don’t?).
    That is why it is very important to take advantage of any use restrictions or
    special requirements that allow us to impose restrictions on how these data structures
    are used. In the next section, we will see one common case of such restrictions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 设计线程安全数据结构通常非常困难，尤其是如果我们想要良好的性能（如果我们不追求并发，那么并行的意义何在呢？）。这就是为什么利用任何使用限制或特殊要求来限制这些数据结构的使用方式非常重要。在下一节中，我们将看到这种限制的一个常见案例。
- en: Data structures with access limitations
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有访问限制的数据结构
- en: Designing thread-safe data structures is so hard that one should look for any
    opportunity to simplify the requirements and the implementation. If there is any
    scenario you don’t need right now, think if you can make your code simpler if
    you do not support that scenario. One obvious case is a data structure that is
    built by a single thread (no thread safety guarantees needed) then becomes immutable
    and is accessed by many threads that act as readers (a weak guarantee is sufficient).
    Any STL container, for example, can operate in this mode as-is. We still need
    to ensure that no reader can access the container while it’s still being filled
    with data, but that can be easily done with a barrier or a condition. This is
    a very useful but rather trivial case. Are there any other restrictions we can
    make use of?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 设计线程安全数据结构如此困难，以至于我们应该寻找任何机会简化要求和实现。如果你现在不需要任何场景，想想如果你不支持该场景，你是否可以使你的代码更简单。一个明显的例子是，一个由单个线程构建的数据结构（不需要线程安全保证），然后变为不可变，并被许多作为读者的线程访问（一个弱保证就足够了）。例如，任何STL容器都可以以这种方式运行。我们仍然需要确保在容器被填充数据时，没有读者可以访问容器，但这可以通过一个屏障或条件轻松完成。这是一个非常有用但相当简单的情况。我们还能利用哪些其他限制？
- en: 'In this section, we consider a particular use case that occurs quite frequently
    and allows for much simpler data structures. Specifically, we examine the situation
    when a particular data structure is accessed by only two threads. One thread is
    the producer, it adds data to the data structure. The other thread is the consumer,
    it removes the data. Both threads do modify the data structure but in different
    ways. This situation occurs rather frequently and often allows for very specialized
    and very efficient data structure implementations. It probably deserves recognition
    as a design pattern for concurrent designs, and it already has a commonly recognized
    name: “single-producer single-consumer data structure.”'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们考虑一个相当常见且允许使用更简单数据结构的特定用例。具体来说，我们考察了当某个数据结构仅由两个线程访问的情况。一个线程是生产者，它向数据结构添加数据。另一个线程是消费者，它从数据结构中移除数据。两个线程都会修改数据结构，但方式不同。这种情况相当常见，并且往往允许非常专业且非常高效的数据结构实现。这或许值得被认可为并发设计的设计模式，并且它已经有一个普遍认可的名字：“单生产者单消费者数据结构。”
- en: 'In this section, we are going to see an example of a single-producer single-consumer
    queue. It is a data structure that is frequently used with one producer and one
    consumer thread, but the ideas we explore here can be used to design other data
    structures as well. The main distinguishing feature of this queue is going to
    be that it is lock-free: there are no mutexes in it at all, so we can expect much
    higher performance from it.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到一个单生产者单消费者队列的例子。这是一个经常与一个生产者和一个消费者线程一起使用的数据结构，但我们在这里探讨的思想也可以用来设计其他数据结构。这个队列的主要区别特征将是它是无锁的：它根本不包含互斥锁，因此我们可以期望从它那里获得更高的性能。
- en: 'The queue is built on an array of a fixed size, so, unlike a regular queue,
    it cannot grow indefinitely (this is another common restriction used to simplify
    lock-free data structures):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是基于一个固定大小的数组构建的，因此，与普通队列不同，它不能无限增长（这是用于简化无锁数据结构的一个常见限制）：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In our example, we default-construct elements in the array. If this is undesirable,
    we can also use a properly aligned uninitialized buffer. All accesses to the queue
    are determined by two atomic variables, `back_` and `front_`. The former is the
    index of the array element that we will write into when we push a new element
    onto the queue. The latter is the index of the array element we will read from
    when we need to pop an element from the queue. All array elements in the range
    [`front_`, `back_`) are filled with elements currently on the queue. Note that
    this range can wrap over the end of the buffer: after using the element `buffer_[N-1]`
    the queue does not run out of space but starts again from `buffer_[0]`. This is
    known as a **circular buffer**.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们默认构造数组中的元素。如果这不可取，我们也可以使用一个正确对齐的未初始化缓冲区。所有对队列的访问都由两个原子变量`back_`和`front_`决定。前者是我们将新元素推入队列时将要写入的数组元素的索引。后者是我们需要从队列中弹出元素时将要读取的数组元素的索引。范围`[front_`,
    `back_]`内的所有数组元素都填充了队列上的当前元素。请注意，这个范围可以绕过缓冲区的末尾：在使用了`buffer_[N-1]`元素之后，队列并没有用完空间，而是从`buffer_[0]`重新开始。这被称为**循环缓冲区**。
- en: 'How do we use these indices to manage the queue? Let us start with the push
    operation:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用这些索引来管理队列？让我们从推入操作开始：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We need to read the current value of `back_`, of course: this is the index
    of the array element we are about to write. We support only one producer, and
    only the producer thread can increment `back_`, so we do not need any particular
    precautions here. We do, however, need to be careful to avoid overwriting any
    elements already in the queue. To do this we must check the current value of `front_`
    (we can read it before or after reading `back_`, it makes no difference). If the
    element `buffer_[back]` that we are about to overwrite is also the front element,
    then the queue is full and the `push()` operation fails (note that there is another
    solution to this problem that is often used in real-time systems: if the queue
    is full, the oldest element is silently overwritten and lost). After the new element
    is stored, we atomically increment the `back_` value to signal to the consumer
    that this slot is now available for reading. Because we are publishing this memory
    location, we must use the release barrier. Also note the modular arithmetic: after
    reaching the array element `N-1`, we’re looping back to element 0.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要读取`back_`的当前值：这是我们即将写入的数组元素的索引。我们只支持一个生产者，只有生产者线程可以增加`back_`，因此在这里我们不需要特别的预防措施。然而，我们需要小心避免覆盖队列中已经存在的任何元素。为此，我们必须检查`front_`的当前值（我们可以在读取`back_`之前或之后读取它，这没有关系）。如果我们即将覆盖的`buffer_[back]`元素也是队首元素，那么队列已满，`push()`操作将失败（请注意，对于这个问题还有另一种常用的解决方案：如果队列已满，最老的元素将被静默覆盖并丢失）。在存储新元素后，我们原子性地增加`back_`的值，以通知消费者这个槽位现在可以读取。因为我们正在发布这个内存位置，所以我们必须使用释放屏障。此外，请注意模运算：在达到数组元素`N-1`之后，我们将循环回到元素0。
- en: 'Next, let us see the `pop()` operation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`pop()`操作：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Again, we need to read both `front_` and `back_`: `front_` is the index of
    the element we are about to read, and only the consumer can advance this index.
    On the other hand, `back_` is needed to make sure we actually have an element
    to read: if the front and back are the same, the queue is empty; again, we use
    `std::optional` to return a value that might not exist. We must use acquire barrier
    when reading `back_` to make sure we see the element values that were written
    into the array by the producer thread. Finally, we advance `front_` to ensure
    that we don’t read the same element again and to make this array slot available
    to the producer thread.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们需要读取`front_`和`back_`两个部分：`front_`是我们即将读取的元素的索引，只有消费者可以前进这个索引。另一方面，`back_`是确保我们实际上有一个元素可以读取所必需的：如果前一个和后一个索引相同，那么队列就是空的；再次强调，我们使用`std::optional`来返回可能不存在的一个值。在读取`back_`时，我们必须使用获取屏障来确保我们看到生产者线程写入数组中的元素值。最后，我们前进`front_`以确保我们不会再次读取相同的元素，并使这个数组槽位对生产者线程可用。
- en: 'There are several subtle details here that must be pointed out. Reading `back_`
    and `front_` is not done in a single transaction (it is not atomic). In particular,
    if the producer reads `front_` first, it is possible that, by the time it reads
    `back_` and compares the two, the consumer has already advanced `front_`. That
    does not make our data structure incorrect, though. At worst, the producer can
    report that the queue is full when in fact, it is no longer full. We could read
    both values atomically, but this will only degrade the performance, and the caller
    still has to handle the case when the queue is full. Similarly, when `pop()` reports
    that the queue is empty, it may no longer be so by the time the call completes.
    Again, these are the inevitable complexities of concurrency: each operation reflects
    the state of the data at some point in time. By the time the caller gets the return
    value and can analyze it, the data may have changed already.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个必须指出的微妙细节。读取`back_`和`front_`不是在一个单一的事务中完成的（它不是原子的）。特别是，如果生产者首先读取`front_`，那么当它读取`back_`并与两个值进行比较时，消费者可能已经前进`front_`了。这并不会使我们的数据结构出错。最坏的情况是，生产者可能会报告队列已满，而实际上它已经不再满了。我们可以原子地读取这两个值，但这只会降低性能，调用者仍然需要处理队列已满的情况。同样，当`pop()`报告队列为空时，到调用完成时它可能已经不再为空了。这些是并发不可避免的复杂性：每个操作都反映了数据在某个时间点的状态。当调用者获取返回值并分析它时，数据可能已经发生了变化。
- en: Another note-worthy detail is the careful management of the queue elements’
    lifetime. We default-construct all elements in the array, so the proper way to
    transfer the data from the caller into the queue during `push()` is by copy or
    move assignment (`std::forward` does both). On the other hand, once a value is
    returned to the caller by `pop()`, we never need that value again, so the right
    operation here is move, first into the optional and then into the caller’s return
    value object. Note that moving an object is not the same as destroying it; indeed,
    the moved-from array elements are not destroyed until the queue itself is. If
    an array element is reused, it is copy- or move-assigned a new value, and assignments
    are two of the three operations that are safe to do on a moved-from object (the
    third one is the destructor, which we will also call eventually).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的细节是对队列元素生命周期的谨慎管理。我们在数组中默认构造所有元素，因此在`push()`期间从调用者将数据传输到队列的正确方式是通过复制或移动赋值（`std::forward`可以完成这两者）。另一方面，一旦`pop()`将值返回给调用者，我们就不再需要那个值了，所以这里的正确操作是移动，首先移动到`optional`中，然后移动到调用者的返回值对象中。请注意，移动一个对象与销毁它不同；实际上，被移动的数组元素直到队列本身被销毁时才被销毁。如果一个数组元素被重用，它会被复制或移动赋值一个新的值，而赋值是可以在移动后的对象上安全执行的三种操作之一（第三种是析构函数，我们最终也会调用它）。
- en: The single-producer single-consumer pattern is a common pattern that allows
    a programmer to greatly simplify their concurrent data structures. There are others,
    you can find them in books and papers dedicated to concurrent data structures.
    All these patterns are ultimately designed to help you write data structures that
    perform correctly and efficiently when accessed by multiple threads. We, however,
    must move on and finally tackle the problem of using these threads to get some
    useful work done.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 单生产者单消费者模式是一种常见的模式，它允许程序员极大地简化他们的并发数据结构。还有其他模式，你可以在专门针对并发数据结构的书籍和论文中找到它们。所有这些模式最终都是为了帮助你编写在多线程访问时能够正确且高效执行的数据结构。然而，我们必须继续前进，最终解决使用这些线程来完成一些有用工作的问题。
- en: Concurrent execution patterns
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发执行模式
- en: 'The next group of patterns for concurrency we must learn are execution patterns.
    These patterns are used to organize the computations done on multiple threads.
    You will find out that, just as with the synchronization patterns we saw earlier,
    all of these are low-level patterns: most solutions for practical problems must
    combine these patterns into larger, more complex, designs. This is not because
    C++ is ill-suited for such larger designs; if anything, it is the opposite: there
    are so many ways to implement, for example, a thread pool, in C++, that for every
    concrete application, there is a version that is ideally suited in terms of performance
    and features. This is why it is hard to describe these more complete solutions
    as patterns: while the problems they address are common, the solutions vary a
    great deal. But all of these designs have a number of challenges to resolve, and
    the solutions to those challenges usually use the same tools over and over, so
    we can at least describe these more basic challenges and their common solutions
    as design patterns.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须学习的下一个并发模式组是执行模式。这些模式用于组织在多个线程上完成的计算。你会发现，就像我们之前看到的同步模式一样，所有这些都是低级模式：大多数实际问题的解决方案必须将这些模式组合成更大、更复杂的结构。这并不是因为C++不适合这样的更大设计；实际上，情况正好相反：在C++中有许多方法来实现，例如线程池，对于每个具体的应用，都有一个在性能和功能方面都理想的版本。这就是为什么很难将这些更完整的解决方案描述为模式：虽然它们解决的问题很常见，但解决方案有很大的不同。但所有这些设计都有许多挑战需要解决，而解决这些挑战的解决方案通常反复使用相同的工具，因此我们至少可以将这些更基本的挑战和它们的常见解决方案描述为设计模式。
- en: Active object
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动对象
- en: The first concurrent execution pattern we are going to see is the Active Object.
    An active object usually encapsulates the code to be executed, the data needed
    for the execution, and the flow of control needed to execute the code asynchronously.
    This flow of control could be as simple as a separate thread that the object starts
    and joins. In most cases, we do not start a new thread for every task, so an active
    object would have some way to run its code on a multi-threaded executor such as
    a thread pool. From the caller’s point of view, an active object is an object
    that the caller constructs, initializes with the data, then tells the object to
    execute itself, and the execution happens asynchronously.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看到的第一个并发执行模式是活动对象。活动对象通常封装要执行的代码、执行所需的数据以及执行代码所需的控制流。这种控制流可能只是一个对象启动并连接的单独线程。在大多数情况下，我们不会为每个任务启动一个新的线程，所以活动对象会有某种方式在其多线程执行器（如线程池）上运行其代码。从调用者的角度来看，活动对象是一个调用者构建的对象，用数据初始化，然后告诉对象执行自己，执行是异步发生的。
- en: 'The basic active object looks like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的活动对象看起来像这样：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the simplest case shown here, the active object contains a thread that is
    used to execute the code asynchronously. In most practical cases you would use
    an executor that schedules the work on one of the threads it manages, but this
    gets us into implementation-specific details. The execution starts when `operator()`
    is called; we can also make the object execute as soon as it is constructed by
    calling `operator()` from the constructor. At some point, we have to wait for
    the results. If we use a separate thread, we can join the thread at that time
    (and take care to not attempt to join it twice if the caller calls `wait()` again).
    If the object represents not a thread but a task in a thread pool or some other
    executor, we would do the cleanup necessary for that case.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里展示的最简单的情况下，活动对象包含一个用于异步执行代码的线程。在大多数实际情况下，你会使用一个执行器，它在它管理的线程之一上调度工作，但这使我们陷入了实现特定的细节。执行开始于调用`operator()`时；我们也可以通过在构造函数中调用`operator()`来使对象在构造时立即执行。在某个时刻，我们必须等待结果。如果我们使用一个单独的线程，我们可以在那时连接线程（并且要注意，如果调用者再次调用`wait()`，不要尝试两次连接它）。如果对象代表的是一个线程池或某些其他执行器中的任务，而不是线程，我们会进行必要的清理工作。
- en: 'As you can see, once we settle on a particular way to execute code asynchronously,
    writing active objects with different data and code is a rather repetitive task.
    Nobody writes active objects the way we just did, we always use some generic reusable
    framework. There are two general approaches to implementing such a framework.
    The first one uses inheritance: the base class does the boilerplate work, and
    the derived class contains the unique task-specific data and code. Staying with
    our simple approach to active objects, we could write the base class as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，一旦我们确定了一种特定的异步执行代码的方式，编写具有不同数据和代码的活动对象就变得相当重复。没有人像我们刚才那样编写活动对象，我们总是使用某种通用的可重用框架。实现此类框架有两种一般方法。第一种使用继承：基类执行样板工作，而派生类包含独特的任务特定数据和代码。继续使用我们简单的活动对象方法，我们可以将基类编写如下：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The base object `Job` contains everything needed to implement the asynchronous
    control flow: the thread and the state flag needed to join the thread only once.
    It also defines the way to execute the code by calling the non-virtual function
    `run()`. The code that is executed on the thread must be provided by the derived
    object by overriding `operator()`. Note that only `run()` is public, and `operator()`
    is not: this is the non-virtual idiom in action (we saw it in [*Chapter 14*](B19262_14.xhtml#_idTextAnchor640),
    *The Template Method Pattern and the* *Non-Virtual Idiom*).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 基础对象 `Job` 包含实现异步控制流所需的一切：用于仅一次连接线程的线程和状态标志。它还定义了通过调用非虚函数 `run()` 来执行代码的方式。在线程上执行的代码必须由派生对象通过重载
    `operator()` 提供。请注意，只有 `run()` 是公开的，而 `operator()` 则不是：这就是非虚语法的实际应用（我们在 [*第14章*](B19262_14.xhtml#_idTextAnchor640)，*模板方法模式和*
    *非虚语法*）中看到了它）。
- en: 'The derived object is problem-specific, of course, but generally looks like
    this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 派生对象是针对特定问题的，但通常看起来是这样的：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The only subtlety here is the call to `run()` done at the end of the constructor
    of the derived object. It is not necessary (we can execute the active object later
    ourselves) but if we do want the constructor to run it, it has to be done in the
    derived class. If we start the thread and the asynchronous execution in the base
    class constructor, then we will have a race between the execution on the thread
    – `operator()` – and the rest of the initialization which continues in the derived
    class constructor. For the same reason, an active object that starts executing
    from the constructor should not be derived from again; we ensure that by making
    the object final.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一细微差别是在派生对象构造函数结束时对 `run()` 的调用。这不是必需的（我们可以稍后自己执行活动对象）但如果我们想让构造函数运行它，就必须在派生类中完成。如果我们从基类构造函数开始启动线程和异步执行，那么我们将在线程上的执行（`operator()`）和派生类构造函数中继续的其余初始化之间产生竞争。出于同样的原因，从构造函数开始执行的活动对象不应再次派生；我们通过使对象成为最终类来确保这一点。
- en: 'The use of our active object is very simple: we create it, the object starts
    executing the code in the background (on a separate thread), and when we need
    the result we ask for it (this may involve waiting):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的活动对象非常简单：我们创建它，对象开始在后台（在单独的线程）执行代码，当我们需要结果时，我们请求它（这可能涉及等待）：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you’ve written any concurrent code in C++ at all, you will have definitely
    used an active object already: `std::thread` is an active object, it lets us execute
    arbitrary code on a separate thread. There are concurrency libraries for C++ where
    a thread is a base object and all concrete threads are derived from it. But this
    is not the approach chosen for the C++ standard thread. It follows the second
    way to implement a reusable active object: type erasure. If you need to familiarize
    yourself with it, reread [*Chapter 6*](B19262_06.xhtml#_idTextAnchor266), *Understanding
    Type Erasure*. Even though `std::thread` itself is a type-erased active object,
    we’re going to implement our own just to demonstrate the design (the standard
    library code is rather hard to read). This time, there is no base class. The framework
    is provided by a single class:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在任何 C++ 并发代码中编写过代码，那么你肯定已经使用过活动对象了：`std::thread` 是一个活动对象，它让我们能够在单独的线程上执行任意代码。对于
    C++，有并发库，其中线程是一个基础对象，所有具体的线程都从中派生出来。但 C++ 标准线程并没有选择这种方法。它遵循实现可重用活动对象的第二种方式：类型擦除。如果你需要熟悉它，请重新阅读
    [*第6章*](B19262_06.xhtml#_idTextAnchor266)，*理解类型擦除*。尽管 `std::thread` 本身就是一个类型擦除的活动对象，但我们还是将实现自己的，以展示设计（标准库代码相当难以阅读）。这次，没有基类。框架由一个单一类提供：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To implement the type-erased callable, we use `std::function` (we could also
    use one of the more efficient implementations from [*Chapter 6*](B19262_06.xhtml#_idTextAnchor266),
    *Understanding Type Erasure*, or implement type erasure ourselves following the
    same approach). The code supplied by the caller to be executed on a thread comes
    from the callable `f` in the constructor argument. Note that the order of the
    class members is very important: the asynchronous execution starts as soon as
    the thread `t_` is initialized, so other data members, in particular, the callable
    `f_`, must be initialized before that happens.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现类型擦除的可调用对象，我们使用`std::function`（我们也可以使用[*第6章*](B19262_06.xhtml#_idTextAnchor266)，*理解类型擦除*中更有效的实现之一，或者按照相同的方法自己实现类型擦除）。调用者提供的要在线程上执行的代码来自构造函数参数中的可调用对象`f`。请注意，类成员的顺序非常重要：异步执行是在线程`t_`初始化后立即开始的，因此其他数据成员，特别是可调用对象`f_`，必须在那时之前初始化。
- en: 'To use the active object of this style, we need to supply a callable. It could
    be a lambda expression or a named object, for example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种风格的主动对象，我们需要提供一个可调用对象。它可以是lambda表达式或命名对象，例如：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that, in this design, there is no easy way to access the data members
    of the callable `TheJob`, unless it was created as a named object. For this reason,
    the results are usually returned through arguments passed to the constructor by
    reference (the same as we do with `std::thread`):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个设计中，没有简单的方法可以直接访问可调用对象`TheJob`的数据成员，除非它被创建为一个命名对象。因此，结果通常是通过构造函数传入的引用参数返回的（这与我们使用`std::thread`的方式相同）：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Active objects can be found in every concurrent C++ program, but some uses of
    them are common and specialized, and so are recognized as concurrent design patterns
    in their own right. We will now see several of these patterns.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 主动对象可以在每个并发C++程序中找到，但它们的一些用法是常见和专门的，因此被认可为它们自己的并发设计模式。我们现在将看到这些模式中的几个。
- en: Reactor Object pattern
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反应器对象模式
- en: 'The Reactor pattern often uses for event handling or responding to service
    requests. It solves a specific problem where we have multiple requests for certain
    actions that are issued by multiple threads; however, the nature of these actions
    is such that at least part of them must be executed on one thread or otherwise
    synchronized. The reactor object is the object that services these requests: it
    accepts requests from multiple threads and executes them.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 反应器模式通常用于事件处理或响应服务请求。它解决了一个特定问题，即我们有多条针对某些操作的请求，这些请求由多个线程发出；然而，这些操作的本质是，至少部分操作必须在某个线程上执行或进行同步。反应器对象是处理这些请求的对象：它接受来自多个线程的请求并执行它们。
- en: 'Here is an example of a reactor that can accept requests to perform a specific
    computation with caller-supplied inputs and store the results. The requests can
    come from any number of threads. Each request is allocated a slot in the array
    of results – that is the part that must be synchronized across all threads. After
    the slot is allocated, we can do the computations concurrently. To implement this
    reactor, we are going to use the atomic index to allocate unique array slots to
    each request:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个反应器的例子，它可以接受请求以使用调用者提供的输入执行特定的计算，并将结果存储起来。请求可以来自任意数量的线程。每个请求都会在结果数组中分配一个槽位——这就是必须在所有线程之间同步的部分。在槽位分配后，我们可以并发地进行计算。为了实现这个反应器，我们将使用原子索引为每个请求分配唯一的数组槽位：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The calls to `operator()` are thread-safe: any number of threads can call this
    operator simultaneously, and each call will add the result of the computation
    to the next array slot without overwriting any data produced by other calls. To
    retrieve the results from the object, we can either wait until all requests are
    done or implement another synchronization mechanism such as the publishing protocol
    to make calls to `operator()` and `print_results()` thread-safe with respect to
    each other.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对`operator()`的调用是线程安全的：任意数量的线程可以同时调用此操作符，并且每个调用都会将计算结果添加到下一个数组槽位，而不会覆盖其他调用产生的任何数据。要从对象中检索结果，我们可以等待所有请求完成，或者实现另一种同步机制，例如发布协议，以使对`operator()`和`print_results()`的调用在彼此之间是线程安全的。
- en: 'Note that usually, a reactor object processes requests asynchronously: it has
    a separate thread to execute the computations and a queue to channel all the requests
    to a single thread. We can build such a reactor by combining several patterns
    we saw earlier, for example, we can add a thread-safe queue to our basic reactor
    to get an asynchronous reactor (we are about to see an example of such a design).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通常，反应器对象异步处理请求：它有一个单独的线程来执行计算，并且有一个队列来将所有请求通道到一个线程。我们可以通过结合我们之前看到的几个模式来构建这样的反应器，例如，我们可以向基本反应器添加一个线程安全的队列来得到一个异步反应器（我们很快将看到一个这样的设计示例）。
- en: So far, we focused on starting and executing jobs, and then we wait for the
    work to complete. The next pattern focuses on handling the completion of asynchronous
    tasks.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们专注于启动和执行工作，然后等待工作完成。下一个模式专注于处理异步任务的完成。
- en: Proactor Object pattern
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Proactor 对象模式
- en: 'The Proactor pattern is used to execute asynchronous tasks, usually long-running,
    by requests from one or more threads. This sounds a lot like the Reactor, but
    the difference is what happens when a task is done: in the case of the Reactor,
    we just have to wait for the work to get done (the wait can be blocking or non-blocking,
    but in all cases, the caller initiates the check for completion). The Proactor
    object associates each task with a callback, and the callback is executed asynchronously
    when the task is done. The Reactor and the Proactor are the synchronous and asynchronous
    solutions to the same problem: handling the completion of concurrent tasks.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Proactor 模式用于通过一个或多个线程的请求来执行异步任务，通常是长时间运行的任务。这听起来很像反应器，但区别在于任务完成时发生的情况：在反应器的情况下，我们只需要等待工作完成（等待可以是阻塞的或非阻塞的，但在所有情况下，调用者都启动了完成检查）。Proactor
    对象将每个任务与一个回调关联，当任务完成时，回调异步执行。反应器和 Proactor 是处理并发任务完成的同步和异步解决方案。
- en: A proactor object typically has a queue of tasks to be executed asynchronously
    or uses another executor to schedule these tasks. Each task is submitted with
    a callback, usually a callable. The callback is executed when the task is done;
    often, the same thread that executed the task will also invoke the callback. Since
    the callback is always asynchronous, care must be taken if it needs to modify
    any shared data (for example, any data that is accessed by the thread that submitted
    the task to the proactor). If there is any data shared between the callback and
    other threads, it must be accessed in a thread-safe way.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Proactor 对象通常有一个任务队列，用于异步执行任务，或者使用另一个执行器来调度这些任务。每个任务都提交一个回调，通常是可调用的。当任务完成时执行回调；通常，执行任务的同一线程也会调用回调。由于回调总是异步的，如果它需要修改任何共享数据（例如，任何由提交任务到
    Proactor 的线程访问的数据），必须以线程安全的方式访问。
- en: 'Here is an example of a proactor object that uses the thread-safe queue from
    the previous section. In this example, each task takes one integer as input and
    computes a `double` result:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用上一节中线程安全队列的 Proactor 对象的示例。在这个例子中，每个任务接受一个整数作为输入并计算一个 `double` 结果：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The queue stores the work requests which consist of the input and the callable;
    any number of threads can call `operator()` to add requests to the queue. A more
    generic proactor might take a callable for the work request instead of having
    the computation coded into the concrete proactor object. The proactor executes
    all the requests in order on a single thread. When the requested computation is
    done, the thread invokes the callback and passes the result to it. This is how
    we may use such a proactor object:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 队列存储工作请求，这些请求由输入和可调用对象组成；任何数量的线程都可以调用 `operator()` 将请求添加到队列中。一个更通用的 Proactor
    可能会接受一个可调用对象作为工作请求，而不是将计算编码到具体的 Proactor 对象中。Proactor 按顺序在一个线程上执行所有请求。当请求的计算完成时，线程调用回调并将结果传递给它。这就是我们可能使用这样的
    Proactor 对象的方式：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that our proactor executes all callbacks on one thread, and the main thread
    does not do any output. Otherwise, we would have to protect `std::cout` with a
    mutex.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的 Proactor 在一个线程上执行所有回调，主线程不做任何输出。否则，我们就必须用互斥锁来保护 `std::cout`。
- en: The Proactor pattern is used to both execute asynchronous events and perform
    additional actions (callbacks) when these events happen. The last pattern we explore
    in this section does not execute anything but is used to react to external events.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Proactor 模式用于执行异步事件，并在这些事件发生时执行附加操作（回调）。在本节中我们探索的最后一个模式不执行任何操作，而是用于对外部事件做出反应。
- en: Monitor pattern
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视器模式
- en: The Monitor pattern is used when we need to observe, or monitor, some conditions
    and respond to certain events. Usually, a monitor runs on its own thread that
    is sleeping or waiting most of the time. The thread is awakened either by a notification
    or simply by the passage of time. Once awakened, the monitor object examines the
    state of the system it is tasked to observe. It may take certain actions if the
    specified conditions are met, then the thread goes back to waiting.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要观察或监控某些条件并对某些事件做出响应时，使用监视器模式。通常，监视器在自己的线程上运行，该线程大部分时间处于休眠或等待状态。线程可以通过通知或简单地通过时间的流逝而被唤醒。一旦唤醒，监视器对象将检查它被分配观察的系统状态。如果满足指定的条件，它可能会采取某些行动，然后线程返回等待状态。
- en: We are going to see a monitor implementation that uses a timeout; a monitor
    with a condition variable can be implemented using the same approach but with
    the waiting on notification pattern as seen earlier in this chapter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一种使用超时的监视器实现；具有条件变量的监视器可以使用相同的方法实现，但使用本章前面看到的等待通知模式。
- en: 'First, we need something to monitor. Let us say that we have several producer
    threads that do some computations and store results in an array using an atomic
    index:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些可以监控的东西。让我们假设我们有几个生产者线程执行一些计算并将结果存储在一个数组中，使用原子索引：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Our producer also stores the count of results computed by the thread in the
    `count` variable passed to it. Here is how we launch the producer threads:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的生产者还将线程计算的结果计数存储在传递给它的`count`变量中。以下是启动生产者线程的方式：
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We have one result count per thread, so each producer has its own count to
    increment. Why, then, did we make the counts atomic? Because the counts are also
    what we are going to monitor: our monitor thread will periodically report on how
    much work is done. Thus, each work count is accessed by two threads, the producer
    and the monitor, and we need to either use atomic operations or a mutex to avoid
    data races.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都有一个结果计数，因此每个生产者都有自己的计数来递增。那么，为什么我们使计数原子化呢？因为计数也是我们将要监控的内容：我们的监视器线程将定期报告完成的工作量。因此，每个工作计数被两个线程访问，即生产者和监视器，我们需要使用原子操作或互斥锁来避免数据竞争。
- en: 'The monitor is going to be a separate thread that wakes up every now and then,
    reads the values of the result counts, and reports the progress of the work:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 监视器将是一个独立的线程，它时不时地醒来，读取结果计数的值，并报告工作进度：
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The monitor can be started before the producer threads, or at any time we need
    to monitor the progress of the work, and it will report how many results are computed
    by each producer thread, for example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 监视器可以在生产者线程之前启动，或者在我们需要监控工作进度时启动，它将报告每个生产者线程计算的结果数量，例如：
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here we used five threads to compute the total of 64K results, and the monitor
    reports the counts for each thread and the total result count. To shut down the
    monitor, we need to set the `done` flag and join the monitor thread:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了五个线程来计算总共64K个结果，监视器报告了每个线程的计数和总结果计数。要关闭监视器，我们需要设置`done`标志并加入监视器线程：
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The other common variant of the Monitor pattern is the one where, instead of
    waiting on a timer, we wait on a condition. This monitor is a combination of the
    basic monitor and the pattern for waiting on a notification that we saw earlier
    in this chapter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 监视器模式的另一种常见变体是，我们不是等待计时器，而是等待一个条件。这种监视器是基本监视器和我们在本章前面看到的等待通知模式的组合。
- en: The concurrent programming community has come up with many other patterns for
    solving common problems related to concurrency; most of these can be used in C++
    programs but they are not specific to C++. There are C++-specific features such
    as atomic variables that influence the way we implement and use these patterns.
    The examples from this chapter should give you enough guidance to be able to adapt
    any other concurrent pattern to C++.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程社区已经提出了许多其他用于解决与并发相关常见问题的模式；大多数这些模式都可以用于C++程序，但它们并不特定于C++。有一些C++特有的功能，如原子变量，影响了我们实现和使用这些模式的方式。本章的示例应该足以指导你将任何其他并发模式适应到C++中。
- en: The description of execution patterns mostly concludes the brief study of C++
    patterns for concurrency. Before you turn the last page, I want to show you a
    totally different type of concurrent pattern that is just coming to C++.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 执行模式的描述基本上完成了对C++并发模式的简要研究。在你翻到最后一页之前，我想向你展示一种完全不同类型的并发模式，这种模式刚刚进入C++。
- en: Coroutine patterns in C++
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的协程模式
- en: 'Coroutines are a very recent addition to C++: they were introduced in C++20,
    and their present state is a foundation for building libraries and frameworks
    as opposed to features you should use in the application code directly. It is
    a complex feature with many subtle details, and it would take an entire chapter
    to explain what it does (there is a chapter like that in my book *The Art of Writing
    Efficient Programs*). Briefly, coroutines are functions that can suspend and resume
    themselves. They cannot be forced to suspend, a coroutine continues to execute
    until it suspends itself. They are used to implement what is known as cooperative
    multitasking, where multiple streams of execution voluntarily yield control to
    each other rather than being forcibly preempted by the OS.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是 C++ 中非常新的特性：它们是在 C++20 中引入的，目前的状态是构建库和框架的基础，而不是你应该直接在应用程序代码中使用的特性。这是一个复杂的特性，包含许多细微的细节，需要整整一章的篇幅来解释它（我的书《编写高效程序的艺术》中就有这样的章节）。简而言之，协程是可以暂停和恢复自己的函数。它们不能被强制暂停，协程会继续执行直到它自己暂停。它们用于实现所谓的协作多任务，在这种多任务中，多个执行流自愿地将控制权交给彼此，而不是被操作系统强制抢占。
- en: 'Every execution pattern we saw in this chapter, and many more, can be implemented
    using coroutines. It is, however, too early to say whether this is going to become
    a common use of coroutines in C++, so we cannot say whether a “proactor coroutine”
    will ever become a pattern. One application of coroutines, however, is well on
    the way to becoming a new pattern in C++: the coroutine generator.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们看到的每一个执行模式，以及更多，都可以使用协程来实现。然而，现在还过早地说这将成为 C++ 中协程的常见用法，所以我们不能确定“生产者协程”是否会成为一种模式。不过，协程的一个应用正在成为
    C++ 中的一个新模式：协程生成器。
- en: 'This pattern comes into play when we want to take some computation that is
    normally done with a complex loop and rewrite it as an iterator. For example,
    let us say that we have a 3D array and we want to iterate over all its elements
    and do some computation on them. This is easy enough to do with a loop:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将通常使用复杂循环完成的某些计算重写为迭代器时，这种模式就会发挥作用。例如，假设我们有一个三维数组，我们想要遍历它的所有元素并对它们进行一些计算。这用循环来做很容易：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'But it’s hard to write reusable code this way: if we need to customize the
    work we do on each array element, we have to modify the inner loop. It would be
    much easier if we had an iterator that runs over the entire 3D array. Unfortunately,
    to implement this iterator we have to turn the loops inside out: first, we increment
    `k` until it reaches `N3`; then, we increment `j` by one and go back to incrementing
    `k`, and so on. The result is a very convoluted code that reduced many a programmer
    to counting on their fingers to avoid one-off errors:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但以这种方式编写可重用代码是困难的：如果我们需要自定义对每个数组元素执行的工作，我们必须修改内部循环。如果我们有一个遍历整个三维数组的迭代器会容易得多。不幸的是，为了实现这个迭代器，我们必须将循环颠倒过来：首先，我们将
    `k` 增加直到它达到 `N3`；然后，我们将 `j` 增加 1 并回到增加 `k`，依此类推。结果是代码非常复杂，许多程序员不得不依靠手指计数来避免一次性错误：
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We even took a shortcut and gave our iterator a non-standard interface:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至走了一个捷径，给我们的迭代器提供了一个非标准的接口：
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The implementation is even more convoluted if we want to conform to the STL
    iterator interface.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要符合 STL 迭代器接口，实现过程会更加复杂。
- en: 'Problems such as this, where a complex function such as our nested loop must
    be suspended in the middle of the execution so the caller can execute some arbitrary
    code and resume the suspended function, are an ideal fit for coroutines. Indeed,
    a coroutine that produces the same sequence as our iterator looks very simple
    and natural:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题，比如我们的嵌套循环在执行过程中必须暂停，以便调用者可以执行一些任意代码并恢复暂停的函数，非常适合协程。确实，一个产生与我们的迭代器相同序列的协程看起来非常简单和自然：
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'That’s it; we have a function that takes the parameters necessary to loop over
    a 3D array, a regular nested loop, and we do something to each element. The secret
    is in that innermost line where “something” happens: the C++20 keyword `co_yield`
    suspends the coroutine and returns the value `a[i][j][k]` to the caller. It is
    very similar to the `return` operator, except `co_yield` does not exit the coroutine
    permanently: the caller can resume the coroutine, and the execution continues
    from the next line after `co_yield`.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；我们有一个函数，它接受遍历 3D 数组所需的参数，一个常规的嵌套循环，并且我们对每个元素执行一些操作。秘密在于最内层的行，其中“一些操作”发生：C++20
    关键字 `co_yield` 暂停协程并返回值 `a[i][j][k]` 给调用者。它与 `return` 操作符非常相似，但 `co_yield` 并不会永久退出协程：调用者可以恢复协程，并且执行从
    `co_yield` 之后的下一行继续。
- en: 'The use of this coroutine is also straightforward:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种协程的方法也很直接：
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The coroutine magic happens inside the generator object that is returned by
    the coroutine. Its implementation is anything but simple, and, if you want to
    write one yourself, you have to become an expert on C++ coroutines (and do so
    by reading another book or article). You can find a very minimal implementation
    in *Example 28*, and, with the help of a good reference for coroutines, you can
    understand its inner working line by line. Fortunately, if all you want is to
    write code like that shown previously, you don’t really have to learn the details
    of the coroutines: there are several open-source libraries that provide utility
    types such as the generator (with slightly different interfaces), and in C++23
    `std::generator` will be added to the standard library.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 协程的魔法发生在由协程返回的生成器对象内部。其实现方式远非简单，如果你想要自己编写，你必须成为 C++ 协程的专家（通过阅读另一本书或文章来实现）。你可以在
    *示例 28* 中找到一个非常简单的实现，并且，在协程的良好参考手册的帮助下，你可以逐行理解其内部工作原理。幸运的是，如果你只想编写像之前展示的那样简单的代码，你实际上并不需要学习协程的细节：有几个开源库提供了如生成器（接口略有不同）之类的实用类型，并且，在
    C++23 中，`std::generator` 将被添加到标准库中。
- en: 'While it is certainly easier to write the coroutine with a loop and `co_yield`
    than the convoluted inverted loop of the iterator, what is the price of this convenience?
    Obviously, you have to either write a generator or find one in a library, but
    once that is done, are there any more disadvantages to the coroutines? In general,
    a coroutine involves more work than a regular function, but the performance of
    the resulting code depends greatly on the compiler and can vary with seemingly
    insignificant changes to the code (as is the case for any compiler optimizations).
    The coroutines are still quite new and the compilers do not have comprehensive
    optimizations for them. That being said, the performance of coroutines can be
    comparable to that of the hand-crafted iterator. For our *Example 28*, the current
    (at the moment of this writing) release of Clang 17 gives the following results:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用循环和 `co_yield` 编写协程确实比迭代器的复杂倒置循环更容易，但这种便利的代价是什么？显然，你必须要么编写一个生成器，要么在库中找到一个生成器，但一旦完成，协程还有其他缺点吗？一般来说，协程比常规函数涉及更多的工作，但生成的代码的性能很大程度上取决于编译器，并且可能会因为代码看似微不足道的更改而变化（就像任何编译器优化一样）。协程仍然相当新颖，编译器还没有为它们提供全面的优化。话虽如此，协程的性能可以与手工编写的迭代器相媲美。对于我们的
    *示例 28*，当前（在撰写本文时）的 Clang 17 版本给出了以下结果：
- en: '[PRE60]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'On the other hand, GCC 13 gives an advantage to the iterator:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，GCC 13 给了迭代器一个优势：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We can expect the compilers to get better at optimizing coroutines in the future.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以期待编译器在将来能更好地优化协程。
- en: Another variant of the coroutine generator is useful when the sequence of values
    that we want to produce is not limited in advance and we want to generate new
    elements only when they are needed (lazy generator). Again, the advantage of coroutines
    is the simplicity of returning results to the caller from inside of the loop.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要生成的值序列没有预先限制，并且我们只想在需要时生成新元素（懒生成器）时，协程生成器的另一种变体是有用的。同样，协程的优势在于从循环内部向调用者返回结果的简单性。
- en: 'Here is a simple random number generator implemented as a coroutine:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的随机数生成器，实现为一个协程：
- en: '[PRE62]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This coroutine never ends: it suspends itself to return the next pseudo-random
    number `i`, and every time it is resumed, the execution jumps back into the infinite
    loop. Again, the generator is a rather complex object with a lot of boilerplate
    code that you would be better off getting from a library (or waiting until C++23).
    But once that’s done, the use of the generator is very simple:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协程永远不会结束：它会挂起自己以返回下一个伪随机数`i`，每次它被恢复时，执行都会跳回无限循环。再次强调，生成器是一个相当复杂的对象，有很多样板代码，你最好从库中获取（或者等待C++23）。但一旦完成，生成器的使用就非常简单：
- en: '[PRE63]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Every time you call `gen()`, you get a new random number (of rather poor quality
    since we have implemented one of the oldest and simplest pseudo-random number
    generators, so consider this example useful for illustration only). The generator
    can be called as many times as you need; when it is finally destroyed, so is the
    coroutine.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`gen()`，你都会得到一个新的随机数（由于我们实现了一个最古老和最简单的伪随机数生成器，所以质量相当差，所以请将此示例仅用于说明）。生成器可以调用任意多次；当它最终被销毁时，协程也会被销毁。
- en: We will likely see more design patterns that take advantage of coroutines develop
    in the coming years. For now, the generator is the only established one, and just
    recently at that, so it is fitting to conclude the last chapter of the book on
    C++ design patterns with the newest addition to our pattern toolbox.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来几年中，我们可能会看到更多利用协程的设计模式。目前，生成器是唯一确立的模式，而且刚刚确立，因此，在本书的C++设计模式最后一章中，加入我们模式工具箱的最新补充是合适的。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored common C++ solutions to the problems of developing
    concurrent software. This is a very different type of problem compared to everything
    we studied before. Our main concerns here are correctness, specifically, by avoiding
    data races, and performance. Synchronization patterns are standard ways to control
    access to shared data to avoid undefined behavior. Execution patterns are the
    basic building blocks of thread schedulers and asynchronous executors. Finally,
    the high-level patterns and guidelines for the concurrent design are the ways
    we, the programmers, keep our sanity while trying to think about all the things
    that could happen before, after, or at the same time as one another.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了开发并发软件的常见C++解决方案。与之前我们研究过的所有内容相比，这是一个非常不同类型的问题。我们在这里的主要关注点是正确性，特别是通过避免数据竞争，以及性能。同步模式是控制对共享数据访问的标准方式，以避免未定义的行为。执行模式是线程调度器和异步执行器的基本构建块。最后，并发设计的高级模式和指南是我们，程序员，在试图思考所有可能同时发生的事情之前、之后或同时发生的事情时保持理智的方法。
- en: Questions
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is concurrency?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是并发？
- en: How does C++ support concurrency?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++如何支持并发？
- en: What are synchronization design patterns?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是同步设计模式？
- en: What are execution design patterns?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是执行设计模式？
- en: What overall guidelines for the design and the architecture of concurrent programs
    should be followed?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于并发程序的设计和架构，应该遵循哪些总体指南？
- en: What is a transactional interface?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是事务接口？
- en: Assessments
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1, An Introduction to Inheritance and Polymorphism
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章，继承和多态简介
- en: Objects and classes are the building blocks of a C++ program. By combining data
    and algorithms (*code*) into a single unit, the C++ program represents the components
    of the system that it models, as well as their interactions.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象和类是C++程序的基本构建块。通过将数据和算法（*代码*）组合成一个单一单元，C++程序表示了它所模拟的系统组件，以及它们的交互。
- en: Public inheritance represents an *is-a* relationship between objects—an object
    of the derived class can be used as if it was an object of the base class. This
    relation implies that the interface of the base class, with its invariants and
    restrictions, is also a valid interface for the derived class.Unlike public inheritance,
    private inheritance says nothing about the interfaces. It expresses a *has-a*
    or *is implemented in terms of* relationship. The derived class reuses the implementation
    provided by the base class. For the most part, the same can be accomplished by
    composition. Composition should be preferred when possible; however, empty base
    optimization and (less often) virtual method overrides are valid reasons to use
    private inheritance.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公共继承表示对象之间的*is-a*关系——派生类的对象可以像基类对象一样使用。这种关系意味着基类的接口，包括其不变性和限制，也是派生类的一个有效接口。与公共继承不同，私有继承没有关于接口的说明。它表达的是*has-a*或*is
    implemented in terms of*关系。派生类重用了基类提供的实现。在大多数情况下，可以通过组合实现相同的效果。在可能的情况下应优先选择组合；然而，空基类优化和（较少见）虚方法覆盖是使用私有继承的有效理由。
- en: A polymorphic object in C++ is an object whose behavior depends on its type,
    and the type is not known at compile time (at least at the point where the behavior
    in question is requested). An object that is referred to as a base class object
    can demonstrate the behavior of the derived class if that is its true type. In
    C++, polymorphic behavior is implemented using virtual functions.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++中的多态对象是一个其行为取决于其类型且在编译时（至少在请求行为的相关点）类型未知的对象。如果一个对象被引用为基类对象，并且它确实是其派生类的类型，那么它可以表现出派生类的行为。在C++中，多态行为是通过虚函数实现的。
- en: 'Dynamic cast verifies at run time that the destination type of the cast is
    valid: it must be either the actual type of the object (the type the object was
    created with) or one if its base types. It is the latter part, checking all possible
    base types of an object, that makes dynamic casts expensive.'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态转换在运行时验证转换的目标类型是否有效：它必须是对象的实际类型（对象创建时使用的类型）或其基类型之一。正是检查对象的所有可能基类型的这部分使得动态转换变得昂贵。
- en: Chapter 2, Class and Function Templates
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章，类和函数模板
- en: A template is not a type; it is a *Factory* for many different types with similar
    structures. A template is written in terms of generic types; substituting concrete
    types for these generic types results in a type generated from the template.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板不是一种类型；它是一个为具有相似结构的许多不同类型提供服务的*工厂*。模板是用泛型类型编写的；用具体类型替换这些泛型类型将生成从模板生成的类型。
- en: There are class, function, and variable templates. Each kind of template generates
    the corresponding entities—functions in the case of function templates, classes
    (types) from class templates, and variables from variable templates.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在类模板、函数模板和变量模板。每种模板生成相应的实体——函数模板生成函数，类模板生成类（类型），变量模板生成变量。
- en: Templates can have type and non-type parameters. Type parameters are types.
    Non-type parameters can be integral or enumerated values or templates (in the
    case of variadic templates, the placeholders are also non-type parameters).
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板可以有类型参数和非类型参数。类型参数是类型。非类型参数可以是整型或枚举值或模板（在变长模板的情况下，占位符也是非类型参数）。
- en: A template instantiation is the code generated by a template. Usually, the instantiations
    are implicit; the use of a template forces its instantiation. An explicit instantiation,
    without use, is also possible; it generates a type or a function that can be used
    later. An explicit specialization of a template is a specialization where all
    generic types are specified; it is not an instantiation, and no code is generated
    until the template is used. It is only an alternative recipe for generating code
    for these specific types.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板实例化是由模板生成的代码。通常，实例化是隐式的；使用模板会强制其实例化。没有使用的情况下也可以进行显式实例化；它生成可以在以后使用的类型或函数。模板的显式特化是一种所有泛型类型都已指定的特化；它不是实例化，并且直到模板被使用之前不会生成任何代码。它只是为这些特定类型生成代码的另一种方法。
- en: Usually, the parameter pack is iterated over using recursion. The compiler will
    typically inline the code generated by this recursion, so the recursion exists
    only during compilation (as well as in the head of the programmer reading the
    code). In C++17 (and, rarely, in C++14), it is possible to operate on the entire
    pack without recursion.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，参数包是通过递归来迭代的。编译器通常会内联由这种递归生成的代码，因此递归仅在编译期间存在（以及程序员阅读代码的头部）。在C++17（以及很少见的C++14）中，可以在不递归的情况下操作整个包。
- en: Lambda expressions are essentially a compact way to declare local classes that
    can be called like functions. They are used to effectively store a fragment of
    code in a variable (or, rather, associate the code with a variable) so that this
    code can be called later.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda表达式本质上是一种声明可以像函数一样调用的局部类的方法。它们用于有效地将代码片段存储在变量中（或者更确切地说，将代码与变量关联起来），以便稍后调用此代码。
- en: Concepts impose restrictions on the template parameters. This can be used to
    avoid substituting types and instantiating a template that would lead to an error
    in the body of the template. In the more complex cases, concepts can be used to
    disambiguate the choice between multiple template overloads.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 概念对模板参数施加限制。这可以用来避免替换类型和实例化会导致模板体中发生错误的模板。在更复杂的情况下，概念可以用来消除多个模板重载之间的歧义。
- en: Chapter 3, Memory and Ownership
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章，内存和所有权
- en: Clear memory ownership, and by extension, resource ownership, is one of the
    key attributes of a good design. With clear ownership, resources are certain to
    be created and made available in time for when they are needed, maintained while
    they are in use, and released/cleaned up when no longer needed.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清晰的内存所有权，以及由此扩展的资源所有权，是良好设计的关键属性之一。有了清晰的拥有权，资源在需要时一定会被创建并可供使用，在使用期间得到维护，在不再需要时释放/清理。
- en: Resource leaks, including memory leaks; dangling handles (resource handles,
    such as pointers, references, or iterators, pointing to resources that do not
    exist); multiple attempts to release the same resource; multiple attempts to construct
    the same resource.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源泄露，包括内存泄露；悬垂句柄（资源句柄，如指针、引用或迭代器，指向不存在的资源）；多次尝试释放同一资源；多次尝试构造同一资源。
- en: Non-ownership, exclusive ownership, shared ownership, as well as conversion
    between different types of ownership and transfer of ownership.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非所有权、独占所有权、共享所有权，以及不同类型所有权的转换和所有权转移。
- en: Ownership-agnostic functions and classes should refer to objects by raw pointers
    and references if the corresponding ownership is handled through owning pointers.
    If the objects are owned by rich pointers or containers, the problem becomes more
    difficult. If the additional data contained in the rich pointer is not needed
    or a single element of a container is accessed, raw pointers and references are
    perfectly adequate. Otherwise, ideally, we would use a corresponding non-owning
    reference object like `std::string_view` or one of the views from the ranges library.
    If none is available, we may have to pass the owning object itself by reference.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于通过拥有指针处理的所有权，所有权无关的函数和类应通过原始指针和引用来引用对象。如果对象由丰富指针或容器拥有，问题会变得更加复杂。如果丰富指针中包含的额外数据不需要，或者访问容器中的单个元素，原始指针和引用就足够了。否则，理想情况下，我们会使用相应的非拥有引用对象，如`std::string_view`或范围库中的视图之一。如果没有可用的，可能不得不通过引用传递拥有对象本身。
- en: Exclusive memory ownership is easier to understand and follow the control flow
    of the program. It is also more efficient.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 独占内存所有权更容易理解，并且可以更好地跟随程序的流程控制。它也更有效率。
- en: Preferably, by allocating the object on the stack or as a data member of the
    owning class (including container classes). If reference semantics or certain
    move semantics are needed, a unique pointer should be used. For conditionally
    constructed objects, `std::optional` is a great solution.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最好是通过在栈上分配对象或作为拥有类的数据成员（包括容器类）来分配对象。如果需要引用语义或某些移动语义，应使用唯一指针。对于条件构造的对象，`std::optional`是一个很好的解决方案。
- en: Shared ownership should be expressed through a shared pointer such as `std::shared_ptr`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 共享所有权应通过共享指针，如`std::shared_ptr`来表示。
- en: Shared ownership in a large system is difficult to manage and may delay the
    deallocation of resources unnecessarily. It also has a nontrivial performance
    overhead, compared to exclusive ownership. Maintaining shared ownership in a thread-safe
    concurrent program requires very careful implementation.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在大型系统中共享所有权难以管理，并且可能不必要地延迟资源的释放。与独占所有权相比，它还有相当大的性能开销。在线程安全的并发程序中维护共享所有权需要非常谨慎的实现。
- en: 'Views such as `std::string_view`, `std::span`, and views from `std::ranges`
    are essentially non-owning rich pointers. A string view to a string is what a
    raw pointer is to a unique pointer: a non-owning object containing the same information
    as the corresponding owning object.'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如`std::string_view`、`std::span`和来自`std::ranges`的视图等视图本质上是非拥有丰富指针。一个字符串视图到字符串就像原始指针到唯一指针：一个不拥有对象，包含与相应拥有对象相同的信息。
- en: Chapter 4, Swap - From Simple to Subtle
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章，从简单到微妙——交换
- en: The swap function exchanges the state of the two objects. After the swap call,
    the objects should remain unchanged, except for the names they are accessed by.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换函数交换两个对象的状态。在交换调用之后，对象应该保持不变，除了它们被访问的名称之外。
- en: Swap is usually employed in programs that provide commit-or-rollback semantics;
    a temporary copy of the result is created first, then swapped into its final destination
    only if no errors were detected.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换通常用于提供提交或回滚语义的程序中；首先创建一个临时结果副本，然后只有在没有检测到错误的情况下才将其交换到最终目的地。
- en: The use of swap to provide commit-or-rollback semantics assumes that the swap
    operation itself cannot throw an exception or otherwise fail and leave the swapped
    objects in an undefined state.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用交换来提供提交或回滚语义假设交换操作本身不能抛出异常或以其他方式失败，并留下未定义状态的对象。
- en: A non-member swap function should always be provided, to ensure that the calls
    to non-member swap are executed correctly. A member swap function can also be
    provided, for two reasons—first, it is the only way to swap an object with a temporary,
    and second, the swap implementation usually needs access to the private data members
    of the class. If both are provided, the non-member function should call the member
    swap function on one of the two parameters.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应始终提供一个非成员交换函数，以确保非成员交换的调用能够正确执行。也可以提供一个成员交换函数，原因有两个——首先，这是唯一一种可以交换临时对象的方法，其次，交换实现通常需要访问类的私有数据成员。如果两者都提供，则非成员函数应该调用两个参数中的一个的成员交换函数。
- en: All STL containers and some other standard library classes provide a member
    function `swap()`. In addition, the non-member `std::swap()` function template
    has standard overloads for all STL types.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有STL容器和一些其他标准库类都提供了一个成员函数`swap()`。此外，非成员`std::swap()`函数模板为所有STL类型提供了标准重载。
- en: 'The `std:: qualifier` disables the argument-dependent lookup and forces the
    default `std::swap` template instantiation to be called, even if a custom swap
    function was implemented with the class. To avoid this problem, it is recommended
    to also provide an explicit instantiation of the `std::swap` template.'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::qualifier`禁用了依赖参数的查找，并强制调用默认的`std::swap`模板实例化，即使该类已实现了一个自定义的交换函数。为了避免这个问题，建议也提供一个`std::swap`模板的显式实例化。'
- en: Chapter 5, Comprehensive Look at RAII
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章，全面审视RAII
- en: Memory is the most common resource, but any object can be a resource. Any virtual
    or physical quantity that the program operates on is a resource.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存是最常见的资源，但任何对象都可以是资源。程序操作的所有虚拟或物理量都是资源。
- en: Resources should not be lost (leaked). If a resource is accessed through a handle,
    such as a pointer or an ID, that handle should not be dangling (referring to a
    resource that does not exist). Resources should be released when they are no longer
    needed, in the manner that corresponds to the way they were acquired.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源不应丢失（泄漏）。如果资源通过句柄访问，例如指针或ID，则该句柄不应悬空（指不存在的资源）。当不再需要资源时，应按获取它们的方式释放资源。
- en: Resource Acquisition Is Initialization is an idiom; it is the dominant C++ approach
    to resource management, where each resource is owned by an object, acquired in
    the constructor, and released in the destructor of that object.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源获取即初始化是一个惯用语；它是C++中资源管理的主要方法，其中每个资源都由一个对象拥有，在构造函数中获取，并在该对象的析构函数中释放。
- en: An RAII object should always be created on the stack or as a data member of
    another object. When the flow of the program leaves the scope containing the RAII
    object or the larger object containing the RAII object is deleted, the destructor
    of the RAII object is executed. This happens regardless of how the control flow
    leaves the scope.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RAII对象应始终在栈上创建或作为另一个对象的数据成员。当程序的流程离开包含RAII对象的范围或包含RAII对象的大对象被删除时，RAII对象的析构函数将被执行。这无论控制流如何离开范围都会发生。
- en: If each resource is owned by an RAII object and the RAII object does not give
    out raw handles (or the user is careful to not clone the raw handle), the handle
    can only be obtained from the RAII object and the resource is not released as
    long as that object remains.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果每个资源都由RAII对象拥有，并且RAII对象不提供原始句柄（或者用户小心地不克隆原始句柄），则句柄只能从RAII对象中获取，只要该对象保持存在，资源就不会被释放。
- en: The most frequently used is `std::unique_ptr` for memory management; `std::lock_guard`
    is used to manage mutexes.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最常用的是`std::unique_ptr`用于内存管理；`std::lock_guard`用于管理互斥锁。
- en: As a rule, RAII objects must be non-copyable. Moving an RAII object transfers
    the ownership of the resource; the classic RAII pattern does not support this,
    so most RAII objects should be non-movable (differentiate between `std::unique_ptr`
    and `const std::unique_ptr`).
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，RAII对象必须是不可复制的。移动RAII对象会转移资源的所有权；经典的RAII模式不支持这一点，因此大多数RAII对象应该是不可移动的（区分`std::unique_ptr`和`const
    std::unique_ptr`）。
- en: RAII has difficulty handing release failures, because exceptions cannot propagate
    from the destructors, and hence there is no good way to report the failure to
    the caller. For that reason, failing to release a resource often results in undefined
    behavior (this approach is sometimes taken by the C++ standard as well).
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RAII在处理释放失败时存在困难，因为异常不能从析构函数中传播，因此没有很好的方法将失败报告给调用者。因此，未能释放资源通常会导致未定义的行为（C++标准有时也采取这种方法）。
- en: Chapter 6, Understanding Type Erasure
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章，理解类型擦除
- en: Type erasure is a programming technique where the program, as written, does
    not show an explicit dependence on some of the types it uses. It is a powerful
    design tool when used for separating abstract behavior from a particular implementation.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型擦除是一种编程技术，程序本身不显示对它使用的某些类型的显式依赖。当用于将抽象行为与特定实现分离时，它是一种强大的设计工具。
- en: The implementation involves either a polymorphic object and a virtual function
    call, or a function that is implemented specifically for the erased type and is
    invoked through a function pointer. Usually, this is combined with generic programming
    to construct such polymorphic objects or generate functions from a template automatically
    and ensure that the reified type is always the same as the one provided during
    construction.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现涉及一个多态对象和虚函数调用，或者一个专门为擦除类型实现并通过函数指针调用的函数。通常，这会与泛型编程结合使用，以构建这样的多态对象或从模板自动生成函数，并确保具体化的类型始终与构造期间提供的类型相同。
- en: A program may be written in a way that avoids explicit mention of most types.
    The types are deduced by template functions and declared as `auto` or as template-deduced
    typedef types. However, the actual types of objects that are hidden by `auto`
    still depend on all types the object operates on (such as the deleter type for
    a pointer). The erased type is not captured by the object type at all. In other
    words, if you could get the compiler to tell you what this particular auto stands
    for, all types would be explicitly there. But if the type was erased, even the
    most detailed declaration of the containing object will not reveal it (such as
    `std::shared_ptr<int>` —this is the entire type, the deleter type is not there).
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序可以编写成避免明确提及大多数类型。类型是通过模板函数推导出来的，并声明为`auto`或模板推导的typedef类型。然而，被`auto`隐藏的对象的实际类型仍然取决于对象操作的所有类型（例如，指针的删除器类型）。擦除的类型根本不被对象类型捕获。换句话说，如果你能让编译器告诉你这个特定的`auto`代表什么，所有类型都会明确地在那里。但如果类型被擦除，即使是最详细的包含对象的声明也无法揭示它（例如`std::shared_ptr<int>`——这是整个类型，删除器类型不在其中）。
- en: 'The type is reified by the function that is generated for that type: while
    its signature (arguments) does not depend on the erased type, the body of the
    function does. Usually, the first step is casting one of the arguments from a
    generic pointer such as `void*` to the pointer to the erased type.'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型是通过为该类型生成的函数来具体化的：虽然其签名（参数）不依赖于擦除类型，但函数体则依赖于它。通常，第一步是将其中一个参数从`void*`等通用指针转换为擦除类型的指针。
- en: 'The performance of type erasure always incurs some overhead compared to invoking
    the same callable directly: there is always an extra indirection and the pointer
    associated with it. Almost all implementations use runtime polymorphism (virtual
    functions or dynamic casts) or the equivalent virtual table of function pointers,
    which increases both the time (indirect function calls) and memory (virtual pointers).
    The greatest overhead usually comes from additional memory allocations, necessary
    for storing objects whose size is not known at compile time. If such allocations
    can be minimized and the additional memory made local to the object, the total
    overhead at runtime may be quite small (the overhead in memory remains and is
    often increased by such optimizations).'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与直接调用相同的可调用对象相比，类型擦除总是会产生一些开销：总会有额外的间接引用及其相关的指针。几乎所有实现都使用运行时多态（虚函数或动态类型转换）或函数指针的等效虚拟表，这增加了时间和内存（虚拟指针）。最大的开销通常来自额外的内存分配，这是为了存储编译时不知道大小的对象。如果可以最小化这种分配，并将额外的内存局部化到对象中，运行时的总开销可能相当小（内存开销仍然存在，并且通常通过这种优化而增加）。
- en: Chapter 7, SFINAE, Concepts, and Overload Resolution Management
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章，SFINAE、概念和重载解析管理
- en: For each function call, it is the set of all functions with the specified name
    that are accessible from the call location (the accessibility may be affected
    by the namespaces, nested scopes, and so on).
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个函数调用，它是从调用位置（其可访问性可能受命名空间、嵌套作用域等因素影响）可访问的所有具有指定名称的函数的集合。
- en: It is the process of selecting which function in the overload set is going to
    be called, given the arguments and their types.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是根据参数及其类型选择重载集中哪个函数将被调用的过程。
- en: For template functions and member functions (and class constructors in C++17),
    type deduction determines the types of template parameters from the types of the
    function arguments. For each parameter, it may be possible to deduce the type
    from several arguments. In this case, the results of this deduction must be the
    same, otherwise, the type deduction fails. Once the template parameter types are
    deduced, the concrete types are substituted for the template parameters in all
    arguments, the return type, and the default arguments. This is a type substitution.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于模板函数和成员函数（以及C++17中的类构造函数），类型推导从函数参数的类型推导出模板参数的类型。对于每个参数，可能可以从多个参数中推导出类型。在这种情况下，这种推导的结果必须相同，否则类型推导将失败。一旦推导出模板参数的类型，就将具体类型替换到所有参数、返回类型和默认参数中的模板参数。这是一个类型替换。
- en: Type substitution, described previously, can result in invalid types, such as
    a member function pointer for a type that has no member functions. Such substitution
    failures do not generate compilation errors; instead, the failing overload is
    removed from the overload set.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述的类型替换可能导致无效的类型，例如，对于没有成员函数的类型，成员函数指针就是一个无效的类型。这种替换失败不会生成编译错误；相反，失败的函数重载将从重载集中移除。
- en: This is only in the function declaration (return type, parameter types, and
    default values). Substitution failures in the body of the function chosen by the
    overload resolution are hard errors.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这仅适用于函数声明（返回类型、参数类型和默认值）。重载解析所选函数体中的替换失败是硬错误。
- en: If each overload returns a different type, these types can be examined at compile
    time. The types must have some way to distinguish them, for example, different
    sizes or different values of embedded constants. For `constexpr` functions, we
    can also examine the return values (the function needs the body in this case).
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果每个重载返回不同的类型，这些类型可以在编译时进行检查。这些类型必须有一些方法来区分它们，例如，不同的大小或嵌入常量的不同值。对于`constexpr`函数，我们还可以检查返回值（在这种情况下，函数需要函数体）。
- en: It is used with great care and caution. By deliberately causing substitution
    failures, we can direct the overload resolution toward a particular overload.
    Generally, the desired overload is preferred unless it fails; otherwise, the variadic
    overload remains and is chosen, indicating that the expression we wanted to test
    was invalid. By differentiating between the overloads using their return types,
    we can generate a compile-time (`constexpr`) constant that can be used in conditional
    compilation.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它被谨慎地使用。通过故意造成替换失败，我们可以将重载解析引导到特定的重载。通常，除非失败，否则首选期望的重载；否则，变长参数重载仍然存在并被选择，这表明我们想要测试的表达式是无效的。通过使用它们的返回类型区分重载，我们可以生成一个编译时（`constexpr`）常量，该常量可用于条件编译。
- en: C++20 constraints offer a more natural, easier-to-understand syntax. They also
    result in much clearer error messages when a called function does not meet the
    requirements. Also, unlike SFINAE, constraints are not limited to the substituted
    parameters of function templates.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++20的约束提供了更自然、更容易理解的语法。当被调用的函数不符合要求时，它们还导致更清晰的错误消息。此外，与SFINAE不同，约束不仅限于函数模板的替换参数。
- en: The standard did not just define concepts and constraints in the language. It
    also offers a way of thinking about template restrictions. While a wide range
    of SFINAE-based techniques exists, the code is easier to read and maintain if
    the use of SFINAE is restricted to a few powerful approaches that resemble the
    use of concepts.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准不仅定义了语言中的概念和约束，还提供了一种思考模板限制的方法。虽然存在广泛的基于SFINAE的技术，但如果将SFINAE的使用限制为几种类似概念使用的方法，代码将更容易阅读和维护。
- en: Chapter 8, The Curiously Recurring Template Pattern
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章，奇特重复的模板模式
- en: 'While not very expensive in absolute numbers (a few nanoseconds at most), a
    virtual function call is several times more expensive than a non-virtual one,
    and could easily be an order of magnitude or more slower than an inlined function
    call. The overhead comes from the indirection: a virtual function is always invoked
    by a function pointer, and the actual function is unknown at compile time and
    cannot be inlined.'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然在绝对数值上并不非常昂贵（最多只有几纳秒），但虚函数调用比非虚函数调用要贵上几倍，并且可能比内联函数调用慢一个数量级或更多。这种开销来自于间接引用：虚函数总是通过函数指针来调用，而实际的函数在编译时是未知的，因此不能内联。
- en: If the compiler knows the exact function that is going to be called, it can
    optimize away the indirection and may be able to inline the function.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果编译器知道将要调用的确切函数，它可以消除间接引用并可能将函数内联。
- en: Just like the runtime polymorphic calls are made through the pointer to the
    base class, the static polymorphic calls must be also made through a pointer or
    reference to the base class. In the case of CRTP and static polymorphism, the
    base type is actually a whole collection of types generated by the base class
    template, one for each derived class. To make a polymorphic call we have to use
    a function template that can be instantiated on any of these base types.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如通过基类指针进行运行时多态调用一样，静态多态调用也必须通过基类的指针或引用来进行。在CRTP和静态多态的情况下，基类型实际上是基类模板生成的整个类型集合，每个派生类一个。为了进行多态调用，我们必须使用一个函数模板，它可以实例化在任何这些基类型上。
- en: When the derived class is called directly, the use of CRTP is quite different
    from the compile-time equivalent of the virtual functions. It becomes an implementation
    technique, where common functionality is provided to multiple derived classes,
    and each one expands and customizes the interface of the base class template.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当直接调用派生类时，CRTP的使用与编译时等价的虚函数有很大不同。它成为一种实现技术，为多个派生类提供公共功能，每个派生类都扩展并定制了基类模板的接口。
- en: 'Strictly speaking, nothing new is needed to use multiple CRTP bases: the derived
    class can inherit from several such base types, each an instantiation of a CRTP
    base class template. However, listing these based together with the correct template
    parameter (derived class itself) for each one becomes cumbersome. It is easier
    and less error-prone to declare the derived class as a variadic template with
    a template template parameter and inherit from the entire parameter pack.'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 严格来说，使用多个CRTP基类不需要任何新的东西：派生类可以继承自几个这样的基类型，每个都是CRTP基类模板的一个实例化。然而，将这些基类与每个正确的模板参数（派生类本身）一起列出变得繁琐。将派生类声明为具有模板模板参数的变长模板，并从整个参数包中继承，更容易且更不容易出错。
- en: Chapter 9, Named Arguments, Method Chaining, and the Builder Pattern
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章，命名参数、方法链和构造者模式
- en: It is easy to miscount arguments, change the wrong argument, or use an argument
    of the wrong type that happens to convert to the parameter type. Also, adding
    a new parameter requires changing all function signatures that must pass these
    parameters along.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容易误计参数数量，更改错误的参数，或者使用错误类型的参数，该参数恰好转换为参数类型。此外，添加新参数需要更改所有必须传递这些参数的功能签名。
- en: The argument values within the aggregate have explicit names. Adding a new value
    does not require changing the function signatures. Classes made for different
    groups of arguments have different types and cannot be accidentally mixed.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 聚合内的参数值具有显式名称。添加新值不需要更改功能签名。为不同参数组制作的类具有不同的类型，并且不能意外混合。
- en: The named argument idiom permits the use of temporary aggregate objects. Instead
    of changing each data member by name, we write a method to set the value of each
    argument. All such methods return a reference to the object itself and can be
    chained together in one statement.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名参数习语允许使用临时聚合对象。我们不是通过名称更改每个数据成员，而是编写一个方法来设置每个参数的值。所有这些方法都返回对对象的引用，并且可以在一个语句中连在一起。
- en: Method cascading applies multiple methods to the same object. In a method chain,
    in general, each method returns a new object and the next method applies to it.
    Often, method chaining is used to cascade methods. In this case, all chained methods
    return the reference to the original object.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法级联将多个方法应用于同一对象。在方法链中，通常，每个方法返回一个新的对象，下一个方法应用于它。通常，方法链用于级联方法。在这种情况下，所有链式方法都返回对原始对象的引用。
- en: The Builder pattern is a design pattern that uses a separate builder object
    to construct complex objects. It is used when a constructor is not sufficient
    or not easy to use to construct an object in its desired fully built state. The
    need for a builder can arise when the constructor of the object being built cannot
    be modified (a general object used for a particular purpose), when a desired constructor
    would have many similar arguments and be hard to use when the construction process
    is complex, or when the construction process is computationally expensive but
    some of the results can be reused.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造者模式是一种设计模式，它使用一个单独的构造者对象来构建复杂对象。当构造函数不足以构建对象或难以使用来构建对象在其期望的完全构建状态时，会使用它。当正在构建的对象的构造函数无法修改（用于特定目的的通用对象）时，当所需的构造函数会有许多类似参数且在构建过程复杂时难以使用，或者当构建过程计算成本高昂但某些结果可以重用时，可能需要构造者。
- en: The fluent interface is an interface that uses method chaining to present multiple
    instructions, commands, or operations that can be executed on an object. In particular,
    fluent builders are used in C++ to split complex object construction into multiple
    smaller steps. Some of these steps can be conditional or depend on other data.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流式接口是一种使用方法链来呈现可以在对象上执行的多条指令、命令或操作的接口。特别是，在C++中，流式构造者用于将复杂对象的构建分解成多个较小的步骤。其中一些步骤可以是条件性的或依赖于其他数据。
- en: Chapter 10, Local Buffer Optimization
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章，本地缓冲区优化
- en: Micro-benchmarks can measure the performance of small fragments of code in isolation.
    To measure the performance of the same fragment in the context of a program, we
    have to use a profiler.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微基准测试可以测量代码小片段的独立性能。为了在程序上下文中测量相同片段的性能，我们必须使用分析器。
- en: Processing small amounts of data usually involve a correspondingly small amount
    of computing and are therefore very fast. Memory allocation adds a constant overhead,
    not proportional to the data size. The relative impact is larger when the processing
    time is short. In addition, memory allocation may use a global lock or otherwise
    serialize multiple threads.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理少量数据通常涉及相应的小量计算，因此非常快。内存分配增加了一个常数开销，与数据大小不成比例。当处理时间短时，相对影响更大。此外，内存分配可能使用全局锁或以其他方式序列化多个线程。
- en: Local buffer optimization replaces external memory allocation with a buffer
    that is a part of the object itself. This avoids the cost, and the overhead, of
    an additional memory allocation.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地缓冲区优化用对象本身的一部分缓冲区替换外部内存分配。这避免了额外的内存分配成本和开销。
- en: The object has to be constructed and the memory for it must be allocated, regardless
    of whether any secondary allocations happen. This allocation has some cost – more
    if the object is allocated on the heap and less if it’s a stack variable – but
    that cost must be paid before the object can be used. Local buffer optimization
    increases the size of the object and therefore of the original allocation, but
    that usually does not significantly affect the cost of that allocation.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论是否发生任何次要分配，对象都必须被构造，并且为其分配内存。这种分配有一定的成本——如果对象在堆上分配，成本更高，如果是栈变量，成本更低——但必须在对象可以使用之前支付这种成本。局部缓冲区优化增加了对象的大小，因此也增加了原始分配的大小，但通常这不会显著影响分配的成本。
- en: Short string optimization involves storing string characters in a local buffer
    contained inside the string object, up to a certain length of the string.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 短字符串优化涉及将字符串字符存储在字符串对象内部的局部缓冲区中，直到字符串的某个特定长度。
- en: Small vector optimization involves storing a few elements of the vector’s content
    in a local buffer contained in the vector object.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 小向量优化涉及将向量内容的一小部分存储在向量对象内部的局部缓冲区中。
- en: Chapter 11, ScopeGuard
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章，ScopeGuard
- en: An error-safe program maintains a well-defined state (a set of invariants) even
    if it encounters an error. Exception safety is a particular kind of error safety;
    it assumes that errors are signaled by throwing expressions. The program must
    not enter an undefined state when an (allowed) expression is thrown. An exception-safe
    program may require that certain operations do not throw exceptions.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误安全程序即使在遇到错误的情况下也能保持一个良好定义的状态（一组不变量）。异常安全性是一种特定的错误安全性；它假设错误是通过抛出表达式来表示的。当抛出（允许的）表达式时，程序不得进入一个未定义的状态。异常安全程序可能需要某些操作不抛出异常。
- en: If a consistent state must be maintained across several actions, each of which
    may fail, then the prior actions must be undone if a subsequent action fails.
    This often requires that the actions do not commit fully until the end of the
    transaction is reached successfully. The final commit operation must not fail
    (for example, throw an exception), otherwise error safety cannot be guaranteed.
    The rollback operation also must not fail.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果必须在多个动作之间保持一致的状态，而这些动作中任何一个都可能失败，那么如果后续的动作失败，则必须撤销先前的动作。这通常要求动作在事务成功到达终点之前不完整地提交。最终的提交操作不能失败（例如，抛出异常），否则无法保证错误安全性。回滚操作也不能失败。
- en: RAII classes ensure that a certain action is always taken when the program leaves
    a scope, such as a function. With RAII, the closing action cannot be skipped or
    bypassed, even if the function exits the scope prematurely with an early return
    or by throwing an exception.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RAII类确保当程序离开作用域（如函数）时，总是执行某个特定的动作。使用RAII，关闭动作不能被跳过或绕过，即使函数通过提前返回或抛出异常提前退出作用域。
- en: The classic RAII needs a special class for every action. ScopeGuard automatically
    generates an RAII class from an arbitrary code fragment (at least, if lambda expressions
    are supported).
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经典的RAII（Resource Acquisition Is Initialization）需要为每个动作创建一个特殊的类。ScopeGuard能够自动从一个任意的代码片段（至少，如果支持lambda表达式的话）生成一个RAII类。
- en: If the status is returned through error codes, it cannot. If all errors in the
    program are signaled by exceptions and any return from a function is a success,
    we can detect at runtime whether an exception was thrown. The complication is
    that the guarded operation may itself take place during stack unwinding caused
    by another exception. That exception is propagating when the guard class has to
    decide whether the operation succeeded or failed, but its presence does not indicate
    the failure of the guarded operation (it may indicate that something else failed
    elsewhere). Robust exception detection must keep track of how many exceptions
    are propagating at the beginning and at the end of the guarded scope, which is
    possible only in C++17 (or using compiler extensions).
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果状态是通过错误代码返回的，那么就不能这样做。如果程序中的所有错误都通过异常来表示，并且任何函数的返回都是成功，那么我们可以在运行时检测到是否抛出了异常。复杂的是，受保护的运算可能本身就在由另一个异常引起的栈展开过程中进行。当保护类必须决定操作是成功还是失败时，该异常正在传播，但它的存在并不表示受保护的运算失败（它可能表示其他地方出了问题）。健壮的异常检测必须跟踪受保护作用域的开始和结束时传播了多少个异常，这只有在C++17（或使用编译器扩展）中才可能实现。
- en: The ScopeGuard classes are usually template instantiations. This means that
    the concrete type of the ScopeGuard is unknown to the programmer, or at least
    difficult to specify explicitly. The ScopeGuard relies on lifetime extension and
    template argument deduction to manage this complexity. A type-erased ScopeGuard
    is a concrete type; it does not depend on the code it holds. The downside is that
    type erasure requires runtime polymorphism and, most of the time, a memory allocation.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ScopeGuard类通常是模板实例化。这意味着ScopeGuard的具体类型对程序员来说是未知的，或者至少难以明确指定。ScopeGuard依赖于生命周期扩展和模板参数推导来管理这种复杂性。类型擦除的ScopeGuard是一个具体类型；它不依赖于它所包含的代码。缺点是类型擦除需要运行时多态性，并且大多数情况下需要内存分配。
- en: Chapter 12, Friend Factory
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章，友元工厂
- en: A non-member friend function has the same access to the members of the class
    as a member function.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非成员友元函数具有与成员函数相同的对类成员的访问权限。
- en: Granting friendship to a template makes every instantiation of this template
    a friend; this includes instantiations of the same template but with different,
    unrelated, types.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将友元授予模板会使该模板的每个实例化都成为友元；这包括相同模板的实例化，但具有不同、无关的类型。
- en: Binary operators implemented as member functions are always called on the left-hand-side
    operand of the operator, with no conversions allowed for that object. Conversions
    are allowed for the right-hand-side operand, according to the type of the argument
    of the member operator. This creates an asymmetry between expressions such as
    `x + 2` and `2 + x`, where the latter cannot be handled by a member function since
    the type of `2` (`int`) does not have any.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为成员函数实现的二元运算符始终在运算符的左侧操作数上调用，不允许对该对象进行转换。允许对右侧操作数进行转换，根据成员运算符的参数类型。这导致表达式如`x
    + 2`和`2 + x`之间存在不对称，因为后者不能由成员函数处理，因为`2`的类型（`int`）没有任何转换。
- en: The first operand of the inserter is always the stream, not the object that
    is printed. Therefore, a member function would have to be on that stream, which
    is a part of the standard library; it cannot be extended by the user to include
    user-defined types.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入器的第一个操作数始终是流，而不是要打印的对象。因此，成员函数必须在该流上，这是标准库的一部分；用户不能扩展它以包括用户定义的类型。
- en: While the details are complex, the main difference is that user-defined conversions
    (implicit constructors and conversion operators) are considered when calling non-template
    functions but, for template functions, the argument types must match the parameter
    types (almost) exactly, and no user-defined conversions are permitted.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然细节很复杂，但主要区别在于，在调用非模板函数时，会考虑用户定义的转换（隐式构造函数和转换运算符），但对于模板函数，参数类型必须与参数类型（几乎）完全匹配，不允许用户定义的转换。
- en: Defining an in situ friend function (with the definition immediately following
    the declaration) in a class template causes every instantiation of that template
    to generate one non-template, non-member function with the given name and parameter
    types in the containing scope.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类模板中定义一个就地友元函数（定义紧随声明之后）会导致该模板的每个实例化都在包含的作用域中生成一个具有给定名称和参数类型的非模板、非成员函数。
- en: Chapter 13, Virtual Constructors and Factories
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章，虚构造函数和工厂
- en: There are several reasons, but the simplest is that the memory must be allocated
    in the amount `sizeof(T)`, where `T` is the actual object type, and the `sizeof()`
    operator is `constexpr` (a compile-time constant).
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有几个原因，但最简单的原因是内存必须以`sizeof(T)`的数量分配，其中`T`是实际的对象类型，而`sizeof()`运算符是`constexpr`（编译时常量）。
- en: The Factory pattern is a creational pattern that solves the problem of creating
    objects without having to explicitly specify the type of the object.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂模式是一种创建型模式，它解决了在不需要显式指定对象类型的情况下创建对象的问题。
- en: While in C++ the actual type has to be specified at the construction point,
    the Factory pattern allows us to separate the point of construction from the place
    where the program has to decide what object to construct and identify the type
    using some alternative identifier, a number, a value, or another type.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然 C++ 中必须在构造点指定实际类型，但工厂模式允许我们将构造点与程序必须决定构建什么对象以及使用某种替代标识符（如数字、值或另一种类型）来识别类型的点分开。
- en: The virtual copy constructor is a particular kind of factory where the object
    to construct is identified by the type of another object we already have. A typical
    implementation involves a virtual `clone()` method that is overridden in every
    derived class.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟拷贝构造函数是一种特殊的工厂，其中要构建的对象由我们已有的另一个对象的类型来识别。一个典型的实现涉及在每个派生类中重写的虚拟 `clone()` 方法。
- en: The Template pattern describes the design where the overall control flow is
    dictated by the base class, with derived classes providing customizations at certain
    predefined points. In our case, the overall control flow is that of factory construction,
    and the customization point is the act of construction of an object (memory allocation
    and constructor invocation).
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板模式描述了一种设计，其中整体控制流程由基类决定，而派生类在预定义的某些点上提供定制。在我们的情况下，整体控制流程是工厂构建，定制点是构建对象的行为（内存分配和构造函数调用）。
- en: The Builder pattern is used when it is necessary (or just more convenient) to
    delegate the work of constructing an object to another class instead of doing
    the complete initialization in the constructor. An object that constructs other
    objects of different types depending on some run-time information using the factory
    method is also a builder. In addition to the factory itself, such builders, or
    factory classes, usually have other run-time data that is used for constructing
    objects and must be stored in another object – in our case, the factory object,
    which is also the builder object.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建造者模式在需要（或更方便）将构建对象的工作委托给另一个类而不是在构造函数中完成完整初始化时使用。一个根据某些运行时信息使用工厂方法构建不同类型对象的对象也是一个建造者。除了工厂本身之外，这样的建造者或工厂类通常还有其他运行时数据，用于构建对象，并且必须存储在另一个对象中——在我们的例子中，是工厂对象，它也是建造者对象。
- en: "Chapter 14, The Template Method Pattern and the \LNon-Virtual Idiom"
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章，模板方法模式和非虚拟习语
- en: A behavioral pattern describes a way to solve a common problem by using a specific
    method to communicate between different objects.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行为模式描述了一种通过使用特定方法在不同对象之间进行通信来解决常见问题的方法。
- en: The template method pattern is a standard way to implement an algorithm that
    has a rigid *skeleton,* or the overall flow of control, but allows for one or
    more customization points for specific kinds of problems.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板方法模式是一种标准的实现算法的方式，该算法有一个严格的 *骨架*，或整体控制流程，但允许一个或多个定制点来处理特定类型的问题。
- en: The Template Method lets the sub-classes (derived types) implement specific
    behaviors of the otherwise generic algorithm. The key to this pattern is the way
    the base and the derived types interact.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板方法允许子类（派生类型）实现其他通用算法的特定行为。这个模式的关键是基类和派生类型之间的交互方式。
- en: The more common hierarchical approach to design sees the low-level code provide
    *building blocks* from which the high-level code builds the specific algorithm,
    by combining them in a particular flow of control. In the template pattern, the
    high-level code does not determine the overall algorithm and is not in control
    of the overall flow. The lower-level code controls the algorithm and determines
    when the high-level code is called to adjust specific aspects of the execution.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更常见的分层设计方法是将低级代码提供 *构建块*，高级代码通过特定的控制流程将它们组合起来构建特定的算法。在模板模式中，高级代码不决定整体算法，也不控制整体流程。低级代码控制算法并决定何时调用高级代码来调整执行的特定方面。
- en: It is a pattern where the public interface of a class hierarchy is implemented
    by non-virtual public methods of the base class and the derived classes contain
    only virtual private methods (as well as any necessary data and non-virtual methods
    needed to implement them).
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一种模式，其中类层次结构的公共接口由基类的非虚拟公共方法实现，而派生类只包含虚拟私有方法（以及实现它们所需的任何必要数据和非虚拟方法）。
- en: A public virtual function performs two separate tasks – it provides the interface
    (since it is public) and also modifies the implementation. A better separation
    of concerns is to use virtual functions only to customize the implementation and
    to specify the common interface using the non-virtual functions of the base class.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公共虚拟函数执行两个独立的任务——它提供接口（因为它公开）并修改实现。更好的关注点分离是仅使用虚拟函数来自定义实现，并使用基类的非虚拟函数来指定公共接口。
- en: Once the NVI is employed, virtual functions can usually be made private. One
    exception is when the derived class needs to invoke a virtual function of the
    base class to delegate part of the implementation. In this case, the function
    should be made protected.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦采用了NVI（Non-Virtual Interface），通常可以将虚拟函数设置为私有。一个例外是当派生类需要调用基类的虚拟函数以委托部分实现时。在这种情况下，该函数应设置为受保护的。
- en: Destructors are called in *nested* order, starting from the most derived class.
    When the destructor for the derived class is done, it calls the destructor of
    the base class. By that time, the *extra* information that the derived class contained
    is already destroyed, and only the base portion is left. If the base class destructor
    were to call a virtual function, it would have to be dispatched to the base class
    (since the derived class is gone by then). There is no way for the base class
    destructor to call the virtual functions of the derived class.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 析构函数是按照*嵌套*顺序调用的，从最派生的类开始。当派生类的析构函数完成时，它会调用基类的析构函数。到那时，派生类包含的*额外*信息已经被销毁，只剩下基类部分。如果基类的析构函数调用一个虚拟函数，它必须被调度到基类（因为那时派生类已经不存在了）。基类的析构函数没有方法调用派生类的虚拟函数。
- en: The fragile base class problem manifests itself when a change to the base class
    unintentionally breaks the derived class. While not specific to the template method,
    it affects, potentially, all object-oriented designs, including ones based on
    the template pattern. In the simplest example, changing the non-virtual public
    function in the base class, in a way that changes the names of the virtual functions
    called to customize the behavior of the algorithm, will break all existing derived
    classes because their current customizations, implemented by the virtual functions
    with the old names, would suddenly stop working. To avoid this problem, the existing
    customization points should not be changed.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当对基类的更改无意中破坏了派生类时，就会显现出脆弱基类问题。虽然这不是模板方法的特有现象，但它可能影响所有面向对象的设计，包括基于模板模式的设计。在最简单的例子中，如果以改变调用以自定义算法行为所调用的虚拟函数名称的方式更改基类中的非虚拟公共函数，那么所有现有的派生类都将被破坏，因为它们当前的定制，通过具有旧名称的虚拟函数实现，将突然停止工作。为了避免这个问题，不应更改现有的定制点。
- en: Chapter 15, Policy-Based Design
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章，基于策略的设计
- en: The Strategy pattern is a behavioral pattern that allows the user to customize
    a certain aspect of the behavior of the class by selecting an algorithm that implements
    this behavior from a set of provided alternatives, or by providing a new implementation.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 策略模式是一种行为模式，它允许用户通过从提供的一组替代算法中选择一个实现该行为的算法，或者通过提供一个新的实现，来自定义类的一定行为方面。
- en: While the traditional OOP Strategy applies at runtime, C++ combines generic
    programming with the Strategy pattern in a technique known as policy-based design.
    In this approach, the primary class template delegates certain aspects of its
    behavior to the user-specified policy types.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然传统的面向对象策略在运行时适用，但C++通过一种称为基于策略设计的技术将泛型编程与策略模式相结合。在这种方法中，主要类模板将某些行为方面委托给用户指定的策略类型。
- en: In general, there are almost no restrictions on the policy type, although the
    particular way in which the type is declared and used imposes certain restrictions
    by convention. For example, if a policy is invoked as a function, then any callable
    type can be used. On the other hand, if a specific member function of the policy
    is called, the policy must necessarily be a class and provide the required member
    function. Template policies can be used as well but must match the specified number
    of template parameters exactly.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，对策略类型几乎没有限制，尽管类型声明的特定方式和使用方式按照惯例施加了某些限制。例如，如果策略作为一个函数被调用，则可以使用任何可调用类型。另一方面，如果调用策略的特定成员函数，策略必然是一个类，并提供所需的成员函数。模板策略也可以使用，但必须与指定的模板参数数量完全匹配。
- en: The two primary ways are composition and inheritance. The composition should
    generally be preferred; however, many policies in practice are empty classes with
    no data members and can benefit from empty base class optimization. Private inheritance
    should be preferred unless the policy must also modify the public interface of
    the primary class. Policies that need to operate on the primary policy-based class
    itself often have to employ CRTP. In other cases, when the policy object itself
    does not depend on the types used in the construction of the primary template,
    the policy behavior can be exposed through a static member function.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要有两种方式：组合和继承。组合通常应该被优先考虑；然而，实践中许多策略是空类，没有数据成员，并且可以从空基类优化中受益。除非策略还必须修改主类的公共接口，否则应该优先考虑私有继承。需要操作基于策略的主类本身的策略通常必须使用CRTP。在其他情况下，当策略对象本身不依赖于主模板构建中使用的类型时，策略行为可以通过静态成员函数公开。
- en: 'As a general rule, policies that contain only constants and are used to constrain
    the public interface are easier to write and maintain. However, there are several
    cases when injecting public member functions through the base class policies is
    preferred: when we also need to add member variables to the class or when the
    complete set of public functions would be difficult to maintain or lead to conflicts.'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常情况下，只包含常量并用于约束公共接口的策略更容易编写和维护。然而，在某些情况下，通过基类策略注入公共成员函数是首选的：当我们还需要向类中添加成员变量时，或者当完整的公共函数集难以维护或可能导致冲突时。
- en: The primary drawback is complexity, in various manifestations. Policy-based
    types with different policies are, generally, different types (the only alternative,
    type erasure, usually carries a prohibitive runtime overhead). This may force
    large parts of the code to be templated as well. Long lists of policies are difficult
    to maintain and use correctly. For this reason, care should be taken to avoid
    creating unnecessary or hard-to-justify policies. Sometimes a type with two sufficiently
    unrelated sets of policies is better to be split into two separate types.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要的缺点是复杂性，以各种形式表现出来。具有不同策略的策略类型通常是不同的类型（唯一的替代方案，类型擦除，通常具有禁止的运行时开销）。这可能会迫使代码的大部分内容也要模板化。长列表的策略难以维护和正确使用。因此，应避免创建不必要的或难以证明合理的策略。有时，具有两个足够不相关的策略集的类型最好分成两个单独的类型。
- en: Chapter 16, Adapters and Decorators
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章，适配器和装饰器
- en: The Adapter is a very general pattern that modifies an interface of a class
    or a function (or a template, in C++) so it can be used in a context that requires
    a different interface but similar underlying behavior.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器是一个非常通用的模式，它修改了一个类或函数（或在C++中的模板）的接口，使其可以在需要不同接口但具有相似底层行为的上下文中使用。
- en: The Decorator pattern is a more narrow pattern; it modifies the existing interface
    by adding or removing behavior but does not convert an interface into a completely
    different one.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装饰器模式是一个更窄的模式；它通过添加或删除行为来修改现有接口，但不会将接口转换为完全不同的接口。
- en: In the classic OOP implementation, both the decorated class and the Decorator
    class inherit from a common base class. This has two limitations; the most important
    one is that the decorated object preserves the polymorphic behavior of the decorated
    class but cannot preserve the interface that is added in a concrete (derived)
    decorated class and was not present in the base class. The second limitation is
    that the Decorator is specific to a particular hierarchy. We can remove both limitations
    using the generic programming tools of C++.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在经典的面向对象实现中，被装饰的类和装饰器类都继承自一个公共基类。这有两个限制；最重要的是，被装饰的对象保留了被装饰类的多态行为，但不能保留在具体（派生）装饰类中添加的接口，而这个接口在基类中不存在。第二个限制是装饰器特定于特定的层次结构。我们可以使用C++的泛型编程工具来消除这两个限制。
- en: In general, a Decorator preserves as much of the interface of the decorated
    class as possible. Any functions the behavior of which is not modified are left
    unchanged. For that reason, public inheritance is commonly used. If a Decorator
    has to forward most calls to the decorated class explicitly, then the inheritance
    aspect is less important, and composition or private inheritance can be used.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，装饰器尽可能地保留被装饰类的接口。任何行为未被修改的函数都保持不变。因此，公共继承被广泛使用。如果一个装饰器必须显式地将大多数调用转发到被装饰的类，那么继承方面就不那么重要了，可以使用组合或私有继承。
- en: Unlike Decorators, adapters usually present a very different interface from
    that of the original class. Composition is often preferred in this case. The exception
    is compile-time adapters that modify the template parameters but otherwise are
    essentially the same class template (similar to template aliases). These adapters
    must use public inheritance.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与装饰器不同，适配器通常与原始类的接口非常不同。在这种情况下，通常更倾向于使用组合。例外的是编译时适配器，它们修改模板参数，但本质上仍然是相同的类模板（类似于模板别名）。这些适配器必须使用公有继承。
- en: The main limitation is that it cannot be applied to template functions. It also
    cannot be used to replace function arguments with expressions containing those
    arguments.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要限制是它不能应用于模板函数。它也不能用来用包含这些参数的表达式替换函数参数。
- en: Template aliases are never considered by the argument type deduction when function
    templates are instantiated. Both adapter and policy patterns can be used to add
    or modify the public interface of a class.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板别名在函数模板实例化时永远不会被考虑。适配器和策略模式都可以用来添加或修改类的公共接口。
- en: Adapters are easy to stack (compose) to build a complex interface one function
    at a time. The features that are not enabled do not need any special treatment
    at all; if the corresponding adapter is not used, then that feature is not enabled.
    The traditional policy pattern requires predetermined slots for every pattern.
    With the exception of the default arguments after the last explicitly specified
    one, all policies, even the default ones, must be explicitly specified. On the
    other hand, the adapters in the middle of the stack do not have access to the
    final type of the object, which complicates the implementation. The policy-based
    class is always the final type, and using CRTP, this type can be propagated into
    the policies that need it.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器很容易堆叠（组合）以逐步构建一个复杂的接口。未启用的功能根本不需要任何特殊处理；如果未使用相应的适配器，则该功能将不会启用。传统的策略模式需要为每个模式预定槽位。除了最后一个显式指定的默认参数之后的所有策略，即使是默认策略，也必须显式指定。另一方面，堆栈中间的适配器无法访问对象的最终类型，这使实现变得复杂。基于策略的类总是最终类型，使用CRTP，这种类型可以传播到需要它的策略中。
- en: Chapter 17, The Visitor Pattern and Multiple Dispatch
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章，访问者模式与多分派
- en: The Visitor pattern provides a way to separate the implementation of algorithms
    from the objects they operate on; in other words, it is a way to add operations
    to classes without modifying them by writing new member functions.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问者模式提供了一种将算法的实现与它们操作的对象的实现分离的方法；换句话说，这是一种在不修改类的情况下通过编写新成员函数向类添加操作的方法。
- en: The Visitor pattern allows us to extend the functionality of class hierarchies.
    It can be used when the source code of the class is not available for modification
    or when such modifications would be difficult to maintain.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问者模式允许我们扩展类层次结构的功能。它可以在类源代码不可用或修改此类修改难以维护时使用。
- en: Double dispatch is the process of dispatching a function call (selecting the
    algorithm to run) based on two factors. Double dispatch can be implemented at
    runtime using the Visitor pattern (virtual functions provide the single dispatch)
    or at compile time using templates or compile-time visitors.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双重分派是基于两个因素来调度函数调用（选择要运行的算法）的过程。双重分派可以通过使用访问者模式（虚拟函数提供单分派）在运行时实现，或者通过使用模板或编译时访问者在编译时实现。
- en: The classic visitor has a circular dependency between the visitor class hierarchy
    and the visitable class hierarchy. While the visitable classes do not need to
    be edited when a new visitor is added, they do need to be recompiled when the
    visitor hierarchy changes. The latter must happen every time a new visitable class
    is added, hence a dependency circle. The Acyclic Visitor breaks this circle by
    using cross-casting and multiple inheritance.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经典的访问者类层次结构与可访问类层次结构之间存在循环依赖。虽然当添加新的访问者时，可访问类不需要被编辑，但当访问者层次结构发生变化时，它们需要重新编译。后者必须在每次添加新的可访问类时发生，因此产生依赖循环。无环访问者通过使用交叉转换和多继承来打破这个循环。
- en: A natural way to accept a visitor into an object composed of smaller objects
    is to visit each of these objects one by one. This pattern, implemented recursively,
    ends up visiting every built-in data member contained in an object and does so
    in a fixed, predetermined order. Hence, the pattern maps naturally onto the requirement
    for serialization and deserialization, where we must deconstruct an object into
    a collection of built-in types, then restore it.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受访问者进入由更小对象组成的对象的一种自然方式是逐个访问这些对象。这种通过递归实现的模式最终会访问对象中包含的每个内置数据成员，并且以固定的、预定的顺序进行。因此，该模式自然映射到序列化和反序列化的需求，我们必须将对象解构为内置类型的集合，然后恢复它。
- en: Chapter 18, Patterns for Concurrency
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章，并发模式
- en: Concurrency is the property of a program that allows multiple tasks to execute
    at the same time or partially overlapping in time. Usually, concurrency is achieved
    through the use of multiple threads.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并发是程序的一种属性，允许多个任务同时执行或在时间上部分重叠。通常，通过使用多个线程来实现并发。
- en: 'C++11 has the basic support for writing concurrent programs: threads, mutexes,
    and condition variables. C++14 and C++17 added several convenience classes and
    utilities, but the next major addition to concurrency features of C++ is C++20:
    here, we have several new synchronization primitives as well as the introduction
    of the coroutines.'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++11 为编写并发程序提供了基本支持：线程、互斥锁和条件变量。C++14 和 C++17 添加了几个便利类和工具，但 C++ 并发功能的主要新增是在
    C++20：在这里，我们有了几个新的同步原语以及协程的引入。
- en: Synchronization patterns are the common solutions to the basic problems of accessing
    shared data. Usually, they provide ways to arrange exclusive access to the data
    that is modified by multiple threads or is accessed by some threads while being
    modified by others.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步模式是解决访问共享数据基本问题的常见解决方案。通常，它们提供了安排对由多个线程修改或由某些线程在修改时访问的数据的独占访问的方法。
- en: Execution patterns are the standard ways to arrange asynchronous execution of
    some computations using one or more threads. These patterns offer ways to initiate
    the execution of some code and receive the results of this execution without the
    caller being responsible for the execution itself (some other entity in the program
    has that duty).
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行模式是使用一个或多个线程来安排某些计算异步执行的标准方式。这些模式提供了启动某些代码执行并接收执行结果的方法，而调用者本身并不负责执行（程序中的其他实体承担这一职责）。
- en: 'The most important guideline for design for concurrency is modularity; when
    applies specifically to concurrency, it means building concurrent software from
    components that satisfy certain restrictions on their behavior in concurrent programs.
    The most important of these restrictions is the thread safety guarantee: generally,
    it is much easier to build concurrent software from components that allow a wide
    range of thread-safe operations.'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计并发的最重要的指导原则是模块化；当具体应用于并发时，这意味着从满足其在并发程序中行为一定限制的组件构建并发软件。这些限制中最重要的是线程安全保证：通常，从允许广泛线程安全操作的组件构建并发软件要容易得多。
- en: 'In order to be useful in concurrent programs, any data structure or component
    must provide a transactional interface. An operation is a transaction if it performs
    a well-defined complete computation and leaves the system in a well-defined state.
    A simplified way to identify which operations are and are not transactions is
    this: if a concurrent program executes each operation under lock but there are
    no order guarantees between the operations, is the state of the system guaranteed
    to be well-defined? If it isn’t, then some of the operations should be executed
    as a sequence without releasing the lock. That sequence is a transaction; the
    operations that are the steps of the sequence are not transactions by themselves.
    It should not be the responsibility of the caller to arrange these operations
    in a sequence. Instead, the data structure or component should offer the interface
    for performing the entire transaction as a single operation.'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在并发程序中发挥作用，任何数据结构或组件都必须提供事务接口。一个操作如果是执行一个定义明确的完整计算并将系统置于一个定义明确的状态，则称为事务。识别哪些操作是事务以及哪些不是的一个简化方法是：如果一个并发程序在锁定状态下执行每个操作，但操作之间没有顺序保证，那么系统的状态是否可以保证是定义明确的？如果不行，那么一些操作应该作为一个序列执行，而不释放锁。这个序列就是一个事务；序列中的操作本身不是事务。不应该由调用者负责安排这些操作的顺序。相反，数据结构或组件应该提供接口，以便将整个事务作为一个单一操作执行。
