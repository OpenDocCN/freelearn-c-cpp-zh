- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: The Basics of std::vector
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::vector的基本原理
- en: '`std::vector` is a fundamental component of C++ programming. This chapter will
    explore `std::vector` as a dynamic array, discussing its utility in various programming
    contexts. By the end of the chapter, you should be adept at declaring, initializing,
    and manipulating vectors. These skills will enable you to utilize `std::vector`
    effectively in diverse applications. It will provide a solid foundation for understanding
    the broader set of data structures and algorithms of the **Standard Template**
    **Library** (**STL**).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`是C++编程的一个基本组成部分。本章将探讨`std::vector`作为一个动态数组，讨论其在各种编程环境中的实用性。到本章结束时，你应该能够熟练地声明、初始化和操作向量。这些技能将使你能够在各种应用中有效地使用`std::vector`。它将为理解更广泛的数据结构和算法的**标准模板库**（**STL**）打下坚实的基础。'
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: The significance of `std::vector`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::vector`的重要性'
- en: Declaring and initializing `std::vector`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明和初始化`std::vector`
- en: Accessing elements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问元素
- en: Adding and removing elements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加和删除元素
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: The significance of std::vector
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::vector`的重要性'
- en: In C++, `std::vector` is a frequently chosen data structure. While beginners
    might initially see parallels between it and the basic arrays in C, the advantages
    of `std::vector` become evident with deeper exploration. Additionally, a solid
    grasp of `std::vector` facilitates a smoother transition to understanding other
    components of STL.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，`std::vector`是一个常用的数据结构。虽然初学者可能会将其与C中的基本数组看到相似之处，但随着更深入的探索，`std::vector`的优势变得明显。此外，对`std::vector`的牢固掌握有助于更顺利地过渡到理解STL的其他组件。
- en: Both vectors and arrays function as containers for collections of elements.
    The critical distinction between them lies in their flexibility and capabilities.
    Arrays are static in size, set at declaration time, and cannot be altered afterward.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 向量和数组都作为元素集合的容器。它们之间的关键区别在于它们的灵活性和功能。数组在大小上是静态的，在声明时设置，之后不能更改。
- en: In contrast, vectors are dynamic. They can expand or contract based on the operations
    performed on them. Unlike arrays, which commit to a fixed memory block upon declaration,
    vectors dynamically manage memory. They frequently allocate extra memory to anticipate
    future growth, optimizing efficiency and flexibility. While arrays offer simple
    index-based element access and modification, vectors provide a broader set of
    functions, including methods for inserting, deleting, and locating elements.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，向量是动态的。它们可以根据对它们的操作进行扩展或收缩。与在声明时承诺一个固定内存块的数组不同，向量动态管理内存。它们经常分配额外的内存来预测未来的增长，优化效率和灵活性。虽然数组提供简单的基于索引的元素访问和修改，但向量提供更广泛的功能，包括插入、删除和定位元素的方法。
- en: The primary advantage of `std::vector` is its combination of dynamic resizing
    and optimized performance. Traditional C++ arrays have their size set at compile
    time. If an array is declared to hold 10 elements, it’s constrained to that capacity.
    However, in many real-world scenarios, the volume of data isn’t determined until
    runtime. This is where `std::vector` shines.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`的主要优势是其动态调整大小和优化性能的结合。传统的C++数组在编译时设置其大小。如果一个数组被声明为包含10个元素，它将受到该容量的限制。然而，在许多实际场景中，数据的量直到运行时才能确定。这正是`std::vector`大放异彩的地方。'
- en: A basic comparison of C-style arrays and std::vector
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C风格数组和std::vector的基本比较
- en: Acting as a dynamic array, `std::vector` can adjust its size during program
    execution. It efficiently manages its memory, reallocating not for each new addition,
    but in larger chunks to maintain a balance between performance and adaptability.
    Thus, rather than pre-committing to a specific size and risking either memory
    waste or a shortage, `std::vector` dynamically responds to varying data demands.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为动态数组，`std::vector`可以在程序执行期间调整其大小。它高效地管理其内存，不是为每个新添加的元素重新分配，而是在较大的块中重新分配，以保持性能和适应性的平衡。因此，`std::vector`动态地响应不断变化的数据需求。
- en: Here are two code examples that demonstrate the contrast between using a C-style
    array and `std::vector`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个代码示例，展示了使用 C 风格数组和 `std::vector` 之间的对比。
- en: 'The following code demonstrates the use of a C-style array:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了 C 风格数组的使用：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the example output:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, we do the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们执行以下操作：
- en: Declare a C-style dynamic array with a size of `5`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个大小为 `5` 的 C 风格动态数组。
- en: Initialize the dynamic array.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化动态数组。
- en: Print the contents of the array.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印数组的内容。
- en: Resize the array to a new size (e.g., `7`).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数组调整到新大小（例如，`7`）。
- en: Copy the elements from the old array to the new one.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将旧数组中的元素复制到新数组中。
- en: Deallocate the old array.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放旧数组。
- en: Update the pointer to the new array.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新指针到新数组。
- en: Print the contents of the resized array.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印调整大小后的数组的内容。
- en: Get the size of the resized array.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取调整大小后数组的大小。
- en: Deallocate the resized array when done.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，释放调整大小后的数组。
- en: 'In contrast, the following code demonstrates the use of `std::vector`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，以下代码演示了 `std::vector` 的使用：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the example output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By way of contrast with the C-style version, in this example, we do the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C 风格版本进行对比，在这个例子中，我们执行以下操作：
- en: Declare `std::vector` with initial values.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明具有初始值的 `std::vector`。
- en: Print the contents of the vector.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印向量的内容。
- en: Resize. This operation is easy with `std::vector`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整大小。使用 `std::vector` 进行此操作很容易。
- en: Print again to see the change.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打印以查看变化。
- en: Get the size. This operation is simple with the `size()` member function.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取大小。这个操作通过 `size()` 成员函数很简单。
- en: In the initial example, the C-style array is constrained by its fixed size.
    Modifying its size typically requires a non-trivial procedure. Conversely, `std::vector`
    can adjust its size effortlessly and provides a `size()` method to determine the
    number of elements it holds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始示例中，C 风格数组受其固定大小的限制。修改其大小通常需要非平凡的程序。相反，`std::vector` 可以轻松调整其大小，并提供一个 `size()`
    方法来确定它包含的元素数量。
- en: Beyond its dynamic resizing capability, `std::vector` further simplifies memory
    management compared to traditional arrays. With `std::vector`, there’s no need
    for explicit memory allocations or deallocations as it internally handles these
    tasks. This approach minimizes the risk of memory leaks and streamlines the development
    process. As a result, many C++ developers, regardless of their experience level,
    prefer using `std::vector` over raw arrays for convenience and safety.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其动态调整大小的能力之外，`std::vector` 与传统数组相比，进一步简化了内存管理。使用 `std::vector`，不需要显式进行内存分配或释放，因为它内部处理这些任务。这种方法最小化了内存泄漏的风险，并简化了开发过程。因此，许多
    C++ 开发者，无论经验水平如何，都更喜欢使用 `std::vector` 而不是原始数组，以方便和安全。
- en: Let’s look at an example that contrasts how a legacy C-style array manages memory
    and how `std::vector` makes this easier and safer.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，对比传统的 C 风格数组如何管理内存，以及 `std::vector` 如何使这一过程更简单、更安全。
- en: Comparison of C-style arrays and std::vector for memory management
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C 风格数组和 `std::vector` 在内存管理方面的比较
- en: First, let us consider an example of a C-style array with manual memory management.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一个具有手动内存管理的 C 风格数组的例子。
- en: 'In this example, we’ll use dynamic memory allocation (`new` and `delete`) to
    simulate some of the resizing capabilities of `std::vector`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用动态内存分配（`new` 和 `delete`）来模拟 `std::vector` 的一些调整大小功能：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the example output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, we do the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们执行以下操作：
- en: Dynamically allocate a C-style array with a size of `5`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态分配一个大小为 `5` 的 C 风格数组。
- en: Populate the array.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充数组。
- en: 'Simulate a resize: allocate a larger array and copy the data.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟调整大小：分配一个更大的数组并复制数据。
- en: Populate the rest of the new array.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充新数组的其余部分。
- en: Print the array’s content.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印数组的内容。
- en: Clean up the allocated memory.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理分配的内存。
- en: Now, let us consider an example of `std::vector` with built-in memory management.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个具有内置内存管理的 `std::vector` 的例子。
- en: 'Using `std::vector`, you don’t have to allocate or deallocate memory manually;
    it is managed internally:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::vector`，您不需要手动分配或释放内存；它由内部管理：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the example output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The steps in this example include the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的步骤包括以下内容：
- en: Create `std::vector` with a size of `5`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个大小为 `5` 的 `std::vector`。
- en: Populate the vector.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充向量。
- en: Resizing is straightforward with `push_back()` or `resize()`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `push_back()` 或 `resize()` 进行调整大小非常直接。
- en: Print the vector’s contents.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印向量的内容。
- en: There’s no need for explicit memory deallocation.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有必要进行显式的内存释放。
- en: In the first example, the challenges of manual memory management are evident.
    Failing to use `delete` appropriately can result in memory leaks. On the other
    hand, the second example highlights the efficiency of `std::vector`, which internally
    manages memory, eliminating the need for manual resizing and memory operations
    and enhancing the development process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，手动内存管理的挑战显而易见。未能适当地使用 `delete` 可能会导致内存泄漏。另一方面，第二个例子突出了 `std::vector`
    的效率，它内部管理内存，消除了手动调整大小和内存操作的需求，并提高了开发过程。
- en: Traditional arrays come with a basic set of operations. In contrast, `std::vector`
    offers various member functions that provide advanced data manipulation and retrieval
    capabilities. These functions will be explored in subsequent sections.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 传统数组提供了一套基本操作。相比之下，`std::vector` 提供了各种成员函数，这些函数提供了高级的数据操作和检索能力。这些函数将在后续章节中探讨。
- en: In C++ development, `std::vector` is a fundamental tool. Its flexibility makes
    it a go-to choice for various applications, from game development to complex software
    projects. The built-in safety mechanisms against common memory issues underscore
    its value. As an STL component, `std::vector` encourages consistent and optimal
    coding practices by integrating well with other STL elements.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 开发中，`std::vector` 是一个基本工具。其灵活性使其成为从游戏开发到复杂软件项目等各种应用的优选选择。内置的防止常见内存问题的安全机制凸显了其价值。作为一个
    STL 组件，`std::vector` 通过与其他 STL 元素的良好集成，鼓励一致的、最优的编码实践。
- en: This section explored the fundamental differences between C-style arrays and
    `std::vector`. Unlike static C-style arrays, we learned that `std::vector` offers
    dynamic resizing and robust memory management, which are critical for developing
    flexible and efficient applications. The comparison detailed how `std::vector`
    abstracts away low-level memory handling, thus minimizing common errors associated
    with manual memory management.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了 C 风格数组和 `std::vector` 之间的基本区别。与静态的 C 风格数组不同，我们了解到 `std::vector` 提供了动态调整大小和强大的内存管理，这对于开发灵活和高效的应用程序至关重要。比较详细地说明了
    `std::vector` 如何抽象出低级内存处理，从而最小化与手动内存管理相关的常见错误。
- en: Understanding `std::vector` is beneficial because it is one of the most widely
    used sequence containers in C++ programming. `std::vector` supports dynamic growth
    in contiguously allocated memory and random access iteration and is compatible
    with a range of algorithms in the STL. We also discussed how `std::vector` provides
    a safer and more intuitive interface for managing collections of objects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 `std::vector` 是有益的，因为它是在 C++ 编程中最广泛使用的序列容器之一。`std::vector` 支持在连续分配的内存中动态增长，支持随机访问迭代，并且与
    STL 中的多种算法兼容。我们还讨论了 `std::vector` 如何提供更安全、更直观的接口来管理对象集合。
- en: The following section will build upon this foundational knowledge. We will learn
    the syntax for declaring `std::vector` and the various methods available for initializing
    it. This will include an examination of default, copy, and move semantics as they
    pertain to vectors.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将在此基础上构建。我们将学习声明 `std::vector` 的语法以及初始化它的各种方法。这包括对默认、复制和移动语义的考察，这些语义与向量相关。
- en: Declaring and initializing std::vector
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明和初始化 std::vector
- en: Having established the foundational knowledge of `std::vector` in C++ development,
    it’s time to delve into its practical applications—expressly, how to declare and
    initialize vectors.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 开发中建立了 `std::vector` 的基础知识后，是时候深入探讨其实际应用了——具体来说，是如何声明和初始化向量的。
- en: The essence of `std::vector` lies in its dynamic nature. Unlike traditional
    arrays with fixed sizes, vectors can grow or shrink as necessary, making them
    a versatile tool for developers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 的本质在于其动态性。与固定大小的传统数组不同，向量可以根据需要增长或缩小，这使得它们成为开发者手中多才多艺的工具。'
- en: Declaring a vector
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明一个向量
- en: The performance of `std::vector` stems from its design, which combines the benefits
    of a contiguous memory layout (such as arrays) with the flexibility of dynamic
    resizing. It reserves memory to hold that many elements when initialized with
    a specified size. But if the vector fills up and more capacity is needed, it allocates
    a larger memory block, transfers the existing elements, and deallocates the old
    memory. This dynamic resizing process is optimized to reduce overhead, ensuring
    that vectors remain efficient. The fusion of contiguous storage and automated
    memory management distinguishes `std::vector` as an essential component in the
    C++ ecosystem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`的性能源于其设计，它结合了连续内存布局（如数组）的优点和动态调整大小的灵活性。当以指定的大小初始化时，它会预留足够的内存来存储这些元素。但如果向量填满并且需要更多容量，它会分配一个更大的内存块，转移现有元素，并释放旧内存。这个动态调整大小的过程被优化以减少开销，确保向量保持高效。连续存储和自动内存管理的结合使`std::vector`成为C++生态系统中的基本组件。'
- en: 'To declare a basic `std::vector`, use the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个基本的`std::vector`，请使用以下：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This line of code initializes an empty `std::vector` named `vec` specifically
    designed to hold values of type `int`. (`int` is the template parameter inside
    the `<>` for `std::vector's` type.) `std::vector` is a dynamic array, which means
    that even though `vec` begins with a size of `0`, its capacity can grow as needed.
    As you insert integers into `vec`, the container will automatically allocate memory
    to accommodate the increasing number of elements. This dynamic resizing makes
    `std::vector` a versatile and widely used container in C++ for situations where
    the number of elements isn’t known in advance or might change over time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码初始化了一个名为`vec`的空`std::vector`，专门设计用来存储`int`类型的值。（`int`是`std::vector`类型模板参数`<>`内的内容。）`std::vector`是一个动态数组，这意味着尽管`vec`的初始大小为`0`，但其容量可以根据需要增长。当你向`vec`中插入整数时，容器将自动分配内存以适应元素数量的增加。这种动态调整大小使得`std::vector`成为C++中一种多用途且广泛使用的容器，适用于元素数量事先未知或可能随时间变化的情况。
- en: 'When creating `std::vector`, it’s possible to specify its initial size. This
    can be beneficial if you have prior knowledge about the number of elements you’ll
    need to store:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建`std::vector`时，可以指定其初始大小。如果你事先知道需要存储的元素数量，这可能会很有益：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, `std::vector` named `vec` is initialized with space for
    10 integers. By default, these integers will be value-initialized, which means
    they will be set to `0` for fundamental data types such as `int`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，名为`vec`的`std::vector`被初始化为有10个整数的空间。默认情况下，这些整数将被值初始化，这意味着对于`int`这样的基本数据类型，它们将被设置为`0`。
- en: 'If you wish to initialize the elements with a specific value, you can provide
    a second argument during the vector’s construction:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望使用特定的值初始化元素，可以在构造向量时提供第二个参数：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `std::vector` is declared with 10 integers, and each of those 10 integers
    is initialized to the value of `5`. This approach ensures efficient memory allocation
    and desired value initialization in a single step.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用10个整数声明了`std::vector`，并且这10个整数都被初始化为`5`的值。这种方法确保了在单步中高效地分配内存和初始化所需值。
- en: Initializing a vector
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化向量
- en: 'In C++11 and later versions, `std::vector` initialization became more straightforward
    with the introduction of initializer lists. This allows developers to specify
    the initial values of the vector directly within curly braces:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11及以后的版本中，随着初始化列表的引入，`std::vector`的初始化变得更加简单。这允许开发者在花括号内直接指定向量的初始值：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding statement creates an instance of `std::vector` named `vec` and
    initializes it with five integers. This method provides a concise way to declare
    and populate a vector simultaneously. This is just one way to initialize `std::vector`.
    Depending on your needs, there are many ways this can be done:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句创建了一个名为`vec`的`std::vector`实例，并使用五个整数对其进行初始化。这种方法提供了一种简洁的方式来声明和填充向量，这是初始化`std::vector`的一种方法。根据你的需求，还有许多其他方法可以实现这一点：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`std::vector` is a versatile templated container capable of storing various
    data types, not just primitives such as `int`. You can store objects of custom
    classes, other standard library types, and pointers. This adaptability makes `std::vector`
    suitable for a wide range of applications and scenarios.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`是一个多功能的模板容器，能够存储各种数据类型，而不仅仅是像`int`这样的原始类型。你可以存储自定义类的对象、其他标准库类型和指针。这种适应性使得`std::vector`适用于广泛的用途和场景。'
- en: 'Furthermore, vectors provide a straightforward mechanism for copying the contents
    of one vector to another. This is known as **copy initialization**. The following
    code demonstrates this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，向量提供了一种将一个向量的内容复制到另一个向量的简单机制。这被称为 **复制初始化**。以下代码演示了这一点：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, `vec2` is initialized as an exact copy of `vec1`, meaning `vec2`
    will contain the same elements as `vec1`. This copy initialization ensures that
    the original vector (`vec1`) remains unchanged and that the new vector (`vec2`)
    is provided with a separate copy of the data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`vec2` 被初始化为 `vec1` 的精确副本，这意味着 `vec2` 将包含与 `vec1` 相同的元素。这种复制初始化确保原始向量（`vec1`）保持不变，并且新向量（`vec2`）提供了数据的单独副本。
- en: 'One of the true strengths of STL containers is their ability to handle user-defined
    types seamlessly, extending beyond primitive data types such as `int` or `double`.
    This flexibility is a testament to its templated design, which allows it to adapt
    to various data types while maintaining type safety. In the upcoming example,
    we illustrate this versatility by utilizing `std::vector` with a custom class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: STL 容器的真正优势之一是它们能够无缝地处理用户定义的类型，而不仅仅是像 `int` 或 `double` 这样的原始数据类型。这种灵活性是对其模板设计的证明，它允许它适应各种数据类型同时保持类型安全。在接下来的示例中，我们通过使用自定义类来展示这种多功能性：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the example output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, `std::vector` is first used to manage objects of the custom
    `Person` class. It demonstrates the ease with which `std::vector` accommodates
    and manages memory for built-in and user-defined types.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，首先使用 `std::vector` 来管理自定义 `Person` 类的对象。它展示了 `std::vector` 如何轻松地容纳和管理内置类型和用户定义类型的内存。
- en: In C++, while static arrays have their utility, they come with fixed sizes that
    can sometimes be limiting. On the other hand, `std::vector` provides a dynamic
    and flexible alternative.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，尽管静态数组有其用途，但它们具有固定的大小，有时可能受到限制。另一方面，`std::vector` 提供了一种动态和灵活的替代方案。
- en: Understanding the declaration and initialization of vectors is essential for
    effective C++ programming. `std::vector` is a versatile tool suitable for various
    tasks, from implementing complex algorithms to developing large-scale applications.
    Incorporating `std::vector` into your programming practices can enhance the efficiency
    and maintainability of your code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 理解向量的声明和初始化对于有效的 C++ 编程至关重要。`std::vector` 是一种多用途的工具，适用于从实现复杂算法到开发大型应用程序的各种任务。将
    `std::vector` 纳入编程实践可以提高代码的效率和可维护性。
- en: In this section, we covered the syntactical aspects of working with `std::vector`.
    Specifically, we delved into the proper techniques for declaring `std::vector`
    of various types and the diverse strategies for initializing these vectors to
    suit different programming scenarios.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们涵盖了与 `std::vector` 一起工作的语法方面。具体来说，我们深入探讨了声明不同类型 `std::vector` 的正确技术以及初始化这些向量以适应不同编程场景的多种策略。
- en: We learned that declaring `std::vector` involves specifying the type of elements
    it will contain and, optionally, the initial size and default value for the elements.
    We discovered multiple methods regarding initialization, including direct-list
    initialization and initializing with a specific range of values. This section
    underscored the flexibility of `std::vector`, showing how it can be tailored to
    start with a predefined set of elements or be constructed from existing collections.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到声明 `std::vector` 需要指定它将包含的元素类型，以及可选的初始大小和元素的默认值。我们发现了多种初始化方法，包括直接列表初始化和使用特定值范围的初始化。本节强调了
    `std::vector` 的灵活性，展示了它如何从预定义的元素集开始或从现有集合中构建。
- en: This information is crucial for practical C++ development as it provides a foundation
    for using `std::vector` effectively. Proper initialization can lead to performance
    optimizations and ensure the vector is in a valid state appropriate for its intended
    use. The ability to declare and initialize vectors succinctly and correctly is
    a foundational skill for leveraging the power of the STL in real-world C++ applications.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息对于实际的 C++ 开发至关重要，因为它为有效地使用 `std::vector` 提供了基础。适当的初始化可以导致性能优化并确保向量处于适合其预期用途的有效状态。能够简洁且正确地声明和初始化向量是利用
    STL 在实际 C++ 应用程序中发挥其强大功能的基础技能。
- en: In the next section, *Accessing elements*, we will focus on the operations that
    allow us to retrieve and modify the contents of a `std::vector`. We will learn
    about random access, which allows for the efficient retrieval and modification
    of elements at any position within the vector. Additionally, we will explore how
    to access the first and last elements, and the importance of understanding and
    managing vector size to ensure robust and error-free code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节“访问元素”中，我们将关注允许我们检索和修改`std::vector`内容的操作。我们将学习随机访问，它允许高效地检索和修改向量中任何位置的元素。此外，我们还将探讨如何访问第一个和最后一个元素，以及理解和管理向量大小的重要性，以确保代码健壮且无错误。
- en: Accessing elements
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问元素
- en: Having discussed the declaration and initialization of `std::vector`, our focus
    now shifts to accessing and manipulating the contained data. Multiple methods
    in C++ allow you to access vector elements with both speed and safety.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了`std::vector`的声明和初始化之后，我们的重点现在转向访问和操作包含的数据。C++中的多个方法允许您以速度和安全的方式访问向量元素。
- en: Random access
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机访问
- en: The subscript `[]` operator allows direct element access via indices, similar
    to arrays. In the following example, given a vector, the expression `numbers[1]`
    returns the value `20`. However, using this operator doesn’t involve boundary
    checks. An index that is out of range, such as `numbers[10]`, results in undefined
    behavior, leading to unpredictable outcomes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下标`[]`操作符允许通过索引直接访问元素，类似于数组。在以下示例中，给定一个向量，表达式`numbers[1]`返回值`20`。然而，使用此操作符不涉及边界检查。超出范围的索引，如`numbers[10]`，会导致未定义的行为，从而导致不可预测的结果。
- en: 'This is shown in the following example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下示例中显示：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the example output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For safer index-based access, `std::vector` offers the `at()` member function.
    It performs an index boundary check and throws an `out_of_range` exception for
    invalid indices.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更安全地基于索引访问，`std::vector`提供了`at()`成员函数。它执行索引边界检查，并在无效索引上抛出`out_of_range`异常。
- en: 'Here is an example of this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是此示例的一个例子：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Caution is paramount when accessing vector elements. While C++ favors performance,
    it often sidesteps safety checks, as evident with the subscript operator. Hence,
    developers must ensure valid access through careful index management or by employing
    safer methods such as `at()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 访问向量元素时，谨慎至关重要。虽然C++优先考虑性能，但它经常绕过安全检查，例如下标操作符所示。因此，开发者必须通过仔细的索引管理或采用更安全的方法（如`at()`）来确保有效的访问。
- en: Accessing the first and last elements
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问第一个和最后一个元素
- en: The first and last elements can be accessed with `front()` and `back()`, respectively.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`front()`和`back()`分别访问第一个和最后一个元素。
- en: 'This is shown in the following example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下示例中显示：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The example output is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 示例输出如下：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Vector size
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量大小
- en: With `std::vector`, understanding the structure and the amount of data it contains
    is essential. The `size()` member function provides the current count of elements
    stored within the vector. Invoking this function on an instance of `std::vector`
    will return the number of elements it holds. This count represents the active
    elements and can be used to determine the range for valid indexing. The returned
    value is of type `size_t`, an unsigned integer type suitable for representing
    sizes and counts. It’s beneficial when iterating through a vector, performing
    size comparisons, or allocating space based on the number of vector elements.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::vector`时，理解其结构和包含的数据量是至关重要的。`size()`成员函数提供了向量中当前存储的元素数量。在`std::vector`实例上调用此函数将返回它持有的元素数量。这个计数代表活动元素，可以用来确定有效索引的范围。返回值是`size_t`类型，这是一种无符号整数类型，适合表示大小和计数。当遍历向量、执行大小比较或根据向量元素数量分配空间时，这很有用。
- en: 'Let us look at the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, the `size()` function is called on the data vector to
    retrieve and display the number of elements it contains. The result, as expected,
    indicates that there are five elements in the vector.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，对数据向量调用`size()`函数以检索和显示它包含的元素数量。结果正如预期的那样，表明向量中有五个元素。
- en: In summary, `std::vector` offers a suite of tools, ranging from the efficient
    subscript operator to the safer `at()` method, and the convenient `front()` and
    `back()` methods. Understanding these tools is vital to efficiently and safely
    access and manipulate data within a vector.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`std::vector`提供了一套工具，从高效的索引操作符到更安全的`at()`方法，再到方便的`front()`和`back()`方法。理解这些工具对于有效地和安全地访问和操作向量中的数据至关重要。
- en: In this section, we concentrated on the methodologies for retrieving and inspecting
    the contents of `std::vector`. We learned about the capabilities of `std::vector`
    to provide random access to its elements, enabling direct access to any element
    using its index with constant time complexity. This section also detailed the
    methods to access a vector’s first and last elements through the `front()` and
    `back()` member functions, respectively.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们专注于检索和检查`std::vector`内容的方法。我们了解了`std::vector`提供随机访问其元素的能力，这使得我们可以使用其索引以常数时间复杂度直接访问任何元素。本节还详细介绍了通过`front()`和`back()`成员函数分别访问向量第一个和最后一个元素的方法。
- en: Moreover, we discussed the importance of understanding and utilizing the `size()`
    member function to determine the number of elements currently stored in `std::vector`.
    This understanding is instrumental in ensuring that our access patterns remain
    within the bounds of the vector, thereby preventing out-of-range errors and undefined
    behavior.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们讨论了理解并利用`size()`成员函数的重要性，以确定当前存储在`std::vector`中的元素数量。这种理解对于确保我们的访问模式保持在向量的界限内至关重要，从而防止越界错误和未定义的行为。
- en: The skills acquired from this section are essential, as they form the basis
    of interacting with `std::vector`’s contents. These access patterns are core to
    using vectors effectively in C++ applications, whether for reading or modifying
    elements. The ability to directly access elements in a vector leads to efficient
    algorithms and supports a wide range of everyday programming tasks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节中获得的能力是至关重要的，因为它们是交互`std::vector`内容的基础。这些访问模式是使用向量在C++应用程序中有效使用的关键，无论是读取还是修改元素。直接访问向量中的元素可以导致高效的算法并支持广泛的日常编程任务。
- en: The following section will advance our knowledge further by addressing how to
    modify the size and contents of `std::vector`. We will explore how to add elements
    to a vector and the various methods available to remove them. This will include
    understanding how vectors manage their capacity and its implications on performance.
    We will learn why and how to use `.empty()` as a more performant alternative to
    checking whether the size is `0`, and we will delve into clearing all elements
    from a vector.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将通过解决如何修改`std::vector`的大小和内容来进一步扩展我们的知识。我们将探讨如何向向量中添加元素以及删除它们的各种方法。这包括理解向量如何管理其容量及其对性能的影响。我们将学习为什么以及如何使用`.empty()`作为检查大小是否为`0`的更高效替代方案，并且我们将深入了解如何从向量中清除所有元素。
- en: Adding and removing elements
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和删除元素
- en: One of the advantages of `std::vector` over traditional arrays is its ability
    to resize dynamically. As applications evolve, so do data requirements; static
    data structures do not cut it. In this section, we will explore dynamic data management
    with `std::vector`, learning to seamlessly add to and remove from vectors while
    making sure we are staying safe.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的数组相比，`std::vector`的一个优点是它能够动态地调整大小。随着应用程序的发展，数据需求也在变化；静态数据结构不再适用。在本节中，我们将探索使用`std::vector`进行动态数据管理，学习无缝地向向量中添加和删除元素，同时确保我们的操作是安全的。
- en: Adding elements
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加元素
- en: Let’s start with adding elements. The `push_back()` member function is possibly
    the most straightforward way to add an element to the end of a vector. Suppose
    you have `std::vector<int> scores;` and wish to append a new score, say `95`.
    You would simply invoke `scores.push_back(95);`, and voilà, your score is added.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加元素开始。`push_back()`成员函数可能是向向量末尾添加元素最直接的方法。假设你有`std::vector<int> scores;`并希望添加一个新的分数，比如`95`。你只需调用`scores.push_back(95);`，哇，你的分数就添加成功了。
- en: 'Here’s a simple illustrative code example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的示例代码：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When run, this program will display the vector’s size before and after adding
    a score and the score itself, demonstrating the `push_back()` function in action.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此程序时，它将显示在添加分数之前和之后的向量大小以及分数本身，从而演示了`push_back()`函数的实际应用。
- en: 'What if you need to insert a score at a specific position, not just at the
    end? The `insert()` function becomes your best ally. If you wanted to insert a
    score of `85` at the third position, you’d use an iterator to specify the location:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在特定位置插入一个分数，而不仅仅是末尾，怎么办？`insert()`函数将成为您的最佳助手。如果您想在第三位置插入分数`85`，您将使用迭代器来指定位置：
- en: '`scores.insert(scores.begin() +` `2, 85);`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`scores.insert(scores.begin() + 2, 85);`'
- en: Remember that vector indexing starts at `0`; the `+ 2` is for the third position.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，向量索引从`0`开始；`+ 2`是为了第三位。
- en: 'Let’s expand on the previous example by incorporating the use of the `insert()`
    function in the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在以下代码中结合使用`insert()`函数来扩展前面的例子：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This program will showcase the original scores, display the scores after appending
    one to the end, and inserting one in the third position. It illustrates the `push_back()`
    and `insert()` functions in action.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将展示原始分数，显示在末尾追加一个分数后的分数，以及在第三位置插入一个分数。它展示了`push_back()`和`insert()`函数的作用。
- en: And vectors don’t stop there. The `emplace_back()` and `emplace()` functions
    allow for constructing elements directly inside the vector. This means fewer temporary
    objects and a potential boost in performance, especially with complex data types.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 向量并没有停止在这里。`emplace_back()`和`emplace()`函数允许在向量内部直接构造元素。这意味着更少的临时对象，并且可能提高性能，尤其是在复杂的数据类型中。
- en: 'Let’s consider a `Person` class that has a few data members. To create a new
    `Person` object, a string concatenation operation is performed. Using `emplace_back()`
    and `emplace()` will avoid extra temporary objects and copy/move operations that
    `push_back()` might cause, offering a performance boost. The following code demonstrates
    this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个具有几个数据成员的`Person`类。要创建一个新的`Person`对象，会执行字符串连接操作。使用`emplace_back()`和`emplace()`将避免`push_back()`可能引起的额外临时对象和复制/移动操作，从而提高性能。以下代码演示了这一点：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This example clarifies how `emplace_back()` and `emplace()` allow for the direct
    construction of objects inside the vector. Using `push_back()` might create temporary
    `Person` objects. Using `emplace_back()` directly constructs the object in place,
    potentially avoiding temporary object creation. Using `insert()` might create
    temporary `Person` objects. Using `emplace()` directly constructs the object in
    place at the specified location. This is particularly beneficial with types such
    as `Person`, where the constructor might involve resource-intensive operations
    (such as string concatenation). In such scenarios, the performance advantage of
    `emplace` methods over their `push` counterparts becomes evident.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了`emplace_back()`和`emplace()`如何允许在向量内部直接构造对象。使用`push_back()`可能会创建临时的`Person`对象。使用`emplace_back()`直接在原地构造对象，可能避免临时对象的创建。使用`insert()`可能会创建临时的`Person`对象。使用`emplace()`直接在指定位置构造对象。这对于像`Person`这样的类型尤其有益，其构造函数可能涉及资源密集型操作（如字符串连接）。在这种情况下，`emplace`方法相对于它们的`push`对应方法的性能优势变得明显。
- en: Removing elements
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除元素
- en: But life isn’t just about adding. Sometimes, we need to remove data. The `pop_back()`
    function removes the last element of a vector, reducing its size by one. If, however,
    you’re looking to remove from a specific position or even a range of positions,
    the `erase()` function will be your go-to.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但生活不仅仅是加法。有时，我们需要删除数据。`pop_back()`函数从向量中删除最后一个元素，将其大小减少一个。然而，如果您想从特定位置或一系列位置删除，`erase()`函数将是您的首选。
- en: The erase-remove idiom
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: erase-remove惯用法
- en: In C++ and its STL, there are established coding patterns that experienced developers
    often use. One notable pattern is the **erase-remove** idiom, which facilitates
    the removal of specific elements from a container based on defined criteria. This
    section will detail the functionality of this idiom and discuss newer alternatives
    introduced in C++20.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++及其STL中，有经验开发者经常使用的编码模式。一个值得注意的模式是**erase-remove**惯用法，它根据定义的准则从容器中删除特定元素。本节将详细说明这个惯用法的功能，并讨论C++20中引入的新替代方案。
- en: 'STL containers, especially `std::vector`, do not provide a straightforward
    method to remove elements based on a predicate. Instead, they provide separate
    methods: one to rearrange elements (using `std::remove` and `std::remove_if`)
    and another to erase them.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: STL容器，特别是`std::vector`，没有提供一种直接根据谓词删除元素的方法。相反，它们提供了单独的方法：一个用于重新排列元素（使用`std::remove`和`std::remove_if`），另一个用于删除它们。
- en: 'Here’s how the erase-remove idiom works:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何实现erase-remove惯用法的：
- en: '`std::remove` or `std::remove_if` is used to reorder elements of the container.
    Elements that need to be removed are moved to the end.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`std::remove`或`std::remove_if`对容器的元素进行重新排序。需要移除的元素被移动到末尾。
- en: These algorithms return an iterator pointing to the start of the removed elements.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些算法返回一个指向被移除元素起始位置的迭代器。
- en: The container’s `erase` method is then used to remove the elements from the
    container physically.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用容器的`erase`方法从容器中物理移除元素。
- en: 'A classic example removes all instances of `0` from `std::vector<int>`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的例子是从`std::vector<int>`中移除所有`0`的实例：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Modernizing with std::erase and std::erase_if
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用std::erase和std::erase_if进行现代化
- en: 'Recognizing the ubiquity and somewhat counterintuitive nature of the erase-remove
    idiom, C++20 introduced direct utility functions to simplify this operation: `std::erase`
    and `std::erase_if`. These functions merge the two-step process into one, offering
    a more intuitive and less error-prone approach.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 认识到erase-remove惯用语的普遍性和某种程度上反直觉的特性，C++20引入了直接实用函数来简化此操作：`std::erase`和`std::erase_if`。这些函数将两步过程合并为一步，提供了一种更直观且更不易出错的解决方案。
- en: 'Using the previous example, removing all instances of `0` with C++20 becomes:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前的例子，在C++20中移除所有`0`的实例变得如下：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'No longer does one have to invoke separate algorithms and remember to handle
    both stages of the process. Similarly, to remove elements based on a predicate,
    you would do the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不再需要调用单独的算法并记住处理过程的两个阶段。同样，为了根据谓词移除元素，您将执行以下操作：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: While the erase-remove idiom has been a cornerstone of STL-based C++ programming
    for years, modern C++ continues to evolve and simplify common patterns. With `std::erase`
    and `std::erase_if`, developers now have more straightforward tools to remove
    container elements, leading to cleaner and more readable code. It’s a testament
    to the ongoing commitment of the C++ community to enhance the language’s user-friendliness
    while retaining its power and expressiveness.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然erase-remove惯用语多年来一直是基于STL的C++编程的基石，但现代C++仍在不断发展和简化常见模式。有了`std::erase`和`std::erase_if`，开发者现在有更直接的工具来移除容器元素，从而产生更干净、更易读的代码。这是C++社区持续致力于增强语言的用户友好性、同时保留其强大和表达力的承诺的证明。
- en: Note that `std::vector` has been ingeniously designed to optimize memory operations.
    While one might intuitively expect the underlying array to resize every time an
    element is added or removed, that isn’t the case. Instead, when a vector grows,
    it often allocates more memory than immediately necessary, anticipating future
    additions. This strategy minimizes the frequent memory reallocations, which could
    be computationally expensive. Conversely, when elements are removed, the vector
    doesn’t always shrink its allocated memory immediately. This behavior provides
    a balance between memory usage and performance. However, it is worth noting that
    the specifics of these memory management decisions can vary by the C++ library
    implementation. As such, while the behavior is consistent across implementations
    in terms of the interface, the internal memory management nuances might differ.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`std::vector`已被巧妙地设计以优化内存操作。虽然人们可能会直观地期望在添加或移除元素时，底层数组会进行大小调整，但这并不是事实。相反，当向量增长时，它通常会分配比立即需要的更多内存，以预测未来的添加。这种策略最小化了频繁的内存重新分配，这可能非常昂贵。相反，当移除元素时，向量并不总是立即缩小其分配的内存。这种行为在内存使用和性能之间提供了平衡。然而，值得注意的是，这些内存管理决策的具体细节可能因C++库实现而异。因此，虽然接口方面的行为在实现之间是一致的，但内部内存管理的细微差别可能不同。
- en: Capacity
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容量
- en: You can use the `capacity()` member function to know how much memory has been
    allocated. The `std::vector::capacity()` member function returns the amount of
    memory allocated for the vector, which may be greater than its actual size. This
    value represents the maximum number of elements the vector can hold before reallocating
    memory, ensuring efficient growth patterns without frequent memory operations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`capacity()`成员函数来了解已分配了多少内存。`std::vector::capacity()`成员函数返回为向量分配的内存量，这可能会大于其实际大小。此值表示向量在重新分配内存之前可以容纳的最大元素数，确保在无需频繁内存操作的情况下高效增长。
- en: 'This can be seen in the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在以下内容中看到：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The exact output may be different for your compiler, but here is an example
    output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的输出可能因编译器而异，但以下是一个示例输出：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This example illustrates how the size and capacity of a `std::vector` instance
    change as elements are added and removed. Examining the outputs shows that the
    capacity often doesn’t correspond directly with the size, highlighting the memory
    optimization techniques.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了随着元素的添加和删除，`std::vector` 实例的大小和容量如何变化。检查输出显示，容量通常并不直接与大小相对应，突出了内存优化技术。
- en: Prefer using empty() when possible
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当可能时，优先使用 empty()
- en: In C++, when the primary intention is to check whether a container is devoid
    of elements, it’s recommended to use the `.empty()` member function instead of
    comparing `.size()` or `.capacity()` with `0`. The `.empty()` function provides
    a direct way to ascertain whether a container has any elements, and in many implementations,
    it can offer a performance advantage. Specifically, `.empty()` typically has a
    constant time complexity of `O(1)`, whereas `.size()` might have a linear time
    complexity of `O(n)` for some container types, making `.empty()` a more efficient
    choice for mere emptiness checks. Using `.empty()` can lead to more concise and
    potentially faster code, especially in performance-critical sections.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，当主要目的是检查容器是否为空时，建议使用 `.empty()` 成员函数而不是将 `.size()` 或 `.capacity()` 与 `0`
    进行比较。`.empty()` 函数提供了一种直接确定容器是否有元素的方法，并且在许多实现中，它可以提供性能优势。具体来说，`.empty()` 通常具有常数时间复杂度
    `O(1)`，而 `.size()` 对于某些容器类型可能具有线性时间复杂度 `O(n)`，这使得 `.empty()` 对于简单的空检查来说是一个更有效的选择。使用
    `.empty()` 可以使代码更加简洁，并可能更快，尤其是在性能关键部分。
- en: Clearing all elements
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除所有元素
- en: The `clear()` function of `std::vector` is a powerful utility that swiftly erases
    all elements within the container. After invoking this function, the `size()`
    of the vector will return `0`, indicating its now-empty state. However, a crucial
    aspect to be aware of is that any references, pointers, or iterators that previously
    pointed to the elements within the vector are invalidated by this operation. This
    also holds for any past-the-end iterators. Interestingly, while `clear()` purges
    all the elements, it doesn’t alter the capacity of the vector. This means that
    the memory allocated for the vector remains unchanged, allowing for efficient
    subsequent insertions without immediate reallocation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 的 `clear()` 函数是一个强大的实用工具，可以迅速删除容器内的所有元素。调用此函数后，向量的 `size()` 将返回
    `0`，表示其现在为空状态。然而，需要注意的一个关键方面是，任何之前指向向量内元素的引用、指针或迭代器都将因这次操作而失效。这也适用于任何超出范围的迭代器。有趣的是，尽管
    `clear()` 清除了所有元素，但它并不改变向量的容量。这意味着为向量分配的内存保持不变，允许在无需立即重新分配的情况下进行高效的后续插入。'
- en: 'The `clear()` member function of `std::vector` removes all elements from the
    vector, effectively reducing its size to `0`. Here’s a simple example to demonstrate
    its usage:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 的 `clear()` 成员函数从向量中删除所有元素，有效地将其大小减少到 `0`。以下是一个简单的示例，演示其用法：'
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is the example output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This example underscores the efficiency of `std::vector` in handling bulk deletions
    with a single function call, making data management even more straightforward.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子强调了 `std::vector` 在使用单个函数调用处理大量删除时的效率，使数据管理更加直接。
- en: Dynamic resizing is a prominent feature of `std::vector`, but it requires careful
    management to maintain efficiency. When a vector’s contents exceed its capacity,
    it necessitates memory reallocation, which involves allocating a new memory block,
    copying the existing elements, and deallocating the old memory. This process can
    introduce performance overheads, mainly if the vector grows by small amounts repeatedly.
    If you can anticipate the maximum size, use the `reserve()` function to pre-allocate
    memory to mitigate such inefficiencies.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 动态调整大小是 `std::vector` 的一个显著特性，但它需要谨慎管理以保持效率。当向量的内容超过其容量时，需要进行内存重新分配，这涉及到分配一个新的内存块、复制现有元素和释放旧内存。这个过程可能会引入性能开销，尤其是在向量通过小量重复增长时。如果你可以预测最大大小，可以使用
    `reserve()` 函数预先分配内存以减轻这种低效。
- en: For example, invoking `scores.reserve(100);` allocates memory for 100 elements,
    reducing the need for frequent reallocations up to that limit.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，调用 `scores.reserve(100);` 为100个元素分配内存，减少到该限制之前的频繁重新分配需求。
- en: '`std::vector` offers a comprehensive set of functions tailored for dynamic
    data management. It facilitates quickly adding elements, inserting them in between,
    or removing them from various positions. Coupled with its efficient memory management,
    `std::vector` stands out as both a flexible and performance-oriented container.
    As you delve deeper into C++, the utility of `std::vector` will become increasingly
    apparent, as it addresses a wide range of programming scenarios effectively.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`提供了一套针对动态数据管理的综合函数。它使得快速添加元素、在中间插入元素或从各种位置删除元素变得容易。结合其高效的内存管理，`std::vector`作为一个灵活且注重性能的容器脱颖而出。随着你对C++的深入了解，`std::vector`的实用性将越来越明显，因为它有效地解决了广泛的编程场景。'
- en: In this section, we explored the dynamic nature of `std::vector`, which allows
    us to modify its content and size. We learned how to add elements to a vector
    using methods such as `push_back`, `emplace_back`, and insertion at a specific
    position using iterators. We also examined the process of removing elements, whether
    a single element at a particular position, a range of elements, or removing elements
    by value.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了`std::vector`的动态特性，这使得我们可以修改其内容和大小。我们学习了如何使用`push_back`、`emplace_back`等方法向向量中添加元素，以及如何使用迭代器在特定位置插入元素。我们还考察了删除元素的过程，无论是特定位置的单一元素、一系列元素，还是按值删除元素。
- en: We discussed the concept of capacity, the amount of pre-allocated space for
    elements in a vector, and how it differs from size, which is the actual number
    of elements currently in the vector. Understanding this distinction is critical
    for writing memory- and performance-efficient programs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了容量概念，即向量中元素预分配的空间量，以及它与大小（即向量中当前实际元素的数量）的区别。理解这一区别对于编写内存和性能高效的程序至关重要。
- en: The use of `empty()` as a preferred method for checking whether a vector contains
    any elements was also highlighted. We discussed the advantages of `empty()` over
    checking whether `size()` returns `0`, particularly regarding clarity and potential
    performance benefits.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还强调了使用`empty()`作为检查向量是否包含任何元素的推荐方法。我们讨论了`empty()`相对于检查`size()`是否返回`0`的优势，特别是在清晰度和潜在的性能优势方面。
- en: Additionally, we covered the importance of the `clear()` function, which removes
    all elements from a vector, effectively resetting its size to `0` without necessarily
    changing its capacity.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还介绍了`clear()`函数的重要性，该函数从向量中删除所有元素，有效地将其大小重置为`0`，而无需改变其容量。
- en: This section’s information is handy because it allows us to manage `std::vector`’s
    contents actively and efficiently. Knowledge of adding and removing elements is
    vital for implementing algorithms that require dynamic data manipulation, which
    is a common scenario in software development.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的信息非常实用，因为它使我们能够积极且高效地管理`std::vector`的内容。了解添加和删除元素对于实现需要动态数据操作的算法至关重要，这在软件开发中是一个常见的场景。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned the foundational aspects of `std::vector`
    in C++ STL. The chapter began by explaining the significance of `std::vector`,
    highlighting its advantages over C-style arrays, particularly regarding memory
    management and ease of use. The chapter thoroughly compared C-style arrays and
    `std::vector`, demonstrating how `std::vector` facilitates dynamic size adjustment
    and safer memory operations.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了C++ STL中`std::vector`的基础知识。本章首先解释了`std::vector`的重要性，强调了它相对于C风格数组的优势，尤其是在内存管理和易用性方面。本章详细比较了C风格数组和`std::vector`，展示了`std::vector`如何促进动态大小调整和更安全的内存操作。
- en: Next, you were guided through the processes of declaring and initializing vectors.
    You learned how to declare `std::vector` and initialize these instances using
    different methods. The chapter then explored the myriad ways of accessing elements
    within `std::vector`, from random access to accessing the first and last elements,
    and underscored the importance of understanding vector size.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你被引导了解了声明和初始化向量的过程。你学习了如何声明`std::vector`以及使用不同方法初始化这些实例。然后，章节探讨了访问`std::vector`中元素的各种方法，从随机访问到访问第一个和最后一个元素，并强调了理解向量大小的重要性。
- en: Further, the chapter delved into the intricacies of adding and removing elements.
    This section illuminated the best practices for modifying the contents of a vector,
    including when to use `empty()` instead of checking for a size of `0` and the
    significance of understanding a vector’s capacity.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章深入探讨了添加和删除元素的内情。本节阐明了修改向量内容时的最佳实践，包括何时使用 `empty()` 而不是检查大小为 `0`，以及理解向量容量的重要性。
- en: The information presented in this chapter is invaluable as it builds the foundational
    knowledge required to effectively utilize `std::vector` (and many other STL data
    types) in various programming scenarios. Mastery of `std::vector` allows for writing
    more efficient and maintainable code, enabling C++ developers to leverage STL’s
    full potential for dynamic array manipulation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所提供的信息极为宝贵，因为它构建了在多种编程场景中有效利用 `std::vector`（以及许多其他 STL 数据类型）所需的基础知识。掌握 `std::vector`
    允许编写更高效、更易于维护的代码，使 C++ 开发者能够充分利用 STL 在动态数组操作方面的全部潜力。
- en: In the next chapter, you will elevate your understanding of `std::vector` by
    learning about iterators, central to navigating through elements in STL containers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将通过学习迭代器来提高你对 `std::vector` 的理解，迭代器是导航 STL 容器中元素的关键。
