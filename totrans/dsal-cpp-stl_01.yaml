- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Basics of std::vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::vector` is a fundamental component of C++ programming. This chapter will
    explore `std::vector` as a dynamic array, discussing its utility in various programming
    contexts. By the end of the chapter, you should be adept at declaring, initializing,
    and manipulating vectors. These skills will enable you to utilize `std::vector`
    effectively in diverse applications. It will provide a solid foundation for understanding
    the broader set of data structures and algorithms of the **Standard Template**
    **Library** (**STL**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The significance of `std::vector`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring and initializing `std::vector`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and removing elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  prefs: []
  type: TYPE_NORMAL
- en: The significance of std::vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, `std::vector` is a frequently chosen data structure. While beginners
    might initially see parallels between it and the basic arrays in C, the advantages
    of `std::vector` become evident with deeper exploration. Additionally, a solid
    grasp of `std::vector` facilitates a smoother transition to understanding other
    components of STL.
  prefs: []
  type: TYPE_NORMAL
- en: Both vectors and arrays function as containers for collections of elements.
    The critical distinction between them lies in their flexibility and capabilities.
    Arrays are static in size, set at declaration time, and cannot be altered afterward.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, vectors are dynamic. They can expand or contract based on the operations
    performed on them. Unlike arrays, which commit to a fixed memory block upon declaration,
    vectors dynamically manage memory. They frequently allocate extra memory to anticipate
    future growth, optimizing efficiency and flexibility. While arrays offer simple
    index-based element access and modification, vectors provide a broader set of
    functions, including methods for inserting, deleting, and locating elements.
  prefs: []
  type: TYPE_NORMAL
- en: The primary advantage of `std::vector` is its combination of dynamic resizing
    and optimized performance. Traditional C++ arrays have their size set at compile
    time. If an array is declared to hold 10 elements, it’s constrained to that capacity.
    However, in many real-world scenarios, the volume of data isn’t determined until
    runtime. This is where `std::vector` shines.
  prefs: []
  type: TYPE_NORMAL
- en: A basic comparison of C-style arrays and std::vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Acting as a dynamic array, `std::vector` can adjust its size during program
    execution. It efficiently manages its memory, reallocating not for each new addition,
    but in larger chunks to maintain a balance between performance and adaptability.
    Thus, rather than pre-committing to a specific size and risking either memory
    waste or a shortage, `std::vector` dynamically responds to varying data demands.
  prefs: []
  type: TYPE_NORMAL
- en: Here are two code examples that demonstrate the contrast between using a C-style
    array and `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates the use of a C-style array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a C-style dynamic array with a size of `5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the dynamic array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the contents of the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize the array to a new size (e.g., `7`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the elements from the old array to the new one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deallocate the old array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the pointer to the new array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the contents of the resized array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the size of the resized array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deallocate the resized array when done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In contrast, the following code demonstrates the use of `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'By way of contrast with the C-style version, in this example, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare `std::vector` with initial values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the contents of the vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize. This operation is easy with `std::vector`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print again to see the change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the size. This operation is simple with the `size()` member function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the initial example, the C-style array is constrained by its fixed size.
    Modifying its size typically requires a non-trivial procedure. Conversely, `std::vector`
    can adjust its size effortlessly and provides a `size()` method to determine the
    number of elements it holds.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond its dynamic resizing capability, `std::vector` further simplifies memory
    management compared to traditional arrays. With `std::vector`, there’s no need
    for explicit memory allocations or deallocations as it internally handles these
    tasks. This approach minimizes the risk of memory leaks and streamlines the development
    process. As a result, many C++ developers, regardless of their experience level,
    prefer using `std::vector` over raw arrays for convenience and safety.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example that contrasts how a legacy C-style array manages memory
    and how `std::vector` makes this easier and safer.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of C-style arrays and std::vector for memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let us consider an example of a C-style array with manual memory management.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’ll use dynamic memory allocation (`new` and `delete`) to
    simulate some of the resizing capabilities of `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically allocate a C-style array with a size of `5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Simulate a resize: allocate a larger array and copy the data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the rest of the new array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the array’s content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clean up the allocated memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let us consider an example of `std::vector` with built-in memory management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `std::vector`, you don’t have to allocate or deallocate memory manually;
    it is managed internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The steps in this example include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create `std::vector` with a size of `5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resizing is straightforward with `push_back()` or `resize()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the vector’s contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s no need for explicit memory deallocation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the first example, the challenges of manual memory management are evident.
    Failing to use `delete` appropriately can result in memory leaks. On the other
    hand, the second example highlights the efficiency of `std::vector`, which internally
    manages memory, eliminating the need for manual resizing and memory operations
    and enhancing the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional arrays come with a basic set of operations. In contrast, `std::vector`
    offers various member functions that provide advanced data manipulation and retrieval
    capabilities. These functions will be explored in subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: In C++ development, `std::vector` is a fundamental tool. Its flexibility makes
    it a go-to choice for various applications, from game development to complex software
    projects. The built-in safety mechanisms against common memory issues underscore
    its value. As an STL component, `std::vector` encourages consistent and optimal
    coding practices by integrating well with other STL elements.
  prefs: []
  type: TYPE_NORMAL
- en: This section explored the fundamental differences between C-style arrays and
    `std::vector`. Unlike static C-style arrays, we learned that `std::vector` offers
    dynamic resizing and robust memory management, which are critical for developing
    flexible and efficient applications. The comparison detailed how `std::vector`
    abstracts away low-level memory handling, thus minimizing common errors associated
    with manual memory management.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding `std::vector` is beneficial because it is one of the most widely
    used sequence containers in C++ programming. `std::vector` supports dynamic growth
    in contiguously allocated memory and random access iteration and is compatible
    with a range of algorithms in the STL. We also discussed how `std::vector` provides
    a safer and more intuitive interface for managing collections of objects.
  prefs: []
  type: TYPE_NORMAL
- en: The following section will build upon this foundational knowledge. We will learn
    the syntax for declaring `std::vector` and the various methods available for initializing
    it. This will include an examination of default, copy, and move semantics as they
    pertain to vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and initializing std::vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having established the foundational knowledge of `std::vector` in C++ development,
    it’s time to delve into its practical applications—expressly, how to declare and
    initialize vectors.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of `std::vector` lies in its dynamic nature. Unlike traditional
    arrays with fixed sizes, vectors can grow or shrink as necessary, making them
    a versatile tool for developers.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The performance of `std::vector` stems from its design, which combines the benefits
    of a contiguous memory layout (such as arrays) with the flexibility of dynamic
    resizing. It reserves memory to hold that many elements when initialized with
    a specified size. But if the vector fills up and more capacity is needed, it allocates
    a larger memory block, transfers the existing elements, and deallocates the old
    memory. This dynamic resizing process is optimized to reduce overhead, ensuring
    that vectors remain efficient. The fusion of contiguous storage and automated
    memory management distinguishes `std::vector` as an essential component in the
    C++ ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a basic `std::vector`, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This line of code initializes an empty `std::vector` named `vec` specifically
    designed to hold values of type `int`. (`int` is the template parameter inside
    the `<>` for `std::vector's` type.) `std::vector` is a dynamic array, which means
    that even though `vec` begins with a size of `0`, its capacity can grow as needed.
    As you insert integers into `vec`, the container will automatically allocate memory
    to accommodate the increasing number of elements. This dynamic resizing makes
    `std::vector` a versatile and widely used container in C++ for situations where
    the number of elements isn’t known in advance or might change over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating `std::vector`, it’s possible to specify its initial size. This
    can be beneficial if you have prior knowledge about the number of elements you’ll
    need to store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `std::vector` named `vec` is initialized with space for
    10 integers. By default, these integers will be value-initialized, which means
    they will be set to `0` for fundamental data types such as `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to initialize the elements with a specific value, you can provide
    a second argument during the vector’s construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, `std::vector` is declared with 10 integers, and each of those 10 integers
    is initialized to the value of `5`. This approach ensures efficient memory allocation
    and desired value initialization in a single step.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++11 and later versions, `std::vector` initialization became more straightforward
    with the introduction of initializer lists. This allows developers to specify
    the initial values of the vector directly within curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding statement creates an instance of `std::vector` named `vec` and
    initializes it with five integers. This method provides a concise way to declare
    and populate a vector simultaneously. This is just one way to initialize `std::vector`.
    Depending on your needs, there are many ways this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`std::vector` is a versatile templated container capable of storing various
    data types, not just primitives such as `int`. You can store objects of custom
    classes, other standard library types, and pointers. This adaptability makes `std::vector`
    suitable for a wide range of applications and scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, vectors provide a straightforward mechanism for copying the contents
    of one vector to another. This is known as **copy initialization**. The following
    code demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `vec2` is initialized as an exact copy of `vec1`, meaning `vec2`
    will contain the same elements as `vec1`. This copy initialization ensures that
    the original vector (`vec1`) remains unchanged and that the new vector (`vec2`)
    is provided with a separate copy of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the true strengths of STL containers is their ability to handle user-defined
    types seamlessly, extending beyond primitive data types such as `int` or `double`.
    This flexibility is a testament to its templated design, which allows it to adapt
    to various data types while maintaining type safety. In the upcoming example,
    we illustrate this versatility by utilizing `std::vector` with a custom class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `std::vector` is first used to manage objects of the custom
    `Person` class. It demonstrates the ease with which `std::vector` accommodates
    and manages memory for built-in and user-defined types.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, while static arrays have their utility, they come with fixed sizes that
    can sometimes be limiting. On the other hand, `std::vector` provides a dynamic
    and flexible alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the declaration and initialization of vectors is essential for
    effective C++ programming. `std::vector` is a versatile tool suitable for various
    tasks, from implementing complex algorithms to developing large-scale applications.
    Incorporating `std::vector` into your programming practices can enhance the efficiency
    and maintainability of your code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered the syntactical aspects of working with `std::vector`.
    Specifically, we delved into the proper techniques for declaring `std::vector`
    of various types and the diverse strategies for initializing these vectors to
    suit different programming scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that declaring `std::vector` involves specifying the type of elements
    it will contain and, optionally, the initial size and default value for the elements.
    We discovered multiple methods regarding initialization, including direct-list
    initialization and initializing with a specific range of values. This section
    underscored the flexibility of `std::vector`, showing how it can be tailored to
    start with a predefined set of elements or be constructed from existing collections.
  prefs: []
  type: TYPE_NORMAL
- en: This information is crucial for practical C++ development as it provides a foundation
    for using `std::vector` effectively. Proper initialization can lead to performance
    optimizations and ensure the vector is in a valid state appropriate for its intended
    use. The ability to declare and initialize vectors succinctly and correctly is
    a foundational skill for leveraging the power of the STL in real-world C++ applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, *Accessing elements*, we will focus on the operations that
    allow us to retrieve and modify the contents of a `std::vector`. We will learn
    about random access, which allows for the efficient retrieval and modification
    of elements at any position within the vector. Additionally, we will explore how
    to access the first and last elements, and the importance of understanding and
    managing vector size to ensure robust and error-free code.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having discussed the declaration and initialization of `std::vector`, our focus
    now shifts to accessing and manipulating the contained data. Multiple methods
    in C++ allow you to access vector elements with both speed and safety.
  prefs: []
  type: TYPE_NORMAL
- en: Random access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The subscript `[]` operator allows direct element access via indices, similar
    to arrays. In the following example, given a vector, the expression `numbers[1]`
    returns the value `20`. However, using this operator doesn’t involve boundary
    checks. An index that is out of range, such as `numbers[10]`, results in undefined
    behavior, leading to unpredictable outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For safer index-based access, `std::vector` offers the `at()` member function.
    It performs an index boundary check and throws an `out_of_range` exception for
    invalid indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Caution is paramount when accessing vector elements. While C++ favors performance,
    it often sidesteps safety checks, as evident with the subscript operator. Hence,
    developers must ensure valid access through careful index management or by employing
    safer methods such as `at()`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the first and last elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first and last elements can be accessed with `front()` and `back()`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The example output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Vector size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With `std::vector`, understanding the structure and the amount of data it contains
    is essential. The `size()` member function provides the current count of elements
    stored within the vector. Invoking this function on an instance of `std::vector`
    will return the number of elements it holds. This count represents the active
    elements and can be used to determine the range for valid indexing. The returned
    value is of type `size_t`, an unsigned integer type suitable for representing
    sizes and counts. It’s beneficial when iterating through a vector, performing
    size comparisons, or allocating space based on the number of vector elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `size()` function is called on the data vector to
    retrieve and display the number of elements it contains. The result, as expected,
    indicates that there are five elements in the vector.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, `std::vector` offers a suite of tools, ranging from the efficient
    subscript operator to the safer `at()` method, and the convenient `front()` and
    `back()` methods. Understanding these tools is vital to efficiently and safely
    access and manipulate data within a vector.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we concentrated on the methodologies for retrieving and inspecting
    the contents of `std::vector`. We learned about the capabilities of `std::vector`
    to provide random access to its elements, enabling direct access to any element
    using its index with constant time complexity. This section also detailed the
    methods to access a vector’s first and last elements through the `front()` and
    `back()` member functions, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we discussed the importance of understanding and utilizing the `size()`
    member function to determine the number of elements currently stored in `std::vector`.
    This understanding is instrumental in ensuring that our access patterns remain
    within the bounds of the vector, thereby preventing out-of-range errors and undefined
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The skills acquired from this section are essential, as they form the basis
    of interacting with `std::vector`’s contents. These access patterns are core to
    using vectors effectively in C++ applications, whether for reading or modifying
    elements. The ability to directly access elements in a vector leads to efficient
    algorithms and supports a wide range of everyday programming tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The following section will advance our knowledge further by addressing how to
    modify the size and contents of `std::vector`. We will explore how to add elements
    to a vector and the various methods available to remove them. This will include
    understanding how vectors manage their capacity and its implications on performance.
    We will learn why and how to use `.empty()` as a more performant alternative to
    checking whether the size is `0`, and we will delve into clearing all elements
    from a vector.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of `std::vector` over traditional arrays is its ability
    to resize dynamically. As applications evolve, so do data requirements; static
    data structures do not cut it. In this section, we will explore dynamic data management
    with `std::vector`, learning to seamlessly add to and remove from vectors while
    making sure we are staying safe.
  prefs: []
  type: TYPE_NORMAL
- en: Adding elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with adding elements. The `push_back()` member function is possibly
    the most straightforward way to add an element to the end of a vector. Suppose
    you have `std::vector<int> scores;` and wish to append a new score, say `95`.
    You would simply invoke `scores.push_back(95);`, and voilà, your score is added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple illustrative code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When run, this program will display the vector’s size before and after adding
    a score and the score itself, demonstrating the `push_back()` function in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you need to insert a score at a specific position, not just at the
    end? The `insert()` function becomes your best ally. If you wanted to insert a
    score of `85` at the third position, you’d use an iterator to specify the location:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scores.insert(scores.begin() +` `2, 85);`'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that vector indexing starts at `0`; the `+ 2` is for the third position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s expand on the previous example by incorporating the use of the `insert()`
    function in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This program will showcase the original scores, display the scores after appending
    one to the end, and inserting one in the third position. It illustrates the `push_back()`
    and `insert()` functions in action.
  prefs: []
  type: TYPE_NORMAL
- en: And vectors don’t stop there. The `emplace_back()` and `emplace()` functions
    allow for constructing elements directly inside the vector. This means fewer temporary
    objects and a potential boost in performance, especially with complex data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a `Person` class that has a few data members. To create a new
    `Person` object, a string concatenation operation is performed. Using `emplace_back()`
    and `emplace()` will avoid extra temporary objects and copy/move operations that
    `push_back()` might cause, offering a performance boost. The following code demonstrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This example clarifies how `emplace_back()` and `emplace()` allow for the direct
    construction of objects inside the vector. Using `push_back()` might create temporary
    `Person` objects. Using `emplace_back()` directly constructs the object in place,
    potentially avoiding temporary object creation. Using `insert()` might create
    temporary `Person` objects. Using `emplace()` directly constructs the object in
    place at the specified location. This is particularly beneficial with types such
    as `Person`, where the constructor might involve resource-intensive operations
    (such as string concatenation). In such scenarios, the performance advantage of
    `emplace` methods over their `push` counterparts becomes evident.
  prefs: []
  type: TYPE_NORMAL
- en: Removing elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But life isn’t just about adding. Sometimes, we need to remove data. The `pop_back()`
    function removes the last element of a vector, reducing its size by one. If, however,
    you’re looking to remove from a specific position or even a range of positions,
    the `erase()` function will be your go-to.
  prefs: []
  type: TYPE_NORMAL
- en: The erase-remove idiom
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C++ and its STL, there are established coding patterns that experienced developers
    often use. One notable pattern is the **erase-remove** idiom, which facilitates
    the removal of specific elements from a container based on defined criteria. This
    section will detail the functionality of this idiom and discuss newer alternatives
    introduced in C++20.
  prefs: []
  type: TYPE_NORMAL
- en: 'STL containers, especially `std::vector`, do not provide a straightforward
    method to remove elements based on a predicate. Instead, they provide separate
    methods: one to rearrange elements (using `std::remove` and `std::remove_if`)
    and another to erase them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the erase-remove idiom works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::remove` or `std::remove_if` is used to reorder elements of the container.
    Elements that need to be removed are moved to the end.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These algorithms return an iterator pointing to the start of the removed elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The container’s `erase` method is then used to remove the elements from the
    container physically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A classic example removes all instances of `0` from `std::vector<int>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Modernizing with std::erase and std::erase_if
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recognizing the ubiquity and somewhat counterintuitive nature of the erase-remove
    idiom, C++20 introduced direct utility functions to simplify this operation: `std::erase`
    and `std::erase_if`. These functions merge the two-step process into one, offering
    a more intuitive and less error-prone approach.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the previous example, removing all instances of `0` with C++20 becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'No longer does one have to invoke separate algorithms and remember to handle
    both stages of the process. Similarly, to remove elements based on a predicate,
    you would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: While the erase-remove idiom has been a cornerstone of STL-based C++ programming
    for years, modern C++ continues to evolve and simplify common patterns. With `std::erase`
    and `std::erase_if`, developers now have more straightforward tools to remove
    container elements, leading to cleaner and more readable code. It’s a testament
    to the ongoing commitment of the C++ community to enhance the language’s user-friendliness
    while retaining its power and expressiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `std::vector` has been ingeniously designed to optimize memory operations.
    While one might intuitively expect the underlying array to resize every time an
    element is added or removed, that isn’t the case. Instead, when a vector grows,
    it often allocates more memory than immediately necessary, anticipating future
    additions. This strategy minimizes the frequent memory reallocations, which could
    be computationally expensive. Conversely, when elements are removed, the vector
    doesn’t always shrink its allocated memory immediately. This behavior provides
    a balance between memory usage and performance. However, it is worth noting that
    the specifics of these memory management decisions can vary by the C++ library
    implementation. As such, while the behavior is consistent across implementations
    in terms of the interface, the internal memory management nuances might differ.
  prefs: []
  type: TYPE_NORMAL
- en: Capacity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the `capacity()` member function to know how much memory has been
    allocated. The `std::vector::capacity()` member function returns the amount of
    memory allocated for the vector, which may be greater than its actual size. This
    value represents the maximum number of elements the vector can hold before reallocating
    memory, ensuring efficient growth patterns without frequent memory operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be seen in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The exact output may be different for your compiler, but here is an example
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This example illustrates how the size and capacity of a `std::vector` instance
    change as elements are added and removed. Examining the outputs shows that the
    capacity often doesn’t correspond directly with the size, highlighting the memory
    optimization techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Prefer using empty() when possible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++, when the primary intention is to check whether a container is devoid
    of elements, it’s recommended to use the `.empty()` member function instead of
    comparing `.size()` or `.capacity()` with `0`. The `.empty()` function provides
    a direct way to ascertain whether a container has any elements, and in many implementations,
    it can offer a performance advantage. Specifically, `.empty()` typically has a
    constant time complexity of `O(1)`, whereas `.size()` might have a linear time
    complexity of `O(n)` for some container types, making `.empty()` a more efficient
    choice for mere emptiness checks. Using `.empty()` can lead to more concise and
    potentially faster code, especially in performance-critical sections.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing all elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `clear()` function of `std::vector` is a powerful utility that swiftly erases
    all elements within the container. After invoking this function, the `size()`
    of the vector will return `0`, indicating its now-empty state. However, a crucial
    aspect to be aware of is that any references, pointers, or iterators that previously
    pointed to the elements within the vector are invalidated by this operation. This
    also holds for any past-the-end iterators. Interestingly, while `clear()` purges
    all the elements, it doesn’t alter the capacity of the vector. This means that
    the memory allocated for the vector remains unchanged, allowing for efficient
    subsequent insertions without immediate reallocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `clear()` member function of `std::vector` removes all elements from the
    vector, effectively reducing its size to `0`. Here’s a simple example to demonstrate
    its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This example underscores the efficiency of `std::vector` in handling bulk deletions
    with a single function call, making data management even more straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic resizing is a prominent feature of `std::vector`, but it requires careful
    management to maintain efficiency. When a vector’s contents exceed its capacity,
    it necessitates memory reallocation, which involves allocating a new memory block,
    copying the existing elements, and deallocating the old memory. This process can
    introduce performance overheads, mainly if the vector grows by small amounts repeatedly.
    If you can anticipate the maximum size, use the `reserve()` function to pre-allocate
    memory to mitigate such inefficiencies.
  prefs: []
  type: TYPE_NORMAL
- en: For example, invoking `scores.reserve(100);` allocates memory for 100 elements,
    reducing the need for frequent reallocations up to that limit.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::vector` offers a comprehensive set of functions tailored for dynamic
    data management. It facilitates quickly adding elements, inserting them in between,
    or removing them from various positions. Coupled with its efficient memory management,
    `std::vector` stands out as both a flexible and performance-oriented container.
    As you delve deeper into C++, the utility of `std::vector` will become increasingly
    apparent, as it addresses a wide range of programming scenarios effectively.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored the dynamic nature of `std::vector`, which allows
    us to modify its content and size. We learned how to add elements to a vector
    using methods such as `push_back`, `emplace_back`, and insertion at a specific
    position using iterators. We also examined the process of removing elements, whether
    a single element at a particular position, a range of elements, or removing elements
    by value.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the concept of capacity, the amount of pre-allocated space for
    elements in a vector, and how it differs from size, which is the actual number
    of elements currently in the vector. Understanding this distinction is critical
    for writing memory- and performance-efficient programs.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `empty()` as a preferred method for checking whether a vector contains
    any elements was also highlighted. We discussed the advantages of `empty()` over
    checking whether `size()` returns `0`, particularly regarding clarity and potential
    performance benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we covered the importance of the `clear()` function, which removes
    all elements from a vector, effectively resetting its size to `0` without necessarily
    changing its capacity.
  prefs: []
  type: TYPE_NORMAL
- en: This section’s information is handy because it allows us to manage `std::vector`’s
    contents actively and efficiently. Knowledge of adding and removing elements is
    vital for implementing algorithms that require dynamic data manipulation, which
    is a common scenario in software development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned the foundational aspects of `std::vector`
    in C++ STL. The chapter began by explaining the significance of `std::vector`,
    highlighting its advantages over C-style arrays, particularly regarding memory
    management and ease of use. The chapter thoroughly compared C-style arrays and
    `std::vector`, demonstrating how `std::vector` facilitates dynamic size adjustment
    and safer memory operations.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you were guided through the processes of declaring and initializing vectors.
    You learned how to declare `std::vector` and initialize these instances using
    different methods. The chapter then explored the myriad ways of accessing elements
    within `std::vector`, from random access to accessing the first and last elements,
    and underscored the importance of understanding vector size.
  prefs: []
  type: TYPE_NORMAL
- en: Further, the chapter delved into the intricacies of adding and removing elements.
    This section illuminated the best practices for modifying the contents of a vector,
    including when to use `empty()` instead of checking for a size of `0` and the
    significance of understanding a vector’s capacity.
  prefs: []
  type: TYPE_NORMAL
- en: The information presented in this chapter is invaluable as it builds the foundational
    knowledge required to effectively utilize `std::vector` (and many other STL data
    types) in various programming scenarios. Mastery of `std::vector` allows for writing
    more efficient and maintainable code, enabling C++ developers to leverage STL’s
    full potential for dynamic array manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will elevate your understanding of `std::vector` by
    learning about iterators, central to navigating through elements in STL containers.
  prefs: []
  type: TYPE_NORMAL
