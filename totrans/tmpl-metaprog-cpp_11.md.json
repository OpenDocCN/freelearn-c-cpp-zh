["```cpp\nusing value_type      = /* ... */;\n```", "```cpp\nusing size_type       = std::size_t;\n```", "```cpp\nusing difference_type = std::ptrdiff_t;\n```", "```cpp\nusing reference       = value_type&;\n```", "```cpp\nusing const_reference = value_type const&;\n```", "```cpp\nusing pointer         = /* ... */;\n```", "```cpp\nusing const_pointer   = /* ... */;\n```", "```cpp\nusing iterator        = /* ... */;\n```", "```cpp\nusing const_iterator  = /* ... */;\n```", "```cpp\nstd::vector<int> v {1, 2, 3};\n```", "```cpp\nstd::list<int> l;\n```", "```cpp\nfor (std::size_t i = 0; i < v.size(); ++i)\n```", "```cpp\n   l.push_back(v[i]);\n```", "```cpp\nstd::vector<int> v{ 1, 2, 3 };\n```", "```cpp\n// copy vector to vector\n```", "```cpp\nstd::vector<int> vc(v.size());\n```", "```cpp\nstd::copy(v.begin(), v.end(), vc.begin());\n```", "```cpp\n// copy vector to list\n```", "```cpp\nstd::list<int> l;\n```", "```cpp\nstd::copy(v.begin(), v.end(), std::back_inserter(l));\n```", "```cpp\n// copy list to set\n```", "```cpp\nstd::set<int> s;\n```", "```cpp\nstd::copy(l.begin(), l.end(), std::inserter(s, s.begin()));\n```", "```cpp\ntemplate<typename InputIt, class OutputIt>\n```", "```cpp\nOutputIt copy(InputIt first, InputIt last, \n```", "```cpp\n              OutputIt d_first)\n```", "```cpp\n{\n```", "```cpp\n   for (; first != last; (void)++first, (void)++d_first)\n```", "```cpp\n   {\n```", "```cpp\n      *d_first = *first;\n```", "```cpp\n   }\n```", "```cpp\n   return d_first;\n```", "```cpp\n}\n```", "```cpp\nstd::vector<int> v{ 1,2,3,4,5 };\n```", "```cpp\n// prints 1 2 3 4 5\n```", "```cpp\nstd::copy(v.begin(), v.end(),\n```", "```cpp\n          std::ostream_iterator<int>(std::cout, \" \"));\n```", "```cpp\n// prints 5 4 3 2 1\n```", "```cpp\nstd::copy(v.rbegin(), v.rend(),\n```", "```cpp\n          std::ostream_iterator<int>(std::cout, \" \"));\n```", "```cpp\nstd::vector<int> v{ 1,2,3,4,5 };\n```", "```cpp\nstd::copy(std::begin(v), std::end(v), \n```", "```cpp\n          std::ostream_iterator<int>(std::cout, \" \"));\n```", "```cpp\nint a[] = { 1,2,3,4,5 };\n```", "```cpp\nstd::copy(std::begin(a), std::end(a),\n```", "```cpp\n          std::ostream_iterator<int>(std::cout, \" \"));\n```", "```cpp\nstd::vector<int> v{ 1,2,3,4,5 };\n```", "```cpp\nfor (auto const& e : v) \n```", "```cpp\n   std::cout << e << ' ';\n```", "```cpp\nint a[] = { 1,2,3,4,5 };\n```", "```cpp\nfor (auto const& e : a)\n```", "```cpp\n   std::cout << e << ' ';\n```", "```cpp\ntemplate <typename T, std::size_t N>\n```", "```cpp\n   requires(N > 0)\n```", "```cpp\nclass circular_buffer_iterator;\n```", "```cpp\ntemplate <typename T, std::size_t N>\n```", "```cpp\n   requires(N > 0)\n```", "```cpp\nclass circular_buffer\n```", "```cpp\n{\n```", "```cpp\n  // ...\n```", "```cpp\n};\n```", "```cpp\npublic:\n```", "```cpp\n   using value_type = T;\n```", "```cpp\n   using size_type = std::size_t;\n```", "```cpp\n   using difference_type = std::ptrdiff_t;\n```", "```cpp\n   using reference = value_type&;\n```", "```cpp\n   using const_reference = value_type const&;\n```", "```cpp\n   using pointer = value_type*;\n```", "```cpp\n   using const_pointer = value_type const*;\n```", "```cpp\n   using iterator = circular_buffer_iterator<T, N>;\n```", "```cpp\n   using const_iterator = \n```", "```cpp\n      circular_buffer_iterator<T const, N>;\n```", "```cpp\nprivate:\n```", "```cpp\n   std::array<value_type, N> data_;\n```", "```cpp\n   size_type                 head_ = 0;\n```", "```cpp\n   size_type                 tail_ = 0;\n```", "```cpp\n   size_type                 size_ = 0;\n```", "```cpp\nconstexpr circular_buffer() = default;\n```", "```cpp\nconstexpr circular_buffer(value_type const (&values)[N]) :\n```", "```cpp\n   size_(N), tail_(N-1)\n```", "```cpp\n{\n```", "```cpp\n   std::copy(std::begin(values), std::end(values), \n```", "```cpp\n             data_.begin());\n```", "```cpp\n}\n```", "```cpp\nconstexpr circular_buffer(const_reference v):\n```", "```cpp\n   size_(N), tail_(N-1)\n```", "```cpp\n{\n```", "```cpp\n   std::fill(data_.begin(), data_.end(), v);\n```", "```cpp\n}\n```", "```cpp\ncircular_buffer<int, 1> b1;              // {}\n```", "```cpp\ncircular_buffer<int, 3> b2({ 1, 2, 3 }); // {1, 2, 3}\n```", "```cpp\ncircular_buffer<int, 3> b3(42);          // {42, 42, 42}\n```", "```cpp\nconstexpr size_type size() const noexcept \n```", "```cpp\n{ return size_; }\n```", "```cpp\nconstexpr size_type capacity() const noexcept \n```", "```cpp\n{ return N; }\n```", "```cpp\nconstexpr bool empty() const noexcept \n```", "```cpp\n{ return size_ == 0; }\n```", "```cpp\nconstexpr bool full() const noexcept \n```", "```cpp\n{ return size_ == N; }\n```", "```cpp\nconstexpr void clear() noexcept \n```", "```cpp\n{ size_ = 0; head_ = 0; tail_ = 0; };\n```", "```cpp\nconstexpr reference operator[](size_type const pos)\n```", "```cpp\n{\n```", "```cpp\n   return data_[(head_ + pos) % N];\n```", "```cpp\n}\n```", "```cpp\nconstexpr const_reference operator[](size_type const pos) const\n```", "```cpp\n{\n```", "```cpp\n   return data_[(head_ + pos) % N];\n```", "```cpp\n}\n```", "```cpp\nconstexpr reference at(size_type const pos)\n```", "```cpp\n{\n```", "```cpp\n   if (pos < size_)\n```", "```cpp\n      return data_[(head_ + pos) % N];\n```", "```cpp\n   throw std::out_of_range(\"Index is out of range\");\n```", "```cpp\n}\n```", "```cpp\nconstexpr const_reference at(size_type const pos) const\n```", "```cpp\n{\n```", "```cpp\n   if (pos < size_)\n```", "```cpp\n      return data_[(head_ + pos) % N];\n```", "```cpp\n   throw std::out_of_range(\"Index is out of range\");\n```", "```cpp\n}\n```", "```cpp\nconstexpr reference front()\n```", "```cpp\n{\n```", "```cpp\n   if (size_ > 0) return data_[head_];\n```", "```cpp\n   throw std::logic_error(\"Buffer is empty\");\n```", "```cpp\n}\n```", "```cpp\nconstexpr const_reference front() const\n```", "```cpp\n{\n```", "```cpp\n   if (size_ > 0) return data_[head_];\n```", "```cpp\n   throw std::logic_error(\"Buffer is empty\");\n```", "```cpp\n}\n```", "```cpp\nconstexpr reference back()\n```", "```cpp\n{\n```", "```cpp\n   if (size_ > 0) return data_[tail_];\n```", "```cpp\n   throw std::logic_error(\"Buffer is empty\");\n```", "```cpp\n}\n```", "```cpp\nconstexpr const_reference back() const\n```", "```cpp\n{\n```", "```cpp\n   if (size_ > 0) return data_[tail_];\n```", "```cpp\n   throw std::logic_error(\"Buffer is empty\");\n```", "```cpp\n}\n```", "```cpp\nconstexpr void push_back(T const& value)\n```", "```cpp\n{\n```", "```cpp\n   if (empty())\n```", "```cpp\n   {\n```", "```cpp\n      data_[tail_] = value;\n```", "```cpp\n      size_++;\n```", "```cpp\n   }\n```", "```cpp\n   else if (!full())\n```", "```cpp\n   {\n```", "```cpp\n      data_[++tail_] = value;\n```", "```cpp\n      size_++;\n```", "```cpp\n   }\n```", "```cpp\n   else\n```", "```cpp\n   {\n```", "```cpp\n      head_ = (head_ + 1) % N;\n```", "```cpp\n      tail_ = (tail_ + 1) % N;\n```", "```cpp\n      data_[tail_] = value;\n```", "```cpp\n   }\n```", "```cpp\n}\n```", "```cpp\nconstexpr void push_back(T&& value)\n```", "```cpp\n{\n```", "```cpp\n   if (empty())\n```", "```cpp\n   {\n```", "```cpp\n      data_[tail_] = value;\n```", "```cpp\n      size_++;\n```", "```cpp\n   }\n```", "```cpp\n   else if (!full())\n```", "```cpp\n   {\n```", "```cpp\n      data_[++tail_] = std::move(value);\n```", "```cpp\n      size_++;\n```", "```cpp\n   }\n```", "```cpp\n   else\n```", "```cpp\n   {\n```", "```cpp\n      head_ = (head_ + 1) % N;\n```", "```cpp\n      tail_ = (tail_ + 1) % N;\n```", "```cpp\n      data_[tail_] = std::move(value);\n```", "```cpp\n   }\n```", "```cpp\n}\n```", "```cpp\nconstexpr T pop_front()\n```", "```cpp\n{\n```", "```cpp\n   if (empty()) throw std::logic_error(\"Buffer is empty\");\n```", "```cpp\n   size_type index = head_;\n```", "```cpp\n   head_ = (head_ + 1) % N;\n```", "```cpp\n   size_--;\n```", "```cpp\n   return data_[index];\n```", "```cpp\n}\n```", "```cpp\ncircular_buffer<int, 4> b({ 1, 2, 3, 4 });\n```", "```cpp\nassert(b.size() == 4);\n```", "```cpp\nb.push_back(5);\n```", "```cpp\nb.push_back(6);\n```", "```cpp\nb.pop_front();\n```", "```cpp\nassert(b.size() == 3);\n```", "```cpp\nassert(b[0] == 4);\n```", "```cpp\nassert(b[1] == 5);\n```", "```cpp\nassert(b[2] == 6);\n```", "```cpp\niterator begin()\n```", "```cpp\n{\n```", "```cpp\n   return iterator(*this, 0);\n```", "```cpp\n}\n```", "```cpp\niterator end()\n```", "```cpp\n{\n```", "```cpp\n   return iterator(*this, size_);\n```", "```cpp\n}\n```", "```cpp\nconst_iterator begin() const\n```", "```cpp\n{\n```", "```cpp\n   return const_iterator(*this, 0);\n```", "```cpp\n}\n```", "```cpp\nconst_iterator end() const\n```", "```cpp\n{\n```", "```cpp\n   return const_iterator(*this, size_);\n```", "```cpp\n}\n```", "```cpp\nprivate:\n```", "```cpp\n   friend circular_buffer_iterator<T, N>;\n```", "```cpp\ntemplate <typename T, std::size_t N>\n```", "```cpp\nrequires(N > 0)\n```", "```cpp\nclass circular_buffer_iterator\n```", "```cpp\n{\n```", "```cpp\npublic:\n```", "```cpp\n   using self_type = circular_buffer_iterator<T, N>;\n```", "```cpp\n   using value_type = T;\n```", "```cpp\n   using reference = value_type&;\n```", "```cpp\n   using const_reference = value_type const &;\n```", "```cpp\n   using pointer = value_type*;\n```", "```cpp\n   using const_pointer = value_type const*;\n```", "```cpp\n   using iterator_category =\n```", "```cpp\n      std::random_access_iterator_tag;\n```", "```cpp\n   using size_type = std::size_t;\n```", "```cpp\n   using difference_type = std::ptrdiff_t;\n```", "```cpp\npublic:\n```", "```cpp\n   /* definitions */\n```", "```cpp\nprivate:\n```", "```cpp\n   std::reference_wrapper<circular_buffer<T, N>> buffer_;\n```", "```cpp\n   size_type              index_ = 0;\n```", "```cpp\n};\n```", "```cpp\nexplicit circular_buffer_iterator(\n```", "```cpp\n   circular_buffer<T, N>& buffer,\n```", "```cpp\n   size_type const index):\n```", "```cpp\n   buffer_(buffer), index_(index)\n```", "```cpp\n{ }\n```", "```cpp\nself_type& operator++()\n```", "```cpp\n{ \n```", "```cpp\n   if(index_ >= buffer_.get().size())\n```", "```cpp\n      throw std::out_of_range(\"Iterator cannot be \n```", "```cpp\n                  incremented past the end of the range\");\n```", "```cpp\n   index_++;\n```", "```cpp\n   return *this;\n```", "```cpp\n}\n```", "```cpp\nself_type operator++(int)\n```", "```cpp\n{\n```", "```cpp\n   self_type temp = *this;\n```", "```cpp\n   ++*this;\n```", "```cpp\n   return temp;\n```", "```cpp\n}\n```", "```cpp\nbool operator==(self_type const& other) const\n```", "```cpp\n{\n```", "```cpp\n   return compatible(other) && index_ == other.index_;\n```", "```cpp\n}\n```", "```cpp\nbool operator!=(self_type const& other) const\n```", "```cpp\n{\n```", "```cpp\n   return !(*this == other);\n```", "```cpp\n}\n```", "```cpp\nconst_reference operator*() const\n```", "```cpp\n{\n```", "```cpp\n   if (buffer_.get().empty() || !in_bounds())\n```", "```cpp\n      throw std::logic_error(\"Cannot dereferentiate the \n```", "```cpp\n                              iterator\");\n```", "```cpp\n   return buffer_.get().data_[\n```", "```cpp\n      (buffer_.get().head_ + index_) % \n```", "```cpp\n       buffer_.get().capacity()];\n```", "```cpp\n}\n```", "```cpp\nconst_reference operator->() const\n```", "```cpp\n{\n```", "```cpp\n   if (buffer_.get().empty() || !in_bounds())\n```", "```cpp\n      throw std::logic_error(\"Cannot dereferentiate the \n```", "```cpp\n                              iterator\");\n```", "```cpp\n   return buffer_.get().data_[\n```", "```cpp\n      (buffer_.get().head_ + index_) % \n```", "```cpp\n       buffer_.get().capacity()];\n```", "```cpp\n}\n```", "```cpp\nbool compatible(self_type const& other) const\n```", "```cpp\n{\n```", "```cpp\n   return buffer_.get().data_.data() == \n```", "```cpp\n          other.buffer_.get().data_.data();\n```", "```cpp\n}\n```", "```cpp\nbool in_bounds() const\n```", "```cpp\n{\n```", "```cpp\n   return\n```", "```cpp\n      !buffer_.get().empty() &&\n```", "```cpp\n      (buffer_.get().head_ + index_) % \n```", "```cpp\n       buffer_.get().capacity() <= buffer_.get().tail_;\n```", "```cpp\n}\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_swappable_v<circular_buffer_iterator<int, 10>>);\n```", "```cpp\nself_type& operator--()\n```", "```cpp\n{\n```", "```cpp\n   if(index_ <= 0)\n```", "```cpp\n      throw std::out_of_range(\"Iterator cannot be \n```", "```cpp\n           decremented before the beginning of the range\");\n```", "```cpp\n   index_--;\n```", "```cpp\n   return *this;\n```", "```cpp\n}\n```", "```cpp\nself_type operator--(int)\n```", "```cpp\n{\n```", "```cpp\n   self_type temp = *this;\n```", "```cpp\n   --*this;\n```", "```cpp\n   return temp;\n```", "```cpp\n}\n```", "```cpp\nself_type operator+(difference_type offset) const\n```", "```cpp\n{\n```", "```cpp\n   self_type temp = *this;\n```", "```cpp\n   return temp += offset;\n```", "```cpp\n}\n```", "```cpp\nself_type operator-(difference_type offset) const\n```", "```cpp\n{\n```", "```cpp\n   self_type temp = *this;\n```", "```cpp\n   return temp -= offset;\n```", "```cpp\n}\n```", "```cpp\ndifference_type operator-(self_type const& other) const\n```", "```cpp\n{\n```", "```cpp\n   return index_ - other.index_;\n```", "```cpp\n}\n```", "```cpp\nself_type& operator +=(difference_type const offset)\n```", "```cpp\n{\n```", "```cpp\n   difference_type next = \n```", "```cpp\n      (index_ + next) % buffer_.get().capacity();\n```", "```cpp\n   if (next >= buffer_.get().size())\n```", "```cpp\n      throw std::out_of_range(\"Iterator cannot be \n```", "```cpp\n                incremented past the bounds of the range\");\n```", "```cpp\n   index_ = next;\n```", "```cpp\n   return *this;\n```", "```cpp\n}\n```", "```cpp\nself_type& operator -=(difference_type const offset)\n```", "```cpp\n{\n```", "```cpp\n   return *this += -offset;\n```", "```cpp\n}\n```", "```cpp\nbool operator<(self_type const& other) const\n```", "```cpp\n{\n```", "```cpp\n   return index_ < other.index_;\n```", "```cpp\n}\n```", "```cpp\nbool operator>(self_type const& other) const\n```", "```cpp\n{\n```", "```cpp\n   return other < *this;\n```", "```cpp\n}\n```", "```cpp\nbool operator<=(self_type const& other) const\n```", "```cpp\n{\n```", "```cpp\n   return !(other < *this);\n```", "```cpp\n}\n```", "```cpp\nbool operator>=(self_type const& other) const\n```", "```cpp\n{\n```", "```cpp\n   return !(*this < other);\n```", "```cpp\n}\n```", "```cpp\nvalue_type& operator[](difference_type const offset)\n```", "```cpp\n{\n```", "```cpp\n   return *((*this + offset));\n```", "```cpp\n}\n```", "```cpp\nvalue_type const & operator[](difference_type const offset) const\n```", "```cpp\n{\n```", "```cpp\n   return *((*this + offset));\n```", "```cpp\n}\n```", "```cpp\ncircular_buffer<int, 3> b({1, 2, 3});\n```", "```cpp\nstd::vector<int> v;\n```", "```cpp\nfor (auto it = b.begin(); it != b.end(); ++it)\n```", "```cpp\n{\n```", "```cpp\n   v.push_back(*it);\n```", "```cpp\n}\n```", "```cpp\ncircular_buffer<int, 3> b({ 1, 2, 3 });\n```", "```cpp\nstd::vector<int> v;\n```", "```cpp\nfor (auto const e : b)\n```", "```cpp\n{\n```", "```cpp\n   v.push_back(e);\n```", "```cpp\n}\n```", "```cpp\ncircular_buffer<int, 3> b({ 1,2,3 });\n```", "```cpp\n*b.begin() = 0;\n```", "```cpp\nassert(b.front() == 0);\n```", "```cpp\nreference operator*()\n```", "```cpp\n{\n```", "```cpp\n   if (buffer_.get().empty() || !in_bounds())\n```", "```cpp\n      throw std::logic_error(\"Cannot dereferentiate the \n```", "```cpp\n                              iterator\");\n```", "```cpp\n   return buffer_.get().data_[\n```", "```cpp\n      (buffer_.get().head_ + index_) % \n```", "```cpp\n       buffer_.get().capacity()];\n```", "```cpp\n}\n```", "```cpp\nreference operator->()\n```", "```cpp\n{\n```", "```cpp\n   if (buffer_.get().empty() || !in_bounds())\n```", "```cpp\n      throw std::logic_error(\"Cannot dereferentiate the \n```", "```cpp\n                              iterator\");\n```", "```cpp\n   return buffer_.get().data_[\n```", "```cpp\n      (buffer_.get().head_ + index_) % \n```", "```cpp\n       buffer_.get().capacity()];\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename InputIt1, typename InputIt2,\n```", "```cpp\n          typename OutputIt>\n```", "```cpp\nOutputIt flatzip(\n```", "```cpp\n   InputIt1 first1, InputIt1 last1,\n```", "```cpp\n   InputIt2 first2, InputIt2 last2,\n```", "```cpp\n   OutputIt dest)\n```", "```cpp\n{\n```", "```cpp\n   auto it1 = first1;\n```", "```cpp\n   auto it2 = first2;\n```", "```cpp\n   while (it1 != last1 && it2 != last2)\n```", "```cpp\n   {\n```", "```cpp\n      *dest++ = *it1++;\n```", "```cpp\n      *dest++ = *it2++;\n```", "```cpp\n   }\n```", "```cpp\n   return dest;\n```", "```cpp\n}\n```", "```cpp\n// one range is empty\n```", "```cpp\nstd::vector<int> v1 {1,2,3};\n```", "```cpp\nstd::vector<int> v2;\n```", "```cpp\nstd::vector<int> v3;\n```", "```cpp\nflatzip(v1.begin(), v1.end(), v2.begin(), v2.end(),\n```", "```cpp\n        std::back_inserter(v3));\n```", "```cpp\nassert(v3.empty());\n```", "```cpp\n// neither range is empty\n```", "```cpp\nstd::vector<int> v1 {1, 2, 3};\n```", "```cpp\nstd::vector<int> v2 {4, 5};\n```", "```cpp\nstd::vector<int> v3;\n```", "```cpp\nflatzip(v1.begin(), v1.end(), v2.begin(), v2.end(),\n```", "```cpp\n        std::back_inserter(v3));\n```", "```cpp\nassert(v3 == std::vector<int>({ 1, 4, 2, 5 }));\n```", "```cpp\ncircular_buffer<int, 4> a({1, 2, 3, 4});\n```", "```cpp\ncircular_buffer<int, 3> b({5, 6, 7});\n```", "```cpp\ncircular_buffer<int, 8> c(0);\n```", "```cpp\nflatzip(a.begin(), a.end(), b.begin(), b.end(), c.begin());\n```", "```cpp\nstd::vector<int> v;\n```", "```cpp\nfor (auto e : c)\n```", "```cpp\n   v.push_back(e);\n```", "```cpp\nassert(v == std::vector<int>({ 1, 5, 2, 6, 3, 7, 0, 0 }));\n```"]