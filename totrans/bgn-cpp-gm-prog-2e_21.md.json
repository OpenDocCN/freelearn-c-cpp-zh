["```cpp\n#pragma once\n#include \"GameObjectSharer.h\"\n#include <string>\nusing namespace std;\nclass GameObject;\nclass Component {\npublic:\n    virtual string getType() = 0;\n    virtual string getSpecificType() = 0;\n    virtual void disableComponent() = 0;\n    virtual void enableComponent() = 0;\n    virtual bool enabled() = 0;\n    virtual void start(GameObjectSharer* gos, GameObject* self) = 0;\n};\n```", "```cpp\n/*********************************\n******THIS IS AN INTERFACE********\n*********************************/\n```", "```cpp\n#pragma once\n#include \"Component.h\"\n#include <iostream>\nclass ColliderComponent : public Component\n{\nprivate:\n    string m_Type = \"collider\";\n    bool m_Enabled = false;\npublic:\n    /****************************************************\n    *****************************************************\n    From Component interface\n    *****************************************************\n    *****************************************************/\n    string Component::getType() {\n        return m_Type;\n    }\n    void Component::disableComponent() {\n        m_Enabled = false;\n    }\n    void Component::enableComponent() {\n        m_Enabled = true;\n    }\n    bool Component::enabled() {\n        return m_Enabled;\n    }\n   void Component::start(GameObjectSharer* gos, GameObject* self)\n   {\n\n    }\n};\n```", "```cpp\n/*\nAll Functionality in ColliderComponent.h\n*/\n```", "```cpp\n#pragma once\n#include \"ColliderComponent.h\"\n#include <SFML/Graphics.hpp>\nusing namespace sf;\nclass RectColliderComponent : public ColliderComponent\n{\nprivate:\n    string m_SpecificType = \"rect\";\n    FloatRect m_Collider;\n    string m_Tag = \"\";\npublic:\n    RectColliderComponent(string name);\n    string getColliderTag();\n    void setOrMoveCollider(\n        float x, float y, float width, float height);\n\n    FloatRect& getColliderRectF();\n    /****************************************************\n    *****************************************************\n    From Component interface base class\n    *****************************************************\n    *****************************************************/\n    string getSpecificType() {\n        return m_SpecificType;\n    }\n\n    void Component::start(\n        GameObjectSharer* gos, GameObject* self) {}\n};\n```", "```cpp\n#include \"RectColliderComponent.h\"\nRectColliderComponent::RectColliderComponent(string name) {\n    m_Tag = \"\" + name;\n}\nstring RectColliderComponent::getColliderTag() {\n    return m_Tag;\n}\nvoid RectColliderComponent::setOrMoveCollider(\n    float x, float y, float width, float height) {\n\n    m_Collider.left = x;\n    m_Collider.top = y;\n    m_Collider.width = width;\n    m_Collider.height = height;\n}\nFloatRect& RectColliderComponent::getColliderRectF() {\n    return m_Collider;\n}\n```", "```cpp\n#pragma once\n#include \"Component.h\"\n#include \"TransformComponent.h\"\n#include <string>\n#include <SFML/Graphics.hpp>\n#include \"GameObjectSharer.h\"\n#include <iostream>\nusing namespace sf;\nusing namespace std;\nclass GraphicsComponent : public Component {\nprivate:\n    string m_Type = \"graphics\";\n    bool m_Enabled = false;\npublic:\n    virtual void draw(\n        RenderWindow& window,\n        shared_ptr<TransformComponent> t) = 0;\n    virtual void initializeGraphics(\n        string bitmapName,\n        Vector2f objectSize) = 0;\n    /****************************************************\n    *****************************************************\n    From Component interface\n    *****************************************************\n    *****************************************************/\n    string Component::getType() {\n        return m_Type;\n    }\n    void Component::disableComponent() {\n        m_Enabled = false;\n    }\n    void Component::enableComponent() {\n        m_Enabled = true;\n    }\n    bool Component::enabled() {\n        return m_Enabled;\n    }\n    void Component::start(\n        GameObjectSharer* gos, GameObject* self) {}\n};\n```", "```cpp\n/*\nAll Functionality in GraphicsComponent.h\n*/\n```", "```cpp\n#pragma once\n#include \"Component.h\"\n#include \"GraphicsComponent.h\"\n#include <string>\nclass Component;\nclass StandardGraphicsComponent : public GraphicsComponent {\nprivate:\n    sf::Sprite m_Sprite;\n    string m_SpecificType = \"standard\";\npublic:\n    /****************************************************\n    *****************************************************\n    From Component interface base class\n    *****************************************************\n    *****************************************************/\n    string Component::getSpecificType() {\n        return m_SpecificType;\n    }\n\n    void Component::start(\n        GameObjectSharer* gos, GameObject* self) {\n    }\n    /****************************************************\n    *****************************************************\n    From GraphicsComponent\n    *****************************************************\n    *****************************************************/\n    void draw(\n        RenderWindow& window,\n        shared_ptr<TransformComponent> t) override;\n    void initializeGraphics(\n        string bitmapName,\n        Vector2f objectSize) override;\n};\n```", "```cpp\n#include \"StandardGraphicsComponent.h\"\n#include \"BitmapStore.h\"\n#include <iostream>\nvoid StandardGraphicsComponent::initializeGraphics(\n    string bitmapName,\n    Vector2f objectSize)\n{\n    BitmapStore::addBitmap(\"graphics/\" + bitmapName + \".png\");\n    m_Sprite.setTexture(BitmapStore::getBitmap(\n        \"graphics/\" + bitmapName + \".png\"));\n    auto textureSize = m_Sprite.getTexture()->getSize();\n    m_Sprite.setScale(float(objectSize.x) / textureSize.x, \n        float(objectSize.y) / textureSize.y);    \n    m_Sprite.setColor(sf::Color(0, 255, 0)); \n}\nvoid StandardGraphicsComponent::draw(\n    RenderWindow& window,\n    shared_ptr<TransformComponent> t)\n{\n    m_Sprite.setPosition(t->getLocation());\n    window.draw(m_Sprite);\n}\n```", "```cpp\n#pragma once\n#include \"Component.h\"\n#include<SFML/Graphics.hpp>\nusing namespace sf;\nclass Component;\nclass TransformComponent : public Component {\nprivate:\n    const string m_Type = \"transform\";\n    Vector2f m_Location;\n    float m_Height;\n    float m_Width;\npublic:\n    TransformComponent(\n        float width, float height, Vector2f location);\n    Vector2f& getLocation();\n    Vector2f getSize();\n    /****************************************************\n    *****************************************************\n    From Component interface\n    *****************************************************\n    *****************************************************/\n    string Component::getType()\n    {\n        return m_Type;\n    }\n    string Component::getSpecificType()\n    {\n        // Only one type of Transform so just return m_Type\n        return m_Type;\n    }\n    void Component::disableComponent(){}\n    void Component::enableComponent(){}\n    bool Component::enabled()\n    {\n        return false;\n    }\n    void Component::start(GameObjectSharer* gos, GameObject* self)    {}\n};\n```", "```cpp\n#include \"TransformComponent.h\"\nTransformComponent::TransformComponent(\n    float width, float height, Vector2f location)\n{\n    m_Height = height;\n    m_Width = width;\n    m_Location = location;\n}\nVector2f& TransformComponent::getLocation() \n{\n    return m_Location;\n}\nVector2f TransformComponent::getSize() \n{\n    return Vector2f(m_Width, m_Height);\n}\n```", "```cpp\n#pragma once\n#include \"Component.h\"\nclass UpdateComponent : public Component\n{\nprivate:\n    string m_Type = \"update\";\n    bool m_Enabled = false;\npublic:\n    virtual void update(float fps) = 0;\n\n    /****************************************************\n    *****************************************************\n    From Component interface\n    *****************************************************\n    *****************************************************/\n    string Component::getType() {\n        return m_Type;\n    }\n    void Component::disableComponent() {\n        m_Enabled = false;\n    }\n    void Component::enableComponent() {\n        m_Enabled = true;\n    }\n    bool Component::enabled() {\n        return m_Enabled;\n    }\n    void Component::start(\n        GameObjectSharer* gos, GameObject* self) {\n    }\n};\n```", "```cpp\n/*\nAll Functionality in UpdateComponent.h\n*/\n```", "```cpp\n#pragma once\n#include \"UpdateComponent.h\"\n#include \"TransformComponent.h\"\n#include \"GameObjectSharer.h\"\n#include \"RectColliderComponent.h\"\n#include \"GameObject.h\"\nclass BulletUpdateComponent : public UpdateComponent\n{\nprivate:\n    string m_SpecificType = \"bullet\";\n    shared_ptr<TransformComponent> m_TC;\n    shared_ptr<RectColliderComponent> m_RCC;\n    float m_Speed = 75.0f;\n\n    int m_AlienBulletSpeedModifier;\n    int m_ModifierRandomComponent = 5;\n    int m_MinimumAdditionalModifier = 5;\n    bool m_MovingUp = true;\npublic:\n    bool m_BelongsToPlayer = false;\n    bool m_IsSpawned = false;\n    void spawnForPlayer(Vector2f spawnPosition);\n    void spawnForInvader(Vector2f spawnPosition);\n    void deSpawn();\n    bool isMovingUp();\n    /****************************************************\n    *****************************************************\n    From Component interface base class\n    *****************************************************\n    *****************************************************/\n    string Component::getSpecificType() {\n        return m_SpecificType;\n    }\n\n    void Component::start(\n        GameObjectSharer* gos, GameObject* self) {        \n        // Where is this specific invader\n        m_TC = static_pointer_cast<TransformComponent>(\n            self->getComponentByTypeAndSpecificType(\n                \"transform\", \"transform\"));\n        m_RCC = static_pointer_cast<RectColliderComponent>(\n            self->getComponentByTypeAndSpecificType(\n                \"collider\", \"rect\"));\n    }\n    /****************************************************\n    *****************************************************\n    From UpdateComponent\n    *****************************************************\n    *****************************************************/\n    void update(float fps) override;\n};\n```", "```cpp\n#include \"BulletUpdateComponent.h\"\n#include \"WorldState.h\"\nvoid BulletUpdateComponent::spawnForPlayer(\n    Vector2f spawnPosition)\n{\n    m_MovingUp = true;\n    m_BelongsToPlayer = true;\n    m_IsSpawned = true;\n\n    m_TC->getLocation().x = spawnPosition.x;\n    // Tweak the y location based on the height of the bullet \n    // The x location is already tweaked to the center of the player\n    m_TC->getLocation().y = spawnPosition.y - m_TC->getSize().y;\n    // Update the collider\n    m_RCC->setOrMoveCollider(m_TC->getLocation().x,\n        m_TC->getLocation().y, \n        m_TC->getSize().x, m_TC->getSize().y);\n}\nvoid BulletUpdateComponent::spawnForInvader(\n    Vector2f spawnPosition)\n{\n    m_MovingUp = false;\n    m_BelongsToPlayer = false;\n    m_IsSpawned = true;\n    srand((int)time(0));\n    m_AlienBulletSpeedModifier = (\n        ((rand() % m_ModifierRandomComponent)))  \n        + m_MinimumAdditionalModifier;    \n    m_TC->getLocation().x = spawnPosition.x;\n    // Tweak the y location based on the height of the bullet \n    // The x location already tweaked to the center of the invader\n    m_TC->getLocation().y = spawnPosition.y;\n    // Update the collider\n    m_RCC->setOrMoveCollider(\n        m_TC->getLocation().x, m_TC->\n        getLocation().y, m_TC->getSize().x, m_TC->getSize().y);\n}\nvoid BulletUpdateComponent::deSpawn()\n{\n    m_IsSpawned = false;\n}\nbool BulletUpdateComponent::isMovingUp()\n{\n    return m_MovingUp;\n}\nvoid BulletUpdateComponent::update(float fps)\n{\n    if (m_IsSpawned)\n    {    \n        if (m_MovingUp)\n        {\n            m_TC->getLocation().y -= m_Speed * fps;\n        }\n        else\n        {\n            m_TC->getLocation().y += m_Speed / \n                m_AlienBulletSpeedModifier * fps;\n        }\n        if (m_TC->getLocation().y > WorldState::WORLD_HEIGHT \n            || m_TC->getLocation().y < -2)\n        {\n            deSpawn();\n        }\n        // Update the collider\n        m_RCC->setOrMoveCollider(m_TC->getLocation().x, \n            m_TC->getLocation().y, \n            m_TC->getSize().x, m_TC->getSize().y);\n    }\n}\n```", "```cpp\n#pragma once\n#include \"UpdateComponent.h\"\n#include \"TransformComponent.h\"\n#include \"GameObjectSharer.h\"\n#include \"RectColliderComponent.h\"\n#include \"GameObject.h\"\nclass BulletSpawner;\nclass InvaderUpdateComponent : public UpdateComponent\n{\nprivate:\n    string m_SpecificType = \"invader\";\n    shared_ptr<TransformComponent> m_TC;\n    shared_ptr < RectColliderComponent> m_RCC;\n    shared_ptr < TransformComponent> m_PlayerTC;\n    shared_ptr < RectColliderComponent> m_PlayerRCC;\n    BulletSpawner* m_BulletSpawner;\n    float m_Speed = 10.0f;\n    bool m_MovingRight = true;\n    float m_TimeSinceLastShot;\n    float m_TimeBetweenShots = 5.0f;\n    float m_AccuracyModifier;\n    float m_SpeedModifier = 0.05;\n    int m_RandSeed;\npublic:\n    void dropDownAndReverse();\n    bool isMovingRight();\n    void initializeBulletSpawner(BulletSpawner* \n        bulletSpawner, int randSeed);\n    /****************************************************\n    *****************************************************\n    From Component interface base class\n    *****************************************************\n    *****************************************************/\n    string Component::getSpecificType() {\n        return m_SpecificType;\n    }\n    void Component::start(GameObjectSharer* gos, \n        GameObject* self) {\n\n        // Where is the player?\n        m_PlayerTC = static_pointer_cast<TransformComponent>(\n            gos->findFirstObjectWithTag(\"Player\")\n            .getComponentByTypeAndSpecificType(\n                \"transform\", \"transform\"));\n        m_PlayerRCC = static_pointer_cast<RectColliderComponent>(\n            gos->findFirstObjectWithTag(\"Player\")\n            .getComponentByTypeAndSpecificType(\n                \"collider\", \"rect\"));\n        // Where is this specific invader\n        m_TC = static_pointer_cast<TransformComponent>(\n            self->getComponentByTypeAndSpecificType(\n                \"transform\", \"transform\"));\n        m_RCC = static_pointer_cast<RectColliderComponent>(\n            self->getComponentByTypeAndSpecificType(\n                \"collider\", \"rect\"));\n    }\n    /****************************************************\n    *****************************************************\n    From UpdateComponent\n    *****************************************************\n    *****************************************************/\n    void update(float fps) override;    \n};\n```", "```cpp\nshared_ptr<TransformComponent> m_TC;\nshared_ptr < RectColliderComponent> m_RCC;\n```", "```cpp\nshared_ptr < TransformComponent> m_PlayerTC;\nshared_ptr < RectColliderComponent> m_PlayerRCC;\n```", "```cpp\nfloat m_Speed = 10.0f;\nbool m_MovingRight = true;\nfloat m_TimeSinceLastShot;\nfloat m_TimeBetweenShots = 5.0f;\nfloat m_AccuracyModifier;\nfloat m_SpeedModifier = 0.05;\nint m_RandSeed;\n```", "```cpp\nvoid dropDownAndReverse();\nbool isMovingRight();\nvoid initializeBulletSpawner(BulletSpawner* \n        bulletSpawner, int randSeed);\n```", "```cpp\n#include \"InvaderUpdateComponent.h\"\n#include \"BulletSpawner.h\"\n#include \"WorldState.h\"\n#include \"SoundEngine.h\"\nvoid InvaderUpdateComponent::update(float fps)\n{\n    if (m_MovingRight)\n    {\n        m_TC->getLocation().x += m_Speed * fps;\n    }\n    else\n    {\n        m_TC->getLocation().x -= m_Speed * fps;\n    }\n    // Update the collider\n    m_RCC->setOrMoveCollider(m_TC->getLocation().x, \n        m_TC->getLocation().y, m_TC->getSize().x, m_TC-\n      >getSize().y);\n    m_TimeSinceLastShot += fps;\n\n    // Is the middle of the invader above the \n   // player +- 1 world units\n    if ((m_TC->getLocation().x + (m_TC->getSize().x / 2)) > \n        (m_PlayerTC->getLocation().x - m_AccuracyModifier) &&\n        (m_TC->getLocation().x + (m_TC->getSize().x / 2)) < \n        (m_PlayerTC->getLocation().x + \n        (m_PlayerTC->getSize().x + m_AccuracyModifier)))\n    {\n        // Has the invader waited long enough since the last shot\n        if (m_TimeSinceLastShot > m_TimeBetweenShots)\n        {\n            SoundEngine::playShoot();\n            Vector2f spawnLocation;\n            spawnLocation.x = m_TC->getLocation().x + \n                m_TC->getSize().x / 2;\n            spawnLocation.y = m_TC->getLocation().y + \n                m_TC->getSize().y;\n            m_BulletSpawner->spawnBullet(spawnLocation, false);\n            srand(m_RandSeed);\n            int mTimeBetweenShots = (((rand() % 10))+1) / \n                WorldState::WAVE_NUMBER;\n            m_TimeSinceLastShot = 0;            \n        }\n    }\n}\nvoid InvaderUpdateComponent::dropDownAndReverse()\n{\n    m_MovingRight = !m_MovingRight;\n    m_TC->getLocation().y += m_TC->getSize().y;\n    m_Speed += (WorldState::WAVE_NUMBER) + \n        (WorldState::NUM_INVADERS_AT_START \n       - WorldState::NUM_INVADERS) \n        * m_SpeedModifier;\n}\nbool InvaderUpdateComponent::isMovingRight()\n{\n    return m_MovingRight;\n}\nvoid InvaderUpdateComponent::initializeBulletSpawner(\n    BulletSpawner* bulletSpawner, int randSeed)\n{\n    m_BulletSpawner = bulletSpawner;\n    m_RandSeed = randSeed;\n    srand(m_RandSeed);\n    m_TimeBetweenShots = (rand() % 15 + m_RandSeed);\n    m_AccuracyModifier = (rand() % 2);\n    m_AccuracyModifier += 0 + static_cast <float> (\n        rand()) / (static_cast <float> (RAND_MAX / (10)));\n}\n```", "```cpp\nvoid InvaderUpdateComponent::update(float fps)\n{\n    if (m_MovingRight)\n    {\n        m_TC->getLocation().x += m_Speed * fps;\n    }\n    else\n    {\n        m_TC->getLocation().x -= m_Speed * fps;\n    }\n```", "```cpp\n    // Update the collider\n    m_RCC->setOrMoveCollider(m_TC->getLocation().x, \n        m_TC->getLocation().y, m_TC->getSize().x, m_TC \n      ->getSize().y);\n```", "```cpp\n   m_TimeSinceLastShot += fps;\n\n    // Is the middle of the invader above the \n   // player +- 1 world units\n    if ((m_TC->getLocation().x + (m_TC->getSize().x / 2)) > \n        (m_PlayerTC->getLocation().x - m_AccuracyModifier) &&\n        (m_TC->getLocation().x + (m_TC->getSize().x / 2)) < \n        (m_PlayerTC->getLocation().x + \n        (m_PlayerTC->getSize().x + m_AccuracyModifier)))\n    {\n```", "```cpp\n        // Has the invader waited long enough since the last shot\n        if (m_TimeSinceLastShot > m_TimeBetweenShots)\n        {\n            SoundEngine::playShoot();\n            Vector2f spawnLocation;\n            spawnLocation.x = m_TC->getLocation().x + \n                m_TC->getSize().x / 2;\n            spawnLocation.y = m_TC->getLocation().y + \n                m_TC->getSize().y;\n            m_BulletSpawner->spawnBullet(spawnLocation, false);\n            srand(m_RandSeed);\n            int mTimeBetweenShots = (((rand() % 10))+1) / \n                WorldState::WAVE_NUMBER;\n            m_TimeSinceLastShot = 0;            \n        }\n    }\n}\n```", "```cpp\nvoid InvaderUpdateComponent::dropDownAndReverse()\n{\n    m_MovingRight = !m_MovingRight;\n    m_TC->getLocation().y += m_TC->getSize().y;\n    m_Speed += (WorldState::WAVE_NUMBER) + \n        (WorldState::NUM_INVADERS_AT_START \n      - WorldState::NUM_INVADERS) \n        * m_SpeedModifier;\n}\n```", "```cpp\nbool InvaderUpdateComponent::isMovingRight()\n{\n    return m_MovingRight;\n}\n```", "```cpp\nvoid InvaderUpdateComponent::initializeBulletSpawner(\n    BulletSpawner* bulletSpawner, int randSeed)\n{\n    m_BulletSpawner = bulletSpawner;\n    m_RandSeed = randSeed;\n    srand(m_RandSeed);\n    m_TimeBetweenShots = (rand() % 15 + m_RandSeed);\n    m_AccuracyModifier = (rand() % 2);\n    m_AccuracyModifier += 0 + static_cast <float> (\n        rand()) / (static_cast <float> (RAND_MAX / (10)));\n}\n```", "```cpp\n#pragma once\n#include \"UpdateComponent.h\"\n#include \"TransformComponent.h\"\n#include \"GameObjectSharer.h\"\n#include \"RectColliderComponent.h\"\n#include \"GameObject.h\"\nclass PlayerUpdateComponent : public UpdateComponent\n{\nprivate:\n    string m_SpecificType = \"player\";\n    shared_ptr<TransformComponent> m_TC;\n    shared_ptr<RectColliderComponent> m_RCC;\n    float m_Speed = 50.0f;\n    float m_XExtent = 0;\n    float m_YExtent = 0;\n    bool m_IsHoldingLeft = false;\n    bool m_IsHoldingRight = false;\n    bool m_IsHoldingUp = false;\n    bool m_IsHoldingDown = false;\npublic:\n    void updateShipTravelWithController(float x, float y);\n    void moveLeft();\n    void moveRight();\n    void moveUp();\n    void moveDown();\n    void stopLeft();\n    void stopRight();\n    void stopUp();\n    void stopDown();\n    /****************************************************\n    *****************************************************\n    From Component interface base class\n    *****************************************************\n    *****************************************************/\n    string Component::getSpecificType() {\n        return m_SpecificType;\n    }\n    void Component::start(GameObjectSharer* gos, GameObject* self) {        \n        m_TC = static_pointer_cast<TransformComponent>(self->\n            getComponentByTypeAndSpecificType(\n                \"transform\", \"transform\"));\n        m_RCC = static_pointer_cast<RectColliderComponent>(self->\n            getComponentByTypeAndSpecificType(\n                \"collider\", \"rect\"));        \n    }\n    /****************************************************\n    *****************************************************\n    From UpdateComponent\n    *****************************************************\n    *****************************************************/\n    void update(float fps) override;\n};\n```", "```cpp\n#include \"PlayerUpdateComponent.h\"\n#include \"WorldState.h\"\nvoid PlayerUpdateComponent::update(float fps)\n{\n    if (sf::Joystick::isConnected(0))\n    {\n        m_TC->getLocation().x += ((m_Speed / 100) \n            * m_XExtent) * fps;\n        m_TC->getLocation().y += ((m_Speed / 100) \n            * m_YExtent) * fps;        \n    }\n    // Left and right\n    if (m_IsHoldingLeft)\n    {\n        m_TC->getLocation().x -= m_Speed * fps;\n    }\n    else if (m_IsHoldingRight)\n    {\n        m_TC->getLocation().x += m_Speed * fps;\n    }\n    // Up and down\n    if (m_IsHoldingUp)\n    {\n        m_TC->getLocation().y -= m_Speed * fps;\n    }\n    else if (m_IsHoldingDown)\n    {\n        m_TC->getLocation().y += m_Speed * fps;\n    }\n\n    // Update the collider\n    m_RCC->setOrMoveCollider(m_TC->getLocation().x, \n        m_TC->getLocation().y, m_TC->getSize().x, \n        m_TC->getSize().y);\n\n    // Make sure the ship doesn't go outside the allowed area\n    if (m_TC->getLocation().x >\n        WorldState::WORLD_WIDTH - m_TC->getSize().x) \n    {\n        m_TC->getLocation().x = \n            WorldState::WORLD_WIDTH - m_TC->getSize().x;\n    }\n    else if (m_TC->getLocation().x < 0)\n    {\n        m_TC->getLocation().x = 0;\n    }\n    if (m_TC->getLocation().y > \n        WorldState::WORLD_HEIGHT - m_TC->getSize().y)\n    {\n        m_TC->getLocation().y = \n            WorldState::WORLD_HEIGHT - m_TC->getSize().y;\n    }\n    else if (m_TC->getLocation().y < \n        WorldState::WORLD_HEIGHT / 2)\n    {\n        m_TC->getLocation().y = \n            WorldState::WORLD_HEIGHT / 2;\n    }\n}    \nvoid PlayerUpdateComponent::\n    updateShipTravelWithController(float x, float y)\n{\n    m_XExtent = x;\n    m_YExtent = y;\n}\nvoid PlayerUpdateComponent::moveLeft()\n{\n    m_IsHoldingLeft = true;\n    stopRight();\n}\nvoid PlayerUpdateComponent::moveRight()\n{\n    m_IsHoldingRight = true;\n    stopLeft();\n}\nvoid PlayerUpdateComponent::moveUp()\n{\n    m_IsHoldingUp = true;\n    stopDown();\n}\nvoid PlayerUpdateComponent::moveDown()\n{\n    m_IsHoldingDown = true;\n    stopUp();\n}\nvoid PlayerUpdateComponent::stopLeft()\n{\n    m_IsHoldingLeft = false;\n}\nvoid PlayerUpdateComponent::stopRight()\n{\n    m_IsHoldingRight = false;\n}\nvoid PlayerUpdateComponent::stopUp()\n{\n    m_IsHoldingUp = false;\n}\nvoid PlayerUpdateComponent::stopDown()\n{\n    m_IsHoldingDown = false;\n}\n```", "```cpp\n…((m_Speed / 100) * m_YExtent) * fps;\n```", "```cpp\n#pragma once\n#include <SFML/Graphics.hpp>\n#include <vector>\n#include <string>\n#include \"Component.h\"\n#include \"GraphicsComponent.h\"\n#include \"GameObjectSharer.h\"\n#include \"UpdateComponent.h\"\nclass GameObject {\nprivate:\n    vector<shared_ptr<Component>> m_Components;\n    string m_Tag;\n    bool m_Active = false;\n    int m_NumberUpdateComponents = 0;\n    bool m_HasUpdateComponent = false;\n    int m_FirstUpdateComponentLocation = -1;\n    int m_GraphicsComponentLocation = -1;\n    bool m_HasGraphicsComponent = false;\n    int m_TransformComponentLocation = -1;\n    int m_NumberRectColliderComponents = 0;\n    int m_FirstRectColliderComponentLocation = -1;\n    bool m_HasCollider = false;\npublic:\n    void update(float fps);\n    void draw(RenderWindow& window);\n    void addComponent(shared_ptr<Component> component);\n    void setActive();\n    void setInactive();\n    bool isActive();\n    void setTag(String tag);\n    string getTag();\n    void start(GameObjectSharer* gos);\n    // Slow only use in init and start\n    shared_ptr<Component> getComponentByTypeAndSpecificType(\n        string type, string specificType);\n    FloatRect& getEncompassingRectCollider();\n    bool hasCollider();\n    bool hasUpdateComponent();\n    string getEncompassingRectColliderTag();\n    shared_ptr<GraphicsComponent> getGraphicsComponent();\n    shared_ptr<TransformComponent> getTransformComponent();\n    shared_ptr<UpdateComponent> getFirstUpdateComponent();\n};\n```", "```cpp\n#include \"DevelopState.h\"\n#include \"GameObject.h\"\n#include <iostream> \n#include \"UpdateComponent.h\"\n#include \"RectColliderComponent.h\"\nvoid GameObject::update(float fps)\n{\n    if (m_Active && m_HasUpdateComponent)\n    {\n        for (int i = m_FirstUpdateComponentLocation; i < \n            m_FirstUpdateComponentLocation + \n            m_NumberUpdateComponents; i++) \n        {\n            shared_ptr<UpdateComponent> tempUpdate =\n                static_pointer_cast<UpdateComponent>(\n             m_Components[i]);\n            if (tempUpdate->enabled()) \n            {\n                tempUpdate->update(fps);\n            }\n        }\n    }\n}\nvoid GameObject::draw(RenderWindow& window)\n{\n    if (m_Active && m_HasGraphicsComponent)\n    {\n        if (m_Components[m_GraphicsComponentLocation]->enabled())\n        {\n            getGraphicsComponent()->draw(window, \n                getTransformComponent());\n        }\n    }\n}\nshared_ptr<GraphicsComponent> GameObject::getGraphicsComponent() \n{\n    return static_pointer_cast<GraphicsComponent>(\n        m_Components[m_GraphicsComponentLocation]);\n}\nshared_ptr<TransformComponent> GameObject::getTransformComponent() \n{\n    return static_pointer_cast<TransformComponent>(\n        m_Components[m_TransformComponentLocation]);\n}\nvoid GameObject::addComponent(shared_ptr<Component> component)\n{\n    m_Components.push_back(component);\n    component->enableComponent();\n\n   if (component->getType() == \"update\") \n    {\n        m_HasUpdateComponent = true;\n        m_NumberUpdateComponents++;\n        if (m_NumberUpdateComponents == 1) \n        {\n            m_FirstUpdateComponentLocation = \n                m_Components.size() - 1;\n        }\n    }\n    else if (component->getType() == \"graphics\") \n    {\n        // No iteration in the draw method required\n        m_HasGraphicsComponent = true;\n        m_GraphicsComponentLocation = m_Components.size() - 1;\n    }\n    else if (component->getType() == \"transform\") \n    {\n        // Remember where the Transform component is\n        m_TransformComponentLocation = m_Components.size() - 1;\n    }\n    else if (component->getType() == \"collider\" && \n        component->getSpecificType() == \"rect\") \n    {\n        // Remember where the collider component(s) is\n        m_HasCollider = true;\n        m_NumberRectColliderComponents++;\n        if (m_NumberRectColliderComponents == 1) \n        {\n            m_FirstRectColliderComponentLocation = \n                m_Components.size() - 1;\n        }\n    }    \n}\nvoid GameObject::setActive()\n{\n    m_Active = true;\n}\nvoid GameObject::setInactive()\n{\n    m_Active = false;\n}\nbool GameObject::isActive()\n{\n    return m_Active;\n}\nvoid GameObject::setTag(String tag)\n{\n    m_Tag = \"\" + tag;\n}\nstd::string GameObject::getTag()\n{\n    return m_Tag;\n}\nvoid GameObject::start(GameObjectSharer* gos) \n{\n    auto it = m_Components.begin();\n    auto end = m_Components.end();\n    for (it;\n        it != end;\n        ++it)\n    {\n        (*it)->start(gos, this);\n    }\n}\n// Slow - only use in start function\nshared_ptr<Component> GameObject::\n   getComponentByTypeAndSpecificType(\n    string type, string specificType) {\n    auto it = m_Components.begin();\n    auto end = m_Components.end();\n    for (it;\n        it != end;\n        ++it)\n    {\n        if ((*it)->getType() == type)\n        {\n            if ((*it)->getSpecificType() == specificType)\n            {\n                return  (*it);\n            }\n        }\n    }\n    #ifdef debuggingErrors        \n        cout << \n            \"GameObject.cpp::getComponentByTypeAndSpecificType-\" \n            << \"COMPONENT NOT FOUND ERROR!\" \n            << endl;\n    #endif\n        return m_Components[0];\n}\nFloatRect& GameObject::getEncompassingRectCollider() \n{\n    if (m_HasCollider) \n    {\n        return (static_pointer_cast<RectColliderComponent>(\n            m_Components[m_FirstRectColliderComponentLocation]))\n            ->getColliderRectF();\n    }\n}\nstring GameObject::getEncompassingRectColliderTag() \n{\n    return static_pointer_cast<RectColliderComponent>(\n        m_Components[m_FirstRectColliderComponentLocation])->\n        getColliderTag();\n}\nshared_ptr<UpdateComponent> GameObject::getFirstUpdateComponent()\n{\n    return static_pointer_cast<UpdateComponent>(\n        m_Components[m_FirstUpdateComponentLocation]);\n}\nbool GameObject::hasCollider() \n{\n    return m_HasCollider;\n}\nbool GameObject::hasUpdateComponent()\n{\n    return m_HasUpdateComponent;\n}\n```", "```cpp\nvoid GameObject::update(float fps)\n{\n    if (m_Active && m_HasUpdateComponent)\n    {\n        for (int i = m_FirstUpdateComponentLocation; i < \n            m_FirstUpdateComponentLocation + \n            m_NumberUpdateComponents; i++) \n        {\n            shared_ptr<UpdateComponent> tempUpdate =\n                static_pointer_cast<UpdateComponent>(\n             m_Components[i]);\n            if (tempUpdate->enabled()) \n            {\n                tempUpdate->update(fps);\n            }\n        }\n    }\n}\n```", "```cpp\nvoid GameObject::draw(RenderWindow& window)\n{\n    if (m_Active && m_HasGraphicsComponent)\n    {\n        if (m_Components[m_GraphicsComponentLocation]->enabled())\n        {\n            getGraphicsComponent()->draw(window, \n                getTransformComponent());\n        }\n    }\n}\n```", "```cpp\nshared_ptr<GraphicsComponent> GameObject::getGraphicsComponent() \n{\n    return static_pointer_cast<GraphicsComponent>(\n        m_Components[m_GraphicsComponentLocation]);\n}\n```", "```cpp\nshared_ptr<TransformComponent> GameObject::getTransformComponent() \n{\n    return static_pointer_cast<TransformComponent>(\n        m_Components[m_TransformComponentLocation]);\n}\n```", "```cpp\nvoid GameObject::addComponent(shared_ptr<Component> component)\n{\n    m_Components.push_back(component);\n    component->enableComponent();\n\n   if (component->getType() == \"update\") \n    {\n        m_HasUpdateComponent = true;\n        m_NumberUpdateComponents++;\n        if (m_NumberUpdateComponents == 1) \n        {\n            m_FirstUpdateComponentLocation = \n                m_Components.size() - 1;\n        }\n    }\n    else if (component->getType() == \"graphics\") \n    {\n        // No iteration in the draw method required\n        m_HasGraphicsComponent = true;\n        m_GraphicsComponentLocation = m_Components.size() - 1;\n    }\n    else if (component->getType() == \"transform\") \n    {\n        // Remember where the Transform component is\n        m_TransformComponentLocation = m_Components.size() - 1;\n    }\n    else if (component->getType() == \"collider\" && \n        component->getSpecificType() == \"rect\") \n    {\n        // Remember where the collider component(s) is\n        m_HasCollider = true;\n        m_NumberRectColliderComponents++;\n        if (m_NumberRectColliderComponents == 1) \n        {\n            m_FirstRectColliderComponentLocation = \n                m_Components.size() - 1;\n        }\n    }    \n}\n```", "```cpp\nvoid GameObject::setActive()\n{\n    m_Active = true;\n}\nvoid GameObject::setInactive()\n{\n    m_Active = false;\n}\nbool GameObject::isActive()\n{\n    return m_Active;\n}\nvoid GameObject::setTag(String tag)\n{\n    m_Tag = \"\" + tag;\n}\nstd::string GameObject::getTag()\n{\n    return m_Tag;\n}\n```", "```cpp\nvoid GameObject::start(GameObjectSharer* gos) \n{\n    auto it = m_Components.begin();\n    auto end = m_Components.end();\n    for (it;\n        it != end;\n        ++it)\n    {\n        (*it)->start(gos, this);\n    }\n}\n```", "```cpp\n// Slow only use in start\nshared_ptr<Component> GameObject::getComponentByTypeAndSpecificType(\n    string type, string specificType) {\n    auto it = m_Components.begin();\n    auto end = m_Components.end();\n    for (it;\n        it != end;\n        ++it)\n    {\n        if ((*it)->getType() == type)\n        {\n            if ((*it)->getSpecificType() == specificType)\n            {\n                return  (*it);\n            }\n        }\n    }\n    #ifdef debuggingErrors        \n        cout << \n            \"GameObject.cpp::getComponentByTypeAndSpecificType-\" \n            << \"COMPONENT NOT FOUND ERROR!\" \n            << endl;\n    #endif\n        return m_Components[0];\n}\n```", "```cpp\nFloatRect& GameObject::getEncompassingRectCollider() \n{\n    if (m_HasCollider) \n    {\n        return (static_pointer_cast<RectColliderComponent>(\n            m_Components[m_FirstRectColliderComponentLocation]))\n            ->getColliderRectF();\n    }\n}\n```", "```cpp\nstring GameObject::getEncompassingRectColliderTag() \n{\n    return static_pointer_cast<RectColliderComponent>(\n        m_Components[m_FirstRectColliderComponentLocation])->\n        getColliderTag();\n}\n```", "```cpp\nshared_ptr<UpdateComponent> GameObject::getFirstUpdateComponent()\n{\n    return static_pointer_cast<UpdateComponent>(\n        m_Components[m_FirstUpdateComponentLocation]);\n}\n```", "```cpp\nbool GameObject::hasCollider() \n{\n    return m_HasCollider;\n}\nbool GameObject::hasUpdateComponent()\n{\n    return m_HasUpdateComponent;\n}\n```"]