["```cpp\nenum sound_type\n{\n  SOUND_MUSIC = 0,\n  SOUND_SFX = 1\n};\n\nclass SoundManager\n{\npublic:\n\n  static SoundManager* Instance()\n  {\n    if(s_pInstance == 0)\n    {\n      s_pInstance = newSoundManager();\n      return s_pInstance;\n    }\n    return s_pInstance;\n  }\n\n  bool load(std::string fileName, std::string id, sound_type type);\n\n  void playSound(std::string id, int loop);\n  void playMusic(std::string id, int loop);\n\n  private:\n\n  static SoundManager* s_pInstance;\n\n  std::map<std::string, Mix_Chunk*> m_sfxs;\n  std::map<std::string, Mix_Music*> m_music;\n\n  SoundManager();\n  ~SoundManager();\n\n  SoundManager(const SoundManager&);\n  SoundManager &operator=(const SoundManager&);\n};\n\ntypedef SoundManager TheSoundManager;\n```", "```cpp\n(int frequency, Uint16 format, int channels, int chunksize)\n```", "```cpp\nSoundManager::SoundManager()\n{\n  Mix_OpenAudio(22050, AUDIO_S16, 2, 4096);\n}\n```", "```cpp\nstd::map<std::string, Mix_Chunk*> m_sfxs;\nstd::map<std::string, Mix_Music*> m_music;\n```", "```cpp\nbool load(std::string fileName, std::string id, sound_type type);\n```", "```cpp\nbool SoundManager::load(std::string fileName, std::string id, sound_type type)\n{\n  if(type == SOUND_MUSIC)\n  {\n    Mix_Music* pMusic = Mix_LoadMUS(fileName.c_str());\n\n    if(pMusic == 0)\n    {\n      std::cout << \"Could not load music: ERROR - \"\n      << Mix_GetError() << std::endl;\n      return false;\n    }\n\n    m_music[id] = pMusic;\n    return true;\n  }\n  else if(type == SOUND_SFX)\n  {\n    Mix_Chunk* pChunk = Mix_LoadWAV(fileName.c_str());\n    if(pChunk == 0)\n    {\n      std::cout << \"Could not load SFX: ERROR - \"\n      << Mix_GetError() << std::endl;\n\n      return false;\n    }\n\n    m_sfxs[id] = pChunk;\n    return true;\n  }\n  return false;\n}\n```", "```cpp\nvoid playSound(std::string id, int loop);\nvoid playMusic(std::string id, int loop);\n```", "```cpp\nvoid SoundManager::playMusic(std::string id, int loop)\n{\n  Mix_PlayMusic(m_music[id], loop);\n}\n\nvoid SoundManager::playSound(std::string id, int loop)\n{\n  Mix_PlayChannel(-1, m_sfxs[id], loop);\n}\n```", "```cpp\nSoundManager::~SoundManager()\n{\n  Mix_CloseAudio();\n}\n```", "```cpp\nclass GameObject\n{\npublic:\n  // base class needs virtual destructor\n  virtual ~GameObject() {}\n  // load from file \n  virtual void load(std::unique_ptr<LoaderParams> const &pParams)=0;\n  // draw the object\n  virtual void draw()=0;\n  // do update stuff\n  virtual void update()=0;\n  // remove anything that needs to be deleted\n  virtual void clean()=0;\n  // object has collided, handle accordingly\n  virtual void collision() = 0;\n  // get the type of the object\n  virtual std::string type() = 0;\n  // getters for common variables\n  Vector2D& getPosition() { return m_position; }\n  int getWidth() { return m_width; }\n  int getHeight() { return m_height; }\n  // scroll along with tile map\n  void scroll(float scrollSpeed) { m_position.setX(m_position.getX() - \n  scrollSpeed); }\n  // is the object currently being updated?\n  bool updating() { return m_bUpdating; }\n  // is the object dead?\n  bool dead() { return m_bDead; }\n  // is the object doing a death animation?\n  bool dying() { return m_bDying; }\n  // set whether to update the object or not\n  void setUpdating(bool updating) { m_bUpdating = updating; }\n\nprotected:\n\n  // constructor with default initialisation list\n  GameObject() :  m_position(0,0),\n  m_velocity(0,0),\n  m_acceleration(0,0),\n  m_width(0),\n  m_height(0),\n  m_currentRow(0),\n  m_currentFrame(0),\n  m_bUpdating(false),\n  m_bDead(false),\n  m_bDying(false),\n  m_angle(0),\n  m_alpha(255)\n  {\n  }\n  // movement variables\n  Vector2D m_position;\n  Vector2D m_velocity;\n  Vector2D m_acceleration;\n  // size variables\n  int m_width;\n  int m_height;\n  // animation variables\n  int m_currentRow;\n  int m_currentFrame;\n  int m_numFrames;\n  std::string m_textureID;\n  // common boolean variables\n  bool m_bUpdating;\n  bool m_bDead;\n  bool m_bDying;\n  // rotation\n  double m_angle;\n  // blending\n  int m_alpha;\n};\n```", "```cpp\nvirtual void load(std::unique_ptr<LoaderParams> const &pParams)=0;\n```", "```cpp\n // object has collided, handle accordingly\nvirtual void collision() = 0;\n\n // get the type of the object\nvirtual std::string type() = 0;\n```", "```cpp\nclass ShooterObject : public GameObject\n{\npublic:\n\n  virtual ~ShooterObject() {}// for polymorphism\n  virtual void load(std::unique_ptr<LoaderParams> const\n  &pParams);\n  virtual void draw();\n  virtual void update();\n  virtual void clean() {}// not implemented in this class\n  virtual void collision() {}//not implemented in this class\n  virtual std::string type() { return \"SDLGameObject\"; }\n\nprotected:\n\n  // we won't directly create ShooterObject's\n  ShooterObject();\n\n  // draw the animation for the object being destroyed\n  void doDyingAnimation();\n\n  // how fast will this object fire bullets? with a counter\n  int m_bulletFiringSpeed;\n  int m_bulletCounter;\n\n  // how fast will this object move?\n  int m_moveSpeed;\n\n  // how long will the death animation takes? with a counter\n  int m_dyingTime;\n  int m_dyingCounter;\n\n  // has the explosion sound played?\n  bool m_bPlayedDeathSound;\n};\n```", "```cpp\nvoid ShooterObject::doDyingAnimation()\n{\n  // keep scrolling with the map\n  scroll(TheGame::Instance()->getScrollSpeed());\n\n  m_currentFrame = int(((SDL_GetTicks() / (1000 / 3)) % \n  m_numFrames));\n\n  if(m_dyingCounter == m_dyingTime)\n  {\n    m_bDead = true;\n  }\n  m_dyingCounter++; //simple counter, fine with fixed frame rate\n}\n```", "```cpp\nprivate:\n\n  // bring the player back if there are lives left\n  void ressurect();\n\n  // handle any input from the keyboard, mouse, or joystick\n  void handleInput();\n\n  // handle any animation for the player\n  void handleAnimation();\n\n  // player can be invulnerable for a time\n  int m_invulnerable;\n  int m_invulnerableTime;\n  int m_invulnerableCounter;\n};\n```", "```cpp\nvoid Player::ressurect()\n{\n  TheGame::Instance()->setPlayerLives(TheGame::Instance()\n  ->getPlayerLives() - 1);\n\n  m_position.setX(10);\n  m_position.setY(200);\n  m_bDying = false;\n\n  m_textureID = \"player\";\n\n  m_currentFrame = 0;\n  m_numFrames = 5;\n  m_width = 101;\n  m_height = 46;\n\n  m_dyingCounter = 0;\n  m_invulnerable = true;\n}\n```", "```cpp\nvoid Player::handleAnimation()\n{\n  // if the player is invulnerable we can flash its alpha to let \n  people know\n  if(m_invulnerable)\n  {\n    // invulnerability is finished, set values back\n    if(m_invulnerableCounter == m_invulnerableTime)\n    {\n      m_invulnerable = false;\n      m_invulnerableCounter = 0;\n      m_alpha = 255;\n    }\n    else// otherwise, flash the alpha on and off\n    {\n      if(m_alpha == 255)\n      {\n        m_alpha = 0;\n      }\n      else\n      {\n        m_alpha = 255;\n      }\n    }\n\n    // increment our counter\n    m_invulnerableCounter++;\n  }\n\n  // if the player is not dead then we can change the angle with \n  the velocity to give the impression of a moving helicopter\n  if(!m_bDead)\n  {\n    if(m_velocity.getX() < 0)\n    {\n      m_angle = -10.0;\n    }\n    else if(m_velocity.getX() > 0)\n    {\n      m_angle = 10.0;\n    }\n    else\n    {\n      m_angle = 0.0;\n    }\n  }\n\n  // our standard animation code - for helicopter propellors\n  m_currentFrame = int(((SDL_GetTicks() / (100)) % m_numFrames));\n}\n```", "```cpp\nvoid TextureManager::drawFrame(std::string id, int x, int y, int \nwidth, int height, int currentRow, int currentFrame, SDL_Renderer \n*pRenderer, double angle, int alpha, SDL_RendererFlip flip)\n{\n  SDL_Rect srcRect;\n  SDL_Rect destRect;\n  srcRect.x = width * currentFrame;\n  srcRect.y = height * currentRow;\n  srcRect.w = destRect.w = width;\n  srcRect.h = destRect.h = height;\n  destRect.x = x;\n  destRect.y = y;\n\n  // set the alpha of the texture and pass in the angle\n  SDL_SetTextureAlphaMod(m_textureMap[id], alpha);\n  SDL_RenderCopyEx(pRenderer, m_textureMap[id], &srcRect, \n  &destRect, angle, 0, flip);\n}\n```", "```cpp\nvoid Player::update()\n{\n  // if the level is complete then fly off the screen\n  if(TheGame::Instance()->getLevelComplete())\n  {\n    if(m_position.getX() >= TheGame::Instance()->getGameWidth())\n    {\n      TheGame::Instance()->setCurrentLevel(TheGame::Instance()\n      ->getCurrentLevel() + 1);\n    }\n    else\n    {\n      m_velocity.setY(0);\n      m_velocity.setX(3);\n      ShooterObject::update();\n      handleAnimation();\n    }\n  }\n  else\n  {\n    // if the player is not doing its death animation then update \n    it normally\n    if(!m_bDying)\n    {\n      // reset velocity\n      m_velocity.setX(0);\n      m_velocity.setY(0);\n\n      // get input\n      handleInput();\n      // do normal position += velocity update\n      ShooterObject::update();\n\n      // update the animation\n      handleAnimation();\n    }\n    else // if the player is doing the death animation\n    {\n      m_currentFrame = int(((SDL_GetTicks() / (100)) % \n      m_numFrames));\n\n      // if the death animation has completed\n      if(m_dyingCounter == m_dyingTime)\n      {\n        // ressurect the player\n        ressurect();\n      }\n\n      m_dyingCounter++;\n    }\n  }\n}\n```", "```cpp\nTheGame::Instance()->setCurrentLevel(TheGame::Instance()->getCurrentLevel() + 1);\n```", "```cpp\nvoid Game::setCurrentLevel(int currentLevel)\n{\n  m_currentLevel = currentLevel;\n  m_pGameStateMachine->changeState(new BetweenLevelState());\n  m_bLevelComplete = false;\n}\n```", "```cpp\n// Enemy base class\nclass Enemy : public ShooterObject\n{\npublic:\n  virtual std::string type() { return\"Enemy\"; }\n\nprotected:\n  int m_health;\n\n  Enemy() : ShooterObject() {}\n  virtual ~Enemy() {} // for polymorphism\n\n};\n```", "```cpp\nvoid ScrollingBackground::load(std::unique_ptr<LoaderParams> const &pParams)\n{\n  ShooterObject::load(std::move(pParams));\n  m_scrollSpeed = pParams->getAnimSpeed();\n\n  m_scrollSpeed = 1;\n\n  m_srcRect1.x = 0;\n  m_destRect1.x = m_position.getX();\n  m_srcRect1.y = 0;\n  m_destRect1.y = m_position.getY();\n\n  m_srcRect1.w = m_destRect1.w = m_srcRect2Width = \n  m_destRect1Width = m_width;\n  m_srcRect1.h = m_destRect1.h = m_height;\n\n  m_srcRect2.x = 0;\n  m_destRect2.x = m_position.getX() + m_width;\n  m_srcRect2.y = 0;\n  m_destRect2.y = m_position.getY();\n\n  m_srcRect2.w = m_destRect2.w = m_srcRect2Width = \n  m_destRect2Width = 0;\n  m_srcRect2.h = m_destRect2.h = m_height;\n}\n\nvoid ScrollingBackground::draw()\n{\n  // draw first rect\n  SDL_RenderCopyEx(TheGame::Instance()->getRenderer(), \n  TheTextureManager::Instance()->getTextureMap()[m_textureID], \n  &m_srcRect1, &m_destRect1, 0, 0, SDL_FLIP_NONE);\n\n  // draw second rect\n  SDL_RenderCopyEx(TheGame::Instance()->getRenderer(), \n  TheTextureManager::Instance()->getTextureMap()[m_textureID], \n  &m_srcRect2, &m_destRect2, 0, 0, SDL_FLIP_NONE);\n\n}\n\nvoid ScrollingBackground::update()\n{\n  if(count == maxcount)\n  {\n    // make first rectangle smaller\n    m_srcRect1.x += m_scrollSpeed;\n    m_srcRect1.w -= m_scrollSpeed;\n    m_destRect1.w -= m_scrollSpeed;\n\n    // make second rectangle bigger\n    m_srcRect2.w += m_scrollSpeed;\n    m_destRect2.w += m_scrollSpeed;\n    m_destRect2.x -= m_scrollSpeed;\n\n    // reset and start again\n    if(m_destRect2.w >= m_width)\n    {\n      m_srcRect1.x = 0;\n      m_destRect1.x = m_position.getX();\n      m_srcRect1.y = 0;\n      m_destRect1.y = m_position.getY();\n\n      m_srcRect1.w = m_destRect1.w = m_srcRect2Width = \n      m_destRect1Width = m_width;\n      m_srcRect1.h = m_destRect1.h = m_height;\n\n      m_srcRect2.x = 0;\n      m_destRect2.x = m_position.getX() + m_width;\n      m_srcRect2.y = 0;\n      m_destRect2.y = m_position.getY();\n\n      m_srcRect2.w = m_destRect2.w = m_srcRect2Width = \n      m_destRect2Width = 0;\n      m_srcRect2.h = m_destRect2.h = m_height;\n    }\n    count = 0;\n  }\n\n  count++;\n}\n```", "```cpp\nclass PlayerBullet : public ShooterObject\n{\npublic:\n\n  PlayerBullet() : ShooterObject()\n  {\n  }\n\n  virtual ~PlayerBullet() {}\n\n  virtual std::string type() { return \"PlayerBullet\"; }\n\n  virtual void load(std::unique_ptr<LoaderParams> pParams, Vector2D \n  heading)\n  {\n    ShooterObject::load(std::move(pParams));\n    m_heading = heading;\n  }\n\n  virtual void draw()\n  {\n    ShooterObject::draw();\n  }\n\n  virtual void collision()\n  {\n    m_bDead = true;\n  }\n\n  virtual void update()\n  {\n    m_velocity.setX(m_heading.getX());\n    m_velocity.setY(m_heading.getY());\n\n    ShooterObject::update();\n  }\n\n  virtual void clean()\n  {\n    ShooterObject::clean();\n  }\n\nprivate:\n\n  Vector2D m_heading;\n};\n\n// Enemy Bullet is just a Player Bullet with a different typename\nclass EnemyBullet : public PlayerBullet\n{\npublic:\n\n  EnemyBullet() : PlayerBullet()\n  {\n  }\n\n  virtual ~EnemyBullet() {}\n\n  virtual std::string type() { return \"EnemyBullet\"; }\n};\n```", "```cpp\nvoid addPlayerBullet(int x, int y, int width, int height, std::string textureID, int numFrames, Vector2D heading);\nvoid addEnemyBullet(int x, int y, int width, int height, std::string textureID, int numFrames, Vector2D heading);\n```", "```cpp\nTheBulletHandler::Instance()->addEnemyBullet(m_position.getX(), m_position.getY() + 15, 16, 16, \"bullet2\", 1, Vector2D(-10, 0));\n```", "```cpp\nvoid BulletHandler::addPlayerBullet(int x, int y, int width, int \n  height, std::string textureID, int numFrames, Vector2D heading)\n{\n  PlayerBullet* pPlayerBullet = newPlayerBullet();\n  pPlayerBullet->load(std::unique_ptr<LoaderParams>(new \n  LoaderParams(x, y, width, height, textureID, numFrames)), \n  heading);\n\n  m_playerBullets.push_back(pPlayerBullet);\n}\n\nvoid BulletHandler::addEnemyBullet(int x, int y, int width, int \nheight, std::string textureID, int numFrames, Vector2D heading)\n{\n  EnemyBullet* pEnemyBullet = new EnemyBullet();\n  pEnemyBullet->load(std::unique_ptr<LoaderParams>(new \n  LoaderParams(x, y, width, height, textureID, numFrames)), \n  heading);\n\n  m_enemyBullets.push_back(pEnemyBullet);\n}\n```", "```cpp\nfor (std::vector<PlayerBullet*>::iterator p_it = \nm_playerBullets.begin(); p_it != m_playerBullets.end();)\n{\n  if((*p_it)->getPosition().getX() < 0 || (*p_it)\n  ->getPosition().getX() >TheGame::Instance()->getGameWidth()\n  || (*p_it)->getPosition().getY() < 0 || (*p_it)->\n  getPosition().getY() >TheGame::Instance()->getGameHeight() || \n  (*p_it)->dead())// if off screen or dead\n  {\n    delete * p_it; // delete the bullet\n    p_it = m_playerBullets.erase(p_it); //remove\n  }\n  else// continue to update and loop\n  {\n    (*p_it)->update();\n    ++p_it;\n  }\n}\n```", "```cpp\nconst static int s_buffer = 4;\n\nstatic bool RectRect(SDL_Rect* A, SDL_Rect* B)\n{\n  int aHBuf = A->h / s_buffer;\n  int aWBuf = A->w / s_buffer;\n\n  int bHBuf = B->h / s_buffer;\n  int bWBuf = B->w / s_buffer;\n\n  // if the bottom of A is less than the top of B - no collision\n  if((A->y + A->h) - aHBuf <= B->y + bHBuf)  { return false; }\n\n  // if the top of A is more than the bottom of B = no collision\n  if(A->y + aHBuf >= (B->y + B->h) - bHBuf)  { return false; }\n\n  // if the right of A is less than the left of B - no collision\n  if((A->x + A->w) - aWBuf <= B->x +  bWBuf) { return false; }\n\n  // if the left of A is more than the right of B - no collision\n  if(A->x + aWBuf >= (B->x + B->w) - bWBuf)  { return false; }\n\n  // otherwise there has been a collision\n return true;\n}\n```", "```cpp\nPlayer* m_pPlayer;\n```", "```cpp\nPlayer* getPlayer() { return m_pPlayer; }\nvoid setPlayer(Player* pPlayer) { m_pPlayer = pPlayer; }\n```", "```cpp\npGameObject->load(std::unique_ptr<LoaderParams>(new LoaderParams(x, y, width, height, textureID, numFrames,callbackID, animSpeed)));\n\nif(type == \"Player\") // check if it's the player\n{\n  pLevel->setPlayer(dynamic_cast<Player*>(pGameObject));\n}\n\npObjectLayer->getGameObjects()->push_back(pGameObject);\n```", "```cpp\nelse if(e->FirstChildElement()->Value() == std::string(\"data\") || (e->FirstChildElement()->NextSiblingElement() != 0 && e->FirstChildElement()->NextSiblingElement()->Value() == std::string(\"data\")))\n{\n  parseTileLayer(e, pLevel->getLayers(), pLevel->getTilesets(), \n  pLevel->getCollisionLayers());\n}\n```", "```cpp\n// local temporary variable\nbool collidable = false;\n\n// other code…\n\nfor(TiXmlElement* e = pTileElement->FirstChildElement(); e != NULL; e = e->NextSiblingElement())\n{\n  if(e->Value() == std::string(\"properties\"))\n  {\n    for(TiXmlElement* property = e->FirstChildElement(); property != NULL; property = property->NextSiblingElement())\n    {\n      if(property->Value() == std::string(\"property\"))\n      {\n        if(property->Attribute(\"name\") == std::string(\"collidable\"))\n        {\n          collidable = true;\n        }\n      }\n    }\n  }\n\n  if(e->Value() == std::string(\"data\"))\n  {\n    pDataNode = e;\n  }\n}\n\n// other code…\n\n// push into collision array if necessary\nif(collidable)\n{\n  pCollisionLayers->push_back(pTileLayer);\n}\n\npLayers->push_back(pTileLayer);\n```", "```cpp\nclass CollisionManager\n{\npublic:\n\n  void checkPlayerEnemyBulletCollision(Player* pPlayer);\n  void checkPlayerEnemyCollision(Player* pPlayer, const \n  std::vector<GameObject*> &objects);\n  void checkEnemyPlayerBulletCollision(const \n  std::vector<GameObject*> &objects);\n  void checkPlayerTileCollision(Player* pPlayer, const \n  std::vector<TileLayer*> &collisionLayers);\n};\n```", "```cpp\nif(objects[i]->type() != std::string(\"Enemy\") || !objects[i]->updating())\n{\n continue;\n}\n```", "```cpp\nvoid CollisionManager::checkPlayerTileCollision(Player* pPlayer, \n  const std::vector<TileLayer*> &collisionLayers)\n{\n  // iterate through collision layers\n  for(std::vector<TileLayer*>::const_iterator it = \n  collisionLayers.begin(); it != collisionLayers.end(); ++it)\n  {\n    TileLayer* pTileLayer = (*it);\n    std::vector<std::vector<int>> tiles = pTileLayer-\n    >getTileIDs();\n\n    // get this layers position\n    Vector2D layerPos = pTileLayer->getPosition();\n\n    int x, y, tileColumn, tileRow, tileid = 0;\n\n    // calculate position on tile map\n    x = layerPos.getX() / pTileLayer->getTileSize();\n    y = layerPos.getY() / pTileLayer->getTileSize();\n\n    // if moving forward or upwards\n    if(pPlayer->getVelocity().getX() >= 0 || pPlayer-\n    >getVelocity().getY() >= 0)\n    {\n      tileColumn = ((pPlayer->getPosition().getX() + pPlayer-\n      >getWidth()) / pTileLayer->getTileSize());\n      tileRow = ((pPlayer->getPosition().getY() + pPlayer-\n      >getHeight()) \n      / pTileLayer->getTileSize());\n      tileid = tiles[tileRow + y][tileColumn + x];\n    }\n    else if(pPlayer->getVelocity().getX() < 0 || pPlayer-\n    >getVelocity().getY() < 0) // if moving backwards or downwards\n    {\n      tileColumn = pPlayer->getPosition().getX() / pTileLayer-\n      >getTileSize();\n      tileRow = pPlayer->getPosition().getY() / pTileLayer-\n      >getTileSize();\n      tileid = tiles[tileRow + y][tileColumn + x];\n    }\n    if(tileid != 0) // if the tile id not blank then collide\n    {\n      pPlayer->collision();\n    }\n  }\n}\n```"]