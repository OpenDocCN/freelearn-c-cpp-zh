- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Creating an Online Chat
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建在线聊天
- en: Welcome to the next chapter of our book on making online multiplayer games using
    Godot Engine 4.0!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们关于使用 Godot Engine 4.0 制作在线多人游戏的书籍的下一章！
- en: In the previous chapter, we saw how to make a lobby for players and its importance
    to gathering before entering a game. Now, we will take a step further and explore
    the development of an online chat using Godot’s Network API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了如何为玩家创建大厅以及它在进入游戏前聚集玩家的重要性。现在，我们将更进一步，探讨使用 Godot 的网络 API 开发在线聊天的过程。
- en: As we saw, Godot’s Network API provides us with a robust set of tools for building
    real-time multiplayer games. In this chapter, we will use the `ENetMultiplayerPeer`
    class to establish a reliable connection between players, and some **remote procedure
    call** (**RPC**) methods to handle the chat system’s logic.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Godot 的网络 API 为我们提供了一套强大的工具，用于构建实时多人游戏。在本章中，我们将使用 `ENetMultiplayerPeer`
    类在玩家之间建立可靠的连接，并使用一些 **远程过程调用**（**RPC**）方法来处理聊天系统的逻辑。
- en: As you may already know, a chat system is essential in any online multiplayer
    game, as it enables players to communicate with each other during gameplay. A
    well-designed chat system can greatly enhance the player experience, allowing
    for smoother coordination between team members and encouraging socialization among
    players.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经知道，在任何在线多人游戏中，聊天系统都是必不可少的，因为它允许玩家在游戏过程中相互沟通。一个设计良好的聊天系统可以极大地提升玩家体验，使团队成员之间的协调更加顺畅，并鼓励玩家之间的社交互动。
- en: 'In this chapter, we’ll also explore the importance of using multiple communication
    channels in our network. We introduced this concept in the previous chapter, but
    now we are going to see how to actually use this feature in RPC methods so that
    our network is able to smoothly pass data around peers. By the end of the following
    step-by-step instructions, we will end up with the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将探讨在网络中使用多个通信渠道的重要性。我们在上一章中介绍了这个概念，但现在我们将看到如何在实际的 RPC 方法中使用这个功能，以便我们的网络能够顺畅地在玩家之间传递数据。在以下逐步指导的末尾，我们将得到以下结果：
- en: '![Figure 4.1 – The Chat screen with players exchanging messages](img/Figure_04.01_B18527.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 玩家交换信息的聊天界面](img/Figure_04.01_B18527.jpg)'
- en: Figure 4.1 – The Chat screen with players exchanging messages
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 玩家交换信息的聊天界面
- en: 'We will cover the following topics in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding data exchange and channels
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数据交换和通道
- en: Sending chat messages
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送聊天消息
- en: Updating peer’s data remotely
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程更新玩家的数据
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Through this chapter, we are going to use the fourth folder of our Godot Engine
    project repository, available through the following link:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们将使用 Godot 引擎项目仓库的第四个文件夹，该文件夹可通过以下链接获取：
- en: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)'
- en: After importing the project into your Godot Engine project manager, open it
    and navigate to the `res://04.creating-an-online-chat` folder. Then, open the
    `ChatControl.tscn` and `ChatControl.gd` files. They are going to be the focus
    of this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在将项目导入你的 Godot 引擎项目管理器后，打开它并导航到 `res://04.creating-an-online-chat` 文件夹。然后，打开
    `ChatControl.tscn` 和 `ChatControl.gd` 文件。它们将是本章的重点。
- en: Coming next in this chapter, we are going to learn the basic concepts of reliable
    and unreliable data exchange and how channels work so we have the ground set for
    our chat system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章接下来的内容中，我们将学习可靠和不可靠数据交换的基本概念以及通道的工作原理，以便为我们的聊天系统打下基础。
- en: Understanding data exchange and channels
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数据交换和通道
- en: A chat system is essentially a chronological stack of messages that we order
    based on what players send to each other. Since this system needs a coherent chronological
    order, we need to understand how to prevent data from getting mixed and disorganized
    as it gets transmitted throughout the network. We also need to prevent this ordering
    from impacting other systems and components. To do that, we are going to learn
    how we can send packets reliably and how we can use multiple channels for data
    exchange.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天系统本质上是一个按时间顺序排列的消息堆栈，我们根据玩家之间发送的消息来排序。由于这个系统需要一个连贯的时间顺序，我们需要了解如何防止数据在网络传输过程中变得混乱和无序。我们还需要防止这种排序影响其他系统和组件。为此，我们将学习如何可靠地发送数据包，以及如何使用多个通道进行数据交换。
- en: Reliable and unreliable packets
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可靠和不可靠的包
- en: Godot Engine’s Network API allows for reliable and unreliable data exchange
    between peers. The `@rpc` annotation provides a way to transmit data securely
    between clients and the server using different transport protocols such as UDP
    and TCP. Reliable data exchange ensures that data is delivered in order and is
    not lost in transit, making it ideal for crucial data such as chat messages. Unreliable
    data exchange is faster and more efficient but offers no guarantee of order or
    delivery, making it ideal for non-critical data such as player position or real-time
    updates. In our chat system, we use the reliable `@rpc` option for chat messages
    to ensure that they are delivered in a timely manner without loss or duplication.
    Reliable data exchange ensures that players are able to follow the conversation
    and respond appropriately. Channels provide another layer of control over data
    exchange, allowing for better network optimization by prioritizing or separating
    data sent through different channels.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 引擎的网络 API 允许在节点之间进行可靠和不可靠的数据交换。`@rpc` 注解提供了一种使用不同的传输协议（如 UDP 和 TCP）在客户端和服务器之间安全传输数据的方法。可靠的数据交换确保数据按顺序交付，并且在传输过程中不会丢失，这使得它非常适合像聊天消息这样的关键数据。不可靠的数据交换更快、更高效，但无法保证数据的顺序或交付，这使得它非常适合像玩家位置或实时更新这样的非关键数据。在我们的聊天系统中，我们使用可靠的
    `@rpc` 选项来确保聊天消息能够及时无误地送达。可靠的数据交换确保玩家能够跟随对话并做出适当的回应。通道提供了对数据交换的又一层控制，通过优先处理或分离通过不同通道发送的数据，从而实现更好的网络优化。
- en: In the upcoming section, let’s learn how channels work and what we can do with
    them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将学习通道是如何工作的，以及我们可以用它们做什么。
- en: Understanding channels
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解通道
- en: When developing multiplayer games in Godot Engine, understanding how communication
    channels work within the Network API is crucial for optimizing network performance
    and minimizing latency. In the context of Godot Engine’s Network API, communication
    channels are used to separate different types of data being exchanged between
    peers. For example, you may want to use one channel for game state updates, another
    channel for chat messages, and another channel for player movement data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Godot 引擎中开发多人游戏时，理解网络 API 中通信通道的工作方式对于优化网络性能和最小化延迟至关重要。在 Godot 引擎网络 API 的上下文中，通信通道用于在节点之间交换的不同类型的数据进行分离。例如，你可能希望使用一个通道来更新游戏状态，另一个通道来发送聊天消息，还有另一个通道来发送玩家移动数据。
- en: The `@rpc` annotation in Godot Engine’s Network API provides an option to specify
    the channel that an RPC method should use for sending and receiving data. By default,
    all RPC methods use channel `0`. However, we can specify a different channel by
    passing an integer number as the last option in the `@rpc` annotation. For example,
    if you want to use a channel for game state updates, you can assign game state
    updates to channel `1` and chat messages to channel `2`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 引擎网络 API 中的 `@rpc` 注解提供了一个选项，用于指定 RPC 方法在发送和接收数据时应使用的通道。默认情况下，所有 RPC 方法都使用通道
    `0`。然而，我们可以通过在 `@rpc` 注解中将一个整数作为最后一个选项传递来指定不同的通道。例如，如果你想为游戏状态更新使用一个通道，你可以将游戏状态更新分配给通道
    `1`，将聊天消息分配给通道 `2`。
- en: Using multiple channels in your Godot Engine multiplayer game can help improve
    network performance and minimize latency. By separating different types of data
    into separate channels, you can prioritize more important data and prevent congestion
    on a single channel.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Godot 引擎多人游戏中使用多个通道可以帮助提高网络性能并最小化延迟。通过将不同类型的数据分离到不同的通道中，你可以优先处理更重要的数据，并防止单个通道上的拥堵。
- en: It’s worth noting that using multiple channels can also help prevent data loss
    and corruption in the event of packet loss or network congestion. By separating
    data into different channels, you can ensure that data loss or corruption on one
    channel doesn’t affect the other channels. This can help prevent issues such as
    desynchronization between peers or corrupted game data. We are going to talk about
    that in the next section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，使用多个通道也可以在数据包丢失或网络拥塞的情况下帮助防止数据丢失和损坏。通过将数据分离到不同的通道，你可以确保一个通道上的数据丢失或损坏不会影响其他通道。这有助于防止诸如同伴之间的不同步或损坏的游戏数据等问题。我们将在下一节中讨论这一点。
- en: Remember, we are going to use reliable data exchange for our messages, so we
    can’t prevent players from updating other crucial information, such as their and
    others’ avatars’ positions, just because the data exchange channel is still waiting
    for a chat message to arrive. It’s wise to use another channel for that. Let’s
    see how this works.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们将使用可靠的数据交换来处理我们的消息，因此我们不能因为数据交换通道仍在等待聊天消息到达，就阻止玩家更新其他关键信息，例如他们和他人头像的位置。为此使用另一个通道是明智的。让我们看看它是如何工作的。
- en: 'Open the `res://04.creating-an-online-chat/ChatControl.tscn` scene and you
    will notice it’s already structured with all the necessary nodes we need to make
    our chat system. So, we are going to focus on the script here. The following figure
    shows the `ChatControl` scene node hierarchy:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `res://04.creating-an-online-chat/ChatControl.tscn` 场景，你会注意到它已经按照我们制作聊天系统所需的全部节点进行了结构化。因此，我们将重点放在脚本上。以下图显示了
    `ChatControl` 场景节点的层次结构：
- en: '![Figure 4.2 – The ChatControl scene node hierarchy](img/Figure_04.02_B18527.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – ChatControl 场景节点层次结构](img/Figure_04.02_B18527.jpg)'
- en: Figure 4.2 – The ChatControl scene node hierarchy
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – ChatControl 场景节点层次结构
- en: 'From there, open the `res://04.creating-an-online-chat/ChatControl.gd` file,
    and make the method responsible for adding messages to the chat:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，打开 `res://04.creating-an-online-chat/ChatControl.gd` 文件，并使负责向聊天添加消息的方法：
- en: 'Create an `@rpc` annotation on top of the `add_message()` method. This RPC
    method should be available to any peer; it should also call itself locally. On
    top of that, it’ll be a reliable method. Finally, here, we are going to use a
    separate channel to exchange data, so let’s use channel `2`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `add_message()` 方法上方创建一个 `@rpc` 注解。这个 RPC 方法应该对任何同伴都可用；它也应该在本地调用自己。在此基础上，它将是一个可靠的方法。最后，在这里，我们将使用一个单独的通道来交换数据，所以让我们使用通道
    `2`：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside the `add_message()` method, create a new variable called `message_text`
    that’s going to use the `_avatar_name` String and the message arguments to create
    a text that uses two placeholders separated by a colon, like this:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `add_message()` 方法内部，创建一个名为 `message_text` 的新变量，它将使用 `_avatar_name` 字符串和消息参数来创建一个使用两个冒号分隔的占位符的文本，如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, concatenate the `label.text`String, skip a line, and then add the `message_text`
    String. This will add the latest message to the players’ visible chat:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，连接 `label.text` 字符串，换行，然后添加 `message_text` 字符串。这将把最新的消息添加到玩家的可见聊天中：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, to ensure the players’ chat is always showing the latest message,
    we update `container.scroll_vertical` to match the `label.size.y float`. This
    way, it will scroll to the bottom of the chat label, displaying the latest message:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了确保玩家的聊天总是显示最新的消息，我们将 `container.scroll_vertical` 更新为与 `label.size.y float`
    匹配。这样，它将滚动到聊天标签的底部，显示最新的消息：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The complete `add_message()` method should look like this at this point:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，`add_message()` 方法应该看起来像这样：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With that, we can use a dedicated channel to transmit our players’ messages
    from one to another and display them in each player’s chat interface. Using an
    independent data transmission channel is as simple as adding an integer number
    as the last option of a function’s `@``rpc` annotation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们可以使用专用通道从一名玩家传输消息到另一名玩家，并在每个玩家的聊天界面中显示它们。使用独立的数据传输通道就像在函数的 `@rpc` 注解的最后选项中添加一个整数一样简单。
- en: In the next section, let’s learn how we can gather the player’s message and
    actually process it, sending it to other players throughout our peers’ network.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们学习如何收集玩家的消息并实际处理它，将其发送到我们同伴网络中的其他玩家。
- en: Sending chat messages
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送聊天消息
- en: Godot Engine’s RPCs allow for efficient data transmission between clients and
    the server in multiplayer games. We can create an RPC method for this specific
    purpose, with message data as arguments. The transmission can be either reliable
    or unreliable, depending on the needs of the application. Once the message is
    sent, it’s received by the appropriate recipients (including clients and the server)
    who handle it appropriately, such as by displaying it to the user or logging it.
    We did that in the *Understanding data exchange and channels* section when we
    made the `add_message()` method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Godot引擎的RPC允许在多人游戏中在客户端和服务器之间进行高效的数据传输。我们可以为这个特定目的创建一个RPC方法，将消息数据作为参数。传输可以是可靠的或不可靠的，具体取决于应用程序的需求。一旦消息被发送，它就会被适当的接收者（包括客户端和服务器）接收，并适当地处理，例如显示给用户或记录。我们在*理解数据交换和通道*部分做到了这一点，当时我们创建了`add_message()`方法。
- en: Sending messages using Godot’s RPCs is a straightforward process that involves
    defining the message format. In our case, we use the player’s avatar name and
    the message content, as seen previously, calling an RPC method to transmit the
    message and handling the message appropriately on the receiving end.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Godot的RPC发送消息是一个直接的过程，涉及定义消息格式。在我们的例子中，我们使用玩家的头像名称和消息内容，如之前所见，调用RPC方法来传输消息，并在接收端适当地处理消息。
- en: 'We are going to implement a method to read the message that players input using
    the `LineEdit` node and send it to all peers on the network. For that, we are
    going to use the `LineEdit.text_submitted` signal connected to the `_on_line_edit_text_submitted()`
    callback method, as shown in the following image:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个方法来读取玩家使用`LineEdit`节点输入的消息，并将其发送到网络上的所有对等节点。为此，我们将使用连接到`_on_line_edit_text_submitted()`回调方法的`LineEdit.text_submitted`信号，如下面的图像所示：
- en: '![Figure 4.3 – The LineEdit text_submitted signal connection](img/Figure_04.03_B18527.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – LineEdit文本提交信号连接](img/Figure_04.03_B18527.jpg)'
- en: Figure 4.3 – The LineEdit text_submitted signal connection
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – LineEdit文本提交信号连接
- en: 'With the signal connected, open the script and let’s work on the `_on_line_edit_text_submitted()`
    method:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 信号连接后，打开脚本，让我们来处理`_on_line_edit_text_submitted()`方法：
- en: 'The first thing we need to do is to prevent the processing of empty messages.
    For this, let’s return from the function if the `new_text` argument is an empty
    string:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是防止处理空消息。为此，让我们在`new_text`参数是空字符串时从函数中返回：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we can make an RPC to the `add_message()` method. This will call this
    method on all connected peers. We are going to pass the `ChatControl.avatar_name`
    String and the `new_text` String as arguments so the peers have the proper data
    to create their chat messages:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以调用`add_message()`方法进行RPC。这将调用所有已连接节点的此方法。我们将传递`ChatControl.avatar_name`字符串和`new_text`字符串作为参数，以便对等节点有适当的数据来创建他们的聊天消息：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we clear the `line_edit.text` String to visually communicate that
    the game received the player’s message and is processing it:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们清除`line_edit.text`字符串，以视觉上传达游戏已收到玩家的消息并正在处理它：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The complete `_on_line_edit_text_submitted()` method should look like the following:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的`_on_line_edit_text_submitted()`方法应如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this method, any player in the game will be able to input a message and
    ask all peers, including themselves, to add a new message to their chat based
    on the `add_message()` logic we saw previously.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，游戏中的任何玩家都将能够输入一条消息，并要求所有对等节点（包括他们自己）根据我们之前看到的`add_message()`逻辑添加一条新消息到他们的聊天中。
- en: Now, we need to understand how we are going to update each player about other
    players’ messages. In the next section, we will learn how to use RPCs on nodes
    other than the root node of a scene. With that, we will be able to make more concise
    scripts since we won’t bloat our classes with methods they won’t implement.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要了解我们将如何更新每个玩家关于其他玩家消息的情况。在下一节中，我们将学习如何在场景的根节点之外的节点上使用RPC。有了这个，我们将能够编写更简洁的脚本，因为我们不会在不会实现的方法中膨胀我们的类。
- en: Updating peer’s data remotely
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程更新对等节点数据
- en: Something really cool about Godot Engine’s Network API is that we can abuse
    RPCs to pass data around. For instance, we’ve seen that we use the player’s avatar
    name in our messages. But have you asked yourself how we retrieve this data in
    any of these steps?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Godot引擎的Network API中真正酷的地方是我们可以利用RPC在各个地方传递数据。例如，我们已经看到我们在消息中使用玩家的头像名称。但你有没有想过在这些步骤中我们是如何检索这些数据的？
- en: You probably saw that there’s an RPC method called `set_avatar_name()`, right?
    Since its `@rpc` annotation doesn’t have any options, you can assume that it uses
    the default options. This is important to know because, as we saw previously,
    this means that it should be called remotely only by the **Multiplayer Authority**
    – in this case, the server.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能看到了一个名为`set_avatar_name()`的RPC方法，对吧？由于它的`@rpc`注解没有任何选项，你可以假设它使用默认选项。了解这一点很重要，因为正如我们之前所看到的，这意味着它应该只由**多人游戏权限**（在这种情况下，服务器）远程调用。
- en: 'Let’s open `ChatServer.gd` to understand what’s happening behind the scenes.
    In essence, most of it is pretty much the same as in the `retrieve_avatar()` RPC
    method. In *line 39*, we have the following instruction:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`ChatServer.gd`文件，了解幕后发生了什么。本质上，大部分内容与`retrieve_avatar()` RPC方法几乎相同。在*第39行*，我们有以下指令：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We saw that this is a way to keep the sender of the latest RPC in memory so
    that we can refer back to it if necessary, and in this case, it will be necessary.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到这是一种方法，可以将最新RPC的发送者保存在内存中，以便在必要时可以回溯，在这种情况下，这是必要的。
- en: 'In *line 45*, we make a `rpc_id()` call to the `set_avatar_name()` method on
    the peer that just requested its avatar’s data:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第45行*，我们向刚刚请求其头像数据的玩家调用`rpc_id()`方法来调用`set_avatar_name()`方法：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that there’s something else on top of that. We are calling this `rpc_id()`
    method from the `ChatControl` node, which is a child node of the `Main` root node.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有其他一些内容。我们是从`ChatControl`节点调用这个`rpc_id()`方法，它是`Main`根节点的子节点。
- en: 'This is the server’s own `ChatControl` node. Since the server and client’s
    scene tree have the same `NodePath` to their `ChatControl` node, we can make this
    `rpc_id()` call on the server’s `ChatControl`node instead of making it from the
    `Main` node, and it will remotely call it on the player who requested their avatar’s
    data:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是服务器的`ChatControl`节点。由于服务器和客户端的场景树具有相同的`NodePath`到它们的`ChatControl`节点，我们可以在服务器的`ChatControl`节点上执行这个`rpc_id()`调用，而不是从`Main`节点调用，它将远程调用它，请求其头像数据的玩家：
- en: "![Figure 4.\uFEFF4– The ChatServer and ChatClient’s scene node hierarchies](img/Figure_04.04_B18527.jpg)"
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4–ChatServer和ChatClient的场景节点层次结构](img/Figure_04.04_B18527.jpg)'
- en: Figure 4.4– The ChatServer and ChatClient’s scene node hierarchies
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4–ChatServer和ChatClient的场景节点层次结构
- en: This is a good and simple way to prevent bloating a single class with many RPC
    methods because, remember, if a caller has an RPC method, all peers should have
    this method on their equivalent nodes at the same `NodePath`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个防止单个类因包含许多RPC方法而膨胀的好方法，因为记住，如果调用者有一个RPC方法，所有节点都应该在其等效节点上具有相同的`NodePath`上的此方法。
- en: It’s also a very effective way to remotely update nodes with new data. RPCs
    are really impressive and useful tools to have at our disposal when making online
    multiplayer games with Godot Engine.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一种非常有效的方法，可以远程更新节点的新数据。RPCs（远程过程调用）是我们在使用Godot引擎制作在线多人游戏时，可以拥有的非常令人印象深刻且有用的工具。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we saw how we can use `RPC` methods to pass data around
    and perform actions on multiple peers of our network. We also understood the core
    difference between reliable and unreliable data exchange and saw some examples
    of situations of when to use each one. Due to this core difference in the way
    we can exchange data between the peers of our network, we also understood that
    one way may block the other, so we can use channels to prevent that one type of
    data from getting in the way of another type of data unrelated to that exchange.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用`RPC`方法在网络的多个节点之间传递数据和执行操作。我们还理解了可靠和不可靠数据交换之间的核心区别，并看到了一些使用每种情况的示例。由于我们可以在网络节点之间交换数据的方式存在这种核心区别，我们也理解了一种方式可能会阻塞另一种方式，因此我们可以使用通道来防止这种类型的数据阻碍与该交换无关的其他类型的数据。
- en: By creating an online lobby where players can chat, we saw how to use the `@rpc`
    annotation with some of its available options, including the option to allow other
    peers to make remote calls instead of only the Multiplayer Authority.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个玩家可以聊天的在线大厅，我们看到了如何使用`@rpc`注解及其一些可用选项，包括允许其他玩家进行远程调用而不是只有多人游戏权限。
- en: In the next chapter, we will use the knowledge we’ve just acquired to build
    an actual real-time multiplayer experience. We’ll create a multiplayer online
    quiz where players will compete to see who can pick the correct answer the quickest.
    See you there!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用我们刚刚获得的知识来构建一个实际的实时多人体验。我们将创建一个多人在线问答游戏，玩家将竞争看谁能够最快地选择正确的答案。那里见！
- en: Part 2:Creating Online Multiplayer Mechanics
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：创建在线多人游戏机制
- en: After understanding the tools we have available to create online multiplayer
    games, we put them into context by creating actual game prototypes. In this part,
    we learn how to turn single-player games into online multiplayer games, starting
    with a quiz game and ending with a prototype of an MMORPG game.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解我们可用于创建在线多人游戏的工具后，我们通过创建实际的游戏原型来将这些工具置于具体情境中。在本部分中，我们学习如何将单人游戏转变为在线多人游戏，从问答游戏开始，以MMORPG游戏的原型结束。
- en: 'This part contains the following chapters:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B18527_05.xhtml#_idTextAnchor108)*,* *Making an Online Quiz Game*'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18527_05.xhtml#_idTextAnchor108)*,* *制作在线问答游戏*'
- en: '[*Chapter 6*](B18527_06.xhtml#_idTextAnchor131), *Building an Online Checkers
    Game*'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18527_06.xhtml#_idTextAnchor131), *构建在线国际象棋游戏*'
- en: '[*Chapter 7*](B18527_07.xhtml#_idTextAnchor146), *Developing an Online Pong
    Game*'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18527_07.xhtml#_idTextAnchor146), *开发在线乒乓球游戏*'
- en: '[*Chapter 8*](B18527_08.xhtml#_idTextAnchor162), *Designing an Online Co-Op
    Platformer*'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18527_08.xhtml#_idTextAnchor162), *设计在线合作平台游戏*'
- en: '[*Chapter 9*](B18527_09.xhtml#_idTextAnchor188), *Creating an Online Adventure
    Prototype*'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18527_09.xhtml#_idTextAnchor188), *创建在线冒险原型*'
