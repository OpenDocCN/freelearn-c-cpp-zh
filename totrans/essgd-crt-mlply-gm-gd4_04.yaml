- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an Online Chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the next chapter of our book on making online multiplayer games using
    Godot Engine 4.0!
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how to make a lobby for players and its importance
    to gathering before entering a game. Now, we will take a step further and explore
    the development of an online chat using Godot’s Network API.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw, Godot’s Network API provides us with a robust set of tools for building
    real-time multiplayer games. In this chapter, we will use the `ENetMultiplayerPeer`
    class to establish a reliable connection between players, and some **remote procedure
    call** (**RPC**) methods to handle the chat system’s logic.
  prefs: []
  type: TYPE_NORMAL
- en: As you may already know, a chat system is essential in any online multiplayer
    game, as it enables players to communicate with each other during gameplay. A
    well-designed chat system can greatly enhance the player experience, allowing
    for smoother coordination between team members and encouraging socialization among
    players.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll also explore the importance of using multiple communication
    channels in our network. We introduced this concept in the previous chapter, but
    now we are going to see how to actually use this feature in RPC methods so that
    our network is able to smoothly pass data around peers. By the end of the following
    step-by-step instructions, we will end up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The Chat screen with players exchanging messages](img/Figure_04.01_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The Chat screen with players exchanging messages
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding data exchange and channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending chat messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating peer’s data remotely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Through this chapter, we are going to use the fourth folder of our Godot Engine
    project repository, available through the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)'
  prefs: []
  type: TYPE_NORMAL
- en: After importing the project into your Godot Engine project manager, open it
    and navigate to the `res://04.creating-an-online-chat` folder. Then, open the
    `ChatControl.tscn` and `ChatControl.gd` files. They are going to be the focus
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Coming next in this chapter, we are going to learn the basic concepts of reliable
    and unreliable data exchange and how channels work so we have the ground set for
    our chat system.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding data exchange and channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A chat system is essentially a chronological stack of messages that we order
    based on what players send to each other. Since this system needs a coherent chronological
    order, we need to understand how to prevent data from getting mixed and disorganized
    as it gets transmitted throughout the network. We also need to prevent this ordering
    from impacting other systems and components. To do that, we are going to learn
    how we can send packets reliably and how we can use multiple channels for data
    exchange.
  prefs: []
  type: TYPE_NORMAL
- en: Reliable and unreliable packets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Godot Engine’s Network API allows for reliable and unreliable data exchange
    between peers. The `@rpc` annotation provides a way to transmit data securely
    between clients and the server using different transport protocols such as UDP
    and TCP. Reliable data exchange ensures that data is delivered in order and is
    not lost in transit, making it ideal for crucial data such as chat messages. Unreliable
    data exchange is faster and more efficient but offers no guarantee of order or
    delivery, making it ideal for non-critical data such as player position or real-time
    updates. In our chat system, we use the reliable `@rpc` option for chat messages
    to ensure that they are delivered in a timely manner without loss or duplication.
    Reliable data exchange ensures that players are able to follow the conversation
    and respond appropriately. Channels provide another layer of control over data
    exchange, allowing for better network optimization by prioritizing or separating
    data sent through different channels.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, let’s learn how channels work and what we can do with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When developing multiplayer games in Godot Engine, understanding how communication
    channels work within the Network API is crucial for optimizing network performance
    and minimizing latency. In the context of Godot Engine’s Network API, communication
    channels are used to separate different types of data being exchanged between
    peers. For example, you may want to use one channel for game state updates, another
    channel for chat messages, and another channel for player movement data.
  prefs: []
  type: TYPE_NORMAL
- en: The `@rpc` annotation in Godot Engine’s Network API provides an option to specify
    the channel that an RPC method should use for sending and receiving data. By default,
    all RPC methods use channel `0`. However, we can specify a different channel by
    passing an integer number as the last option in the `@rpc` annotation. For example,
    if you want to use a channel for game state updates, you can assign game state
    updates to channel `1` and chat messages to channel `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple channels in your Godot Engine multiplayer game can help improve
    network performance and minimize latency. By separating different types of data
    into separate channels, you can prioritize more important data and prevent congestion
    on a single channel.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that using multiple channels can also help prevent data loss
    and corruption in the event of packet loss or network congestion. By separating
    data into different channels, you can ensure that data loss or corruption on one
    channel doesn’t affect the other channels. This can help prevent issues such as
    desynchronization between peers or corrupted game data. We are going to talk about
    that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, we are going to use reliable data exchange for our messages, so we
    can’t prevent players from updating other crucial information, such as their and
    others’ avatars’ positions, just because the data exchange channel is still waiting
    for a chat message to arrive. It’s wise to use another channel for that. Let’s
    see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `res://04.creating-an-online-chat/ChatControl.tscn` scene and you
    will notice it’s already structured with all the necessary nodes we need to make
    our chat system. So, we are going to focus on the script here. The following figure
    shows the `ChatControl` scene node hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The ChatControl scene node hierarchy](img/Figure_04.02_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The ChatControl scene node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'From there, open the `res://04.creating-an-online-chat/ChatControl.gd` file,
    and make the method responsible for adding messages to the chat:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `@rpc` annotation on top of the `add_message()` method. This RPC
    method should be available to any peer; it should also call itself locally. On
    top of that, it’ll be a reliable method. Finally, here, we are going to use a
    separate channel to exchange data, so let’s use channel `2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `add_message()` method, create a new variable called `message_text`
    that’s going to use the `_avatar_name` String and the message arguments to create
    a text that uses two placeholders separated by a colon, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, concatenate the `label.text`String, skip a line, and then add the `message_text`
    String. This will add the latest message to the players’ visible chat:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, to ensure the players’ chat is always showing the latest message,
    we update `container.scroll_vertical` to match the `label.size.y float`. This
    way, it will scroll to the bottom of the chat label, displaying the latest message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The complete `add_message()` method should look like this at this point:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we can use a dedicated channel to transmit our players’ messages
    from one to another and display them in each player’s chat interface. Using an
    independent data transmission channel is as simple as adding an integer number
    as the last option of a function’s `@``rpc` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let’s learn how we can gather the player’s message and
    actually process it, sending it to other players throughout our peers’ network.
  prefs: []
  type: TYPE_NORMAL
- en: Sending chat messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Godot Engine’s RPCs allow for efficient data transmission between clients and
    the server in multiplayer games. We can create an RPC method for this specific
    purpose, with message data as arguments. The transmission can be either reliable
    or unreliable, depending on the needs of the application. Once the message is
    sent, it’s received by the appropriate recipients (including clients and the server)
    who handle it appropriately, such as by displaying it to the user or logging it.
    We did that in the *Understanding data exchange and channels* section when we
    made the `add_message()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages using Godot’s RPCs is a straightforward process that involves
    defining the message format. In our case, we use the player’s avatar name and
    the message content, as seen previously, calling an RPC method to transmit the
    message and handling the message appropriately on the receiving end.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to implement a method to read the message that players input using
    the `LineEdit` node and send it to all peers on the network. For that, we are
    going to use the `LineEdit.text_submitted` signal connected to the `_on_line_edit_text_submitted()`
    callback method, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The LineEdit text_submitted signal connection](img/Figure_04.03_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – The LineEdit text_submitted signal connection
  prefs: []
  type: TYPE_NORMAL
- en: 'With the signal connected, open the script and let’s work on the `_on_line_edit_text_submitted()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to prevent the processing of empty messages.
    For this, let’s return from the function if the `new_text` argument is an empty
    string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can make an RPC to the `add_message()` method. This will call this
    method on all connected peers. We are going to pass the `ChatControl.avatar_name`
    String and the `new_text` String as arguments so the peers have the proper data
    to create their chat messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we clear the `line_edit.text` String to visually communicate that
    the game received the player’s message and is processing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The complete `_on_line_edit_text_submitted()` method should look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this method, any player in the game will be able to input a message and
    ask all peers, including themselves, to add a new message to their chat based
    on the `add_message()` logic we saw previously.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to understand how we are going to update each player about other
    players’ messages. In the next section, we will learn how to use RPCs on nodes
    other than the root node of a scene. With that, we will be able to make more concise
    scripts since we won’t bloat our classes with methods they won’t implement.
  prefs: []
  type: TYPE_NORMAL
- en: Updating peer’s data remotely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something really cool about Godot Engine’s Network API is that we can abuse
    RPCs to pass data around. For instance, we’ve seen that we use the player’s avatar
    name in our messages. But have you asked yourself how we retrieve this data in
    any of these steps?
  prefs: []
  type: TYPE_NORMAL
- en: You probably saw that there’s an RPC method called `set_avatar_name()`, right?
    Since its `@rpc` annotation doesn’t have any options, you can assume that it uses
    the default options. This is important to know because, as we saw previously,
    this means that it should be called remotely only by the **Multiplayer Authority**
    – in this case, the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s open `ChatServer.gd` to understand what’s happening behind the scenes.
    In essence, most of it is pretty much the same as in the `retrieve_avatar()` RPC
    method. In *line 39*, we have the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We saw that this is a way to keep the sender of the latest RPC in memory so
    that we can refer back to it if necessary, and in this case, it will be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *line 45*, we make a `rpc_id()` call to the `set_avatar_name()` method on
    the peer that just requested its avatar’s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that there’s something else on top of that. We are calling this `rpc_id()`
    method from the `ChatControl` node, which is a child node of the `Main` root node.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the server’s own `ChatControl` node. Since the server and client’s
    scene tree have the same `NodePath` to their `ChatControl` node, we can make this
    `rpc_id()` call on the server’s `ChatControl`node instead of making it from the
    `Main` node, and it will remotely call it on the player who requested their avatar’s
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.\uFEFF4– The ChatServer and ChatClient’s scene node hierarchies](img/Figure_04.04_B18527.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4– The ChatServer and ChatClient’s scene node hierarchies
  prefs: []
  type: TYPE_NORMAL
- en: This is a good and simple way to prevent bloating a single class with many RPC
    methods because, remember, if a caller has an RPC method, all peers should have
    this method on their equivalent nodes at the same `NodePath`.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also a very effective way to remotely update nodes with new data. RPCs
    are really impressive and useful tools to have at our disposal when making online
    multiplayer games with Godot Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we saw how we can use `RPC` methods to pass data around
    and perform actions on multiple peers of our network. We also understood the core
    difference between reliable and unreliable data exchange and saw some examples
    of situations of when to use each one. Due to this core difference in the way
    we can exchange data between the peers of our network, we also understood that
    one way may block the other, so we can use channels to prevent that one type of
    data from getting in the way of another type of data unrelated to that exchange.
  prefs: []
  type: TYPE_NORMAL
- en: By creating an online lobby where players can chat, we saw how to use the `@rpc`
    annotation with some of its available options, including the option to allow other
    peers to make remote calls instead of only the Multiplayer Authority.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use the knowledge we’ve just acquired to build
    an actual real-time multiplayer experience. We’ll create a multiplayer online
    quiz where players will compete to see who can pick the correct answer the quickest.
    See you there!
  prefs: []
  type: TYPE_NORMAL
- en: Part 2:Creating Online Multiplayer Mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After understanding the tools we have available to create online multiplayer
    games, we put them into context by creating actual game prototypes. In this part,
    we learn how to turn single-player games into online multiplayer games, starting
    with a quiz game and ending with a prototype of an MMORPG game.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18527_05.xhtml#_idTextAnchor108)*,* *Making an Online Quiz Game*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18527_06.xhtml#_idTextAnchor131), *Building an Online Checkers
    Game*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18527_07.xhtml#_idTextAnchor146), *Developing an Online Pong
    Game*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18527_08.xhtml#_idTextAnchor162), *Designing an Online Co-Op
    Platformer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18527_09.xhtml#_idTextAnchor188), *Creating an Online Adventure
    Prototype*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
