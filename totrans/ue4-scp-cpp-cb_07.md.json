["```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/Interface.h\"\n#include \"MyInterface.generated.h\"\n\n// This class does not need to be modified.\nUINTERFACE(MinimalAPI)\nclass UMyInterface : public UInterface\n{\n  GENERATED_BODY()\n};\n\nclass CHAPTER_07_API IMyInterface\n{\n  GENERATED_BODY()\n\n  // Add interface functions to this class. This is the class that   \n  //will be inherited to implement this interface.\n\npublic:\n    virtual FString GetTestName();\n};\n```", "```cpp\n#include \"MyInterface.h\"\n\n// Add default functionality here for any IMyInterface functions that are not pure virtual.\nFString IMyInterface::GetTestName()\n{\n unimplemented();\n return FString();\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"MyInterface.h\"\n#include \"SingleInterfaceActor.generated.h\"\n\nUCLASS()\nclass CHAPTER_07_API ASingleInterfaceActor : public AActor, public IMyInterface\n{\n  GENERATED_BODY()\n```", "```cpp\nUCLASS()\nclass CHAPTER_07_API ASingleInterfaceActor : public AActor, public IMyInterface\n{\n  GENERATED_BODY()\n\npublic: \n  // Sets default values for this actor's properties\n  ASingleInterfaceActor();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic: \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n    FString GetTestName() override;\n\n};\n```", "```cpp\nFString ASingleInterfaceActor::GetTestName()\n{\n    return IMyInterface::GetTestName();\n}\n```", "```cpp\nvoid AChapter_07GameModeBase::BeginPlay()\n{\n    Super::BeginPlay();\n\n    // Spawn a new actor using the ASingleInterfaceActor class at \n    //the default location\n    FTransform SpawnLocation;\n    ASingleInterfaceActor* SpawnedActor = \nGetWorld()->SpawnActor<ASingleInterfaceActor>(  \n                                  ASingleInterfaceActor::StaticClass(), \n                                             SpawnLocation); \n\n    // Get a reference to the class the actor has\n    UClass* ActorClass = SpawnedActor->GetClass();\n\n    // If the class implements the interface, display a message\n    if (ActorClass-\n    >ImplementsInterface(UMyInterface::StaticClass()))\n    {\n        GEngine->AddOnScreenDebugMessage(-1, 10, FColor::Red, \n                          TEXT(\"Spawned actor implements \n                               interface!\"));\n    }\n}\n```", "```cpp\n#include \"Chapter_07GameModeBase.h\"\n#include \"MyInterface.h\"\n#include \"SingleInterfaceActor.h\"\n```", "```cpp\nUCLASS()\nclass CHAPTER_07_API AChapter_07GameModeBase : public AGameModeBase\n{\n    GENERATED_BODY()\n\npublic:\n    virtual void BeginPlay() override;\n\n TArray<IMyInterface*> MyInterfaceInstances;\n};\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"MyInterface.h\"\n#include \"Chapter_07GameModeBase.generated.h\"\n```", "```cpp\nfor (TActorIterator<AActor> It(GetWorld(), AActor::StaticClass()); \n     It; \n     ++It)\n{\n    AActor* Actor = *It;\n\n    IMyInterface* MyInterfaceInstance = Cast<IMyInterface>(Actor);\n\n    // If the pointer is valid, add it to the list\n    if (MyInterfaceInstance)\n    {\n        MyInterfaceInstances.Add(MyInterfaceInstance);\n    }\n}\n\n// Print out how many objects implement the interface\nFString Message = FString::Printf(TEXT(\"%d actors implement the \n                              interface\"), MyInterfaceInstances.Num());\n\nGEngine->AddOnScreenDebugMessage(-1, 10, FColor::Red, Message);\n```", "```cpp\n#include \"Chapter_07GameModeBase.h\"\n#include \"MyInterface.h\"\n#include \"SingleInterfaceActor.h\"\n#include \"EngineUtils.h\" // TActorIterator\n```", "```cpp\nexplicit TActorIterator( UWorld* InWorld, \n TSubclassOf<ActorType>InClass = ActorType::StaticClass() ) \n: Super(InWorld, InClass ) \n```", "```cpp\nfor (iterator-constructor;iterator;++iterator) \n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/BoxComponent.h\"\n#include \"AntiGravityVolume.generated.h\"\n\nUCLASS()\nclass CHAPTER_07_API AAntiGravityVolume : public AActor\n{\n    GENERATED_BODY()\n\npublic: \n    // Sets default values for this actor's properties\n    AAntiGravityVolume();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n UPROPERTY()\n UBoxComponent* CollisionComponent;\n\n virtual void NotifyActorBeginOverlap(AActor* OtherActor) override;\n virtual void NotifyActorEndOverlap(AActor* OtherActor) override;\n\n};\n```", "```cpp\nvoid AAntiGravityVolume::NotifyActorBeginOverlap(AActor* OtherActor)\n{\n    IGravityObject* GravityObject = Cast<IGravityObject>(OtherActor);\n\n    if (GravityObject != nullptr)\n    {\n        GravityObject->DisableGravity();\n    }\n}\n\nvoid AAntiGravityVolume::NotifyActorEndOverlap(AActor* OtherActor)\n{\n    IGravityObject* GravityObject = Cast<IGravityObject>(OtherActor);\n\n    if (GravityObject != nullptr)\n    {\n        GravityObject->EnableGravity();\n    }\n}\n```", "```cpp\n// Sets default values\nAAntiGravityVolume::AAntiGravityVolume()\n{\n    // Set this actor to call Tick() every frame. You can turn this off \n    // to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    CollisionComponent = \n           CreateDefaultSubobject<UBoxComponent>(\"CollisionComponent\");\n\n    CollisionComponent->SetBoxExtent(FVector(200, 200, 400));\n    RootComponent = CollisionComponent;\n}\n```", "```cpp\nclass CHAPTER_07_API IGravityObject\n{\n    GENERATED_BODY()\n\n    // Add interface functions to this class. This is the class that \n    // will be inherited to implement this interface.\npublic:\n virtual void EnableGravity();\n virtual void DisableGravity();\n};\n\n```", "```cpp\n#include \"GravityObject.h\"\n\n// Add default functionality here for any IGravityObject functions that are not pure virtual.\nvoid IGravityObject::EnableGravity()\n{\n AActor* ThisAsActor = Cast<AActor>(this);\n if (ThisAsActor != nullptr)\n {\n TArray<UPrimitiveComponent*> PrimitiveComponents;\n\n ThisAsActor->GetComponents(PrimitiveComponents);\n\n for (UPrimitiveComponent* Component : PrimitiveComponents)\n {\n Component->SetEnableGravity(true);\n }\n\n GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \n        TEXT(\"Enabling Gravity\"));\n }\n}\n\nvoid IGravityObject::DisableGravity()\n{\n AActor* ThisAsActor = Cast<AActor>(this);\n if (ThisAsActor != nullptr)\n {\n TArray<UPrimitiveComponent*> PrimitiveComponents;\n\n ThisAsActor->GetComponents(PrimitiveComponents);\n\n for (UPrimitiveComponent* Component : PrimitiveComponents)\n {\n Component->SetEnableGravity(false);\n }\n\n GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \n        TEXT(\"Disabling Gravity\"));\n }\n}\n```", "```cpp\n#include \"AntiGravityVolume.h\"\n#include \"GravityObject.h\"\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"PhysicsCube.generated.h\"\n\nUCLASS()\nclass CHAPTER_07_API APhysicsCube : public AActor\n{\n  GENERATED_BODY()\n\npublic: \n  // Sets default values for this actor's properties\n  APhysicsCube();\n\nprotected:\n  // Called when the game starts or when spawned\n  virtual void BeginPlay() override;\n\npublic: \n  // Called every frame\n  virtual void Tick(float DeltaTime) override;\n\n UPROPERTY()\n UStaticMeshComponent* MyMesh;\n\n};\n```", "```cpp\n#include \"PhysicsCube.h\"\n#include \"ConstructorHelpers.h\"\n\n// Sets default values\nAPhysicsCube::APhysicsCube()\n{\n   // Set this actor to call Tick() every frame. You can turn this \n   //off \n   // to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n MyMesh = CreateDefaultSubobject<UStaticMeshComponent>(\"MyMesh\");\n\n auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>\n    (TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n\n if (MeshAsset.Object != nullptr)\n {\n MyMesh->SetStaticMesh(MeshAsset.Object);\n }\n\n MyMesh->SetMobility(EComponentMobility::Movable);\n MyMesh->SetSimulatePhysics(true);\n SetActorEnableCollision(true);\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"GravityObject.h\"\n#include \"PhysicsCube.generated.h\"\n\nUCLASS()\nclass CHAPTER_07_API APhysicsCube : public AActor, public IGravityObject\n```", "```cpp\ntemplate<class T, class AllocatorType>\n voidGetComponents(TArray<T*, AllocatorType>&OutComponents)\n const\n```", "```cpp\n// This class does not need to be modified.\nUINTERFACE(meta = (CannotImplementInterfaceInBlueprint))\nclass UKillable : public UInterface\n{\n  GENERATED_BODY()\n};\n```", "```cpp\nclass CHAPTER_07_API IKillable\n{\n    GENERATED_BODY()\n\n    // Add interface functions to this class. This is the class that \n    // will be inherited to implement this interface.\npublic:\n UFUNCTION(BlueprintCallable, Category = Killable)\n virtual bool IsDead();\n UFUNCTION(BlueprintCallable, Category = Killable)\n virtual void Die();\n};\n```", "```cpp\n#include \"Killable.h\"\n\n// Add default functionality here for any IKillable functions that are \n// not pure virtual.\nbool IKillable::IsDead()\n{\n return false;\n}\n\nvoid IKillable::Die()\n{\n GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \"Arrrgh\");\n\n AActor* Me = Cast<AActor>(this);\n\n if (Me)\n {\n Me->Destroy();\n }\n\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/Interface.h\"\n#include \"Killable.h\"\n#include \"Undead.generated.h\"\n\n// This class does not need to be modified.\nUINTERFACE(MinimalAPI)\nclass UUndead : public UKillable\n{\n  GENERATED_BODY()\n};\n\n/**\n * \n */\nclass CHAPTER_07_API IUndead : public IKillable\n{\n  GENERATED_BODY()\n\n  // Add interface functions to this class. This is the class that will \n  // be inherited to implement this interface.\npublic:\n};\n```", "```cpp\nclass CHAPTER_07_API IUndead : public IKillable\n{\n    GENERATED_BODY()\n\n    // Add interface functions to this class. This is the class that \n    // will be inherited to implement this interface.\npublic:\n virtual bool IsDead() override;\n virtual void Die() override;\n virtual void Turn();\n virtual void Banish();\n};\n```", "```cpp\n#include \"Undead.h\"\n\n// Add default functionality here for any IUndead functions that are \n// not pure virtual.\nbool IUndead::IsDead()\n{\n return true;\n}\n\nvoid IUndead::Die()\n{\n GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \"You can't kill what is already dead. Mwahaha\");\n}\n\nvoid IUndead::Turn()\n{\n GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \"I'm fleeing!\");\n\n}\n\nvoid IUndead::Banish()\n{\n AActor* Me = Cast<AActor>(this);\n if (Me)\n {\n Me->Destroy();\n }\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Killable.h\"\n#include \"Snail.generated.h\"\n\nUCLASS()\nclass CHAPTER_07_API ASnail : public AActor, public IKillable\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Undead.h\"\n#include \"Zombie.generated.h\"\n\nUCLASS()\nclass CHAPTER_07_API AZombie : public AActor, public IUndead\n```", "```cpp\nclass CHAPTER_07_API ISelectable\n{\n  GENERATED_BODY()\n\n  // Add interface functions to this class. This is the class that will \n  // be inherited to implement this interface.\npublic:\n virtual bool IsSelectable();\n virtual bool TrySelect();\n virtual void Deselect();\n};\n```", "```cpp\n#include \"Selectable.h\"\n\n// Add default functionality here for any ISelectable functions that are not pure virtual.\nbool ISelectable::IsSelectable()\n{\n    GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \"Selectable\");\n    return true;\n}\n\nbool ISelectable::TrySelect()\n{\n    GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \"Accepting Selection\");\n    return true;\n}\n\nvoid ISelectable::Deselect()\n{\n    unimplemented();\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"PhysicsCube.h\"\n#include \"Selectable.h\"\n#include \"SelectableCube.generated.h\"\n\nUCLASS()\nclass CHAPTER_07_API ASelectableCube : public APhysicsCube, public ISelectable\n```", "```cpp\nUCLASS()\nclass CHAPTER_07_API ASelectableCube : public APhysicsCube, public ISelectable\n{\n    GENERATED_BODY()\n\npublic:\n ASelectableCube();\n virtual void NotifyHit(class UPrimitiveComponent* MyComp, \n AActor* Other, \n class UPrimitiveComponent* OtherComp, \n bool bSelfMoved, FVector HitLocation, \n FVector HitNormal, FVector NormalImpulse, \n const FHitResult& Hit) override;\n\n};\n\n```", "```cpp\n#include \"SelectableCube.h\"\n\nASelectableCube::ASelectableCube() : Super()\n{\n MyMesh->SetNotifyRigidBodyCollision(true);\n}\n\nvoid ASelectableCube::NotifyHit(class UPrimitiveComponent* MyComp, \n AActor* Other, \n class UPrimitiveComponent* OtherComp, \n bool bSelfMoved, FVector HitLocation, \n FVector HitNormal, \n FVector NormalImpulse, \n const FHitResult& Hit)\n{\n if (ISelectable::IsSelectable())\n {\n TrySelect();\n }\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"SelectableCube.h\"\n#include \"NonSelectableCube.generated.h\"\n\nUCLASS()\nclass CHAPTER_07_API ANonSelectableCube : public ASelectableCube\n{\n    GENERATED_BODY()\n\npublic:\n virtual bool IsSelectable() override;\n virtual bool TrySelect() override;\n virtual void Deselect() override;\n};\n\n```", "```cpp\n#include \"NonSelectableCube.h\"\n\nbool ANonSelectableCube::IsSelectable()\n{\n GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \"Not Selectable\"); \n return false;\n}\n\nbool ANonSelectableCube::TrySelect()\n{\n GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \"Refusing Selection\");\n return false;\n}\n\nvoid ANonSelectableCube::Deselect()\n{\n unimplemented();\n}\n```", "```cpp\nclass CHAPTER_07_API IInteractable\n{\n    GENERATED_BODY()\n\n    // Add interface functions to this class. This is the class that \n    // will be inherited to implement this interface.\npublic:\n UFUNCTION(BlueprintNativeEvent, BlueprintCallable, \n Category = Interactable)\n bool CanInteract(); \n UFUNCTION(BlueprintNativeEvent, BlueprintCallable, \n Category = Interactable)\n void PerformInteract();\n\n};\n```", "```cpp\nclass CHAPTER_07_API IOpenable\n{\n  GENERATED_BODY()\n\n  // Add interface functions to this class. This is the class that \n    // will be inherited to implement this interface.\npublic:\n UFUNCTION(BlueprintNativeEvent, BlueprintCallable, \n Category = Openable)\n void Open();\n};\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Engine/StaticMeshActor.h\"\n#include \"Interactable.h\"\n#include \"DoorBell.generated.h\"\n\nUCLASS()\nclass CHAPTER_07_API ADoorBell : public AStaticMeshActor, public IInteractable\n{\n  GENERATED_BODY()\n\npublic:\n ADoorBell();\n\n virtual bool CanInteract_Implementation() override;\n virtual void PerformInteract_Implementation() override;\n\n UPROPERTY(BlueprintReadWrite, EditAnywhere)\n AActor* DoorToOpen;\n\nprivate:\n bool HasBeenPushed;\n};\n```", "```cpp\nADoorBell::ADoorBell()\n{\n    HasBeenPushed = false;\n\n    auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n\n    UStaticMeshComponent * SM = GetStaticMeshComponent();\n\n    if (SM != nullptr)\n    {\n        if (MeshAsset.Object != nullptr)\n        {\n            SM->SetStaticMesh(MeshAsset.Object);\n            SM->SetGenerateOverlapEvents(true);\n        }\n\n        SM->SetMobility(EComponentMobility::Movable);\n        SM->SetWorldScale3D(FVector(0.5, 0.5, 0.5));\n    }\n\n    SetActorEnableCollision(true);\n\n    SetActorEnableCollision(true);\n\n    DoorToOpen = nullptr;\n} \n```", "```cpp\nbool ADoorBell::CanInteract_Implementation()\n{\n    return !HasBeenPushed;\n}\n\nvoid ADoorBell::PerformInteract_Implementation()\n{\n    HasBeenPushed = true;\n    if (DoorToOpen->GetClass()->ImplementsInterface( \n                                             UOpenable::StaticClass()))\n    {\n        IOpenable::Execute_Open(DoorToOpen);\n    }\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Engine/StaticMeshActor.h\"\n#include \"Interactable.h\"\n#include \"Openable.h\"\n#include \"Door.generated.h\"\n\nUCLASS()\nclass CHAPTER_07_API ADoor : public AStaticMeshActor, public IInteractable, public IOpenable\n{\n    GENERATED_BODY()\n\n};\n```", "```cpp\nUCLASS()\nclass CHAPTER_07_API ADoor : public AStaticMeshActor, public IInteractable, public IOpenable\n{\n    GENERATED_BODY()\n\npublic:\n ADoor();\n\n UFUNCTION()\n virtual bool CanInteract_Implementation() override;\n\n UFUNCTION()\n virtual void PerformInteract_Implementation() override;\n\n UFUNCTION()\n virtual void Open_Implementation() override;\n};\n```", "```cpp\nADoor::ADoor()\n{\n    auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n\n    UStaticMeshComponent * SM = GetStaticMeshComponent();\n\n    if (SM != nullptr)\n    {\n        if (MeshAsset.Object != nullptr)\n        {\n            SM->SetStaticMesh(MeshAsset.Object);\n            SM->SetGenerateOverlapEvents(true);\n        }\n\n        SM->SetMobility(EComponentMobility::Movable);\n        SM->SetWorldScale3D(FVector(0.3, 2, 3));\n    }\n\n    SetActorEnableCollision(true);\n}\n```", "```cpp\nbool ADoor::CanInteract_Implementation()\n{\n    return true;\n}\n\nvoid ADoor::PerformInteract_Implementation()\n{\n    GEngine->AddOnScreenDebugMessage(-1, 5, FColor::Red, TEXT(\"The door refuses to budge. Perhaps there is a hidden switch nearby ? \")); \n}\n\nvoid ADoor::Open_Implementation()\n{\n    AddActorLocalOffset(FVector(0, 0, 200));\n}\n```", "```cpp\nUCLASS()\nclass CHAPTER_07_API AInteractingPawn : public ADefaultPawn\n{\n    GENERATED_BODY()\n\npublic:\n void TryInteract();\n\nprivate:\n virtual void SetupPlayerInputComponent( UInputComponent* \n                                            InInputComponent) override;\n};\n```", "```cpp\n#include \"InteractingPawn.h\"\n#include \"Interactable.h\"\n#include \"Camera/PlayerCameraManager.h\"\n#include \"CollisionQueryParams.h\"\n#include \"WorldCollision.h\"\n\nvoid AInteractingPawn::TryInteract()\n{\n    APlayerController* MyController = Cast<APlayerController>( \n                                                           Controller);\n\n    if (MyController)\n    {\n        APlayerCameraManager* MyCameraManager = \n                                     MyController->PlayerCameraManager;\n\n        auto StartLocation = MyCameraManager->GetCameraLocation();\n        auto EndLocation = StartLocation + \n                      (MyCameraManager->GetActorForwardVector() * \n                       100);\n\n        FCollisionObjectQueryParams Params;\n        FHitResult HitResult;\n\n        GetWorld()->SweepSingleByObjectType(HitResult, StartLocation, \n                                            EndLocation, \n                                            FQuat::Identity,\n FCollisionObjectQueryParams(FCollisionObjectQueryParams::AllObjects), \n                                       FCollisionShape::MakeSphere(25),\n              FCollisionQueryParams(FName(\"Interaction\"), true, this));\n\n        if (HitResult.Actor != nullptr)\n        {\n            auto Class = HitResult.Actor->GetClass();\n            if (Class->ImplementsInterface( \n                                         UInteractable::StaticClass()))\n            {\n                if (IInteractable::Execute_CanInteract( \n                                                HitResult.Actor.Get()))\n                {\n                    IInteractable::Execute_PerformInteract( \n                                                HitResult.Actor.Get());\n                }\n            }\n        }\n\n    }\n\n}\n\nvoid AInteractingPawn::SetupPlayerInputComponent(UInputComponent* \n                                                      InInputComponent)\n{\n    Super::SetupPlayerInputComponent(InInputComponent);\n    InInputComponent->BindAction(\"Interact\", IE_Released, this, \n                                       &AInteractingPawn::TryInteract);\n}\n```"]