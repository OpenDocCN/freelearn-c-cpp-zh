# 第 7 章。使用 2D 图形

在本章中，我们将学习如何使用 2D 图形和内置 Cinder 工具进行工作和绘图。

本章中的食谱将涵盖以下内容：

+   绘制 2D 几何原语

+   使用鼠标绘制任意形状

+   实现涂鸦算法

+   实现 2D 元球

+   在曲线上动画文本

+   添加模糊效果

+   实现力导向图

# 绘制 2D 几何原语

在本食谱中，我们将学习如何绘制以下 2D 几何形状，作为填充和描边形状：

+   圆形

+   椭圆

+   直线

+   矩形

## 准备工作

包含必要的头文件以使用 Cinder 命令在 OpenGL 中进行绘制。

在你的源文件顶部添加以下代码行：

[PRE0]

## 如何做到这一点…

我们将使用 Cinder 的 2D 绘图方法创建几个几何原语。执行以下步骤来完成：

1.  让我们先声明成员变量以保存我们将要绘制的形状的信息。

    创建两个 `ci::Vec2f` 对象来存储线的起点和终点，一个 `ci::Rectf` 对象来绘制矩形，一个 `ci::Vec2f` 对象来定义圆的中心，以及一个 `float` 对象来定义其半径。最后，我们将创建 `aci::Vec2f` 来定义椭圆的半径，以及两个 `float` 对象来定义其宽度和高度。

    让我们再声明两个 `ci::Color` 对象来定义描边和填充颜色。

    [PRE1]

1.  在 `setup` 方法中，让我们初始化前面的成员：

    [PRE2]

1.  在 `draw` 方法中，让我们首先绘制填充形状。

    让我们清除背景并将 `mFillColor` 设置为绘图颜色。

    [PRE3]

1.  通过调用 `ci::gl::drawSolidRect`、`ci::gl::drawSolidCircle` 和 `ci::gl::drawSolidEllipse` 方法绘制填充形状。

    在 `draw` 方法中添加以下代码片段：

    [PRE4]

1.  要将我们的形状作为描边图形绘制，让我们首先将 `mStrokeColor` 设置为绘图颜色。

    [PRE5]

1.  让我们再次绘制我们的形状，这次只使用描边，通过调用 `ci::gl::drawLine`、`ci::gl::drawStrokeRect`、`ci::gl::drawStrokeCircle` 和 `ci::gl::drawStrokedEllipse` 方法。

    在 `draw` 方法中添加以下代码片段：

    [PRE6]

    这将产生以下结果：

    ![如何做到这一点…](img/8703OS_07_01.jpg)

## 它是如何工作的…

Cinder 的绘图方法使用 OpenGL 调用来提供快速且易于使用的绘图例程。

`ci::gl::color` 方法设置绘图颜色，以便所有形状都将使用该颜色绘制，直到再次调用 `ci::gl::color` 设置另一个颜色。

## 还有更多…

你也可以通过调用 `glLineWidth` 方法并传递一个 `float` 类型的参数来设置描边宽度。

例如，要将描边设置为 5 像素宽，你应该编写以下代码：

[PRE7]

# 使用鼠标绘制任意形状

在本食谱中，我们将学习如何使用鼠标绘制任意形状。

每当用户按下鼠标按钮时，我们将开始一个新的轮廓，并在用户拖动鼠标时进行绘制。

该形状将使用填充和描边来绘制。

## 准备工作

包含必要的文件以使用 Cinder 命令绘制并创建一个 `ci::Shape2d` 对象。

在源文件的顶部添加以下代码片段：

[PRE8]

## 如何操作……

我们将创建一个 `ci::Shape2d` 对象，并使用鼠标坐标创建顶点。执行以下步骤来完成此操作：

1.  声明一个 `ci::Shape2d` 对象来定义我们的形状，以及两个 `ci::Color` 对象来定义填充和描边颜色。

    [PRE9]

1.  在 `setup` 方法中初始化颜色。

    我们将使用黑色进行描边，黄色进行填充。

    [PRE10]

1.  由于绘制将使用鼠标完成，因此需要使用 `mouseDown` 和 `mouseDrag` 事件。

    声明必要的回调方法。

    [PRE11]

1.  在 `mouseDown` 的实现中，我们将通过调用 `moveTo` 方法创建一个新的轮廓。

    以下代码片段显示了方法应该的样子：

    [PRE12]

1.  在 `mouseDrag` 方法中，我们将通过调用 `lineTo` 方法向我们的形状中添加一条线。

    其实现应该像以下代码片段所示：

    [PRE13]

1.  在 `draw` 方法中，我们首先需要清除背景，然后将 `mFillColor` 设置为绘图颜色，并绘制 `mShape`。

    [PRE14]

1.  剩下的只是将 `mStrokeColor` 设置为绘图颜色，并将 `mShape` 作为描边形状绘制。

    [PRE15]

1.  构建并运行应用程序。按下鼠标按钮开始绘制新的轮廓，并拖动以绘制。![如何操作……](img/8703OS_07_02.jpg)

## 工作原理……

`ci:Shape2d` 是一个定义二维任意形状的类，允许有多个轮廓。

`ci::Shape2d::moveTo` 方法创建一个以参数传递的坐标为起点的新的轮廓。然后，`ci::Shape2d::lineTo` 方法从最后位置创建一条直线到作为参数传递的坐标。

绘制实心图形时，形状在内部被划分为三角形。

## 更多……

在使用 `ci::Shape2d` 构建形状时，也可以添加曲线。

| 方法 | 说明 |
| --- | --- |
| `quadTo (constVec2f& p1, constVec2f& p2)` | 使用 `p1` 作为控制点，从最后位置添加一个二次曲线到 `p2` |
| `curveTo (constVec2f& p1, constVec2f& p2, constVec2f& p3)` | 使用 `p1` 和 `p2` 作为控制点，从最后位置添加一个曲线到 `p3` |
| `arcTo (constVec2f& p, constVec2f& t, float radius)` | 使用 `t` 作为切点，半径作为弧的半径，从最后位置添加一个弧到 `p1` |

# 实现涂鸦算法

在这个菜谱中，我们将实现一个涂鸦算法，使用 Cinder 实现起来非常简单，但在绘制时会产生有趣的效果。您可以在 [http://www.zefrank.com/scribbler/about.html](http://www.zefrank.com/scribbler/about.html) 上了解更多关于连接相邻点的概念。您可以在 [http://www.zefrank.com/scribbler/](http://www.zefrank.com/scribbler/) 或 [http://mrdoob.com/projects/harmony/](http://mrdoob.com/projects/harmony/) 上找到一个涂鸦的例子。

## 如何操作……

我们将实现一个展示涂鸦的应用程序。执行以下步骤来完成此操作：

1.  包含必要的头文件：

    [PRE16]

1.  向您的应用程序主类添加属性：

    [PRE17]

1.  实现以下`setup`方法：

    [PRE18]

1.  由于绘图将使用鼠标完成，因此需要使用`mouseDown`和`mouseUp`事件。实现以下方法：

    [PRE19]

1.  最后，绘制方法的实现如下代码片段所示：

    [PRE20]

## 它是如何工作的…

当左鼠标按钮按下时，我们在容器中添加一个新的点，并绘制连接它和其他附近点的线条。我们正在寻找的新添加的点与其邻域中的点之间的距离必须小于`mMaxDist`属性的值。请注意，我们只在程序启动时，在`setup`方法的末尾清除一次绘图区域，因此我们不需要为每一帧重新绘制所有连接，这将非常慢。

![它是如何工作的…](img/8703OS_07_03.jpg)

# 实现二维元球

在这个配方中，我们将学习如何实现称为元球的有机外观对象。

## 准备工作

在这个配方中，我们将使用来自第5章中“应用排斥和吸引力的配方”的代码库，即*构建粒子系统*中的*构建粒子系统*。

## 如何做…

我们将使用着色器程序实现元球的渲染。执行以下步骤来完成此操作：

1.  在`assets`文件夹中创建一个名为`passThru_vert.glsl`的文件，并将以下代码片段放入其中：

    [PRE21]

1.  在`assets`文件夹中创建一个名为`mb_frag.glsl`的文件，并将以下代码片段放入其中：

    [PRE22]

1.  添加必要的头文件。

    [PRE23]

1.  向应用程序的主类添加一个属性，即我们的GLSL着色器程序的`GlslProg`对象。

    [PRE24]

1.  在`setup`方法中，更改`repulsionFactor`和`numParticle`的值。

    [PRE25]

1.  在`setup`方法的末尾，加载我们的GLSL着色器程序，如下所示：

    [PRE26]

1.  最后的主要更改是在`draw`方法中，如下代码片段所示：

    [PRE27]

## 它是如何工作的…

本配方最重要的部分是步骤2中提到的片段着色器程序。着色器根据从我们的粒子系统传递给着色器的位置和半径生成基于渲染元球的纹理。在步骤7中，您可以了解如何将信息传递给着色器程序。我们使用`setMatricesWindow`和`setViewport`来设置OpenGL进行绘图。

![它是如何工作的…](img/8703OS_07_04.jpg)

## 参见

+   **关于元球体的维基百科文章**：[http://zh.wikipedia.org/wiki/元球体](http://zh.wikipedia.org/wiki/元球体)

# 在曲线上动画化文本

在这个配方中，我们将学习如何围绕用户定义的曲线动画化文本。

我们将创建`Letter`和`Word`类来管理动画，一个`ci::Path2d`对象来定义曲线，以及一个`ci::Timer`对象来定义动画的持续时间。

## 准备工作

创建并添加以下文件到您的项目中：

+   `Word.h`

+   `Word.cpp`

+   `Letter.h`

+   `Letter.cpp`

## 如何做…

我们将创建一个单词并沿 `ci::Path2d` 对象动画化其字母。执行以下步骤来完成：

1.  在 `Letter.h` 文件中，包含必要的 `text`、`ci::Vec2f` 和 `ci::gl::Texture` 文件。

    还需添加 `#pragma once` 宏

    [PRE28]

1.  声明具有以下成员和方法的 `Letter` 类：

    [PRE29]

1.  移动到 `Letter.cpp` 文件以实现类。

    在构造函数中，创建一个 `ci::TextBox` 对象，设置其参数，并将其渲染到纹理上。同时，将宽度设置为纹理宽度加上10的填充值：

    [PRE30]

1.  在 `draw` 方法中，我们将绘制纹理并使用 OpenGL 变换将纹理移动到其位置，并根据旋转进行旋转：

    [PRE31]

1.  在 `setPos` 方法的实现中，我们将更新位置并计算其旋转，使字母垂直于其移动。我们通过计算其速度的反正切来实现这一点：

    [PRE32]

1.  `Letter` 类已准备就绪！现在移动到 `Word.h` 文件，添加 `#pragma once` 宏，并包含 `Letter.h` 文件：

    [PRE33]

1.  声明具有以下成员和方法的 `Word` 类：

    [PRE34]

1.  移动到 `Word.cpp` 文件并包含 `Word.h` 文件：

    [PRE35]

1.  在构造函数中，我们将遍历 `text` 中的每个字符并添加一个新的 `Letter` 对象。我们还将通过计算所有字母宽度的总和来计算文本的总长度：

    [PRE36]

    在析构函数中，我们将删除所有 `Letter` 对象以清理类使用的内存：

    [PRE37]

1.  在 `update` 方法中，我们将传递 `ci::Path2d` 对象的引用、路径的总长度以及动画进度的归一化值（从 0.0 到 1.0）。

    我们将计算每个单独字母沿曲线的位置，考虑到 `Word` 的长度和当前进度：

    [PRE38]

1.  在 `draw` 方法中，我们将遍历所有字母并调用每个字母的 `draw` 方法：

    [PRE39]

1.  随着 `Word` 和 `Letter` 类的准备就绪，现在是时候移动到我们的应用程序的类源文件了。首先，包含必要的源文件并添加有用的 `using` 语句：

    [PRE40]

1.  声明以下成员：

    [PRE41]

1.  在 `setup` 方法中，我们将首先创建 `std::string` 和 `ci::Font`，并使用它们来初始化 `mWord`。我们还将使用我们希望动画持续的时间来初始化 `mSeconds`：

    [PRE42]

1.  我们现在需要通过创建关键点和通过调用 `curveTo` 连接它们来创建曲线：

    [PRE43]

1.  让我们通过计算每个点与其相邻点之间的距离之和来计算路径的长度。在 `setup` 方法中添加以下代码片段：

    [PRE44]

1.  我们需要检查 `mTimer` 是否正在运行，并通过计算已过秒数与 `mSeconds` 之间的比率来计算进度。在 `update` 方法中添加以下代码片段：

    [PRE45]

1.  在 `draw` 方法中，我们需要清除背景，启用 alpha 混合，绘制 `mWord`，并绘制路径：

    [PRE46]

1.  最后，每当用户按下任何键时，我们需要启动计时器。

    声明 `keyUp` 事件处理程序：

    [PRE47]

1.  以下是对`keyUp`事件处理器的实现：

    [PRE48]

1.  构建并运行应用程序。按任意键开始动画。![如何做到这一点…](img/8703OS_07_05.jpg)

# 添加模糊效果

在这个菜谱中，我们将学习如何在绘制纹理时应用模糊效果。

## 准备工作

在这个菜谱中，我们将使用Geeks3D提供的Gaussian blur着色器，[请访问这里](http://www.geeks3d.com/20100909/shader-library-gaussian-blur-post-processing-filter-in-glsl/)。

## 如何做到这一点…

我们将实现一个Cinder应用程序示例，以说明该机制。执行以下步骤：

1.  在`assets`文件夹中创建一个名为`passThru_vert.glsl`的文件，并将以下代码片段放入其中：

    [PRE49]

1.  在`assets`文件夹中创建一个名为`gaussian_v_frag.glsland`的文件，并将以下代码片段放入其中：

    [PRE50]

    在`assets`文件夹中创建一个名为`gaussian_h_frag.glsl`的文件，并将以下代码片段放入其中：

    [PRE51]

1.  添加必要的头文件：

    [PRE52]

1.  将属性添加到应用程序的主类中：

    [PRE53]

1.  实现以下`setup`方法：

    [PRE54]

1.  在`draw`方法的开头计算模糊强度：

    [PRE55]

1.  在`draw`函数中，使用第一步着色器将图像渲染到`mFboBlur1`：

    [PRE56]

1.  在`draw`函数中，使用第二步着色器渲染`mFboBlur1`中的纹理：

    [PRE57]

1.  将`mImageBlur`设置为从`mFboBlur2`的结果纹理：

    [PRE58]

1.  在`draw`方法的末尾，绘制带有结果的纹理和GUI：

    [PRE59]

## 工作原理…

由于高斯模糊着色器需要应用两次——垂直和水平处理——我们必须使用**帧缓冲对象**（**FBO**），这是一种在图形卡内存中绘制到纹理的机制。在第8步中，我们从`mImage`对象中绘制原始图像，并应用存储在`gaussian_v_frag.glsl`文件中的着色程序，该文件已加载到`mGaussianVShaderobject`中。此时，所有内容都绘制到`mFboBlur1`中。下一步是使用`mFboBlur2`中的纹理，并在第9步中应用第二个遍历的着色器。最终处理后的纹理存储在第10步的`mImageBlur`中。在第7步中，我们计算模糊强度。

![工作原理…](img/8703OS_07_06.jpg)

# 实现一个力导向图

力导向图是一种使用简单的物理，如排斥和弹簧，来绘制美观图形的方法。我们将使我们的图形交互式，以便用户可以拖动节点并看到图形如何重新组织自己。

## 准备工作

在本食谱中，我们将使用[第5章](ch05.html "第5章。构建粒子系统")中*Building Particle Systems*食谱的代码库，即*在2D中创建粒子系统*。有关如何绘制节点及其之间连接的详细信息，请参阅[第6章](ch06.html "第6章。渲染和纹理化粒子系统")中的*Connecting particles*食谱，*Rendering and Texturing Particle Systems*。

## 如何做到这一点…

我们将创建一个交互式力导向图。执行以下步骤：

1.  向你的主应用程序类添加属性。

    [PRE60]

1.  在`setup`方法中设置默认值并创建一个图。

    [PRE61]

1.  实现与鼠标的交互。

    [PRE62]

1.  在`update`方法内部，计算影响粒子的所有力。

    [PRE63]

1.  在`draw`方法中实现绘制粒子和它们之间的链接。

    [PRE64]

1.  在`Particle.cpp`源文件中，应实现每个粒子的绘制，如下所示：

    [PRE65]

## 它是如何工作的…

在步骤2中，在`setup`方法中，我们为图的每个级别创建粒子，并在它们之间添加链接。在步骤4中的`update`方法中，我们计算影响所有粒子的力，这些力使每个粒子相互排斥，以及来自连接节点的弹簧的力。在排斥扩散粒子时，弹簧试图将它们保持在`mLinkLength`中定义的固定距离。

![它是如何工作的…](img/8703OS_07_07.jpg)

## 参见

+   **关于力导向图绘制的维基百科文章**：[http://en.wikipedia.org/wiki/Force-based_algorithms_(graph_drawing)](http://en.wikipedia.org/wiki/Force-based_algorithms_(graph_drawing))
