["```cpp\nQThread thread; \nthread.start(); \n\n```", "```cpp\nclass Thread : public QThread \n{ \nQ_OBJECT \nprotected: \n    void run()  \n    { \n      Object* myObject = new Object(); \n        connect(myObject, &Object::started,  \n                this, &Thread::doWork); \n        exec(); \n    } \n\nprivate slots: \n    void doWork(); \n}; \n\n```", "```cpp\nclass Thread : public QThread \n{ \n    Thread() : \n        mObject(new QObject()) \n    { \n    } \nprivate : \n    QObject* myObject; \n}; \n\n// Somewhere in MainWindow \nThread thread; \nthread.start(); \n\n```", "```cpp\nclass Thread : public QThread \n{ \n    Q_OBJECT \n    void run() { \n        // long running operation \n        emit result(\"I <3 threads\"); \n    } \nsignals: \n    void result(QString data); \n}; \n\n// Somewhere in MainWindow \nThread* thread = new Thread(this); \nconnect(thread, &Thread::result, this, &MainWindow::handleResult); \nconnect(thread, &Thread::finished, thread, &QObject::deleteLater); \nthread->start(); \n\n```", "```cpp\nQObject::connect( \n    const QObject *sender, const char *signal,  \n    const QObject *receiver, const char *method,  \n    Qt::ConnectionType type = Qt::AutoConnection) \n\n```", "```cpp\nconnect(thread, &Thread::result,  \n        this, &MainWindow::handleResult); \n\n```", "```cpp\nconnect(thread, &Thread::finished, thread, &QObject::deleteLater); \n\n```", "```cpp\nclass Thread : public QThread \n{ \nQ_OBJECT \nprotected: \n    void run()  \n    { \n        Object* myObject = new Object(); \n        connect(myObject, &Object::started,  \n                this, &Thread::doWork); \n        exec(); \n    } \n\nprivate slots: \n    void doWork(); \n}; \n\n```", "```cpp\nclass Worker : public QObject \n{ \n    Q_OBJECT \npublic slots: \n    void doWork()  \n    { \n        emit result(\"workers are the best\"); \n    } \n\nsignals: \n    void result(QString data); \n}; \n\n// Somewhere in MainWindow \nQThread* thread = new Thread(this); \nWorker* worker = new Worker(); \nworker->moveToThread(thread); \n\nconnect(thread, &QThread::finished,  \n        worker, &QObject::deleteLater); \nconnect(this, &MainWindow::startWork,  \n        worker, &Worker::doWork); \nconnect(worker, &Worker::resultReady,  \n        this, handleResult); \n\nthread->start(); \n\n// later on, to stop the thread \nthread->quit(); \nthread->wait(); \n\n```", "```cpp\nQMutex mutex; \nint number = 1; \n\nmutex.lock(); \nnumber *= 2; \nmutex.unlock(); \n\n```", "```cpp\nQMutex mutex; \nQMutexLocker locker(&mutex); \n\nint number = 1; \nnumber *= 2; \nif (overlyComplicatedCondition) { \n    return; \n} else if (notSoSimple) { \n    return; \n} \n\n```", "```cpp\nclass Job : public QRunnable \n{ \n    void run() \n    { \n        // long running operation \n    } \n} \n\nJob* job = new Job(); \nQThreadPool::globalInstance()->start(job); \n\n```", "```cpp\nvoid longRunningFunction(); \nQFuture<void> future = QtConcurrent::run(longRunningFunction); \n\n```", "```cpp\nQImage processGrayscale(QImage& image); \nQImage lenna; \n\nQFuture<QImage> future = QtConcurrent::run(processGrayscale, \n    lenna); \n\nQImage grayscaleLenna = future.result(); \n\n```", "```cpp\nQFutureWatcher<QImage> watcher; \nconnect(&watcher, &QFutureWatcher::finished,  \n        this, &QObject::handleGrayscale); \n\nQImage processGrayscale(QImage& image); \nQImage lenna; \nQFuture<QImage> future = QtConcurrent::run(processImage, lenna); \nwatcher.setFuture(future); \n\n```", "```cpp\nQList images = ...; \n\nQImage processGrayscale(QImage& image); \nQFuture<void> future = QtConcurrent::mapped( \n                                     images, processGrayscale); \n\n```", "```cpp\nQList images = ...; \n\nQImage processGrayscale(QImage& image); \nvoid combineImage(QImage& finalImage, const QImage& inputImage); \n\nQFuture<void> future = QtConcurrent::mappedReduced( \n                                            images,  \n                                            processGrayscale,  \n                                            combineImage); \n\n```", "```cpp\n#include <QSize> \n#include <QVector> \n#include <QPointF> \n\nstruct JobResult \n{ \n    JobResult(int valueCount = 1) : \n        areaSize(0, 0), \n        pixelPositionY(0), \n        moveOffset(0, 0), \n        scaleFactor(0.0), \n        values(valueCount) \n    { \n    } \n\n    QSize areaSize; \n    int pixelPositionY; \n    QPointF moveOffset; \n    double scaleFactor; \n\n    QVector<int> values; \n}; \n\n```", "```cpp\n#include <QObject> \n#include <QRunnable> \n\n#include \"JobResult.h\" \n\nclass Job : public QObject, public QRunnable \n{ \n    Q_OBJECT \npublic: \n    Job(QObject *parent = 0); \n    void run() override; \n}; \n\n```", "```cpp\n#include <QObject> \n#include <QRunnable> \n#include <QPointF> \n#include <QSize> \n#include <QAtomicInteger> \n\nclass Job : public QObject, public QRunnable \n{ \n    Q_OBJECT \npublic: \n    Job(QObject *parent = 0); \n    void run() override; \n\n    void setPixelPositionY(int value); \n    void setMoveOffset(const QPointF& value); \n    void setScaleFactor(double value); \n    void setAreaSize(const QSize& value); \n    void setIterationMax(int value); \n\nprivate: \n    int mPixelPositionY; \n    QPointF mMoveOffset; \n    double mScaleFactor; \n    QSize mAreaSize; \n    int mIterationMax; \n}; \n\n```", "```cpp\n#include <QObject> \n#include <QRunnable> \n#include <QPointF> \n#include <QSize> \n#include <QAtomicInteger> \n\n#include \"JobResult.h\" \n\nclass Job : public QObject, public QRunnable \n{ \n    Q_OBJECT \npublic: \n    ... \nsignals: \n    void jobCompleted(JobResult jobResult); \n\npublic slots: \n    void abort(); \n\nprivate: \n    QAtomicInteger<bool> mAbort; \n    ... \n}; \n\n```", "```cpp\n#include \"Job.h\" \n\nJob::Job(QObject* parent) : \n    QObject(parent), \n    mAbort(false), \n    mPixelPositionY(0), \n    mMoveOffset(0.0, 0.0), \n    mScaleFactor(0.0), \n    mAreaSize(0, 0), \n    mIterationMax(1) \n{ \n} \n\n```", "```cpp\nvoid Job::run() \n{ \n    JobResult jobResult(mAreaSize.width()); \n    jobResult.areaSize = mAreaSize; \n    jobResult.pixelPositionY = mPixelPositionY; \n    jobResult.moveOffset = mMoveOffset; \n    jobResult.scaleFactor = mScaleFactor; \n    ... \n} \n\n```", "```cpp\nvoid Job::run() \n{ \n   ... \n    double imageHalfWidth = mAreaSize.width() / 2.0; \n    double imageHalfHeight = mAreaSize.height() / 2.0; \n    for (int imageX = 0; imageX < mAreaSize.width(); ++imageX) { \n        int iteration = 0; \n        double x0 = (imageX - imageHalfWidth)  \n                  * mScaleFactor + mMoveOffset.x(); \n        double y0 = (mPixelPositionY - imageHalfHeight)  \n                  * mScaleFactor - mMoveOffset.y(); \n        double x = 0.0; \n        double y = 0.0; \n        do { \n            if (mAbort.load()) { \n                return; \n            } \n\n            double nextX = (x * x) - (y * y) + x0; \n            y = 2.0 * x * y + y0; \n            x = nextX; \n            iteration++; \n\n        } while(iteration < mIterationMax \n                && (x * x) + (y * y) < 4.0); \n\n        jobResult.values[imageX] = iteration; \n    } \n\n    emit jobCompleted(jobResult); \n} \n\n```", "```cpp\nvoid Job::abort() \n{ \n    mAbort.store(true); \n} \n\n```", "```cpp\n#include <QObject> \n#include <QSize> \n#include <QPointF> \n#include <QElapsedTimer> \n#include <QList> \n\n#include \"JobResult.h\" \n\nclass Job; \n\nclass MandelbrotCalculator : public QObject \n{ \n    Q_OBJECT \npublic: \n    explicit MandelbrotCalculator(QObject *parent = 0); \n    void init(QSize imageSize); \n\nprivate: \n    QPointF mMoveOffset; \n    double mScaleFactor; \n    QSize mAreaSize; \n    int mIterationMax; \n    int mReceivedJobResults; \n    QList<JobResult> mJobResults; \n    QElapsedTimer mTimer; \n}; \n\n```", "```cpp\n... \nclass MandelbrotCalculator : public QObject \n{ \n    Q_OBJECT \npublic: \n    explicit MandelbrotCalculator(QObject *parent = 0); \n    void init(QSize imageSize); \n\nsignals: \n    void pictureLinesGenerated(QList<JobResult> jobResults); \n    void abortAllJobs(); \n\npublic slots: \n    void generatePicture(QSize areaSize, QPointF moveOffset, \n                         double scaleFactor, int iterationMax); \n    void process(JobResult jobResult); \n\nprivate: \n    Job* createJob(int pixelPositionY); \n    void clearJobs(); \n\nprivate: \n    ... \n}; \n\n```", "```cpp\n#include <QDebug> \n#include <QThreadPool> \n\n#include \"Job.h\" \n\nconst int JOB_RESULT_THRESHOLD = 10; \n\nMandelbrotCalculator::MandelbrotCalculator(QObject *parent) \n    : QObject(parent), \n      mMoveOffset(0.0, 0.0), \n      mScaleFactor(0.005), \n      mAreaSize(0, 0), \n      mIterationMax(10), \n      mReceivedJobResults(0), \n      mJobResults(), \n      mTimer() \n{ \n} \n\n```", "```cpp\nvoid MandelbrotCalculator::generatePicture(QSize areaSize, QPointF moveOffset, double scaleFactor, int iterationMax) \n{ \n    if (areaSize.isEmpty()) { \n        return; \n    } \n\n    mTimer.start(); \n    clearJobs(); \n\n    mAreaSize = areaSize; \n    mMoveOffset = moveOffset; \n    mScaleFactor = scaleFactor; \n    mIterationMax = iterationMax; \n\n    for(int pixelPositionY = 0; \n        pixelPositionY < mAreaSize.height(); pixelPositionY++) { \n        QThreadPool::globalInstance()-> \n            start(createJob(pixelPositionY)); \n    } \n} \n\n```", "```cpp\nJob* MandelbrotCalculator::createJob(int pixelPositionY) \n{ \n    Job* job = new Job(); \n\n    job->setPixelPositionY(pixelPositionY); \n    job->setMoveOffset(mMoveOffset); \n    job->setScaleFactor(mScaleFactor); \n    job->setAreaSize(mAreaSize); \n    job->setIterationMax(mIterationMax); \n\n    connect(this, &MandelbrotCalculator::abortAllJobs, \n            job, &Job::abort); \n\n    connect(job, &Job::jobCompleted, \n            this, &MandelbrotCalculator::process); \n\n    return job; \n} \n\n```", "```cpp\nvoid MandelbrotCalculator::clearJobs() \n{ \n    mReceivedJobResults = 0; \n    emit abortAllJobs(); \n    QThreadPool::globalInstance()->clear(); \n} \n\n```", "```cpp\nvoid MandelbrotCalculator::process(JobResult jobResult) \n{ \n    if (jobResult.areaSize != mAreaSize || \n            jobResult.moveOffset != mMoveOffset || \n            jobResult.scaleFactor != mScaleFactor) { \n        return; \n    } \n\n    mReceivedJobResults++; \n    mJobResults.append(jobResult); \n\n    if (mJobResults.size() >= JOB_RESULT_THRESHOLD || \n            mReceivedJobResults == mAreaSize.height()) { \n        emit pictureLinesGenerated(mJobResults); \n        mJobResults.clear(); \n    } \n\n    if (mReceivedJobResults == mAreaSize.height()) { \n        qDebug() << \"Generated in \" << mTimer.elapsed() << \" ms\"; \n    } \n} \n\n```", "```cpp\n#include <memory> \n\n#include <QWidget> \n#include <QPoint> \n#include <QThread> \n#include <QList> \n\n#include \"MandelbrotCalculator.h\" \n\nclass QResizeEvent; \n\nclass MandelbrotWidget : public QWidget \n{ \n    Q_OBJECT \n\npublic: \n    explicit MandelbrotWidget(QWidget *parent = 0); \n    ~MandelbrotWidget(); \n\nprivate: \n    MandelbrotCalculator mMandelbrotCalculator; \n    QThread mThreadCalculator; \n    double mScaleFactor; \n    QPoint mLastMouseMovePosition; \n    QPointF mMoveOffset; \n    QSize mAreaSize; \n    int mIterationMax; \n    std::unique_ptr<QImage> mImage; \n}; \n\n```", "```cpp\nclass MandelbrotWidget : public QWidget \n{ \n... \npublic slots: \n    void processJobResults(QList<JobResult> jobResults); \n\nsignals: \n    void requestPicture(QSize areaSize, QPointF moveOffset, double scaleFactor, int iterationMax); \n\nprotected: \n    void paintEvent(QPaintEvent*) override; \n    void resizeEvent(QResizeEvent* event) override; \n    void wheelEvent(QWheelEvent* event) override; \n    void mousePressEvent(QMouseEvent* event) override; \n    void mouseMoveEvent(QMouseEvent* event) override; \n\nprivate: \n    QRgb generateColorFromIteration(int iteration); \n\nprivate: \n    ... \n}; \n\n```", "```cpp\n#include \"MandelbrotWidget.h\" \n\n#include <QResizeEvent> \n#include <QImage> \n#include <QPainter> \n#include <QtMath> \n\nconst int ITERATION_MAX = 4000; \nconst double DEFAULT_SCALE = 0.005; \nconst double DEFAULT_OFFSET_X = -0.74364390249094747; \nconst double DEFAULT_OFFSET_Y = 0.13182589977450967; \n\nMandelbrotWidget::MandelbrotWidget(QWidget *parent) : \n    QWidget(parent), \n    mMandelbrotCalculator(), \n    mThreadCalculator(this), \n    mScaleFactor(DEFAULT_SCALE), \n    mLastMouseMovePosition(), \n    mMoveOffset(DEFAULT_OFFSET_X, DEFAULT_OFFSET_Y), \n    mAreaSize(), \n    mIterationMax(ITERATION_MAX) \n{ \n    mMandelbrotCalculator.moveToThread(&mThreadCalculator); \n\n    connect(this, &MandelbrotWidget::requestPicture, \n        &mMandelbrotCalculator, \n        &MandelbrotCalculator::generatePicture); \n\n    connect(&mMandelbrotCalculator, \n        &MandelbrotCalculator::pictureLinesGenerated, \n        this, &MandelbrotWidget::processJobResults); \n\n    mThreadCalculator.start(); \n} \n\n```", "```cpp\nMandelbrotWidget::~MandelbrotWidget() \n{  \n    mThreadCalculator.quit(); \n    mThreadCalculator.wait(1000); \n    if (!mThreadCalculator.isFinished()) { \n        mThreadCalculator.terminate(); \n    } \n} \n\n```", "```cpp\nvoid MandelbrotWidget::resizeEvent(QResizeEvent* event) \n{ \n    mAreaSize = event->size(); \n\n    mImage = std::make_unique<QImage>(mAreaSize, \n        QImage::Format_RGB32); \n    mImage->fill(Qt::black); \n\n    emit requestPicture(mAreaSize, mMoveOffset, mScaleFactor, \n        mIterationMax); \n} \n\n```", "```cpp\nvoid MandelbrotWidget::wheelEvent(QWheelEvent* event) \n{ \n    int delta = event->delta(); \n    mScaleFactor *= qPow(0.75, delta / 120.0); \n    emit requestPicture(mAreaSize, mMoveOffset, mScaleFactor, \n        mIterationMax); \n} \n\n```", "```cpp\nvoid MandelbrotWidget::mousePressEvent(QMouseEvent* event) \n{ \n    if (event->buttons() & Qt::LeftButton) { \n        mLastMouseMovePosition = event->pos(); \n    } \n} \n\n```", "```cpp\nvoid MandelbrotWidget::mouseMoveEvent(QMouseEvent* event) \n{ \n    if (event->buttons() & Qt::LeftButton) { \n        QPointF offset = event->pos() - mLastMouseMovePosition; \n        mLastMouseMovePosition = event->pos(); \n        offset.setY(-offset.y()); \n        mMoveOffset += offset * mScaleFactor; \n        emit requestPicture(mAreaSize, mMoveOffset, mScaleFactor, \n            mIterationMax); \n    } \n} \n\n```", "```cpp\nvoid MandelbrotWidget::processJobResults(QList<JobResult> jobResults) \n{ \n    int yMin = height(); \n    int yMax = 0; \n\n    for(JobResult& jobResult : jobResults) { \n\n        if (mImage->size() != jobResult.areaSize) { \n            continue; \n        } \n\n        int y = jobResult.pixelPositionY; \n        QRgb* scanLine =  \n            reinterpret_cast<QRgb*>(mImage->scanLine(y)); \n\n        for (int x = 0; x < mAreaSize.width(); ++x) { \n            scanLine[x] = \n                generateColorFromIteration(jobResult.values[x]); \n        } \n\n        if (y < yMin) { \n            yMin = y; \n        } \n\n        if (y > yMax) { \n            yMax = y; \n        } \n    } \n\n    repaint(0, yMin, \n            width(), yMax); \n} \n\n```", "```cpp\nQRgb MandelbrotWidget::generateColorFromIteration(int iteration) \n{ \n    if (iteration == mIterationMax) { \n        return qRgb(50, 50, 255); \n    } \n\n    return qRgb(0, 0, (255.0 * iteration / mIterationMax)); \n} \n\n```", "```cpp\nvoid MandelbrotWidget::paintEvent(QPaintEvent* event) \n{ \n    QPainter painter(this); \n    painter.save(); \n\n    QRect imageRect = event->region().boundingRect(); \n    painter.drawImage(imageRect, *mImage, imageRect); \n\n    painter.setPen(Qt::white); \n\n    painter.drawText(10, 20, QString(\"Size: %1 x %2\") \n        .arg(mImage->width()) \n        .arg(mImage->height())); \n\n    painter.drawText(10, 35, QString(\"Offset: %1 x %2\") \n        .arg(mMoveOffset.x()) \n        .arg(mMoveOffset.y())); \n\n    painter.drawText(10, 50, QString(\"Scale: %1\") \n        .arg(mScaleFactor)); \n\n    painter.drawText(10, 65, QString(\"Max iteration: %1\") \n        .arg(ITERATION_MAX)); \n\n    painter.restore(); \n} \n\n```"]