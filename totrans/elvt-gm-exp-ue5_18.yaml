- en: '18'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Gameplay Framework Classes in Multiplayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered **remote procedure calls** (**RPCs**), which
    allow the server and the clients to execute remote functions on each other. We
    also covered enumerations and array index wrapping, which allow you to iterate
    an array in both directions and loop around when you go beyond its limits.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to look at the most common gameplay framework classes
    and see where their instances exist in a multiplayer environment. This is important
    to understand so that you know which instances can be accessed in a specific game
    instance. An example of this is that only the server should be able to access
    the game mode instance because you don’t want clients to be able to modify the
    rules of the game.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also cover the game state and player state classes, which, as their names
    imply, store information about the state of the game and each player, respectively.
    Finally, toward the end of this chapter, we’ll cover some new concepts in the
    game mode, as well as some useful built-in functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Gameplay Framework instances in multiplayer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Game Mode, Player State, and Game State
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll understand where the instances of the most
    important Gameplay Framework classes exist in multiplayer, as well as how the
    game state and player state store information that can be accessed by any client.
    You’ll also know how to make the most out of the Game Mode class and other useful
    built-in functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has the following technical requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Engine 5 installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio 2019 installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The project for this chapter can be found in the `Chapter18` folder of the
    code bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to access the gameplay framework instances
    in multiplayer.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Gameplay Framework Instances in Multiplayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unreal Engine comes with a set of built-in classes (the Gameplay Framework)
    that provide the common functionality that most games require, such as a way to
    define the game rules (game mode), a way to control a character (the player controller
    and pawn/character class), and so on. When an instance of a gameplay framework
    class is created in a multiplayer environment, we need to know if it exists on
    the server, the clients, or the owning client. With that in mind, an instance
    of the gameplay framework class will always fall into one of the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server Only**: The instance will only exist on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server and Clients**: The instance will exist on the server and the clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server and Owning Client**: The instance will exist on the server and the
    owning client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Owning Client Only**: The instance will only exist on the owning client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram, which shows each category and where the
    most common classes in the gameplay framework fall into:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.1 – The most common gameplay framework classes divided into categories
    ](img/Figure_18.01_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.1 – The most common gameplay framework classes divided into categories
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at each class in the preceding diagram in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Game Mode` class defines the rules of the game and its instance can only be
    accessed by the server. If a client tries to access it, the instance will always
    be invalid, to prevent clients from changing the game rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game State (Server and Clients)**: The Game State class stores the state
    of the game and its instance can be accessed both by the server and the clients.
    The game state will be covered in greater depth in the next topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player State (Server and Clients)**: The Player State class stores the state
    of a player and its instance can be accessed both by the server and the clients.
    The player state will be covered in greater depth in the next topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pawn` class is the visual representation of a player and its instance can
    be accessed by the server and the clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Player Controller` class represents the intent of a player, which is relayed
    to the currently possessed pawn, and its instance can only be accessed on the
    server and the owning client. For security reasons, clients can’t access other
    clients’ player controllers, so they should use the server to communicate. If
    a client calls the `UGameplayStatics::GetPlayerController` function with an index
    other than `0` (which would return its player controller), the returned instance
    will always be invalid. This means that the server is the only place that has
    access to all of the player controllers. You can find out whether a player controller
    instance is in its owning client by calling the `AController::IsLocalController`
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HUD (Owning Client Only)**: The HUD class is used as an immediate mode to
    draw basic shapes and text on the screen. Since it’s used for the UI, its instance
    is only available on the owning client, because the server and the other clients
    don’t need to know about it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UMG Widgets (Owning Client Only)**: The UMG widget classes are used to display
    complex UI on the screen. Since it’s used for the UI, its instance is only available
    on the owning client, because the server and the other clients don’t need to know
    about it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To help you understand these concepts, we will use *Dota 2* as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: The game mode defines that there are different phases of the game (pre-game
    for hero picking, the actual game, and the post-game phase with the winner) and
    that the end goal is to destroy the other team’s ancient. Since the game mode
    is a class that is critical to gameplay, clients can’t be allowed to access it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game state stores the elapsed time, whether it’s day or night, the score
    of each team, and so on, so the server and the clients need to be able to access
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player state stores the name, the hero selected, and the kill/death/assist
    ratio of a player, so the server and the clients need to be able to access it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pawn would be the hero, the courier, the illusions, and so on, controlled
    by the player, so the server and the clients need to be able to access it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player controller is what relays the input information to the controlled
    pawn, so only the server and the owning client need to be able to access it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI classes (`HUD` and `User Widget`) display all of the information on the
    owning client, so it only needs to be accessed there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next exercise, you will display the instance values of the most common
    gameplay framework classes.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 18.01 – Displaying the Gameplay Framework instance values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to create a new C++ project that uses the **Third
    Person** template, and we’re going to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: On the owning client, the player controller creates and adds a simple UMG widget
    to the viewport that displays the name of the menu instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the `Tick` function, the character displays the value of its instance (as
    a pawn), as well as whether it has a valid instance for the game mode, game state,
    player state, player controller, and HUD.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `GFInstances` (as in Gameplay Framework Instances) and save it
    to a location of your liking. Once the project has been created, it should open
    the editor as well as the Visual Studio solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the editor, create a new `C++` class called `GFInstancePlayerController`
    that derives from `PlayerController`. Wait for the compilation to end, close the
    editor, and go back to Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `GFInstancesCharacter.h` file and declare the protected override for
    the `Tick` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `GFInstancesCharacter.cpp` file and implement the `Tick` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the instances for the game mode, game state, player controller, and HUD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, we stored the instances for the game mode, game
    state, player controller, and HUD in separate variables so that we can check whether
    they are valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a string for each gameplay framework class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have created strings to store the name of the pawn and checked whether
    the other gameplay framework instances are valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Display each string on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, we have printed the strings that indicate the
    name of the pawn and whether the other gameplay framework instances are valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can move on to the `AGFInstancesPlayerController` class, we need
    to tell Unreal Engine that we want to use the UMG functionality so that we can
    use the `UUserWidget` class. To do this, we need to open `GFInstances.Build.cs`
    and add `UMG` to the `PublicDependencyModuleNames` string array, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you try to compile and get errors from adding the new module, then clean
    and recompile your project. If that doesn’t work, try restarting your IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `GFInstancesPlayerController.h` and add the protected variables to create
    the UMG widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected override for the `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `GFInstancesPlayerController.cpp` and include `UserWidget.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the widget and add it to the viewport if it’s a local controller and
    the `MenuClass` variable is valid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Content` folder, create a new folder called `UI`, and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new widget blueprint called `WBP_Menu` and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Canvas Panel` to the **Hierarchy** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Name` to the **canvas panel** and set it to be a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the text block `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `Event Construct` in the following manner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.2 – The Event Construct that displays the name of the WBP_Menu
    instance ](img/Figure_18.02_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.2 – The Event Construct that displays the name of the WBP_Menu instance
  prefs: []
  type: TYPE_NORMAL
- en: Save and close `WBP_Menu`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Content` folder and create a blueprint called `BP_PlayerController`
    that derives from `GFInstancesPlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `BP_PlayerController` and set `Menu Class` to use `WBP_Menu`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `BP_PlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a blueprint called `BP_GameMode` that derives from `GFInstancesGameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `BP_GameMode` and set `Player Controller Class` to use `BP_PlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `BP_GameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **World Settings**, set **GameMode Override** to **None**, and save the
    map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Project Settings** and pick **Maps & Modes** from the left panel, which
    can be found in the **Project** category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Default` Game Mode to use `BP_GameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close **Project Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you can test the project.
  prefs: []
  type: TYPE_NORMAL
- en: Go to `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the window sizes to `800x600` and play using **New Editor Window (PIE)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.3 – Expected result on the Server and Client 1 windows ](img/Figure_18.03_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.3 – Expected result on the Server and Client 1 windows
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve completed this exercise, you’ll notice that each character displays
    its name, as well as if the instances for the game mode, game state, player state,
    player controller, and HUD are valid. It also displays the instance name of the
    `WBP_Menu` UMG widget in the top-left corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s analyze the values that are displayed in the Server and Client 1
    windows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The two figures for the Server and Client 1 window will have two text blocks
    that say `Server Character` and `Client 1 Character`. These were added to the
    original screenshot to help you understand which character is which.
  prefs: []
  type: TYPE_NORMAL
- en: Output for the Server window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Have a look at the following output of the `Server` window from the previous
    exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.4 – The Server window ](img/Figure_18.04_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.4 – The Server window
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you have the values for `Server Character` and
    `Client 1 Character`. The `WBP_Menu` UMG widget is displayed in the top-left corner
    and is only created for the player controller of `Server Character` since it’s
    the only player controller in this window that controls a character.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s analyze the values for `Server Character`.
  prefs: []
  type: TYPE_NORMAL
- en: Server Character
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the character that the listen server is controlling. The values that
    are displayed on this character are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Game Mode = Valid** because the game mode instance only exists in the server,
    which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game State = Valid** because the game state instance exists on the clients
    and the server, which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player State = Valid** because the player state instance exists on the clients
    and the server, which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pawn = BP_ThirdPersonCharacter_C_0** because pawn instances exist on the
    clients and the server, which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player Controller = Valid** because player controller instances exist on
    the owning client and the server, which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HUD = Valid** because HUD instances only exist on the owning client, which
    is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we are going to look at `Client 1 Character` in the same window.
  prefs: []
  type: TYPE_NORMAL
- en: Client 1 Character
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the character that `Client 1` is controlling. The values that are displayed
    on this character are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Game Mode = Valid** because the game mode instance only exists in the server,
    which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game State = Valid** because the game state instance exists on the clients
    and the server, which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player State = Valid** because the player state instance exists on the clients
    and the server, which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pawn = BP_ThirdPersonCharacter_C_1** because pawn instances exist on the
    clients and the server, which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player Controller = Valid** because player controller instances exist on
    the owning client and the server, which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HUD = Invalid** because HUD instances only exist on the owning client, which
    is not the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output for the Client 1 window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Have a look at the following output of the `Client 1` window from the previous
    exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.5 – The Client 1 window ](img/Figure_18.05_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.5 – The Client 1 window
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you have the values for `Client 1 Character` and
    `Server Character`. The `WBP_Menu` UMG widget is displayed in the top-left corner
    and is only created for the player controller of `Client 1 Character` since it’s
    the only player controller in this window that controls a character.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s analyze the values for `Client 1 Character`.
  prefs: []
  type: TYPE_NORMAL
- en: Client 1 Character
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the character that `Client 1` is controlling. The values that are displayed
    on this character are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Game Mode = Invalid** because the game mode instance only exists in the server,
    which is not the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game State = Valid** because the game state instance exists on the server
    and the clients, which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player State = Valid** because the player state instance exists on the server
    and the clients, which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pawn = BP_ThirdPersonCharacter_C_0** because pawn instances exist on the
    server and the clients, which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player Controller = Valid** because player controller instances exist on
    the server and the owning client, which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HUD = Valid** because HUD instances only exist on the owning client, which
    is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we are going to look at `Server Character` in the same window.
  prefs: []
  type: TYPE_NORMAL
- en: Server Character
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the character that the listen server controls. The values that are
    displayed on this character are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Game Mode = Invalid** because the game mode instance only exists in the server,
    which is not the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game State = Valid** because the game state instance exists on the server
    and the clients, which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player State = Valid** because the player state instance exists on the server
    and the clients, which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pawn = BP_ThirdPersonCharacter_C_1** because pawn instances exist on the
    server and the clients, which is the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player Controller = Invalid** because player controller instances exist on
    the server and the owning client, which is not the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HUD = Invalid** because HUD instances only exist on the owning client, which
    is not the case here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By completing this exercise, you should have a better understanding of where
    each instance of the gameplay framework class exists and where it doesn’t. In
    the next section, we’re going to cover the player state and game state classes,
    as well as some additional concepts regarding the game mode and useful built-in
    functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Using Game Mode, Player State, and Game State
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve covered most of the important classes in the gameplay framework,
    including the game mode, player controller, and the pawn. In this section, we’re
    going to cover the player state, game state, and some additional concepts regarding
    the game mode, as well as some useful built-in functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Game mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve already talked about the game mode and how it works, but there are a few
    concepts that are useful to know about. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To set the default class values, you can use a constructor like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code lets you specify which classes to use when spawning pawns,
    player controllers, player states, and game states when we are using this game
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the game mode instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to access the game mode instance, you need to get it from the `GetWorld`
    function by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code allows you to access the current game mode instance, but
    you have to make sure that you are calling it on the server since this will be
    invalid on the clients due to security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Match states
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we’ve only been using the `AGameModeBase` class, which is the most
    basic game mode class in the framework. Although it’s more than enough for certain
    types of games, there will be cases where you will require a bit more functionality.
    An example of this would be if we wanted to do a lobby system, where the match
    only starts if all the players have marked that they are ready. This example wouldn’t
    be possible to do with just the built-in function of the `AGameModeBase` class.
    For these cases, it’s better to use the `AGameMode` class instead, which is a
    child class of `AGameModeBase` that adds support for match states. The way match
    states work is by using a state machine that can only be in one of the following
    states at a given time:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EnteringMap`: This is the starting state when the world is still loading and
    the actors aren’t ticking yet. It will transition to the `WaitingToStart` state
    once the world finishes loading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitingToStart`: This state is set when the world has finished loading and
    the actors are ticking, although the pawns for the players won’t be spawned because
    the game hasn’t started yet. When the state machine enters this state, it will
    call the `HandleMatchIsWaitingToStart` function. The state machine will transition
    to the `InProgress` state if the `ReadyToStartMatch` function returns `true` or
    if the `StartMatch` function is called somewhere in the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InProgress`: This state is where the actual game takes place. When the state
    machine enters this state, it will spawn the pawns for the players, call `BeginPlay`
    on all of the actors in the world, and call the `HandleMatchHasStarted` function.
    The state machine will transition to the `WaitingPostMatch` state if the `ReadyToEndMatch`
    function returns `true` or if the `EndMatch` function is called somewhere in the
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitingPostMatch`: This state is set when the match ends. When the state machine
    enters this state, it will call the `HandleMatchHasEnded` function. In this state,
    actors still tick, but new players cannot join. It will transition to the `LeavingMap`
    state when it starts unloading the world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LeavingMap`: This state is set while it’s unloading the world. When the state
    machine enters this state, it will call the `HandleLeavingMap` function. The state
    machine will transition to the `EnteringMap` state when it starts loading the
    new level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Aborted`: This is a failed state that can only be set by calling the `AbortMatch`
    function, which is used to flag that something went wrong that prevented the match
    from happening.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To help you understand these concepts better, we can use *Dota 2* again as
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EnteringMap`: The state machine will be in this state when the map is loading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitingToStart`: The state machine will be in this state once the map is loaded
    and the players are picking their heroes. The `ReadyToStartMatch` function will
    check whether all the players have selected their heroes; if they have, then the
    match can start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InProgress`: The state machine will be in this state when the game is underway.
    The players control their heroes to farm and fight other players. The `ReadyToEndMatch`
    function will constantly check the health of each ancient to see whether one of
    them was destroyed; if it was, then the match ends.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitingPostMatch`: The state machine will be in this state when the game has
    ended and you can see the destroyed ancient, as well as a message that displays
    the name of the winning team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LeavingMap`: The state machine will be in this state when it’s unloading the
    map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Aborted`: The state machine will be in this state if one of the players failed
    to connect in the initial stage, therefore aborting the whole match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Respawning the player
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the player dies and you want to respawn it, you typically have two options.
    The first option is to reuse the same pawn instance, manually reset its state
    back to the defaults, and teleport it to the respawn location. The second option
    is to destroy the current pawn instance and spawn a new one, which will already
    have its state reset. If you prefer the latter option, then the `AGameModeBase::RestartPlayer`
    function handles the logic of spawning a new pawn instance for a certain player
    controller for you and places it on a player start.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to take into consideration is that the function only spawns
    a new pawn instance if the player controller doesn’t already possess a pawn, so
    make sure to destroy the controlled pawn before calling `RestartPlayer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have the `OnDeath` function, which takes the player
    controller of the player that died, destroys its controlled pawn, and calls the
    `RestartPlayer` function to spawn a new instance. By default, the new pawn instance
    will spawn in the player start actor that was used when the player spawned for
    the first time. Alternatively, you can tell the game mode that you want to spawn
    on a random player start. To accomplish that, all you need to do is override the
    `AGameModeBase::ShouldSpawnAtStartSpot` function and force it to `return false`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will make the game mode use a random player start instead
    of always using the first one that was used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the game mode, please visit [https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes](https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes)
    and [https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Player state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The player state class stores the information that other clients need to know
    about a specific player (such as their current score, kills/deaths/assists, and
    so on) since they can’t access its player controller. The most widely used built-in
    functions are `GetPlayerName()`, `GetScore` and `GetPingInMilliseconds()`, which
    give you the name, score, and ping of the player, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example of how to use the player state is a scoreboard entry on a multiplayer
    shooter such as *Call Of Duty*, because every client needs to know the name, kills/deaths/assists,
    and ping for that player. The player state instance can be accessed in various
    ways, so let’s take a look at the most common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: AController::PlayerState
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This variable contains the player state associated with the controller and
    can only be accessed by the server and the owning client. The following example
    shows how to use the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: AController::GetPlayerState()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function returns the player state associated with the controller and can
    only be accessed by the server and the owning client. This function also has a
    template version so that you can cast it to your own custom player state class.
    The following example shows how to use the default and template versions of this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: APawn::GetPlayerState()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function returns the player state associated with the controller that
    is possessing the pawn and can be accessed by the server and the clients. This
    function also has a template version so that you can cast it to your own custom
    player state class. The following example shows how to use the default and template
    versions of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: AGameState::PlayerArray
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This variable in the game state (covered in the next section) stores the player
    state instances for each player and can be accessed on the server and the clients.
    The following example shows how to use this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To help you understand these concepts better, we will use *Dota 2* again as
    an example. The player state would have at least the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: The name of the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hero**: The selected hero'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health**: The health of the hero'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mana**: The mana of the hero'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stats**: The hero stats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level**: The level the hero is currently in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kill/Death/Assist**: The kill/death/assist ratio for the player'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the player state, please visit [https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Game State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The game state class stores the information that other clients need to know
    about the game (such as the match’s elapsed time and the score required to win
    the game) since they can’t access the game mode. The most widely used variable
    is `PlayerArray`, which is an array that provides the player state of every connected
    client. A good example of how to use the game state is a scoreboard on a multiplayer
    shooter such as *Call Of Duty* because every client needs to know how many kills
    are required to win, as well as the names, kills/deaths/assists, and pings for
    every connected player.
  prefs: []
  type: TYPE_NORMAL
- en: The game state instance can be accessed in various ways. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: UWorld::GetGameState()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function returns the game state associated with the world and can be accessed
    on the server and the clients. This function also has a template version so that
    you can cast it to your own custom game state class. The following example shows
    how to use the default and template versions of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: AGameModeBase::GameState
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This variable contains the game state associated with the game mode and can
    only be accessed on the server. The following example shows how to use the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: AGameModeBase::GetGameState()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function returns the game state associated with the game mode and can
    only be accessed on the server. This function also has a template version so that
    you can cast it to your own custom game state class. The following example shows
    how to use the default and template versions of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To help you understand these concepts better, we will use *Dota 2* again as
    an example. The game state will have the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Elapsed Time**: How long the match has been going on for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Radiant Kills**: How many Dire heroes the Radiant team has killed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dire Kills**: How many Radiant heroes the Dire team has killed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Day/Night Timer**: Used to determine whether it is day or night'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the game state, please visit [https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.xhtml](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Useful built-in functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UE5 comes with a lot of functionality built in. Let’s look at some examples
    that are useful to know about when developing a game.
  prefs: []
  type: TYPE_NORMAL
- en: void AActor::EndPlay(const EEndPlayReason::Type EndPlayReason)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function is called when the actor has stopped playing, which is the opposite
    of the `BeginPlay` function. This function has a parameter called `EndPlayReason`,
    which tells you why the actor stopped playing (if it was destroyed, if you stopped
    `PIE`, and so on). Take a look at the following example, which prints to the screen
    that the actor has stopped playing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: void ACharacter::Landed(const FHitResult& Hit)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function is called when a player lands on a surface after being in the
    air. Take a look at the following example, which plays a sound when a player lands
    on a surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: bool UWorld::ServerTravel(const FString& FURL, bool bAbsolute, bool bShouldSkipGameNotify)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function will make the server load a new map and bring all of the connected
    clients along with it. This is different from using other methods that load maps,
    such as the `UGameplayStatics::OpenLevel` function, because it won’t bring the
    clients along; it will just load the map on the server and disconnect the clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example, which gets the current map name and uses
    server travel to reload it and bring along the connected clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: void TArray::Sort(const PREDICATE_CLASS& Predicate)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `TArray` data structure comes with the `Sort` function, which allows you
    to sort the values of an array by using a lambda function that returns whether
    the `A` value should be ordered first, followed by the `B` value. Take a look
    at the following example, which sorts an integer array from the smallest value
    to the highest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will sort the `SortTest` array’s values of [43, 1, 23, 8]
    from smallest to highest – that is, [1, 8, 23, 43].
  prefs: []
  type: TYPE_NORMAL
- en: void AActor::FellOutOfWorld(const UDamageType& DmgType)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Unreal Engine, there is a concept called `Z` (set in the `Z` value, it will
    call the `FellOutOfWorld` function, which, by default, destroys the actor. Take
    a look at the following example, which prints to the screen that the actor fell
    out of the world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: URotatingMovementComponent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This component rotates the owning actor along time with a certain rate on each
    axis, defined in the `RotationRate` variable. To use it, you need to include the
    following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You must also declare the component variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you must initialize it in the actor constructor, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `RotationRate` is set to rotate `90` degrees per second
    on the `Yaw` axis.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 18.02 – Making a simple multiplayer pickup game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to create a new C++ project that uses the **Third
    Person** template. The following will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: On the owning client, the player controller will create and add to the viewport
    a UMG widget that, for each player, displays the score, sorted from highest to
    lowest, and how many pickups it has collected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a simple pickup actor class that gives 10 points to the player that picked
    it up. The pickup will also rotate 90 degrees per second on the `Yaw` axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the `Kill Z` to `-500` and make the player respawn and lose 10 points every
    time they fall from the world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game will end when there are no more pickups available. Once the game ends,
    all characters will be destroyed and after 5 seconds, the server will do a server
    travel call to reload the same map and bring along the connected clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete the C++ part of this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Pickups` and save it to a location of your liking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project has been created, it should open the editor, as well as the
    Visual Studio solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s create the new C++ classes we’re going to use.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Pickup` class that derives from `Actor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `PickupsGameState` class that derives from `GameState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `PickupsPlayerState` class that derives from `PlayerState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `PickupsPlayerController` class that derives from `PlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the editor and open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we’re going to work on the `PickupsGameState` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `PickupsGameState.h` and declare the protected replicated integer variable,
    `PickupsRemaining`, which tells all clients how many pickups remain in the level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected override for the `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected `GetPlayerStatesOrderedByScore` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the public `RemovePickup` function, which removes one pickup from
    the `PickupsRemaining` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the public `HasPickups` function, which returns whether any pickups
    remain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `PickupsGameState.cpp` and include `Pickup.h`, `GameplayStatics.h`, `UnrealNetwork.h`,
    and `PlayerState.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `GetLifetimeReplicatedProps` function and make the `PickupRemaining`
    variable replicate to all clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `BeginPlay` override function and set the value of `PickupsRemaining`
    by getting all the pickups in the world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `GetPlayerStatesOrderedByScore` function, which duplicates the
    `PlayerArray` variable and sorts it so that the players with the highest scores
    show up first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s work on the `PickupsPlayerState` class. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `PickupsPlayerState.h` and declare the protected replicated integer variable,
    `Pickups`, which indicates how many pickups a player has collected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the public `AddPickup` function, which adds one pickup to the `Pickups`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `PickupsPlayerState.cpp` and include `UnrealNetwork.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `GetLifetimeReplicatedProps` function and make the `Pickups`
    variable replicate to all clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let’s work on the `PickupsPlayerController` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `PickupsPlayerController.h` and declare the protected `ScoreboardMenuClass`
    variable, which will set the UMG widget class we want to use for our scoreboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected `ScoreboardMenu` variable, which stores the scoreboard
    UMG widget instance we will create on the `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected override for the `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `PickupsPlayerController.cpp` and include `UserWidget.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `BeginPlay` override function, which, for the owning client,
    creates and adds the scoreboard UMG widget to the viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s edit the `PickupsGameMode` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `PickupsGameMode.h` and replace the `#include` statement for `GameModeBase.h`
    with `GameMode.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the class derive from `AGameMode` instead of `AGameModeBase`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected game state variable, `MyGameState`, which holds the instance
    of the `APickupsGameState` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Move the constructor to the protected area and delete the public area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the protected override for the `BeginPlay` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected override for the `ShouldSpawnAtStartSpot` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected overrides for the match state functions of the game mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected `RestartMap` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `PickupsGameMode.cpp` and include `GameplayStatics.h` and `PickupGameState.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `BeginPlay` override function, which stores the `APickupGameState`
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `ShouldSpawnAtStartSpot` override function, which indicates that
    we want the players to respawn on a random player start and not always on the
    same one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `HandleMatchHasStarted` override function, which prints to the
    screen, informing players that the game has started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `HandleMatchHasEnded` override function, which prints to the
    screen, informing players that the game has ended, destroys all characters, and
    schedules a timer to restart the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `ReadyToStartMatch_Implementation` override function, which indicates
    that the match can start straight away:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `ReadyToEndMatch_Implementation` override function, which indicates
    that the match ends when the game state has no more pickups remaining:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `RestartMap` function, which performs a server travel to the
    same level and brings all clients along:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s edit the `PickupsCharacter` class. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `PickupsCharacter.h` and declare the protected sound variables for falling
    and landing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected override functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the public functions that add scores and pickups to the player state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the public client RPC that plays a sound on the owning client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `PickupsCharacter.cpp` and include `PickupsPlayerState.h`, `GameMode.h`,
    `PlayerState.h`, and `GameplayStatics.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `EndPlay` override function, which plays the fall sound if the
    character was destroyed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `Landed` override function, which plays the landed sound:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `FellOutOfWorld` override function, which stores the controller,
    removes `10` points from the score, destroys the character, and tells the game
    mode to restart the player using the previous controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `AddScore` function, which adds a certain amount to the `score`
    in the player state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `AddPickup` function, which adds a pickup to the `Pickup` variable
    in our custom player state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `ClientPlaySound2D_Implementation` function, which plays a sound
    on the owning client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s work on the `Pickup` class. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Pickup.h` and clear all existing functions and delete the public areas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the protected `Static Mesh` component called `Mesh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected rotating movement component called `RotatingMovement`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected `PickupSound` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected constructor and `BeginPlay` override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected `OnBeginOverlap` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `Pickup.cpp` and include `PickupsCharacter.h`, `PickupsGameState.h`, and
    `RotatingMovementComponent.h` after `Pickup.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the constructor, initialize the `Mesh` component so that it overlaps everything
    and make it the root component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still in the constructor, initialize the rotating movement component so that
    it rotates `90` degrees per second on the `Yaw` axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To finalize the constructor, enable replication and disable the `Tick` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the `BeginPlay` function, bind the begin overlap event of `Mesh`
    to the `OnBeginOverlap` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete the definition for the `Tick` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `OnBeginOverlap` function, which checks whether the character
    is valid and has authority, removes the pickup from the game state, plays the
    pickup sound on the owning client, and adds `10` points and the pickup to the
    character. Once all of that is done, the pickup will destroy itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `Pickups.Build.cs` and add the `UMG` module to `PublicDependencyModuleNames`,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you try to compile and get errors from adding the new module, then clean
    and recompile your project. If that doesn’t work, try restarting your IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Compile and run the code until the editor loads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once it’s loaded, we’re going to import some assets and create some blueprints
    that derive from the C++ classes we’ve just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s import the sound files:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Content\Sounds` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `Pickup.wav`, `Footstep.wav`, `Jump.wav`, `Land.wav`, and `Fall.wav`
    from the `Exercise18.02\Assets` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the new files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will add the `Play Sound` anim notifies to some of the character’s
    animations.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MM_Jump` animation, located in `Content\Characters\Mannequins\Animations\Manny`,
    and add a `Play Sound` anim notify at frame `0` using the `Jump` sound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `MM_Jump`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MF_Run_Fwd` animation, located in `Content\Characters\Mannequins\Animations\Quinn`,
    and add `Play Sound` anim notifies using the `Footstep` sound at `0.24`, `0.56`,
    `0.82`, `1.12`, `1.38`, and `1.70` seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `MF_Run_Fwd`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MF_Walk_Fwd` animation, located in `Content\Characters\Mannequins\Animations\Quinn`,
    and add two `Play Sound` anim notifies using the `Footstep` sound at `0.33, 0.72,
    1.23,` and `1.7` seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `MF_Walk_Fwd`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s set the sounds to use on the character blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BP_ThirdPersonCharacter` blueprint, located in `Content\ThirdPerson\Blueprints`,
    and set `Fall Sound` and `Land Sound` so that they use the `Fall` and `Land` sounds,
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `BP_ThirdPersonCharacter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s create the blueprint for the pickup.
  prefs: []
  type: TYPE_NORMAL
- en: Create and open the `Content\Blueprints` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new blueprint called `BP_Pickup` that derives from the `Pickup` class
    and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure the `Static Mesh` component in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(X=0.5, Y=0.5, Z=0.5)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Engine\BasicShapes\Cube`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Engine\EngineMaterials\CubeMaterial`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To display the Engine content, you need to click on the dropdown for the static
    mesh, click on the cog icon next to the filter box, and make sure that the `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Set the `Pickup Sound` variable to use the `Pickup` sound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `BP_Pickup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s create the scoreboard UMG widgets. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create and go to the `Content\UI` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new widget blueprint called `WBP_Scoreboard_Header`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `true`, `true`, `Player Name`, and `green`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a text block called `true`, `= 500`, `= 1.0, 0.0`, `true`, `Score`, and
    `green`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a text block called `true`, `= 650`, `= 1.0, 0.0`, `true`, `Pickups`, and
    `green`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Save and close `WBP_Scoreboard_Header`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to `WBP_Scoreboard_Header`, rename it to `WBP_Scoreboard_Entry`, and
    open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the color of all of the text blocks to `white` instead of `green`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `Player State` variable with the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.6 – Creating the Player State variable ](img/Figure_18.06_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.6 – Creating the Player State variable
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the `Name` with `Player Name` and bind it to the `GetPlayerName`
    function from the dropdown, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.7 – Binding the player name function ](img/Figure_18.07_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.7 – Binding the player name function
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a text block called `Score` with `Score` and bind it to the `Score`
    variable from the dropdown, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.8 – Binding the player score function ](img/Figure_18.08_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.8 – Binding the player score function
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a text block called `Pickups` with `Pickups` and bind it to the `Pickups`
    variable from the dropdown, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.9 – Binding the pickups count function ](img/Figure_18.09_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.9 – Binding the pickups count function
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a pure function called `Get Typeface` that does the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.10 – Determining whether the entry should be displayed in Bold
    or Regular ](img/Figure_18.10_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.10 – Determining whether the entry should be displayed in Bold or
    Regular
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we used a `Select` node, which can be created by dragging
    a wire from the return value and releasing it on an empty space, and then typed
    `Select` on the filter. From there, we picked the `Select` node from the list.
    Here, we are using the `Select` node to pick the name of the typeface we’re going
    to use, so it should return `Regular` if the player state’s pawn is not the same
    as the pawn that owns the widget and `Bold` if it is. We do this to highlight
    the player’s state entry in bold so that the player knows what their entry is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement `Event Construct` in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.11 – The Event Graph that sets the text for the name, score, and
    pickups count ](img/Figure_18.11_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.11 – The Event Graph that sets the text for the name, score, and pickups
    count
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we set the font for `Name`, `Score`, and `Pickups` to
    use the `Bold` typeface to highlight which scoreboard entry is relative to the
    player of the current client. For the remainder of the players, use the `Regular`
    typeface. If you can’t find the **Roboto** font, then pick **Show Engine Content**
    from the dropdown options.
  prefs: []
  type: TYPE_NORMAL
- en: Save and close `WBP_Scoreboard_Entry`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `WBP_Scoreboard` and add a **Canvas Panel** to the **Hierarchy** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Game State` of the `Pickups Game State` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the `Scoreboard` to the canvas panel with `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a text block to `Scoreboard` called `PickupsRemaining` with `Text` set to
    `100 Pickup(s) Remaining`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a vertical box to `PlayerStates` with `Is Variable` set to `true` and a
    top padding of `50`. You should have the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.12 – The WBP_Scoreboard widget hierarchy ](img/Figure_18.12_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.12 – The WBP_Scoreboard widget hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'Bind the `Text` value for the `PickupsRemaining` text block with the following
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.13 – Displaying the number of pickups remaining in the world ](img/Figure_18.13_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.13 – Displaying the number of pickups remaining in the world
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `Add Scoreboard Header` that adds an instance of `WBP_Scoreboard_Header`
    to `Player States`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.14 – The Add Scoreboard Header event ](img/Figure_18.14_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.14 – The Add Scoreboard Header event
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new event called `Add Scoreboard Entries`. This goes through all of
    the player states ordered by score and adds an instance of `WBP_Scoreboard_Entry`
    to `Player States`, as demonstrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.15 – The Add Scoreboard Entries event ](img/Figure_18.15_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.15 – The Add Scoreboard Entries event
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new event called `Update Scoreboard`. This event clears the widgets
    in `Player States` and calls `Add Scoreboard Header` and `Add Scoreboard Entries`,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.16 – The Update Scoreboard event ](img/Figure_18.16_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.16 – The Update Scoreboard event
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement `Event Construct` in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.17 – Event Construct ](img/Figure_18.17_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.17 – Event Construct
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we get the game state instance, update the scoreboard,
    and schedule a timer to automatically call the `Update Scoreboard` event every
    `0.5` seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Save and close `WBP_Scoreboard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s create the blueprint for the player controller. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to `Content\Blueprints` and create a new blueprint called `BP_PlayerController`
    that derives from the `PickupsPlayerController` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the new blueprint and set `Scoreboard Menu` to use `WBP_Scoreboard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `BP_PlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let’s create the blueprint for the game mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new blueprint called `BP_GameMode` that derives from the `PickupsGameMode`
    class, open it, and change the following variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PickupsGameState`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BP_PlayerController`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PickupsPlayerState`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Save and close `BP_GameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let’s configure **Project Settings** so that it uses the new game mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Project Settings** and pick **Maps & Modes** from the left panel, which
    is in the **Project** category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `BP_GameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close **Project Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s modify the main level. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have `ThirdPersonMap` opened, located in `Content\ThirdPerson\Maps`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some cube actors to act as platforms. Make sure they have gaps between them
    to force the player to jump on them and possibly fall from the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a couple of player start actors spread throughout the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add at least 50 instances of `BP_Pickup` and spread them across the entire map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an example of a possible way of configuring the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 18.18 – An example of a map configuration ](img/Figure_18.18_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.18 – An example of a map configuration
  prefs: []
  type: TYPE_NORMAL
- en: Go to **World Settings**, set **GameMode Override** to **None**, and save everything.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the window sizes to `800x600` and play using **New Editor Window (PIE).**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.19 – The listen Server and Client 1 picking up cubes in the world
    ](img/Figure_18.19_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.19 – The listen Server and Client 1 picking up cubes in the world
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you can play on each client. You’ll notice that
    the characters can collect pickups and gain **10** points just by overlapping
    with them. If a character falls from the level, they will respawn on a random
    player start and lose **10** points.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the pickups have been collected, the game will end, and after **5**
    seconds, it will perform a server travel to reload the same level and bring all
    the clients with it. You will also see that the UI displays how many pickups are
    remaining in the level, as well as the scoreboard with information about the name,
    score, and pickups for each player.
  prefs: []
  type: TYPE_NORMAL
- en: In the next activity, you’re going to add a scoreboard, kill limit, the concept
    of death/respawning, and the ability for the characters to pick up weapons, ammo,
    armor, and health in our multiplayer FPS game.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 18.01 – Adding death, respawning, a scoreboard, kill limit, and pickups
    to the multiplayer FPS game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this activity, you’ll add the concept of death/respawning and the ability
    for a character to collect pickups to our multiplayer FPS game. We’ll also add
    a scoreboard and a kill limit to the game so that it has an end goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MultiplayerFPS` project from *Activity 17.01 – Adding weapons and
    ammo to the multiplayer FPS game*. Compile the code and run the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `FPSGameState`, which derives from the `GameState`
    class, and has a kill limit variable and a function that returns the player states
    ordered by kills.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `FPSPlayerState`, which derives from the `PlayerState`
    class, and stores the number of kills and deaths of a player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `PlayerMenu`, which derives from the `UserWidget`
    class, and has some `BlueprintImplementableEvent` functions to toggle the scoreboard
    visibility, set the scoreboard visibility, and notify when a player was killed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `FPSPlayerController`, which derives from `APlayerController`,
    that creates the `PlayerMenu` UMG widget instance on the owning client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `Pickup`, which derives from the `Actor` class, and
    has a static mesh that rotates 90 degrees per second on the `Yaw` axis and can
    be picked up by the player on overlap. Once picked up, it plays a pickup sound
    and disables collision and visibility. After a certain amount of time, it will
    make it visible and able to collide again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `AmmoPickup`, which derives from the `Pickup` class,
    and adds a certain amount of an ammo type to the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `ArmorPickup`, which derives from the `Pickup` class,
    and adds a certain amount of armor to the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `HealthPickup`, which derives from the `Pickup` class,
    and adds a certain amount of health to the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a C++ class called `WeaponPickup`, which derives from the `Pickup` class,
    and adds a certain weapon type to the player. If the player already has the weapon,
    it will add a certain amount of ammo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `FPSCharacter` class so that it does the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the character is damaged, it checks whether it’s dead. If it’s dead, it
    registers the kill for the killer character and the death of the player and respawn
    it. If the character is not dead, then it plays the pain sound on the owning client.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the character dies and executes the `EndPlay` function, it should destroy
    all of its weapon instances.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the character falls from the world, it will register the death of the player
    and respawn it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player presses the *Tab* key, it will toggle the visibility of the scoreboard
    menu.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edit the `MultiplayerFPSGameModeBase` class so that it does the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uses the `GameMode` class instead of `GameModeBase`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores the number of kills necessary to win the game.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses our custom player controller, player state, and game state classes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Makes it implement the match state functions so that the match starts immediately
    and ends if there is a player that has the required number of kills.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the match ends, it will perform a server travel to the same level after
    `5` seconds.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handles when a player dies by adding the kill (when killed by another player)
    and the death to the respective player state, as well as respawn the player on
    a random player start.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `AmmoPickup.wav` from `Activity18.01\Assets` into `Content\Pickups\Ammo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create `BP_PistolBullets_Pickup` from `AmmoPickup`, place it in `Content\Pickups\Ammo`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(X=0.5, Y=0.5, Z=0.5)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Engine\BasicShapes\Cube`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapon\Pistol\MI_Pistol`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pistol Bullets`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`25`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Pickup\Ammo\AmmoPickup`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `BP_MachineGunBullets_Pickup` from `AmmoPickup`, place it in `Content\Pickups\Ammo`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(X=0.5, Y=0.5, Z=0.5)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Engine\BasicShapes\Cube`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapon\MachineGun\MI_MachineGun`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Machine Gun Bullets`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`50`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Pickup\Ammo\AmmoPickup`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `BP_Slugs_Pickup` from `AmmoPickup`, place it in `Content\Pickups\Ammo`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(X=0.5, Y=0.5, Z=0.5)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Engine\BasicShapes\Cube`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapon\Railgun\MI_Railgun`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slugs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Pickup\Ammo\AmmoPickup`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `ArmorPickup.wav` from `Activity18.01\Assets` into `Content\Pickups\Armor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `M_Armor` material in `Content\Pickups\Armor`, which has `Base Color`
    set to `blue` and `Metallic` set to `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create `BP_Armor_Pickup` from `ArmorPickup`, place it in `Content\Pickups\Armor`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(X=1.0, Y=1.5, Z=1.0)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Engine\BasicShapes\Cube`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Pickup\Armor\M_Armor`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`50`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Pickup\Armor\ArmorPickup`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `HealthPickup.wav` from `Activity18.01\Assets` into `Content\Pickups\Health`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `M_Health` material in `Content\Pickups\Health`, which has `Base
    Color` set to `green` and `Metallic`/`Roughness` set to `0.5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create `BP_Health_Pickup` from `HealthPickup`, place it in `Content\Pickups\Health`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Engine\BasicShapes\Sphere`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Pickup\Health\M_Health`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`50`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Pickup\Health\HealthPickup`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `WeaponPickup.wav` from `Activity18.01\Assets` into `Content\Pickups\Weapon`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create `BP_Pistol_Pickup` from `WeaponPickup`, place it in `Content\Pickups\Weapon`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Content\Pickup\Weapon\SM_Weapon`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapon\Pistol\MI_Pistol`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pistol`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`25`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Pickup\Weapon\WeaponPickup`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `BP_MachineGun_Pickup` from `WeaponPickup`, place it in `Content\Pickups\Weapon`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Content\Pickup\Weapon\SM_Weapon`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapon\MachineGun\MI_MachineGun`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Machine Gun`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`50`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Pickup\Weapon\WeaponPickup`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `BP_Railgun_Pickup` from `WeaponPickup`, place it in `Content\Pickups\Weapon`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Content\Pickup\Weapon\SM_Weapon`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapon\Railgun\MI_Railgun`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Railgun`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Pickup\Weapon\WeaponPickup`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `Land.wav` and `Pain.wav` from `Activity18.01\Assets` into `Content\Player\Sounds`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `BP_Player` so that it uses the `Pain` and `Land` sounds, as well as deletes
    all of the nodes that create and add the `WBP_HUD` instance to the viewport in
    the `Begin Play` event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a UMG widget called `WBP_Scoreboard_Entry` in `Content\UI` that displays
    the name, kills, deaths, and ping of `FPSPlayerState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a UMG widget called `WBP_Scoreboard_Header` that displays the headers
    for the name, kills, deaths, and ping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a UMG widget called `WBP_Scoreboard` that displays the kill limit from
    the game state, a vertical box that has `WBP_Scoreboard_Header` as the first entry,
    and then add a `WBP_Scoreboard_Entry` for each `FPSPlayerState` in the game state
    instance. The vertical box will update every `0.5` seconds, through a timer, by
    clearing its children and adding them again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `WBP_HUD` so that it adds a new text block called `Killed` that starts
    with `Visibility` set to `Hidden`. When the player kills someone, it will make
    the text block visible, display the name of the killed player, and hide after
    `1` second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new blueprint called `WBP_PlayerMenu` from `PlayerMenu` and place it
    in `Content\UI`. Use a widget switcher with an instance of `WBP_HUD` to index
    `0` and an instance of `WBP_Scoreboard` to index `1`. In the event graph, make
    sure that you override the `Toggle Scoreboard`, `Set Scoreboard Visibility`, and
    `Notify Kill` events that were set as `BlueprintImplementableEvent` in C++. The
    `Toggle Scoreboard` event toggles the widget switcher’s active index between `0`
    and `1`, the `Set Scoreboard Visibility` event sets the widget switcher’s active
    index to `0` or `1`, and the `Notify Kill` event tells the `WBP_HUD` instance
    to set the text and hide it after 1 second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `BP_PlayerController` from `FPSPlayerController`, place it in the `Content`
    folder, and set the `PlayerMenuClass` variable to use `WBP_PlayerMenu`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `BP_GameMode` and set `Player Controller Class` to use `BP_PlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the input action `IA_Scoreboard` to toggle the scoreboard with the *Tab*
    key and update `IMC_Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `DM-Test` level so that you have at least three new player starts placed
    in different locations. Then, place an instance of every different pickup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `-500`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Expected output**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 18.20 – The expected output of the activity ](img/Figure_18.20_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18.20 – The expected output of the activity
  prefs: []
  type: TYPE_NORMAL
- en: The result should be a project where each client’s character can use and switch
    between three different weapons. If a character kills another, it should register
    the kill and the death, as well as respawn the character that died at a random
    player start. You should have a scoreboard that displays the name, kill count,
    death count, and ping for each player. A character can fall from the level, which
    should only count as a death, and respawn at a random player start. The character
    should also be able to pick up the different pickups in the level to get ammo,
    armor, health, and weapons. The game should end when the kill limit has been reached
    by showing the scoreboard and server travel to the same level after 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned that the instances of the gameplay framework classes
    exist in some specific game instances, but not in others. You also learned about
    the purpose of the game state and player state classes, as well as new concepts
    for the game mode and some useful built-in functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you made a basic but functional multiplayer shooter
    that can be used as a foundation to build upon. You added new weapons, ammo types,
    fire modes, pickups, and so on to make it more feature-complete and fun.
  prefs: []
  type: TYPE_NORMAL
- en: Having completed this book, you should now have a better understanding of how
    to use UE5 to make games come to life. We’ve covered a lot of topics in this book,
    ranging from the simple to more advanced. You started by learning how to create
    projects using the different templates and how to use Blueprints to create actors
    and components. Then, you learned how to create a fully functioning **Third Person**
    template from scratch by importing the required assets and setting up the Animation
    Blueprint, Blend Space, game mode, and character, as well as defining and handling
    the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you moved on to your first project – a simple stealth game that uses game
    physics and collisions, projectile movement components, actor components, interfaces,
    blueprint function libraries, UMG, sounds, and particle effects. Following this,
    you learned how to create a simple side-scrolling game by using AI, Anim Montages,
    and Destructible Meshes. Finally, you learned how to create a first-person multiplayer
    shooter by using the Server-Client architecture, variable replication, and RPCs,
    as well as how the Player State, Game State, and Game Mode classes work.
  prefs: []
  type: TYPE_NORMAL
- en: By working on various projects that use different parts of Unreal Engine, you
    now have a strong understanding of how UE5 works. Although this is the end of
    this book, this is just the beginning of your journey into the world of game development
    using UE5.
  prefs: []
  type: TYPE_NORMAL
