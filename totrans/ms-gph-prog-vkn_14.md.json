["```cpp\nstruct RayPayload {\n    vec3 radiance;\n    float distance;\n};\n```", "```cpp\nlayout( location = 0 ) rayPayloadEXT RayPayload payload;\nvoid main() {\nconst ivec2 pixel_coord = ivec2(gl_LaunchIDEXT.xy);\n    const int probe_index = pixel_coord.y;\n    const int ray_index = pixel_coord.x;\n    // Convert from linear probe index to grid probe \n       indices and then position:\n    ivec3 probe_grid_indices = probe_index_to_grid_indices( \n      probe_index );\n    vec3 ray_origin = grid_indices_to_world( \n      probe_grid_indices probe_index );\n    vec3 direction = normalize( mat3(random_rotation) * \n      spherical_fibonacci(ray_index, probe_rays) );\n    payload.radiance = vec3(0);\n    payload.distance = 0;\n    traceRayEXT(as, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, \n      ray_origin, 0.0, direction, 100.0, 0);\n\n    // Store the result coming from Hit or Miss shaders\n    imageStore(global_images_2d[ radiance_output_index ], \n    pixel_coord, vec4(payload.radiance, payload.distance));\n} \n```", "```cpp\nlayout( location = 0 ) rayPayloadInEXT RayPayload payload;\nhitAttributeEXT vec2 barycentric_weights;\n```", "```cpp\nvoid main() {\n    vec3 radiance = vec3(0);\n    float distance = 0.0f;\n    if (gl_HitKindEXT == gl_HitKindBackFacingTriangleEXT) {\n        // Track backfacing rays with negative distance\n        distance = gl_RayTminEXT + gl_HitTEXT;\n        distance *= -0.2;        \n    }\n```", "```cpp\n    else {\n```", "```cpp\n    uint mesh_index = mesh_instance_draws[ \n      gl_GeometryIndexEXT ].mesh_draw_index;\n    MeshDraw mesh = mesh_draws[ mesh_index ];\n\n    int_array_type index_buffer = int_array_type( \n      mesh.index_buffer );\n    int i0 = index_buffer[ gl_PrimitiveID * 3 ].v;\n    int i1 = index_buffer[ gl_PrimitiveID * 3 + 1 ].v;\n    int i2 = index_buffer[ gl_PrimitiveID * 3 + 2 ].v;\n```", "```cpp\n    float_array_type vertex_buffer = float_array_type( \n      mesh.position_buffer );\n    vec4 p0 = vec4(vertex_buffer[ i0 * 3 + 0 ].v, \n      vertex_buffer[ i0 * 3 + 1 ].v,\n      vertex_buffer[ i0 * 3 + 2 ].v, 1.0 );\n    // Calculate p1 and p2 using i1 and i2 in the same \n       way.   \n```", "```cpp\n    const mat4 transform = mesh_instance_draws[ \n      gl_GeometryIndexEXT ].model;\n    vec4 p0_world = transform * p0;\n    // calculate as well p1_world and p2_world\n```", "```cpp\n    float_array_type uv_buffer = float_array_type( \n      mesh.uv_buffer );\n    vec2 uv0 = vec2(uv_buffer[ i0 * 2 ].v, uv_buffer[ \n      i0 * 2 + 1].v);\n    // Read uv1 and uv2 using i1 and i2 \n    float b = barycentric_weights.x;\n    float c = barycentric_weights.y;\n    float a = 1 - b - c;\n\n    vec2 uv = ( a * uv0 + b * uv1 + c * uv2 );\n```", "```cpp\n    vec3 diffuse = texture( global_textures[ \n      nonuniformEXT( mesh.textures.x ) ], uv ).rgb;\n```", "```cpp\n    float_array_type normals_buffer = \n      float_array_type( mesh.normals_buffer );\n    vec3 n0 = vec3(normals_buffer[ i0 * 3 + 0 ].v,\n      normals_buffer[ i0 * 3 + 1 ].v,\n      normals_buffer[ i0 * 3 + 2 ].v );\n    // Similar calculations for n1 and n2 using i1 and \n       i2\n    vec3 normal = a * n0 + b * n1 + c * n2;\n    const mat3 normal_transform = mat3(mesh_instance_draws\n      [gl_GeometryIndexEXT ].model_inverse);\n    normal = normal_transform * normal;\n```", "```cpp\n    const vec3 world_position = a * p0_world.xyz + b * \n      p1_world.xyz + c * p2_world.xyz;\n    vec3 diffuse = albedo * direct_lighting(world_position, \n      normal);\n    // Optional: infinite bounces by samplying previous \n       frame Irradiance:\n    diffuse += albedo * sample_irradiance( world_position, \n      normal, camera_position.xyz ) * \n      infinite_bounces_multiplier;\n```", "```cpp\n    radiance = diffuse;\n    distance = gl_RayTminEXT + gl_HitTEXT;\n    }\n```", "```cpp\n    payload.radiance = radiance;\n    payload.distance = distance;\n}\n```", "```cpp\nlayout( location = 0 ) rayPayloadInEXT RayPayload payload;\nvoid main() {\npayload.radiance = vec3( 0.529, 0.807, 0.921 );\npayload.distance = 1000.0f;\n}\n```", "```cpp\nlayout (local_size_x = 8, local_size_y = 8, local_size_z = \n        1) in;\nvoid main() {\n    ivec3 coords = ivec3(gl_GlobalInvocationID.xyz);\n    const uint probe_with_border_side = probe_side_length + \n                                        2;\n    const uint probe_last_pixel = probe_side_length + 1;\n    int probe_index = get_probe_index_from_pixels\n      (coords.xy, int(probe_with_border_side), \n      probe_texture_width);\n    // Check if thread is a border pixel\n    bool border_pixel = ((gl_GlobalInvocationID.x % \n      probe_with_border_side) == 0) || \n      ((gl_GlobalInvocationID.x % probe_with_border_side ) \n      == probe_last_pixel );\n    border_pixel = border_pixel || \n      ((gl_GlobalInvocationID.y % probe_with_border_side) \n      == 0) || ((gl_GlobalInvocationID.y % \n      probe_with_border_side ) == probe_last_pixel );\n```", "```cpp\n    if ( !border_pixel ) {\n        vec4 result = vec4(0);\n        uint backfaces = 0;\n        uint max_backfaces = uint(probe_rays * 0.1f); \n```", "```cpp\n        for ( int ray_index = 0; ray_index < probe_rays; \n              ++ray_index ) {\n            ivec2 sample_position = ivec2( ray_index, \n              probe_index );\n            vec3 ray_direction = normalize( \n              mat3(random_rotation) * \n              spherical_fibonacci(ray_index, probe_rays) );\n            vec3 texel_direction = oct_decode\n              (normalized_oct_coord(coords.xy));\n            float weight = max(0.0, dot(texel_direction, \n              ray_direction));\n```", "```cpp\n            float distance = texelFetch(global_textures\n              [nonuniformEXT(radiance_output_index)], \n              sample_position, \n              0).w;\n            if ( distance < 0.0f && \n                 use_backfacing_blending() ) {\n                ++backfaces;\n                // Early out: only blend ray radiance into \n                   the probe if the backface threshold \n                   hasn't been exceeded\n                if (backfaces >= max_backfaces) {\n                    return;\n                }\n                continue;\n            }\n```", "```cpp\n            if (weight >= EPSILON) {\n                vec3 radiance = texelFetch(global_textures\n                  [nonuniformEXT(radiance_output_index)], \n                  sample_position, 0).rgb;\n                radiance.rgb *= energy_conservation;\n\n                // Storing the sum of the weights in alpha \n                   temporarily\n                result += vec4(radiance * weight, weight);\n            }\n\n```", "```cpp\n            float probe_max_ray_distance = 1.0f * 1.5f;\n            if (weight >= EPSILON) {\n                float distance = texelFetch(global_textures\n                  [nonuniformEXT(radiance_output_index)], \n                  sample_position, 0).w;\n                // Limit distance\n                distance = min(abs(distance), \n                  probe_max_ray_distance);\n                vec3 value = vec3(distance, distance * \n                  distance, 0);\n                // Storing the sum of the weights in alpha \n                   temporarily\n                result += vec4(value * weight, weight);\n            }\n        }\n```", "```cpp\n        if (result.w > EPSILON) {\n            result.xyz /= result.w;\n            result.w = 1.0f;\n        }\n```", "```cpp\n        vec4 previous_value = imageLoad( irradiance_image, \n          coords.xy );\n        result = mix( result, previous_value, hysteresis );\n        imageStore(irradiance_image, coords.xy, result);\n```", "```cpp\n        vec2 previous_value = imageLoad( visibility_image, \n          coords.xy ).rg;\n        result.rg = mix( result.rg, previous_value, \n          hysteresis );\n        imageStore(visibility_image, coords.xy, \n          vec4(result.rg, 0, 1));\n```", "```cpp\n        // NOTE: returning here.\n        return;\n    }\n```", "```cpp\n    groupMemoryBarrier();\n    barrier();\n```", "```cpp\n    const uint probe_pixel_x = gl_GlobalInvocationID.x % \n      probe_with_border_side;\n    const uint probe_pixel_y = gl_GlobalInvocationID.y % \n      probe_with_border_side;\n    bool corner_pixel = (probe_pixel_x == 0 || \n      probe_pixel_x == probe_last_pixel) && (probe_pixel_y \n      == 0 || probe_pixel_y == probe_last_pixel);\n    bool row_pixel = (probe_pixel_x > 0 && probe_pixel_x < \n      probe_last_pixel);\n    ivec2 source_pixel_coordinate = coords.xy;\n    if ( corner_pixel ) {\n        source_pixel_coordinate.x += probe_pixel_x == 0 ? \n          probe_side_length : -probe_side_length;\n        source_pixel_coordinate.y += probe_pixel_y == 0 ? \n          probe_side_length : -probe_side_length;\n     }\n    else if ( row_pixel ) {\n        source_pixel_coordinate.x += \n          k_read_table[probe_pixel_x - 1];\n        source_pixel_coordinate.y += (probe_pixel_y > 0) ? \n          -1 : 1;\n     }\n    else {\n        source_pixel_coordinate.x += (probe_pixel_x > 0) ? \n          -1 : 1;\n        source_pixel_coordinate.y += \n          k_read_table[probe_pixel_y - 1];\n     }\n\n```", "```cpp\n    vec4 copied_data = imageLoad( irradiance_image, \n      source_pixel_coordinate );\n    imageStore( irradiance_image, coords.xy, copied_data );\n```", "```cpp\n    vec4 copied_data = imageLoad( visibility_image, \n      source_pixel_coordinate );\n    imageStore( visibility_image, coords.xy, copied_data );\n}\n```", "```cpp\nlayout (local_size_x = 8, local_size_y = 8, local_size_z = \n        1) in;\nvoid main() {\n    ivec3 coords = ivec3(gl_GlobalInvocationID.xyz);\n    int resolution_divider = output_resolution_half == 1 ? \n      2 : 1;\n    vec2 screen_uv = uv_nearest(coords.xy, resolution / \n      resolution_divider);\n\n    float raw_depth = 1.0f;\n    int chosen_hiresolution_sample_index = 0;\n    if (output_resolution_half == 1) {\n        float closer_depth = 0.f;\n        for ( int i = 0; i < 4; ++i ) {\n            float depth = texelFetch(global_textures\n             [nonuniformEXT(depth_fullscreen_texture_index)\n             ], (coords.xy) * 2 + pixel_offsets[i], 0).r;\n            if ( closer_depth < depth ) {\n                closer_depth = depth;\n                chosen_hiresolution_sample_index = i;\n            }\n        }\n\n        raw_depth = closer_depth;\n    }\n```", "```cpp\n    vec3 normal = vec3(0);\n    if (output_resolution_half == 1) {\n        vec2 encoded_normal = texelFetch(global_textures\n          [nonuniformEXT(normal_texture_index)],      \n          (coords.xy) * 2 + pixel_offsets\n          [chosen_hiresolution_sample_index], 0).rg;\n       normal = normalize(octahedral_decode(encoded_normal)\n       );\n    }\n```", "```cpp\n    const vec3 pixel_world_position = \n      world_position_from_depth(screen_uv, raw_depth, \n      inverse_view_projection)\n    vec3 irradiance = sample_irradiance( \n      pixel_world_position, normal, camera_position.xyz );\n    imageStore(global_images_2d[ indirect_output_index ], \n      coords.xy, vec4(irradiance,1));\n}\n```", "```cpp\nvec3 sample_irradiance( vec3 world_position, vec3 normal, \n  vec3 camera_position ) {\n    const vec3 V = normalize(camera_position.xyz – \n      world_position);\n    // Bias vector to offset probe sampling based on normal \n       and view vector.\n    const float minimum_distance_between_probes = 1.0f;\n    vec3 bias_vector = (normal * 0.2f + V * 0.8f) * \n      (0.75f  minimum_distance_between_probes) * \n      self_shadow_bias;\n    vec3 biased_world_position = world_position + \n      bias_vector;\n\n    // Sample at world position + probe offset reduces \n       shadow leaking.\n    ivec3 base_grid_indices = \n      world_to_grid_indices(biased_world_position);\n    vec3 base_probe_world_position = \n      grid_indices_to_world_no_offsets( base_grid_indices \n      );\n```", "```cpp\n    // alpha is how far from the floor(currentVertex) \n       position. on [0, 1] for each axis.\n    vec3 alpha = clamp((biased_world_position – \n      base_probe_world_position) , vec3(0.0f), vec3(1.0f));\n```", "```cpp\n    vec3  sum_irradiance = vec3(0.0f);\n    float sum_weight = 0.0f;\n```", "```cpp\n    // Iterate over adjacent probe cage\n    for (int i = 0; i < 8; ++i) {\n        // Compute the offset grid coord and clamp to the \n           probe grid boundary\n        // Offset = 0 or 1 along each axis\n        ivec3  offset = ivec3(i, i >> 1, i >> 2) & \n          ivec3(1);\n        ivec3  probe_grid_coord = clamp(base_grid_indices + \n          offset, ivec3(0), probe_counts - ivec3(1));\n        int probe_index = \n          probe_indices_to_index(probe_grid_coord);\n        vec3 probe_pos = \n          grid_indices_to_world(probe_grid_coord, \n          probe_index); \n```", "```cpp\n        vec3 trilinear = mix(1.0 - alpha, alpha, offset);\n        float weight = 1.0;\n```", "```cpp\n        vec3 probe_to_biased_point_direction = \n          biased_world_position - probe_pos;\n        float distance_to_biased_point = \n          length(probe_to_biased_point_direction);\n        probe_to_biased_point_direction *= 1.0 / \n          distance_to_biased_point;\n       {\n            vec2 uv = get_probe_uv\n              (probe_to_biased_point_direction,\n              probe_index, probe_texture_width, \n              probe_texture_height, \n              probe_side_length );\n            vec2 visibility = textureLod(global_textures\n            [nonuniformEXT(grid_visibility_texture_index)],\n            uv, 0).rg;\n            float mean_distance_to_occluder = visibility.x;\n            float chebyshev_weight = 1.0;\n```", "```cpp\n            if (distance_to_biased_point > \n                mean_distance_to_occluder) {\n                float variance = abs((visibility.x * \n                  visibility.x) - visibility.y);\n                const float distance_diff = \n                  distance_to_biased_point – \n                  mean_distance_to_occluder;\n                chebyshev_weight = variance / (variance + \n                  (distance_diff * distance_diff));\n                // Increase contrast in the weight\n                chebyshev_weight = max((chebyshev_weight * \n                  chebyshev_weight * chebyshev_weight), \n                    0.0f);\n            }\n\n            // Avoid visibility weights ever going all of \n               the way to zero\n           chebyshev_weight = max(0.05f, chebyshev_weight);\n           weight *= chebyshev_weight;\n        }\n```", "```cpp\n         vec2 uv = get_probe_uv(normal, probe_index, \n           probe_texture_width, probe_texture_height, \n           probe_side_length );\n        vec3 probe_irradiance = \n          textureLod(global_textures\n          [nonuniformEXT(grid_irradiance_output_index)],\n          uv, 0).rgb;\n         // Trilinear weights\n        weight *= trilinear.x * trilinear.y * trilinear.z + \n          0.001f;\n        sum_irradiance += weight * probe_irradiance;\n        sum_weight += weight;\n    }\n```", "```cpp\n    vec3 irradiance = 0.5f * PI * sum_irradiance / \n      sum_weight;\n    return irradiance;\n}\n```", "```cpp\n    vec3 F = fresnel_schlick_roughness(max(dot(normal, V), \n      0.0), F0, roughness);\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n    vec3 indirect_irradiance = textureLod(global_textures\n      [nonuniformEXT(indirect_lighting_texture_index)], \n      screen_uv, 0).rgb;\n    vec3 indirect_diffuse = indirect_irradiance * \n      base_colour.rgb;\n    const float ao = 1.0f;\n    final_color.rgb += (kD * indirect_diffuse) * ao;\n```", "```cpp\nlayout (local_size_x = 32, local_size_y = 1, local_size_z = \n        1) in;\nvoid main() {\n    ivec3 coords = ivec3(gl_GlobalInvocationID.xyz);\n    // Invoke this shader for each probe\n    int probe_index = coords.x;\n    const int total_probes = probe_counts.x * \n      probe_counts.y * probe_counts.z;\n    // Early out if index is not valid\n    if (probe_index >= total_probes) {\n        return;\n    }\n```", "```cpp\n    int closest_backface_index = -1;\n    float closest_backface_distance = 100000000.f;\n    int closest_frontface_index = -1;\n    float closest_frontface_distance = 100000000.f;\n    int farthest_frontface_index = -1;\n    float farthest_frontface_distance = 0;\n    int backfaces_count = 0;\n```", "```cpp\n    // For each ray cache front/backfaces index and \n       distances.\n    for (int ray_index = 0; ray_index < probe_rays; \n         ++ray_index) {\n        ivec2 ray_tex_coord = ivec2(ray_index, \n          probe_index);\n        float ray_distance = texelFetch(global_textures\n          [nonuniformEXT(radiance_output_index)], \n          ray_tex_coord, 0).w;\n        // Negative distance is stored for backface hits in \n           the Ray Tracing Hit shader.\n        if ( ray_distance <= 0.0f ) {\n            ++backfaces_count;\n            // Distance is a positive value, thus negate \n               ray_distance as it is negative already if\n            // we are inside this branch.\n            if ( (-ray_distance) < \n                  closest_backface_distance ) {\n                closest_backface_distance = ray_distance;\n                closest_backface_index = ray_index;\n            }\n        }\n        else {\n            // Cache either closest or farther distance and \n               indices for this ray.\n            if (ray_distance < closest_frontface_distance) \n            {\n                closest_frontface_distance = ray_distance;\n                closest_frontface_index = ray_index;\n            } else if (ray_distance > \n                       farthest_frontface_distance) {\n                farthest_frontface_distance = ray_distance;\n                farthest_frontface_index = ray_index;\n            }\n        }\n    }\n```", "```cpp\n       vec4 current_offset = vec4(0);\n    // Read previous offset after the first frame.\n    if ( first_frame == 0 ) {\n        const int probe_counts_xy = probe_counts.x * \n          probe_counts.y;\n        ivec2 probe_offset_sampling_coordinates = \n          ivec2(probe_index % probe_counts_xy, probe_index \n          / probe_counts_xy);\n        current_offset.rgb = texelFetch(global_textures\n          [nonuniformEXT(probe_offset_texture_index)], \n          probe_offset_sampling_coordinates, 0).rgb;\n    }\n```", "```cpp\n    vec3 full_offset = vec3(10000.f);\n    vec3 cell_offset_limit = max_probe_offset * \n      probe_spacing;\n    // Check if a fourth of the rays was a backface, we can \n       assume the probe is inside a geometry.\n    const bool inside_geometry = (float(backfaces_count) / \n      probe_rays) > 0.25f;\n    if (inside_geometry && (closest_backface_index != -1)) \n    {\n        // Calculate the backface direction.\n        const vec3 closest_backface_direction = \n          closest_backface_distance * normalize( \n          mat3(random_rotation) * \n          spherical_fibonacci(closest_backface_index, \n          probe_rays) );        \n```", "```cpp\n        const vec3 positive_offset = (current_offset.xyz + \n          cell_offset_limit) / closest_backface_direction;\n        const vec3 negative_offset = (current_offset.xyz – \n          cell_offset_limit) / closest_backface_direction;\n        const vec3 maximum_offset = vec3(max\n          (positive_offset.x, negative_offset.x), \n          max(positive_offset.y, negative_offset.y), \n          max(positive_offset.z, negative_offset.z));\n        // Get the smallest of the offsets to scale the \n           direction\n        const float direction_scale_factor = min(min\n          (maximum_offset.x, maximum_offset.y),\n          maximum_offset.z) - 0.001f;\n        // Move the offset in the opposite direction of the \n           backface one.\n        full_offset = current_offset.xyz – \n          closest_backface_direction * \n          direction_scale_factor;\n    }\n```", "```cpp\n    else if (closest_frontface_distance < 0.05f) {\n        // In this case we have a very small hit distance.\n        // Ensure that we never move through the farthest \n           frontface\n        // Move minimum distance to ensure not moving on a \n           future iteration.\n        const vec3 farthest_direction = min(0.2f, \n          farthest_frontface_distance) * normalize( \n          mat3(random_rotation) * \n          spherical_fibonacci(farthest_frontface_index, \n          probe_rays) );\n        const vec3 closest_direction = normalize(mat3\n          (random_rotation) * spherical_fibonacci\n          (closest_frontface_index, probe_rays));\n        // The farthest frontface may also be the closest \n           if the probe can only \n        // see one surface. If this is the case, don't move \n           the probe.\n        if (dot(farthest_direction, closest_direction) < \n            0.5f) {\n            full_offset = current_offset.xyz + \n              farthest_direction;\n        }\n    } \n```", "```cpp\n    if (all(lessThan(abs(full_offset), cell_offset_limit)))\n    {\n        current_offset.xyz = full_offset;\n    }\n    const int probe_counts_xy = probe_counts.x * \n      probe_counts.y;\n    const int probe_texel_x = (probe_index % \n      probe_counts_xy);\n    const int probe_texel_y = probe_index / \n      probe_counts_xy;\n    imageStore(global_images_2d[ probe_offset_texture_index \n      ], ivec2(probe_texel_x, probe_texel_y), \n      current_offset);\n}\n```"]