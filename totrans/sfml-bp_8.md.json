["```cpp\nclass Connection\n{\n  public:\n  Connection();\n  virtual ~Connection();\n\n  void run();\n  void stop();\n  void wait();\n\n  bool pollEvent(sf::Packet& event);\n  bool pollEvent(packet::NetworkEvent*& event);\n\n  void send(sf::Packet& packet);\n  void disconnect();\n  int id()const;\n  virtual sf::IpAddress getRemoteAddress()const = 0;\n\n  protected:\n  sf::TcpSocket _sockIn;\n  sf::TcpSocket _sockOut;\n\n  private:\n  bool _isRunning;\n\n  void _receive();\n  sf::Thread _receiveThread;\n  sf::Mutex _receiveMutex;\n  std::queue<sf::Packet> _incoming;\n\n  void _send();\n  sf::Thread _sendThread;\n  sf::Mutex _sendMutex;\n  std::queue<sf::Packet> _outgoing;\n\n  static int _numberOfCreations;\n  const int _id;\n};\n```", "```cpp\nConnection::Connection() :_isRunning(false), _receiveThread(&Connection::_receive,this), _sendThread(&Connection::_send,this),_id(++_numberOfCreations) {}\nConnection::~Connection() {}\n```", "```cpp\nvoid Connection::run()\n{\n  _isRunning = true;\n  _receiveThread.launch();\n  _sendThread.launch();\n}\n\nvoid Connection::stop() {_isRunning  = false;}\n\nvoid Connection::wait()\n{\n  _receiveThread.wait();\n  _sendThread.wait();\n}\n```", "```cpp\nint Connection::id()const {return _id;}\n\nbool Connection::pollEvent(sf::Packet& event)\n{\n  bool res = false;\n  sf::Lock guard(_receiveMutex);\n  if(_incoming.size() > 0)\n  {\n    std::swap(event,_incoming.front());\n    _incoming.pop();\n    res = true;\n  }\n  return res;\n}\n\nbool Connection::pollEvent(packet::NetworkEvent*& event)\n{\n  bool res = false;\n  sf::Packet msg;\n  if(Connection::pollEvent(msg))\n  {\n    event = packet::NetworkEvent::makeFromPacket(msg);\n    if(event != nullptr)\n      res = true;\n  }\n  return res;\n}\n```", "```cpp\nvoid Connection::send(sf::Packet& packet)\n{\n  sf::Lock guard(_sendMutex);\n  _outgoing.emplace(packet);\n}\n```", "```cpp\nvoid Connection::disconnect()\n{\n  _sockIn.disconnect();\n  _sockOut.disconnect();\n}\n```", "```cpp\nvoid Connection::_receive()\n{\n  sf::SocketSelector selector;\n  selector.add(_sockIn);\n  while(_isRunning)\n  {\nif(not selector.wait(sf::seconds(1)))\n  continue;\nif(not selector.isReady(_sockIn))\n  continue;\n    sf::Packet packet;\n    sf::Socket::Status status = _sockIn.receive(packet);\n    if(status == sf::Socket::Done)\n    {\n      sf::Lock guard(_receiveMutex);\n      _incoming.emplace(std::move(packet));\n    }\n    else if (status == sf::Socket::Disconnected)\n    {\n      packet.clear();\n      packet<<packet::Disconnected();\n      sf::Lock guard(_receiveMutex);\n      _incoming.emplace(std::move(packet));\n      stop();\n    }\n  }\n}\n```", "```cpp\nvoid Connection::_send()\n{\n  while(_isRunning)\n  {\n    _sendMutex.lock();\n    if(_outgoing.size() > 0)\n    {\n      sf::Packet packet = _outgoing.front();\n      _outgoing.pop();\n      _sendMutex.unlock();\n      _sockOut.send(packet);\n    }\n    else\n    {\n      _sendMutex.unlock();\n    }\n  }\n}\n```", "```cpp\nvoid sendDatas(sf::Socket& socket)\n{\n  sf::Uint32 x = 24;\n  std::string s = \"hello\";\n  double d = 5.89;\n  // Group the variables to send into a packet\n  sf::Packet packet;\n  packet << x << s << d;\n  // Send it over the network (socket is a valid sf::TcpSocket)\n  socket.send(packet);\n}\n\nvoid receiveDatas(sf::Socket& socket)\n{\n  sf::Packet packet;\n  socket.receive(packet);\n  // Extract the variables contained in the packet\n  sf::Uint32 x;\n  std::string s;\n  double d;\n  if (packet >> x >> s >> d)\n  {\n    // Data extracted successfully...\n  }\n}\n```", "```cpp\nstruct MyStruct\n{\n  float number;\n  sf::Int8 integer;\n  std::string str;\n};\n\nsf::Packet& operator <<(sf::Packet& packet, const MyStruct& m){\n  return packet << m.number << m.integer << m.str;\n}\n\nsf::Packet& operator >>(sf::Packet& packet, MyStruct& m){\n  return packet >> m.number >> m.integer >> m.str;\n}\n\nint main()\n{\n  MyStruct toSend;\n  toSend.number = 18.45f;\n  toSend.integer = 42;\n  toSend.str = \"Hello world!\";\n\n  sf::Packet packet;\n  packet << toSend;\n\n  // create a socket\n\n  socket.send(packet);\n  //...\n}\n```", "```cpp\nnamespace FuncIds{\n  enum FUNCIDS {\n    //both side\n    IdHandler = 0, IdDisconnected, IdLogOut,\n    //client\n    IdGetListGame, IdCreateGame, IdJoinGame,IdRequestCreateEntity, IdRequestDestroyEntity,\n    //server events\n    IdSetListGame, IdJoinGameConfirmation, IdJoinGameReject, IdDestroyEntity, IdCreateEntity,  IdUpdateEntity, IdOnHittedEntity, IdOnHitEntity,  IdOnSpawnEntity, IdUpdateTeam\n  };\n}\n```", "```cpp\nclass NetworkEvent\n{\n  public:\n  NetworkEvent(FuncIds::FUNCIDS type);\n  virtual ~NetworkEvent();\n\n  FuncIds::FUNCIDS type()const;\n  static NetworkEvent* makeFromPacket(sf::Packet& packet);\n\n  friend sf::Packet& operator>>(sf::Packet&, NetworkEvent& self);\n  friend sf::Packet& operator<<(sf::Packet&, const NetworkEvent& self);\n\n  protected:\n  const FuncIds::FUNCIDS _type;\n};\n```", "```cpp\nNetworkEvent::NetworkEvent(FuncIds::FUNCIDS type) : _type(type){}\nNetworkEvent::~NetworkEvent(){}\n```", "```cpp\nNetworkEvent* NetworkEvent::makeFromPacket(sf::Packet& packet)\n{\n  sf::Uint8 type;\n  NetworkEvent* res = nullptr;\n  packet>>type;\n  switch(type)\n  {\n    case FuncIds::IdDisconnected :\n    {\n      res = new Disconnected();\n      packet>>(*static_cast<Disconnected*>(res));\n    }break;\n\n    //... test all the different  FuncIds\n\n    case FuncIds::IdUpdateTeam :\n    {\n      res = new UpdateTeam();\n      packet>>(*static_cast<UpdateTeam*>(res));\n    }break;\n  }\nreturn res;\n}\n```", "```cpp\nFuncIds::FUNCIDS NetworkEvent::type()const {return _type;}\n```", "```cpp\nsf::Packet& operator>>(sf::Packet& packet, NetworkEvent& self)\n{\n    return packet;\n}\n\nsf::Packet& operator<<(sf::Packet& packet, const NetworkEvent& \n  self)\n{\n  packet<<sf::Uint8(self._type);\n  return packet;\n}\n```", "```cpp\nnamespace EntityType {\n  enum TYPES {IdMain = 0,IdEye,IdWormEgg,IdWorm,IdCarnivor,};\n}\n\nclass RequestCreateEntity : public NetworkEvent\n{\n  public :\n  RequestCreateEntity();\n  RequestCreateEntity(short int type,const sf::Vector2i& coord);\n\n  short int getType()const;\n  const sf::Vector2i& getCoord()const;\n\n  friend sf::Packet& operator>>(sf::Packet&, RequestCreateEntity& self);\n  friend sf::Packet& operator<<(sf::Packet&, const RequestCreateEntity& self);\n\n  private:\n  short int _entitytype;\n  sf::Vector2i _coord;\n};\n```", "```cpp\nRequestCreateEntity::RequestCreateEntity() : NetworkEvent(FuncIds::IdRequestCreateEntity){}\n\nRequestCreateEntity::RequestCreateEntity(short int type,const sf::Vector2i& coord) : NetworkEvent(FuncIds::IdRequestCreateEntity), _entitytype(type), _coord(coord) {}\n\nshort int RequestCreateEntity::getType()const\n{\n    return _entitytype;\n}\n\nconst sf::Vector2i& RequestCreateEntity::getCoord()const {return _coord;}\n\nsf::Packet& operator>>(sf::Packet& packet, RequestCreateEntity& self)\n{\n  sf::Int8 type;\n  sf::Int32 x,y;\n  packet>>type>>x>>y;\n\n  self._entitytype = type;\n  self._coord.x = x;\n  self._coord.y = y;\n  return packet;\n}\n```", "```cpp\nsf::Packet& operator<<(sf::Packet& packet, const RequestCreateEntity& self)\n{\n  packet<<sf::Uint8(self._type)\n  <<sf::Int8(self._entitytype)\n  <<sf::Int32(self._coord.x)\n  <<sf::Int32(self._coord.y);\n  return packet;\n}\n```", "```cpp\nclass Server\n{\n    public:\n        Server(int port);\n        ~Server();\n        void run();â€©\n    private:\n        const unsigned int _port;\n        void runGame();\n        void listen();\n\n        sf::Thread _gameThread;\n        sf::Mutex _gameMutex;\n        std::vector<std::shared_ptr<Game>> _games;\n\n        sf::Mutex _clientMutex;\n        std::vector<std::shared_ptr<Client>> _clients;\n\n        sf::Thread _listenThread;\n        sf::TcpListener _socketListener;\n        std::shared_ptr<Client> _currentClient;\n};\n```", "```cpp\nsig_atomic_t stop = false;\nvoid signalHandler(int sig) {stop = true;}\n```", "```cpp\nServer::Server(int port) : \n  _port(port),_gameThread(&Server::runGame,this),_listenThread(&Server::listen,this)\n{\n  rand_init();\n  _currentClient = nullptr;\n}\n```", "```cpp\nServer::~Server()\n{\n  _gameMutex.lock();\n  for(Game* game : _games)\n  game->stop()\n  _gameMutex.unlock();\n  _clientMutex.lock();\n  for(Client* client : _clients)\n  client->stop();\n  _clientMutex.unlock();\n}\n```", "```cpp\nvoid Server::run()\n{\n  std::signal(SIGINT,signalHandler);\n  _gameThread.launch();\n  _listenThread.launch();\n  _gameThread.wait();\n  _listenThread.terminate();\n}\n```", "```cpp\nvoid Server::runGame()\n{\n  while(!stop)\n  {\n    sf::Lock guard(_clientMutex);\n    for(auto it = _clients.begin(); it != _clients.end();++it)//loop on clients\n    {\n      std::shared_ptr<Client> client = *it; //get iteration current client\n      packet::NetworkEvent* msg;\n      while(client and client->pollEvent(msg)) //some events incomings\n      {\n        switch(msg->type()) //check the type\n        {\n          case FuncIds::IdGetListGame :\n          {\n            sf::Packet response;\n            packet::SetListGame list;\n            sf::Lock guard(_gameMutex);\n            for(Game* game : _games) { //send match informations\n            list.add(game->id(),game->getPlayersCount(),game->getTeamCount());\n          }\n          response<<list;\n          client->send(response);\n        }break;\n        case FuncIds::IdCreateGame :\n        {\n          sf::Packet response;\n          packet::SetListGame list;\n          sf::Lock guard(_gameMutex);\n          _games.emplace_back(new Game(\"./media/map.json\")); //create a new match\n          for(Game* game : _games){ //send match informations\n          list.add(game->id(),game->getPlayersCount(),game->getTeamCount());\n        }\n        //callback when a client exit a match\n        _games.back()->onLogOut = [this](std::shared_ptr<Client> client){\n          _clients.emplace_back(client);\n        };\n        _games.back()->run(); //start the match\n        response<<list;\n        for(auto it2 = _clients.begin(); it2 != _clients.end();++it2){ //send to all client\n        (*it2)->send(response);\n      }\n    }break;\n    case FuncIds::IdJoinGame :\n    {\n      int gameId = static_cast<packet::JoinGame*>(msg)->gameId()\n      sf::Lock guard(_gameMutex); \n      //check if the player can really join the match\n      for(auto game : _games) {\n        if(game->id() == gameId) {\n          if(game->addClient(client)){ //yes he can\n          client = nullptr;\n          it = _clients.erase(it); //stop to manage the client here. Now the game do it\n          --it;\n        }\n        break;\n      }\n    }\n  }break;\n  case FuncIds::IdDisconnected : //Oups, the client leave the game\n  {\n    it = _clients.erase(it);\n    --it;\n    client = nullptr;\n  }break;\n  default : break;\n}\ndelete msg;\n}\n```", "```cpp\nvoid Server::listen()\n{\n  if(_socketListener.listen(_port) != sf::Socket::Done) {\n    stop = true;\n    return;\n  }\n  _currentClient =   new Client;\n  while(!stop)\n  {\n    if (_socketListener.accept(_currentClient->getSockIn()) == sf::Socket::Done) {\n      if(_currentClient->connect()) {\n        sf::Lock guard(_clientMutex);\n        _clients.emplace_back(_currentClient);\n        _currentClient->run();\n        _currentClient = new Client;\n      }\n      else {\n        _currentClient->disconnect();\n      }\n    }\n  }\n}\n```", "```cpp\nbool Game::addClient(Client* client)\n{\n    sf::Lock guard(_teamMutex);\n    Team* clientTeam = nullptr;\n    for(Team* team : _teams)\n    {\n        // is there any team for the player\n        if(team->getClients().size() == 0 and team->isGameOver())\n        { //find it\n            clientTeam = team;\n            break;\n        }\n    }\n\n    sf::Packet response;\n    if(clientTeam != nullptr)\n    {\n        //send map informations\n        std::ifstream file(_mapFileName);\n        //get file content to as std::string\n        std::string content((std::istreambuf_iterator<char>(file)),(std::istreambuf_iterator<char>()));\n\n        packet::JoinGameConfirmation conf(content,clientTeam->id());//send confirmation\n\n        for(Team* team : _teams)\n        { //send team datas\n            packet::JoinGameConfirmation::Data data;\n            data.team = team->id();\n            data.gold = team->getGold();\n            data.color = team->getColor();\n            conf.addTeam(std::move(data));\n        }\n\n        response<<conf;\n        client->send(response);\n        {\n            //send initial content\n            response.clear();\n            sf::Lock gameGuard(_gameMutex);\n            packet::CreateEntity datas; //entites informations\n            for(auto id : entities)\n                addCreate(datas,id);\n            response<<datas;\n            client->send(response);\n        }\n\n        client->setTeam(clientTeam);\n        sf::Lock guardClients(_clientsMutex);\n        _clients.emplace_back(client);\n    }\n    else\n    { //Oups, someone the match is already full\n        response<<packet::JoinGameReject(_id);\n        client->send(response);\n    }\n    return clientTeam != nullptr;\n}\n```", "```cpp\n    void Game::processNetworkEvents()\n    {\n        sf::Lock guard(_clientsMutex);\n         for(auto it = _clients.begin(); it != _clients.end();++it)\n        {\n             auto client = *it;\n             packet::NetworkEvent* msg;\n              while(client and client->pollEvent(msg))\n             {\n                  switch(msg->type())\n                  {\n                       case FuncIds::IdDisconnected :\n                       {\n                           it = _clients.erase(it);\n                           --it;\n                           delete client;\n                           client = nullptr;\n                       }break;\n\n                       case FuncIds::IdLogOut :\n                       {\n                           it = _clients.erase(it);\n                           --it;\n                           client->getTeam()->remove(client);\n                           onLogOut(client); //callback to the server\n                            client = nullptr;\n                       }break;\n\n                       case FuncIds::IdRequestCreateEntity :\n                       {\n                           packet::RequestCreateEntity* event = static_cast<packet::RequestCreateEntity*>(msg);\n                           sf::Lock gameGuard(_teamMutex);\n                            // create the entity is the team as enough money\n                       }break;\n\n                       case FuncIds::IdRequestDestroyEntity :\n                       {\n                           packet::RequestDestroyEntity* event = static_cast<packet::RequestDestroyEntity*>(msg);\n                           // destroy the entity if it shares the same team as the client\n                       }break;\n                        default : break;\n                   } //end switch           } //end while       } //end for \n    }\n    ```", "```cpp\nif(_destroyEntityId.size() > 0)\n{\n  packet::DestroyEntity update;\n  for(auto id : _destroyEntityId)\n  update.add(id);\n  sf::Packet packet;\n  packet<<update;\n  sendToAll(packet);\n  _destroyEntityId.clear();\n}\n```", "```cpp\nclass Game\n{\n  public:\n  Game(int x=1600, int y=900);\n  ~Game();\n  bool connect(const sf::IpAddress& ip, unsigned short port,sf::Time timeout=sf::Time::Zero);\n  void run(int frame_per_seconds=60);\n  private:\n  void processEvents();\n  void processNetworkEvents();\n  void update(sf::Time deltaTime);\n  void render();\n  bool _asFocus; \n  sf::RenderWindow _window;\n  sf::Sprite _cursor;\n  Client _client;\n  bool _isConnected;\n  enum Status {StatusMainMenu,StatusInGame, StatusDisconnected} _status;\n  MainMenu _mainMenu;\n  GameMenu _gameMenu;\n  Level* _level;\n  Level::FuncType _onPickup;\n  int _team;\n};\n```", "```cpp\nclass MainMenu : public sfutils::Frame\n{\n  public:\n  MainMenu(sf::RenderWindow& window,Client& client);\n  void fill(packet::SetListGame& list);\n  private:\n  Client& _client;\n};\n```", "```cpp\nMainMenu::MainMenu(sf::RenderWindow& window,Client& client) : sfutils::Frame(window,Configuration::guiInputs), _client(client)\n{\n        setLayout(new sfutils::Vlayout);\n}\n\nvoid MainMenu::fill(packet::SetListGame& list)\n{\n    clear();\n    sfutils::VLayout* layout = static_cast<sfutils::VLayout*>(Frame::getLayout());\n    {\n        sfutils::TextButton* button = new sfutils::TextButton(\"Create game\");\n        button->setCharacterSize(20);\n        button->setOutlineThickness(1);\n        button->setFillColor(sf::Color(48,80,197));\n        button->on_click = [this](const sf::Event&, sfutils::Button& button){\n            sf::Packet event;\n            event<<packet::CreateGame();\n            _client.send(event);\n        };\n        layout->add(button);\n    }\n\n    {\n        sfutils::TextButton* button = new sfutils::TextButton(\"Refresh\");\n        button->setCharacterSize(20);\n        button->setOutlineThickness(1);\n        button->setFillColor(sf::Color(0,88,17));\n        button->on_click = [this](const sf::Event&, sfutils::Button& button){\n            sf::Packet event;\n            event<<packet::GetListGame();\n            _client.send(event);\n        };\n        layout->add(button);\n    }\n\n    for(const autoe& game : list.list())\n    {\n        std::stringstream ss;\n        ss<<\"Game [\"<<game.id<<\"] Players: \"<<game.nbPlayers<<\"/\"<<game.nbTeams;\n        sfutils::TextButton* button = new sfutils::TextButton(ss.str());\n        button->setCharacterSize(20);\n        button->setOutlineThickness(1);\n        button->on_click = [this,game](const sf::Event&, sfutils::Button& button){\n            sf::Packet event;\n            event<<packet::JoinGame(game.id);\n            _client.send(event);\n        };\n        layout->add(button);\n    } //end for\n}\n```", "```cpp\nvoid Game::processNetworkEvents()\n{\n  packet::NetworkEvent* msg;\n  while(_client.pollEvent(msg))\n  {\n    if(msg->type() == FuncIds::IdDisconnected) {\n      _isConnected = false;\n      _status = StatusDisconnected;\n    }\n    else\n    {\n      switch(_status)\n      {\n        case StatusMainMenu:\n        {\n          switch(msg->type())\n          {\n            case FuncIds::IdSetListGame :\n            {\n              packet::SetListGame* event = static_cast<packet::SetListGame*>(msg);\n              _mainMenu.fill(*event);\n            }break;\n            case FuncIds::IdJoinGameConfirmation :\n            {\n              packet::JoinGameConfirmation* event = static_cast<packet::JoinGameConfirmation*>(msg);\n              // create the level from event\n              if(_level != nullptr) {\n                _team = event->getTeamId();\n                // initialize the team menu\n                _status = StatusInGame;\n              }\n            }break;\n            case FuncIds::IdJoinGameReject :\n            {\n              //...\n            }break;\n            default : break;\n          }\n        }break;\n        case StatusInGame :\n        {\n          _gameMenu.processNetworkEvent(msg);\n          _level->processNetworkEvent(msg);\n        }break;\n        case StatusDisconnected :\n        {\n          // ...\n                }break;\n            } //end switch\n        } //end else\n        delete msg;\n    } //end while\n}\n```", "```cpp\nvoid Level::processNetworkEvent(packet::NetworkEvent* msg)\n{\n  switch(msg->type())\n  {\n    case FuncIds::IdDestroyEntity :\n    {//need to destroy an entity\n      packet::DestroyEntity* event = static_cast<packet::DestroyEntity*>(msg);\n         for(auto id : event->getDestroy())\n           {\n                destroyEntity(id);\n            }\n    }break;\n    case FuncIds::IdCreateEntity :\n    {//need to create an entity\n      packet::CreateEntity* event = static_cast<packet::CreateEntity*>(msg);\n      for(const autoa& data : event->getCreates())\n      {\n        Entity& e = createEntity(data.entityId,data.coord); //create the entity\n        makeAs(data.entityType,e,&_teamInfo.at(data.entityTeam),*this,data); //add the components\n      }\n    }break;\n    case FuncIds::IdUpdateEntity :\n    {//an entity has changed\n      packet::UpdateEntity* event = static_cast<packet::UpdateEntity*>(msg);\n      for(const auto& data : event->getUpdates())\n      {\n        if(entities.isValid(data.entityId)) //the entity is still here, so we have to update it\n        {\n          CompSkin::Handle skin = entities.getComponent<CompSkin>(data.entityId);\n          CompHp::Handle hp = entities.getComponent<CompHp>(data.entityId);\n          //... and other updates\n          hp->_hp = data.hp;\n        }\n      }\n    }break;\n    case FuncIds::IdOnHittedEntity :\n    {//entity event to launch\n      packet::OnHittedEntity* event = static_cast<packet::OnHittedEntity*>(msg);\n      for(const auto& data : event->getHitted())\n      {\n        if(entities.isValid(data.entityId))\n        {\n          Entity& e = entities.get(data.entityId);\n          if(e.onHitted and entities.isValid(data.enemyId)) //to avoid invalid datas\n          {\n            Entity& enemy = entities.get(data.enemyId);\n            //call the callback\n            e.onHitted(e,_map->mapPixelToCoords(e.getPosition()), enemy, _map->mapPixelToCoords(enemy.getPosition()),*this);\n          }\n        }\n      }\n    }break;\n    case FuncIds::IdOnHitEntity :\n    {//another event\n      //same has previous with e.onHit callback\n    }break;\n    case FuncIds::IdOnSpawnEntity :\n    { //other event\n      packet::OnSpawnEntity* event = static_cast<packet::OnSpawnEntity*>(msg);\n      for(auto id : event->getSpawn())\n      {\n        if(entities.isValid(id))\n        {\n          Entity& e = entities.get(id);\n          CompAISpawner::Handle spawn = entities.getComponent<CompAISpawner>(id);\n          if(spawn.isValid() and spawn->_onSpawn) //check data validity\n          {//ok, call the call back\n            spawn->_onSpawn(*this,_map->mapPixelToCoords(e.getPosition()));\n          }\n        }\n      }\n    }break;\n    default : break;\n  }\n}\n```", "```cpp\nString sql = \"SELECT * from Entity WHERE id = 10\"\nSqlQuery query(sql);\nSqlResults res = query.execute();\nEntity e;\ne.color = res[\"color\"];\n//.. other initializations\n```", "```cpp\nEntity e = Entity::get(10);\n// color is already load and set\n```", "```cpp\nclass CompHp : public sfutils::Component<CompHp,Entity>, public orm::SqlObject<CompHp>\n{\n  public:\n  CompHp(); //default constructor\n  explicit CompHp(int hp);\n  orm::IntegerField _hp; //change the type to be persistent\n  orm::IntegerField _maxHp; //here again\n  //create column for the query ability (same name as your attributes)\n  MAKE_STATIC_COLUMN(_hp,_maxHp); \n};\n```", "```cpp\nREGISTER_AND_CONSTRUCT(CompHp,\"CompHp\",\\\n_hp,\"hp\",\\\n_maxHp,\"maxHp\")\n```", "```cpp\n#include <ORM/backends/Sqlite3.hpp>\norm::Sqlite3DB def(\"./08_dataPersistence.sqlite\"); //create the database (need to be include before file that use SqlObject)\norm::DB& orm::DB::Default = def;//set the default connection (multi connection is possible)\n#include <ORM/core/Tables.hpp>\n#include <SFML-Book/server/Server.hpp>\nint main(int argc, char* argv[])\n{\n  // get port parameter\n  orm::DB::Default.connect(); //connect to the database\n  orm::Tables::create(); //create all the tables if needed\n  book::Server server(port);\n  server.run();\n  orm::DB::Default.disconnect(); //disconnect the database\n  return 0;\n}\n```", "```cpp\nCompHp chp;\nchp._hp = 42;\nchp.save();\n//oups I've forgotten the other field\nchp._maxHp = 42;\nchp.save();\nstd::cout<<\"My id is now \"<<chp.getPk()<<std::endl;\n```", "```cpp\nCompHp::type_ptr chp = CompHp::get(10); //load from database\n//chp.getPk() = -1 on error, but chp is a valid object so you can use it\nstd::cout<<\"My id is \"<<chp->getPk()<<\" And my content is \"<<*chp<<std::endl;\n```", "```cpp\nCompHp::result_type res;\nCompHp::query()\n.filter(\n  orm::Q<CompHp>(25,orm::op::gt,CompHp::$_hp)\n  and orm::Q<CompHp>(228,orm::op::lte,CompHp::$_maxHp)\n  or (orm::Q<CompHp>(12,orm::op::gt,CompHp::$_hp) and orm::Q<CompHp>(25,orm::op::exact,CompHp::$_maxHp))\n)// (_hp > 25) and (_maxHp <= 228) or (_hp > 12 and _maxHp ==25 )\n. orderBy(CompHp::$_hp,'+')// could be +,-,?\n.limit(12) //only the first 12 objects\n.get(res);\nfor(auto chp : res)\nstd::cout<<\"My id is \"<<chp->getPk()<<\" And my content is \"<<*chp<<std::endl;\n```"]