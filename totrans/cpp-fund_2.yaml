- en: '*Chapter 2*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*'
- en: Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Lesson Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 课程目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Explain what functions are and how to declare them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释函数是什么以及如何声明它们
- en: Utilize local and global variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用局部和全局变量
- en: Pass arguments to functions and return values from functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向函数传递参数并从函数返回值
- en: Create overloaded functions and call them appropriately
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建重载函数并适当地调用它们
- en: Apply the concept of namespaces in organizing functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用命名空间的概念来组织函数
- en: In this chapter, we are going to look at functions in C++, how to use them,
    and why we would want to use them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨C++中的函数，如何使用它们，以及为什么我们想要使用它们。
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: 'Functions are a core tool in a programmer''s toolkit for writing maintainable
    code. The concept of a function is common in almost every programming language.
    Functions have different names in various languages: procedures, routines, and
    many more, but they all have two main characteristics in common:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是程序员工具箱中编写可维护代码的核心工具。函数的概念在几乎每一种编程语言中都很常见。在不同的语言中，函数有不同的名称：过程、例程等等，但它们都有两个共同的主要特征：
- en: They represent a sequence of instructions grouped together.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们代表了一系列组合在一起的指令。
- en: The sequence of instructions is identified by a name, which can be used to refer
    to the function.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令序列通过一个名称来标识，该名称可以用来引用函数。
- en: The programmer can call, or invoke a function when the functionalities provided
    by the function are needed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数提供的功能需要时，程序员可以调用或调用该函数。
- en: 'When the function is called, the sequence of instructions is executed. The
    caller can also provide some data to the function to be used in operations within
    the program. The following are the main advantages of using functions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被调用时，执行指令序列。调用者还可以向函数提供一些数据，以便在程序中的操作中使用。以下是使用函数的主要优点：
- en: '**Reduces repetition**: It often occurs that a program needs to repeat the
    same operations in different parts of the codebase. Functions allow us to write
    a single implementation that is carefully tested, documented, and of high quality.
    This code can be called from different places in the codebase, which enables code
    reusability. This, in turn, increases the productivity of the programmer and the
    quality of the software.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少重复**：通常情况下，程序需要在代码库的不同部分重复相同的操作。函数允许我们编写一个经过仔细测试、文档化且高质量的单一实现。此代码可以从代码库的不同位置调用，这实现了代码的可重用性。这反过来又提高了程序员的效率和软件的质量。'
- en: '**Boosts code readability and modification**: Often, we need several operations
    to implement a functionality in our program. In these cases, grouping the operations
    together in a function and giving a descriptive name to the function helps to
    express what we want to do instead of how we do it.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提升代码可读性和可修改性**：通常，我们需要执行多个操作来实现程序中的功能。在这些情况下，将操作组合在一起放入函数中，并为函数赋予描述性的名称，有助于表达我们想要做什么，而不是我们是如何做的。'
- en: Using functions greatly increases the readability of our code because it's now
    composed of descriptive names of what we are trying to achieve, without the noise
    of how the result is achieved.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用函数极大地提高了我们代码的可读性，因为现在它由我们试图实现的目标的描述性名称组成，而没有达到结果的噪声。
- en: In fact, it is easier to test and debug as you may only need to modify a function
    without having to revisit the structure of the program.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，测试和调试更容易，因为你可能只需要修改一个函数，而不必重新审视程序的结构。
- en: '**Higher level of abstraction**: We can give a meaningful name to the function
    to represent what it should achieve. This way, the calling code can be concerned
    with what the function is supposed to do, and it does not need to know how the
    operations are performed.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更高的抽象级别**：我们可以给函数一个有意义的名称来表示它应该实现什么。这样，调用代码可以关注函数应该做什么，而不需要知道操作是如何执行的。'
- en: Note
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Abstraction is the process of extracting all relevant properties from a class
    and exposing them, while hiding details that are not important for a specific
    usage.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 抽象是从类中提取所有相关属性并暴露它们的过程，同时隐藏对特定用途不重要的细节。
- en: Let's take a tree as an example. If we were to use it in the context of an orchard,
    we could abstract the tree to be a "machine" that takes a determined amount of
    space and, given sunlight, water, and fertilizers, produces a certain number of
    fruits per year. The property we are interested in is the tree's fruit production
    ability, so we want to expose it and hide all the other details that are not relevant
    to our case.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们以一棵树为例。如果我们将其应用于果园的情境，我们可以将树抽象为一个“机器”，它占用一定量的空间，并在阳光、水和肥料的条件下，每年产生一定数量的果实。我们感兴趣的是树的生产能力，因此我们希望将其暴露出来，并隐藏所有与我们的案例无关的其他细节。
- en: 'In computer science, we want to apply the same concept: capture the key fundamental
    properties of a class without showing the algorithm that implements it.'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在计算机科学中，我们希望应用相同的概念：捕获类的关键基本属性，而不显示实现它的算法。
- en: A prime example of this is the `sort` function, which is present in many languages.
    We know what the function expects and what it is going to do, but rarely are we
    aware of the algorithm that is used to do it, and it might also change between
    different implementations of the language.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个典型例子是`sort`函数，它在许多语言中都存在。我们知道函数期望什么以及它将要做什么，但我们很少意识到用于执行它的算法，而且它可能在语言的不同的实现之间发生变化。
- en: In the following sections, we will demystify how function declaration and definition
    works.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将揭示函数声明和定义是如何工作的。
- en: Function Declaration and Definition
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数声明和定义
- en: A `function` declaration has the role of telling the compiler the name, the
    parameters, and the return type of a function. After a function has been declared,
    it can be used in the rest of the program.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明的作用是告诉编译器函数的名称、参数和返回类型。一旦函数被声明，它就可以在程序的其余部分中使用。
- en: The definition of the function specifies what operations a function performs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的定义指定了函数执行的操作。
- en: 'A declaration is composed of the type of the returned value, followed by the
    name of the function and by a list of parameters inside a pair of parentheses.
    These last two components form the signature of the function. The syntax of a
    function declaration is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 声明由返回值的类型组成，后跟函数名，然后是一对括号内的参数列表。后两个组件构成了函数的签名。函数声明的语法如下：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If a function returns nothing, then the type `void` can be used, and if a function
    is not expecting any parameters the list can be empty.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数不返回任何内容，则可以使用`void`类型，如果函数不期望任何参数，则列表可以为空。
- en: 'Let''s look at an example of a function declaration:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个函数声明的例子：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we declared a function named `doNothingForNow()`, which takes no arguments
    and returns nothing. After this declaration, we can call the `doNothingForNow()`
    function in our program.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为`doNothingForNow()`的函数，它不接受任何参数也不返回任何内容。在此声明之后，我们可以在程序中调用`doNothingForNow()`函数。
- en: To call a function that does not have any parameters, write the name of the
    function followed by a pair of parentheses.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用没有参数的函数，只需写出函数名后跟一对括号。
- en: When a function is called, the execution flow goes from the body of the function
    currently being executed to the body of the called function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被调用时，执行流程会从当前正在执行的函数体转移到被调用函数的体。
- en: In the following example, the execution flow starts at the beginning of the
    body of `main` function and starts executing its operations in order. The first
    operation it encounters is the call to `doNothingForNow()`. At that point, the
    execution flow goes into the body of `doNothingForNow()`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，执行流程从`main`函数体的开始处开始，并按顺序执行其操作。它遇到的第一个操作是调用`doNothingForNow()`。在那个时刻，执行流程进入`doNothingForNow()`的体。
- en: When all the operations inside a function are executed, or the function instructs
    them to go back to the caller, the execution flow resumes from the operation after
    the function call.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数内的所有操作都执行完毕，或者函数指示它们返回调用者时，执行流程从函数调用之后的操作恢复。
- en: 'In our example, the operation after the function call prints `Done` on the
    console:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，函数调用之后的操作会在控制台上打印`Done`：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we were to compile this program, the compilation would succeed, but linking
    would *fail*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译这个程序，编译将成功，但链接会*失败*。
- en: In this program, we instructed the compiler that a function called `doNothingForNow()`
    exists and then we invoked it. The compiler generates an output that calls `doNothingForNow()`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们指示编译器存在一个名为`doNothingForNow()`的函数，然后我们调用了它。编译器生成一个调用`doNothingForNow()`的输出。
- en: The linker then tries to create an executable from the compiler output, but
    since we did not define `doNothingForNow()`, it cannot find the function's definition,
    so it fails.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器随后尝试从编译器输出创建一个可执行文件，但由于我们没有定义`doNothingForNow()`，它找不到函数的定义，因此失败。
- en: To successfully compile the program, we need to define `doNothingForNow()`.
    In the next section, we will explore how to define a function using the same example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功编译程序，我们需要定义`doNothingForNow()`。在下一节中，我们将通过相同的示例来探索如何定义一个函数。
- en: Defining a Function
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一个函数
- en: 'To define a function, we need to write the same information that we used for
    the declaration: the return type, the name of the function, and the parameter
    list, followed by the function body. The function body delimits a new scope and
    is composed of a sequence of statements delimited by curly braces.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个函数，我们需要编写与声明相同的信息：返回类型、函数名和参数列表，然后是函数体。函数体定义了一个新的作用域，由花括号分隔的一系列语句组成。
- en: 'When the function is executed, the statements are executed in order:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数执行时，语句按顺序执行：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s fix the program by adding the body for `doNothingForNow()`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加`doNothingForNow()`的函数体来修复程序：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we defined `doNothingForNow()` with an empty body. This means that as
    soon as the function execution starts, the control flow returns to the function
    that called it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用空体定义了`doNothingForNow()`。这意味着一旦函数执行开始，控制流就会返回到调用它的函数。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: When we define a function, we need to make sure that the signature (the return
    value, the name, and the parameters) are the same as the declaration.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个函数时，我们需要确保签名（返回值、名称和参数）与声明相同。
- en: The definition counts as a declaration as well. We can skip the declaration
    if we define the function before calling it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 定义也计为声明。如果我们定义函数在调用它之前，我们可以省略声明。
- en: 'Let''s revisit our program now since we have added the definition for our function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回顾一下我们的程序，因为我们已经为我们的函数添加了定义：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we compile and run the program, it will succeed and show `Done` on the output
    console.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译并运行程序，它将成功并在输出控制台显示`Done`。
- en: In a program, there can be multiple declarations of the same function, as long
    as the declarations are the same. On the other hand, only a single definition
    of the function can exist, as mandated by the **One Definition Rule** (**ODR**).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，可以有多个相同函数的声明，只要声明相同。另一方面，根据**单一定义规则**（**ODR**），只能存在一个函数的定义。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Several definitions of the same function may exist if compiled in different
    files, but they need to be identical. If they are not, then the program might
    do unpredictable things.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在不同的文件中编译，相同的函数可能有多个定义，但它们必须相同。如果不相同，则程序可能会执行不可预测的操作。
- en: The compiler is not going to warn you!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不会警告你！
- en: The solution is to have the declaration in a **header** file, and the definition
    in an **implementation** file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将声明放在**头文件**中，将定义放在**实现文件**中。
- en: A header file is included in many different implementation files, and the code
    in these files can call the function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个头文件被包含在许多不同的实现文件中，这些文件中的代码可以调用该函数。
- en: An implementation file is compiled only once, so we can guarantee that the definition
    is seen only once by the compiler.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实现文件只编译一次，因此我们可以保证编译器只能看到一次定义。
- en: Then, the linker puts all of the outputs of the compiler together, finds a definition
    of the function, and produces a valid executable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，链接器将编译器的所有输出合并在一起，找到一个函数的定义，并生成一个有效的可执行文件。
- en: 'Exercise 3: Calling a Function from main()'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 3：从main()中调用函数
- en: In our application, we want to log errors. To do so, we have to specify a function
    called `log(),` which prints `Error!` to the standard output when called.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们想要记录错误。为此，我们必须指定一个名为`log()`的函数，当被调用时，它会将`Error!`打印到标准输出。
- en: 'Let''s create a function that can be called from several files, and put it
    in a different header file that can be included:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个可以从多个文件调用的函数，并将其放在一个不同的头文件中，该文件可以包含：
- en: 'Create a file named `log.h` and declare a function called `log()` with no parameters
    and that returns nothing:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`log.h`的文件，并声明一个没有参数且不返回任何内容的`log()`函数：
- en: '[PRE6]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s create a new file, `log.cpp`, where we define the `log()` function
    to print to the standard output:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个新的文件，`log.cpp`，在其中定义`log()`函数以打印到标准输出：
- en: '[PRE7]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Change the `main.cpp` file to include `log.h` and call `log()` in the `main()`
    function:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`main.cpp`文件修改为包含`log.h`并在`main()`函数中调用`log()`：
- en: '[PRE8]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Compile the two files and run the executable. You will see that the message
    **Error!** is printed when we execute it.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译这两个文件并运行可执行文件。你会看到当我们执行它时，会打印出**错误！**信息。
- en: Local and Global Variables
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部和全局变量
- en: The body of a function is a code block that can contain valid statements, one
    of which is a **variable definition**. As we learned in *Lesson 1*, *Getting Started*,
    when such a statement appears, the function declares a **local variable**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体是一个可以包含有效语句的代码块，其中之一是**变量定义**。正如我们在第1课“入门”中学到的，当这样的语句出现时，函数声明了一个**局部变量**。
- en: This is in contrast to global variables, which are the variables that are declared
    outside of functions (and classes, which we will look at in *Lesson 3*, *Classes*).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这与全局变量形成对比，全局变量是在函数（以及我们将在第3课“类”中探讨的类）外部声明的变量。
- en: The difference between a local and a global variable is in the *scope* in which
    it is declared, and thus, in who can access it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量和全局变量之间的区别在于其声明的**作用域**，因此，在谁可以访问它。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Local variables are in the function scope and can only be accessed by the function.
    On the contrary, global variables can be accessed by any function that can see
    them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量在函数作用域内，并且只能被函数访问。相反，全局变量可以被任何可以看到它们的函数访问。
- en: 'It is desirable to use local variables over global variables because they enable
    **encapsulation**: only the code inside the function body can access and modify
    the variable, making the variable invisible to the rest of the program. This makes
    it easy to understand how a variable is used by a function since its usage is
    restricted to the function body and we are guaranteed that no other code is accessing
    it.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用局部变量而不是全局变量是可取的，因为它们使**封装**成为可能：只有函数体内的代码可以访问和修改变量，使变量对程序的其他部分不可见。这使得理解函数如何使用变量变得容易，因为其使用仅限于函数体，我们保证没有其他代码正在访问它。
- en: 'Encapsulation is usually used for three separate reasons, which we will explore
    in more detail in *Lesson 3*, *Classes*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 封装通常有三个单独的原因，我们将在第3课“类”中更详细地探讨：
- en: To restrict the access to data used by a functionality
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了限制对功能使用的数据的访问
- en: To bundle together the data and the functionality that operates on it
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了将数据及其操作它的功能捆绑在一起
- en: Encapsulation is a key concept that allows you to create abstractions
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装是一个关键概念，它允许你创建抽象
- en: On the other hand, global variables can be accessed by *any* function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，全局变量可以被**任何**函数访问。
- en: This makes it hard to be sure of the function's value when interacting with
    them, unless we know not only what our function does, but also what all the other
    code in the program that interacts with the global variable does.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在与它们交互时很难确定函数的值，除非我们不仅知道我们的函数做什么，而且知道所有与全局变量交互的程序中的其他代码做什么。
- en: Additionally, code that we add later to the program, might start modifying the
    global variable in a way that we did not expect in our function, breaking the
    functionality of our function without ever modifying the function itself. This
    makes it extremely difficult to modify, maintain, and evolve programs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们后来添加到程序中的代码可能会以我们没有预料到的方式修改全局变量，即使没有修改函数本身，也可能破坏函数的功能。这使得修改、维护和演进程序变得极其困难。
- en: The solution to this problem is to use the `const` qualifier so that no code
    can change the variable, and we can treat it as a value that never changes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是使用`const`限定符，这样就没有代码可以更改变量，我们可以将其视为一个永远不会改变的值。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Always use the `const` qualifier with global variables whenever possible.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，始终使用`const`限定符与全局变量一起使用。
- en: Try to avoid using mutable global variables.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量避免使用可变全局变量。
- en: It is a good practice to use global `const` variables instead of using values
    directly in the code. They allow you to give a name and a meaning to the value,
    without any of the risks that come with mutable global variables.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局`const`变量而不是直接在代码中使用值是一种良好的实践。它们允许你给值赋予一个名称和意义，而不承担可变全局变量带来的任何风险。
- en: Working with Variable Objects
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与变量对象一起工作
- en: It is important to understand the relationship between variables, objects, and
    the lifetime of objects in C++ to write programs correctly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，理解变量、对象及其生命周期之间的关系对于正确编写程序至关重要。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: An object is a piece of data in the program's memory.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是程序内存中的一块数据。
- en: A variable is a name we give to an object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是我们赋予对象的名称。
- en: There is a distinction in C++ between the scope of a variable and the lifetime
    of the object it refers to. The scope of a variable is the part of the program
    where the variable can be used.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，变量作用域和它所引用对象的生存期之间有一个区别。变量作用域是程序中变量可以使用的部分。
- en: The lifetime of an object, on the contrary, is the time during execution wherein
    the object is valid to access.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，对象的生存期是在执行期间对象可以访问的时间。
- en: 'Let''s examine the following program to understand the lifetime of an object:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下程序来了解对象的生存期：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Figure 2.1: Lifetime of an object](img/C11557_02_02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：对象的生存期](img/C11557_02_02.jpg)'
- en: 'Figure 2.1: Lifetime of an object'
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.1：对象的生存期
- en: The lifetime of a variable starts when it is initialized and ends when the containing
    block ends. Even if we have a pointer or reference to a variable, we should access
    it only if it's still valid. `fooPointer` is pointing to a variable which is no
    longer valid, so it should not be used!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的生存期从初始化开始，到包含它的块结束时结束。即使我们有变量或引用的指针，我们也应该只在它仍然有效时访问它。`fooPointer`指向一个不再有效的变量，因此不应该使用它！
- en: When we declare a local variable in the scope of a function, the compiler automatically
    creates an object when the function execution reaches the variable declaration;
    the variable refers to that object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在函数的作用域内声明一个局部变量时，编译器会在函数执行到达变量声明时自动创建一个对象；变量引用那个对象。
- en: When we declare a global variable instead, we are declaring it in a scope that
    does not have a clear duration – it is valid for the complete duration of the
    program. Because of this, the compiler creates the object when the program starts
    before any function is executed – even the `main()` function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明一个全局变量时，我们实际上是在一个没有明确持续时间的范围内声明它——它在整个程序运行期间都是有效的。正因为如此，编译器在执行任何函数之前（甚至包括`main()`函数）在程序开始时创建对象。
- en: The compiler also takes care of terminating the object's lifetime when the execution
    exits from the scope in which the variable has been declared, or when the program
    terminates in the case of a global variable. The termination of the lifetime of
    an object is usually called **destruction**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行退出变量声明的范围，或者全局变量在程序终止的情况下，编译器也会负责终止对象的生存期。对象的生存期终止通常被称为**销毁**。
- en: Variables declared in a scope block, either local or global, are called **automatic
    variables**, because the compiler takes care of initializing and terminating the
    lifetime of the object associated with the variables.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在作用域块中声明的变量，无论是局部还是全局，都称为**自动变量**，因为编译器负责初始化和终止与变量相关联的对象的生存期。
- en: 'Let''s look at an example of a local variable:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个局部变量的例子：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, the variable `a` is a local variable of type `int`. The compiler
    automatically initializes the object it refers to with what is called its **default
    initialization** when the execution reaches that statement, and the object will
    be destroyed at the end of the function, again, automatically.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，变量`a`是一个`int`类型的局部变量。当执行到达该语句时，编译器会自动使用所谓的**默认初始化**来初始化它所引用的对象，并且对象将在函数结束时被销毁，同样也是自动的。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The default initialization of basic types, such as integers, is doing nothing
    for us. This means that the variable `a` will have an unspecified value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本类型，如整数，默认初始化对我们来说不做任何事情。这意味着变量`a`将具有一个未指定的值。
- en: 'If multiple local variables are defined, the initialization of the objects
    happens in the order of declaration:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了多个局部变量，对象的初始化顺序是按照声明的顺序进行的：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Variable `a` is initialized before `b`. Since variable `b` was initialized after
    `a`, its object is destroyed before the one `a` refers to.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`a`在`b`之前初始化。由于变量`b`是在`a`之后初始化的，所以它的对象在`a`所引用的对象之前被销毁。
- en: 'If the execution never reaches the declaration, the variable is not initialized.
    If the variable is not initialized, it is also not destroyed:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行从未到达声明处，变量将不会被初始化。如果变量没有被初始化，它也不会被销毁：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, the variable `a` is never default initialized, and thus never destroyed.
    This is similar for global variables:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，变量 `a` 永远没有被默认初始化，因此永远不会销毁。这同样适用于全局变量：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Variable `a` is initialized before the `main()` function is called and is destroyed
    after we return the value from the `main()` function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `a` 在调用 `main()` 函数之前初始化，并在我们从 `main()` 函数返回值之后销毁。
- en: 'Exercise 4: Using Local and Global Variables in a Fibonacci Sequence'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习4：在斐波那契数列中使用局部和全局变量
- en: We want to write a function that returns the 10th number in a Fibonacci sequence.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要编写一个函数，该函数返回斐波那契数列中的第10个数。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The *nth* Fibonacci number is defined as the sum of the *n-1th* and the *n-2th*,
    with the first number in the sequence being 0 and the second being 1.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第 *n* 个斐波那契数定义为第 *n-1* 个和第 *n-2* 个的和，序列中的第一个数是0，第二个数是1。
- en: 'Example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: 10th Fibonacci number = 8th Fibonacci number + 9th Fibonacci number
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第10个斐波那契数 = 第8个斐波那契数 + 第9个斐波那契数
- en: We want to use the best practice of giving a name and a meaning to values, so
    instead of using 10 in the code, we are going to define a `const` global variable,
    named `POSITION`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用最佳实践为值命名并赋予其意义，因此我们不会在代码中使用10，而是将定义一个名为 `POSITION` 的全局 `const` 变量。
- en: 'We will also use two local variables in the function to remember the `n-1th`
    and the `n-2th` number:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在函数中使用两个局部变量来记住 `n-1th` 和 `n-2th` 的数字：
- en: 'Write the program and include the following constant global variable after
    the header file:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写程序并在头文件之后包含以下全局常量变量：
- en: '[PRE14]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, create a function named `print_tenth_fibonacci()` with the return type
    as `void`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `print_tenth_fibonacci()` 的函数，其返回类型为 `void`：
- en: '[PRE15]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Within the function, include three local variables, named `n_1`, `n_2`, and
    `current` of type `int`, as shown here:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，包含三个局部变量，分别命名为 `n_1`、`n_2` 和 `current`，类型为 `int`，如下所示：
- en: '[PRE16]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s create a `for` loop to generate the remaining Fibonacci numbers until
    we reach the 10th, using the global variables we defined previously as starting
    and ending indices:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 `for` 循环，使用我们之前定义的全局变量作为起始和结束索引，生成剩余的斐波那契数，直到达到第10个：
- en: '[PRE17]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, after the previous `for` loop, add the following print statement to print
    the last value stored in the `current` variable:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在之前的 `for` 循环之后，添加以下打印语句以打印存储在 `current` 变量中的最后一个值：
- en: '[PRE18]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `main()` function, call `print_tenth_fibonacci()` and print the value
    of the 10th element of the Fibonacci sequence:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，调用 `print_tenth_fibonacci()` 并打印斐波那契数列的第10个元素的值：
- en: '[PRE19]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's understand the variable data flow of this exercise. First, the `n_1` variable
    is initialized, then `n_2` is initialized, and right after that, `current` is
    initialized. And then, `current` is destroyed, `n_2` is destroyed, and finally,
    `n_1` is destroyed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这个练习的变量数据流。首先，初始化 `n_1` 变量，然后初始化 `n_2`，紧接着初始化 `current`。然后，销毁 `current`，销毁
    `n_2`，最后销毁 `n_1`。
- en: '`i` is also an automatic variable in the scope that''s created by the `for`
    loop, so it is destroyed at the end of the `for` loop scope.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`i` 也是由 `for` 循环创建的作用域中的自动变量，因此它在 `for` 循环作用域结束时销毁。'
- en: 'For each combination of `cond1` and `cond2`, identify when initialization and
    destruction occurs in the following program:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `cond1` 和 `cond2` 的每个组合，确定以下程序中初始化和销毁发生的时间：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Passing Arguments and Returning Values
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递参数和返回值
- en: In the *Introduction* section, we mentioned that the caller can provide some
    data to the function. This is done by passing arguments to the parameters of the
    function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *简介* 部分，我们提到调用者可以向函数提供一些数据。这是通过将参数传递给函数的参数来完成的。
- en: The parameters that a function accept are part of its signature, so we need
    to specify them in every declaration.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受的参数是其签名的一部分，因此我们需要在每个声明中指定它们。
- en: The list of parameters a function can accept is contained in the parentheses
    after the function name. The parameters in the function parentheses are comma-separated,
    composed by a type, and optionally an identifier.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受的参数列表包含在函数名称后面的括号中。函数括号中的参数由逗号分隔，由类型组成，并可选地有一个标识符。
- en: 'For example, a function taking two integer numbers would be declared as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个接受两个整数的函数声明如下：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we wanted to give a name to these parameters, `a` and `b` respectively,
    we would write the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要给这些参数命名，`a` 和 `b` 分别，我们会写如下：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Inside its body, the function can access the identifiers defined in the function
    signature as if they were declared variables. The values of the function parameters
    are decided when the function is called.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在其主体内部，函数可以像声明变量一样访问函数签名中定义的标识符。函数参数的值是在函数调用时确定的。
- en: 'To call a function that takes a parameter, you need to write the name of the
    function, followed by a list of expressions inside a pair of parentheses:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用一个接受参数的函数，你需要写出函数名，然后在一对括号内写上一系列表达式：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we called the `two_ints` function with two arguments: `1` and `2`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们用两个参数`1`和`2`调用了`two_ints`函数。
- en: The arguments used to call the function initialize the parameters that the function
    is expecting. Inside the `two_ints` function, variable `a` will be equal to `1`,
    and `b` will be equal to `2`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数时使用的参数初始化函数期望的参数。在`two_ints`函数中，变量`a`将等于`1`，而`b`将等于`2`。
- en: Each time the function is called, a new set of parameters is initialized from
    the arguments that were used to call the function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每次函数被调用时，都会从用于调用函数的参数中初始化一组新的参数。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '**Parameter**: This is a variable that was defined by a function, and can be
    used to provide data as per the code.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数**：这是一个由函数定义的变量，可以根据代码提供数据。'
- en: '**Argument**: The value the caller wants to bind to the parameters of the function.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数**：调用者想要绑定到函数参数的值。'
- en: 'In the following example, we used two values, but we can also use arbitrary
    expressions as arguments:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用了两个值，但也可以使用任意表达式作为参数：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The order in which the expression is evaluated is not specified!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式评估的顺序没有指定！
- en: This means that when calling `two_ints(1+2, 2+3);`, the compiler might first
    execute `1+2` and then `2+3`, or `2+3` and then `1+2`. This is usually not a problem
    if the expression does not change any state in the program, but it can create
    bugs that are hard to detect when it does. For example, given `int i = 0;`, if
    we call `two_ints(i++, i++)`, we don't know whether the function is going to be
    called with `two_ints(0, 1)` or `two_ints(1, 0)`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在调用`two_ints(1+2, 2+3);`时，编译器可能会首先执行`1+2`然后执行`2+3`，或者先执行`2+3`然后执行`1+2`。如果表达式没有改变程序中的任何状态，这通常不是问题，但如果它确实创建了难以检测的bug，则可能成为问题。例如，给定`int
    i = 0;`，如果我们调用`two_ints(i++, i++)`，我们不知道函数将被调用为`two_ints(0, 1)`还是`two_ints(1,
    0)`。
- en: In general, it's better to declare expressions that change the state of the
    program in their own statements, and call functions with expressions that do not
    modify the program's state.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好在它们自己的语句中声明会改变程序状态的表达式，并使用不修改程序状态的表达式调用函数。
- en: The function parameters can be of any type. As we already saw, a type in C++
    could be a value, a reference, or a pointer. This gives the programmer a few options
    on how to accept parameters from the callers, based on the behavior it wants.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数可以是任何类型。正如我们之前看到的，C++中的类型可以是值、引用或指针。这给程序员提供了一些选择，可以根据期望的行为从调用者那里接受参数。
- en: In the following subsections, we will explore the working mechanism of *Pass
    by value* and *Pass by reference* in more detail.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下子节中，我们将更详细地探讨*按值传递*和*按引用传递*的工作机制。
- en: Pass by Value
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按值传递
- en: When the parameter type of a function is a value type, we say that the function
    is taking an argument by value or the argument is passed by value.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数的参数类型是值类型时，我们说函数是通过值传递参数，或者参数是通过值传递的。
- en: When a parameter is a value type, a new local object is created each time the
    function is called.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数是值类型时，每次函数被调用时都会创建一个新的局部对象。
- en: As we saw with automatic variables, the lifetime of the object lasts until the
    execution does not reach the end of the function's scope.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们通过自动变量看到的，对象的生存期一直持续到执行未达到函数的作用域的末尾。
- en: When the parameter is initialized, a new copy is made from the argument provided
    when invoking the function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数被初始化时，会从调用函数时提供的参数中创建一个新的副本。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to modify a parameter but do not want or do not care about the calling
    code seeing the modification, use *pass by value*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要修改一个参数，但又不想或不在乎调用代码看到修改，请使用*按值传递*。
- en: 'Exercise 5: Calculating Age using Pass by Value Arguments'
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5：使用按值传递参数计算年龄
- en: James wants to write a C++ program to calculate what the age of a person will
    be after five years by providing their current age as an input.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 詹姆斯想编写一个C++程序，通过提供当前年龄作为输入来计算一个人的五年后年龄。
- en: 'To implement such a program, he is going to write a function that takes a person''s
    age by value and computes how old they will be in 5 years, and then prints it
    on the screen:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这样一个程序，他打算编写一个函数，该函数通过值接收一个人的年龄并计算他们将在5年后多大，然后将其打印到屏幕上：
- en: 'Create a function named `byvalue_age_in_5_years`, as illustrated here. Make
    sure that the value in the calling code does not change:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`byvalue_age_in_5_years`的函数，如图所示。确保调用代码中的值不发生变化：
- en: '[PRE25]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, in `main()`, call the function we created in the previous step by passing
    the variable `age` as a value:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`main()`中，通过传递变量`age`作为值来调用我们在上一步创建的函数：
- en: '[PRE26]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'Pass by value should be the default way of accepting arguments: always use
    it unless you have a specific reason not to.'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过值传递应该是接受参数的默认方式：除非你有特定的理由不这样做，否则始终使用它。
- en: 'The reason for this is that it makes the separation between the calling code
    and the called function stricter: the calling code cannot see the changes that
    the called function makes on the parameters.'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原因在于这使调用代码和被调用函数之间的分离更加严格：调用代码无法看到被调用函数对参数所做的更改。
- en: 'Passing parameters by value creates a clear boundary between the calling function
    and the called function, because the parameters are copied:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值传递参数在调用函数和被调用函数之间创建了一个清晰的边界，因为参数是被复制的：
- en: As the calling function, we know that the variables we passed to the functions
    will not be modified by it.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为调用函数，我们知道我们传递给函数的变量不会被它修改。
- en: As the called function, we know that even if we modify the provided parameters,
    there will be no impact on the called function.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为被调用函数，我们知道即使我们修改了提供的参数，也不会对被调用函数产生影响。
- en: This makes it easy to understand the code, because the changes we make to the
    parameters have no impact outside of the function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得代码更容易理解，因为我们对参数所做的更改不会在函数外部产生影响。
- en: Pass by value can be the faster option when taking an argument, especially if
    the memory size of the argument is small (for example, integers, characters, float,
    or small structures).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递参数时，通过值传递可能是更快的选项，特别是如果参数的内存大小较小（例如，整数、字符、浮点数或小型结构）。
- en: We need to remember though that passing by value performs a copy of the argument.
    Sometimes, this can be an expensive operation both in terms of memory and processing
    time, like when copying a container with many elements.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住的是，通过值传递会对参数执行复制操作。有时，这可能在内存和处理时间上都可能是一个昂贵的操作，例如在复制包含许多元素的容器时。
- en: There are some cases where this limitation can be overcome with the `move` semantic
    that was added in C++11\. We will see more of it in *Lesson 3*, *Classes*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，可以通过C++11中添加的`move`语义来克服这种限制。我们将在*第3课*，*类*中看到更多关于它的内容。
- en: Let's look at an alternative to pass by value that has a different set of properties.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一种不同于通过值传递的替代方法，它具有不同的属性集。
- en: Pass by Reference
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用传递
- en: When the parameter type of the function is a reference type, we say that the
    function is taking an argument by reference or the argument is passed by reference.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数的参数类型是引用类型时，我们说函数是通过引用接受参数或参数是通过引用传递的。
- en: We saw earlier that a reference type does not create a new object – it is simply
    a new variable, or name that refers to an object that already exists.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，引用类型不会创建一个新的对象——它只是一个新的变量，或名称，它指向已经存在的对象。
- en: 'When the function that accepts the argument by reference is called, the reference
    is bound to the object used in the argument: the parameter will refer to the given
    object. This means that the function has access to the object the calling code
    provided and can modify it.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过引用接受参数的函数被调用时，引用绑定到用于参数的对象：参数将引用给定的对象。这意味着函数可以访问调用代码提供的对象并对其进行修改。
- en: This is convenient if the goal of the function is to modify an object, but it
    can be more difficult to understand the interaction between the caller and the
    called function in such situations.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数的目标是修改一个对象，这很方便，但在这种情况下，理解调用者和被调用函数之间的交互可能更困难。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Unless the function must modify the variable, always use `const` references,
    as we will see later.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除非函数必须修改变量，否则始终使用`const`引用，正如我们稍后将会看到的。
- en: 'Exercise 6: Calculating Incrementation of Age using Pass by Reference'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习6：使用引用传递计算年龄增加
- en: James would like to write a C++ program which, given anyone's age as input,
    prints `Congratulations!` if their age will be 18 or older in the next 5 years.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 詹姆斯想编写一个C++程序，给定任何人的年龄作为输入，如果他们的年龄在接下来的5年内将达到18岁或以上，则打印`Congratulations!`。
- en: 'Let''s write a function that accepts its parameters by reference:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个接受引用参数的函数：
- en: 'Create a function named `byreference_age_in_5_years()` of type `void`, as illustrated
    here:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`byreference_age_in_5_years()`的`void`类型函数，如图所示：
- en: '[PRE27]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, in `main()`, call the function we created in the previous step by passing
    the variable `age` as a reference:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`main()`中，通过将变量`age`作为引用传递来调用我们在上一步创建的函数：
- en: '[PRE28]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Contrary to passing by value the speed when passing by reference does not change
    when the memory size of the object passed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与按值传递不同，按引用传递的速度不会随着传递的对象的内存大小而改变。
- en: This makes pass by reference the preferred method when copying an object, since
    providing pass by value to the function is expensive, especially if we cannot
    use the `move` semantic that was added in C++11.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在复制对象时，通过引用传递成为首选方法，因为将值传递给函数是昂贵的，尤其是如果我们不能使用在C++11中添加的`move`语义。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to use pass by reference, but you are not modifying the provided
    object, make sure to use `const`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用引用传递，但又没有修改提供的对象，请确保使用`const`。
- en: With C++, we can use `std::cin` to read input from the console executing the
    program.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++，我们可以使用`std::cin`从正在执行的程序的控制台读取输入。
- en: When writing `std::cin >> variable;`, the program will block waiting for some
    user input, and then it will populate `variable` with the value read from the
    input as long as it is a valid value and the program knows how to read it. By
    default, we can assign all the built-in data types and some types defined in the
    standard library, such as `string`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写`std::cin >> variable;`时，程序将阻塞等待用户输入，然后只要它是一个有效的值并且程序知道如何读取它，它就会将读取的输入值填充到`variable`中。默认情况下，我们可以分配所有内置数据类型以及标准库中定义的一些类型，如`string`。
- en: 'Activity 3: Checking Voting Eligibility'
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动三：检查投票资格
- en: 'James is creating a program to print a message on the console screen: "*Congratulations!
    You are eligible to vote in your country*" or "*No worries, just <value> more
    years to go.*" after the user provides their current age as input.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 詹姆斯正在创建一个程序，在用户输入当前年龄后，在控制台屏幕上打印消息：`*Congratulations! You are eligible to vote
    in your country*`或`*No worries, just <value> more years to go.*`。
- en: 'Create a function named `byreference_age_in_5_years(int& age)` and add the
    following code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`byreference_age_in_5_years(int& age)`的函数，并添加以下代码：
- en: '[PRE29]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the `else` block, add the code to calculate the years remaining until they
    can vote:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`else`块中，添加计算他们可以投票剩余年数的代码：
- en: '[PRE30]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In `main()`, add the input stream, as illustrated, to accept the input from
    the user. Pass the value as a reference in the previous function:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`中，添加如图所示的输入流，以接受用户输入。在上一个函数中将值作为引用传递：
- en: '[PRE31]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The solution for this activity can be found on page 284.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第284页找到。
- en: Working with const References or r-value References
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用const引用或r-value引用
- en: A temporary object cannot be passed as an argument for a reference parameter.
    To accept temporary parameters, we need to use `const` references or *r-value*
    references. The r-value references are references that are identified by two ampersands,
    `&&`, and can only refer to temporary values. We will look at them in more detail
    in *Lesson 4*, *Generic Programming and Templates*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 临时对象不能作为引用参数的参数传递。为了接受临时参数，我们需要使用`const`引用或*r-value*引用。r-value引用是由两个井号`&&`标识的引用，只能引用临时值。我们将在*第4课*，*泛型编程和模板*中更详细地了解它们。
- en: We need to remember that a pointer is a value that represents the location of
    an object.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，指针是一个表示对象位置的值。
- en: Being a value, it means that when we are accepting a parameter as a pointer,
    the pointer itself is passed as a value.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 作为值，这意味着当我们接受参数作为指针时，指针本身作为值传递。
- en: This means that the modification of the pointer inside the function is not going
    to be visible to the caller.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着函数内部指针的修改将不会对调用者可见。
- en: 'But if we are modifying the object the pointer points to, then the original
    object is going to be modified:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们正在修改指针指向的对象，那么原始对象将被修改：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Most of the time, we can think of passing a pointer as passing a reference,
    with the caveat that you need to be aware that the pointer might be null.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们可以将传递指针视为传递引用，前提是你需要意识到指针可能为空。
- en: 'Accepting a parameter as a pointer is mainly used for three reasons:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数作为指针接受主要用于三个原因：
- en: Traversing the elements of an array, by providing the start pointer and either
    the end pointer or the size of the array.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供起始指针和结束指针或数组的大小来遍历数组的元素。
- en: Optionally modifying a value. This means that the function modifies a value
    if it is provided.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地修改一个值。这意味着如果提供了值，函数将修改该值。
- en: Returning more than a single value. This is often done to set the value of a
    pointer passed as an argument and then return an error code to signal whether
    the operation was performed.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回多个值。这通常是为了设置作为参数传递的指针的值，然后返回一个错误代码来指示操作是否执行。
- en: We will see in *Lesson 4*, *Generic Programming and Templates*, how features
    introduced in C++11 and C++17 allow us to avoid using pointers for some of these
    use cases, eliminating the possibility of some common classes of errors, such
    as dereferencing invalid pointers or accessing unallocated memory.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第4课*，*泛型编程和模板*中看到，C++11和C++17中引入的特性如何使我们能够避免在某些用例中使用指针，消除一些常见错误的可能性，例如取消引用无效指针或访问未分配的内存。
- en: The options of passing by value or passing by reference are applicable to every
    single parameter the function expects, independently.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 按值传递或按引用传递的选项适用于函数期望的每个参数，独立适用。
- en: This means that a function can take some arguments by value and some by reference.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着函数可以按值传递一些参数，按引用传递一些参数。
- en: Returning Values from Functions
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从函数返回值
- en: Up until now, we have seen how to provide values to a function. In this section,
    we will see how a function can provide value back to the caller.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何向函数提供值。在本节中，我们将看到函数如何向调用者返回值。
- en: 'We said earlier that the first part of a function declaration is the type returned
    by the function: this is often referred to as the function''s return type.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，函数声明的第一部分是函数返回的类型：这通常被称为函数的返回类型。
- en: 'All the previous examples used `void` to signal that they were returning nothing.
    Now, it is time to look at an example of a function returning a value:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一个示例都使用了`void`来表示它们没有返回任何内容。现在，是时候看看一个返回值的函数的例子了：
- en: '[PRE33]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The previous function accepts two integers by value as parameters and returns
    an integer.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数通过值接受两个整数作为参数，并返回一个整数。
- en: 'The invocation of the function in the caller code is an expression evaluating
    to an integer. This means that we can use it anywhere that an expression is allowed:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者代码中函数的调用是一个求值为整数的表达式。这意味着我们可以在允许表达式的任何地方使用它：
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A function can return a value by using the `return` keyword, followed by the
    value it wants to return.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过使用`return`关键字并跟随后要返回的值来返回一个值。
- en: 'The function can use the `return` keyword several times inside its body, and
    each time the execution reaches the `return` keyword, the program will stop executing
    the function and go back to the caller, with the value returned by the function,
    if any. Let''s look at the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以在其体内多次使用`return`关键字，每次执行到达`return`关键字时，程序将停止执行函数并返回到调用者，如果有的话，返回函数的值。让我们看看以下代码：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A function also returns to the caller if it reaches the end of its body.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数到达其体的末尾，它也会返回给调用者。
- en: This is what we did in the earlier examples since we did not use the `return`
    keyword.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们之前在示例中所做的，因为我们没有使用`return`关键字。
- en: 'Not explicitly returning can be okay if a function has a `void` return type.
    However, it will give unexpected results if the function is expected to return
    a value: the returned type will have an unspecified value and the program will
    not be correct.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数具有`void`返回类型，则不显式返回可能是可以的。然而，如果函数预期要返回一个值，它将给出意外的结果：返回的类型将具有一个未指定的值，程序将不会正确。
- en: Be sure to enable the warning, as it will save you a lot of debugging time.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要启用这个警告，因为它会为你节省大量的调试时间。
- en: Note
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: It is surprising, but every major compiler allows the compiling of functions,
    which declare a return type other than void, but don't return a value.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这很令人惊讶，但每个主要的编译器都允许编译声明了除`void`以外的返回类型的函数，但并没有返回值。
- en: This is easy to spot in simple functions, but it is much harder in complex ones
    with lots of branches.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的函数中很容易发现这一点，但在具有许多分支的复杂函数中则要困难得多。
- en: Every compiler supports options to warn you if a function returns without providing
    a value.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每个编译器都支持选项来警告你如果函数没有提供值就返回。
- en: 'Let''s look at an example of a function returning an integer:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个返回整数的函数示例：
- en: '[PRE36]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As we said earlier, a function can use the `return` statement several times
    inside its body, as shown in the following example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，一个函数可以在其体内多次使用`return`语句，如下面的示例所示：
- en: '[PRE37]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We always return a value that's independent of the values of the arguments.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是返回一个与参数值无关的值。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: It is a good practice to return as early as possible in an **algorithm**.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法中尽早返回是一个好的实践。
- en: The reason for this is that as you follow the logic of the code, especially
    when there are many conditionals, a `return` statement tells you when that execution
    path is finished, allowing you to ignore what happens in the remaining part of
    the function.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于，当你遵循代码的逻辑时，尤其是在有许多条件的情况下，一个`return`语句告诉你哪个执行路径已经完成，这允许你忽略函数剩余部分发生的事情。
- en: If you only return at the end of the function, you always have to look at the
    full code of the function.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只在函数的末尾返回，你总是必须查看函数的完整代码。
- en: Since a function can be declared to return any type, we have to decide whether
    to return a value or a reference.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数可以声明为返回任何类型，我们必须决定是返回值还是引用。
- en: Returning by Value
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按值返回
- en: A function whose return type is a value type is said to return by value.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型为值类型的函数被称为按值返回。
- en: When a function that returns by value reaches a `return` statement, the program
    creates a new object, which is initialized from the value of the expression in
    the return statement.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个按值返回的函数到达`return`语句时，程序会创建一个新的对象，该对象从`return`语句中的表达式值初始化。
- en: In the previous function, `sum`, when the code reaches the stage of returning
    `a + b`, a new integer is created, with the value equal to the sum of `a` and
    `b`, and is returned.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数`sum`中，当代码达到返回`a + b`的阶段时，会创建一个新的整数，其值等于`a`和`b`的和，然后返回。
- en: On the side of the caller, `int a = sum(1,2);`, a new temporary automatic object
    is created and is initialized from the value returned by the function (the integer
    that was created from the sum of `a` and `b`).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用者的方面，`int a = sum(1,2);`，会创建一个新的临时自动对象，并从函数返回的值（从`a`和`b`的和创建的整数）初始化。
- en: This object is called **temporary** because its lifetime is valid only while
    the full-expression in which it is created is executed. We will see in the *Returning
    by Reference* section, what this means and why this is important.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象被称为**临时对象**，因为它的生存期仅在创建它的完整表达式执行期间有效。我们将在*按引用返回*部分看到这意味着什么以及为什么这很重要。
- en: The calling code can then use the returned temporary value in another expression
    or assign it to a value.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 调用代码然后可以使用返回的临时值在另一个表达式中使用，或者将其赋值给一个值。
- en: Add the end of the full expression, since the lifetime of the temporary object
    is over, it is destroyed.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在完整表达式的末尾添加，因为临时对象的生存期已经结束，它将被销毁。
- en: In this explanation, we mentioned that objects are initialized several times
    while returning a value. This is not a performance concern as C++ allows compilers
    to optimize all these initializations, and often initialization happens only once.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解释中，我们提到在返回值时对象会被初始化多次。这不是一个性能问题，因为C++允许编译器优化所有这些初始化，并且初始化通常只发生一次。
- en: Note
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: It is preferable to return by value as it's often easier to understand, easier
    to use, and as fast as returning by reference.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 按值返回更可取，因为它通常更容易理解，更容易使用，并且与按引用返回一样快。
- en: How can returning by value be so fast? C++11 introduced the `move` semantic,
    which allows moving instead of copying the return types when they support the
    `move` operation. We'll see how in *Lesson 3*, *Classes*. Even before C++11, all
    mainstream compilers implemented **return value optimization** (**RVO**) and **named
    return value optimization** (**NRVO**), where the return value of a function is
    constructed directly in the variable into which they would have been copied to
    when returned. In C++17, this optimization, also called **copy elision**, became
    mandatory.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 按值返回为什么这么快？C++11引入了`move`语义，允许在支持`move`操作时移动而不是复制返回类型。我们将在第3课，*类*中看到这一点。甚至在C++11之前，所有主流编译器都实现了**返回值优化**（**RVO**）和**命名返回值优化**（**NRVO**），其中函数的返回值直接在它们返回时会被复制的变量中构造。在C++17中，这种优化也被称为**复制省略**，成为强制要求。
- en: Returning by Reference
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按引用返回
- en: A function whose return type is a reference is said to return by reference.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型为引用的函数被称为按引用返回。
- en: When a function returning a reference reaches a `return` statement, a new reference
    is initialized from the expression that's used in the `return` statement.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回引用的函数到达一个`return`语句时，一个新的引用将从`return`语句中使用的表达式初始化。
- en: In the caller, the function call expression is **substituted** by the returned
    reference.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用者中，函数调用表达式被**替换**为返回的引用。
- en: 'However, in this situation, we need to also be aware of the lifetime of the
    object the reference is referring to. Let''s look at an example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，我们还需要注意所引用的对象的生存期。让我们看一个例子：
- en: '[PRE38]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First, we need to note that this function already has a caveat. The `max` function
    is returning by value, and it did not make a difference if we returned `a` or
    `b` when they were equal.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要注意这个函数已经有一个警告。`max`函数是通过值返回的，当它们相等时，返回`a`或`b`没有区别。
- en: In this function, instead, when `a == b` we are returning `b`, this means that
    the code calling this function needs to be aware of this distinction. In the case
    where a function returns a non-`const` reference it might modify the object referred
    to by the returned reference, and whether `a` or `b` is returned might make a
    difference.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，相反，当`a == b`时，我们返回`b`，这意味着调用此函数的代码需要意识到这种区别。在函数返回非`const`引用时，它可能会修改由返回引用所引用的对象，而返回`a`或`b`可能会有所不同。
- en: We are already seeing how references can make our code harder to understand.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了引用如何使我们的代码更难以理解。
- en: 'Let''s look at the function we used:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们使用的函数：
- en: '[PRE39]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This program has an error! The reason is that `1` and `2` are temporary values,
    and as we explained before, a temporary value is alive until the end of the full
    expression containing it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有错误！原因是`1`和`2`是临时值，正如我们之前解释的，临时值的生命周期直到包含它的完整表达式结束。
- en: 'To better understand what is meant by "*the end of the full expression containing
    it*", let''s look at the code we have in the preceding code block: `int& a = max(1,2);`.
    There are four expressions in this piece of code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解“*包含它的完整表达式的结束*”的含义，让我们看看前面代码块中的代码：`int& a = max(1,2);`。这段代码中有四个表达式：
- en: '`1` is an integer literal, which still counts as an expression'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`是一个整数字面量，它仍然算作一个表达式。'
- en: '`2` is an integer literal, similar to `1`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`是一个整数字面量，类似于`1`。'
- en: '`max(expression1, expression2)` is a function call expression'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max(expression1, expression2)`是一个函数调用表达式。'
- en: '`a = expression3` is an assignment expression'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a = expression3`是一个赋值表达式。'
- en: All of this happens in the declaration statement of variable `a`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在变量`a`的声明语句中发生。
- en: The third point covers the function call expression, while containing the full
    expression is covered in the following point.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 第三点涵盖了函数调用表达式，而包含完整表达式的内容将在下一点中介绍。
- en: This means that lifetimes `1` and `2` will stop at the end of the assignment.
    But we got a reference to one of them! And we are using it!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着生命周期`1`和`2`将在赋值结束时停止。但我们得到了其中一个的引用！并且我们正在使用它！
- en: Accessing an object whose lifetime is terminated is prohibited by C++, and this
    will result in an invalid program.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: C++禁止访问生命周期已结束的对象，这将导致程序无效。
- en: In a more complex example, such as `int a = max(1,2) + max(3,4);`, the temporary
    objects returned by the `max` functions will be valid until the end of the assignment,
    but no longer.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的例子中，例如`int a = max(1,2) + max(3,4);`，`max`函数返回的临时对象将有效直到赋值结束，但之后不再有效。
- en: Here, we are using the two references to `sum` them, and then we assign the
    result as a value. If we assigned the result to a reference, as in the following
    example, `int& a = max(1,2) + max(3,4);`, instead, the program would have been
    wrong.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用两个引用来求和，然后将结果作为值赋值。如果我们像以下示例中那样将结果赋给一个引用，即`int& a = max(1,2) + max(3,4);`，程序就会出错。
- en: This sounds confusing, but it is important to understand as it can be a source
    of hard-to-debug problems if we use a temporary object after the full expression
    in which it's created has finished executing.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很令人困惑，但理解这一点很重要，因为它可能是我们在创建它的完整表达式执行完毕后使用临时对象时难以调试的问题的来源。
- en: 'Let''s look at another common mistake in functions returning references:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看函数返回引用时常见的另一个错误：
- en: '[PRE40]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We created a local, automatic object in the function body and then we returned
    a reference to it.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数体内创建了一个局部自动对象，然后返回了对它的引用。
- en: In the previous section, we saw that local objects' lifetimes end at the end
    of the function. This means that we are returning a reference to an object whose
    lifetime will always be terminated.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到局部对象的生存期在函数结束时结束。这意味着我们正在返回一个引用到对象的引用，其生存期将始终被终止。
- en: Earlier, we mentioned the similarities between passing arguments by reference
    and passing arguments by pointers.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到了按引用传递参数和按指针传递参数之间的相似性。
- en: 'This similarity persists when returning pointers: the object pointed to by
    a pointer needs to be alive when the pointer is later **dereferenced**.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回指针时，这种相似性仍然存在：指针指向的对象在指针稍后**解引用**时必须存在。
- en: So far, we have covered examples of mistakes while returning by reference. How
    can references be used correctly as return types to functions?
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了按引用返回时的错误示例。如何正确地将引用用作函数的返回类型？
- en: 'The important part of using references correctly as return values is to make
    sure that the object outlives the reference: the object must always be alive –
    at least until there is a reference to it.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用引用作为返回值的重要部分是确保对象比引用存在的时间更长：对象必须始终存活——至少直到有引用指向它。
- en: 'A common example is accessing a part of an object, for example, using an `std::array`,
    which is a safe option compared to the built-in array:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的例子是访问对象的一部分，例如，使用 `std::array`，与内置数组相比，这是一个更安全的选项：
- en: '[PRE41]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The calling code would look as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 调用代码如下：
- en: '[PRE42]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this example, we are returning a reference to an element inside an array,
    and the array remains alive longer than the reference.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在返回数组内部元素的引用，而数组比引用存在的时间更长。
- en: 'The following are guidelines for using return by reference correctly:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些正确使用按引用返回的指南：
- en: Never return a reference to a local variable (or a part of it)
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要返回局部变量（或其一部分）的引用。
- en: Never return a reference to a parameter accepted by value (or a part of it)
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要返回一个按值接收的参数（或其一部分）的引用。
- en: When returning a reference that was received as a parameter, the argument passed
    to the function must live longer than the returned reference.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回作为参数接收的引用时，传递给函数的参数必须比返回的引用存活的时间更长。
- en: Apply the previous rule, even when you are returning a reference to a part of
    the object (for example, an element of an array).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 即使返回对象的一部分（例如，数组的一个元素）的引用，也要应用之前的规则。
- en: 'Activity 4: Using Pass by Reference and Pass by Value'
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 4：使用按引用传递和按值传递
- en: 'In this activity, we are going to see the different trade-offs that can be
    made when writing a function, depending on the parameters the function accepts:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将看到在编写函数时，根据函数接受的参数可以做出不同的权衡：
- en: Write a function that takes two numbers and returns the sum. Should it take
    the arguments by value or reference? Should it return by value or by reference?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数接受两个数字并返回它们的和。它应该通过值还是引用接收参数？它应该按值还是按引用返回？
- en: After that, write a function that takes two `std::arrays` of ten integers and
    an index (guaranteed to be less than 10) and returns the greater of the two elements
    to the given index in the two arrays.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，编写一个函数，该函数接受两个包含十个整数的 `std::arrays` 和一个索引（保证小于10），并将两个数组中给定索引处的较大元素返回。
- en: The calling function should then modify the element. Should it take the arguments
    by value or reference? Should it return by value or by reference? What happens
    if the values are the same?
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用函数应该随后修改该元素。它应该通过值还是引用接收参数？它应该按值还是按引用返回？如果值相同会发生什么？
- en: Take the arrays by reference and return by reference because we are saying that
    the calling function is supposed to modify the element. Take the index by value
    since there is no reason to use references.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用接收数组并按引用返回，因为我们正在说调用函数应该修改元素。由于没有理由使用引用，所以按值接收索引。
- en: If the values are the same, the element from the first array is returned.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值相同，则返回第一个数组中的元素。
- en: Note
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at page 285.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第285页找到。
- en: Const Parameters and Default Arguments
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量参数和默认参数
- en: In the previous chapter, we saw how and when to use references in function parameters
    and return types. C++ has an additional qualifier, the `const` qualifier, which
    can be used independently from the *ref-ness* (whether the type is a reference
    or not) of the type.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何在函数参数和返回类型中使用引用，以及何时使用引用。C++还有一个额外的限定符，即 `const` 限定符，它可以独立于类型的
    *ref-ness*（类型是否为引用）使用。
- en: Let's see how `const` is used in the various scenarios we investigated when
    looking at how functions can accept parameters.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在查看函数如何接受参数时，我们调查的各种场景中`const`是如何使用的。
- en: Passing by const Value
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过常量值传递
- en: 'In pass by value, the function parameter is a value type: when invoked, the
    argument is copied into the parameter.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在按值传递时，函数参数是一个值类型：当调用时，参数会复制参数。
- en: This means that regardless of whether `const` is used in the parameter or not,
    the calling code cannot see the difference.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着无论`const`是否在参数中使用，调用代码都无法看到区别。
- en: The only reason to use `const` in the function signature is to document to the
    implementation that it cannot modify such a value.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数签名中使用`const`的唯一原因是为了向实现者说明它不能修改这样的值。
- en: This is not commonly done, as the biggest value of a function signature is for
    the caller to understand the contract of calling the function. Because of this,
    it is rare to see `int max(const int, const int)`, even if the function does not
    modify the parameters.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常不是常见的做法，因为函数签名最大的价值在于让调用者理解调用函数的约定。正因为如此，即使函数不修改参数，也很少看到`int max(const int,
    const int)`这样的用法。
- en: 'There is an exception, though: when the function accepts a `pointer`.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个例外：当函数接受一个`pointer`时。
- en: In such cases, the function wants to make sure that it is not assigning a new
    value to the pointer. The pointer acts similar to a reference here, since it cannot
    be bound to a new object, but provides nullability.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，函数想要确保它没有将新值赋给指针。在这里，指针的行为类似于引用，因为它不能绑定到新对象，但提供了空值。
- en: An example could be `setValue(int * const)`, a function that takes a `const`
    pointer to an `int`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可以是`setValue(int * const)`，这是一个接受`const`指针到`int`的函数。
- en: The integer is not `const`, so it can be changed, but the pointer is `const`
    and the implementation cannot change it during implementation.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 整数不是`const`，因此它可以被改变，但指针是`const`的，实现者不能在实现过程中改变它。
- en: Passing by const Reference
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过常量引用传递
- en: Const is extremely important in pass by reference, and any time you use a reference
    in the parameters of a function, you should also add `const` to it (if the function
    is not designed to modify it).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过引用传递时，`const`非常重要，每次你在函数的参数中使用引用时，都应该给它添加`const`（如果函数不是设计用来修改它的）。
- en: The reason for this is that a reference allows you to modify the provided object
    freely.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于引用允许你自由地修改提供的对象。
- en: It is error-prone, since the function might modify an object the caller does
    not expect to be modified by mistake, and it is hard to understand as there is
    no clear boundary between the caller and the function, again, because the function
    can modify the state of the caller.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有风险的，因为函数可能会错误地修改调用者不期望修改的对象，而且由于调用者和函数之间没有明确的边界，这也很难以理解。
- en: '`const` instead fixes the problem, since a function cannot modify an object
    through a `const` reference.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`而不是解决这个问题，因为函数不能通过`const`引用修改对象。'
- en: This allows the function to use reference parameters without some of the drawbacks
    of using references.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许函数使用引用参数，而不必承受使用引用的一些缺点。
- en: The function should remove the `const` from a reference, but only if it is intended
    to modify the provided object, otherwise every reference should be `const`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应该从引用中移除`const`，但仅当它打算修改提供的对象时，否则每个引用都应该`const`。
- en: Another advantage of `const` reference parameters is that temporary objects
    can be used as arguments for them.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`引用参数的另一个优点是，临时对象可以用作它们的参数。'
- en: Returning by const Value
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过常量值返回
- en: There is no widespread reason to return by `const` value since the calling code
    often assigns the value to a variable, in which case the `const`-ness of the variables
    is going to be the deciding factor, or passes the value to a next expression,
    and it is rare for an expression to expect a `const` value.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 没有广泛的原因通过常量值返回，因为调用代码通常将值赋给一个变量，在这种情况下，变量的`const`属性将是决定因素，或者将值传递给下一个表达式，而表达式期望`const`值的情况很少。
- en: Returning by `const` value also inhibits the `move` semantic of C++11, thus
    reducing performance.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`const`值返回也抑制了C++11的`move`语义，从而降低了性能。
- en: Returning by const Reference
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过常量引用返回
- en: A function should always return by `const` reference when the returned reference
    is meant to only be read and not be modified by the calling code.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应该始终通过`const`引用返回，当返回的引用仅用于读取而不被调用代码修改时。
- en: 'The same concept we applied to object lifetimes when returning references to
    them also apply to `const`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用于返回对象引用时对象生命周期的相同概念也适用于`const`：
- en: When returning a reference accepted as a parameter, if the parameter is a `const`
    reference, the returned reference must be `const` as well
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当返回作为参数接受的引用时，如果参数是`const`引用，则返回的引用也必须是`const`。
- en: When returning a reference to a part of an object accepted as the `const` reference
    parameter, the returned reference must be `const` as well
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当返回作为`const`引用参数接受的对象的一部分的引用时，返回的引用也必须是`const`。
- en: A parameter accepted as a reference should be returned as a `const` reference
    if the caller is not expected to modify it.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用者不期望修改它，则应将作为引用接受的参数返回为`const`引用。
- en: Sometimes, the compilation fails, stating that the code is trying to modify
    an object that is a `const` reference. Unless the function is meant to modify
    the object, the solution is not to remove `const` from the reference in the parameter.
    Instead, look for why the operation that you are trying to perform does not work
    with `const`, and what the possible alternatives are.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，编译会失败，指出代码正在尝试修改一个`const`引用的对象。除非函数的目的是修改对象，否则解决方案不是从参数中的引用中移除`const`，而是寻找为什么你试图执行的操作不与`const`一起工作，以及可能的替代方案。
- en: '`const` is not about the implementation, it is about the meaning of the function.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`不是关于实现的，而是关于函数的意义。'
- en: When you write the function signature, you should decide whether to use `const`,
    as the implementation will have to find a way to respect that.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写函数签名时，你应该决定是否使用`const`，因为实现将必须找到一种方法来尊重这一点。
- en: 'For example:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE43]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This should clearly take a reference to the array since its purpose is to modify
    the array.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该清楚地引用数组，因为它的目的是修改数组。
- en: 'On the other hand, we can use the following:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以使用以下方法：
- en: '[PRE44]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This tells us that we are only looking into the array – we are not changing
    it, so we should use `const`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们我们只是在查看数组——我们并没有改变它，所以我们应该使用`const`。
- en: Note
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: It is a best practice to use `const` as much as possible, as it allows the compiler
    to make sure that we are not modifying objects that we do not want to modify.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能使用`const`是一个最佳实践，因为它允许编译器确保我们不会修改我们不希望修改的对象。
- en: This can help to prevent bugs.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以帮助防止错误。
- en: 'It also helps to keep another best practice in mind: never use the same variable
    to represent different concepts. Since the variable cannot be changed, it is less
    natural to reuse it instead of creating a new one.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这也有助于记住另一个最佳实践：永远不要使用同一个变量来表示不同的概念。由于变量不能被改变，因此重新使用它而不是创建一个新的变量不太自然。
- en: Default Arguments
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认参数
- en: Another feature C++ provides to make life easier for the caller when it comes
    to calling functions are default arguments.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供的一个功能，使调用者在调用函数时更容易，是默认参数。
- en: 'Default arguments are added to a function declaration. The syntax is to add
    an `=` sign and supply the value of the default argument after the identifier
    of the parameter of the function. An example of this would be:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数被添加到函数声明中。语法是在参数标识符之后添加一个`=`符号并提供默认参数的值。一个例子将是：
- en: '[PRE45]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The caller of the function can call `multiply` either with `1` or `2` arguments:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的调用者可以带有`1`或`2`个参数调用`multiply`：
- en: '[PRE46]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When an argument with a default value is omitted, the function uses the default
    value instead. This is extremely convenient if there are functions with sensible
    defaults that callers mostly do not want to modify, except in specific cases.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了具有默认值的参数，则函数将使用默认值。如果调用者大多数情况下都不想修改具有合理默认值的函数，除非在特定情况下，这非常方便。
- en: 'Imagine a function that returns the first word of a string:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个返回字符串第一个单词的函数：
- en: '`char const * firstWord(char const * string, char separator = '' '').`'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`char const * firstWord(char const * string, char separator = '' '').`'
- en: Most of the time, a word is separated by a whitespace character, but a function
    can decide whether or not it should use a different separator. The fact that a
    function offers the possibility to provide a separator is not forcing most callers,
    which simply want to use the space, to specify it.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，一个单词由空白字符分隔，但函数可以决定是否使用不同的分隔符。函数提供提供分隔符的可能性并不是强迫大多数调用者，他们只想使用空格，来指定它。
- en: It is a best practice to set the default arguments in the function signature
    declaration, and not declare them in the definition.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数签名声明中设置默认参数是一种最佳实践，而不是在定义中声明它们。
- en: Namespaces
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: One of the goals of functions is to better organize our code. To do so, it is
    important to give meaningful names to them.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的一个目标是为了更好地组织我们的代码。要做到这一点，给它们赋予有意义的名称是很重要的。
- en: For example, in package management software, there might be a function called
    `sort` for sorting packages. As you can see, the name is the same as the function
    that would sort a list of numbers.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在包管理软件中，可能会有一个名为 `sort` 的函数用于排序包。正如你所看到的，名称与用于排序数字列表的函数名称相同。
- en: 'C++ has a feature that allows you to avoid these kinds of problems and groups
    names together: **namespaces**.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 有一个功能可以帮助你避免这类问题并将名称分组：**命名空间**。
- en: A namespace starts a scope in which all the names declared inside are part of
    the namespace.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间开始了一个作用域，其中声明的所有名称都是命名空间的一部分。
- en: 'To create a namespace, we use the `namespace` keyword, followed by the identifier
    and then the code block:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个命名空间，我们使用 `namespace` 关键字，后跟标识符，然后是代码块：
- en: '[PRE47]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: To access an identifier inside a namespace, we prepend the name of the namespace
    to the name of the function.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问命名空间中的标识符，我们在函数名称前加上命名空间名称。
- en: 'Namespaces can be nested as well. Simply use the same declaration as before
    inside the namespace:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间也可以嵌套。只需在命名空间内使用之前的相同声明即可：
- en: '[PRE48]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To access an identifier inside a namespace, you prepend the name of the identifier
    with the name of the namespace in which it is declared, followed by `::`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问命名空间中的标识符，你需要在标识符名称前加上声明它的命名空间名称，然后跟 `::`。
- en: You might have noticed that, before we were using `std::cout`. This is because
    the C++ standard library defines the `std` namespace and we were accessing the
    variable named `cout`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在我们使用 `std::cout` 之前。这是因为 C++ 标准库定义了 `std` 命名空间，我们正在访问名为 `cout` 的变量。
- en: To access an identifier inside multiple namespaces, you can prepend the list
    of all the namespaces separated by `::` – `parent::child::some_identifier`. We
    can access names in the global scope by prepending `::` to the name—`::name_in_global_scope`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问多个命名空间中的标识符，可以在所有命名空间列表前加上 `::` 分隔符 – `parent::child::some_identifier`。我们可以通过在名称前加上
    `::` 来访问全局作用域中的名称—`::name_in_global_scope`。
- en: If we were to only use `cout`, the compiler would have told us that the name
    does not exist in the current scope.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只使用 `cout`，编译器会告诉我们该名称在当前作用域中不存在。
- en: This is because the compiler searches only in the current namespace and the
    parent namespaces to find an identifier by default, so unless we specify the `std`
    namespace, the compiler will not search in it.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器默认只搜索当前命名空间及其父命名空间来查找标识符，所以除非我们指定 `std` 命名空间，否则编译器不会在其中搜索。
- en: C++ helps make this more ergonomic with the help of the `using` declaration.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 通过 `using` 声明帮助使这一过程更加便捷。
- en: The `using` declaration is defined by the `using` keyword, followed by an identifier
    specified with its namespaces.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 声明由 `using` 关键字定义，后跟一个指定了其命名空间的标识符。'
- en: 'For example, `using std::cout;` is a `using` declaration that declares that
    we want to use `cout`. When we want to use all the declarations from a namespace,
    we can write `using namespace namespace_name`;. For example, if we want to use
    every name defined in the `std` namespace, we would write: `using namespace std;`.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`using std::cout;` 是一个 `using` 声明，表示我们想要使用 `cout`。当我们想要使用一个命名空间中的所有声明时，我们可以写
    `using namespace namespace_name;`。例如，如果我们想要使用 `std` 命名空间中定义的所有名称，我们可以写：`using
    namespace std;`。
- en: When a name is declared inside the `using` declaration, the compiler also looks
    for that name when looking for an identifier.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `using` 声明中声明一个名称时，编译器也会在查找标识符时查找该名称。
- en: This means that, in our code, we can use `cout` and the compiler will find `std::cout`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在我们的代码中，我们可以使用 `cout`，编译器会找到 `std::cout`。
- en: A `using` declaration is valid as long as we are in the scope in which it is
    declared.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 声明只要在声明的范围内就是有效的。'
- en: Note
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: To better organize your code and avoid naming conflicts, you should always put
    your code inside a namespace that's specific to either your application or library.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地组织代码并避免命名冲突，你应该始终将你的代码放在一个特定于你的应用程序或库的命名空间内。
- en: Namespaces can also be used to specify that some code is used only by the current
    code.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间还可以用来指定某些代码仅由当前代码使用。
- en: 'Let''s imagine you have a file called `a.cpp` that contains `int default_name
    = 0;` and another file called `b.cpp` with `int default_name = 1;`. When you compile
    the two files and link them together, we get an invalid program: the same variable
    has been declared with two different values, and this violates the **One Definition
    Rule** (**ODR**).'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象你有一个名为`a.cpp`的文件，其中包含`int default_name = 0;`，还有一个名为`b.cpp`的文件，其中包含`int
    default_name = 1;`。当你编译这两个文件并将它们链接在一起时，我们得到一个无效程序：同一个变量被声明为两个不同的值，这违反了**单一定义规则**（**ODR**）。
- en: But you never meant for those to be the same variable. To you, they were some
    variables that you just wanted to use inside your `.cpp` file.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 但你从未打算让这些变量相同。对你来说，它们只是你想要在`.cpp`文件内部使用的变量。
- en: 'To tell that to the compiler, you can use anonymous namespaces: a namespace
    with no identifier.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让编译器知道这一点，你可以使用匿名命名空间：一个没有标识符的命名空间。
- en: All the identifiers created inside it will be private to the *current translation
    unit* (normally the `.cpp` file).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中创建的所有标识符都将属于**当前翻译单元**（通常是`.cpp`文件）的私有。
- en: How can you access an identifier inside an anonymous namespace? You can access
    the identifier directly, without the need to use the namespace name, which does
    not exist, or the `using` declaration.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如何访问匿名命名空间内的标识符？你可以直接访问标识符，无需使用命名空间名称，因为匿名命名空间没有标识符，也不需要使用`using`声明。
- en: Note
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You should only use anonymous namespaces in `.cpp` files.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该只在使用匿名命名空间的情况下在`.cpp`文件中编写代码。
- en: 'Activity 5: Organizing Functions in Namespaces'
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动五：在命名空间中组织函数
- en: 'Write a function to read the name of a car for a lottery in a namespace based
    on numerical input. If the user inputs `1`, they win a Lamborghini, and if the
    user inputs `2`, they win a Porsche:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，根据数值输入在命名空间中读取汽车名称用于抽奖：如果用户输入`1`，他们将赢得一辆兰博基尼；如果用户输入`2`，他们将赢得一辆保时捷：
- en: Define the first namespace as `LamborghiniCar` with an `output()` function that
    will print "`Congratulations! You deserve the Lamborghini.`" when called.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个命名空间定义为`LamborghiniCar`，并定义一个`output()`函数，当被调用时将打印"`Congratulations! You
    deserve the Lamborghini.`"。
- en: Define the second namespace as `PorscheCar` with an `output()` function that
    will print "`Congratulations! You deserve the Porsche.`" when called.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第二个命名空间定义为`PorscheCar`，并定义一个`output()`函数，当被调用时将打印"`Congratulations! You deserve
    the Porsche.`"。
- en: Write a `main` function to read the input of numbers `1` and `2` into a variable
    called `magicNumber`.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`main`函数，将数字`1`和`2`的输入读取到名为`magicNumber`的变量中。
- en: Create an `if-else` loop with the `if` condition calling the first namespace
    with `LamborghiniCar::output()` if the input is `1`. Otherwise, the second namespace
    is called similarly when the input is `2`.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`if-else`循环，如果输入是`1`，则调用第一个命名空间`LamborghiniCar::output()`。否则，当输入是`2`时，类似地调用第二个命名空间。
- en: If neither of these conditions are met, we print a message asking them to enter
    a number between `1` and `2`.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这些条件都不满足，我们打印一条消息，要求他们输入一个介于`1`和`2`之间的数字。
- en: Note
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 285.
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第285页找到。
- en: Function Overloading
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数重载
- en: We saw how C++ allows us to write a function that takes parameters either by
    value or by reference, using `const`, and organizes them in namespaces.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了C++如何允许我们编写一个函数，该函数可以通过值或引用传递参数，使用`const`，并在命名空间中组织它们。
- en: 'There is an additional powerful feature of C++ that allows us to give the same
    name to functions that perform the same conceptual operation on different types:
    **function overloading**.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: C++有一个额外的强大功能，允许我们给在执行相同概念操作的不同类型上的函数赋予相同的名称：**函数重载**。
- en: Function overloading is the ability to declare several functions with the same
    name – that is, if the set of parameters they accept is different.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载是指能够声明具有相同名称的多个函数——也就是说，如果它们接受的参数集不同。
- en: An example of this is the `multiply` function. We can imagine this function
    being defined for integers and floats, or even for vectors and matrices.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个例子是`multiply`函数。我们可以想象这个函数被定义为整数和浮点数，甚至向量矩阵。
- en: If the concept represented by the function is the same, we can provide several
    functions that accept different kinds of parameters.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数所代表的概念相同，我们可以提供接受不同类型参数的多个函数。
- en: When a function is invoked, the compiler looks at all the functions with that
    name, called the **overload set**, and picks the function that is the best match
    for the arguments provided.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用一个函数时，编译器会查看所有具有该名称的函数，称为**重载集**，并选择与提供的参数最匹配的函数。
- en: 'The precise rule on how the function is selected is complex, but the behavior
    is often intuitive: the compiler looks for the better match between the arguments
    and the expected parameters of the function. If we have two functions, `int increment(int)`
    and `float increment(float)`, and we call them with `increment(1)`, the integer
    overload is selected because an integer is a better match to an integer than a
    float, even if an integer can be converted into a float. An example of this would
    be:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 函数选择的确切规则很复杂，但行为通常是直观的：编译器会在参数和函数的预期参数之间寻找更好的匹配。如果我们有两个函数，`int increment(int)`
    和 `float increment(float)`，并且我们用 `increment(1)` 调用它们，整数重载会被选择，因为整数与整数相比，比浮点数更匹配，即使整数可以被转换为浮点数。这个例子可以是：
- en: '[PRE49]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Thanks to this feature, the calling code does not need to worry about which
    overload of the function the compiler is going to select, and the code can be
    more expressive thanks to using the same function to express the same meaning.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个特性，调用代码不需要担心编译器将要选择哪个函数重载，而且由于使用了相同的函数来表达相同的意思，代码可以更加清晰。
- en: 'Activity 6: Writing a Math Library for a 3D Game'
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动6：为3D游戏编写数学库
- en: 'Johnny wants to implement a *math* library for the video game he is making.
    It will be a 3D game, so he will need to operate on points representing the three
    coordinates: *x*, *y*, and *z*.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰尼想为他正在制作的视频游戏实现一个 *数学* 库。这将是一个3D游戏，因此他需要操作代表三个坐标的点：*x*、*y* 和 *z*。
- en: The points are represented as `std::array<float, 3>`. A library will be used
    throughout the game, so Johnny needs to be sure it can work when included multiple
    times (by creating a header file and declaring the functions there).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 点被表示为 `std::array<float, 3>`。库将在整个游戏中使用，因此约翰尼需要确保它可以在多次包含时工作（通过创建头文件并在那里声明函数）。
- en: 'The library needs to support the following steps:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 该库需要支持以下步骤：
- en: Finding the distance between 2 floats, 2 integers, or 2 points.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找两个浮点数、两个整数或两个点之间的距离。
- en: If only one of the 2 points is provided, the other one is assumed to be the
    origin (the point at location `(0,0,0)`).
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果只提供了2个点中的一个，则假定另一个点是原点（位置在 `(0,0,0)` 的点）。
- en: Additionally, Johnny often needs to compute the circumference of a circle from
    its radius (defined as `2*pi*r`) to understand how far enemies can see. `pi` is
    constant for the duration of the program (which can be declared globally in the
    `.cpp` file).
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，约翰尼经常需要从圆的半径（定义为 `2*pi*r`）计算圆的周长，以了解敌人能看到多远。`pi` 在整个程序运行期间是常数（可以在 `.cpp`
    文件中全局声明）。
- en: When an enemy moves, it visits several points. Johnny needs to compute the total
    distance that it would take to walk along those points.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当敌人移动时，它会访问几个点。约翰尼需要计算沿着这些点行走的总距离。
- en: For simplicity, we will limit the number of points to `10`, but Johnny might
    need up to 100\. The function would take `std::array<std::array<float, 3>, 10>`
    and compute the distance between consecutive points.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将点的数量限制为 `10`，但约翰尼可能需要多达 `100`。函数将接受 `std::array<std::array<float,
    3>, 10>` 并计算连续点之间的距离。
- en: 'For example (with a list of 5 points): for the array `{{0,0,0}, {1,0,0}, {1,1,0},
    {0,1,0}, {0,1,1}}`, the total distance is 5, because going from `{0,0,0}` to `{1,0,0}`
    is a distance of `1`, then going from `{1,0,0}` to `{1,1,0}` is a distance of
    `1` again, and so on for the remaining 3 points.'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如（包含5个点的列表）：对于数组 `{{0,0,0}, {1,0,0}, {1,1,0}, {0,1,0}, {0,1,1}}`，总距离是5，因为从
    `{0,0,0}` 到 `{1,0,0}` 的距离是 `1`，然后从 `{1,0,0}` 到 `{1,1,0}` 的距离又是 `1`，以此类推，对于剩余的3个点也是如此。
- en: Note
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 286.
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第286页找到。
- en: Make sure that the functions are well-organized by grouping them together.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 确保函数组织良好，通过将它们分组在一起。
- en: Remember that the distance between two points is computed as the square root
    of (`x2-x1)^2 + (y2-y1)^2 + (z2-z1)^2`.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，两点之间的距离是通过计算 `x2-x1)^2 + (y2-y1)^2 + (z2-z1)^2` 的平方根来得到的。
- en: C++ offers the `std::pow` function for the `std::sqrt` function, which takes
    the number to square. Both are in the `cmath` header.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 提供了 `std::pow` 函数用于 `std::sqrt` 函数，它接受要平方的数字。这两个函数都在 `cmath` 头文件中。
- en: Summary
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw the powerful features C++ offers to implement functions.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了C++提供的用于实现函数的强大功能。
- en: We started by discussing why functions are useful and what they can be used
    for, and then we dove into how to declare and define them.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论了为什么函数是有用的以及它们可以用来做什么，然后我们深入探讨了如何声明和定义它们。
- en: We analyzed different ways of accepting parameters and returning values, how
    to make use of local variables, and then explored how to improve the safety and
    convenience of calling them with `const` and default arguments.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析了接受参数和返回值的多种方式，如何利用局部变量，然后探讨了如何通过使用`const`和默认参数来提高调用它们的安全性和便利性。
- en: Finally, we saw how functions can be organized in namespaces and the ability
    to give the same name to different functions that implement the same concept,
    making the calling code not have to think about which version to call.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了函数如何被组织在命名空间中，以及给实现相同概念的不同函数赋予相同名称的能力，这使得调用代码不必考虑调用哪个版本。
- en: In the next chapter, we will look at how to create classes and how they are
    used in C++ to make building complex programs easy and safe.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何创建类以及它们在C++中如何被用来使构建复杂程序变得简单和安全。
