<html><head></head><body>
  <div id="_idContainer033">
   <h1 class="chapter-number" id="_idParaDest-89">
    <a id="_idTextAnchor088">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     8
    </span>
   </h1>
   <h1 id="_idParaDest-90">
    <a id="_idTextAnchor089">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     The Fastest C++ Code is Inline Assembly
    </span>
   </h1>
   <p class="italic-heading">
    <em class="italic">
     <span class="koboSpan" id="kobo.3.1">
      Lower than this you should
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.4.1">
       not get
      </span>
     </em>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     In the fast-paced world of C++ developers, where efficiency is paramount, optimizing code to squeeze out every last drop of performance has always been a fascinating challenge.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     This journey often takes developers down to the very roots of computing, where C++ meets assembly language, and every CPU
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      cycle counts.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     Circa three decades ago, during the wild 90s, programmers frequently had to manually craft every byte of executable code, often diving into the murky waters of assembly language (and even lower) to achieve the desired performance.
    </span>
    <span class="koboSpan" id="kobo.7.2">
     These early pioneers of optimization developed techniques that, while rudimentary by today’s standards, laid the groundwork for understanding the power and limitations of both C++
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      and assembly.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.9.1">
     This exploration delves into the specifics of optimizing a seemingly simple task, lighting up a pixel on the screen, by comparing handcrafted and optimized assembly routines from three decades ago with the modern-day output of advanced compilers such as Clang, GCC, and MSVC.
    </span>
    <span class="koboSpan" id="kobo.9.2">
     As we navigate through the evolution of compilers, we’ll see how the balance between human intuition and machine-generated optimization has shifted, offering new insights into the ever-evolving relationship between the code we write and the machine that ultimately runs our programs.
    </span>
    <span class="koboSpan" id="kobo.9.3">
     As a side note, in this chapter, we’ll focus on Intel’s x86 family of processors and delve into specific features, while leaving coverage of the ARM architecture for another book, potentially by a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.10.1">
      different author.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.11.1">
     In this chapter, you will learn
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.12.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.13.1">
      How to use assembly code to speed up
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.14.1">
       your routines
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.15.1">
      How not to use assembly code and trust your compiler’s optimizer to come up with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.16.1">
       fastest solution
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-91">
    <a id="_idTextAnchor090">
    </a>
    <span class="koboSpan" id="kobo.17.1">
     Light me a pixel
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.18.1">
     Circa 30 years ago, at the nearer end of the wild 90s, the author of these lines spent quite a significant time optimizing code that was supposed to run as fast as possible, consuming the least amount of resources while showing incredible spinning graphics on a screen (there was also scrolling involved, too, and other not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.19.1">
      relevant calculations).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.20.1">
     These applications were called demos (intros, etc.) and showcased some spectacular graphical effects, backed by a strong mathematical background, and had an in-house developed graphical engine; in those days, there was no DirectX to take all those nasty low-level details off your plate, so all had to be done by hand.
    </span>
    <span class="koboSpan" id="kobo.20.2">
     Methods for pixel color calculation, color palette setting, vertical retrace of the CRT screen, and flipping of back and front buffers were all coded by hand, using C++ of the 90s and some assembly language routines for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.21.1">
      time-critical bits.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.22.1">
     One of these methods was
    </span>
    <a id="_idIndexMarker289">
    </a>
    <span class="koboSpan" id="kobo.23.1">
     putting a pixel on the screen, which, in its simplest incarnation of the method, looked
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.24.1">
      like this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.25.1">
void putpixel(int x, int y, unsigned char color) {
    unsigned char far* vid_mem = (unsigned char far*)0xA0000000L;
    vid_mem[(y * 320) + x] = color;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     I’ll spare you the very low-level details such as how segment/offset memory worked 30 years ago.
    </span>
    <span class="koboSpan" id="kobo.26.2">
     Instead, imagine that the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.27.1">
      following apply:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.28.1">
      You are using DOS (in 1994, in the wild-far-eastern part of Europe, almost everyone who had a PC used DOS – kudos to the 0.1 percent of early
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.29.1">
       Linux adopters)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.30.1">
      You are also using a special graphic mode, 0x13 (almost all the games used this mode because it allowed 256 colors to be drawn on the screen using the mysterious 320 by 200 resolution, whose origins only IBM engineers from 40 years
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.31.1">
       ago know)
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.32.1">
     In this case, if you put a byte at the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.33.1">
      0xA000
     </span>
    </strong>
    <span class="koboSpan" id="kobo.34.1">
     segment and a specific offset, the graphic card will light up a pixel at the specific coordinates, which can be obtained from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.35.1">
      preceding formula.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.36.1">
     Now, after
    </span>
    <a id="_idIndexMarker290">
    </a>
    <span class="koboSpan" id="kobo.37.1">
     several iterations of the code, the aforementioned programmer observed that the routine was not that optimal, and it could have benefited from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.38.1">
      some optimizations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.39.1">
     Please bear with me; the code that was generated by the affordable compiler (the one you just copied from the disk that we mentioned in
    </span>
    <a href="B22235_02.xhtml#_idTextAnchor026">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.40.1">
        Chapter 2
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.41.1">
     of the book) is in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.42.1">
      following screenshot:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer032">
     <span class="koboSpan" id="kobo.43.1">
      <img alt="Figure 8.1 – Everyone’s favorite Turbo Debugger from 30 years ago" src="image/B22235_08_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.44.1">
     Figure 8.1 – Everyone’s favorite Turbo Debugger from 30 years ago
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.45.1">
     Now, this looks pretty wild, considering the age of it, but again, we need just a bit of patience, and all the mystery surrounding why it’s here will be revealed.
    </span>
    <span class="koboSpan" id="kobo.45.2">
     You see, we were discussing how the code generated by the compiler is far from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.46.1">
      being optimal.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.47.1">
     Let’s take a moment to consider this piece of code.
    </span>
    <span class="koboSpan" id="kobo.47.2">
     After giving it some thought, especially from the perspective of someone familiar with assembly language, which is becoming increasingly rare these days, it might be clear to them that the compiler didn’t struggle as much as we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.48.1">
      might expect.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.49.1">
     The following is
    </span>
    <a id="_idIndexMarker291">
    </a>
    <span class="koboSpan" id="kobo.50.1">
     the assembly code that the compiler generated for the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.51.1">
       putpixel
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.52.1">
      routine:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.53.1">
putpixel   proc   near
  push bp              ; Save the base pointer on the stack
  mov bp, sp      ; Set the BP to the current stack pointer
  sub sp, 4           ; Reserve 4 bytes for local variables
  mov word ptr [bp-2], 40960       ; Store 0xA000 at [bp-2]
  mov word ptr [bp-4], 0                ; Store 0 at [bp-4]
  mov ax, word ptr [bp+6]   ; Load the y-coordinate into AX
  mov dx, 320               ; Load the screen width into DX
  imul dx      ; Multiply AX (y-coord) by DX (screen width)
  mov bx, word ptr [bp+4]   ; Load the x-coordinate into BX
  add bx, ax      ; Add y*screen width (AX) to BX (x-coord)
  mov es, word ptr [bp-2]             ; Load 0xA000 into ES
  add bx, word ptr [bp-4]       ; Final pixel address in BX
  mov al, byte ptr [bp+8]    ; Load the color value into AL
  mov byte ptr es:[bx], al               ; Light the pixel!
</span><span class="koboSpan" id="kobo.53.2">  mov sp, bp                    ; Restore the stack pointer
  pop bp                         ; Restore the base pointer
  ret                           ; Return from the procedure</span></pre>
   <p>
    <span class="koboSpan" id="kobo.54.1">
     For those not familiar with the notation,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.55.1">
      []
     </span>
    </strong>
    <span class="koboSpan" id="kobo.56.1">
     represents the data at the address given in the square parentheses, so the parameters are being passed in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      like this:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.58.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.59.1">
       x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.60.1">
      coordinate of the pixel (
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.61.1">
       from
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.62.1">
        [bp+4]
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.63.1">
       )
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.64.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.65.1">
       y
      </span>
     </strong>
     <span class="koboSpan" id="kobo.66.1">
      coordinate of the pixel (
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.67.1">
       from
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.68.1">
        [bp+6]
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.69.1">
       )
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.70.1">
      The color value to set (
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.71.1">
       from
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.72.1">
        [bp+8]
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.73.1">
       )
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.74.1">
     Indeed, the
    </span>
    <a id="_idIndexMarker292">
    </a>
    <span class="koboSpan" id="kobo.75.1">
     code as is contains a lot of unnecessary memory access to move data around, when those operations could have been kept in registers, and there is quite a lot of unnecessary access to various memory areas, which can be skipped.
    </span>
    <span class="koboSpan" id="kobo.75.2">
     The code compiled by the compiler of the day generated code that was easy to debug, but which could have been written much neater.
    </span>
    <span class="koboSpan" id="kobo.75.3">
     Compilers today generate the same kind of code, having a very similar performance, when compiling in Debug mode but once you switch them to optimized Release mode, they will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.76.1">
      do magic.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.77.1">
     Modern CPUs are highly complex beasts; when running in protected mode, they employ various techniques, such as out-of-order execution, instruction pipelining, and other techniques that make really low-level performance analysis nowadays quite difficult to nail down properly...
    </span>
    <span class="koboSpan" id="kobo.77.2">
     but old machines were much simpler!
    </span>
    <span class="koboSpan" id="kobo.77.3">
     Or just use DOS on a modern computer and you will get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.78.1">
      same feeling.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.79.1">
     Not considering that protected mode was introduced in the early 80286 processors, DOS simply could not handle it (and still can’t), so it stuck to what it knew best: running programs in real mode.
    </span>
    <span class="koboSpan" id="kobo.79.2">
     While running in real mode, the processor just executed one instruction after the other, and there even was an instruction table explaining how many cycles each instruction
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.80.1">
      would take
     </span>
    </span>
    <span class="No-Break">
     <span class="superscript">
      <span id="footnote-024-backlink">
       <a class="_idFootnoteLink _idGenColorInherit" href="B22235_08.xhtml#footnote-024">
        <span class="koboSpan" id="kobo.81.1">
         1
        </span>
       </a>
      </span>
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.82.1">
      .
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-024">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_08.xhtml#footnote-024-backlink">
      <span class="koboSpan" id="kobo.83.1">
       1
      </span>
     </a>
     <a href="https://zs3.me/intel.php">
      <span class="koboSpan" id="kobo.84.1">
       https://zs3.me/intel.php
      </span>
     </a>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.85.1">
     After spending a significant amount of time consulting those tables, we came to the conclusion that one
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.86.1">
      imul
     </span>
    </strong>
    <span class="koboSpan" id="kobo.87.1">
     can take longer than two shifts and an add on a processor of those days (the same conclusion was drawn by several other thousands of programmers all around the world after consulting those tables, but we felt that we must be some kind of local heroes for discovering
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.88.1">
      this feature).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.89.1">
     Considering that 320 is a very nice number, as it is the sum of 256 and 64, after several rounds of optimizations, we came up with the following slightly more optimized version for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.90.1">
      the routine:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.91.1">
void putpixel(int x, int y, unsigned char c) {
  asm {
  mov ax, 0xA000      // Load 0xA000 (VGA mode 13h) into AX
  mov es, ax        // Set ES to the video segment (0xA000)
  mov dx, y                // Load the y-coordinate into DX
  mov di, x                // Load the x-coordinate into DI
  mov bx, y                // Copy the y-coordinate into BX
  shl dx, 8    // Multiply DX by 256 (left shift by 8 bits)
  shl bx, 6     // Multiply BX by 64 (left shift by 6 bits)
  add dx, bx // Add those, effectively multiplying y by 320
  add di, dx   // Add the calculated y to DI (pixel offset)
  mov al, c                 // Load the color value into AL
  stosb                                  // Light the pixel
} }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.92.1">
     It is not the most optimal routine that one can come up with for this purpose, but for our specific requirements, it was more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.93.1">
      than enough.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.94.1">
     A significantly
    </span>
    <a id="_idIndexMarker293">
    </a>
    <span class="koboSpan" id="kobo.95.1">
     reduced amount of direct memory access (which was considered slow even in the old days), the lengthy multiplication by 320 using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.96.1">
      imul
     </span>
    </strong>
    <span class="koboSpan" id="kobo.97.1">
     changed to multiplication by 256 (this is the shift to the left by 8 operations:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.98.1">
      shl dx,8
     </span>
    </strong>
    <span class="koboSpan" id="kobo.99.1">
     ), and 64 (the same by 6), then a sum, which still adds up to fewer cycles than the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.100.1">
      power-consuming multiplication.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.101.1">
     And thus, the foundation was laid for the myth that if you really want fast code, you have to write it yourself at the lowest
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.102.1">
      possible level.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.103.1">
     As an interesting mental exercise, let’s jump forward in time 30 years, skipping several generations of compilers.
    </span>
    <span class="koboSpan" id="kobo.103.2">
     If we feed the C++ routine as it is to a modern compiler (for our purpose, we have used Clang – the latest at the time of writing was version 18.1 – but using GCC will get also a very similar result, just using a different set of registers), we get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.104.1">
      following output:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.105.1">
putpixel(int, int, unsigned char):
  movzx eax, byte ptr [esp + 12]
  mov ecx, dword ptr [esp + 4]
  mov edx, dword ptr [esp + 8]
  lea edx, [edx + 4*edx]
  shl edx, 6
  mov byte ptr [edx + ecx + 40960], al</span></pre>
   <p>
    <span class="koboSpan" id="kobo.106.1">
     This is way
    </span>
    <a id="_idIndexMarker294">
    </a>
    <span class="koboSpan" id="kobo.107.1">
     shorter than the one we concocted for our purpose and considered optimal targeting the processors from 3 decades ago, but processors have evolved a lot in the last 30 years, and a lot more advanced features have come in, with new commands (some more words about new commands a bit late in this chapter, so stay tuned) and we find it extremely satisfying how compilers’ optimization routines have resolved the multiplication with that nice
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.108.1">
      number, 320.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.109.1">
     C++ compilers have evolved significantly over the past few decades, from their humble beginnings as Turbo C++ or Watcom C++, becoming incredibly sophisticated and capable of performing a wide range of optimizations that were previously unimaginable due to mostly hardware constraints because, well...
    </span>
    <span class="koboSpan" id="kobo.109.2">
     640 KB should be enough
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.110.1">
      for everyone.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.111.1">
     Modern compilers are no longer just simple translators from human-readable code to machine code; they have become complex systems that analyze and transform code in ways that can drastically improve performance and memory usage, taking into consideration some aspects that are all meant to help developers bring out the best of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.112.1">
      their source.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.113.1">
     GCC, Clang, and MSVC all employ advanced optimization techniques such as inlining functions, loop unrolling, constant folding, dead code elimination, and aggressive optimizations that span across entire modules or programs, since, at their stage, they have an overview of the entire application, allowing these
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.114.1">
      high-level optimizations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.115.1">
     On a side note, these compilers also leverage modern hardware features, such as vectorization and parallelism, to generate highly efficient machine code that can target a specific processor.
    </span>
    <span class="koboSpan" id="kobo.115.2">
     We will soon see how these optimizations fall into place when we present the example in the next section, where we take a mundane task and let our compilers churn
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.116.1">
      through it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.117.1">
     But till we reach that stage, just one more use case from 30 years ago.
    </span>
    <span class="koboSpan" id="kobo.117.2">
     The subtitle of this chapter is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.118.1">
      Lower than this you should not get
     </span>
    </em>
    <span class="koboSpan" id="kobo.119.1">
     .
    </span>
    <span class="koboSpan" id="kobo.119.2">
     Certainly, we meant coding at a lower level, not something else, and right now, we will proudly contradict ourselves.
    </span>
    <span class="koboSpan" id="kobo.119.3">
     Again.
    </span>
    <span class="koboSpan" id="kobo.119.4">
     Here is the contradiction:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.120.1">
      in certain situations, you really should get to a level lower
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.121.1">
       than assembly
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.122.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.123.1">
     If you are familiar with graphic programming, then I suppose you are familiar with the concept of double-buffering and back-buffering.
    </span>
    <span class="koboSpan" id="kobo.123.2">
     The back buffer is an off-screen buffer (memory area, with the same size as the screen) where all the rendering (drawing of graphics) happens first.
    </span>
    <span class="koboSpan" id="kobo.123.3">
     When the rendering is done, the back buffer is copied onto the screen in order to show the graphics, the back buffer is cleared, and the rendering restarts.
    </span>
    <span class="koboSpan" id="kobo.123.4">
     At
    </span>
    <a id="_idIndexMarker295">
    </a>
    <span class="koboSpan" id="kobo.124.1">
     some time in history, Tom Duff, a Canadian programmer, invented a wonderful piece of ingenious code that was meant to accomplish exactly this task; the name of it is Duff’s device and it has been discussed several times in several forums, and we are not going to discuss it now.
    </span>
    <span class="koboSpan" id="kobo.124.2">
     Instead, we will show you the “highly optimized” code that we used to copy data from the back buffer to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.125.1">
      the screen:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.126.1">
void flip(unsigned int source, unsigned int dest) {
  asm {
     push ds   // Save the current value of the DS register
     mov ax, dest   // Load the destination address into AX
     mov es, ax       // Copy the value from AX into the ES
     mov ax, source      // Load the source address into AX
     mov ds, ax         // Copy the value in AX into the DS
     xor si, si  // Zero out the SI (source index) register
     xor di, di      // Zero out the DI (destination index)
     mov cx, 64000       // Load 64000 into the CX register
                   // (this is the number of bytes to copy)
     rep movsb         // Run  the`movsb` instruction 64000
          // times (movsb copies bytes from DS:SI to ES:DI)
     pop ds         // Restore the original value of the DS
} }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.127.1">
     The preceding trick consists of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.128.1">
      rep movsb
     </span>
    </strong>
    <span class="koboSpan" id="kobo.129.1">
     instruction, which will do the actual copying of bytes (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.130.1">
      movsb
     </span>
    </strong>
    <span class="koboSpan" id="kobo.131.1">
     ), repeated (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.132.1">
      rep
     </span>
    </strong>
    <span class="koboSpan" id="kobo.133.1">
     ) 64,000 times, as indicated by the CX register (we all know that 64,000 = 320 x 200; that’s why they are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.134.1">
      magic numbers).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.135.1">
     This code works perfectly given the circumstances.
    </span>
    <span class="koboSpan" id="kobo.135.2">
     However, there is an opportunity for a tiny bit of optimization; you see, we are using a decent processor – at least, an 80386.
    </span>
    <span class="koboSpan" id="kobo.135.3">
     Unlike its predecessor, the 80286, which was a pure 16-bit processor, the 80386 is a huge step forward, since it is the first 32-bit x86 processor coming from Intel.
    </span>
    <span class="koboSpan" id="kobo.135.4">
     So, what we can do is the following: instead of copying 64,000 bytes using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.136.1">
      rep movsd
     </span>
    </strong>
    <span class="koboSpan" id="kobo.137.1">
     , we can harvest the
    </span>
    <a id="_idIndexMarker296">
    </a>
    <span class="koboSpan" id="kobo.138.1">
     opportunities given by our high-end processor and put to use the new 32-bit framework, keywords, and registers.
    </span>
    <span class="koboSpan" id="kobo.138.2">
     What we do is move 16,000 double words (we all know that a byte is measured as 8 bits, two bytes are called a word, measuring 16 bits, and two words are called a double word, totaling 32 bits) because that is exactly what the new processor has support for: operation on 32-bit values.
    </span>
    <span class="koboSpan" id="kobo.138.3">
     The newly introduced
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.139.1">
      movsd
     </span>
    </strong>
    <span class="koboSpan" id="kobo.140.1">
     command does exactly this: copies 4 bytes in one step, so that could be a speed-up of 4 times compared to our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.141.1">
      older code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.142.1">
     Our anecdotical C++ compiler, introduced at the beginning of this book, is Turbo C++ Lite.
    </span>
    <span class="koboSpan" id="kobo.142.2">
     Unfortunately for us, Turbo C++ cannot compile code for anything other than processors below 80286, so we are stuck with 16-bit registers and some really inefficient
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.143.1">
      register handling.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.144.1">
     And here is where the lowest level of hack anyone can see in C++ code comes in – we simply add the bytes of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.145.1">
      rep movsd
     </span>
    </strong>
    <span class="koboSpan" id="kobo.146.1">
     command as hexadecimal values in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.147.1">
      the code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.148.1">
xor di,di
mov cx,16000
db 0xF3,0x66,0xA5 //rep movsd
pop ds</span></pre>
   <p>
    <span class="koboSpan" id="kobo.149.1">
     Nothing is simpler and more eye-watering than seeing this in production code, right?
    </span>
    <span class="koboSpan" id="kobo.149.2">
     Now, regardless that our compiler cannot compile code for 80386 because it’s stuck in the Stone Age (pretty much like half of the chapter you are reading right now), we can still produce code that runs optimally on your processor.
    </span>
    <span class="koboSpan" id="kobo.149.3">
     Please don’t
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.150.1">
      do this.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-92">
    <a id="_idTextAnchor091">
    </a>
    <span class="koboSpan" id="kobo.151.1">
     A note on the past
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.152.1">
     Now, you might ask why we even bother mentioning assembly language in 2024, when the major trends exhaust themselves concerning the widespread adoption of AI-driven development tools, the growth of low-code/no-code platforms, and the continued rise of the Nth iteration of various JavaScript modules that have exactly the same output as the previous one, except that the syntax
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.153.1">
      is different.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.154.1">
     Regardless that these are the loudest happenings in the IT world nowadays, assembly language is still not obsolete.
    </span>
    <span class="koboSpan" id="kobo.154.2">
     It might not get as much focus as everyone’s favorite Rust language (Alex will debate Rust in a later chapter if all goes according to plan), but there are still major business branches where the assembly is a must, and still essential in several hardware environments that require precise control, performance optimization, or direct hardware access, such as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.155.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.156.1">
       Embedded systems
      </span>
     </strong>
     <span class="koboSpan" id="kobo.157.1">
      : Microcontrollers and IoT devices often use assembly for efficient, low-level programming.
     </span>
     <span class="koboSpan" id="kobo.157.2">
      There isn’t too much power on these small devices; every
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.158.1">
       bit counts.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.159.1">
       Operating system
      </span>
     </strong>
     <span class="koboSpan" id="kobo.160.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.161.1">
       OS
      </span>
     </strong>
     <span class="koboSpan" id="kobo.162.1">
      )
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.163.1">
       development
      </span>
     </strong>
     <span class="koboSpan" id="kobo.164.1">
      : Bootloaders and critical parts of OS kernels require assembly for hardware initialization and management.
     </span>
     <span class="koboSpan" id="kobo.164.2">
      To achieve this feat, either you work for a large corporation or start your own project.
     </span>
     <span class="koboSpan" id="kobo.164.3">
      Linux is pretty much
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.165.1">
       accounted for.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.166.1">
       High-performance computing
      </span>
     </strong>
     <span class="koboSpan" id="kobo.167.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.168.1">
       HPC
      </span>
     </strong>
     <span class="koboSpan" id="kobo.169.1">
      ): Assembly is used for optimizing performance-critical code, particularly in scientific computing or custom hardware (e.g., FPGAs).
     </span>
     <span class="koboSpan" id="kobo.169.2">
      To pursue this, you must find someone wanting to pay you to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.170.1">
       pursue this.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.171.1">
       Security and reverse engineering
      </span>
     </strong>
     <span class="koboSpan" id="kobo.172.1">
      : Analyzing and exploiting binaries often involves understanding and writing assembly.
     </span>
     <span class="koboSpan" id="kobo.172.2">
      This is the most lucrative of all, and the most realistic way of getting into assembly
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.173.1">
       programming, unfortunately.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.174.1">
       Firmware development
      </span>
     </strong>
     <span class="koboSpan" id="kobo.175.1">
      : BIOS/UEFI and low-level device drivers are commonly written in assembly for direct hardware interaction.
     </span>
     <span class="koboSpan" id="kobo.175.2">
      Here, again, you must be on the payroll of a large corporation, although there are a few open source projects too (coreboot, libreboot, or just google free bios to get a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.176.1">
       decent list).
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.177.1">
       Legacy systems
      </span>
     </strong>
     <span class="koboSpan" id="kobo.178.1">
      : Maintaining older systems or working with retro computing often requires assembly.
     </span>
     <span class="koboSpan" id="kobo.178.2">
      This is the ideal chance to blend both fun and suffering into
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.179.1">
       one experience.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.180.1">
       Specialized hardware
      </span>
     </strong>
     <span class="koboSpan" id="kobo.181.1">
      : DSPs and custom CPU architectures may need assembly for specialized,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.182.1">
       efficient processing.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.183.1">
     Please don’t dismiss assembly language just yet.
    </span>
    <span class="koboSpan" id="kobo.183.2">
     It remains relevant and will continue to be as long as computers exist.
    </span>
    <span class="koboSpan" id="kobo.183.3">
     For those who are interested in the topic, it has its place.
    </span>
    <span class="koboSpan" id="kobo.183.4">
     Otherwise, you can stick to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.184.1">
      standard C++.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-93">
    <a id="_idTextAnchor092">
    </a>
    <span class="koboSpan" id="kobo.185.1">
     The sum of all numbers
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.186.1">
     Dearest esteemed reader.
    </span>
    <span class="koboSpan" id="kobo.186.2">
     It is a truth universally acknowledged that all developers at some stage in their lives must go through a technical interview.
    </span>
    <span class="koboSpan" id="kobo.186.3">
     There are various levels of interrogations: some just on the level of “Please tell me something about yourself” (these are the hardest), while some go deeper and might even ask you to write some code on a blackboard or even
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.187.1">
      a computer.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.188.1">
     One of the programs that very frequently comes up in interview questions is to write some code that will calculate the sum of a series of numbers sharing a certain peculiarity, for example, the sum of all even numbers, the sum of all numbers divisible by, let’s say, five, or the sum of odd numbers in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.189.1">
      specific interval.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.190.1">
     For simplicity’s sake, let’s stick to
    </span>
    <a id="_idIndexMarker297">
    </a>
    <span class="koboSpan" id="kobo.191.1">
     something simple: the sum of all odd numbers up to 100.
    </span>
    <span class="koboSpan" id="kobo.191.2">
     The following quick program delivers
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.192.1">
      exactly this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.193.1">
#include &lt;cstdio&gt;
int main() {
    int sum = 0;
    for (int i = 1; i &lt;= 100; ++i) {
        if (i % 2 != 0) {  // Check if the number is odd
            sum += i;      // Add the odd number to the sum
        }
    }
    printf("The sum is: %d\n",sum);
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.194.1">
     Not an overly complicated program: just iterate through the numbers; check whether they are odd; if yes, add their value to the final sum; and, in the end, print out the sum (for everyone interested, the sum of odd numbers from 1 to 100 is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.195.1">
      exactly 2,500).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.196.1">
     But our clear thinking was clouded by the well-known fact (at least, for C++ programmers) that the fastest C++ code is inline assembly, so we decided to sacrifice the portability and understandability of our program on the altar of speed and rewrite the main part of it using assembly language.
    </span>
    <span class="koboSpan" id="kobo.196.2">
     Because, well, that is the fastest.
    </span>
    <span class="koboSpan" id="kobo.196.3">
     Here is our attempt
    </span>
    <a id="_idIndexMarker298">
    </a>
    <span class="koboSpan" id="kobo.197.1">
     at this, using AT&amp;T assembly syntax, just to demonstrate the widely available assembly dialects we can embed in a non-standard compliant
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.198.1">
      C++ program:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.199.1">
#include &lt;cstdio&gt;
int main() {
    int sum = 0;
    int i = 1; // Start with the first odd number
    __asm__ (
        "movl $1, %[i]\n"   // Initialize i to 1
        "movl $0, %[sum]\n" // Initialize sum to 0
        "loop_start:\n"
        "cmpl $100, %[i]\n"   // Compare i with 100
        "jg loop_end\n"       // If i &gt; 100, exit the
        "addl %[i], %[sum]\n" // sum += i
        "addl $2, %[i]\n"     // i += 2
        "jmp loop_start\n"    // Repeat the loop
        "loop_end:\n"
        : [sum] "+r" (sum), [i] "+r" (i)
    );
    printf("The sum is: %d\n", sum);
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.200.1">
     Just a quick presentation of what the assembly code does, because I hope the other lines of code
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.201.1">
      are self-explanatory.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.202.1">
     Here is the
    </span>
    <a id="_idIndexMarker299">
    </a>
    <span class="koboSpan" id="kobo.203.1">
     assembly
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.204.1">
      code breakdown:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.205.1">
       "movl $1, %[i]\n"
      </span>
     </strong>
     <span class="koboSpan" id="kobo.206.1">
      : This instruction sets
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.207.1">
       i
      </span>
     </strong>
     <span class="koboSpan" id="kobo.208.1">
      to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.209.1">
       1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.210.1">
      .
     </span>
     <span class="koboSpan" id="kobo.210.2">
      Although
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.211.1">
       i
      </span>
     </strong>
     <span class="koboSpan" id="kobo.212.1">
      was already initialized to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.213.1">
       1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.214.1">
      in the C++ code, this explicitly sets it again in assembly
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.215.1">
       for clarity.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.216.1">
       "movl $0, %[sum]\n"
      </span>
     </strong>
     <span class="koboSpan" id="kobo.217.1">
      : This sets the sum to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.218.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.219.1">
      , ensuring that the sum starts from
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.220.1">
       0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.221.1">
      in the assembly code.
     </span>
     <span class="koboSpan" id="kobo.221.2">
      We have to admit that these two initializations are not required, but we wanted them to be a gentle introduction to the assembly code so as not to scare
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.222.1">
       you away.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.223.1">
       loop_start
      </span>
     </strong>
     <span class="koboSpan" id="kobo.224.1">
      : This is just a label, and needs no
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.225.1">
       further clarification.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.226.1">
       "cmpl $100, %[i]\n"
      </span>
     </strong>
     <span class="koboSpan" id="kobo.227.1">
      : Compares
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.228.1">
       i
      </span>
     </strong>
     <span class="koboSpan" id="kobo.229.1">
      with
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.230.1">
       100
      </span>
     </strong>
     <span class="koboSpan" id="kobo.231.1">
      .
     </span>
     <span class="koboSpan" id="kobo.231.2">
      The comparison is used to check whether
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.232.1">
       i
      </span>
     </strong>
     <span class="koboSpan" id="kobo.233.1">
      has reached or
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.234.1">
       exceeded
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.235.1">
        100
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.236.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.237.1">
       "jg loop_end\n"
      </span>
     </strong>
     <span class="koboSpan" id="kobo.238.1">
      : If
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.239.1">
       i
      </span>
     </strong>
     <span class="koboSpan" id="kobo.240.1">
      is greater than
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.241.1">
       100
      </span>
     </strong>
     <span class="koboSpan" id="kobo.242.1">
      , the program jumps to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.243.1">
       loop_end
      </span>
     </strong>
     <span class="koboSpan" id="kobo.244.1">
      , exiting
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.245.1">
       the loop.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.246.1">
       "addl %[i], %[sum]\n"
      </span>
     </strong>
     <span class="koboSpan" id="kobo.247.1">
      : Adds the current value of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.248.1">
       i
      </span>
     </strong>
     <span class="koboSpan" id="kobo.249.1">
      to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.250.1">
       sum
      </span>
     </strong>
     <span class="koboSpan" id="kobo.251.1">
      .
     </span>
     <span class="koboSpan" id="kobo.251.2">
      This accumulates the sum of all odd numbers up
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.252.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.253.1">
        99
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.254.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.255.1">
       "addl $2, %[i]\n"
      </span>
     </strong>
     <span class="koboSpan" id="kobo.256.1">
      : Increments
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.257.1">
       i
      </span>
     </strong>
     <span class="koboSpan" id="kobo.258.1">
      by 2 to move to the next odd number (e.g., 1 → 3 →
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.259.1">
       5, etc.).
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.260.1">
       "jmp loop_start\n"
      </span>
     </strong>
     <span class="koboSpan" id="kobo.261.1">
      : Jumps back to the start of the loop to repeat
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.262.1">
       the process.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.263.1">
       loop_end
      </span>
     </strong>
     <span class="koboSpan" id="kobo.264.1">
      : This is the label where the program jumps when
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.265.1">
       i
      </span>
     </strong>
     <span class="koboSpan" id="kobo.266.1">
      exceeds
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.267.1">
       100
      </span>
     </strong>
     <span class="koboSpan" id="kobo.268.1">
      , effectively ending
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.269.1">
       the loop.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.270.1">
     The weirdly looking
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.271.1">
      "+r" (sum)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.272.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.273.1">
      "+r" (i)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.274.1">
     parts are constraints that tell the compiler to treat
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.275.1">
      sum
     </span>
    </strong>
    <span class="koboSpan" id="kobo.276.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.277.1">
      i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.278.1">
     as read-write variables, meaning their values can be both read from and written to during the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.279.1">
      assembly operations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.280.1">
     As a first
    </span>
    <a id="_idIndexMarker300">
    </a>
    <span class="koboSpan" id="kobo.281.1">
     drawback, the readability and understandability of the code have suffered exponentially.
    </span>
    <span class="koboSpan" id="kobo.281.2">
     We intentionally use the AT&amp;T syntax for assembly because it is much more cumbersome and harder to comprehend, and we want you to suffer with it and remember never to use assembly in your code unless you know what you’re doing, and then
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.282.1">
      you’re excused.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.283.1">
     Secondly, this code is not portable anymore because there is no such thing as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.284.1">
      __asm__
     </span>
    </strong>
    <span class="koboSpan" id="kobo.285.1">
     under Visual C++; they used
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.286.1">
      __asm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.287.1">
     back in the day (or more recently, at the beginning of this chapter, Turbo C demonstrated the introduction of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.288.1">
      asm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.289.1">
     keyword).
    </span>
    <span class="koboSpan" id="kobo.289.2">
     And since we are here, the C++ standard does not include a common assembly block identifier because assembly language syntax is compiler- and platform-specific, and inline assembly is an extension rather than a core part of the language.
    </span>
    <span class="koboSpan" id="kobo.289.3">
     You have been warned.
    </span>
    <span class="koboSpan" id="kobo.289.4">
     I really hope that the preceding statement managed to entirely discourage you from ever considering writing assembly code in the body of your C++ function, regardless of the presence of the non-standard keyword to enable you to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.290.1">
      do this.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.291.1">
     But now that we are here, courtesy of
    </span>
    <a href="http://gcc.godbolt.org">
     <span class="koboSpan" id="kobo.292.1">
      gcc.godbolt.org
     </span>
    </a>
    <span class="koboSpan" id="kobo.293.1">
     , we have asked the major compilers to churn through the original little C++ program (with no assembly incursion at all) at various optimization levels because we feel the urge to demonstrate to you that, indeed, entirely skipping the assembly language at this stage is the wisest decision you
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.294.1">
      can take.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.295.1">
     The first one to demonstrate how efficient the compiler is in generating optimal C++ code is Microsoft Visual C++.
    </span>
    <span class="koboSpan" id="kobo.295.2">
     Microsoft’s own tiny, squishy C++ compiler has several options to
    </span>
    <a id="_idIndexMarker301">
    </a>
    <span class="koboSpan" id="kobo.296.1">
     generate and optimize the generated code
    </span>
    <span class="superscript">
     <span id="footnote-023-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_08.xhtml#footnote-023">
       <span class="koboSpan" id="kobo.297.1">
        2
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.298.1">
     , but we have a saying here: the shorter the code, the faster it runs.
    </span>
    <span class="koboSpan" id="kobo.298.2">
     So, we have explicitly told the compiler to generate the shortest code (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.299.1">
      /O1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.300.1">
     ), which is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.301.1">
      the following:
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-023">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_08.xhtml#footnote-023-backlink">
      <span class="koboSpan" id="kobo.302.1">
       2
      </span>
     </a>
     <a href="https://learn.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=msvc-170">
      <span class="koboSpan" id="kobo.303.1">
       https://learn.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=msvc-170
      </span>
     </a>
    </p>
   </div>
   <pre class="source-code"><span class="koboSpan" id="kobo.304.1">
`string' DB 'The sum is: %d', 0aH, 00H ; `string'
_main PROC
  xor ecx, ecx  ; Clear the ECX register (set ECX to 0)
  xor edx, edx  ; Clear the EDX register (set EDX to 0)
  inc ecx       ; Increment ECX, setting it to 1
 $LL4@main:
  test cl, 1    ; Test the least significant bit of CL
                ; (ECX) to check if ECX is odd or even
  lea eax, DWORD PTR [ecx+edx] ; Load the effective
                ; address of ECX + EDX into EAX
  cmove eax, edx; If the zero flag is set
                ; (ECX was even), move EDX into EAX
  inc ecx       ; Increment ECX by 1
  mov edx, eax  ; Move the value in EAX to EDX
                ; (update EDX for the next iteration)
  cmp ecx, 100  ; Compare ECX with 100
  jle SHORT $LL4@main ; Jump to the start of the loop
                ; (loop until ECX &gt; 100)
  push edx      ; Push the final value of EDX (the sum)
                ; after the loop onto the stack
  push OFFSET `string' ; Push the offset of the string
  call _printf  ; Call the printf function
  pop ecx       ; Clean up the stack (remove string)
  pop ecx       ; Clean up the stack (remove EDX)
  ret 0         ; Return from the _main function
 _main ENDP</span></pre>
   <p>
    <span class="koboSpan" id="kobo.305.1">
     Interestingly, the assembly output from MSVC is very much in line with the one we concocted by hand; it has a loop, a bit differently dealing with the various registers based on whether we are currently dealing with an odd or even number, but besides this, it’s similar to the one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.306.1">
      we wrote.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.307.1">
     Using the other
    </span>
    <a id="_idIndexMarker302">
    </a>
    <span class="koboSpan" id="kobo.308.1">
     combinations for optimization flags (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.309.1">
      /Ox
     </span>
    </strong>
    <span class="koboSpan" id="kobo.310.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.311.1">
      /O2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.312.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.313.1">
      /Ot
     </span>
    </strong>
    <span class="koboSpan" id="kobo.314.1">
     ) for MSVC did not produce a very different code, just a slightly different assignment of the registers, but nothing that would make us
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.315.1">
      say VOW!
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.316.1">
     After switching to GCC (14.1) in order for it to churn through our simple code, we noticed that for the optimization levels of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.317.1">
      –O1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.318.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.319.1">
      –O2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.320.1">
     , the code generated was very similar to the one generated by MSVC: it had a variable, churned through the numbers, and made some test for oddness and sum.
    </span>
    <span class="koboSpan" id="kobo.320.2">
     That’s it, not black magic...
    </span>
    <span class="koboSpan" id="kobo.320.3">
     unlike the code that was generated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.321.1">
      for
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.322.1">
       –O3
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.323.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.324.1">
     Using this flag, we were
    </span>
    <a id="_idIndexMarker303">
    </a>
    <span class="koboSpan" id="kobo.325.1">
     surprised to see how the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.326.1">
      single instruction, multiple data
     </span>
    </strong>
    <span class="koboSpan" id="kobo.327.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.328.1">
      SIMD
     </span>
    </strong>
    <span class="koboSpan" id="kobo.329.1">
     ) instructions were being pulled in by the compiler, in order to increase the speed, and the unexpected feature this compiler pulled in was that it calculated the sum of elements in an evolving 4-element array, starting with the values {1, 2, 3, 4} and incrementing each element by 4 over 25 iterations using SIMD instructions.
    </span>
    <span class="koboSpan" id="kobo.329.2">
     The accumulated sum was stored in a SIMD register, and after the loop, it was reduced to a single integer, supplying the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.330.1">
      correct result.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.331.1">
     The assembly code produced for this was simply too long (more than three pages), and we decided not to publish it here  because it would have been useless, but as a fact of curiosity, we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.332.1">
      mentioned it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.333.1">
     The next compiler that we checked for how it deals with our simple C++ program is Clang.
    </span>
    <span class="koboSpan" id="kobo.333.2">
     At this stage (meaning after the long SIMD instruction dump from GCC with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.334.1">
      –O3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.335.1">
     ), we did not expect anything spectacular, but we had
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.336.1">
      a surprise.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.337.1">
     Even at
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.338.1">
      –O1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.339.1">
     , Clang greeted us with the following, may I say quite
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.340.1">
      short code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.341.1">
main:
  push rax
  lea rdi, [rip + .L.str]
  mov esi, 2500
  xor eax, eax
  call printf@PLT
  xor eax, eax
  pop rcx
  ret
.L.str:
  .asciz "The sum is: %d\n"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.342.1">
     What a surprise!
    </span>
    <span class="koboSpan" id="kobo.342.2">
     It
    </span>
    <a id="_idIndexMarker304">
    </a>
    <span class="koboSpan" id="kobo.343.1">
     seems that Clang did all the calculations behind the scenes, and just simply put the result in the compiled binary.
    </span>
    <span class="koboSpan" id="kobo.343.2">
     More optimized than this it cannot be.
    </span>
    <span class="koboSpan" id="kobo.343.3">
     We were really thrilled that compilers have matured and grown into these clever beasts, so this tantalized us to check whether other compilers can be clever like
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.344.1">
      this, too.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.345.1">
     GCC exposes
    </span>
    <a id="_idIndexMarker305">
    </a>
    <span class="koboSpan" id="kobo.346.1">
     the same behavior at
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.347.1">
      –O3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.348.1">
     , but surprisingly, only if we want to summarize odd numbers up to 71.
    </span>
    <span class="koboSpan" id="kobo.348.2">
     At 72, something breaks inside and churns out again the long list of SIMD
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.349.1">
      assembly sources.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.350.1">
     We could not convince MSVC under any circumstance, combinations of numbers and parameters to go the Clang way, and precalculate the number required to print out the sum of odd numbers, so we just concluded that it cannot.
    </span>
    <span class="koboSpan" id="kobo.350.2">
     Maybe it will be implemented in the next version, what do you say Microsoft Visual
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.351.1">
      C++ developers?
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-94">
    <a id="_idTextAnchor093">
    </a>
    <span class="koboSpan" id="kobo.352.1">
     A glimpse into the future
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.353.1">
     There is a phrase circulating amongst C++ developers that goes along the lines of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.354.1">
      today’s compiler optimizations are the best we’ve ever managed to cobble together and a not-so-gentle reminder of just how much better they
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.355.1">
       could be
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.356.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.357.1">
     Taking into
    </span>
    <a id="_idIndexMarker306">
    </a>
    <span class="koboSpan" id="kobo.358.1">
     consideration that this book was written in 2024 (hopefully, it will be published in 2025, and if all goes according to plan, in 2027, it will be obsolete, and we will get a commission to come up with a more up-to-date version of it), we have a pretty clear overview of what is happening in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.359.1">
      world today.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.360.1">
     However, if you are reading this book while someone tries to grow potatoes on a different planet and the walls of your building are covered by graffitied monkeys, then you might have had some insights on how far the compilers have come in the last 10 years.
    </span>
    <span class="koboSpan" id="kobo.360.2">
     Actually, it might even happen that Microsoft’s own (yes, we know, tiny, squishy) C++ compiler
    </span>
    <a id="_idIndexMarker307">
    </a>
    <span class="koboSpan" id="kobo.361.1">
     managed to grow up to the stage where it can calculate the sum of a few numbers before compilation and GCC is not
    </span>
    <a id="_idIndexMarker308">
    </a>
    <span class="koboSpan" id="kobo.362.1">
     throwing a tantrum at 72.
    </span>
    <span class="koboSpan" id="kobo.362.2">
     Even for a short, simple program like the one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.363.1">
      we have.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.364.1">
     Welcome to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.365.1">
      the future.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-95">
    <a id="_idTextAnchor094">
    </a>
    <span class="koboSpan" id="kobo.366.1">
     One instruction to rule them all
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.367.1">
     Dear reader.
    </span>
    <span class="koboSpan" id="kobo.367.2">
     In our
    </span>
    <a id="_idIndexMarker309">
    </a>
    <span class="koboSpan" id="kobo.368.1">
     previous section of this chapter, unfortunately, we exhausted the only pompous introduction we could borrow from various cultural sources concerning technical interviews, career and life choices, and whether should we take the red pill or the blue one, so let’s focus our attention on more technical questions that our candidates might face at a technical interview (the word technical appears four times in this short
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.369.1">
      introductory paragraph).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.370.1">
     One of these questions, served to the author of these lines a few years ago, was to write a short code snippet that will count the number of 1 bits (the on bits) in a 32-bit integer.
    </span>
    <span class="koboSpan" id="kobo.370.2">
     Let’s draft up a quick application to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.371.1">
      do this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.372.1">
int countOneBits(uint32_t n) {
    int count = 0;
    while (n) {
        count += n &amp; 1;
        n &gt;&gt;= 1;
    }
    return count;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.373.1">
     Here’s what happens.
    </span>
    <span class="koboSpan" id="kobo.373.2">
     Firstly, we initialize a counter, starting with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.374.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.375.1">
     .
    </span>
    <span class="koboSpan" id="kobo.375.2">
     The next step is to loop through the bits.
    </span>
    <span class="koboSpan" id="kobo.375.3">
     While
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.376.1">
      n
     </span>
    </strong>
    <span class="koboSpan" id="kobo.377.1">
     is non-zero, we add the least significant bit of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.378.1">
      n
     </span>
    </strong>
    <span class="koboSpan" id="kobo.379.1">
     to the counter (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.380.1">
      n&amp;1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.381.1">
     gives us this value).
    </span>
    <span class="koboSpan" id="kobo.381.2">
     Following this, we shift
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.382.1">
      n
     </span>
    </strong>
    <span class="koboSpan" id="kobo.383.1">
     right by one bit (discarding the least
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.384.1">
      significant bit).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.385.1">
     Once all bits are processed (when
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.386.1">
      n
     </span>
    </strong>
    <span class="koboSpan" id="kobo.387.1">
     becomes
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.388.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.389.1">
     ), return the total count of 1 bits.
    </span>
    <span class="koboSpan" id="kobo.389.2">
     Not a very complicated process, just
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.390.1">
      raw work.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.391.1">
     It seems that this procedure of counting bits in numbers must be of a very peculiar interest in computing circles, such as for the purpose of error detection and correction, data compression, cryptography, algorithmic efficiency, digital signal processing, hardware design, and performance metrics, so no wonder it managed to creep itself into the STL (C++ STL, which is the standard template library) too in the form of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.392.1">
      std::popcount
     </span>
    </strong>
    <span class="koboSpan" id="kobo.393.1">
     from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.394.1">
      C++ 20.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.395.1">
     The
    </span>
    <a id="_idIndexMarker310">
    </a>
    <span class="koboSpan" id="kobo.396.1">
     interesting part of the story is that not only in the STL do we find this handy operation, but it was deemed so useful that it even exists at the level of the processors, under the
    </span>
    <a id="_idIndexMarker311">
    </a>
    <span class="koboSpan" id="kobo.397.1">
     infamous
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.398.1">
      POPCNT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.399.1">
     mnemonic.
    </span>
    <span class="koboSpan" id="kobo.399.2">
     Infamous it is, due to the fact that in 2024, it was effectively used in hindering the installation of Windows 11 on older machines that were not officially
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.400.1">
      supported
     </span>
    </span>
    <span class="No-Break">
     <span class="superscript">
      <span id="footnote-022-backlink">
       <a class="_idFootnoteLink _idGenColorInherit" href="B22235_08.xhtml#footnote-022">
        <span class="koboSpan" id="kobo.401.1">
         3
        </span>
       </a>
      </span>
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.402.1">
      .
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-022">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_08.xhtml#footnote-022-backlink">
      <span class="koboSpan" id="kobo.403.1">
       3
      </span>
     </a>
     <a href="https://www.theregister.com/2024/04/23/windows_11_cpu_requirements/">
      <span class="koboSpan" id="kobo.404.1">
       https://www.theregister.com/2024/04/23/windows_11_cpu_requirements/
      </span>
     </a>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.405.1">
     But what that means for our candidate, who has to write code to impress the interviewers, is that they can simply replace the complicated code from before with the following very
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.406.1">
      handy snippet:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.407.1">
int countOneBits(uint32_t n) {
    return std::popcount(n);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.408.1">
     Not forgetting to include the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.409.1">
      &lt;bit&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.410.1">
     header, after feeding the preceding program into
    </span>
    <a href="http://gcc.godbolt.org">
     <span class="koboSpan" id="kobo.411.1">
      gcc.godbolt.org
     </span>
    </a>
    <span class="koboSpan" id="kobo.412.1">
     ’s compilers, we get a strange mishmash of results.
    </span>
    <span class="koboSpan" id="kobo.412.2">
     The code compiled by GCC, regardless of the optimization level, always generates a variation of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.413.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.414.1">
countOneBits(unsigned int):
  sub rsp, 8
  mov edi, edi
  call __popcountdi2
  add rsp, 8
  ret</span></pre>
   <p>
    <span class="koboSpan" id="kobo.415.1">
     So, the code at some level disappears from our eyes into a strange call deep inside the libraries offered by GCC, called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.416.1">
      __popcountdi2
     </span>
    </strong>
    <span class="superscript">
     <span id="footnote-021-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_08.xhtml#footnote-021">
       <span class="koboSpan" id="kobo.417.1">
        4
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.418.1">
     .
    </span>
    <span class="koboSpan" id="kobo.418.2">
     In order to convince GCC to fully utilize the power of the processor that we are running the code on, we need to utilize some of the not-so-well-known command-line options, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.419.1">
      -march
     </span>
    </strong>
    <span class="koboSpan" id="kobo.420.1">
     (or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.421.1">
      -mpopcnt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.422.1">
     for this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.423.1">
      specific purpose).
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-021">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_08.xhtml#footnote-021-backlink">
      <span class="koboSpan" id="kobo.424.1">
       4
      </span>
     </a>
     <a href="https://gcc.gnu.org/onlinedocs/gccint/Integer-library-routines.html">
      <span class="koboSpan" id="kobo.425.1">
       https://gcc.gnu.org/onlinedocs/gccint/Integer-library-routines.html
      </span>
     </a>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.426.1">
     According to the
    </span>
    <a id="_idIndexMarker312">
    </a>
    <span class="koboSpan" id="kobo.427.1">
     official documentation,
    </span>
    <span class="superscript">
     <span id="footnote-020-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_08.xhtml#footnote-020">
       <span class="koboSpan" id="kobo.428.1">
        5
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.429.1">
     this command will select the appropriate processor instruction set in order to use the available extensions of the specific processor.
    </span>
    <span class="koboSpan" id="kobo.429.2">
     Since, at this stage, we know that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.430.1">
      POPCNT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.431.1">
     instruction was introduced in the early Core i5 and i7 processors, in the Nehalem family, we should simply specify the following to GCC:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.432.1">
      -march=nehalem
     </span>
    </strong>
    <span class="koboSpan" id="kobo.433.1">
     .
    </span>
    <span class="koboSpan" id="kobo.433.2">
     And now, not surprisingly, the compiler generates
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.434.1">
      the following:
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-020">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_08.xhtml#footnote-020-backlink">
      <span class="koboSpan" id="kobo.435.1">
       5
      </span>
     </a>
     <a href="https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html">
      <span class="koboSpan" id="kobo.436.1">
       https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html
      </span>
     </a>
    </p>
   </div>
   <pre class="source-code"><span class="koboSpan" id="kobo.437.1">
countOneBits(unsigned int):
  popcnt eax, edi
  ret</span></pre>
   <p>
    <span class="koboSpan" id="kobo.438.1">
     Interestingly, if we provide the compiler with just the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.439.1">
      -mpopcnt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.440.1">
     flag, then it generates an extra
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.441.1">
      xor eax, eax
     </span>
    </strong>
    <span class="koboSpan" id="kobo.442.1">
     (meaning it nulls the EAX register) so maybe we have witnessed some processor-specific extra optimizations by choosing the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.443.1">
      Nehalem architecture:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.444.1">
countOneBits(unsigned int):
  xor eax, eax
  popcnt eax, edi
  ret</span></pre>
   <p>
    <span class="koboSpan" id="kobo.445.1">
     We cannot squeeze more than this out of GCC; there is simply no lower level for this functionality, so we focus our attention on the next compiler on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.446.1">
      our list.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.447.1">
     Without explicitly asking to optimize the code, Clang also generates a generic call to a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.448.1">
      std::popcount
     </span>
    </strong>
    <span class="koboSpan" id="kobo.449.1">
     function, found somewhere in its libraries; however, explicitly asking to optimize the generated code, Clang at various levels of optimization yields
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.450.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.451.1">
countOneBits(unsigned int):
  mov eax, edi
  shr eax
  and eax, 1431655765
  sub edi, eax
  mov eax, edi
  and eax, 858993459
  shr edi, 2
  and edi, 858993459
  add edi, eax
  mov eax, edi
  shr eax, 4
  add eax, edi
  and eax, 252645135
  imul eax, eax, 16843009
  shr eax, 24
  ret</span></pre>
   <p>
    <span class="koboSpan" id="kobo.452.1">
     Surprising as it seems, there
    </span>
    <a id="_idIndexMarker313">
    </a>
    <span class="koboSpan" id="kobo.453.1">
     is a perfectly logical explanation for this code, found at the bit-twiddling site
    </span>
    <span class="superscript">
     <span id="footnote-019-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_08.xhtml#footnote-019">
       <span class="koboSpan" id="kobo.454.1">
        6
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.455.1">
     of Sean Eron Anderson at Stanford.
    </span>
    <span class="koboSpan" id="kobo.455.2">
     Not considering this extra detour, Clang behaves identically to GCC when it comes to handling architecture and specifying the subset of CPU extensions to use while
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.456.1">
      generating code.
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-019">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_08.xhtml#footnote-019-backlink">
      <span class="koboSpan" id="kobo.457.1">
       6
      </span>
     </a>
     <a href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel">
      <span class="koboSpan" id="kobo.458.1">
       https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel
      </span>
     </a>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.459.1">
     The last of the big three, Microsoft’s own (we know, tiny, squishy) C++ compiler handles the situation very similarly to Clang.
    </span>
    <span class="koboSpan" id="kobo.459.2">
     When asking to optimize the code while we specify an architecture that does not support the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.460.1">
      POPCNT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.461.1">
     instruction, it generates code like the one generated by Clang with low-level bit hacks, while if the architecture has support for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.462.1">
      POPCNT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.463.1">
     instruction, it will adjust to the correct type and will call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.464.1">
      POPCNT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.465.1">
     for the proper parameters (/std:c++latest /
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.466.1">
      arch:SSE4.2 /O1).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.467.1">
     Good work, tiny,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.468.1">
      squishy compiler.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-96">
    <a id="_idTextAnchor095">
    </a>
    <span class="koboSpan" id="kobo.469.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.470.1">
     Myths related to C++ programming are shaped by the language’s evolving history through time, the differences and various levels of mastery between the users of the language, and psychological needs within the developer community.
    </span>
    <span class="koboSpan" id="kobo.470.2">
     Early C++ compilers, which often generated less optimal code compared to modern compilers, contributed to myths about the language’s inefficiency and the necessity of manual optimization, such as rewriting entire routines using platform-specific
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.471.1">
      assembly languages.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.472.1">
     As compilers and language features have advanced, these myths persist, sometimes overshadowing modern best practices.
    </span>
    <span class="koboSpan" id="kobo.472.2">
     This, combined with a culture of elitism and a sense of mastery among C++ programmers, reinforces outdated perceptions, even as C++ continues to be seen as a powerful and versatile language for serious,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.473.1">
      performance-critical applications.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.474.1">
     In the upcoming chapter, we will host a beauty pageant of programming languages, quickly eliminating all but our favorite, and the process will culminate in the crowning of the undisputed queen, C++.
    </span>
    <span class="koboSpan" id="kobo.474.2">
     Admittedly, our admiration for this language is so profound that one might suspect the contest was rigged from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.475.1">
      very start.
     </span>
    </span>
   </p>
  </div>
 </body></html>