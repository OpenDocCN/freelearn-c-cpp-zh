# 第9章 公式解释

电子表格程序能够处理文本、数值和由四个算术运算符组成的公式。为了做到这一点，我们需要解释公式。我们还需要找到公式的来源（公式中引用的单元格）和单元格的目标（受单元格变化影响的单元格）。

在本章中，我们将探讨以下主题：

+   数值表达式的解释（扫描和解析）

+   解析和语法树

+   公式的评估

+   参考和矩阵

+   绘制单元格

+   单元格的加载和保存

在以下电子表格中，正在编辑的单元格是`C3`：

![公式解释](img/B05475_09_01.jpg)

# 公式解释

电子表格程序的核心是其解释公式的能力。当用户在单元格中输入一个公式时，它会被解释并计算其值。公式解释的过程分为三个独立的步骤。首先，给定输入字符串，**扫描器**生成**标记列表**，然后**解析器**生成**语法树**，最后**评估器**确定值。

![公式解释](img/B05475_09_02.jpg)

标记是公式中最不重要的部分。例如，`a1`被解释为引用，而`1.2`被解释为值。假设根据以下表格，单元格具有以下值，公式解释过程将如下所示。请记住，公式是以等号（`**=**`）开头的文本。

![公式解释](img/B05475_09_03.jpg)![公式解释](img/B05475_09_04.jpg)![公式解释](img/B05475_09_05.jpg)

## 标记

扫描器以字符串作为输入，并找到其最不重要的部分——其标记。标记之间的空格被忽略，扫描器对大小写没有区别。`Value`标记需要额外信息来跟踪实际值，这被称为**属性**。同样，`Reference`需要一个属性来跟踪引用。在这个应用中，有九种不同的标记：

**Token.h**

[PRE0]

| **Token** | **描述** |
| --- | --- |
| `Plus`, `Minus`, `Star`, 和 `Slash` | 这四个是算术运算符："`+`", "`-`", "`*`", 和 "`/`" |
| `LeftParenthesis` 和 `RightParenthesis` | 这是左右括号："`(`" 和 "`)`" |
| 值 | 这是一个数值，例如，`124`，`3.14`，或`-0.23`。无论是整数还是小数，都无关紧要。同样，如果存在小数点，它前面或后面是否有数字也无关紧要。然而，值必须至少包含一个数字。这需要一个类型为`double`的值作为属性。 |
| 参考 | 这是一个参考，例如，`b8, c6`。这需要一个`Reference`对象作为属性。 |
| 行尾 | 这是行尾，字符串中没有更多（非空格）字符。 |

如前所述，字符串`1.2 * (b2 + c3)`生成了下一页表中的令牌。列表末尾添加了行尾令牌。

| **文本** | **令牌** | **属性** |
| --- | --- | --- |
| 1.2 | 值 | 1.2 |
| * | 星号 |  |
| ( | 左括号 |  |
| b2 | 引用 | 行 `1`，列 `1` |
| + | 加号 |  |
| c3 | 引用 | 行 `2`，列 `2` |
| ) | 右括号 |  |
|  | 行尾 |  |

令牌在`Token`类中定义。令牌由一个令牌标识符、在值令牌的情况下一个双精度值，以及在引用令牌的情况下一个`Reference`对象组成。

**Token.h**

[PRE1]

**Token.cpp**

[PRE2]

## 树节点

如前所述，解析器生成一个语法树。更具体地说，它生成一个`Tree`类的对象（在第12章[辅助类](ch12.html "第12章。辅助类")中描述），这是一个具有节点类型的模板类：`TreeNode`。节点有10个标识符，类似于`Token`，值节点有一个双精度值作为其属性，引用节点有一个引用对象作为属性。

**TreeNode.h**

[PRE3]

当从文件或剪贴板缓冲区读取值时，使用默认构造函数。

[PRE4]

电子表格的一个单元格可以保存到文件中，也可以剪切、复制和粘贴，因此我们包含了以下方法：

[PRE5]

节点的标识符和值只能被检查，不能被修改。然而，引用可以被修改，因为它在用户复制单元格并将其粘贴到另一个位置时会被更新：

[PRE6]

**TreeNode.cpp**

[PRE7]

节点标识符、值和引用被写入和读取，如下所示：

[PRE8]

## `Scanner` – 生成令牌列表

`Scanner`类的任务是分组字符为令牌。例如，`*12.34*`被解释为值`*12.34*`。构造函数接受一个字符串作为参数，而`Scan`通过重复调用`NextToken`直到字符串为空来生成令牌列表。

**Scanner.h**

[PRE9]

当`NextToken`方法遇到字符串的末尾时，它返回`EndOfLine`。如果`ScanValue`和`ScanReference`方法遇到值或引用，则返回`true`：

[PRE10]

下一个令牌会不断地从缓冲区中读取，直到它为空：

[PRE11]

**Scanner.cpp**

[PRE12]

为了简单起见，向字符串中添加了`TEXT('\0')`；而不是检查剩余的文本是否为空，我们寻找`null`字符：

[PRE13]

`Scan`方法将缓冲区中的令牌添加到`tokenList`中，直到遇到`EndOfLine`。最后，返回列表：

[PRE14]

`NextToken`方法通过在缓冲区中找到下一个令牌来完成扫描器的实际工作。首先，我们跳过空白字符。当涉及到算术符号和括号时，提取令牌相当简单。我们只需检查缓冲区的下一个字符。当涉及到数值或引用时，这会变得稍微困难一些。为此，我们有两个辅助方法：`ScanValue`和`ScanReference`。看看以下代码：

[PRE15]

如果没有适用任何简单情况，标记可能是一个值或一个引用。`ScanValue` 和 `ScanReference` 方法会找出是否是这样。如果不是，扫描器遇到了未知字符，并抛出语法错误异常：

[PRE16]

`ScanValue` 使用 `_stscanf_s` 标准函数，这是 `sscanf` 的安全通用版本。返回值存储在 `fieldCount` 中，如果成功读取双精度值，则将其设置为 `1`。我们还需要读取的字符数，它存储在 `charCount` 中，以便从缓冲区中删除正确的字符数：

[PRE17]

`ScanReference` 检查前两个字符是否为字母和数字。如果是，它将提取引用的列和行：

[PRE18]

我们通过从 *a* 减去小写字母来提取列，这给出第一列的索引为零，并从缓冲区中删除字母。

[PRE19]

与 `ScanValue` 类似，我们通过调用 `_stscanf_s` 来提取行，它读取行整数值和字符数，我们使用这些信息来从缓冲区中删除读取的字符：

[PRE20]

## 解析器 – 生成语法树

用户输入一个以等号（**=**）开头的公式。解析器的任务是翻译扫描器的标记列表为语法树。有效公式的语法可以通过**语法**来定义。让我们从一个处理使用算术运算符的表达式的语法开始：

![解析器 – 生成语法树](img/B05475_09_06.jpg)

语法是一组规则。在先前的语法中，有八个规则。**公式**和**表达式**被称为**非终结符**；**行尾**、**值**以及字符**+**、**-**、*****、**/**、**(** 和 **)**被称为**终结符**。终结符和非终结符统称为符号。其中一条规则是语法的**起始规则**，在我们的例子中是第一条规则。起始规则左侧的符号被称为语法的**起始符号**，在我们的例子中是**公式**。

箭头可以读作“**是**”，先前的语法可以读作：

*公式是一个表达式后跟行尾。表达式是两个表达式的和、差、积、商，或者括号内的表达式、引用或数值。*

这是一个好的开始，但有几个问题。让我们测试字符串 *1 + 2 * 3* 是否被语法接受。我们可以通过进行**推导**来测试，从起始符号 `Formula` 开始，应用规则，直到只剩下终结符。以下推导中的数字指的是语法规则：

![解析器 – 生成语法树](img/B05475_09_07.jpg)

推导可以通过**解析树**的发展来表示。

![解析器 – 生成语法树](img/B05475_09_08.jpg)让我们尝试对同一个字符串进行另一种推导，这次按照不同的顺序应用规则。![解析器 – 生成语法树](img/B05475_09_09.jpg)

这个推导生成了一个不同的解析树，如下所示：

![解析器 – 生成语法树](img/B05475_09_10.jpg)

如果一个语法可以针对同一个输入字符串生成两个不同的解析树，那么它被认为是**歧义的**。第二个树显然违反了数学定律，即乘法的优先级高于加法，但语法并不知道这一点。避免歧义的一种方法是为每个优先级级别引入一组新的规则：

![解析器 – 生成语法树](img/B05475_09_11.jpg)

新的语法不是歧义的。如果我们用这个语法尝试我们的字符串，我们只能生成一个解析树，无论我们选择应用规则的顺序如何。有正式的方法可以证明语法不是歧义的；然而，这超出了本书的范围。请参阅本章末尾的参考文献。

![解析器 – 生成语法树](img/B05475_09_12.jpg)

这个推导给出了以下树。由于不可能从同一个输入字符串推导出两个不同的树，因此语法是**无歧义的**。

![解析器 – 生成语法树](img/B05475_09_13.jpg)

现在我们已经准备好编写解析器了。本质上，有两种类型的解析器：**自顶向下解析器**和**自底向上解析器**。正如术语所暗示的，自顶向下解析器从语法的起始符号和输入字符串开始，并尝试应用规则，直到我们只剩下终结符。自底向上解析器从输入字符串开始，并尝试反向应用规则，直到我们达到起始符号。

构建自底向上解析器是一个复杂的问题。通常不是手动完成的；相反，有**解析器生成器**为给定的语法构建一个**解析器表**和解析器实现的骨架代码。然而，自底向上解析的理论超出了本书的范围。

构建自顶向下解析器比构建自底向上解析器更容易。构建一个简单但效率低下的自顶向下解析器的一种方法是在随机顺序中应用所有可能的规则。如果我们遇到了死胡同，我们只需回溯并尝试另一条规则。一个更高效但相对简单的解析器是前瞻解析器。给定一个合适的语法，我们只需要查看下一个标记，就可以唯一确定要应用的规则。如果我们遇到了死胡同，我们不需要回溯；我们只需得出结论，即输入字符串根据语法是不正确的——它被称为**语法错误**。

实现一个前瞻解析器的第一次尝试可能是为语法中的每个规则编写一个函数。不幸的是，我们目前还不能这样做，因为这会导致一个像`Expression`这样的函数：

[PRE21]

你看到问题了吗？该方法在未改变输入流的情况下调用自身，这将导致无限次的递归调用。这被称为**左递归**。然而，我们可以通过简单的转换来解决该问题。

![解析器 – 生成语法树](img/B05475_09_14.jpg)

前面的规则可以转换为等价的规则集（其中epsilon ε表示空字符串）：

![解析器 – 生成语法树](img/B05475_09_15.jpg)

如果我们将这种转换应用于前面语法中的**表达式**和**项**规则，我们将得到以下语法：

![解析器 – 生成语法树](img/B05475_09_16.jpg)

让我们用我们的字符串*1 + 2 * 3*尝试这个新语法。

![解析器 – 生成语法树](img/B05475_09_17.jpg)

推导生成了以下解析树：

![解析器 – 生成语法树](img/B05475_09_18.jpg)

语法适合前瞻解析器的条件是，具有相同左侧符号的每个规则集必须以不同的终结符开始其右侧。如果没有空规则，它最多只能有一个以非终结符作为右侧第一个符号的规则。我们前面讨论的语法满足这些要求。

现在我们已经准备好编写解析器了。然而，解析器还应生成某种类型的输出，表示字符串。一种这样的表示是**语法树**，它可以被视为一个抽象的解析树——我们只保留必要的信息。例如，前面的解析树有一个匹配的语法，如下所示：

![解析器 – 生成语法树](img/B05475_09_19.jpg)

下面的代码是`Parser`类。其思路是，我们为每个具有相同左侧符号的规则集编写一个方法。每个这样的方法生成结果语法树的一部分。构造函数接受要解析的文本，并让扫描器生成一个标记列表。然后，`Parse`开始解析过程，并返回生成的语法树。如果在解析过程中发生错误，将抛出语法错误异常。当标记列表被解析后，我们应该确保列表中没有除`EndOfLine`之外的额外标记。此外，如果输入缓冲区完全为空（用户只输入了一个等号），列表中仍然有`EndOfLine`标记。

解析的结果是一个表示公式的语法树。例如，公式*a1 * c3 / 3.6 + 2.4 * (b2 - 2.4)*生成了以下语法树，我们利用了[第12章](ch12.html "第12章。辅助类")中的`Tree`类，*辅助类*。

![解析器 – 生成语法树](img/B05475_09_20.jpg)

如前文在 `TreeNode` 节中所述，有九种类型的语法树：四个算术运算符、一元加法和减法、括号内的表达式、引用和数值。我们实际上不需要括号来正确存储公式，因为表达式的优先级存储在语法树本身中。然而，我们需要它来从语法树中重新生成原始字符串，当它在单元格中写入时。

**Parser.h**

[PRE22]

`Parse` 方法被调用以解释用户输入的文本。它接收来自扫描器的标记列表，其中至少包含 `EndOfLine` 标记，并解析标记列表并接收指向语法树的指针。当标记列表被解析后，它会检查下一个标记是否为 `EndOfLine` 以确保缓冲区中没有多余的字符（除了空格）：

**Parser.cpp**

[PRE23]

`Match` 方法用于匹配列表中的下一个标记与期望的标记。如果它们不匹配或如果标记列表为空，则抛出一个语法错误异常。否则，下一个标记将从列表中移除：

[PRE24]

其余的方法实现了我们之前讨论的语法。对于 `Expression`、`NextExpression`、`Term`、`NextTerm` 和 `Factor` 符号，每个都有一个方法：

[PRE25]

`NextExpression` 方法负责处理加法和减法。如果下一个标记是 `Plus` 或 `Minus`，我们将其匹配并解析其右操作数。然后，我们创建并返回一个新的包含运算符的语法树。如果下一个标记既不是 `Plus` 也不是 `Minus`，我们假设适用另一条规则，并返回给定的左语法树：

[PRE26]

`NextTerm` 方法以类似于 `NextExpression` 的方式处理乘法和除法。记住，我们需要为语法中的每个优先级级别的方法集。

[PRE27]

`Factor` 方法解析括号内的值、引用和表达式。如果下一个标记是一元运算符（加号或减号），我们解析其表达式并创建一个包含表达式的语法树：

[PRE28]

如果下一个标记是左括号，我们将其匹配，解析随后的表达式，并匹配关闭的右括号：

[PRE29]

如果下一个标记是引用，我们接收带有其行和列的引用属性并匹配引用标记。我们创建一个新的包含引用的语法树。请注意，解析器不会检查引用是否有效（是否指向电子表格内的单元格）；这是公式值评估的任务：

[PRE30]

如果前面的任何标记都不适用，则用户输入了一个无效的表达式，并抛出一个语法错误异常：

[PRE31]

# 矩阵和引用

当存储电子表格的单元格时使用 `Matrix` 类，当访问电子表格中的单元格时使用 `Reference` 类。

## 引用类

`Reference` 类在 `Matrix` 类中持有单元格的行和列，如下一节所示：

**Reference.h**

[PRE32]

默认构造函数将行和列初始化为零。引用可以通过 `new` 关键字初始化，并赋值给另一个引用：

[PRE33]

比较运算符首先比较行。如果它们相等，则比较列：

[PRE34]

加法运算符分别对行和列进行加法和减法操作：

[PRE35]

`Clear` 方法将行和列都设置为零，如果行和列为零，则 `IsEmpty` 返回 `true`：

[PRE36]

`ToString` 方法返回表示引用的字符串：

[PRE37]

如果一个引用大于或等于最小引用且小于或等于最大引用，则它位于由最小和最大引用定义的引用块内：

[PRE38]

引用可以写入和读取到文件流、剪贴板和注册表中：

[PRE39]

行和列通过常量方法进行检查，通过非常量方法进行修改：

[PRE40]

**Reference.cpp**

[PRE41]

`ToString` 方法返回引用作为字符串。我们增加行数，意味着行零对应于 *1*。列被转换为字符，意味着列零对应于 *a*。如果行数或列数小于零，则返回 `?`：

[PRE42]

当与注册表通信时，我们使用 `WriteBuffer` 和 `ReadBuffer` 静态方法。为了使其工作，我们将行和列值放入 `ReferenceStruct` 结构体中：

[PRE43]

## `Matrix` 类

`Matrix` 类包含一组按行和列组织的单元格。

**Matrix.h**

[PRE44]

矩阵可以通过 `new` 关键字初始化或赋值给另一个矩阵；在这两种情况下，它们都调用 `Init` 来执行实际的初始化：

[PRE45]

索引运算符接受一个行或 `Reference` 对象。在行的情况下，返回一个列数组（技术上，返回其第一个值的地址），可以通过常规索引运算符进一步索引以获取缓冲区中的值。在引用的情况下，通过索引缓冲区的行和列直接访问值。请注意，在这个类中，垂直行坐标持有第一个索引，水平列坐标持有第二个索引：

[PRE46]

由于 `Matrix` 是一个模板类，我们将其方法的定义放在 `header` 文件中。默认构造函数允许默认单元格构造函数初始化单元格：

[PRE47]

复制构造函数和赋值运算符通过调用 `Init` 来复制单元格：

[PRE48]

# 单元格

单元格可以保持三种模式：（可能的空）文本、数值或公式。其模式存储在 `cellMode` 字段中。它可以保持 `TextMode`、`ValueMode` 或 `FormulaMode` 的值。类似于本章中的 `CalcDocument` 和前几章中的 `WordDocument`，我们在 **文本模式**、**数值模式** 和 **公式模式** 等表达式中引用 `cellMode` 的当前值。

`HeaderWidth`、`HeaderHeight`、`ColWidth` 和 `RowHeight` 是电子表格标题和单元格的大小。为了防止单元格文本覆盖单元格的边框，使用 `CellMargin`。电子表格由十行和四列组成。

**Cell.h**

[PRE49]

单元格可以在水平方向上左对齐、居中对齐、右对齐或两端对齐，并且在垂直方向上可以顶部对齐、居中对齐或底部对齐：

[PRE50]

当用户选择新菜单项时，会调用 `Clear` 方法，并在调用 `Reset` 之前清除单元格的字体和背景颜色，`Reset` 清除文本并将单元格设置为文本模式。`Reset` 也会在用户删除单元格时被调用，在这种情况下，文本会被清除，但字体或颜色不会被清除：

[PRE51]

当用户输入一个字符，该字符插入到当前字符之前或根据 `keyboardMode` 参数的值覆盖它时，会调用 `CharDown` 方法。当用户在单元格中的文本上双击时，`MouseToIndex` 计算被点击字符的索引：

[PRE52]

`Text` 和 `CaretList` 方法返回单元格的文本和光标矩形列表。

[PRE53]

单元格的字体和背景颜色都可以修改和检查，同样也可以修改水平和垂直对齐方式：

[PRE54]

`DrawCell` 方法用黑色绘制单元格的边框，用背景色填充单元格，并绘制文本。如果反转参数为 `true`，则所有颜色都会反转，这发生在单元格正在编辑或被标记的情况下：

[PRE55]

当用户开始编辑单元格时，会调用 `DisplayFormula` 方法。带有公式的单元格可以显示其值或其公式。当用户编辑单元格时，显示公式。当用户标记它时，显示其值。`DisplayFormula` 方法将值替换为公式（或错误信息，如果公式不正确）：

[PRE56]

`InterpretCell` 方法解释单元格的文本，该文本被解释为文本、数值或公式。如果公式包含语法错误，则抛出异常：

[PRE57]

在 `formula` 模式下，`GenerateSourceSet` 分析公式并返回所有引用的（可能为空）集合。在 `text` 或 `value` 模式下，返回一个空集合：

[PRE58]

在 `formula` 模式下，`TreeToString` 返回从语法树转换成字符串的公式，该字符串在编辑单元格时显示在单元格中：

[PRE59]

当用户剪切、复制和粘贴单元格时，它们的引用会更新。`UpdateTree` 更新公式模式下的所有引用：

[PRE60]

`HasValue` 方法返回 `true` 如果单元格包含一个值：在 `value` 模式下为 `true`，在 `text` 模式下为 `false`，在 `formula` 模式下如果已评估为值则为 `true`，如果发生评估错误（缺少值、引用超出范围、循环引用或除以零）则为 `false`：

[PRE61]

`Evaluate` 方法评估公式的语法树；`valueMap` 保存源集合中单元格的值：

[PRE62]

单元格可以保存到文件或剪切、复制和粘贴：

[PRE63]

如本节开头所述，单元格可以保存（可能为空）文本、数值或公式，由`cellMode`的值指示：

[PRE64]

单元格中的所有字符都持有相同的字体和背景颜色。单元格可以水平对齐在左、中、右或两端对齐，并且可以垂直对齐在顶部、居中或底部：

[PRE65]

`text`字段保存单元格中显示的文本。在`edit`模式下，它是用户当前输入的文本。在`mark`模式下，它是用户输入的文本（在文本模式下），用户输入的数值转换为文本，公式的计算值或错误消息（缺失值、引用超出范围、循环引用或除以零）：

[PRE66]

光标列表保存了`text`中每个字符的光标矩形。它还保存了最后一个字符之后的索引的矩形，这意味着光标列表的大小总是比文本多一个：

[PRE67]

当计算公式的值时，它可能得到一个值或我们之前讨论过的任何错误。如果单元格包含一个值，则`hasValue`为`true`，`value`包含实际值：

[PRE68]

当用户以`=*`开头输入公式时，它被`Scanner`和`Parser`类解释为语法树，并存储在`syntaxTreePtr`中：

[PRE69]

**Cell.cpp**

[PRE70]

单元格的宽度是列宽减去边距，其高度是行高减去边距：

[PRE71]

当创建单元格时，它是空的，它持有文本模式，它在水平和垂直方向上居中对齐，并且它持有系统字体，文本为黑色，背景为白色：

[PRE72]

复制构造函数和赋值运算符检查`syntaxTreePtr`是否为`null`，如果不是`null`，则动态复制，其构造函数继续递归地复制其子节点。仅仅复制指针是不够的，因为原始单元格或复制单元格的公式中可能有一个被更改，而另一个没有：

[PRE73]

复制构造函数和赋值运算符之间的一个区别是，在赋值运算符中我们删除了语法树指针，因为它可能指向动态分配的内存，而在复制构造函数中不是这样。如果它指向`null`，则`delete`运算符不执行任何操作：

[PRE74]

语法树是单元格中唯一的动态分配的内存。再次强调，如果指针为`null`，则`delete`不执行任何操作：

[PRE75]

`Clear`和`Reset`之间的区别是：

+   当用户选择**新建**菜单项时，会调用`Clear`，此时电子表格应完全清除，并且单元格的字体、颜色和对齐方式也应重置。

+   当用户删除单元格及其模式时，会调用`Reset`，此时其模式和文本应重置。

[PRE76]

## 字符输入

`CharDown`方法由`WindowProc`（它反过来由Windows系统调用）在用户按下图形字符时调用。如果输入索引位于文本的末尾（文本右侧一步），我们只需添加末尾的字符。如果不是文本的末尾，我们必须考虑键盘模式，它可以是插入或覆盖。

在插入的情况下，我们插入字符，在覆盖的情况下，我们覆盖位于编辑索引处的先前字符。与前几章中的文字处理器不同，我们不需要处理字体，因为单元格中的所有字符都有相同的字体：

[PRE77]

当用户双击单元格时，会调用`MouseToIndex`方法。首先，我们需要从鼠标位置减去单元格边距，然后遍历光标列表并返回鼠标击中的字符位置。如果用户击中第一个字符的左侧（居中对齐或右对齐），则返回零索引，如果他们击中最后一个字符的右侧（左对齐或居中对齐），则返回文本的大小，这对应于最后一个字符右侧的索引：

[PRE78]

## 绘制

当需要绘制单元格内容时，会调用`Draw`方法。文本的绘制相当直接——对于字符列表中的每个字符，我们只需在其光标矩形中绘制该字符。这个特定的单元格可能被标记或正在被编辑，在这种情况下，情况正好相反。在这种情况下，文本、背景和边框颜色被反转。为了不覆盖单元格的边框，我们还要考虑单元格边距：

[PRE79]

## 光标矩形列表生成

当用户向单元格的文本中添加或删除字符、更改其字体或对齐方式时，需要重新计算光标矩形。`GenerateCaretList`可以被认为是前几章中文字处理器的`GenerateParagraph`的简化版本。其任务是计算字符矩形，这些矩形用于设置光标、绘制文本和计算鼠标点击的索引。

首先，我们需要计算每个字符的宽度以及文本的宽度，以便设置其水平起始位置。在两端对齐的情况下，我们计算不带空格的文本宽度并计算空格的数量：

[PRE80]

当我们计算出文本宽度时，我们设置水平起始位置。在左对齐或两端对齐的情况下，起始位置设置为单元格边距。在两端对齐的情况下，我们还设置文本中每个空格的宽度。在右对齐的情况下，我们将单元格宽度与文本宽度的差值加到单元格边距上，以便将文本的最右侧部分放置在单元格的右边界上。在居中对齐的情况下，我们添加一半的差值，以便将文本放置在单元格的中间：

[PRE81]

垂直顶部位置以类似的方式设置。在顶部对齐的情况下，顶部位置设置为单元格边距。在底部对齐的情况下，我们将单元格高度与文本高度的差值加到单元格边距上，以便将文本的底部部分放置在单元格的底部边界。在居中对齐的情况下，我们添加一半的差值，以便将文本放置在单元格的中间：

[PRE82]

当水平起始位置和顶部垂直位置已设置后，我们遍历字符，并将每个字符的矩形添加到`caretList`中。请注意，在两端对齐的情况下，我们使用`spaceWidth`的值来处理空格：

[PRE83]

当每个矩形被添加时，我们将文本右侧字符的矩形添加到其中。我们将其宽度设置为单元格字体平均字符的宽度：

[PRE84]

## 公式解释

当用户单击或双击单元格时，其文本在文本或值模式下保持不变，但在公式模式下会发生变化。在公式模式下，公式的计算值以标记模式显示，而在编辑模式下，显示公式本身。`DisplayFormula`在公式模式下调用`TreeToString`，生成公式的文本：

[PRE85]

当用户通过按***Enter***或***Tab***键或单击鼠标来终止文本输入时，会调用`InterpretCell`方法。如果用户输入了一个公式（以`=*`开头），则对其进行解析。`Parse`返回包含公式的语法树或抛出语法错误时的异常。请注意，`InterpretCell`仅报告语法错误。所有其他错误（缺失值、引用超出范围、循环引用或除以零）都由下面的`Evaluate`处理：

[PRE86]

`GenerateSourceSet`方法遍历语法树，并在公式模式下提取所有引用的（可能为空）集合。在文本或值模式下，集合为空，因为只有公式包含引用：

[PRE87]

在一元加法或减法或括号内的表达式中，返回其子节点的源集：

[PRE88]

在二元表达式中，返回两个子集的源集的并集：

[PRE89]

在引用的情况下，如果它位于电子表格中，则返回仅包含引用的集合。集合中不包含电子表格外的任何引用：

[PRE90]

最后，在值的情况下，返回一个空集：

[PRE91]

`TreeToString`方法遍历语法树并将其转换为字符串。请注意，可能存在具有超出作用域引用的公式。然而，在这种情况下，`Reference`类返回`?`：

[PRE92]

在一元加法或减法的情况下，将`+`或`-`添加到子节点文本中：

[PRE93]

在二元表达式`+`、`-`、`*`或`/`之间插入子节点文本：

[PRE94]

在括号内的表达式的情况下，返回括号内子节点的文本：

[PRE95]

在引用的情况下，返回其文本。再次强调，如果引用超出范围，`?`会被返回：

[PRE96]

在值的情况下，返回其转换后的文本：

[PRE97]

当用户复制粘贴一组单元格时，每个公式的引用是相对的，并且会更新。`UpdateTree`会在语法树中查找并更新引用。在所有其他情况下，它会遍历子列表，并对每个子项递归调用`UpdateTree`（一元表达式和括号表达式各有一个子项，二元表达式有两个子项，值或引用没有子项）：

[PRE98]

当公式的值被评估时，它可能返回一个有效值，在这种情况下，`hasValue`被设置为`true`。然而，如果在评估过程中发生错误（值缺失、引用超出范围、循环引用或除以零），`hasValue`被设置为`false`。当评估另一个单元格的公式值时，会调用`hasValue`。如果它返回`false`，评估将导致缺失值错误：

[PRE99]

在公式模式下，公式正在被评估为值。如果发生错误（值缺失、引用超出范围、循环引用或除以零），`Evaluate`会抛出异常，并将单元格文本设置为错误消息文本。请注意，可以输入超出范围的引用，`InterpretCell`可以接受这些引用。然而，`Evaluate`会抛出一个包含错误消息的异常，该错误消息会在单元格中显示。

此外，完全有可能剪切、复制和粘贴一个单元格，使其引用超出范围，然后再次剪切、复制和粘贴，使引用变得有效。然而，如果用户编辑超出范围的引用的公式，`Reference`类的`ToString`方法会返回`?`，因为很难用负列表示引用：

[PRE100]

`Evaluate`方法通过查找公式引用的单元格的值来找到单元格的当前值：

[PRE101]

在一元或二元表达式的情况下，值会被计算（一元加法只是为了完整性，不会改变值）：

[PRE102]

在除以零的情况下，会抛出异常。

[PRE103]

在括号内的表达式的情况下，我们只需返回其评估值：

[PRE104]

在引用的情况下，我们在`valueMap`中查找源单元格。在源单元格缺失值（不在`valueMap`中）或引用超出范围（引用工作表外的单元格）的情况下，会抛出异常：

[PRE105]

在值的情况下，我们直接返回该值：

[PRE106]

## 文件管理

每次用户从文件菜单中选择**保存**或**另存为**菜单项时，`CalcDocument`都会调用`WriteDocumentToStream`方法。在公式模式下，我们在语法树上调用`WriteTreeToStream`：

[PRE107]

在`ReadCellFromStream`中，我们动态地在公式模式下创建和读取语法树：

[PRE108]

当用户剪切、复制和粘贴单元格时，`CalcDocument`会调用`WriteCellToClipboard`和`ReadCellFromClipboard`方法。它的工作方式与之前我们看到的`WriteDocumentToStream`和`ReadCellFromStream`相同：

[PRE109]

# 进一步阅读

如果本章的扫描器和解析器让你对编译器产生了兴趣，我建议你参考A. V. Aho等人所著的《编译原理、技术和工具》（第二版，Addison Wesley，2007）。这是经典之作《龙书》的第二版。作者从扫描和解析到高级优化，解释了编译器的理论和实践。

如果图的概念引起了你的兴趣，我推荐D. B. West所著的《图论导论》（Prentice Hall，2000），它从数学的角度对图进行推理。

# 摘要

在本章中，我们介绍了电子表格程序的实施。本章结束了本书的第一部分：如何使用小窗口开发应用程序。[第10章](ch10.html "第10章。框架")，《框架》，介绍了第二部分：小窗口的实现。
