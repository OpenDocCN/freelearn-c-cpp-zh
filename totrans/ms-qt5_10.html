<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10.   Need IPC? Get Your Minions to Work  </h1></div></div></div><p>In the previous chapter, you learned how to send information across threads of the same process. In this chapter, you will discover how to share data between threads of different processes. We will even share information between applications running on different physical computers. We will enhance the Mandelbrot generator application from <a class="link" title="Chapter 9.  Keeping Your Sanity with Multithreading" href="part0090.xhtml#aid-2LQIK2">Chapter 9</a>, <em>Keeping Your Sanity with Multithreading</em>. The Mandelbrot application will now only display results processed by the worker programs. These minions have only one mission: compute the tasks as fast as possible and return a result to your main application.</p><p>Here are the topics covered in this chapter:</p><div><ul class="itemizedlist"><li class="listitem">How two applications can communicate together</li><li class="listitem">Creating a multithreaded TCP server</li><li class="listitem">Reading and writing on a TCP socket</li><li class="listitem">Other IPC techniques like <code class="literal">QSharedMemory</code>, <code class="literal">QProcess</code>, and Qt D-Bus</li><li class="listitem">Network serialization using <code class="literal">QDataStream</code></li><li class="listitem">Computer clustering</li><li class="listitem">Inter-process communication techniques</li></ul></div><p>An <strong>IPC</strong> (<strong>inter-process communication</strong>) is a communication between two or more processes. They can be instances of the same or a different application. The Qt framework provides multiple modules to help you implement a communication between your applications. Most of these modules are cross-platform. Let's talk about the IPC tools provided by Qt.</p><p>The first tools are the TCP/IP sockets. They provide a bidirectional data exchange over a network. Therefore, you can use them to talk with processes on different computers. Moreover, the <code class="literal">loopback</code> interface allows you to communicate with processes running on the same computer. All the required classes are inside the <code class="literal">QtNetwork</code> module. This technique relies on a client-server architecture. Here is an example of the server part:</p><pre class="programlisting">QTcpServer* tcpServer = new QTcpServer(this); 
tcpServer-&gt;listen(QHostAddress::Any, 5000); 
 
connect(tcpServer, &amp;QTcpServer::newConnection, [tcpServer] { 
    QTcpSocket *tcpSocket = tcpServer-&gt;nextPendingConnection(); 
    QByteArray response = QString("Hello").toLatin1(); 
    tcpSocket-&gt;write(response); 
    tcpSocket-&gt;disconnectFromHost(); 
    qDebug() &lt;&lt; "Send response and close the socket"; 
}); 
</pre><p>The first step is to instantiate a <code class="literal">QTcpServer</code> class. It deals with the new incoming TCP connections. Then, we call the <code class="literal">listen()</code> function. You can provide a network interface and specify the port on which the server must listen for incoming connections. In this example, we listen on all network addresses (for example, <code class="literal">127.0.0.1</code>, <code class="literal">192.168.1.4</code>, and so on) on the port <code class="literal">5000</code>. When a client establishes a connection with this server, the <code class="literal">QTcpServer::newConnection()</code> signal is triggered. Let's break together this lambda slot:</p><div><ol class="orderedlist arabic"><li class="listitem">We retrieve the <code class="literal">QTcpSocket</code> class related to this new connection with a client.</li><li class="listitem">A <code class="literal">QByteArray</code> response is prepared with the ASCII message "Hello". Forget the lack of originality.</li><li class="listitem">The message is sent to the client through the socket.</li><li class="listitem">Finally, we close the socket. So the client, on this side, will be disconnected.</li></ol><div></div><div><h3 class="title"><a id="tip45"/>Tip</h3><p>You can test a <code class="literal">QTcpServer</code> class with a telnet tool like Putty on Windows or the <code class="literal">telnet</code> command on Linux and Mac OS.</p></div><p>The following snippet is the client part:</p><pre class="programlisting">QTcpSocket *tcpSocket = new QTcpSocket(this); 
tcpSocket-&gt;connectToHost("127.0.0.1", 5000); 
 
connect(tcpSocket, &amp;QTcpSocket::connected, [tcpSocket] { 
    qDebug() &lt;&lt; "connected"; 
}); 
connect(tcpSocket, &amp;QTcpSocket::readyRead, [tcpSocket] { 
    qDebug() &lt;&lt; QString::fromLatin1(tcpSocket-&gt;readAll()); 
}); 
connect(tcpSocket, &amp;QTcpSocket::disconnected, [tcpSocket] { 
    qDebug() &lt;&lt; "disconnected"; 
}); 
</pre><p>The client also uses a <code class="literal">QTcpSocket</code> class to communicate. It turns out that the connection is initiated by the client, therefore we need to call the <code class="literal">connectToHost()</code> function with the server address and port. This class provides a lot of useful signals such as <code class="literal">connected()</code> and <code class="literal">disconnected()</code> that indicate the connection status. The <code class="literal">readyRead()</code> signal is emitted when new data is available for reading. The <code class="literal">readAll()</code>function returns <code class="literal">QByteArray</code> with all the available data. In our case, we know that the server sends an ASCII message to its client. Thus, we can convert this byte array in a <code class="literal">QString</code> and display it.</p><p>For this example, the server writes in the TCP socket and the client reads in it. But this communication is bidirectional, so the client can also write data and the server can read it. Try to send data from the client and display it in the server. Notice that you need to keep the communication alive by removing the <code class="literal">disconnectFromHost()</code> call in the server part.</p><p>The Qt framework provides a helper class, <code class="literal">QDataStream,</code> to easily send a complex object and handle the package fragmentation. This notion will be covered later with the project example of this chapter.</p><p>Let's talk about the second IPC technique: <strong>shared memory</strong>. By default, different processes do not use the same memory space. The <code class="literal">QSharedMemory</code> class provides a cross-platform method to create and use a shared memory across multiple processes. Nevertheless, the processes must run on the same computer. A shared memory is identified by a key. All the processes must use the same key to share the same shared memory segment. The first process will create the shared memory segment and put data in it:</p><pre class="programlisting">QString sharedMessage("Hello"); 
QByteArray sharedData = sharedMessage.toLatin1(); 
 
QSharedMemory* sharedMemory = new QSharedMemory( 
    "sharedMemoryKey", this); 
sharedMemory-&gt;create(sharedMessage.size()); 
 
sharedMemory-&gt;lock(); 
 
memcpy(sharedMemory-&gt;data(), 
       sharedData.data(), 
       sharedData.size()); 
 
sharedMemory-&gt;unlock(); 
</pre><p>Let's analyze all the steps together:</p><div><ol class="orderedlist arabic"><li class="listitem">Once again, we want to share the <code class="literal">QString</code> "Hello" converted in a <code class="literal">QByteArray</code> class.</li><li class="listitem">A <code class="literal">QSharedMemory</code> class is initialized with the key, <code class="literal">sharedMemoryKey</code>. This same key should be used by the second process.</li><li class="listitem">The first process creates the shared memory segment with a specific size in bytes. The creation also attaches the process to the shared memory segment.</li><li class="listitem">You should now be confident with the lock/unlock system. The <code class="literal">QSharedMemory</code> class uses semaphore to protect the shared access. You must lock it before manipulating the shared memory.</li><li class="listitem">A classical <code class="literal">memcpy()</code> function is used to copy data from the <code class="literal">QByteArray</code> class to the <code class="literal">QSharedMemory</code> class.</li><li class="listitem">Finally, we can unlock the shared memory.</li></ol><div></div><p>Destroying a <code class="literal">QShareMemory</code> class will call the <code class="literal">detach()</code> function that detaches the process from the shared memory segment. If this process was the last one attached, <code class="literal">detach()</code> also destroys the shared memory segment. While an attached <code class="literal">QShareMemory</code> is alive, the shared memory segment is available for other processes. The next snippet describes how a second segment can access the shared memory:</p><pre class="programlisting">QSharedMemory* sharedMemory = new QSharedMemory( 
    "sharedMemoryKey", this); 
sharedMemory-&gt;attach(); 
 
sharedMemory-&gt;lock(); 
 
QByteArray sharedData(sharedMemory-&gt;size(), '\0'); 
 
memcpy(sharedData.data(), 
       sharedMemory-&gt;data(), 
       sharedMemory-&gt;size()); 
sharedMemory-&gt;unlock(); 
 
QString sharedMessage = QString::fromLatin1(sharedData); 
qDebug() &lt;&lt; sharedMessage; 
 
sharedMemory-&gt;detach(); 
</pre><p>Here are the key steps:</p><div><ol class="orderedlist arabic"><li class="listitem">As with the first process, this second process initializes a <code class="literal">QShareMemory</code> class with the key, <code class="literal">sharedMemoryKey</code>.</li><li class="listitem">Then we attach the process to the shared memory segment with the <code class="literal">attach()</code> function.</li><li class="listitem">We must lock the <code class="literal">QShareMemory</code> class before accessing it.</li><li class="listitem">We initialize a <code class="literal">QByteArray</code> with the null character, <code class="literal">\0</code>, with the size of the shared memory.</li><li class="listitem">The <code class="literal">memcpy()</code> function copies the data from the <code class="literal">QShareMemory</code> to the <code class="literal">QByteArray</code>.</li><li class="listitem">We can convert the <code class="literal">QByteArray</code> in a <code class="literal">QString</code> and display our message.</li><li class="listitem">The last step is to call the <code class="literal">detach()</code>function to detach the process from the shared memory segment.</li></ol><div></div><p>Please notice that <code class="literal">create()</code> and <code class="literal">attach()</code> functions specify by default a <code class="literal">QShareMemory::ReadWrite</code> access. You can also use the <code class="literal">QShareMemory::ReadOnly</code> access.</p><div><h3 class="title"><a id="tip46"/>Tip</h3><p>You can use the classes, <code class="literal">QBuffer</code> and <code class="literal">QDataStream</code> to serialize a complex object in or from a bytes array.</p></div><p>Another IPC way is to use the <code class="literal">QProcess</code> class. The main process starts an external application as a child process. The communication is done using the standard input and output devices. Let's create a <code class="literal">hello</code> console application relying on the standard input and output channels:</p><pre class="programlisting">QTextStream out(stdout); 
QTextStream in(stdin); 
 
out &lt;&lt; QString("Please enter your name:\n"); 
out.flush(); 
 
QString name = in.readLine(); 
 
out &lt;&lt; "Hello " &lt;&lt; name &lt;&lt; "\n"; 
return 0; 
</pre><p>We use the <code class="literal">QTextStream</code> class to easily work with the standards streams, <code class="literal">stdout</code> and <code class="literal">stdin</code>. The application prints the message <code class="literal">Please enter your name:</code>. Then we wait while the user types his name by calling the <code class="literal">readLine()</code> function. Finally, the program displays the message <code class="literal">Hello</code> and the user <code class="literal">name</code>. If you start yourself this console application, you must type your name on the keyboard to see the final hello message with your name.</p><p>The following snippet runs and communicates with the <code class="literal">hello</code> application. Furthermore, we can programmatically control the child <code class="literal">hello</code> application:</p><pre class="programlisting">QProcess* childProcess = new QProcess(this); 
 
connect(childProcess,  
    &amp;QProcess::readyReadStandardOutput, [childProcess] { 
        qDebug().noquote() &lt;&lt; "[*]" &lt;&lt; childProcess-&gt;readAll(); 
}); 
 
connect(childProcess, &amp;QProcess::started, [childProcess] { 
    childProcess-&gt;write("Sophie\n"); 
}); 
 
childProcess-&gt;start("/path/to/hello"); 
</pre><p>Here are all the steps performed by this main application:</p><div><ol class="orderedlist arabic"><li class="listitem">We initialize a <code class="literal">QProcess</code> object that can start an external application.</li><li class="listitem">The child process displays messages on the console and so writes in the standard output. Then, the <code class="literal">readyReadStandardOutput()</code> signal is sent. In this case, we print the message as debug text with the prefix <code class="literal">[*]</code> to identify that it comes from the child process.</li><li class="listitem">As soon as the child process is started, the <code class="literal">started()</code> signal is sent. In our case, we write in the child standard input the name <code class="literal">Sophie</code> (Lenna will be jealous!).</li><li class="listitem">All is ready, we can start the <code class="literal">QProcess</code> class with the path to the <code class="literal">hello</code> console application.</li></ol><div></div><p>If you start the main application you should get this result in its console:</p><pre class="programlisting">[*] Please enter your name: 
[*] Hello Sophie 
</pre><p>Mission completed! The main application is a wrapper for the <code class="literal">hello</code> application. We receive all messages from the child process and we can send it some information like a specific name.</p><div><h3 class="title"><a id="tip47"/>Tip</h3><p>The <code class="literal">QProcess::start()</code> function also accepts a second variable: the command line arguments for the child process.</p></div><p>The last IPC mechanism that we will cover together is the <strong>D-Bus protocol</strong>. Currently, the Qt D-Bus module is officially supported only on Linux. If you need to use it on Windows, you will have to compile it from Qt sources. It can be seen as a unified protocol for IPC and <strong>RPC</strong> (<strong>remote procedure calling</strong>). Many forms of communication are possible, such as:</p><div><ul class="itemizedlist"><li class="listitem">One-to-one</li><li class="listitem">One-to-many</li><li class="listitem">Many-to-many</li></ul></div><p>The best thing about Qt D-Bus is that you can even use the signal/slot mechanism across the bus. A signal emitted from one application can be connected to a slot from another application. Linux desktop environments like KDE and GNOME use the D-Bus. That implies that you can (also) control your desktop with D-Bus.</p><p>Here are the main concepts of D-Bus:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">Bus</code>: This is used in many-to-many communication. D-Bus defines two buses: the <strong>system bus</strong> and the <strong>session bus</strong>.</li><li class="listitem"><code class="literal">Service name</code>: This is the identifier of a service on a bus.</li><li class="listitem"><code class="literal">Message</code>: This is a message sent by one application. If a bus is used, the message contains the destination.</li></ul></div><p>A Qt D-Bus Viewer tool can be found in your Qt installation folder (for example, <code class="literal">/Qt/5.7/gcc_64/bin/qdbusviewer</code>). All objects and messages from all services of the system and the session bus are displayed. Try to invoke exposed methods and retrieve a result.</p><p>Now that you have messed about with your Linux D-Bus services, it is time to create your own! At first, we will create a simple <code class="literal">HelloService</code> object:</p><pre class="programlisting">//HelloService.h 
class HelloService : public QObject 
{ 
    Q_OBJECT 
 
public slots: 
    QString sayHello(const QString &amp;name); 
}; 
 
//HelloService.cpp 
QString HelloService::sayHello(const QString&amp; name) 
{ 
    qDebug().noquote() &lt;&lt; name &lt;&lt; " is here!"; 
    return QString("Hello %1!").arg(name);; 
} 
</pre><p>No big deal here, the only function is a public slot that requires a <code class="literal">name</code>, displays who is here, and returns a hello message. In the following snippet, the main application registers a new D-Bus service and the <code class="literal">HelloService</code> object:</p><pre class="programlisting">HelloService helloService; 
QString serviceName("org.masteringqt.QtDBus.HelloService"); 
 
QDBusConnection::sessionBus().registerService(serviceName); 
QDBusConnection::sessionBus().registerObject("/",  
    &amp;helloService, QDBusConnection::ExportAllSlots); 
</pre><p>The main application initializes an <code class="literal">HelloService</code> object. Then, we register a new service named <code class="literal">org.masteringqt.QtDBus.HelloService</code> on the session bus. Finally, we register the <code class="literal">HelloService</code> object, exposing all its slots. Notice the simple object path <code class="literal">/</code> used for this example. The service application part is finished. Here is the client application calling the <code class="literal">HelloService</code> object:</p><pre class="programlisting">QString serviceName("org.masteringqt.QtDBus.HelloService"); 
QDBusInterface serviceInterface(serviceName, "/"); 
QDBusReply&lt;QString&gt; response = serviceInterface.call( 
    "sayHello", "Lenna"); 
qDebug().noquote() &lt;&lt; response; 
</pre><p>Let's analyze the client part step by step:</p><div><ol class="orderedlist arabic"><li class="listitem">We initialize a <code class="literal">QDBusInterface</code> object with the same service name and path as the service application.</li><li class="listitem">We call the remote method, <code class="literal">sayHello()</code> on <code class="literal">HelloService</code>, with the parameter <code class="literal">Lenna</code> (Wait, where is Sophie!?).</li><li class="listitem">The response is stored in a <code class="literal">QDBusReply</code> object. In our case, type <code class="literal">QString</code>.</li><li class="listitem">Finally, we display the message generated by the <code class="literal">HelloService</code> object.</li></ol><div></div><p>If you start the service application and then the client application, you should get this console output:</p><pre class="programlisting">//service application output 
Lenna is here! 
 
//client application output 
Hello Lenna! 
</pre><p>Use the <code class="literal">QDBusViewer</code> tool to find your D-Bus service. Select the <strong>Session Bus</strong> tab. Choose your service in the list. Then you can select the method <code class="literal">sayHello</code>. A right-click on it allows you to call the method. An input popup will ask you to fill the method parameter that is a name in our example. The following screenshot shows you what it looks like (it seems that Sophie is here):</p><div><img src="img/image00432.jpeg" alt="Need IPC? Get Your Minions to Work"/></div><p style="clear:both; height: 1em;"> </p><div><div><div><div><h1 class="title"><a id="ch10lvl1sec90"/>Architecturing an IPC project</h1></div></div></div><p>The Mandelbrot picture generator from <a class="link" title="Chapter 9.  Keeping Your Sanity with Multithreading" href="part0090.xhtml#aid-2LQIK2">Chapter 9</a>, <em>Keeping Your Sanity with Multithreading</em>, uses all cores of your computer to speed up the computing. This time, we want to use all the cores of all your computers! The first thing to do is to choose an appropriated IPC technique. For this project example, we want to establish communication between several clients acting as workers to a server running the main application. The TCP/IP sockets allows a one-to-many communication. Moreover, this IPC method is not bounded to a single computer and can operate through a network on multiple computers. This project example uses sockets by implementing a multi-threaded TCP server.</p><p>The next diagram describes the architecture:</p><div><img src="img/image00433.jpeg" alt="Architecturing an IPC project"/></div><p style="clear:both; height: 1em;"> </p><p>Let's talk about the global role of each actor:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">mandelbrot-app</code>: This is the main application displaying the Mandelbrot picture and handling user mouse events. However, in this chapter, the application does not compute the algorithm itself but rather generates requests to connected workers. Then, it aggregates results provided by workers.</li><li class="listitem"><code class="literal">mandelbrot-worker</code>: Here is our minion! A worker is a standalone program. It is connecting to the <code class="literal">mandelbrot-app</code> through a TCP socket. A worker receives a request, computes a job, and sends back a result.</li><li class="listitem"><code class="literal">SDK</code>: This regroups common stuff used by both applications. If the SDK changes, all the dependent applications must be updated.</li></ul></div><p>As you can see, this architecture fits well with the one-to-many communication required by this project. The <code class="literal">mandelbrot-app</code> application can use one or many workers to generate the same Mandelbrot picture.</p><p>Now that you get the big picture, let's look in detail at each module. You can see all of the classes in the SDK in the following diagram:</p><div><img src="img/image00434.jpeg" alt="Architecturing an IPC project"/></div><p style="clear:both; height: 1em;"> </p><p>An SDK is essential when you have several modules (applications, libraries, and so on) that communicate together or need to perform the same actions. You can give the SDK to a third-party developer without compromising your main source code. In our project, <code class="literal">mandelbrot-app</code> and <code class="literal">mandelbrot-worker</code> communicate together by exchanging <code class="literal">Message</code>. The message structure must be known by both entities. A <code class="literal">Message</code> class contains a <code class="literal">type</code> and a raw <code class="literal">data</code> of the type, <code class="literal">QByteArray</code>. Depending on the message <code class="literal">type</code>, the raw data can be empty or can contain an object. In this project, a message <code class="literal">data</code> can be a <code class="literal">JobRequest</code> or a <code class="literal">JobResult</code>. The <code class="literal">mandelbrot-app</code> sends a <code class="literal">JobRequest</code> to <code class="literal">mandelbrot-worker</code>. Then, the worker returns <code class="literal">JobResult</code> to the main application. Finally, <code class="literal">MessageUtils</code> contains functions used by the main application and the workers to send and retrieve a <code class="literal">Message</code>.</p><p>We can now talk about the <code class="literal">mandelbrot-worker</code> in more detail. The next diagram describes it:</p><div><img src="img/image00435.jpeg" alt="Architecturing an IPC project"/></div><p style="clear:both; height: 1em;"> </p><p>The <code class="literal">mandelbrot-worker</code> program is able to use all the CPU cores of a machine. The socket mechanism allows us to run it on multiple physical machines at the same time. The <code class="literal">WorkerWidget</code> class displays the status of the <code class="literal">Worker</code> object. The <code class="literal">Worker</code> object handles the communication with <code class="literal">mandelbrot-app</code> using a <code class="literal">QTcpSocket</code>. A <code class="literal">Job</code> is a <code class="literal">QRunnable</code> class that computes a task. Here is the workflow of this software:</p><div><ol class="orderedlist arabic"><li class="listitem">Send a register <code class="literal">Message</code> to <code class="literal">mandelbrot-app</code> application.</li><li class="listitem">Receive some <code class="literal">JobRequest</code> from <code class="literal">mandelbrot-app</code> and create several <code class="literal">Job</code> instances to complete all tasks.</li><li class="listitem">Each <code class="literal">Job</code> is running in a dedicated thread and will generate a <code class="literal">JobResult</code>.</li><li class="listitem">Send <code class="literal">JobResult</code> to <code class="literal">mandelbrot-app</code>.</li><li class="listitem">On exit, send an unregister <code class="literal">Message</code> to <code class="literal">mandelbrot-app</code>.</li></ol><div></div><p>It is now time to talk about the <code class="literal">mandelbrot-app</code> architecture. Look at the next diagram:</p><div><img src="img/image00436.jpeg" alt="Architecturing an IPC project"/></div><p style="clear:both; height: 1em;"> </p><p>This is the main application. You can launch it on a computer with a weak CPU and the real heavy work is done by workers running the <code class="literal">mandelbrot-worker</code> software. The GUI <code class="literal">MainWindow</code> and <code class="literal">MandelbrotWidget</code> objects are the same as those in <a class="link" title="Chapter 9.  Keeping Your Sanity with Multithreading" href="part0090.xhtml#aid-2LQIK2">Chapter 9</a>, <em>Keeping Your Sanity with Multithreading.</em> The <code class="literal">MandelbrotCalculator</code> class is a little different in this project, because it does not run any <code class="literal">QRunnable</code> itself. It is a TCP server that handles all registered workers and dispatches tasks to those tasks. Each <code class="literal">mandelbrot-worker</code> is managed by a <code class="literal">WorkerClient</code> object instance with a dedicated <code class="literal">QTcpSocket</code>. Here is the workflow for <code class="literal">mandelbrot-app</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">Run a TCP server on a specific port.</li><li class="listitem">Receive a register <code class="literal">Message</code> and create a <code class="literal">WorkerClient</code> object for each registered worker.</li><li class="listitem">When <code class="literal">MandelbrotWidget</code> requests a picture generation,
 <code class="literal">MandelbrotCalculator</code> creates the <code class="literal">JobRequest</code> object required to compute the full Mandelbrot picture.</li><li class="listitem">The <code class="literal">JobRequest</code> objects are sent to the workers.</li><li class="listitem">Receive and aggregate <code class="literal">JobResult</code> from the <code class="literal">mandelbrot-worker</code>.</li><li class="listitem">Transmit <code class="literal">JobResult</code> to the <code class="literal">MandelbrotWidget</code> object that displays the picture.</li><li class="listitem">If an unregister <code class="literal">Message</code> is received from a worker, the <code class="literal">WorkerClient</code> object is released and this worker will not be used for picture generation anymore.</li></ol><div></div><p>You should now get a complete overview of this project architecture. We can begin the implementation of this project. Create a <strong>Subdirs</strong> project called <code class="literal">ch10-mandelbrot-ipc</code>. As you might guess, we now create two sub-projects: <code class="literal">mandelbrot-app</code> and <code class="literal">mandelbrot-worker</code>.</p><p>The implementation in the subsequent sections follows the architecture presentation order:</p><div><ol class="orderedlist arabic"><li class="listitem">SDK.</li><li class="listitem"><code class="literal">mandelbrot-worker</code>.</li><li class="listitem"><code class="literal">mandelbrot-app</code>.</li></ol><div></div><p>The implementation is a step up in complexity. Do not hesitate to take a break and come back to this section to keep the overall architecture clear.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec91"/>Laying down the foundations with an SDK</h1></div></div></div><p>The first step is to implement the classes that will be shared between our application and the workers. To do so, we are going to rely on a custom SDK. If you need to refresh your memory about this technique, take a look at <a class="link" title="Chapter 8.  Animations - Its Alive, Alive!" href="part0081.xhtml#aid-2D7TI2">Chapter 8</a>, <em>Animations-- It's Alive, Alive!</em>.</p><p>As a reminder, here is the diagram describing the SDK:</p><div><img src="img/image00437.jpeg" alt="Laying down the foundations with an SDK"/></div><p style="clear:both; height: 1em;"> </p><p>Let's describe the job of each of these components:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">Message</code> component encapsulates a piece of information that is exchanged between the application and the worker</li><li class="listitem">The <code class="literal">JobRequest</code> component contains the necessary information to dispatch a proper job to a worker</li><li class="listitem">The <code class="literal">JobResult</code> component contains the result of the Mandelbrot set calculation for a given line</li><li class="listitem">The <code class="literal">MessageUtils</code> component contains helper functions to serialize/deserialize data across the TCP socket</li></ul></div><p>All these files have to be accessible from each side of our IPC mechanism (application and worker). Note that the SDK will contain only header files. We did it on purpose to simplify the SDK usage.</p><p>Let's start with <code class="literal">Message</code> implementation in the <code class="literal">sdk</code> directory. Create a <code class="literal">Message.h</code> file with the following content:</p><pre class="programlisting">#include &lt;QByteArray&gt; 
 
struct Message { 
 
    enum class Type { 
        WORKER_REGISTER, 
        WORKER_UNREGISTER, 
        ALL_JOBS_ABORT, 
        JOB_REQUEST, 
        JOB_RESULT, 
    }; 
 
    Message(const Type type = Type::WORKER_REGISTER, 
            const QByteArray&amp; data = QByteArray()) : 
        type(type), 
        data(data) 
    { 
    } 
 
    ~Message() {} 
 
    Type type; 
    QByteArray data; 
};  
</pre><p>The first thing to note is the <code class="literal">enum class Type</code> which details all the possible message types:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">WORKER_REGISTER</code>: This is the message sent by the worker when it first connects to the application. The content of the message is only the number of cores of the worker's CPU. We will see soon why this is useful.</li><li class="listitem"><code class="literal">WORKER_UNREGISTER</code>: This is the message sent by the worker when it is disconnected. This lets the application know that it should remove this worker from its list and stop sending any messages to it.</li><li class="listitem"><code class="literal">ALL_JOBS_ABORT</code>: This is the message sent by the application each time a picture generation is canceled. The worker is then responsible for canceling all its current local threads.</li><li class="listitem"><code class="literal">JOB_REQUEST</code>: This is the message sent by the application to calculate a specific line of the desired picture.</li><li class="listitem"><code class="literal">JOB_RESULT</code>: This is the message sent by the worker with the calculated result from the <code class="literal">JOB_REQUEST</code> inputs.</li></ul></div><p>A quick word about the <code class="literal">enum</code> class type, which is a C++11 addition. It is a safer version of enum (some might say that it is enum as it should have been from the beginning):</p><div><ul class="itemizedlist"><li class="listitem">The scope of the values is local. In this example, you can only reference an <code class="literal">enum</code> value with the syntax <code class="literal">Message::Type::WORKER_REGISTER</code>; no more <code class="literal">Message::WORKER_REGISTER</code> shortcuts. The good thing about this restriction is that you do not need to prefix <code class="literal">enum</code> values with a <code class="literal">MESSAGE_TYPE_</code> to be sure that the name does not conflict with anything else.</li><li class="listitem">There is no implicit conversion to <code class="literal">int</code>. The <code class="literal">enum</code> class acts like a real type, to cast an <code class="literal">enum</code> class to <code class="literal">int</code>, you have to write <code class="literal">static_cast&lt;int&gt;( Message::Type::WORKER_REGISTER)</code>.</li><li class="listitem">There is no forward declaration. You can specify that an <code class="literal">enum class</code> is a char type (with the syntax <code class="literal">enum class Test : char { ... }</code>), but the compiler will not be able to deduce the <code class="literal">enum</code> class size with a forward declaration. Therefore, it has been simply forbidden.</li></ul></div><p>We tend to use the <code class="literal">enum</code> class whenever possible, meaning when it does not clash with Qt <code class="literal">enum</code> usage.</p><p>As you can see, a message has only two members:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">type</code>: This is the message type we just described</li><li class="listitem"><code class="literal">data</code>: This is an opaque type that contains the piece of information to be transmitted</li></ul></div><p>We chose to make <code class="literal">data</code> very generic to place the responsibility of serializing/deserializing on the <code class="literal">Message</code> callers. Based on the message <code class="literal">type</code>, they should know how to read or write the message content.</p><p>By using this approach, we avoid a tangled class hierarchy with <code class="literal">MessageRegister</code>, <code class="literal">MessageUnregister</code>, and so on. Adding a new <code class="literal">Message type</code> is simply adding a value in the <code class="literal">Type enum class</code> and doing the proper serialization/deserialization in <code class="literal">data</code> (which you have to do anyway).</p><p>To see the file in Qt Creator, do not forget to add the <code class="literal">Message.h</code> in <code class="literal">ch10-mandelbrot-ipc.pro</code> file:</p><pre class="programlisting">OTHER_FILES += \ 
sdk/Message.h 
</pre><p>The next header we will look at is <code class="literal">JobRequest.h</code>:</p><pre class="programlisting">#include &lt;QSize&gt; 
#include &lt;QPointF&gt; 
 
struct JobRequest 
{ 
    int pixelPositionY; 
    QPointF moveOffset; 
    double scaleFactor; 
    QSize areaSize; 
    int iterationMax; 
}; 
 
Q_DECLARE_METATYPE(JobRequest) 
 
// In ch10-mandelbrot-ipc 
OTHER_FILES += \ 
    sdk/Message.h \ 
    sdk/JobRequest.h 
</pre><p>This <code class="literal">struct</code> element contains all the necessary data for the worker to calculate a line of the target Mandelbrot picture. Because the application and the worker(s) will live in different memory spaces (or even different physical machines), the parameters to calculate the Mandelbrot set have to be transmitted somehow. This is the purpose of <code class="literal">JobRequest</code>. The meaning of each field is the same as <code class="literal">JobResult</code> from <a class="link" title="Chapter 9.  Keeping Your Sanity with Multithreading" href="part0090.xhtml#aid-2LQIK2">Chapter 9</a>, <em>Keeping Your Sanity with Multithreading</em>.</p><p>Note the presence of the <code class="literal">Q_DECLARE_METATYPE(JobRequest)</code> macro. This macro is used to let the Qt meta-object system know about <code class="literal">JobRequest</code>. This is needed to be able to use the class in conjunction with <code class="literal">QVariant</code>. We will not use <code class="literal">QVariant</code> directly, but rather through the use of <code class="literal">QDataStream</code> which relies on <code class="literal">QVariant</code>.</p><p>Speaking of <code class="literal">JobResult</code>, here is the new <code class="literal">JobResult.h</code>:</p><pre class="programlisting">#include &lt;QSize&gt; 
#include &lt;QVector&gt; 
#include &lt;QPointF&gt; 
 
struct JobResult 
{ 
    JobResult(int valueCount = 1) : 
        areaSize(0, 0), 
        pixelPositionY(0), 
        moveOffset(0, 0), 
        scaleFactor(0.0), 
        values(valueCount) 
    { 
    } 
 
    QSize areaSize; 
    int pixelPositionY; 
    QPointF moveOffset; 
    double scaleFactor; 
 
    QVector&lt;int&gt; values; 
}; 
 
Q_DECLARE_METATYPE(JobResult) 
 
// In ch10-mandelbrot-ipc 
OTHER_FILES += \ 
    sdk/Message.h \ 
    sdk/JobRequest.h \ 
    sdk/JobResult.h 
</pre><p>The new version is a shameless copy-paste (with the small <code class="literal">Q_DECLARE_METATYPE</code> addition) of the project example of <a class="link" title="Chapter 9.  Keeping Your Sanity with Multithreading" href="part0090.xhtml#aid-2LQIK2">Chapter 9</a>, <em>Keeping Your Sanity with Multithreading</em>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec92"/>Working with QDataStream and QTcpSocket</h1></div></div></div><p>The missing piece of the SDK is <code class="literal">MesssageUtils</code>. It deserves a dedicated section because it covers two major topics: serialization and <code class="literal">QDataStream</code> transactions.</p><p>We will start with the serialization. We already know that <code class="literal">Message</code> stores only an opaque <code class="literal">QByteArray</code> data member. As a consequence, the desired data has to be serialized as a <code class="literal">QByteArray</code> before being passed to <code class="literal">Message</code>.</p><p>If we take the example of a <code class="literal">JobRequest</code> object, it is not directly sent. We first put in in a generic <code class="literal">Message</code> object with the appropriate <code class="literal">Message</code> type. The following diagram summarizes the sequence of actions to be done:</p><div><img src="img/image00438.jpeg" alt="Working with QDataStream and QTcpSocket"/></div><p style="clear:both; height: 1em;"> </p><p>The <code class="literal">JobRequest</code> object is first serialized to a <code class="literal">QByteArray</code> class; it is then passed to a <code class="literal">Message</code> instance which is in turn serialized to a final <code class="literal">QByteArray</code>. The deserialization process is the exact mirror of this sequence (from right to left).</p><p>Serializing data brings a lot of questions. How can we do it in a generic fashion? How do we handle the possible endianness of the CPU architecture? How do we specify the length of the data to be able to deserialize it properly?</p><p>Once again, the Qt folks did a great job and provided us a great tool to deal with these issues: <code class="literal">QDataStream</code>.</p><p>The <code class="literal">QDataStream</code> class enables you to serialize binary data to any <code class="literal">QIODevice</code> (<code class="literal">QAbstractSocket</code>, <code class="literal">QProcess</code>, <code class="literal">QFileDevice</code>, <code class="literal">QSerialPort</code>, and so on). The great advantage of <code class="literal">QDataStream</code> is that it encodes the information in a platform-agnostic format. You do not have to worry about the byte order, the operating system, or the CPU.</p><p>The <code class="literal">QDataStream</code> class implements the serialization of C++ primitive types and several Qt type (<code class="literal">QBrush</code>, <code class="literal">QColor</code>, <code class="literal">QString</code>, and so on). Here is an example of a basic write:</p><pre class="programlisting">QFile file("myfile"); 
file.open(QIODevice::WriteOnly); 
QDataStream out(&amp;file); 
out &lt;&lt; QString("QDataStream saved my day"); 
out &lt;&lt; (qint32)42; 
</pre><p>As you can see, <code class="literal">QDataStream</code> relies on the overload of the <code class="literal">&lt;&lt;</code> operator to write data. To read information, open the file with the correct mode and read with the <code class="literal">&gt;&gt;</code> operator.</p><p>Back to our case; we want to serialize custom classes, like <code class="literal">JobRequest</code>. To do so, we have to overload the <code class="literal">&lt;&lt;</code> operator for <code class="literal">JobRequest</code>. The signature of the function will be like so:</p><pre class="programlisting">QDataStream&amp; operator&lt;&lt;(QDataStream&amp; out,  
                        const JobRequest&amp; jobRequest) 
</pre><p>What we write have here is that we want to overload the <code class="literal">out &lt;&lt; jobRequest</code> operator call with our custom version. By doing so, we intend to fill the <code class="literal">out</code> object with the content of <code class="literal">jobRequest</code>. Because <code class="literal">QDataStream</code> already supports the serialization of primitive types, all we have to do is serialize them.</p><p>Here is the updated version of <code class="literal">JobRequest.h</code>:</p><pre class="programlisting">#include &lt;QSize&gt; 
#include &lt;QPointF&gt; 
#include &lt;QDataStream&gt; 
 
struct JobRequest 
{ 
   ... 
}; 
 
inline QDataStream&amp; operator&lt;&lt;(QDataStream&amp; out,  
                               const JobRequest&amp; jobRequest) 
{ 
    out &lt;&lt; jobRequest.pixelPositionY 
        &lt;&lt; jobRequest.moveOffset 
        &lt;&lt; jobRequest.scaleFactor 
        &lt;&lt; jobRequest.areaSize 
        &lt;&lt; jobRequest.iterationMax; 
    return out; 
} 
 
inline QDataStream&amp; operator&gt;&gt;(QDataStream&amp; in,  
                               JobRequest&amp; jobRequest) 
{ 
    in &gt;&gt; jobRequest.pixelPositionY; 
    in &gt;&gt; jobRequest.moveOffset; 
    in &gt;&gt; jobRequest.scaleFactor; 
    in &gt;&gt; jobRequest.areaSize; 
    in &gt;&gt; jobRequest.iterationMax; 
    return in; 
} 
</pre><p>We include <code class="literal">QDataStream</code> and overload the <code class="literal">&lt;&lt;</code> very easily. The returned <code class="literal">out</code> will be updated with the platform-agnostic content of the passed <code class="literal">jobRequest</code>. The <code class="literal">&gt;&gt;</code> operator overload follows the same pattern: we fill the <code class="literal">jobRequest</code> parameter with the content of the <code class="literal">in</code> variable. Behind the scenes, <code class="literal">QDataStream</code> stores the variable size in the serialized data to be able to read it afterwards.</p><p>Be careful to serialize and deserialize the members in the same order. If you do not pay attention to this, you might encounter very peculiar values in <code class="literal">JobRequest</code>.</p><p>The <code class="literal">JobResult</code> operators overload follows the same pattern, and it does not deserve to be included in the chapter. Look at the source code of the project if you have any doubt about its implementation.</p><p>On the other hand, <code class="literal">Message</code> operator overload needs to be covered:</p><pre class="programlisting">#include &lt;QByteArray&gt; 
#include &lt;QDataStream&gt; 
 
#include &lt;QByteArray&gt; 
#include &lt;QDataStream&gt; 
 
struct Message { 
    ... 
}; 
 
inline QDataStream &amp;operator&lt;&lt;(QDataStream &amp;out, const Message &amp;message) 
{ 
    out &lt;&lt;  static_cast&lt;qint8&gt;(message.type) 
        &lt;&lt; message.data; 
    return out; 
} 
 
inline QDataStream &amp;operator&gt;&gt;(QDataStream &amp;in, Message &amp;message) 
{ 
    qint8 type; 
    in &gt;&gt; type; 
    in &gt;&gt; message.data; 
 
    message.type = static_cast&lt;Message::Type&gt;(type); 
    return in; 
} 
</pre><p>Because the <code class="literal">Message::Type enum class</code> signal does not have an implicit conversion to <code class="literal">int</code>, we need to explicitly convert it to be able to serialize it. We know that there will not be more than 255 message types, therefore we can safely cast it to a <code class="literal">qint8</code> type.</p><p>The same story applies to the reading part. We start by declaring a <code class="literal">qint8 type</code> variable that will be filled with <code class="literal">in &gt;&gt; type</code>, and then, the <code class="literal">type</code> variable is casted to a <code class="literal">Message::Type</code> in <code class="literal">message</code>.</p><p>Our SDK classes are ready to be serialized and deserialized. Let's see it in action in <code class="literal">MessageUtils</code> with the serialization of a message and its writing to a <code class="literal">QTcpSocket</code> class.</p><p>Always in the <code class="literal">sdk</code> directory, create a <code class="literal">MessageUtils.h</code> header with the following content:</p><pre class="programlisting">#include &lt;QByteArray&gt; 
#include &lt;QTcpSocket&gt; 
#include &lt;QDataStream&gt; 
 
#include "Message.h" 
 
namespace MessageUtils { 
 
inline void sendMessage(QTcpSocket&amp; socket, 
                        Message::Type messageType, 
                        QByteArray&amp; data, 
                        bool forceFlush = false) 
{ 
    Message message(messageType, data); 
 
    QByteArray byteArray; 
    QDataStream stream(&amp;byteArray, QIODevice::WriteOnly); 
    stream &lt;&lt; message; 
    socket.write(byteArray); 
    if (forceFlush) { 
        socket.flush(); 
    } 
} 
</pre><p>There is no need to instantiate a <code class="literal">MessageUtils</code> class, as it does not hold any state. Here we used a <code class="literal">MessageUtils</code> namespace to simply protect our function against any name collision.</p><p>The meat of the snippet lies in <code class="literal">sendMessage()</code>. Let's look at the parameters:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">socket</code>: This is the <code class="literal">QTcpSocket</code> class in which the message will be sent. It is the responsibility of the caller to ensure that it is properly opened.</li><li class="listitem"><code class="literal">messageType</code>: This is the type of the message to be sent.</li><li class="listitem"><code class="literal">data</code>: This is the serialized data to be included in the message. It is a <code class="literal">QByteArray</code> class, meaning that the caller already serialized its custom class or data.</li><li class="listitem"><code class="literal">forceFlush</code>: This is a flag to force the socket to flush upon the message shipment. The OS keeps socket buffers that wait to be filled before being sent across the wire. Some messages need to be delivered immediately, like an abort all jobs message.</li></ul></div><p>In the function itself, we start by creating a message with the passed parameters. Then, a <code class="literal">QByteArray</code> class is created. This <code class="literal">byteArray</code> will be the receptacle of the serialized data.</p><p>As a matter of fact, <code class="literal">byteArray</code> is passed in the constructor of the <code class="literal">QDataStream</code> stream, which is opened in the <code class="literal">QIODevice::WriteOnly</code> mode. It means that the stream will output its data to the <code class="literal">byteArray</code>.</p><p>After that, the message is elegantly serialized to stream with <code class="literal">stream &lt;&lt; message</code> and the modified <code class="literal">byteArray</code> is written to the socket with <code class="literal">socket.write(byteArray)</code>.</p><p>Finally, if the <code class="literal">forceFlush</code> flag is set to <code class="literal">true</code>, the socket is flushed with <code class="literal">socket.flush()</code>.</p><p>Some messages will not have any payload associated. For this reason, we add a small helper function for this purpose:</p><pre class="programlisting">inline void sendMessage(QTcpSocket&amp; socket, 
                        Message::Type messageType, 
                        bool forceFlush = false) { 
    QByteArray data; 
    sendMessage(socket, messageType, data, forceFlush); 
} 
</pre><p>Now that the <code class="literal">sendMessage()</code> is done, let's turn to the <code class="literal">readMessages()</code>. Because we are working in IPC and more specifically with sockets, interesting issues arise when we want to read and parse messages.</p><p>When something is ready to be read in the socket, a signal will notify us. But how do we know how much to read? In the case of a <code class="literal">WORKER_DISCONNECT</code> message, there is no payload. On the other hand, a <code class="literal">JOB_RESULT</code> message can be very heavy. Even worse, several <code class="literal">JOB_RESULT</code> messages can line up in the socket, waiting to be read.</p><p>To make things more difficult, we have to acknowledge the fact that we are working with the network. Packets can be lost, retransmitted, incomplete or whatever. Sure, TCP ensures that we eventually get all of the information, but it can be delayed.</p><p>If we had to do it ourselves, it would have implied a custom message header, with a payload size and a footer for each message.</p><p>A feature introduced in Qt 5.7 comes to the rescue: <code class="literal">QDataStream</code> transaction. The idea is the following: when you start reading on a <code class="literal">QIODevice</code> class, you already know how much you have to read (based on the size of the object you want to fill). However, you might not get all the data in a single read.</p><p>If the read is not complete, <code class="literal">QDataStream</code> stores what was already read in a temporary buffer and restores it upon the next read. The next read will contain what was already loaded plus the content of the new read. You can see it as a checkpoint in the read stream that can be loaded later.</p><p>This process can be repeated until data is read. The official documentation provides a simple enough example:</p><pre class="programlisting">in.startTransaction(); 
qint8 messageType; 
QByteArray messageData; 
in &gt;&gt; messageType &gt;&gt; messageData; 
 
if (!in.commitTransaction()) 
    return; 
</pre><p>In the <code class="literal">QDataStream</code> class in which we want to read, <code class="literal">in.startTransaction()</code> marks the checkpoint in the stream. It will then try to read  <code class="literal">messageType</code> and <code class="literal">messageData</code> atomically. If it cannot do it, <code class="literal">in.commitTransaction()</code> returns <code class="literal">false</code> and the read data is copied in an internal buffer.</p><p>Upon the next call to this code (more data to read), <code class="literal">in.startTransaction()</code> will restore the preceding buffer and try to finish the atomic read.</p><p>In our <code class="literal">readMessages()</code> situation, we can receive several messages at once. This is why the code is a bit more complex. Here is the updated version of <code class="literal">MessageUtils</code>:</p><pre class="programlisting">#include &lt;memory&gt; 
#include &lt;vector&gt; 
#include &lt;QByteArray&gt; 
#include &lt;QTcpSocket&gt; 
#include &lt;QDataStream&gt; 
 
#include "Message.h" 
 
... 
 
inline std::unique_ptr&lt;std::vector&lt;std::unique_ptr&lt;Message&gt;&gt;&gt; readMessages(QDataStream&amp; stream) 
{ 
    auto messages = std::make_unique&lt;std::vector&lt;std::unique_ptr&lt;Message&gt;&gt;&gt;(); 
    bool commitTransaction = true; 
    while (commitTransaction 
                    &amp;&amp; stream.device()-&gt;bytesAvailable() &gt; 0) { 
        stream.startTransaction(); 
        auto message = std::make_unique&lt;Message&gt;(); 
        stream &gt;&gt; *message; 
        commitTransaction = stream.commitTransaction(); 
        if (commitTransaction) { 
            messages-&gt;push_back(std::move(message)); 
        } 
    } 
    return messages; 
} 
 
} 
</pre><p>In the function, the parameter is only a <code class="literal">QDataStream</code>. We assume that the caller linked the stream with the socket with <code class="literal">stream.setDevice(socket)</code>.</p><p>Because we do not know the length of the content to be read, we prepare ourselves to read several messages. To explicitly indicate ownership and avoid any memory leaks, we return a <code class="literal">vector&lt;unique_ptr&lt;Message&gt;&gt;</code>. This <code class="literal">vector</code> has to be a <code class="literal">unique_ptr</code> pointer to be able to allocate it on the heap and avoid any copy during the return of the function.</p><p>In the function itself, we start by declaring the <code class="literal">vector</code>. After that, a <code class="literal">while</code> loop is executed. The two conditions to stay in the loop are:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">commitTransaction == true</code>: This an atomic read in the stream that has been performed; a complete <code class="literal">message</code> has been read</li><li class="listitem"><code class="literal">stream.device().bytesAvailable() &gt; 0</code>: This states that there is still data to read in the stream</li></ul></div><p>In the <code class="literal">while</code> loop, we start by marking the stream with <code class="literal">stream.startTransaction()</code>. After that, we try to perform an atomic read of a <code class="literal">*message</code> signal and see the result with <code class="literal">stream.commitTransaction()</code>. If it succeeded, the new <code class="literal">message</code> is added to the <code class="literal">messages</code> vector. This is repeated until we read all the content of the stream with the <code class="literal">bytesAvailable() &gt; 0</code> test.</p><p>Let's study a use case to understand what will happen. Consider that we receive multiple messages in <code class="literal">readMessages()</code>:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">stream</code> object will try to read it into <code class="literal">message</code>.</li><li class="listitem">The <code class="literal">commitTransaction</code> variable will be set to <code class="literal">true</code> and the first message will be added to <code class="literal">messages</code>.</li><li class="listitem">If there are still bytes to read in the <code class="literal">stream</code>, repeat from step one. Otherwise, exit the loop.</li></ul></div><p>To sum up, working with sockets raises its own set of questions. On one hand, it is a very powerful IPC mechanism with a lot of flexibility. On the other hand, it brings a lot of complexity due the nature of the network itself. Luckily, Qt (and moreover Qt 5.7) brings great classes to help us.</p><p>Keep in mind that we tolerate the <code class="literal">QDataStream</code> serialization and transactions overhead because it fits well to our need. If you are working on a constrained embedded platform, you might not have so much liberty about serializing overhead and buffer copies. However, you will still have to rebuild messages by hand for incoming bytes.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec93"/>Interacting with sockets in the worker</h1></div></div></div><p>Now that the SDK is completed, we can turn to the worker. The project is complex enough; we can refresh our memory with the <code class="literal">mandelbrot-worker</code> architecture:</p><div><img src="img/image00439.jpeg" alt="Interacting with sockets in the worker"/></div><p style="clear:both; height: 1em;"> </p><p>We will start by implementing the <code class="literal">Job</code> class. Inside the <code class="literal">mandelbrot-worker</code> project, create a new C++ class named <code class="literal">Job</code>. Here is the <code class="literal">Job.h</code> content:</p><pre class="programlisting">#include &lt;QObject&gt; 
#include &lt;QRunnable&gt; 
#include &lt;QAtomicInteger&gt; 
 
#include "JobRequest.h" 
#include "JobResult.h" 
 
class Job : public QObject, public QRunnable 
{ 
    Q_OBJECT 
public: 
    explicit Job(const JobRequest&amp; jobRequest,  
                 QObject *parent = 0); 
    void run() override; 
 
signals: 
    void jobCompleted(JobResult jobResult); 
 
public slots: 
    void abort(); 
 
private: 
    QAtomicInteger&lt;bool&gt; mAbort; 
    JobRequest mJobRequest; 
}; 
</pre><p>If you remember the <code class="literal">Job</code> class from <a class="link" title="Chapter 9.  Keeping Your Sanity with Multithreading" href="part0090.xhtml#aid-2LQIK2">Chapter 9</a>, <em>Keeping Your Sanity with Multithreading</em>, this header should ring a bell. The only difference is that the parameters of the job (area size, scale factor, and so on) are extracted from the <code class="literal">JobRequest</code> object rather than stored directly as member variables.</p><p>As you can see, the <code class="literal">JobRequest</code> object is provided in the constructor of <code class="literal">Job</code>. We will not cover <code class="literal">Job.cpp</code>, as it is very much like the version of it in <a class="link" title="Chapter 9.  Keeping Your Sanity with Multithreading" href="part0090.xhtml#aid-2LQIK2">Chapter 9</a>, <em>Keeping Your Sanity with Multithreading</em>.</p><p>We now proceed to the <code class="literal">Worker</code> class. This class has the following roles:</p><div><ul class="itemizedlist"><li class="listitem">It interacts with the <code class="literal">mandelbrot-app</code> using a <code class="literal">QTcpSocket</code> class</li><li class="listitem">It dispatches <code class="literal">JobRequests</code> to a <code class="literal">QThreadPool</code> class, aggregates the results, and sends them back to <code class="literal">mandelbrot-app</code> application through the <code class="literal">QTcpSocket</code> class</li></ul></div><p>We will start by studying the interaction with the <code class="literal">QTcpSocket</code> class. Create a new class named <code class="literal">Worker</code> with the following header:</p><pre class="programlisting">#include &lt;QObject&gt; 
#include &lt;QTcpSocket&gt; 
#include &lt;QDataStream&gt; 
 
#include "Message.h" 
#include "JobResult.h" 
 
class Worker : public QObject 
{ 
    Q_OBJECT 
public: 
    Worker(QObject* parent = 0); 
    ~Worker(); 
 
private: 
    void sendRegister(); 
 
private: 
    QTcpSocket mSocket; 
}; 
</pre><p>The <code class="literal">Worker</code> class is the owner of <code class="literal">mSocket</code>. The first thing we will implement is the connection with <code class="literal">mandelbrot-app</code>. Here is the constructor of <code class="literal">Worker</code> in <code class="literal">Worker.cpp</code>:</p><pre class="programlisting">#include "Worker.h" 
 
#include &lt;QThread&gt; 
#include &lt;QDebug&gt; 
#include &lt;QHostAddress&gt; 
 
#include "JobRequest.h" 
#include "MessageUtils.h" 
 
Worker::Worker(QObject* parent) : 
    QObject(parent), 
    mSocket(this) 
{ 
    connect(&amp;mSocket, &amp;QTcpSocket::connected, [this] { 
        qDebug() &lt;&lt; "Connected"; 
        sendRegister(); 
    }); 
    connect(&amp;mSocket, &amp;QTcpSocket::disconnected, [] { 
        qDebug() &lt;&lt; "Disconnected"; 
    }); 
 
    mSocket.connectToHost(QHostAddress::LocalHost, 5000); 
} 
</pre><p>The constructor initializes <code class="literal">mSocket</code> with <code class="literal">this</code> as the parent and it then proceeds to connecting the relevant <code class="literal">mSocket</code> signals to lambdas:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">QTcpSocket::connected</code>: When the socket is connected, it will send its register message. We will soon cover this function</li><li class="listitem"><code class="literal">QTcpSocket::disconnected</code>: When the socket is disconnected, it simply prints a message in the console</li></ul></div><p>Finally, <code class="literal">mSocket</code> tries to connect on the <code class="literal">localhost</code> on the port <code class="literal">5000</code>. In the code example, we assume that you execute the worker and the application on the same machine. Feel free to change this value if you run the worker and the application on different machines.</p><p>The body of <code class="literal">sendRegister()</code> function looks like this:</p><pre class="programlisting">void Worker::sendRegister() 
{ 
    QByteArray data; 
    QDataStream out(&amp;data, QIODevice::WriteOnly); 
    out &lt;&lt; QThread::idealThreadCount(); 
    MessageUtils::sendMessage(mSocket, 
                              Message::Type::WORKER_REGISTER, 
                              data); 
} 
</pre><p>A <code class="literal">QByteArray</code> class is filled with the <code class="literal">idealThreadCount</code> function of the worker's machine. After that, we call <code class="literal">MessageUtils::sendMessage</code> to serialize the message and send it through our <code class="literal">mSocket</code>.</p><p>Once the worker is registered, it will start to receive job requests, process them, and send job results back. Here is the updated <code class="literal">Worker.h</code>:</p><pre class="programlisting">class Worker : public QObject 
{ 
    ... 
signals: 
    void abortAllJobs(); 
 
private slots: 
    void readMessages(); 
 
private: 
    void handleJobRequest(Message&amp; message); 
    void handleAllJobsAbort(Message&amp; message); 
    void sendRegister(); 
    void sendJobResult(JobResult jobResult); 
    void sendUnregister(); 
    Job* createJob(const JobRequest&amp; jobRequest); 
 
private: 
    QTcpSocket mSocket; 
    QDataStream mSocketReader; 
    int mReceivedJobsCounter; 
    int mSentJobsCounter; 
}; 
</pre><p>Let's review the role of each one of these new members:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">mSocketReader</code>: This is the <code class="literal">QDataStream</code> class through which we will read <code class="literal">mSocket</code> content. It will be passed as a parameter to our <code class="literal">MessageUtils::readMessages()</code> function.</li><li class="listitem"><code class="literal">mReceivedJobsCounter</code>: This is incremented each time a new <code class="literal">JobRequest</code> is received from <code class="literal">mandelbrot-app</code>.</li><li class="listitem"><code class="literal">mSentJobsCounter</code>: This is incremented each time a new <code class="literal">JobResult</code> is sent to <code class="literal">mandelbrot-app</code>.</li></ul></div><p>Now for the new functions:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">abortAllJobs()</code>: This is a signal emitted when the <code class="literal">Worker</code> class receives the appropriate message.</li><li class="listitem"><code class="literal">readMessages()</code>: This is the slot called each time there is something to read in <code class="literal">mTcpSocket</code>. It parses the messages and, for each message type, it will call the corresponding function.</li><li class="listitem"><code class="literal">handleJobRequest()</code>: This function creates and dispatches a <code class="literal">Job</code> class according to the <code class="literal">JobRequest</code> object contained in the message parameter.</li><li class="listitem"><code class="literal">handleAllJobsAbort()</code>: This function cancels all the current jobs and clear the thread queue.</li><li class="listitem"><code class="literal">sendJobResult()</code>: This function sends the <code class="literal">JobResult</code> object to <code class="literal">mandelbrot-app</code>.</li><li class="listitem"><code class="literal">sendUnregister()</code>: This function sends the unregister message to <code class="literal">mandelbrot-app</code>.</li><li class="listitem"><code class="literal">createJob()</code>: This is a helper function to create and properly connect the signals of a new <code class="literal">Job</code>.</li></ul></div><p>The header is now complete. We can proceed to the updated constructor in <code class="literal">Worker.cpp</code>:</p><pre class="programlisting">Worker::Worker(QObject* parent) : 
    QObject(parent), 
    mSocket(this), 
    mSocketReader(&amp;mSocket), 
    mReceivedJobsCounter(0), 
    mSentJobsCounter(0) 
{ 
    ... 
    connect(&amp;mSocket, &amp;QTcpSocket::readyRead, 
            this, &amp;Worker::readMessages); 
 
    mSocket.connectToHost(QHostAddress::LocalHost, 5000); 
} 
</pre><p>The <code class="literal">QDataStream mSocketReader</code> variable is initialized with the address of <code class="literal">mSocket</code>. This means that it will read its content from the <code class="literal">QIODevice</code> class. After that, we add the new connect to the <code class="literal">QTcpSocket</code> signal, <code class="literal">readyRead()</code>. Each time that data is available to read on the socket, our slot, <code class="literal">readMessages()</code>, will be called.</p><p>Here is the implementation of <code class="literal">readMessages()</code>:</p><pre class="programlisting">void Worker::readMessages() 
{ 
    auto messages = MessageUtils::readMessages(mSocketReader); 
    for(auto&amp; message : *messages) { 
        switch (message-&gt;type) { 
            case Message::Type::JOB_REQUEST: 
                handleJobRequest(*message); 
                break; 
            case Message::Type::ALL_JOBS_ABORT: 
                handleAllJobsAbort(*message); 
                break; 
            default: 
                break; 
        } 
    } 
} 
</pre><p>The messages are parsed with the <code class="literal">MessageUtils::readMessages()</code> function. Note the use of C++11 semantics with <code class="literal">auto</code>, which elegantly hides the smart pointers syntax and still handles the memory for us.</p><p>For each parsed <code class="literal">message</code>, it is handled in the <code class="literal">switch</code> case. Let's review 
<code class="literal">handleJobRequest()</code>:</p><pre class="programlisting">void Worker::handleJobRequest(Message&amp; message) 
{ 
     QDataStream in(&amp;message.data, QIODevice::ReadOnly); 
     QList&lt;JobRequest&gt; requests; 
     in &gt;&gt; requests; 
 
     mReceivedJobsCounter += requests.size(); 
     for(const JobRequest&amp; jobRequest : requests) { 
         QThreadPool::globalInstance() 
                    -&gt;start(createJob(jobRequest)); 
     } 
} 
</pre><p>In this function, the <code class="literal">message</code> object is already deserialized. However, <code class="literal">message.data</code> still needs to be deserialized. To achieve this, we create a <code class="literal">QDataStream</code> in a variable that will read from <code class="literal">message.data</code>.</p><p>From here, we parse the requests <code class="literal">QList</code>. Because <code class="literal">QList</code> already overrides the <code class="literal">&gt;&gt;</code> operator, it works in cascade and calls our <code class="literal">JobRequest &gt;&gt;</code> operator overload. Deserializing data has never been so easy!</p><p>After that, we increment <code class="literal">mReceivedJobsCounter</code> and start processing these 
<code class="literal">JobRequests</code>. For each one, we create a <code class="literal">Job</code> class and dispatch it to the global <code class="literal">QThreadPool</code> class. If you have a doubt about <code class="literal">QThreadPool</code>, get back to <a class="link" title="Chapter 9.  Keeping Your Sanity with Multithreading" href="part0090.xhtml#aid-2LQIK2">Chapter 9</a>, <em>Keeping Your Sanity with Multithreading</em>.</p><p>The <code class="literal">createJob()</code> function is straightforward to implement:</p><pre class="programlisting">Job* Worker::createJob(const JobRequest&amp; jobRequest) 
{ 
    Job* job = new Job(jobRequest); 
    connect(this, &amp;Worker::abortAllJobs, 
            job, &amp;Job::abort); 
    connect(job, &amp;Job::jobCompleted, 
            this, &amp;Worker::sendJobResult); 
    return job; 
} 
</pre><p>A new <code class="literal">Job</code> class is created and its signals are properly connected. When <code class="literal">Worker::abortAllJobs</code> is emitted, every running <code class="literal">Job</code> should be canceled with the <code class="literal">Job::abort</code> slot.</p><p>The second signal, <code class="literal">Job::jobCompleted</code> is emitted when the <code class="literal">Job</code> class has finished calculating its values. Let's see the connected slot, <code class="literal">sendJobResult()</code>:</p><pre class="programlisting">void Worker::sendJobResult(JobResult jobResult) 
{ 
    mSentJobsCounter++; 
    QByteArray data; 
    QDataStream out(&amp;data, QIODevice::WriteOnly); 
    out &lt;&lt; jobResult; 
    MessageUtils::sendMessage(mSocket, 
                              Message::Type::JOB_RESULT, 
                              data); 
} 
</pre><p>We first increment the <code class="literal">mSentJobsCounter</code> and then serialize the <code class="literal">JobResult</code> to a <code class="literal">QByteArray</code> data which is passed <code class="literal">to MessageUtils::sendMessage()</code>.</p><p>We completed the tour of the <code class="literal">JobRequest</code> handling and the following <code class="literal">JobResult</code> shipment. We still have to cover <code class="literal">handleAllJobsAbort()</code>, which is called from <code class="literal">readMessages()</code>:</p><pre class="programlisting">void Worker::handleAllJobsAbort(Message&amp; /*message*/) 
{ 
    emit abortAllJobs(); 
    QThreadPool::globalInstance()-&gt;clear(); 
    mReceivedJobsCounter = 0; 
    mSentJobsCounter = 0; 
} 
</pre><p>The <code class="literal">abortAllJobs()</code> signal is emitted first to tell all the running jobs to cancel their process. After that, the <code class="literal">QThreadPool</code> class is cleared and the counters are reset.</p><p>The last piece of <code class="literal">Worker</code> is the <code class="literal">sendUnregister()</code>, which is called in the <code class="literal">Worker</code> destructor:</p><pre class="programlisting">Worker::~Worker() 
{ 
    sendUnregister(); 
} 
 
void Worker::sendUnregister() 
{ 
    MessageUtils::sendMessage(mSocket, 
                              Message::Type::WORKER_UNREGISTER, 
                              true); 
} 
</pre><p>The <code class="literal">sendUnregister()</code> function just calls <code class="literal">sendMessage</code> without any data to serialize. Note that it passes the <code class="literal">forceFlush</code> flag to <code class="literal">true</code> to make sure that the socket is flushed and that <code class="literal">mandelbrot-app</code> application will receive the message as fast as possible.</p><p>The <code class="literal">Worker</code> instance will be managed by a widget which will display the progress of the current calculation. Create a new class named <code class="literal">WorkerWidget</code> and update
 <code class="literal">WorkerWidget.h</code>, like so:</p><pre class="programlisting">#include &lt;QWidget&gt; 
#include &lt;QThread&gt; 
#include &lt;QProgressBar&gt; 
#include &lt;QTimer&gt; 
 
#include "Worker.h" 
 
class WorkerWidget : public QWidget 
{ 
    Q_OBJECT 
public: 
    explicit WorkerWidget(QWidget *parent = 0); 
    ~WorkerWidget(); 
 
private: 
    QProgressBar mStatus; 
    Worker mWorker; 
    QThread mWorkerThread; 
    QTimer mRefreshTimer; 
}; 
</pre><p>The members of <code class="literal">WorkerWidget</code> are:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">mStatus</code>: The <code class="literal">QProgressBar</code> that will display the percentage of processed <code class="literal">JobRequests</code></li><li class="listitem"><code class="literal">mWorker</code>: The <code class="literal">Worker</code> instance owned and started by <code class="literal">WorkerWidget</code></li><li class="listitem"><code class="literal">mWorkerThread</code>: The <code class="literal">QThread</code> class in which <code class="literal">mWorker</code> will be executed</li><li class="listitem"><code class="literal">mRefreshTimer</code>: The <code class="literal">QTimer</code> class that will periodically poll <code class="literal">mWorker</code> to know the process advancement</li></ul></div><p>We can proceed to <code class="literal">WorkerWidget.cpp</code>:</p><pre class="programlisting">#include "WorkerWidget.h" 
 
#include &lt;QVBoxLayout&gt; 
 
WorkerWidget::WorkerWidget(QWidget *parent) : 
    QWidget(parent), 
    mStatus(this), 
    mWorker(), 
    mWorkerThread(this), 
    mRefreshTimer() 
{ 
    QVBoxLayout* layout = new QVBoxLayout(this); 
    layout-&gt;addWidget(&amp;mStatus); 
 
    mWorker.moveToThread(&amp;mWorkerThread); 
 
    connect(&amp;mRefreshTimer, &amp;QTimer::timeout, [this] { 
        mStatus.setMaximum(mWorker.receivedJobsCounter()); 
        mStatus.setValue(mWorker.sentJobCounter()); 
    }); 
 
    mWorkerThread.start(); 
    mRefreshTimer.start(100); 
} 
 
WorkerWidget::~WorkerWidget() 
{ 
    mWorkerThread.quit(); 
    mWorkerThread.wait(1000); 
} 
</pre><p>First, the <code class="literal">mStatus</code> variable is added to the <code class="literal">WorkerWidget</code> layout. Then the <code class="literal">mWorker</code> thread affinity is moved to <code class="literal">mWorkerThread</code> and <code class="literal">mRefreshTimer</code> is configured to poll <code class="literal">mWorker</code> and update <code class="literal">mStatus</code> data.</p><p>Finally, <code class="literal">mWorkerThread</code> is started, triggering the <code class="literal">mWorker</code> process. The <code class="literal">mRefreshTimer</code> object is also started with an interval of 100 milliseconds between each timeout.</p><p>The last thing to cover in <code class="literal">mandelbrot-worker</code> is the <code class="literal">main.cpp</code>:</p><pre class="programlisting">#include &lt;QApplication&gt; 
 
#include "JobResult.h" 
 
#include "WorkerWidget.h" 
 
int main(int argc, char *argv[]) 
{ 
    qRegisterMetaType&lt;JobResult&gt;(); 
 
    QApplication a(argc, argv); 
    WorkerWidget workerWidget; 
 
    workerWidget.show(); 
    return a.exec(); 
} 
</pre><p>We start by registering <code class="literal">JobResult</code> with <code class="literal">qRegisterMetaType</code> because it is used in the signal/slot mechanism. After that, we instantiate a <code class="literal">WorkerWidget</code> layout and display it.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec94"/>Interacting with sockets from the application</h1></div></div></div><p>The next project to complete is <code class="literal">mandelbrot-app</code>. It will contain the <code class="literal">QTcpServer</code> that will interact with the workers and the picture drawing of the Mandelbrot set. As a reminder, the diagram of the <code class="literal">mandelbrot-app</code> architecture is shown here:</p><div><img src="img/image00440.jpeg" alt="Interacting with sockets from the application"/></div><p style="clear:both; height: 1em;"> </p><p>We will build this application from the ground up. Let's start with the class responsible for maintaining the connection with a specific <code class="literal">Worker: WorkerClient</code>. This class will live in its specific <code class="literal">QThread</code> and will interact with a <code class="literal">Worker</code> class using the same
 <code class="literal">QTcpSocket</code>/<code class="literal">QDataStream</code> mechanism we covered in the last section.</p><p>In <code class="literal">mandelbrot-app</code>, create a new C++ class named <code class="literal">WorkerClient</code> and update 
<code class="literal">WorkerClient.h</code> like so:</p><pre class="programlisting">#include &lt;QTcpSocket&gt; 
#include &lt;QList&gt; 
#include &lt;QDataStream&gt; 
 
#include "JobRequest.h" 
#include "JobResult.h" 
#include "Message.h" 
 
class WorkerClient : public QObject 
{ 
    Q_OBJECT 
public: 
    WorkerClient(int socketDescriptor); 
 
private: 
    int mSocketDescriptor; 
    int mCpuCoreCount; 
    QTcpSocket mSocket; 
    QDataStream mSocketReader; 
}; 
 
Q_DECLARE_METATYPE(WorkerClient*) 
</pre><p>It looks very similar to <code class="literal">Worker</code>. Yet it may behave differently from a life cycle point of view. Each time a new <code class="literal">Worker</code> connects to our <code class="literal">QTcpServer</code>, a new <code class="literal">WorkerClient</code> will be spawned with an associated <code class="literal">QThread</code>. The <code class="literal">WorkerClient</code> object will take the responsibility of interacting with the <code class="literal">Worker</code> class through the <code class="literal">mSocket</code>.</p><p>If the <code class="literal">Worker</code> disconnects, the <code class="literal">WorkerClient</code> object will be deleted and removed from the <code class="literal">QTcpServer</code> class.</p><p>Let's review the content of this header, starting with the members:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">mSocketDescriptor</code>: This is the unique integer assigned by the system to interact with the socket. <code class="literal">stdin</code>, <code class="literal">stdout</code>, and <code class="literal">stderr</code> are also descriptors that point to specific streams in your application. For a given socket, the value will be retrieved in <code class="literal">QTcpServer</code>. More on this later on.</li><li class="listitem"><code class="literal">mCpuCoreCount</code>: This is the CPU core count for the connected <code class="literal">Worker</code>. This field will be initialized when the <code class="literal">Worker</code> sends the <code class="literal">WORKER_REGISTER</code> message.</li><li class="listitem"><code class="literal">mSocket</code>: This is the <code class="literal">QTcpSocket</code> used to interact with the <code class="literal">Worker</code> class.</li><li class="listitem"><code class="literal">mSocketReader</code>: This has the same role it had in <code class="literal">Worker</code> - it reads <code class="literal">mSocket</code> content.</li></ul></div><p>Now we can add the functions to <code class="literal">WorkerClient.h</code>:</p><pre class="programlisting">class WorkerClient : public QObject 
{ 
    Q_OBJECT 
public: 
    WorkerClient(int socketDescriptor); 
    int cpuCoreCount() const; 
 
signals: 
    void unregistered(WorkerClient* workerClient); 
    void jobCompleted(WorkerClient* workerClient,  
                      JobResult jobResult); 
    void sendJobRequests(QList&lt;JobRequest&gt; requests); 
 
public slots: 
    void start(); 
    void abortJob(); 
 
private slots: 
    void readMessages(); 
    void doSendJobRequests(QList&lt;JobRequest&gt; requests); 
 
private: 
    void handleWorkerRegistered(Message&amp; message); 
    void handleWorkerUnregistered(Message&amp; message); 
    void handleJobResult(Message&amp; message); 
 
    ... 
}; 
</pre><p>Let's see what each function does:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">WorkerClient()</code>: This function expects a <code class="literal">socketDescriptor</code> as a parameter. As a consequence, a <code class="literal">WorkerClient</code> function cannot be initialized without a valid socket.</li><li class="listitem"><code class="literal">cpuCoreCount()</code>: This function is a simple getter to let the owner of <code class="literal">WorkerClient</code> know how many cores the <code class="literal">Worker</code> has.</li></ul></div><p>The class has three signals:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">unregister()</code>: This is the signal sent by <code class="literal">WorkerClient</code> when it has received the <code class="literal">WORKER_UNREGISTER</code> message.</li><li class="listitem"><code class="literal">jobCompleted()</code>: This is the signal sent by <code class="literal">WorkerClient</code> when it has received the <code class="literal">JOB_RESULT</code> message. It will pass by copying the deserialized <code class="literal">JobResult</code>.</li><li class="listitem"><code class="literal">sendJobRequests()</code>: This is emitted from the owner of <code class="literal">WorkerClient</code> to pass <code class="literal">JobRequests</code> in a queued connection to the proper slot:
 <code class="literal">doSendJobRequests()</code>.</li></ul></div><p>Here are the details of the slots:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">start()</code>: This slot is called when <code class="literal">WorkerClient</code> can start its process. Typically, it will be connected to the <code class="literal">start</code> signal of the <code class="literal">QThread</code> associated with the <code class="literal">WorkerClient</code>.</li><li class="listitem"><code class="literal">abortJob()</code>: This slot triggers the shipment of the <code class="literal">ALL_JOBS_ABORT</code> message to the <code class="literal">Worker</code>.</li><li class="listitem"><code class="literal">readMessages()</code>: This slot is called each time there is something to read in the socket.</li><li class="listitem"><code class="literal">doSendJobRequests()</code>: This slot is the real slot that triggers the shipment of the <code class="literal">JobRequests</code> to the <code class="literal">Worker</code>.</li></ul></div><p>And finally, here are the details of the private functions:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">handleWorkerRegistered()</code>: This function processes the <code class="literal">WORKER_REGISTER</code> message and initializes <code class="literal">mCpuCoreCount</code></li><li class="listitem"><code class="literal">handleWorkerUnregistered()</code>: This function processes the <code class="literal">WORKER_UNREGISTER</code> message and emits the <code class="literal">unregistered()</code> signal</li><li class="listitem"><code class="literal">handleJobResult()</code>: This function processes the <code class="literal">JOB_RESULT</code> message and dispatches the content through the <code class="literal">jobCompleted()</code> signal</li></ul></div><p>The implementation in <code class="literal">WorkerClient.cpp</code> should be quite familiar. Here is the constructor:</p><pre class="programlisting">#include "MessageUtils.h" 
 
WorkerClient::WorkerClient(int socketDescriptor) : 
    QObject(), 
    mSocketDescriptor(socketDescriptor), 
    mSocket(this), 
    mSocketReader(&amp;mSocket) 
{ 
    connect(this, &amp;WorkerClient::sendJobRequests, 
            this, &amp;WorkerClient::doSendJobRequests); 
} 
</pre><p>The fields are initialized in the initialization list and the <code class="literal">sendJobRequests</code> signal is connected to the private slot, <code class="literal">doSendJobRequests</code>. This trick is used to still have a queued connection across threads while avoiding multiple functions declarations.</p><p>We will proceed with the <code class="literal">start()</code> function:</p><pre class="programlisting">void WorkerClient::start() 
{ 
    connect(&amp;mSocket, &amp;QTcpSocket::readyRead,  
            this, &amp;WorkerClient::readMessages); 
    mSocket.setSocketDescriptor(mSocketDescriptor); 
} 
</pre><p>This is very short indeed. It first connects the <code class="literal">readyRead()</code> signal from the socket to our <code class="literal">readMessages()</code> slot. After that, <code class="literal">mSocket</code> is properly configured with 
<code class="literal">mSocketDescriptor</code>.</p><p>The connect has to be done in <code class="literal">start()</code> because it should be executed in the <code class="literal">QThread</code> class associated with our <code class="literal">WorkerClient</code>. By doing so, we know that the connect will be a direct connection and that <code class="literal">mSocket</code> will not have to queue signals to interact with <code class="literal">WorkerClient</code>.</p><p>Note that at the end of the function, the associated <code class="literal">QThread</code> is not terminated. On the contrary, it is executing its event loop with <code class="literal">QThread::exec()</code>. The <code class="literal">QThread</code> class will continue to run its event loop until someone calls <code class="literal">QThread::exit()</code>.</p><p>The only purpose of the <code class="literal">start()</code> function is to do the <code class="literal">mSocket</code> connect work in the right thread affinity. After that, we rely solely on the Qt signal/slot mechanism to process data. There is no need for a busy <code class="literal">while</code> loop.</p><p>The <code class="literal">readMessages()</code> class is waiting for us; let's see it:</p><pre class="programlisting">void WorkerClient::readMessages() 
{ 
    auto messages = MessageUtils::readMessages(mSocketReader); 
    for(auto&amp; message : *messages) { 
        switch (message-&gt;type) { 
            case Message::Type::WORKER_REGISTER: 
                handleWorkerRegistered(*message); 
                break; 
            case Message::Type::WORKER_UNREGISTER: 
                handleWorkerUnregistered(*message); 
                break; 
            case Message::Type::JOB_RESULT: 
                handleJobResult(*message); 
                break; 
            default: 
                break; 
        } 
    } 
} 
</pre><p>No surprises here. It's exactly like we did for <code class="literal">Worker</code>. The <code class="literal">Messages</code> are deserialized using <code class="literal">MessageUtils::readMessages()</code> and, for each message type, the appropriate function is called.</p><p>Here is the content of each of these functions, starting with <code class="literal">handleWorkerRegistered()</code>:</p><pre class="programlisting">void WorkerClient::handleWorkerRegistered(Message&amp; message) 
{ 
    QDataStream in(&amp;message.data, QIODevice::ReadOnly); 
    in &gt;&gt; mCpuCoreCount; 
} 
</pre><p>For the <code class="literal">WORKER_REGISTER</code> message, <code class="literal">Worker</code> only serialized an <code class="literal">int</code> in <code class="literal">message.data</code>, so we can initialize <code class="literal">mCpuCoreCount</code> on the spot with <code class="literal">in &gt;&gt; mCpuCoreCount</code>.</p><p>Now the body of <code class="literal">handleWorkerUnregistered()</code>:</p><pre class="programlisting">void WorkerClient::handleWorkerUnregistered(Message&amp; /*message*/) 
{ 
    emit unregistered(this); 
} 
</pre><p>It is a relay to send the <code class="literal">unregistered()</code> signal, which will be picked up by the owner of <code class="literal">WorkerClient</code>.</p><p>The last "read" function is <code class="literal">handleJobResult()</code>:</p><pre class="programlisting">void WorkerClient::handleJobResult(Message&amp; message) 
{ 
    QDataStream in(&amp;message.data, QIODevice::ReadOnly); 
    JobResult jobResult; 
    in &gt;&gt; jobResult; 
    emit jobCompleted(this, jobResult); 
} 
</pre><p>This is deceptively short. It only deserializes the <code class="literal">jobResult</code> component from <code class="literal">message.data</code> and emits the <code class="literal">jobCompleted()</code> signal.</p><p>The "write-to-socket" functions are <code class="literal">abortJob()</code> and <code class="literal">doSendJobRequest()</code>:</p><pre class="programlisting">void WorkerClient::abortJob() 
{ 
    MessageUtils::sendMessage(mSocket,  
                              Message::Type::ALL_JOBS_ABORT,  
                              true); 
} 
 
void WorkerClient::doSendJobRequests(QList&lt;JobRequest&gt; requests) 
{ 
    QByteArray data; 
    QDataStream stream(&amp;data, QIODevice::WriteOnly); 
    stream &lt;&lt; requests; 
 
    MessageUtils::sendMessage(mSocket,  
                              Message::Type::JOB_REQUEST,  
                              data); 
} 
</pre><p>The <code class="literal">abortJob()</code> function sends the <code class="literal">ALL_JOBS_ABORT</code> message with the <code class="literal">forceFlush</code> flag set to <code class="literal">true</code> and <code class="literal">doSendJobRequests()</code> serializes the <code class="literal">requests</code> to stream before sending them using <code class="literal">MessageUtils::sendMessage()</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec95"/>Building your own QTcpServer</h1></div></div></div><p>Everything is ready to read and write in our sockets. We still need a server to orchestrate all these instances. To do so, we will develop a modified version of the <code class="literal">MandelbrotCalculator</code> class, which was covered in <a class="link" title="Chapter 9.  Keeping Your Sanity with Multithreading" href="part0090.xhtml#aid-2LQIK2">Chapter 9</a>, <em>Keeping Your Sanity with Multithreading</em>.</p><p>The idea is to respect the same interface, in order to have <code class="literal">MandelbrotWidget</code> oblivious to the fact that the Mandelbrot picture generation is deported on different processes/machines.</p><p>The main difference between the old <code class="literal">MandelbrotCalculator</code> and the new one is that we replaced the <code class="literal">QThreadPool</code> class by a <code class="literal">QTcpServer</code>. The <code class="literal">MandelbrotCalculator</code> class now only has the responsibility to dispatch <code class="literal">JobRequests</code> to Workers and aggregate the result, but it never interacts anymore with a <code class="literal">QThreadPool</code> class.</p><p>Create a new C++ class named <code class="literal">MandelbrotCalculator.cpp</code> and update 
<code class="literal">MandelbrotCalculator.h</code> to match this:</p><pre class="programlisting">#include &lt;memory&gt; 
#include &lt;vector&gt; 
 
#include &lt;QTcpServer&gt; 
#include &lt;QList&gt; 
#include &lt;QThread&gt; 
#include &lt;QMap&gt; 
#include &lt;QElapsedTimer&gt; 
 
#include "WorkerClient.h" 
#include "JobResult.h" 
#include "JobRequest.h" 
 
class MandelbrotCalculator : public QTcpServer 
{ 
    Q_OBJECT 
public: 
    MandelbrotCalculator(QObject* parent = 0); 
    ~MandelbrotCalculator(); 
 
signals: 
    void pictureLinesGenerated(QList&lt;JobResult&gt; jobResults); 
    void abortAllJobs(); 
 
public slots: 
    void generatePicture(QSize areaSize, QPointF moveOffset,  
                         double scaleFactor, int iterationMax); 
 
private slots: 
    void process(WorkerClient* workerClient, JobResult jobResult); 
    void removeWorkerClient(WorkerClient* workerClient); 
 
protected: 
    void incomingConnection(qintptr socketDescriptor) override; 
 
private: 
    std::unique_ptr&lt;JobRequest&gt; createJobRequest( 
                                              int pixelPositionY); 
    void sendJobRequests(WorkerClient&amp; client,  
                         int jobRequestCount = 1); 
    void clearJobs(); 
 
private: 
    QPointF mMoveOffset; 
    double mScaleFactor; 
    QSize mAreaSize; 
    int mIterationMax; 
    int mReceivedJobResults; 
    QList&lt;JobResult&gt; mJobResults; 
    QMap&lt;WorkerClient*, QThread*&gt; mWorkerClients; 
    std::vector&lt;std::unique_ptr&lt;JobRequest&gt;&gt; mJobRequests; 
    QElapsedTimer mTimer; 
}; 
</pre><p>The modified (or new) data is highlighted. First, note that the class now inherits from <code class="literal">QTcpServer</code> rather than <code class="literal">QObject</code>. The <code class="literal">MandelbrotCalculator</code> class is now a <code class="literal">QTcpServer</code> and is able to accept and manage connections. Before digging into this topic, we can review the new members:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">mWorkerClients</code>: This is a <code class="literal">QMap</code> that stores the pair <code class="literal">WorkerClient</code> and <code class="literal">QThread</code>. Each time a <code class="literal">WorkerClient</code> is created, an associated <code class="literal">QThread</code> is also spawned and both of them are stored in <code class="literal">mWorkerClients</code>.</li><li class="listitem"><code class="literal">mJobRequests</code>: This is the list of <code class="literal">JobRequests</code> for the current picture. Each time a picture generation is requested, the full list of <code class="literal">JobRequest</code> is generated, ready to be dispatched to <code class="literal">WorkerClients</code> (that is, to the <code class="literal">Worker</code> on the other side of the socket).</li></ul></div><p>And the functions are:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">process()</code>: This function is a slightly modified version of the one seen in <a class="link" title="Chapter 9.  Keeping Your Sanity with Multithreading" href="part0090.xhtml#aid-2LQIK2">Chapter 9</a>, <em>Keeping Your Sanity with Multithreading</em>. It not only aggregates <code class="literal">JobResults</code> before sending them with the <code class="literal">pictureLinesGenerated()</code> signal, but also dispatches <code class="literal">JobRequest</code> to the passed <code class="literal">WorkerClient</code> to keep them busy.</li><li class="listitem"><code class="literal">removeWorkerClient()</code>: This function removes and deletes the given <code class="literal">WorkerClient</code> from <code class="literal">mWorkerClients</code>.</li><li class="listitem"><code class="literal">incomingConnection()</code>: This function is an overloaded function from <code class="literal">QTcpServer</code>. It is called each time a new client tries to connect to <code class="literal">MandelbrotCalculator</code>.</li><li class="listitem"><code class="literal">createJobRequest()</code>: This is a helper function that creates a <code class="literal">JobRequest</code> that is added to <code class="literal">mJobRequests</code>.</li><li class="listitem"><code class="literal">sendJobRequests()</code>: This function is responsible for sending a list of <code class="literal">JobRequests</code> to the specified <code class="literal">WorkerClient</code>.</li></ul></div><p>Let's turn to <code class="literal">MandelbrotCalculator.cpp</code> with the constructor:</p><pre class="programlisting">#include &lt;QDebug&gt; 
#include &lt;QThread&gt; 
 
using namespace std; 
 
const int JOB_RESULT_THRESHOLD = 10; 
 
MandelbrotCalculator::MandelbrotCalculator(QObject* parent) : 
    QTcpServer(parent), 
     mMoveOffset(), 
    mScaleFactor(), 
    mAreaSize(), 
    mIterationMax(), 
    mReceivedJobResults(0), 
    mWorkerClients(), 
    mJobRequests(), 
    mTimer() 
{ 
    listen(QHostAddress::Any, 5000); 
} 
</pre><p>This is the common initialization list with the <code class="literal">listen()</code> instruction in the body. Because we are subclassing <code class="literal">QTcpServer</code>, we can call listen on ourselves. Note that <code class="literal">QHostAddress::Any</code> works either for IPv4 and IPv6.</p><p>Let's see the overloaded function, <code class="literal">incomingConnection()</code>:</p><pre class="programlisting">void MandelbrotCalculator::incomingConnection( 
                                         qintptr socketDescriptor) 
{ 
    qDebug() &lt;&lt; "Connected workerClient"; 
    QThread* thread = new QThread(this); 
    WorkerClient* client = new WorkerClient(socketDescriptor); 
    int workerClientsCount = mWorkerClients.keys().size(); 
    mWorkerClients.insert(client, thread); 
    client-&gt;moveToThread(thread); 
 
    connect(this, &amp;MandelbrotCalculator::abortAllJobs, 
            client, &amp;WorkerClient::abortJob); 
 
    connect(client, &amp;WorkerClient::unregistered, 
            this, &amp;MandelbrotCalculator::removeWorkerClient); 
    connect(client, &amp;WorkerClient::jobCompleted, 
            this, &amp;MandelbrotCalculator::process); 
 
    connect(thread, &amp;QThread::started, 
            client, &amp;WorkerClient::start); 
    thread-&gt;start(); 
 
    if(workerClientsCount == 0 &amp;&amp; 
        mWorkerClients.size() == 1) { 
        generatePicture(mAreaSize, mMoveOffset,  
                        mScaleFactor, mIterationMax); 
    } 
} 
</pre><p>Once <code class="literal">listen()</code> has been called, each time someone connects to our ip/port pair, <code class="literal">incomingConnection()</code> will be triggered with <code class="literal">socketDescriptor</code> passed as a parameter.</p><div><h3 class="title"><a id="tip48"/>Tip</h3><p>You can test this on your machine connection with a simple <code class="literal">telnet 127.0.0.1 5000</code> command. You should see the <code class="literal">Connected workerClient</code> log in <code class="literal">mandelbrot-app</code>.</p></div><p>We start by creating a <code class="literal">QThread</code> class and a <code class="literal">WorkerClient</code>. This pair is immediately inserted in the <code class="literal">mWorkerClients</code> map and <code class="literal">client</code> thread affinity is changed to <code class="literal">thread</code>.</p><p>After that, we do all the connects to manage the <code class="literal">client</code> (<code class="literal">abortJob</code>, <code class="literal">unregister</code>, and <code class="literal">jobCompleted</code>). We continue with the <code class="literal">QThread::started()</code> signal, which is connected to the <code class="literal">WorkerClient::start()</code> slot and finally, <code class="literal">thread</code> is started.</p><p>The last part of the function is used to trigger a picture generation upon the first <code class="literal">client</code> connection. If we did not do this, the screen would have remained black until we panned or zoomed.</p><p>We have covered the <code class="literal">WorkerClient</code> creation; let's finish its life cycle with its destruction with <code class="literal">removeWorkerClient()</code>:</p><pre class="programlisting">void MandelbrotCalculator::removeWorkerClient(WorkerClient* workerClient) 
{ 
    qDebug() &lt;&lt; "Removing workerClient"; 
    QThread* thread = mWorkerClients.take(workerClient); 
    thread-&gt;quit(); 
    thread-&gt;wait(1000); 
    delete thread; 
    delete workerClient; 
} 
</pre><p>The <code class="literal">workerClient</code>/<code class="literal">thread</code> pair is removed from <code class="literal">mWorkerClients</code> and cleanly deleted. Note that this function can be called from the <code class="literal">WorkerClient::unregistered</code> signal or in the <code class="literal">MandelbrotCalculator</code> destructor:</p><pre class="programlisting">MandelbrotCalculator::~MandelbrotCalculator() 
{ 
    while (!mWorkerClients.empty()) { 
        removeWorkerClient(mWorkerClients.firstKey()); 
    } 
} 
</pre><p>When <code class="literal">MandelbrotCalculator</code> is deleted, <code class="literal">mWorkerClients</code> has to be properly emptied. The iterator style <code class="literal">while</code> loop does a good job of calling 
<code class="literal">removeWorkerClient()</code>.</p><p>In this new version of <code class="literal">MandelbrotCalculator</code>, <code class="literal">generatePicture()</code> does not have exactly the same behavior:</p><pre class="programlisting">void MandelbrotCalculator::generatePicture( 
                             QSize areaSize, QPointF moveOffset, 
                             double scaleFactor, int iterationMax) 
{ 
    // sanity check &amp; members initization 
    ... 
 
    for(int pixelPositionY = mAreaSize.height() - 1;   
        pixelPositionY &gt;= 0; pixelPositionY--) { 
        mJobRequests.push_back(move( 
                               createJobRequest(pixelPositionY))); 
    } 
 
    for(WorkerClient* client : mWorkerClients.keys()) { 
        sendJobRequests(*client, client-&gt;cpuCoreCount() * 2); 
    } 
} 
</pre><p>The beginning is the same. However, the end is quite different. Rather than creating <code class="literal">Jobs</code> and giving them to a <code class="literal">QThreadPool</code>, <code class="literal">MandelbrotCalculator</code> now:</p><div><ul class="itemizedlist"><li class="listitem">Creates <code class="literal">JobRequests</code> to generate the whole picture. Note that they are created in reverse order. We will soon see why.</li><li class="listitem">Dispatches a number of <code class="literal">JobRequests</code> to each <code class="literal">WorkerClient</code> it owns.</li></ul></div><p>The second point deserves a strong emphasis. If we want to maximize the speed of our system, we have to use multiple workers, each one having multiple cores to process multiple jobs at the same time.</p><p>Even though a <code class="literal">Worker</code> class can process multiple jobs at the same time, it can only send us <code class="literal">JobResults</code> one by one (through <code class="literal">WorkerClient::jobCompleted</code>). Each time we process a <code class="literal">JobResult</code> object from a <code class="literal">WorkerClient</code>, we will dispatch a single 
<code class="literal">JobRequest</code> to it.</p><p>Assume that the <code class="literal">Worker</code> class has eight cores. If we send <code class="literal">JobRequests</code> one by one, the <code class="literal">Worker</code> will always have seven cores idle. We are here to heat up your CPUs, not to let them drink mojitos on the beach!</p><p>To mitigate this, the first batch of <code class="literal">JobResults</code> we send to a worker has to be higher than its <code class="literal">coreCount()</code>. By doing so, we ensure that is always has a queue of 
<code class="literal">JobRequests</code> to process until we generate the whole picture. This is why we send 
<code class="literal">client-&gt;cpuCoreCount() * two</code> initial <code class="literal">JobRequests</code>. If you play with this value, you will see that:</p><div><ul class="itemizedlist"><li class="listitem">If <code class="literal">jobCount &lt; cpuCoreCount()</code>, some cores of your <code class="literal">Worker</code> will be idle and you will not leverage the full power of its CPU</li><li class="listitem">If <code class="literal">jobCount &gt; cpuCoreCount()</code> by too much, you might overload the queue of one your <code class="literal">Workers</code></li></ul></div><p>Remember that this system is flexible enough to have multiple workers. If you have a RaspberryPI and an x86 with 16 cores, the RaspberryPI will lag behind the x86 CPU. By giving too much initial <code class="literal">JobRequests</code>, the RaspberryPI will hinder the whole picture generation while the x86 CPU has already finished all its jobs.</p><p>Let's cover the remaining functions of <code class="literal">MandelbrotCalculator</code>, starting with 
<code class="literal">createJobRequest()</code>:</p><pre class="programlisting">std::unique_ptr&lt;JobRequest&gt; MandelbrotCalculator::createJobRequest(int pixelPositionY) 
{ 
    auto jobRequest = make_unique&lt;JobRequest&gt;(); 
    jobRequest-&gt;pixelPositionY = pixelPositionY; 
    jobRequest-&gt;moveOffset = mMoveOffset; 
    jobRequest-&gt;scaleFactor = mScaleFactor; 
    jobRequest-&gt;areaSize = mAreaSize; 
    jobRequest-&gt;iterationMax = mIterationMax; 
    return jobRequest; 
} 
</pre><p>This is a simple creation of a <code class="literal">jobRequest</code> with the member fields of 
<code class="literal">MandelbrotCalculator</code>. Again, we use <code class="literal">unique_ptr</code> to explicitly indicate the ownership of <code class="literal">jobRequest</code> and avoid any memory leaks.</p><p>Next, with <code class="literal">sendJobRequests()</code>:</p><pre class="programlisting">void MandelbrotCalculator::sendJobRequests(WorkerClient&amp; client, int jobRequestCount) 
{ 
    QList&lt;JobRequest&gt; listJobRequest; 
    for (int i = 0; i &lt; jobRequestCount; ++i) { 
        if (mJobRequests.empty()) { 
            break; 
        } 
 
        auto jobRequest = move(mJobRequests.back()); 
        mJobRequests.pop_back(); 
        listJobRequest.append(*jobRequest); 
    } 
 
    if (!listJobRequest.empty()) { 
        emit client.sendJobRequests(listJobRequest); 
    } 
} 
</pre><p>Because we can send multiple <code class="literal">JobRequests</code> at the same time, we loop on 
<code class="literal">jobRequestCount</code> by taking the last <code class="literal">jobRequest</code> of <code class="literal">mJobRequests</code> and adding it to <code class="literal">listJobRequest</code>. This is the reason for which we had to fill <code class="literal">mJobRequests</code> in the reverse order.</p><p>Finally, the <code class="literal">client.sendJobRequests()</code> signal is emitted, which in turns triggers the <code class="literal">WorkerClient::doSendJobRequests()</code> slot.</p><p>We are now going to see the modified version of <code class="literal">process()</code>:</p><pre class="programlisting">void MandelbrotCalculator::process(WorkerClient* workerClient,  
                                   JobResult jobResult) 
{ 
    // Sanity check and JobResult aggregation 
 
    if (mReceivedJobResults &lt; mAreaSize.height()) { 
        sendJobRequests(*workerClient); 
    } else { 
        qDebug() &lt;&lt; "Generated in" &lt;&lt; mTimer.elapsed() &lt;&lt; "ms"; 
    } 
} 
</pre><p>In this version, we pass <code class="literal">workerClient</code> as a parameter. This is used at the end of the function, to be able to dispatch a new <code class="literal">JobRequest</code> to the given <code class="literal">workerClient</code>.</p><p>Finally, the updated version of <code class="literal">abortAllJobs()</code>:</p><pre class="programlisting">void MandelbrotCalculator::clearJobs() 
{ 
    mReceivedJobResults = 0; 
    mJobRequests.clear(); 
    emit abortAllJobs(); 
} 
</pre><p>This simply cleared <code class="literal">mJobRequests</code> instead of emptying <code class="literal">QThreadPool</code>.</p><p>The <code class="literal">MandelbrotCalculator</code> class is completed! You can copy and paste 
<code class="literal">MandelBrotWidget</code> and <code class="literal">MainWindow</code> (<code class="literal">.ui</code> file included) from <a class="link" title="Chapter 9.  Keeping Your Sanity with Multithreading" href="part0090.xhtml#aid-2LQIK2">Chapter 9</a>, <em>Keeping Your Sanity with Multithreading</em>. We designed it to be plug and play, without knowing who generates the picture: a local <code class="literal">QThreadPool</code> with <code class="literal">QRunnable</code> or minions through an IPC mechanism.</p><p>There is only a tiny difference in <code class="literal">main.cpp</code>:</p><pre class="programlisting">#include &lt;QApplication&gt; 
#include &lt;QList&gt; 
 
#include "JobRequest.h" 
#include "JobResult.h" 
#include "WorkerClient.h" 
 
int main(int argc, char *argv[]) 
{ 
    qRegisterMetaType&lt;QList&lt;JobRequest&gt;&gt;(); 
    qRegisterMetaType&lt;QList&lt;JobResult&gt;&gt;(); 
    qRegisterMetaType&lt;WorkerClient*&gt;(); 
 
    QApplication a(argc, argv); 
    MainWindow w; 
    w.show(); 
 
    return a.exec(); 
} 
</pre><p>You can now launch <code class="literal">mandelbrot-app</code> and after that, the one or many <code class="literal">mandelbrot-worker</code> programs that will connect to the application. It should automatically trigger a picture generation. The Mandelbrot picture generation is now working across multiple processes! Because we chose to use sockets, you can start the application and the workers on different physical machines.</p><div><h3 class="title"><a id="tip49"/>Tip</h3><p>Using IPv6, you may very easily test the app/worker connection in different locations. If you do not have a high-speed Internet connection, you will see how the network hinders the picture generation.</p></div><p>You may want to take some time to deploy the application on multiple machines and see how this cluster works together. During our tests, we ramped up our cluster up to 18 cores with very heterogeneous machines (PC, laptop, Macbook, and so on).</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec96"/>Summary</h1></div></div></div><p>IPC is a fundamental mechanism in computer science. In this chapter, you learned the various techniques offered by Qt to do IPC and how to create an application that uses sockets to interact, send, and receive commands. You took the original <code class="literal">mandelbrot-threadpool</code> application to the next level by enabling it to generate pictures on a cluster of machines.</p><p>Adding IPC on top of a multi-threaded application brings some issues. You have many more possible bottlenecks, chances of leaking memory, and have an inefficient calculation. Qt provides multiple mechanisms to do IPC. In Qt 5.7, the addition of transactions makes the serialization/deserialization part much easier.</p><p>In the next chapter, you will discover the Qt Multimedia framework and how to save and load an C++ object from a file. The project example will be a virtual drum machine. You will be able to save and load your tracks.</p></div></body></html>