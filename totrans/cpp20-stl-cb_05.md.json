["```cpp\nauto la = []{ return \"Hello\\n\"; };\n```", "```cpp\ncout << la();\n```", "```cpp\nf(la);\n```", "```cpp\nconst auto la = []{ return \"Hello\\n\"; };\nconst auto lb = [](auto a){ return a(); };\ncout << lb(la);\n```", "```cpp\nHello\n```", "```cpp\nconst auto lb = [](auto a){ return a(); };\ncout << lb([]{ return \"Hello\\n\"; });\n```", "```cpp\nauto la = []{ return \"Hello\\n\"; };\n```", "```cpp\nconst char * greeting{ \"Hello\\n\" };\nconst auto la = []{ return greeting; };\ncout << la();\n```", "```cpp\nIn lambda function:\nerror: 'greeting' is not captured\n```", "```cpp\nconst char * greeting{ \"Hello\\n\" };\nconst auto la = [greeting]{ return greeting; };\ncout << la();\n```", "```cpp\n$ ./working\nHello\n```", "```cpp\n    int main() {\n        ... // code goes here\n    }\n    ```", "```cpp\n    auto one = [](){ return \"one\"; };\n    auto two = []{ return \"two\"; };\n    ```", "```cpp\n    cout << one() << '\\n';\n    cout << format(\"{}\\n\", two());\n    ```", "```cpp\n    auto one = []() -> const char * { return \"one\"; };\n    auto two = []() -> auto { return \"two\"; };\n    ```", "```cpp\n    auto p = [](auto v) { cout << v() << '\\n'; };\n    ```", "```cpp\nauto p = []<template T>(T v) { cout << v() << '\\n'; };\n```", "```cpp\n    p([]{ return \"lambda call lambda\"; });\n    ```", "```cpp\nlambda call lambda\n```", "```cpp\n    << [](auto l, auto r){ return l + r; }(47, 73)\n        << '\\n';\n    ```", "```cpp\n    int num{1};\n    p([num]{ return num; });\n    ```", "```cpp\n    int num{0};\n    auto inc = [&num]{ num++; };\n    for (size_t i{0}; i < 5; ++i) {\n        inc();\n    }\n    cout << num << '\\n';\n    ```", "```cpp\n5\n```", "```cpp\n    auto counter = [n = 0]() mutable { return ++n; };\n    for (size_t i{0}; i < 5; ++i) {\n        cout << format(\"{}, \", counter());\n    }\n    cout << '\\n';\n    ```", "```cpp\n1, 2, 3, 4, 5,\n```", "```cpp\n    int a = 47;\n    int b = 73;\n    auto l1 = []{ return a + b; };\n    ```", "```cpp\nnote: the lambda has no capture-default\n```", "```cpp\nauto l1 = [=]{ return a + b; };\n```", "```cpp\nauto l1 = [&]{ return a + b; };\n```", "```cpp\n[]{}\n```", "```cpp\n[a, b]{ return a + b; }\n```", "```cpp\n[&a, &b]{ return a + b; }\n```", "```cpp\n[](int a, int b){ return a + b };\n```", "```cpp\n[]() -> int { return 47 + 73 };\n```", "```cpp\n[a]{ return ++a; };\n```", "```cpp\nIn lambda function:\nerror: increment of read-only variable 'a'\n```", "```cpp\n[a]() mutable { return ++a; };\n```", "```cpp\n[](int a, int b) -> long { return a + b; };\n```", "```cpp\n    bool is_div4(int i) {\n        return i % 4 == 0;\n    }\n    ```", "```cpp\n    int main() {\n        const vector<int> v{ 1, 7, 4, 9, 4, 8, 12, 10, 20 };\n        int count = count_if(v.begin(), v.end(), is_div4);\n        cout << format(\"numbers divisible by 4: {}\\n\", \n          count);\n    }\n    ```", "```cpp\nnumbers divisible by 4: 5\n```", "```cpp\n    struct is_div4 {\n        bool operator()(int i) {\n            return i % 4 == 0;\n        }\n    };\n    ```", "```cpp\nint count = count_if(v.begin(), v.end(), is_div4());\n```", "```cpp\n    auto is_div4 = [](int i){ return i % 4 == 0; };\n    int count = count_if(v.begin(), v.end(), is_div4);\n    ```", "```cpp\nint count = count_if(v.begin(), v.end(), \n    [](int i){ return i % 4 == 0; });\n```", "```cpp\n    auto is_div_by(int divisor) {\n        return [divisor](int i){ return i % divisor == 0; };\n    }\n    ```", "```cpp\nfor( int i : { 3, 4, 5 } ) {\n    auto pred = is_div_by(i);\n    int count = count_if(v.begin(), v.end(), pred);\n    cout << format(\"numbers divisible by {}: {}\\n\", i,\n      count);\n}\n```", "```cpp\nnumbers divisible by 3: 2\nnumbers divisible by 4: 5\nnumbers divisible by 5: 2\n```", "```cpp\nvoid (*)()\n```", "```cpp\nvoid (*fp)() = func;\n```", "```cpp\nfunc();  // do the func thing\n```", "```cpp\nvoid (*fp)() = []{ cout << \"foo\\n\"; };\n```", "```cpp\nbool (*fp)(int) = is_div4;\nbool (*fp)(int) = [](int i){ return i % 4 == 0; };\n```", "```cpp\n    int main() {\n        deque<int> d;\n        list<int> l;\n        vector<int> v;\n    ```", "```cpp\n    auto print_c = [](auto& c) {\n        for(auto i : c) cout << format(\"{} \", i);\n        cout << '\\n';\n    };\n    ```", "```cpp\n    auto push_c = [](auto& container) {\n        return [&container](auto value) {\n            container.push_back(value);\n        };\n    };\n    ```", "```cpp\n    const vector<std::function<void(int)>> \n        consumers { push_c(d), push_c(l), push_c(v) };\n    ```", "```cpp\n    for(auto &consume : consumers) {\n        for (int i{0}; i < 10; ++i) {\n            consume(i);\n        }\n    }\n    ```", "```cpp\n    print_c(d);\n    print_c(l);\n    print_c(v);\n    ```", "```cpp\n0 1 2 3 4 5 6 7 8 9\n0 1 2 3 4 5 6 7 8 9\n0 1 2 3 4 5 6 7 8 9\n```", "```cpp\nauto push_c = [](auto& container) {\n    return [&container](auto value) {\n        container.push_back(value);\n    };\n};\n```", "```cpp\nconst vector<std::function<void(int)>> \n    consumers { push_c(d), push_c(l), push_c(v) };\n```", "```cpp\ntemplate< class F >\nfunction( F&& f );\n```", "```cpp\nfor(auto &c : consumers) {\n    for (int i{0}; i < 10; ++i) {\n        c(i);\n    }\n}\n```", "```cpp\nvoid hello() {\n    cout << \"hello\\n\";\n}\nint main() {\n    function<void(void)> h = hello;\n    h();\n}\n```", "```cpp\nstruct hello {\n    void greeting() const { cout << \"Hello Bob\\n\"; }\n};\nint main() {\n    hello bob{};\n    const function<void(void)> h = \n        std::bind(&hello::greeting, &bob);\n    h();\n}\n```", "```cpp\nstruct hello {\n    void operator()() const { cout << \"Hello Bob\\n\"; }\n};\nint main() {\n    const function<void(void)> h = hello();\n    h();\n}\n```", "```cpp\nHello Bob\n```", "```cpp\n    template <typename T, typename ...Ts>\n    auto concat(T t, Ts ...ts) {\n        if constexpr (sizeof...(ts) > 0) {\n            return [&](auto ...parameters) {\n    return t(concat(ts...)(parameters...)); \n            };\n        } else  {\n            return t;\n        }\n    }\n    ```", "```cpp\n    int main() {\n        auto twice = [](auto i) { return i * 2; };\n        auto thrice = [](auto i) { return i * 3; };\n        auto combined = concat(thrice, twice, \n          std::plus<int>{});\n        std::cout << format(\"{}\\n\", combined(2, 3));\n    }\n    ```", "```cpp\n30\n```", "```cpp\ntemplate <typename T, typename ...Ts>\nauto concat(T t, Ts ...ts) {\n    if constexpr (sizeof...(ts) > 0) {\n        return [&](auto ...parameters) {\n            return t(concat(ts...)(parameters...)); \n        };\n    } else  {\n        return t;\n    }\n}\n```", "```cpp\n    template <typename F, typename A, typename B>\n    auto combine(F binary_func, A a, B b) {\n        return [=](auto param) {\n            return binary_func(a(param), b(param));\n        };\n    }\n    ```", "```cpp\n    int main() {\n        auto begins_with = [](const string &s){\n            return s.find(\"a\") == 0;\n        };\n        auto ends_with = [](const string &s){\n            return s.rfind(\"b\") == s.length() - 1;\n        };\n        auto bool_and = [](const auto& l, const auto& r){\n            return l && r;\n        };\n    ```", "```cpp\n    std::copy_if(istream_iterator<string>{cin}, {},\n                 ostream_iterator<string>{cout, \" \"},\n                 combine(bool_and, begins_with, \n    ends_with));\n    cout << '\\n';\n    ```", "```cpp\n$ echo aabb bbaa foo bar abazb | ./conjunction\naabb abazb\n```", "```cpp\ntemplate <typename F, typename A, typename B>\nauto combine(F binary_func, A a, B b) {\n    return [=](auto param) {\n        return binary_func(a(param), b(param));\n    };\n}\n```", "```cpp\nstd::copy_if(istream_iterator<string>{cin}, {},\n             ostream_iterator<string>{cout, \" \"},\n             combine(bool_and, begins_with, ends_with));\n```", "```cpp\n    auto braces (const char a, const char b) {\n        return [a, b](const char v) {\n            cout << format(\"{}{}{} \", a, v, b);\n        };\n    }\n    ```", "```cpp\n    auto a = braces('(', ')');\n    auto b = braces('[', ']');\n    auto c = braces('{', '}');\n    auto d = braces('|', '|');\n    ```", "```cpp\n    for( int i : { 1, 2, 3, 4, 5 } ) {\n        for( auto x : { a, b, c, d } ) x(i);\n        cout << '\\n';\n    }\n    ```", "```cpp\n    (1) [1] {1} |1|\n    (2) [2] {2} |2|\n    (3) [3] {3} |3|\n    (4) [4] {4} |4|\n    (5) [5] {5} |5|\n    ```", "```cpp\nauto braces (const char a, const char b) {\n    return [a, b](const auto v) {\n        cout << format(\"{}{}{} \", a, v, b);\n    };\n}\n```", "```cpp\nauto a = braces('(', ')');\nauto b = braces('[', ']');\nauto c = braces('{', '}');\nauto d = braces('|', '|');\n```", "```cpp\n    const char prompt(const char * p) {\n        std::string r;\n        cout << format(\"{} > \", p);\n        std::getline(cin, r, '\\n');\n        if(r.size() < 1) return '\\0';\n        if(r.size() > 1) {\n            cout << \"Response too long\\n\";\n            return '\\0';\n        }\n        return toupper(r[0]);\n    }\n    ```", "```cpp\n    using jumpfunc = void(*)();\n    map<const char, jumpfunc> jumpmap {\n        { 'A', []{ cout << \"func A\\n\"; } },\n        { 'B', []{ cout << \"func B\\n\"; } },\n        { 'C', []{ cout << \"func C\\n\"; } },\n        { 'D', []{ cout << \"func D\\n\"; } },\n        { 'X', []{ cout << \"Bye!\\n\"; } }\n    };\n    ```", "```cpp\nusing jumpfunc = std::function<void()>;\n```", "```cpp\n    char select{};\n    while(select != 'X') {\n        if((select = prompt(\"select A/B/C/D/X\"))) {\n            auto it = jumpmap.find(select);\n            if(it != jumpmap.end()) it->second();\n            else cout << \"Invalid response\\n\";\n        }\n    }\n    ```", "```cpp\nusing jumpfunc = void(*)();\nmap<const char, jumpfunc> jumpmap {\n    { 'A', []{ cout << \"func A\\n\"; } },\n    { 'B', []{ cout << \"func B\\n\"; } },\n    { 'C', []{ cout << \"func C\\n\"; } },\n    { 'D', []{ cout << \"func D\\n\"; } },\n    { 'X', []{ cout << \"Bye!\\n\"; } }\n};\n```", "```cpp\nauto it = jumpmap.find(select);\nif(it != jumpmap.end()) it->second();\nelse cout << \"Invalid response\\n\";\n```"]