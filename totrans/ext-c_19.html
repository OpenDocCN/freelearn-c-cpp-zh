<html><head></head><body>
		<div><h1 class="chapterNumber">Chapter <a id="_idTextAnchor487"/>19</h1>
			<h1 id="_idParaDest-260" class="chapterTitle" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor488"/>Single-Host IPC and Sockets</h1>
			<p class="normal">In the previous chapter, we discussed the techniques by which two processes could operate on the same shared resource concurrently and in a synchronized fashion. In this chapter, we are going to expand these techniques and introduce a new category of methods that allow two processes to transmit data. These techniques, both those introduced in the previous chapter and the ones we are going to discuss in this chapter, are together referred <a id="_idIndexMarker1310"/>to as <strong class="bold">Inter-Process Communication</strong> (<strong class="bold">IPC</strong>) techniques.</p>
			<p class="normal">In this and the following chapter, we are going to talk about the IPC techniques that, despite the methods we discussed in the previous chapter, involve a kind of <em class="italics">message passing</em> or <em class="italics">signaling</em> between two processes. The transmitting messages are not stored in any shared place like a file or a shared memory, rather they are emitted and received by the processes.</p>
			<p class="normal">In this chapter we cover two major topics. Firstly, we underpin the IPC techniques and we discuss single-host IPC and the POSIX API. Secondly, we begin to introduce socket programming and the surrounding topics. These topics include computer networks, the listener-connector model, and the sequences that exist for two processes to establish a connection.</p>
			<p class="normal">As part of this chapter, we are going to discuss the following topics:</p>
			<ul>
				<li class="list">Various IPC techniques. We introduce push-based and pull-based IPC techniques and as part of this section, we define the techniques discussed in the previous chapter to be pull-based IPC techniques.</li>
				<li class="list">Communication protocols and the characteristics that a protocol usually has. We introduce what serialization and deserialization mean and how they contribute to a fully operational IPC.</li>
				<li class="list">File descriptors and how they play a key role in establishing an IPC channel.</li>
				<li class="list">The exposed API for POSIX signals, POSIX pipes, and POSIX message queues are discussed as part of this chapter. For each technique, an example is provided to demonstrate the basic usage.</li>
				<li class="list">Computer networks and how two processes can communicate over an existing network.</li>
				<li class="list">The listener-connector model and how two processes can establish a transport connection over a number of networks. This is the basis for our future discussions regarding socket programming.</li>
				<li class="list">What socket programming is and what socket objects are.</li>
				<li class="list">The sequences that exist for each of the processes participating in a listener-connector connection, and the API that they have to use from the POSIX socket library.</li>
			</ul>
			<p class="normal">In the first section, we are going to revisit IPC techniques.<a id="_idTextAnchor489"/><a id="_idTextAnchor490"/></p>
			<h1 id="_idParaDest-261" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor491"/>IPC techniques</h1>
			<p class="normal">An IPC technique<a id="_idIndexMarker1311"/> generally refers to any means that is used by processes to communicate and transmit data. In the previous chapter, we discussed filesystems and shared memory as our beginning approach to share data between two processes. We didn't use the term 'IPC' for these techniques at that point, but this is in fact what they are! In this chapter, we will add a few more IPC techniques to the ones that we have encountered already, but we should remember that they are different in a number of ways. Before jumping to the differences and trying to categorize them, let's list some IPC techniques:</p>
			<ul>
				<li class="list">Shared memory</li>
				<li class="list">Filesystem (both on disk and in memory)</li>
				<li class="list">POSIX signals</li>
				<li class="list">POSIX pipes</li>
				<li class="list">POSIX message queues</li>
				<li class="list">Unix domain sockets</li>
				<li class="list">Internet (or network) sockets</li>
			</ul>
			<p class="normal">From the programming point of view, the shared memory and filesystem techniques are similar in certain ways and because of that they can be put into the same group, known as <em class="italics">pull-based</em> IPC techniques. The rest of the techniques stand out and they have their own category. We refer to them as <em class="italics">push-based</em> IPC techniques. This chapter together with the next chapter are dedicated to push-based IPC, and various techniques are discussed.</p>
			<p class="normal">Note that the IPC <a id="_idIndexMarker1312"/>techniques all are responsible for transmitting a number of messages between two processes. Since we are going to use the term <em class="italics">message</em> heavily in the upcoming paragraphs, it is worth defining it first.</p>
			<p class="normal">Every message contains a series of bytes that are put together according to a well-defined interface, protocol, or standard. The structure of a message should be known by both processes dealing with that message, and it is usually covered as part of a communication protocol.</p>
			<p class="normal">A list of differences between pull-based and push-based techniques<a id="_idIndexMarker1313"/> can be seen as follows:</p>
			<ul>
				<li class="list">In pull-based techniques, we have a shared resource or <em class="italics">medium</em> external to both processes and available in the user space. Files, shared memories, and even a network service like<a id="_idIndexMarker1314"/> an <strong class="bold">Network Filesystem</strong> (<strong class="bold">NFS</strong>) server can be the shared resource. These mediums are the main place holders for the messages created and consumed by the processes. While in push-based techniques, there is no such a shared resource or medium and instead, there is a <em class="italics">channel</em>. Processes send and receive messages through this channel, and these messages are not stored in any intermediate medium.</li>
				<li class="list">In pull-based techniques, each process must <em class="italics">pull</em> the available messages from the medium. In push-based techniques, the incoming messages are <em class="italics">pushed</em> (<em class="italics">delivered</em>) to the receiver end.</li>
				<li class="list">In pull-based techniques, because of having a shared resource or medium, concurrent access to the medium must be synchronized. That's why we explored the various synchronization techniques for such IPC techniques in the previous chapter. Note that this is not the case regarding push-based techniques and there is no synchronization needed.</li>
				<li class="list">In pull-based techniques, the processes can operate independently. That's because the messages can be stored in a shared resource and it can be fetched later. In other words, the processes can operate in an <em class="italics">async</em> fashion. Conversely, in a push-based IPC technique, both processes should be up and running at the same time, and because the messages are pushed instantly, the receiver process may lose some of the incoming messages if it's down. In other words, the processes operate in a <em class="italics">sync</em> fashion.<div><p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>: </p>
<p class="Information-Box--PACKT-">In push-based techniques, we have a temporary message buffer for each process that holds the incoming pushed messages. This message buffer resides in the kernel and lives as long as the process is running. This message buffer might be accessed concurrently, but the synchronization must be guaranteed by the kernel itself.</p>
</div></li>
			</ul>
			<p class="normal">Messages being either transmitted in an IPC channel when using a push-based technique, or stored in an IPC medium when using a pull-based technique, should have a content that is understandable by the receiving process. This means that both processes – the sender end and the receiver end – must know how to create and parse the messages. Since messages are made up of bytes, this implies that both processes must know how to translate an object (a text or video) into a series of bytes, and how to resurrect the same object from the received bytes. We'll see shortly that the inter-operability of the processes is covered by a common <em class="italics">communication protocol</em> adapted by both of them.</p>
			<p class="normal">In the following section, we'll discuss communication protocols in greater de<a id="_idTextAnchor492"/><a id="_idTextAnchor493"/><a id="_idTextAnchor494"/><a id="_idTextAnchor495"/>pth.</p>
			<h1 id="_idParaDest-262" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor496"/>Communication protocols</h1>
			<p class="normal">Having just a<a id="_idIndexMarker1315"/> communication channel or medium is not enough. Two parties willing to communicate over a shared channel need to understand one another, too! A very simple example is when two people want to talk to each other using the same language, such as English or Japanese. Here, the language can be considered as the protocol used by two parties in order to communicate.</p>
			<p class="normal">In the context of IPC, processes are no exception; they need a common language so they can communicate. Technically, we use the term <em class="italics">protocol</em> to refer to this common language between any two parties. As part of this section, we are going to discuss communication protocols and their various characteristics such as the <em class="italics">message length</em> and the <em class="italics">message content</em>. Before being able to talk about these characteristics, we need to describe a communication protocol in a deeper sense. Note that our main focus in this chapter is IPC techniques; therefore, we only talk about communication protocols between two processes. Any kind of communication happening between parties other than processes cannot be covered as part of this chapter.</p>
			<p class="normal">Processes can only transmit bytes. This effectively means that every piece of information must be translated into a series of bytes before being <a id="_idIndexMarker1316"/>transmitted by one of the IPC techniques. This is<a id="_idIndexMarker1317"/> called <em class="italics">serialization</em> or <em class="italics">marshalling</em>. A paragraph of text, a piece of audio, a music track, or any other kind of object must be serialized before being sent over an IPC channel, or being stored in an IPC medium. Hence, regarding the IPC communication protocols, this means that the messages transmitted between processes are a series of bytes in a very specific and well-defined order.</p>
			<p class="normal">Conversely, when a process receives a series of bytes from an IPC channel, it should be able to <a id="_idIndexMarker1318"/>reconstruct the original <a id="_idIndexMarker1319"/>object out of the incoming bytes. This is called <em class="italics">deserialization</em> or <em class="italics">unmarshaling</em>.</p>
			<p class="normal">To explain serialization and deserialization in the same flow, when a process wants to send an object to another process over any already established IPC channel, the sender process first serializes the object into a byte array. Then it transmits the byte array to the other party. On the receiver side, the process deserializes the incoming bytes and it resurrects the sent object. As you can see, these operations are the inverse of each other, and they are used by both ends in order to use a byte-oriented IPC channel to transmit information. This is something you can't escape from, and every IPC-based technology (RPC, RMI, and so on) relies heavily on the serialization and deserialization of various objects. From now on, we use the term serialization to refer to both serialization and deserialization operations.</p>
			<p class="normal">Note that serialization is not<a id="_idIndexMarker1320"/> limited to push-based IPC techniques that we have discussed so far. In pull-based IPC techniques such as filesystem or shared memory, we still need serialization. That's because the underlying mediums in these techniques can store a series of bytes and if a process wants to store an object in a shared file, for instance, it has to serialize it before being able to store it there. Therefore, serialization is universal to all IPC techniques; no matter which IPC method you are using, you have to deal with a great amount of serialization and deserialization while using the underlying channel or medium.</p>
			<p class="normal">Choosing a communication protocol implicitly dictates the serialization because, as part of a protocol, we define the order of bytes very carefully. This is crucial because a serialized object must be deserialized back to the same object on the receiver side. Therefore, both the serializer and deserializer must obey the same rules dictated by the protocol. Having an incompatible serializer and deserializer at both ends effectively means no communication at all, simply because the receiver end cannot reconstruct the transmitted object.</p>
			<div><div><p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">Sometimes, we use the term <em class="italics">parsing</em> as a synonym for <em class="italics">deserialization</em>, but they are in fact fundamentally different.</p>
				</div>
			</div>
			<p class="normal">To make the discussion more tangible, let's talk about some real examples. A web server and a web client <a id="_idIndexMarker1321"/>communicate using <strong class="bold">Hyper Text Transfer Protocol</strong> (<strong class="bold">HTTP</strong>). Therefore, both sides are required to use compatible HTTP serializers and deserializers to speak to each other. As another example, let's talk <a id="_idIndexMarker1322"/>about the <strong class="bold">Domain Name Service</strong> (<strong class="bold">DNS</strong>) protocol. Both the DNS client and server must use compatible serializers and deserializers so that they can communicate. Note that unlike HTTP, which has textual content, DNS is a binary protocol. We discuss this shortly in the upcoming sections.</p>
			<p class="normal">Since serialization<a id="_idIndexMarker1323"/> operations can be used in various components in a software project, they are usually provided as some libraries that can be added to any component wishing to use them. For famous protocol such as HTTP, DNS, and FTP, there are well-known third-party libraries that can be used without hassle. But for custom protocols specially designed for a project, the serialization libraries must be written by the team itself.</p>
			<div><div><p class="Information-Box--PACKT-"><strong class="bold">Note:</strong></p>
					<p class="Information-Box--PACKT-">Well-known protocols such as HTTP, FTP, and DNS are standards and they are described in some official open documents <a id="_idIndexMarker1324"/>called <strong class="bold">request for comments</strong> (<strong class="bold">RFC</strong>). For example, the HTTP/1.1 protocol is described in RFC-2616. A simple Google search will take you to the RFC page.</p>
				</div>
			</div>
			<p class="normal">As a further note regarding <em class="italics">serialization libraries</em>, they can be provided in various programming languages. Note that a specific serialization itself is not dependent on any programming language because it only talks about the order of bytes and how they should be interpreted. Therefore, the serialization and deserialization algorithms can be developed using any programming language. That's a crucial requirement. In a big software project, we can have multiple components written in various programming languages, and there are situations in which these components must transmit information. Hence, we need the same serialization algorithms written in various languages. For instance, we have HTTP serializers written in C, C++, Java, Python, and so on.</p>
			<p class="normal">To sum up the main point of this section, we need a well-defined protocol between two parties in order for them to talk to each other. An IPC protocol is a standard that dictates how the overall communication must take place and what details must be obeyed regarding the byte order and their meaning in various messages. We have to use some serialization algorithms in order to consume a byte-oriented IPC channel to transmit objects.</p>
			<p class="normal">In the following section, we describe the characteristics of <a id="_idTextAnchor497"/>IPC protocols.</p>
			<h2 id="_idParaDest-263" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor498"/>Protocol characteristics</h2>
			<p class="normal">IPC protocols<a id="_idIndexMarker1325"/> have various characteristics. Briefly, every protocol can specify a different content type for the messages transmitted over an IPC channel. In another protocol, the messages can have a fixed length or a variable length. Some protocols dictate that the provided operations must be consumed in a synchronous fashion, while there are protocols that allow asynchronous usage. In the following sections, we will be covering these distinguishing factors. Note that the existing protocols can be categorized based on these <a id="_idTextAnchor499"/>characteristics.</p>
			<h3 id="_idParaDest-264" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor500"/>Content type</h3>
			<p class="normal">Messages sent <a id="_idIndexMarker1326"/>over IPC channels can have <em class="italics">textual</em> content or <em class="italics">binary</em> content or a combination of both of them. Binary content has bytes with values ranging over all possible numerical values between 0 to 255. But textual content has only characters that are used in text. In other words, only alphanumerical characters together with some symbols are allowed in textual content.</p>
			<p class="normal">While textual content can be considered as a special case of binary content, we try to keep them separate and treat them differently. For instance, textual messages are good candidates to be compressed before sending, while binary messages suffer from a poor <em class="italics">compression ratio</em> (the actual size divided by the compressed size). It is good to know that some protocols are purely textual, such as JSON, and some others are fully binary, such as DNS. There are also protocols such as BSON and HTTP that allow message contents to be a combination of both textual and binary data. In these protocols, raw bytes can be mixed with text to form the final message.</p>
			<p class="normal">Note that binary content can be sent as text. There are various encodings that allow you to represent binary content using textual characters. <em class="italics">Base64</em> is one of the most famous <em class="italics">binary-to-text encoding</em> algorithms that allows such a transformation. These encoding algorithms are widely used in purely textual protocols such as JSON to sen<a id="_idTextAnchor501"/>d binary data.</p>
			<h3 id="_idParaDest-265" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor502"/>Length of messages</h3>
			<p class="normal">The messages <a id="_idIndexMarker1327"/>produced according to an IPC protocol can be either <em class="italics">fixed-length</em> or <em class="italics">variable-length</em>. By fixed-length, we mean that all messages have the same length. Conversely, by variable-length, we mean that the produced messages can have different lengths. Receiving either fixed-length messages or variable-length messages have an immediate impact on the receiver side while deserializing the content of a message. Using a protocol that always produces fixed-length messages can reduce the burden of parsing receiving messages because the receiver already knows the number of bytes that it should read from the channel, and messages with the same size usually (not always) have the same structure. When reading fixed-length messages from an IPC channel, if all of them follow the same structure, we have a nice opportunity to use C structures to refer to those bytes through some already-defined fields, similar to what we did for objects placed in shared memories in the previous chapter.</p>
			<p class="normal">With protocols that produce variable-length messages, finding where an individual message ends is not that easy, and the receiver side somehow (which we explain shortly) should decide whether it has read a complete message or more bytes must be read from the channel. Note that the receiver might read multiple chunks from the channel before reading a complete message, and a single chunk may contain data from two adjacent messages. We will see an example of this in the next chapter.</p>
			<p class="normal">Since most protocols are <a id="_idIndexMarker1328"/>variable-length and you usually don't have the luxury of dealing with fixed-length messages, it is worth discussing the methods that various protocols adopt to make their variable-length messages distinguishable or separable. In other words, these protocols use a mechanism to mark the end of a message and, this way, the receiver can use those marks to indicate that it has read a complete message. Next, you can see some of these methods:</p>
			<ul>
				<li class="list"><strong class="bold">Using a delimiter or a separator</strong>: A delimiter<a id="_idIndexMarker1329"/> or separator is a series of<a id="_idIndexMarker1330"/> bytes (in binary messages) or characters (in textual messages) that indicates the end of a message. The delimiter should be chosen depending on the content of the messages, because it should be easily distinguishable from the actual content.</li>
				<li class="list"><strong class="bold">Length-prefix framing</strong>: In these <a id="_idIndexMarker1331"/>protocols, each message has a fixed-length prefix (usually 4 bytes or even more) that carries the number of bytes that should be read by the receiver in order to have a complete message. Various protocols such <a id="_idIndexMarker1332"/>as all <strong class="bold">Tag-Value-Length</strong> (<strong class="bold">TLV</strong>) protocols, with <strong class="bold">Abstract Syntax Notation</strong> (<strong class="bold">ASN</strong>) as an example, use this technique.</li>
				<li class="list"><strong class="bold">Using a finite-state machine</strong>: These protocols follow a <em class="italics">regular grammar</em> that can be modeled by a <em class="italics">finite-state machine</em>. The receiver side should be aware of the grammar of the<a id="_idIndexMarker1333"/> protocol, and it should use a proper deserializer that works based on a finite-state machine to read a complete messa<a id="_idTextAnchor503"/>ge from the IPC channel.</li>
			</ul>
			<h3 id="_idParaDest-266" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor504"/>Sequentiality</h3>
			<p class="normal">In most <a id="_idIndexMarker1334"/>protocols, we have a <em class="italics">conversation</em> happening between two processes that follows a <em class="italics">request-response</em> scheme. One of the parties sends a request and the other side replies. This scheme is usually used in client-server scenarios. The listener process, often the server process, waits for a message, and when the message is received, it replies accordingly.</p>
			<p class="normal">If the protocol is synchronous or sequential, the sender (client) will wait until the listener (server) completes the request and sends back the reply. In other words, the sender stays in a <em class="italics">blocking</em> state until the listener replies. In an asynchronous protocol, the sender process isn't blocked, and it can continue with another task while the request is being processed by the listener. That is, the sender won't get blocked while the reply is being prepared.</p>
			<p class="normal">In an asynchronous protocol, there should be a <em class="italics">pulling</em> or <em class="italics">pushing</em> mechanism in place, which allows the sender to check for the reply. In a pulling scenario, the sender will regularly ask the listener about the result. In a pushing scenario, the listener will push back the reply to the sender via the same or a different communication channel.</p>
			<p class="normal">The sequentiality of a<a id="_idIndexMarker1335"/> protocol is not limited to request-response scenarios. Messaging applications usually use this technique to have the maximum responsiveness both on the server-si<a id="_idTextAnchor505"/><a id="_idTextAnchor506"/>de and on the client-side.</p>
			<h1 id="_idParaDest-267" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor507"/>Single-host communication</h1>
			<p class="normal">In this section, we are<a id="_idIndexMarker1336"/> going to talk about single-host IPC. Multiple-host IPC will be the subject of our discussion in the next chapter. There are four main techniques that can be used by processes to communicate when they reside on the same machine:</p>
			<ul>
				<li class="list">POSIX signals</li>
				<li class="list">POSIX pipes</li>
				<li class="list">POSIX message queues</li>
				<li class="list">Unix domain sockets</li>
			</ul>
			<p class="normal">POSIX signals, unlike the other preceding techniques, don't create a communication channel between the processes, but can be used as a way to notify a process about an event. In certain scenarios, such signals can be used by processes to notify each other about specific events in the system.</p>
			<p class="normal">Before jumping to the first IPC technique, POSIX signals, let's discuss file descriptors. Other than POSIX signals, no matter which IPC technique you use, you will be dealing with file descriptors of some sort. Therefore, we'll now dedicate a separate section to them and discuss them further.</p>
			<h2 id="_idParaDest-268" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor508"/>File descriptors</h2>
			<p class="normal">Two communicating <a id="_idIndexMarker1337"/>processes can be running either on the same machine or on two different machines connected by a computer network. In this section and much of this chapter, our focus is on the first case, in which processes reside on the same machine. That's where file descriptors become immensely important. Note that in multiple-host IPC we will still be dealing with file descriptors, but they are called <em class="italics">sockets</em> there. We will discuss them thoroughly in the upcoming chapter.</p>
			<p class="normal">A file descriptor<a id="_idIndexMarker1338"/> is an abstract handle to an object within the system that can be used to read and write data. As you can see, despite the name, file descriptors can refer to a wide range of available mechanisms that deal with reading and modifying byte streams.</p>
			<p class="normal">Regular files are certainly among the objects that can be referred to by file descriptors. Such files are located on filesystems, either on a hard disk or in memory.</p>
			<p class="normal">Other things that can be referred to and accessed via file descriptors are devices. As we saw in <em class="italics">Chapter 10</em>, <em class="italics">Unix - History and Architecture</em>, each device can be accessed using a device file, which is usually found in the <code class="Code-In-Text--PACKT-">/dev</code> directory.</p>
			<p class="normal">Regarding push-based IPC techniques, a file descriptor can represent an IPC channel. In this case, the file descriptor can be used to read and write data from and to the represented channel. That's why the first step in setting up an IPC channel is to define a number of file descriptors.</p>
			<p class="normal">Now that you know more about file descriptors and what they represent, we can move on and discuss the first IPC technique that can be used in single-host multi-process system; however, POSIX signals don't use file descriptors. You are going to hear more about file descriptors in the future sections dedicated to POSIX pipes and POSIX message queues. Le<a id="_idTextAnchor509"/>t's begin with POSIX signals.</p>
			<h2 id="_idParaDest-269" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor510"/>POSIX signals</h2>
			<p class="normal">In POSIX systems, processes<a id="_idIndexMarker1339"/> and threads can send and receive a number of predefined<a id="_idIndexMarker1340"/> signals. A signal can be sent either by a process, or a thread, or by the kernel itself. Signals are actually meant to notify a process or a thread about an event or error. For example, when the system is going to be rebooted, the system sends a <code class="Code-In-Text--PACKT-">SIGTERM</code> signal to all processes to let them know that a rebooting is in progress and they must immediately quit. Once a process receives this signal, it should react accordingly. In some cases, nothing should be done, but in some cases, the current state of the process should be persisted.</p>
			<p class="normal">The following<a id="_idIndexMarker1341"/> table shows the available signals in a Linux system. The table is extracted from the<a id="_idIndexMarker1342"/> Linux signals<a href="http://www.man7.org/linux/man-pages/man7/signal.7.html"> manual page that can be found at http://www.man7.org/</a>linux/man-pages/man7/signal.7.html:</p>
			<pre> Signal      Standard   Action   Comment ───────────────────────────────────────────────────────────
SIGABRT      P1990      Core    Abort signal from abort(3)SIGALRM      P1990      Term    Timer signal from alarm(2)SIGBUS       P2001      Core    Bus error (bad memory access)SIGCHLD      P1990      Ign     Child stopped or terminated SIGCLD         -        Ign     A synonym for SIGCHLD SIGCONT      P1990      Cont    Continue if stopped SIGEMT         -        Term    Emulator trap SIGFPE       P1990      Core    Floating-point exception SIGHUP       P1990      Term    Hangup detected on controlling terminal                                 or death of controlling process SIGILL       P1990      Core    Illegal Instruction SIGINFO        -                A synonym for SIGPWR SIGINT       P1990      Term    Interrupt from keyboard SIGIO          -        Term    I/O now possible (4.2BSD)SIGIOT         -        Core    IOT trap. A synonym for SIGABRT SIGKILL      P1990      Term    Kill signal SIGLOST        -        Term    File lock lost (unused)SIGPIPE      P1990      Term    Broken pipe: write to pipe with no                                 readers; see pipe(7)SIGPOLL      P2001      Term    Pollable event (Sys V).                                Synonym for SIGIO SIGPROF      P2001      Term    Profiling timer expired SIGPWR         -        Term    Power failure (System V)SIGQUIT      P1990      Core    Quit from keyboard SIGSEGV      P1990      Core    Invalid memory reference SIGSTKFLT      -        Term    Stack fault on coprocessor (unused)SIGSTOP      P1990      Stop    Stop process SIGTSTP      P1990      Stop    Stop typed at terminal SIGSYS       P2001      Core    Bad system call (SVr4);                                see also seccomp(2)SIGTERM      P1990      Term    Termination signal SIGTRAP      P2001      Core    Trace/breakpoint trap SIGTTIN      P1990      Stop    Terminal input for background process SIGTTOU      P1990      Stop    Terminal output for background process SIGUNUSED      -        Core    Synonymous with SIGSYS SIGURG       P2001      Ign     Urgent condition on socket (4.2BSD)SIGUSR1      P1990      Term    User-defined signal 1 SIGUSR2      P1990      Term    User-defined signal 2 SIGVTALRM    P2001      Term    Virtual alarm clock (4.2BSD)SIGXCPU      P2001      Core    CPU time limit exceeded (4.2BSD);                                see setrlimit(2)SIGXFSZ      P2001      Core    File size limit exceeded (4.2BSD);                                see setrlimit(2)SIGWINCH       -        Ign     Window resize signal (4.3BSD, Sun)</pre>
			<p class="packt_figref">Table 19-1: List of all available signals in a Linux system</p>
			<p class="normal">As you can see in the preceding table, not all of the signals are POSIX, and Linux has got its own signals. While most of the signals correspond to well-known events, there are two POSIX signals that <a id="_idIndexMarker1343"/>can be defined by the user. This is mostly used in scenarios when you want to invoke a certain functionality in your program while the process is running. <em class="italics">Example 19.1</em> demonstrates<a id="_idIndexMarker1344"/> how to use signals and how they can be handled in a C program. Next, you can find the code for <em class="italics">example 19.1</em>:</p>
			<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
void handle_user_signals(int signal) {
  switch (signal) {
    case SIGUSR1:
      printf("SIGUSR1 received!\n");
      break;
    case SIGUSR2:
      printf("SIGUSR2 received!\n");
      break;
    default:
      printf("Unsupported signal is received!\n");
  }
}
void handle_sigint(int signal) {
  printf("Interrupt signal is received!\n");
}
void handle_sigkill(int signal) {
  printf("Kill signal is received! Bye.\n");
  exit(0);
}
int main(int argc, char** argv) {
  signal(SIGUSR1, handle_user_signals);
  signal(SIGUSR2, handle_user_signals);
  signal(SIGINT, handle_sigint);
  signal(SIGKILL, handle_sigkill);
  while (1);
  return 0;
}</pre>
			<p class="packt_figref">Code Box 19-1 [ExtremeC_examples_chapter19_1.c]: Handling POSIX signals</p>
			<p class="normal">In the preceding example, we <a id="_idIndexMarker1345"/>have used the <code class="Code-In-Text--PACKT-">signal</code> function to<a id="_idIndexMarker1346"/> assign various signal handlers to some specific signals. As you can see, we have one signal handler for the user-defined signals, one handler for the <code class="Code-In-Text--PACKT-">SIGINT</code> signal, and one for the <code class="Code-In-Text--PACKT-">SIGKILL</code> signal.</p>
			<p class="normal">The program is merely a never-ending loop, and all we want to do is to handle some signals. The following commands show how to compile and run the example in the background:</p>
			<pre><strong class="highlight">$ gcc ExtremeC_examples_chapter19_1.c -o ex19_1.out</strong>
<strong class="highlight">$ ./ex19_1.out &amp;</strong>
[1] 4598
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 19-1: Compiling and running example 19.1</p>
			<p class="normal">Now that we know the PID of the program, we can send it some signals. The PID is 4598 and the program is running in the background. Note that the PID will be different for you. You can use the <code class="Code-In-Text--PACKT-">kill</code> command to send a signal to a process. The following command is used to examine the preceding example:</p>
			<pre><strong class="highlight">$ kill -SIGUSR2 4598</strong>
SIGUSR2 received!
<strong class="highlight">$ kill -SIGUSR1 4598</strong>
SIGUSR2 received!
<strong class="highlight">$ kill -SIGINT 4598</strong>
Interrupt signal is received!
<strong class="highlight">$ kill -SIGKILL 4598</strong>
<strong class="highlight">$</strong>
[1]+  Stopped         ./ex19_1.out
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 19-2: Sending different signals to the background process</p>
			<p class="normal">As you can see, the program handles all signals except the <code class="Code-In-Text--PACKT-">SIGKILL</code> signal. <code class="Code-In-Text--PACKT-">SIGKILL</code> cannot be handled by any process and, usually, a parent process that has spawned the process can be notified about its child being killed.</p>
			<p class="normal">Note that the <code class="Code-In-Text--PACKT-">SIGINT</code> signal, or the interrupt signal, can be sent to a foreground program by pressing <kbd class="Key--PACKT-">Ctrl</kbd> + <kbd class="Key--PACKT-">C</kbd>. Therefore, whenever you press this combination of keys, you are actually sending an interrupt signal to the running program. The default handler just stops the program, but as you can see in the preceding example, we can handle the <code class="Code-In-Text--PACKT-">SIGINT</code> signal and ignore it.</p>
			<p class="normal">In addition to the ability to send a <a id="_idIndexMarker1347"/>signal to a process using shell <a id="_idIndexMarker1348"/>commands, a process also can send a signal to another process if it knows the target process's PID. You can use the <code class="Code-In-Text--PACKT-">kill</code> function (declared in <code class="Code-In-Text--PACKT-">signal.h</code>), which does exactly the same as its command-line version. It accepts two parameters: the first is the target PID and the second is the signal number. It is also possible for a process or a thread to use the <code class="Code-In-Text--PACKT-">kill</code> or <code class="Code-In-Text--PACKT-">raise</code> functions to send a signal to itself. Note that the <code class="Code-In-Text--PACKT-">raise</code> function sends the signal to the current thread. These functions can be quite useful in scenarios in which you want to notify another part of your program about an event.</p>
			<p class="normal">The last note about the preceding example is that, as you saw in <em class="italics">Shell Box 19-2</em>, it doesn't matter that the main thread is busy with the never-ending loop, the signals are delivered asynchronously. Therefore, you can be sure that you always receive the incoming signals.</p>
			<p class="normal">Now it's time to talk about POSIX pipes as another single-host IPC technique that <a id="_idTextAnchor511"/>can be useful in certain circumstances.</p>
			<h2 id="_idParaDest-270" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor512"/>POSIX pipes</h2>
			<p class="normal">POSIX Pipes<a id="_idIndexMarker1349"/> in Unix are <a id="_idIndexMarker1350"/>unidirectional channels that can be used between two processes that need to exchange messages. Upon creating a POSIX pipe, you will get two file descriptors. One file descriptor is used to write to the pipe, and the other one is used to read from the pipe. The following example shows the basic usage of a POSIX pipe:</p>
			<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
int main(int argc, char** argv) {
  int fds[2];
  pipe(fds);
  int childpid = fork();
  if (childpid == -1) {
    fprintf(stderr, "fork error!\n");
    exit(1);
  }
  if (childpid == 0) {
    // Child closes the read file descriptor
    close(fds[0]);
    char str[] = "Hello Daddy!";
    // Child writes to the write file descriptor
    fprintf(stdout, "CHILD: Waiting for 2 seconds ...\n");
    sleep(2);
    fprintf(stdout, "CHILD: Writing to daddy ...\n");
    write(fds[1], str, strlen(str) + 1);
  } else {
    // Parent closes the write file descriptor
    close(fds[1]);
    char buff[32];
    // Parent reads from the read file descriptor
    fprintf(stdout, "PARENT: Reading from child ...\n");
    int num_of_read_bytes = read(fds[0], buff, 32);
    fprintf(stdout, "PARENT: Received from child: %s\n", buff);
  }
  return 0;
}</pre>
			<p class="packt_figref">Code Box 19-2 [ExtremeC_examples_chapter19_2.c]: Example 19.2 on using a POSIX pipe</p>
			<p class="normal">As you can see, in the second line of the <code class="Code-In-Text--PACKT-">main</code> function, we have used the <code class="Code-In-Text--PACKT-">pipe</code> function. As we've already said, it accepts an array of two file descriptors and opens two file descriptors, one for reading from the pipe and the other one for writing to it. The first file descriptor, found at index 0, should be used for reading; and the second file descriptor, located at index 1, should be used for writing to the pipe.</p>
			<p class="normal">In order to have two processes, we <a id="_idIndexMarker1351"/>have used the fork API. As we've explained in <em class="italics">Chapter 17</em>, <em class="italics">Process Execution</em>, the fork API clones the parent process and creates a new child process. Therefore, the opened file descriptors are available to the child process after calling the <code class="Code-In-Text--PACKT-">fork</code> function.</p>
			<p class="normal">When the child process<a id="_idIndexMarker1352"/> is spawned, the parent process enters the <code class="Code-In-Text--PACKT-">else</code> block and the child process enters the <code class="Code-In-Text--PACKT-">if</code> block. Firstly, each process should close the file descriptor that it is not going to use. In this example, the parent wants to read from the pipe and the child wants to write to the pipe. That's why the parent process closes the second file descriptor (the write file descriptor) and the child process closes the first file descriptor (the read file descriptor). Note that a pipe is unidirectional and reverse communication is not possible.</p>
			<p class="normal">The following shell box shows the output of the preceding example:</p>
			<pre><strong class="highlight">$ gcc ExtremeC_examples_chapter19_2.c -o ex19_2.out</strong>
<strong class="highlight">$ ./ex19_2.out</strong>
PARENT: Reading from child ...
CHILD: Waiting for 2 seconds ...
CHILD: Writing to daddy ...
PARENT: Received from child: Hello Daddy!
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 19-3: Output of running example 19.2</p>
			<p class="normal">As you can see in <em class="italics">Code Box 19-2</em>, for reading and writing operations we use the <code class="Code-In-Text--PACKT-">read</code> and <code class="Code-In-Text--PACKT-">write</code> functions. As we mentioned before, in push-based IPC, a file descriptor refers to a byte channel, and when you have a file descriptor pointing to a channel, you can use the file descriptor's related functions. The <code class="Code-In-Text--PACKT-">read</code> and <code class="Code-In-Text--PACKT-">write</code> functions accept a file descriptor and no matter what kind of IPC channel is behind, they operate on the underlying channel the same way.</p>
			<p class="normal">In the previous example, we used the fork API to spawn a new process. If a situation arises in which we have two different processes spawned separately, the question is, how can they communicate through a shared pipe? If a process demands access to a pipe object within the system, it should have the corresponding file descriptor. There are two options available:</p>
			<ul>
				<li class="list">One of the processes should set up the pipe and transfer the corresponding file descriptors to the other process.</li>
				<li class="list">The processes should use a named pipe.</li>
			</ul>
			<p class="normal">In the first scenario, the processes must use a Unix domain socket channel in order to exchange file descriptors. The problem is that if such a channel exists between the two processes, they could use it for further communication and there would be no need to set up another channel (POSIX pipe) that has a less friendly API than Unix domain sockets.</p>
			<p class="normal">The second scenario seems <a id="_idIndexMarker1353"/>to be more promising. One of the processes could use the <code class="Code-In-Text--PACKT-">mkfifo</code> function and create a queue file by providing a path. Then, the second process could use the path to the already created file and open it for further communication. Note that the channel is still unidirectional and, depending on the scenario, one of the processes should open the file in read-only mode and the other should open it in write-only mode.</p>
			<p class="normal">One more point should be <a id="_idIndexMarker1354"/>discussed about the previous example. As you can see, the child process waits for 2 seconds before writing to the pipe. In the meantime, the parent process is blocked on the <code class="Code-In-Text--PACKT-">read</code> function. So, while there is no message written to the pipe, the process reading from the pipe becomes blocked.</p>
			<p class="normal">As the final note in this section, we know that POSIX pipes are push-based. As we've explained this before, push-based IPC techniques have a corresponding temporary kernel buffer for holding the incoming pushed messages. POSIX pipes are no exception and the kernel holds the written messages until they are read. Note that if the owner process quits, the pipe object and its corresponding kernel buffer are destroyed.</p>
			<p class="normal">In the following s<a id="_idTextAnchor513"/>ection, we will discuss POSIX message queues.</p>
			<h2 id="_idParaDest-271" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor514"/>POSIX message queues</h2>
			<p class="normal">Kernel-hosted<a id="_idIndexMarker1355"/> message queues are part of the POSIX standard. They differ <a id="_idIndexMarker1356"/>significantly from POSIX pipes in a number of ways. Here, we examine the fundamental differences:</p>
			<ul>
				<li class="list">The elements inside a pipe are bytes. Instead, message queues hold messages. Pipes are not aware of any existing structure in the written bytes, while message queues keep actual messages and each call to the <code class="Code-In-Text--PACKT-">write</code> function results in a new message being added to the queue. Message queues preserve the boundaries between written messages. To elaborate more on this, suppose that we have three messages: the first one has 10 bytes, the second one has 20 bytes, and the third one has 30 bytes. We write these messages both to a POSIX pipe and to a POSIX message queue. The pipe only knows that it has 60 bytes inside, and it allows a program to read 15 bytes. But the message queue only knows that it has 3 messages and it doesn't allow a program to read 15 bytes because we don't have any messages with 15 bytes.</li>
				<li class="list">Pipes have a maximum size, the unit of which is the number of bytes. Message queues instead have a maximum number of messages. In message queues, every message has a maximum size in terms of bytes.</li>
				<li class="list">Every message queue, like a named shared memory or a named semaphore, opens a file. While these files are not regular files, they can be used by future processes to access the same message queue instance.</li>
				<li class="list">Message queues can be prioritized, while pipes don't care about the priority of bytes.</li>
			</ul>
			<p class="normal">And they have the following properties in common:</p>
			<ul>
				<li class="list">Both are unidirectional. In order to have bidirectional communication, you need to create two instances of pipes or queues.</li>
				<li class="list">Both have limited capacity; you cannot write any number of bytes or messages that you want.</li>
				<li class="list">Both are represented using file descriptors in most POSIX systems; therefore, I/O functions such as <code class="Code-In-Text--PACKT-">read</code> and <code class="Code-In-Text--PACKT-">write</code> can be used.</li>
				<li class="list">Both techniques are <em class="italics">connection-less</em>. In other words, if two different processes write two different messages, it is possible for one of them to read the other process's message. In other words, there is no ownership defined for the messages and any process can read them. This would be a problem, especially when there is more than one process operating on the same pipe or message queue concurrently.</li>
			</ul>
			<div><div><p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">POSIX message queues explained in this chapter should not be confused with message queue brokers being<a id="_idIndexMarker1357"/> used in the <strong class="bold">Message Queue Middleware</strong> (<strong class="bold">MQM</strong>) architecture.</p>
				</div>
			</div>
			<p class="normal">There are various <a id="_idIndexMarker1358"/>resources on the internet that explain POSIX message queues. The following link explains POSIX message queues specifically for the QNX operating system, but most of the content is still applicable to other POSIX systems: https://users.pja.edu.pl/~jms/qnx/help/watcom/clibref/mq_overview.html.</p>
			<p class="normal">Now it is time to have <a id="_idIndexMarker1359"/>an example. <em class="italics">Example 16.3 </em>has the same scenario as we had in <em class="italics">example 16.2</em>, but it uses a POSIX message queue instead of a POSIX pipe. All the functions related to POSIX message queues are declared in the <code class="Code-In-Text--PACKT-">mqueue.h</code> header file. We will explain some of them shortly. </p>
			<p class="normal">Note that the following code doesn't compile on macOS because OS/X doesn't support POSIX message queues:</p>
			<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;mqueue.h&gt;
int main(int argc, char** argv) {
  // The message queue handler
  mqd_t mq;
  struct mq_attr attr;
  attr.mq_flags = 0;
  attr.mq_maxmsg = 10;
  attr.mq_msgsize = 32;
  attr.mq_curmsgs = 0;
  int childpid = fork();
  if (childpid == -1) {
    fprintf(stderr, "fork error!\n");
    exit(1);
  }
  if (childpid == 0) {
    // Child waits while the parent is creating the queue
    sleep(1);
    mqd_t mq = mq_open("/mq0", O_WRONLY);
    char str[] = "Hello Daddy!";
    // Child writes to the write file descriptor
    fprintf(stdout, "CHILD: Waiting for 2 seconds ...\n");
    sleep(2);
    fprintf(stdout, "CHILD: Writing to daddy ...\n");
    mq_send(mq, str, strlen(str) + 1, 0);
    mq_close(mq);
  } else {
    mqd_t mq = mq_open("/mq0", O_RDONLY | O_CREAT, 0644, &amp;attr);
    char buff[32];
    fprintf(stdout, "PARENT: Reading from child ...\n");
    int num_of_read_bytes = mq_receive(mq, buff, 32, NULL);
    fprintf(stdout, "PARENT: Received from child: %s\n", buff);
    mq_close(mq);
    mq_unlink("/mq0");
  }
  return 0;
}</pre>
			<p class="packt_figref">Code Box 19-3 [ExtremeC_examples_chapter19_3.c]: Example 19.3 on using a POSIX message queues</p>
			<p class="normal">In order to compile the<a id="_idIndexMarker1360"/> preceding code, run the following commands. Note that the preceding code should be linked with the <code class="Code-In-Text--PACKT-">rt</code> library <a id="_idIndexMarker1361"/>on Linux:</p>
			<pre><strong class="highlight">$ gcc ExtremeC_examples_chapter19_3.c -lrt -o ex19_3.out</strong>
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 19-4: Building example 19.3 on Linux</p>
			<p class="normal">The following shell box demonstrates the output of <em class="italics">example 19.3</em>. As you can see, the output is exactly the same as we had for <em class="italics">example 19.2</em> but it uses POSIX message queues to perform the same logic that we wrote in <em class="italics">example 19.2</em>:</p>
			<pre><strong class="highlight">$ ./ex19_3.out</strong>
PARENT: Reading from child ...
CHILD: Waiting for 2 seconds ...
CHILD: Writing to daddy ...
PARENT: Received from child: Hello Daddy!
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 19-5: Running example 19.3 on Linux</p>
			<p class="normal">Note that both POSIX pipes and message queues have a limited buffer in the kernel. Therefore, writing to pipes and message queues without having a consumer that reads their content can lead to all write operations being blocked. In other words, any <code class="Code-In-Text--PACKT-">write</code> function call would remain blocked until a consumer reads a message from the message queue or some bytes from the pipe.</p>
			<p class="normal">In the following section, we will briefly explain Unix domain sockets. They are usually the first choice when co<a id="_idTextAnchor515"/>nnecting two local processes in a single-host setup.</p>
			<h2 id="_idParaDest-272" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor516"/>Unix domain sockets</h2>
			<p class="normal">Another technique<a id="_idIndexMarker1362"/> that can be used by a number of processes to communicate in <a id="_idIndexMarker1363"/>a single-host deployment is using Unix domain sockets. They are special kind of sockets that only operate within the same machine. Therefore, they are different from network sockets, which allow two processes from two different machines to talk to each other over an existing network. Unix domain sockets have various characteristics that make them important and sophisticated in comparison to POSIX pipes and POSIX message queues. The most important characteristic is the fact that Unix domain sockets are bidirectional. Therefore, a single socket object is enough to read from and write to the underlying channel. In other words, the channels operated by Unix domain sockets are full-duplex. In addition, Unix domain sockets can be both <em class="italics">session-aware</em> and <em class="italics">message-aware</em>. This makes them even more flexible. We will discuss session-awareness and message-awareness in the following sections.</p>
			<p class="normal">Since Unix domain sockets cannot be discussed without knowing the basics of socket programming, we won't go any further than this in this chapter. Instead, in the following sections, we <a id="_idIndexMarker1364"/>introduce socket <a id="_idIndexMarker1365"/>programming and the concepts around it. A full discussion regarding Unix domain sockets will be given in the<a id="_idTextAnchor517"/> following chapter. Let's begin with socket programming.</p>
			<h1 id="_idParaDest-273" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor518"/>Introduction to socket programming</h1>
			<p class="normal">As part of this chapter, we <a id="_idIndexMarker1366"/>decided to discuss socket programming before going through the real C code examples as part of the next chapter. That's because there are some fundamental concepts that you need to know before jumping to the code.</p>
			<p class="normal">Socket programming can be done both on single-host and multi-host deployments. As you might have guessed, the socket programming in a single-host system is done through Unix domain sockets. In a multi-host setup, socket programming is about creating and using network sockets. Both Unix sockets and network sockets more or less use the same API and share the same concepts, so it would make sense to cover them together in the next chapter.</p>
			<p class="normal">One of the key concepts before using network sockets is how computer networks work. In the following section, we are going to talk about this and introduce you to computer networks. There are many terms and concepts that you should know before being able to write your first socket programming example.</p>
			<h2 id="_idParaDest-274" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor519"/>Computer networks</h2>
			<p class="normal">The approach <a id="_idIndexMarker1367"/>we take to explain the networking concepts in this section is different from the usual texts you might find about this topic. Our goal is to create a basic understanding of how things work in a computer network, especially between two processes. We want to look at this concept from a programmer's point of view. And the main actors in our discussion are processes, not computers. Therefore, you might find the order of sections a bit odd at first, but it will help you to get the idea of how IPC works over a computer network.</p>
			<p class="normal">Note that this section shouldn't be considered a complete description of computer networks and, of course,<a id="_idTextAnchor520"/> it cannot be done in a few pages and in just one section.</p>
			<h3 id="_idParaDest-275" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor521"/>Physical layer</h3>
			<p class="normal">First, let's forget<a id="_idIndexMarker1368"/> about processes and just consider the computers, or simply the machines. Before moving forward, note that we use various terms to refer to a computer in a network. We can call it a computer, machine, host, node, or even a system. Of course, the context helps you to find out the true meaning behind a given term.</p>
			<p class="normal">The first step toward having multi-host software is a number of computers that are connected together through a network or, more precisely, a computer network. For now, let's focus on two computers that we want to connect. In order to connect these two physical machines to one other, we certainly need some sort of physical medium such as a piece of wire or a wireless setup.</p>
			<p class="normal">Of course, without such a physical medium (which doesn't need to be visible, like in a wireless network), the connection would not be possible. These physical connections are analogous to roads between cities. We will stick to this analogy because it can explain what is happening inside a computer network very closely.</p>
			<p class="normal">All the hardware equipment required to connect two machines physically are considered to be part of the <em class="italics">physical layer</em>. This is the first and the most basic layer that we explore. Without having this layer, it is impossible to transmit data between two computers and assume them to be connected. Everything above this layer is not physical and all you find is a set of various standards regarding how the data should be tr<a id="_idTextAnchor522"/>ansmitted.</p>
			<p class="normal">Let's talk about the next layer, the link layer.</p>
			<h3 id="_idParaDest-276" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor523"/>Link layer</h3>
			<p class="normal">While merely having<a id="_idIndexMarker1369"/> roads is not sufficient for traffic to move along them, the same is true for the physical connections between computers. In order to use roads, we need laws and regulations about the vehicles, signs, materials, borders, speed, lanes, directions, and so on, and without them, traveling along the roads would be chaotic and problematic. Similar rules are needed for direct physical connections between two computers.</p>
			<p class="normal">While the physical components and devices required to connect a number of computers all belong to the physical layer, the mandatory regulations and protocols that govern the way data is transmitted along the physical layer all belong to an upper layer called the <em class="italics">link layer</em>.</p>
			<p class="normal">As part of the regulations enforced by the link protocols, messages should be broken into pieces called <em class="italics">frames</em>. This is analogous to the regulations in a road system that defines a maximum length of the vehicles traveling on a certain road. You cannot drive a 1 km-long trailer (presuming that it is physically possible) on a road. You have to break it down into smaller segments, or into smaller vehicles. Similarly, a long piece of data should be broken into multiple frames, and each frame must be traveling along the network freely, independent of the other frames.</p>
			<p class="normal">It is worth mentioning that networks can exist between any two computational devices. They don't necessarily need to be computers. There are many devices and machines in industry that can be connected to each other to form a network. Industrial networks have their own standards for their physical wiring, connectors, terminators, and so on, and they have their own link protocols and standards.</p>
			<p class="normal">Many standards describe <a id="_idIndexMarker1370"/>such link connections, for instance, how a desktop computer can get connected to an industrial machine. One of the most prominent link protocols that is designed to connect a number of computers via a wire is <em class="italics">Ethernet</em>. Ethernet describes all the rules and regulations governing data transmission over computer networks. We have another widely used link protocol called IEEE 802.11, which governs wireless networks.</p>
			<p class="normal">A network consisting of computers (or any other groups of homogenous computing machines or devices) connected by a physical connection via a specific link protocol is called a <strong class="bold">Local Area Network</strong> (<strong class="bold">LAN</strong>). Note that any device willing to join a LAN must use a physical<a id="_idIndexMarker1371"/> component called a <em class="italics">network adapter</em> or a <strong class="bold">Network Interface Controller</strong> (<strong class="bold">NIC</strong>) attached<a id="_idIndexMarker1372"/> to it. For instance, the computers wanting to join an Ethernet network must have an <em class="italics">Ethernet NIC</em>.</p>
			<p class="normal">A computer can have multiple NICs attached. Each NIC can connect to a specific LAN, therefore a computer with three NICs is able to connect to three different LANs simultaneously.</p>
			<p class="normal">It is also possible that it uses all its three NICs to connect to the same LAN. The way that you configure NICs and how you connect computers to various LANs should be designed beforehand and a precise plan should be in place.</p>
			<p class="normal">Every NIC has a specific and unique address defined by the governing link protocol. This address will be used for data transmission between the nodes inside a LAN. The Ethernet and IEEE 802.11 protocols<a id="_idIndexMarker1373"/> define a <strong class="bold">media access control</strong> (<strong class="bold">MAC</strong>) address for every compatible NIC. Therefore, any Ethernet NIC or IEEE 802.11 Wi-Fi adapter should have a unique MAC address in order to join a compatible LAN. Inside a LAN, the assigned MAC addresses should be unique. Note that ideally, any MAC address should be unique universally and unchangeable. However, this is not the case, and you can even set the MAC address of a NIC.</p>
			<p class="normal">To summarize what we have explained so far, we have a stack of two layers, the physical layer beneath and the link layer above. This is enough to connect a number of computers on a single LAN. But it doesn't end here. We need another layer on top of these two layers to be able to connect computers fro<a id="_idTextAnchor524"/>m various LANs with or without any intermediate LANs in between.</p>
			<h3 id="_idParaDest-277" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor525"/>Network layer</h3>
			<p class="normal">So far, we've seen that <a id="_idIndexMarker1374"/>MAC addresses are used in Ethernet LANs in order to connect a number of nodes. But what happens if two computers from two different LANs need to connect to each other? Note that these LAN networks are not necessarily compatible.</p>
			<p class="normal">For instance, one of the LANs could be a wired Ethernet network, while the other one could be a <strong class="bold">fiber distributed data interface</strong> (<strong class="bold">FDDI</strong>) network<a id="_idIndexMarker1375"/> mainly using fiber optic as the physical layer. Another example is industrial machines connected to<a id="_idIndexMarker1376"/> an <strong class="bold">Industrial Ethernet</strong> (<strong class="bold">IE</strong>) LAN that need to connect to operators' computers, which are on an ordinary Ethernet LAN. These examples and many more show that we need another layer on top of the aforementioned protocols in order to connect various nodes from different LANs. Note that we even need this third layer in order to connect compatible LANs. This would be even more crucial if we are going to transmit data from one LAN to another (compatible or heterogeneous) through a number of intermediate LANs. We explain this further in the upcoming paragraphs.</p>
			<p class="normal">Just like the frames in the link layer, we have <em class="italics">packets</em> in the <em class="italics">network layer</em>. Long messages are broken into smaller pieces called packets. While frames and packets are referring to two different concepts in two different layers, for simplicity, we consider them the same and we stick to the term <em class="italics">packet</em> for the rest of this chapter.</p>
			<p class="normal"> As a key difference, you should know that frames encapsulate packets, in other words, a frame contains a packet. We won't go any deeper regarding frames and packets, but you can find numerous sources on the internet that describe various aspects of these concepts.</p>
			<p class="normal">The <em class="italics">network protocol</em> fills the gap between various LANs in order to connect them to each other. While each LAN can have its own specific physical layer and its own specific link layer standards and protocols, the governing network protocol should be the same for all of them. Otherwise, heterogeneous (not compatible) LANs cannot connect to each other. The most famous network protocol at the moment is the <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>). It is extensively used in large computer networks that usually consist of smaller Ethernet or Wi-Fi LANs. IP has two versions based on the length of its addresses: IPv4 and IPv6.</p>
			<p class="normal">But how can two computers from two different LANs be connected? The answer lies in the <em class="italics">routing</em> mechanism. In order to receive data from an external LAN, there should be a <em class="italics">router</em> node. Suppose that we are going to connect two different LANs: LAN1 and LAN2. A router is simply another<a id="_idIndexMarker1377"/> node that resides in both networks by having two NICs. One NIC is in LAN1 and the other one is in LAN2. Then, a special routing algorithm decides which packets to transfer and how they should be transferred between networks.</p>
			<p class="normal">With the routing mechanism, multiple networks can have a bidirectional flow of data through the router nodes. For this to happen, within every LAN there should be a router node. Therefore, when you want to send data to a computer located in a different geographical zone, it could be that your data is being transmitted through tens of routers before hitting its target. I'm not going to go any further than this into the routing concept, but there are tons of great information about this mechanism on the web.</p>
			<div><div><p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">There is a utility program called <em class="italics">traceroute</em> that allows you to see the routers between your computer and the target computer.</p>
				</div>
			</div>
			<p class="normal">At this point, two hosts from two different LANs can be connected to each other, with or without having intermediate LANs in between. Any further effort to make more specific connections should be done on top of this layer. Therefore, any communication happening between two programs, residing on two different nodes, must take place on top of a stack of three layers of protocols: the physical layer, the link layer, and finally the network layer. But what does it exactly mean when we say that two computers are connected to each other?</p>
			<p class="normal">It is a bit vague to say that two nodes are connected, at least for programmers. To be more precise, the operating systems of these nodes are connected to each other, and they are the actors who transmit data. The ability to join a network and talk to other nodes in the same LAN or in a different LAN is intrinsically encoded in most current operating systems. Unix-based operating systems, which are our main focus in this book, are all operating systems that support networking, and they can be installed on the nodes participating in a network.</p>
			<p class="normal">Linux, Microsoft Windows, and almost any modern operating system supports networking. Indeed, it is unlikely that an operating system could survive if it could not operate in a network. Note that it is the kernel, or to be precise a unit within the kernel, that manages network connections and, therefore, it is more exact to say that the actual networking functionality is provided by the kernel.</p>
			<p class="normal">Since the networking functionality is provided by the kernel, any process in the user space can benefit from that, and it can get connected to another process residing on a different node within the network. As a programmer, you don't need to worry about the layers (physical, link, and network layers) operated by the kernel, and you can focus on the layers above them, those that relate to your code.</p>
			<p class="normal">Every node in an IP network has an IP address. Like we said before, we have two versions of IP<a id="_idIndexMarker1378"/> addresses: <strong class="bold">IP version 4</strong> (<strong class="bold">IPv4</strong>) and <strong class="bold">IP version 6</strong> (<strong class="bold">IPv6</strong>). An IPv4 address consists of four segments, each of which can hold a numerical value between 0 and 255. Therefore, IPv4<a id="_idIndexMarker1379"/> addresses start from <code class="Code-In-Text--PACKT-">0.0.0.0</code> and go up to <code class="Code-In-Text--PACKT-">255.255.255.255</code>. As you can see, we only need 4 bytes (or 32 bits) in order to store <a id="_idIndexMarker1380"/>an IPv4 address. For IPv6 addresses, this goes up to 16 bytes (or 128 bits). Also, we have private and public IP addresses, but the details are way beyond the subject of this chapter. It's sufficient for us to know that every node in an IP network has a unique IP address.</p>
			<p class="normal">Building on the previous section, in a single LAN, every node has a link layer address together with an IP address, but we will use the IP address to make connections to that node and not the link layer address. As an example, in an Ethernet LAN, every node has two addresses; one is a MAC address and the other one is an IP address. The MAC address is used by the link layer protocols to transmit data within the LAN, and the IP address is used by the programs residing on various nodes to make network connections either within the same LAN or over a number of LANs.</p>
			<p class="normal">The main functionality of the network layer is to connect two or more LANs. This will eventually lead to a big mesh of networks that are connected to each other, and they form a giant network with many individual LAN networks within it. In fact, such a network exists, and we know it as the internet.</p>
			<p class="normal">Like any other network, every node that is accessible on the internet must have an IP address. But the main difference between a node that is accessible on the internet and a node that is not is that an internet node must have a public IP address, while a node that is not accessible through the internet usually has a private address.</p>
			<p class="normal">To give an example, your home network might be connected to the internet, but an external node on the internet cannot get connected to your laptop because your laptop has a private IP address and not a public IP address. While your laptop is still accessible inside your home network, it is not available on the internet. Therefore, if your software is going to be available on the internet, it should be run on a machine that has a public IP address.</p>
			<p class="normal">There is a tremendous amount of information about IP networking, and we are not going to cover all of it, but as a programmer it is important to know the difference between private and public addresses.</p>
			<p class="normal">While in a network, ensuring the connectivity between the nodes is not the programmer's responsibility; it is considered part of your skillset to be able to detect network defects. This is very important because it can let you know whether a bug or misbehavior has roots in your code, or it is an infrastructure (or network) issue. That's why we have to touch on some more concepts and tools here.</p>
			<p class="normal">The basic tool that guarantees <a id="_idIndexMarker1381"/>that two hosts (nodes), either in the same LAN or located on different LANs, are capable of transmitting data, or that they can "see" each other, is the <em class="italics">ping</em> tool. You may already know of it. It sends a<a id="_idIndexMarker1382"/> number of <strong class="bold">Internet Control Message Protocol</strong> (<strong class="bold">ICMP</strong>) packets that, if a reply is sent back, means that the other host is up, connected, and responding.</p>
			<div><div><p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">ICMP is another network layer protocol that is mainly used for monitoring and management of IP-based networks in case of connectivity or quality of service issues and failures.</p>
				</div>
			</div>
			<p class="normal">Suppose you are going to check whether your computer can see the public IP address <code class="Code-In-Text--PACKT-">8.8.8.8</code> (which it should if it is connected to the internet). The following commands will help you to check the connectivity:</p>
			<pre><strong class="highlight">$ ping 8.8.8.8</strong>
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: icmp_seq=0 ttl=123 time=12.190 ms
64 bytes from 8.8.8.8: icmp_seq=1 ttl=123 time=25.254 ms
64 bytes from 8.8.8.8: icmp_seq=2 ttl=123 time=15.478 ms
64 bytes from 8.8.8.8: icmp_seq=3 ttl=123 time=22.287 ms
64 bytes from 8.8.8.8: icmp_seq=4 ttl=123 time=21.029 ms
64 bytes from 8.8.8.8: icmp_seq=5 ttl=123 time=28.806 ms
64 bytes from 8.8.8.8: icmp_seq=6 ttl=123 time=20.324 ms
^C
--- 8.8.8.8 ping statistics ---
7 packets transmitted, 7 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 12.190/20.767/28.806/5.194 ms
<strong class="highlight">$</strong></pre>
			<p class="packt_figref">Shell Box 19-6: Using the ping utility to check the connectivity to the internet</p>
			<p class="normal">As you can see in the output, it says that it has sent 7 ICMP ping packets and none of them have been lost during<a id="_idIndexMarker1383"/> transmission. This means that the operating system behind the IP address <code class="Code-In-Text--PACKT-">8.8.8.8</code> is up and responsive.</p>
			<div><div><p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">The public IP address <code class="Code-In-Text--PACKT-">8.8.8.8</code> refers to the Google Public DNS service. More can be <a id="_idIndexMarker1384"/>read here: https://en.wikipedia.org/wiki/Google_Public_DNS.</p>
				</div>
			</div>
			<p class="normal">In this section, we explained how two computers can get connected via a network. Now, we are getting close to the point where two processes can actually get connected to each other and transmit data over a number of LANs. For this purpose, we need another <a id="_idTextAnchor526"/>layer on top of the network layer. That's where network programming begins.</p>
			<h3 id="_idParaDest-278" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor527"/>Transport layer</h3>
			<p class="normal">So far, we have seen that two <a id="_idIndexMarker1385"/>computers can get connected to each other via a stack of three layers: the physical layer, the link layer, and the network layer. For inter-process communication, we actually need two processes to be connected and talking to each other. But with two computers connected through these three layers, we can have many processes running on each of them, and any process running on the first machine might want to establish a connection with another process located on the second machine. Therefore, having a connection just based on the network layer is too general to support several distinct connections initiated by various processes.</p>
			<p class="normal">That's why we need another layer on top of the network layer. The <em class="italics">transport layer </em>is there to address this need. While hosts are connected through the network layer, the processes running on those hosts can get connected through the transport layer established on top of the network layer. Like any other layer that has its own unique identifiers or unique addresses, this layer has a new concept as its unique identifier, usually known as a <em class="italics">port</em>. We will elaborate more on this in the upcoming sections, but before that, we have to explain the <em class="italics">listener-connector</em> model, which allows two parties to communicate over a channel. In the next section, we start to explain this <a id="_idTextAnchor528"/>model by giving an analogy between computer networks and telephone networks.</p>
			<h4 class="title" lang="en-GB" xml:lang="en-GB">Analogy of telephone networks</h4>
			<p class="normal">The best example to start with<a id="_idIndexMarker1386"/> is the <strong class="bold">Public Switched Telephone Network</strong> (or <strong class="bold">PSTN</strong>). While the similarity between computer networks and telephone <a id="_idIndexMarker1387"/>networks might not seem very promising, there are strong similarities that allow us to explain the transport layer in a sensible fashion.</p>
			<p class="normal">In our analogy, the people using the telephone network are like processes in a computer network. Therefore, a telephone call is equivalent to a <em class="italics">transport connection</em>. The people are able to make calls only if the necessary infrastructure has been installed. This is analogous to the networking infrastructure that should be in place in order to enable processes to communicate.</p>
			<p class="normal">We suppose that the required underlying infrastructure is in place and it works perfectly and, based on that, we want to have two entities residing in these systems to make a channel and transmit data. This is analogous to two people in the PSTN and two processes residing on two different hosts in a computer network.</p>
			<p class="normal">Anyone who wants to use PSTN <a id="_idIndexMarker1388"/>needs to have a telephone device. This is analogous to the requirement of having a NIC for a computer node. On top of these devices, there are multiple layers consisting of various protocols. These layers building up the underlying infrastructure make the creation of a transport channel possible.</p>
			<p class="normal">Now, in PSTN, one of the telephone devices that is connected to the PSTN waits until it receives a call. We call this the <em class="italics">listener</em> side. Note that a telephone device plugged into the PSTN always waits for a call signal from the network and, as soon as it receives the signal, it rings.</p>
			<p class="normal">Now, let's talk about the other side, which makes the call. Note that making a call is equivalent to creating a transport channel. The other side also has a telephone device that is used to make a call. The listener is accessible through a telephone number, which can be thought of as the address of the listener. The <em class="italics">connector</em> side must know this telephone number in order to make the call. Therefore, the connector dials the listener's telephone number and the underlying infrastructure lets the listener know that there is an incoming call.</p>
			<p class="normal">When the listener side answers the telephone, it accepts the incoming connection and a channel is established between the listener and the connector. From now on, it is up to the people sitting at each end to talk and continue the discussion over the created PSTN channel. Note that if one of the parties cannot understand the language of the other party, the communication cannot continue and<a id="_idTextAnchor529"/> one of the parties hangs up the phone, and the channel would be destroyed.</p>
			<h4 class="title" lang="en-GB" xml:lang="en-GB">Connection-less versus connection-oriented transport communication</h4>
			<p class="normal">The preceding analogy tries to explain the transport communication in a computer network but, in fact, it describes <em class="italics">connection-oriented communication</em>. Here, we are going to introduce and describe another type of communication: <em class="italics">connection-less communication</em>. But before that, let's have a deeper look at connection-oriented communication.</p>
			<p class="normal">In connection-oriented<a id="_idIndexMarker1389"/> communication, a specific and dedicated channel is created for a connector. Therefore, if we have one listener communicating with three connectors, we have three dedicated channels. It doesn't matter how big the transmitting message is, the message will reach the other party in the correct form without any loss inside the channel. If multiple messages are sent to the same location, the order of the sent messages is preserved, and the receiving process won't notice any disturbances in the underlying infrastructure.</p>
			<p class="normal">As we've explained in the previous sections, any message is always broken into smaller chunks called packets while being transmitted over a computer network. In a connection-oriented scheme however, none of the parties, neither the listener nor the connector, will notice anything about the underlying <em class="italics">packet switching</em>. Even if the sent packets are received in a different order, the receiver's operating system will rearrange the packets in order to reconstruct the message in its true form, and the receiver process won't notice anything.</p>
			<p class="normal">More than that, if one of the packets gets lost while being transmitted, the receiver's operating system will request it again in order to revive the full message. As an example, <strong class="bold">Transport Control Protocol</strong> (<strong class="bold">TCP</strong>) is a transport <a id="_idIndexMarker1390"/>layer protocol that behaves exactly as we have explained above. Therefore, TCP channels are connection-oriented.</p>
			<p class="normal">Along with connection-oriented channels, we also have connection-less communication. In connection-oriented communication, we guarantee two factors: the <em class="italics">delivery</em> of the individual packets, and the <em class="italics">sequence</em> of the packets. A connection-oriented transport protocol such as TCP preserves these factors at the same time. Conversely, a connection-less transport protocol doesn't guarantee them.</p>
			<p class="normal">In other words, you might have no guarantee for the delivery of the individual packets that the message is broken into, or you might not have a guarantee that all the packets will be in the correct order. Or you might not have both! For <a id="_idIndexMarker1391"/>instance, the <strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>) doesn't guarantee packet delivery or the order of the packets. Note that the guarantee of the correctness of contents of an individual packet is provided by the protocol in the network layer and the link layer.</p>
			<p class="normal">Now it's time to explain two <a id="_idIndexMarker1392"/>terms that are commonly used in network programming. The <em class="italics">stream</em> is the sequence of bytes that is transmitted over a connection-oriented channel. This means that connection-less transmission effectively doesn't offer a stream of data. We have a specific term for a unit of data being transmitted over a connection-less channel. We call it a <em class="italics">datagram</em>. A datagram is a piece of data that can be delivered as a whole in a connection-less channel. Any piece of data bigger than the maximum datagram size cannot be surely delivered or the final sequence might be wrong. Datagram is a concept defined in the transport layer, and it is the counterpart concept to packet in the network layer.</p>
			<p class="normal">For instance, regarding UDP packets, it is guaranteed that every individual UDP datagram (packet) is transmitted correctly, but nothing more can be said about the correlation between two adjacent datagrams (packets). It is accepted that no integrity should exist beyond a UDP datagram, but this is not true of TCP. In TCP, because of the guarantee of delivery and preserving the sequence of the sent packets, we can put individual packet<a id="_idTextAnchor530"/>s aside and look at it as a stream of bytes being transmitted between two processes.</p>
			<h4 class="title" lang="en-GB" xml:lang="en-GB">Transport initialization sequences</h4>
			<p class="normal">In this subsection, we are<a id="_idIndexMarker1393"/> going to talk about the steps that each process takes in order to establish a transport communication. We have different sequences for connection-oriented and connection-less schemes, so we are going to talk about them in two following subsections separately. Note that the difference appears only in the initialization of the channel, and after that, both sides will use more or less the same API in order to read from and write to the created channel.</p>
			<p class="normal">The listener process always <em class="italics">binds</em> an endpoint (usually an IP address together with a port) and the connector process always <em class="italics">connects</em> to that endpoint. This is regardless of being a connection-oriented or a connection-less channel.</p>
			<p class="normal">Note that in the following sequences, we have assumed that there is an IP net<a id="_idTextAnchor531"/>work established between the computers hosting the listener and connector processes.</p>
			<h4 class="title" lang="en-GB" xml:lang="en-GB">Connection-less initialization sequences</h4>
			<p class="normal">In order to establish a <a id="_idIndexMarker1394"/>connection-less communication channel, the listener process will do the following:</p>
			<ol>
				<li class="list">The listener process binds a port on one of existing NICs, or even all of them. This means that the listener process asks its host operating system to redirect the incoming data to that port and, hence, to the listener process. The port is simply a number between 0 and 65535 (2 bytes) and must not be already bound by another listener process. Trying to bind a port that's already in use results in an error. Note that in the case of binding a port on a specific NIC, the operating system will redirect all incoming packets that are targeted at that bound port and received on that specific NIC to the listener process.</li>
			</ol>
			<ol>
				<li class="list" value="2">The process waits and reads the messages that become available on the created channel and responds to them by writing back to the channel.</li>
			</ol>
			<p class="normal">And the connector process will do the following:</p>
			<ol>
				<li class="list" value="3">It must know the IP address and the port number of the listener process. Therefore, it tries to connect to the listener side by providing the IP address and the port number to its host operating system. If the target process is not listening on the specified port, or the IP address points to an invalid or the wrong host, the connection will fail.</li>
			</ol>
			<ol>
				<li class="list" value="4">When the connection is successfully established, the connector process can write to the channel and read from it in almost the same way, meaning the same API that the listener process uses.</li>
			</ol>
			<p class="normal">Note that beside taking the preceding steps, the listener and connector processes should both be using the same transport protocol,<a id="_idTextAnchor532"/> otherwise the messages cannot be read and understood by their host operating systems.</p>
			<h4 class="title" lang="en-GB" xml:lang="en-GB">Connection-oriented initialization sequences</h4>
			<p class="normal">In a connection-oriented scenario, the listener <a id="_idIndexMarker1395"/>process will follow the following sequence in order to get initialized:</p>
			<ol>
				<li class="list" value="1">Bind a port, just like the connection-less scenario explained previously. The port is exactly the same as explained in the previous section and it follows the same constraints.</li>
				<li class="list">The listener process continues by configuring the size of its <em class="italics">backlog</em>. The backlog is a queue of pending connections that are not accepted yet by the listener process. In connection-oriented communication, the listener side should accept incoming connections before being able to transmit any data. After configuring the backlog, the listener process enters <em class="italics">listening mode</em>.</li>
			</ol>
			<ol>
				<li class="list" value="3">Now, the listener process begins to <em class="italics">accept</em> incoming connections. This is an essential step in establishing a transport channel. Only after accepting an incoming connection can they transmit data. Note that if the connector process sends a connection to the listener process, but the listener process cannot accept that connection, it will remain in the backlog until it gets either accepted or <em class="italics">timed out</em>. This can happen when the listener process is too busy with other<a id="_idIndexMarker1396"/> connections and it cannot accept any further new connection. Then, the incoming connections will pile up in the backlog and when the backlog becomes full, new connections will be rejected immediately by the host operating system.</li>
			</ol>
			<p class="normal">The sequence of the connector process is very similar to what we explained for the connection-less communication in the previous section. The connector connects to a certain endpoint by providing the IP address and the port, and after being accepted by the listener process, it can use the same API to read from and write to the connection-oriented channel.</p>
			<p class="normal">Since the established channel is connection-oriented, the listener process has a dedicated channel to the connector side; therefore, they can exchange a stream of bytes that doesn't have an upper limit in terms of the number of bytes. Therefore, the two processes can transmit a huge amount of data, and its correctness is guaranteed by the governing transport and network protocols.</p>
			<p class="normal">As the last note about the transport layer, we mentioned that the listener processes (regardless of the underlying channel being connection-oriented and connection-less) are required to bind an endpoint. Regardin<a id="_idTextAnchor533"/><a id="_idTextAnchor534"/>g UDP and TCP specifically, this endpoint is made up of an IP address and a port number.</p>
			<h3 id="_idParaDest-279" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor535"/>Application layer</h3>
			<p class="normal">When a transport<a id="_idIndexMarker1397"/> channel is established between two processes residing on two different ends, they should be able to talk to each other. By talking, we mean transmitting a series of bytes that can be understood by both ends. As we explained in the earlier sections in this chapter, a communication protocol is required here. Since this protocol resides in the <em class="italics">application layer</em> and it is used by the processes (or the applications running as processes), it is called an <em class="italics">application protocol</em>.</p>
			<p class="normal">While there aren't many protocols used in link, network, and transport layers and they are mostly well-known, we have numerous application protocols that are used in the application layer. This is again analogous to telecommunication networks. While there aren't many standards for telephone networks, the number of languages that people use to communicate is large, and they differ greatly. In computer networks, every application run as a process needs to use an application protocol in order to communicate with another process.</p>
			<p class="normal">Therefore, the programmers either use a well-known application protocol such as HTTP or FTP or they have to use a custom application protocol that is designed and built locally within a team.</p>
			<p class="normal">So far, we have discussed five layers; physical, link, network, transport, and application. Now it's time to put all of them into a single body and use it as a reference to design and <a id="_idTextAnchor536"/>deploy computer networks. In the following section, we talk about the internet protocol suite.</p>
			<h3 id="_idParaDest-280" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor537"/>Internet protocol suite</h3>
			<p class="normal">The network model that we see every<a id="_idIndexMarker1398"/> day and that is widely applied is the <strong class="bold">Internet Protocol Suite</strong> (<strong class="bold">IPS</strong>). IPS is mainly used on the internet, and since pretty much all computers want to have access to the internet, they have universally adapted to use IPS, which is not officially the standard approved by ISO. The standard model for computer networks<a id="_idIndexMarker1399"/> is <strong class="bold">Open System Interconnections</strong> (<strong class="bold">OSI</strong>) model, which is more a theoretical model and is almost never publicly deployed and used. IPS has the following layers. Note that the prominent protocols in each layer are mentioned in the following list:</p>
			<ul>
				<li class="list">Physical layer</li>
				<li class="list">Link layer: Ethernet, IEEE 802.11 Wi-Fi</li>
				<li class="list">Internet layer: IPv4, IPv6, and ICMP</li>
				<li class="list">Transport layer: TCP, UDP</li>
				<li class="list">Application layer: Numerous protocols such as HTTP, FTP, DNS, and DHCP, and so on.</li>
			</ul>
			<p class="normal">As you can see, the layers have a nice correspondence to the layers that we discussed in this chapter, but with only one exception; the network layer is renamed the internet layer. This is because as part of IPS, the network protocols that are prominent in this layer are only IPv4 and IPv6. The rest of the explanations can be applied to IPS layers. IPS is the main model that we will be dealing with throughout this book and in the actual work environment.</p>
			<p class="normal">Now that we know how computer networks work, we are in a good position to proceed and see what <em class="italics">socket programming</em> is. As part of the rest of this chapter and the upcoming chapter, you will see that there is a deep correspondence betwe<a id="_idTextAnchor538"/>en the concepts discussed in the transport layer and the concepts we have in socket programming.</p>
			<h2 id="_idParaDest-281" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor539"/>What is socket programming?</h2>
			<p class="normal">Now<a id="_idIndexMarker1400"/> that we know about the IPS model and the various network layers, it is much easier to explain what socket programming is. Before delving into the technical discussions regarding the socket programming, we should define it as an IPC technique that allows us to connect two processes residing on either the same node or two different nodes having a network connectivity between them. If we put the single-host socket programming aside, the other form requires us to have an operational network between the two nodes. This very fact ties socket programming with computer networks and all we have explained so far.</p>
			<p class="normal">To make it more technical, we should say that socket programming mainly happens in the transport layer. As we have already said, the transport layer is responsible for connecting two processes over an existing internet layer (network layer). Therefore, the transport layer is the key layer for establishing a socket programming context. Basically, that's why you as a programmer should know more about the transport layer and its various protocols. Some socket programming-related bugs have their origins in the underlying transport channel.</p>
			<p class="normal">In socket programming, sockets are the main tools for establishing a transport channel. Note that despite what we have discussed so far, socket programming can go beyond transport layer or <em class="italics">process-to-process communications</em> and it can include internet layer (network layer) or <em class="italics">host-to-host communications</em> as well. This means that we can have internet-layer-specific sockets as well as transport layer sockets. With this in mind, most of the sockets that we see and work with are transport sockets and for the <a id="_idTextAnchor540"/>rest of this chapter and the next chapter, we will mainly be talking about transport sockets.</p>
			<h3 id="_idParaDest-282" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor541"/>What is a socket?</h3>
			<p class="normal">As we have<a id="_idIndexMarker1401"/> explained in the previous section, the transport layer is where the actual socket programming is taking place. Everything above it just makes the socket programming more specific; however, the actual underlying channel has been established in the transport layer.</p>
			<p class="normal">We also discussed that the internet connection (network connection) on which the transport channel has been established is actually the connection between the operating systems, or more specifically the kernels of those operating systems. Therefore, there should be a concept in the kernel that resembles a connection. More than that, there could be many established connections initiated or accepted by the same kernel simply because there can be several processes running and hosted in that operating system and willing to have network connections.</p>
			<p class="normal">The concept that we are <a id="_idIndexMarker1402"/>looking for is the <em class="italics">socket</em>. For any established or soon-to-be-established connection in a system, there is a dedicated socket that identifies that connection. For a single connection made between two processes, there is exactly one socket on each side that addresses the same connection. As we explained before, one of these sockets belongs to the connector side and the other one belongs to the listener side. The API that allows us to define and manage a socket object is described by the <em class="italics">socket library</em> exposed by the operating system.</p>
			<p class="normal">Since we are mainly talking about POSIX systems, we expect to have such a socket library as part of the POSIX API and, in fact, we do have such a library. In the rest of this chapter, we discuss the <em class="italics">POSIX socket library</em> and we explain how it can be used to establish a connection between two processes.</p>
			<h3 id="_idParaDest-283" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor542"/>POSIX socket library</h3>
			<p class="normal">Every socket object<a id="_idIndexMarker1403"/> has three attributes: <em class="italics">domain</em>, <em class="italics">type</em>, and <em class="italics">protocol</em>. While the manual pages of an operating system explain these attributes very well, we want to talk about some of the values that are commonly used for these attributes. We start with the domain attribute, which is also known as <strong class="bold">address family</strong> (<strong class="bold">AF</strong>) or <strong class="bold">protocol family</strong> (<strong class="bold">PF</strong>). Some of the values that are widely used can be seen in the following list. Note that these address families support both connection-oriented and connection-less transport connections.</p>
			<ul>
				<li class="list"><code class="Code-In-Text--PACKT-">AF_LOCAL</code> or <code class="Code-In-Text--PACKT-">AF_UNIX</code>: These are local sockets, which work only when both connector and listener<a id="_idIndexMarker1404"/> processes are<a id="_idIndexMarker1405"/> located on the same host.</li>
				<li class="list"><code class="Code-In-Text--PACKT-">AF_INET</code>: These<a id="_idIndexMarker1406"/> sockets allow two processes to connect to each other over an IPv4 connection.</li>
				<li class="list"><code class="Code-In-Text--PACKT-">AF_INET6</code>: These<a id="_idIndexMarker1407"/> sockets allow two processes to connect to each other over an IPv6 connection.</li>
			</ul>
			<div><div><p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">In some POSIX systems, in the constants used for the domain attribute, you might find the prefix <code class="Code-In-Text--PACKT-">PF_</code> instead of <code class="Code-In-Text--PACKT-">AF_</code>. It is often the case that <code class="Code-In-Text--PACKT-">AF_</code> constants have the same values as <code class="Code-In-Text--PACKT-">PF_</code> constants, so they can be used interchangeably.</p>
				</div>
			</div>
			<p class="normal">In the next chapter, we will demonstrate the usage of the <code class="Code-In-Text--PACKT-">AF_UNIX</code> and <code class="Code-In-Text--PACKT-">AF_INET</code> domains, but it should be easy to find examples that use the <code class="Code-In-Text--PACKT-">AF_INET6</code> domain. Also, there could be address families that are specific to a certain operating system and cannot be found on other systems.</p>
			<p class="normal">The most well-known<a id="_idIndexMarker1408"/> values for the type attribute of a socket object are as follows:</p>
			<ul>
				<li class="list"><code class="Code-In-Text--PACKT-">SOCK_STREAM</code>: This means that<a id="_idIndexMarker1409"/> the socket will represent a connection-oriented transport communication that guarantees delivery, correctness, and the order of the sent content. As we've explained streams in the previous sections, the term <code class="Code-In-Text--PACKT-">STREAM</code> also suggests this. Note that, at this point, you cannot predict that the actual underlying transport protocol is TCP because this is not true regarding local sockets that belong to the <code class="Code-In-Text--PACKT-">AF_UNIX</code> address family.</li>
				<li class="list"><code class="Code-In-Text--PACKT-">SOCK_DGRAM</code>: This means that the socket will represent a connection-less transport communication. Note that <a id="_idIndexMarker1410"/>the term datagram, abbreviated as <code class="Code-In-Text--PACKT-">DGRAM</code>, like we explained in the previous sections, refers to a series of bytes that cannot be seen as a stream. Instead, they can be seen as some individual chunks of data that are called datagrams. In a more technical context, a datagram represents a packet of data transmitted over a network.</li>
				<li class="list"><code class="Code-In-Text--PACKT-">SOCK_RAW</code>: A raw socket can <a id="_idIndexMarker1411"/>represent both connection-oriented and connection-less channels. The main difference between <code class="Code-In-Text--PACKT-">SOCK_RAW</code> and <code class="Code-In-Text--PACKT-">SOCK_DGRAM</code> or <code class="Code-In-Text--PACKT-">SOCK_STREAM</code> is that the kernel actually knows about the underlying used transport protocol (UDP or TCP) and it can parse a packet and extract the header and the content. But with a raw socket, it doesn't do so, and it is up to the program that has opened the socket to read and extract various sections.<p class="Bullet-Without-Bullet-Within-Bullet-End--PACKT-">In other words, when using <code class="Code-In-Text--PACKT-">SOCK_RAW</code>, the packets are delivered directly to the program and it should extract and understand the packet structure itself. Note that if the underlying channel is a stream channel (connection-oriented), the recovery of lost packets and packet reordering are not done by the kernel, and the program should do them itself. This implies that recovery and packet reordering are actually done by the kernel when you select TCP as your transport protocol.</p></li>
			</ul>
			<p class="normal">The third attribute, protocol, identifies the protocol that should be used for the socket object. Since most address families, together with the type, determine a certain protocol, this attribute can be chosen by the operating system upon the socket creation. In circumstances when we have multiple possible protocols, this attribute should be defined.</p>
			<p class="normal">Socket programming offers solutions for both single-host and multiple-host IPC. In other words, while it is quite possible to connect two processes located on two different hosts and in two different LANs using internet (network) sockets, it is totally possible to connect two processes residing on the same host using Unix domain sockets.</p>
			<p class="normal">As the last note in this section, we should add that socket connections are bidirectional and full-duplex. This means that both parties can read from and write to the underlying channel without interfering with the other end. This is a desired feature because it is usually a requirement in most IPC-related scenarios.</p>
			<p class="normal">Now that you have been introduced to the concept of sockets, we have to revisit the sequences that we explained in the previous sections regarding listener and connector processes. <a id="_idTextAnchor543"/>But this time, we dive into more detail and describe how sockets can be used to perform these sequences.</p>
			<h4 class="title" lang="en-GB" xml:lang="en-GB">Revisiting listener-connector sequences</h4>
			<p class="normal">As we mentioned before, as <a id="_idIndexMarker1412"/>part of computer networks, in almost every connection one of the ends is always listening for incoming connections, and the other end tries to connect to the listener side. We also discussed an example regarding a telephone network, explaining how a telephone is used to listen to an incoming call, and how it can be used to make calls and connect to other listening devices. A similar situation exists in socket programming. Here, we want to explore the sequences that should be followed by the processes at two different ends in order to establish a successful transport connection.</p>
			<p class="normal">In the following subsections, we will go deeper into the details of socket creation and the various operations that should be performed by both processes that want to engage in a connection. The sequences explained in the following subsections for the listener and connector processes are infrastructure agnostic and benefit from the generalization that socket programming provides over the various underlying transport connections.</p>
			<p class="normal">As you should remember, we discussed the listener and connector sequences regarding connection-oriented and connection-less communications separately. We t<a id="_idTextAnchor544"/>ake the same approach here, and we firstly start with the stream (connection-oriented) listener sequence.</p>
			<h5 class="title" lang="en-GB" xml:lang="en-GB">Stream listener sequence</h5>
			<p class="normal">The following steps <a id="_idIndexMarker1413"/>should be followed by a<a id="_idIndexMarker1414"/> process that wants to listen for new stream connections. You have been introduced to the binding, listening, and accepting phases in the previous sections, but here we will talk about them from a socket programming perspective. Note that most of the actual functionality is provided by the kernel and the process only needs to call the right functions from the socket library in order to put itself into listening mode:</p>
			<ol>
				<li class="list" value="1">The process should create a socket object using the <code class="Code-In-Text--PACKT-">socket</code> function. This socket object is usually called a <em class="italics">listener socket</em>. The socket object represents the whole listener process, and it will be used to accept new connections. Depending on the underlying channel, the arguments sent to the <code class="Code-In-Text--PACKT-">socket</code> function can vary. We<a id="_idIndexMarker1415"/> could pass <a id="_idIndexMarker1416"/>either <code class="Code-In-Text--PACKT-">AF_UNIX</code> or <code class="Code-In-Text--PACKT-">AF_INET</code> as the address family of the socket, but we have to use <code class="Code-In-Text--PACKT-">SOCK_STREAM</code> as the type of the socket because we are going to have a stream channel. The protocol attribute of the socket object can be determined by the operating system. For example, if you choose <code class="Code-In-Text--PACKT-">AF_INET</code> and <code class="Code-In-Text--PACKT-">SOCK_STREAM</code> for a socket object, TCP will be selected by default for the protocol attribute.</li>
				<li class="list">Now, the socket must be bound to an <em class="italics">endpoint</em> that is reachable by the connector processes using the <code class="Code-In-Text--PACKT-">bind</code> function. The details of the chosen endpoint heavily depend on the chosen address family. For example, for an internet channel, the endpoint should be a combination of an IP address and a port. For a Unix domain socket, the endpoint should be the path to a <em class="italics">socket file </em>located on the filesystem.</li>
				<li class="list">The socket must be configured for listening. Here, we use the <code class="Code-In-Text--PACKT-">listen</code> function. As we have explained before, it simply creates a backlog for the listener socket. The backlog is a list of awaiting connections that have not yet been accepted by the listener process. While the listener process cannot accept new incoming connections, the kernel will keep the incoming connections in the corresponding backlog until the listener process becomes free and starts to accept them. Once the backlog is full, any further incoming connections will be rejected by the kernel. Choosing a low size for the backlog can lead to many connections being rejected when the listener process is congested and choosing a large size can lead to a pile of awaiting connections that will eventually get timed out and disconnected. The backlog size should be chosen according to the dynamics of the listener program.</li>
			</ol>
			<ol>
				<li class="list" value="4">After configuring the backlog, it is time to accept the incoming connections. For every incoming connection, the <code class="Code-In-Text--PACKT-">accept</code> function should be called. Therefore, it is a widely used pattern to have the <code class="Code-In-Text--PACKT-">accept</code> called in a never-ending loop. Whenever the listener process stops accepting new connections, the connector processes are put into the backlog and once the backlog is full, they get rejected. Note that every call to the <code class="Code-In-Text--PACKT-">accept</code> function simply picks up the next connection waiting in the socket's backlog. If the backlog is empty and if the listener socket is configured to be blocking, then any call to the <code class="Code-In-Text--PACKT-">accept</code> function will be blocked until a new connection comes in.</li>
			</ol>
			<p class="normal">Note that the <code class="Code-In-Text--PACKT-">accept</code> function returns a new socket object. This means that the kernel dedicates a new unique <a id="_idIndexMarker1417"/>socket object to every <a id="_idIndexMarker1418"/>accepted connection. In other words, a listener process that has accepted 100 clients is using at least 101 sockets: 1 for the listener socket and 100 sockets for its incoming connections. The returned socket from the <code class="Code-In-Text--PACKT-">accept</code> function should be used for further communication with the client sitting at the other end of the channel.</p>
			<p class="normal">Note that this sequence of function calls remains the same for all types of the stream (connection-oriented) socket-based IPC. In the next chapter, we show real examples of ho<a id="_idTextAnchor545"/>w these steps should be programmed using C. In the next subsection, we deal with the stream connector sequence.</p>
			<h5 class="title" lang="en-GB" xml:lang="en-GB">Stream connector sequence</h5>
			<p class="normal">When the<a id="_idIndexMarker1419"/> connector process wants to connect to a listener <a id="_idIndexMarker1420"/>process that is already in listening mode, it should follow the following sequence. Note that the listener process should be in listening mode, otherwise the connection will get refused by the kernel of the target host:</p>
			<ol>
				<li class="list" value="1">The connector process should create a socket by calling the <code class="Code-In-Text--PACKT-">socket</code> function. This socket will be used to connect to the target process. The characteristics of this socket should be similar or at least compatible with those we set for the listener socket, otherwise, we cannot establish a connection. Therefore, we need to set the same address family that we set for the listener socket. And the type should remain <code class="Code-In-Text--PACKT-">SOCK_STREAM</code>.</li>
			</ol>
			<ol>
				<li class="list" value="2">Then it should use the <code class="Code-In-Text--PACKT-">connect</code> function by passing the arguments that uniquely identify the listener endpoint. The listener endpoint should be reachable by the connector process and it should have been made available by the target process. If the <code class="Code-In-Text--PACKT-">connect</code> function succeeds, it means that the connection has been accepted by the target process. Before this point, the connection might be waiting in the backlog of the target process. If the specified target endpoint is not available for any reason, the connection will fail, and the connector process will receive an error.</li>
			</ol>
			<p class="normal">Just like <code class="Code-In-Text--PACKT-">accept</code> function call in the listener process, the <code class="Code-In-Text--PACKT-">connect</code> function returns a socket object. This socket identifies the connection and should be used for further communication with the listener pro<a id="_idTextAnchor546"/>cess. In the upcoming chapter, we will give a demonstration of the preceding sequences in the calculator example.</p>
			<h5 class="title" lang="en-GB" xml:lang="en-GB">Datagram listener sequence</h5>
			<p class="normal">A datagram <a id="_idIndexMarker1421"/>listener process will do the following in order<a id="_idIndexMarker1422"/> to get initialized:</p>
			<ol>
				<li class="list" value="1">Like the stream listener, the datagram listener process creates a socket object by calling the <code class="Code-In-Text--PACKT-">socket</code> function. But this time, it must set the socket's type attribute as <code class="Code-In-Text--PACKT-">SOCK_DGRAM</code>.</li>
			</ol>
			<ol>
				<li class="list" value="2">Now that the listener socket has been created, the listener process should bind it to an endpoint. The endpoint and its constraints are very similar to the stream listener end. Note that there won't be a listening mode or an accepting phase for a datagram listener socket because the underlying channel is connection-less, and we can't have a dedicated session for each incoming connection.</li>
			</ol>
			<p class="normal">As explained, there is no listening mode or accepting phase with a datagram server socket. Also, the datagram listeners should use the <code class="Code-In-Text--PACKT-">recvfrom</code> and <code class="Code-In-Text--PACKT-">sendto</code> functions in order to read from and write back to a connector process. Reads can still be done using the <code class="Code-In-Text--PACKT-">read</code> function, but writing the responses cannot be done just using a simple <code class="Code-In-Text--PACKT-">wr<a id="_idTextAnchor547"/>ite</code> function call. You will see why when we look at the datagram listener example as part of the upcoming chapter.</p>
			<h5 class="title" lang="en-GB" xml:lang="en-GB">Datagram connector sequence</h5>
			<p class="normal">A datagram<a id="_idIndexMarker1423"/> connector has almost the same sequence as a<a id="_idIndexMarker1424"/> stream connector. The only difference is the socket type, which must be <code class="Code-In-Text--PACKT-">SOCK_DGRAM</code> for the datagram connector. One special case for datagram Unix domain connector sockets is that they have to bind to a Unix domain socket file in order to receive the responses from the server. We will elaborate on this in the upcoming chapter as part of the datagram calculator example when using Unix domain sockets.</p>
			<p class="normal">Now that we have gone through all the possible sequences, it's time to explain how sockets and <em class="italics">socket descriptors</em> are related. This is last section in <a id="_idTextAnchor548"/>this chapter, and by starting the next chapter, we will be giving real C examples that cover all the sequences.</p>
			<h3 id="_idParaDest-284" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor549"/>Sockets have their own descriptors!</h3>
			<p class="normal">Unlike other push-based IPC<a id="_idIndexMarker1425"/> techniques that work with file descriptors, socket-based techniques deal with socket objects. Every socket object is referred to by an integer value, which is a socket descriptor inside the kernel. This socket descriptor can be used to refer to the underlying channel.</p>
			<p class="normal">Note that file descriptors and socket descriptors are different. File descriptors refer to a regular file or a device file while socket descriptors refer to socket objects created by <code class="Code-In-Text--PACKT-">socket</code>, <code class="Code-In-Text--PACKT-">accept</code>, and <code class="Code-In-Text--PACKT-">connect</code> function calls.</p>
			<p class="normal">While the file descriptors and socket descriptors are different, we still can use the same API or set of functions to read from and write to them. Therefore, it is possible to use <code class="Code-In-Text--PACKT-">read</code> and <code class="Code-In-Text--PACKT-">write</code> functions to work with sockets just like files.</p>
			<p class="normal">These descriptors have another similarity; both of them can be configured to be non-blocking vi<a id="_idTextAnchor550"/>a the same API. Non-blocking descriptors can be used to work with the behind file or socket in a non-blocking fashion.</p>
			<h2 id="_idParaDest-285" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor551"/>Summary</h2>
			<p class="normal">In this chapter, we started to talk about IPC techniques that allow two processes to communicate and transmit data. Our discussion in this chapter will be complete in the upcoming chapter where we talk specifically about socket programming, and we will give various real C examples.</p>
			<p class="normal">As part of this chapter, we covered the following topics:</p>
			<ul>
				<li class="list">Pull-based and push-based IPC techniques and how they are different and similar.</li>
				<li class="list">We compared single-host IPC techniques versus multiple-host IPC techniques.</li>
				<li class="list">You learned about communication protocols and their various characteristics.</li>
				<li class="list">We went over the serialization and deserialization concepts and how they operate to fulfill a certain communication protocol.</li>
				<li class="list">We explained how the content, length, and the sequentiality features of protocols can affect receiver processes.</li>
				<li class="list">We explained POSIX pipes and demonstrated how to use them with an example.</li>
				<li class="list">You saw what a POSIX message queue is and how it can be used to enable two processes to communicate.</li>
				<li class="list">We briefly explained Unix domain sockets and their basic properties.</li>
				<li class="list">We explained what computer networks are and how the stack of various network layers can lead to a transport connection.</li>
				<li class="list">We explained what socket programming is.</li>
				<li class="list">We explained the initialization sequences of listener and connector processes and the steps they take to become initialized.</li>
				<li class="list">We compared file descriptors and socket descriptors.</li>
			</ul>
			<p class="normal">In the next chapter, we continue our discussion about socket programming with a focus on providing real C examples. We will define an example of a calculator client and a calculator server. After that, we will use both Unix domain sockets and internet sockets to establish a fully functional client-server communication between the calculator client and its server.</p>
		</div>
</body></html>