- en: Chapter 4. Improve Programming with Functions, Math, and Timing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用函数、数学和计时提高编程能力
- en: As a digital artist, I need special conditions to be able to work. We all need
    our own environment and ambience to be productive. Even if each one of us has
    his/her own way, there are many things in common.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一位数字艺术家，我需要特殊的条件才能工作。我们都需要自己的环境和氛围来提高生产力。即使我们每个人都有自己的方式，也有很多共同之处。
- en: In this chapter, I want to give you elements that will make you more comfortable
    to write source code that is easily readable, reusable and, as much as possible,
    beautiful. Like Yin and Yang, for me there has always been a Zen-like quality
    to the artistic and coding sides of me. Here is where I can deliver some programming
    pearls of wisdom to bring peace of mind to your creative side.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我想给你一些元素，这将使你更容易编写易于阅读、重用，尽可能美观的源代码。就像阴阳一样，对我来说，我的艺术和编程方面始终有一种禅意。这里我可以提供一些编程智慧之珠，以给你的创造性带来平静。
- en: 'We are going to learn something we have already used a bit before: functions.
    They contribute to improve both readability and efficiency at the same time. As
    we do that, we''ll touch on some mathematics and trigonometry often used in many
    projects. We''ll also talk about some approaches to calculation optimization,
    and we''ll finish this chapter with timing-related events or actions within the
    Arduino''s firmware.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要学习一些我们之前已经稍微使用过的一些内容：函数。它们同时有助于提高可读性和效率。在这个过程中，我们将涉及到许多项目中常用的数学和三角学。我们还将讨论一些计算优化的方法，并以Arduino固件中的与计时相关的事件或动作结束这一章。
- en: It is going to be a very interesting chapter before the real dive into pure
    Arduino's projects!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在真正深入Arduino纯项目之前，这将是一个非常有趣的章节！
- en: Introducing functions
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍函数
- en: A function is a piece of code defined by a name and that can be reused/executed
    from many different points in a C program. The name of a function has to be *unique*
    in a C program. It is also `global`, which means, as you already read for variables,
    it can be used everywhere in the C program containing the function declaration/definition
    in its scope (see the The scope concept section in [Chapter 3](ch03.html "Chapter 3. C
    Basics – Making You Stronger"), *C Basics – Making You Stronger*).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一段通过名称定义的代码，可以在C程序中的许多不同点重用/执行。函数的名称在C程序中必须是**唯一的**。它也是`全局`的，这意味着，正如你之前已经读到的关于变量的内容，它可以在包含函数声明/定义的作用域内的C程序中的任何地方使用（参见[第3章](ch03.html
    "第3章。C基础 - 使你更强壮")中的作用域概念部分，*C基础 - 使你更强壮*）。
- en: A function can require special elements to be passed to it; these are called
    **arguments**. A function can also produce and return **results**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可能需要传递给它一些特殊元素；这些被称为**参数**。函数也可以产生并返回**结果**。
- en: Structure of a function
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的结构
- en: A function is a block of code that has a header and a body. In standard C, a
    function's declaration and definition are made separately. The declaration of
    the function is specifically called the declaration of the prototype of the function
    and has to be done in the **header file** (see [Chapter 2](ch02.html "Chapter 2. First
    Contact with C"), *First Contact with C*).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一块代码，它有一个标题和一个主体。在标准C中，函数的声明和定义是分开进行的。函数的声明特别被称为函数原型的声明，并且必须在**头文件**中完成（参见[第2章](ch02.html
    "第2章。C语言初探")，*C语言初探*）。
- en: Creating function prototypes using the Arduino IDE
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Arduino IDE创建函数原型
- en: The Arduino IDE makes our life easier; it creates function prototypes for us.
    But in special cases, if you need to declare a function prototype, you can do
    that in the same code file at the beginning of the code. This provides a nice
    way of source code centralization.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino IDE使我们的生活变得更简单；它为我们创建函数原型。但在特殊情况下，如果你需要声明函数原型，你可以在代码文件的开头进行声明。这提供了一种很好的源代码集中化的方式。
- en: 'Let''s take an easy example, we want to create a function that sums two integers
    and produces/returns the result. There are two arguments that are integer type
    variables. In this case, the result of the addition of these two `int` (integer)
    values is also an `int` value. It doesn''t have to be, but for this example it
    is. The prototype in that case would be:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来说明，我们想要创建一个函数，该函数将两个整数相加并产生/返回结果。有两个参数是整数类型的变量。在这种情况下，这两个`int`（整数）值的加法结果是另一个`int`值。这不必是，但在这个例子中是这样的。在这种情况下，原型将是：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Header and name of functions
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数的标题和名称
- en: 'Knowing what prototype looks like is interesting because it is similar to what
    we call the header. The header of a function is its first statement definition.
    Let''s move further by writing the global structure of our function `mySum`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 了解原型看起来像什么很有趣，因为它与我们所说的头相似。函数的头是其第一个语句定义。让我们通过编写我们的函数 `mySum` 的全局结构来进一步了解：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The header has the global form:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 函数头具有以下全局形式：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`returnType` is a variable type. By now, I guess you understand the `void`
    type better. In the case where our function doesn''t return anything, we have
    to specify it by choosing `returnType` equals to `void`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`returnType` 是一个变量类型。到现在为止，我猜你更好地理解了 `void` 类型。在我们的函数不返回任何内容的情况下，我们必须通过选择 `returnType`
    等于 `void` 来指定它。'
- en: '`functionName` has to be chosen to be easy to remember and should be as self-descriptive
    as possible. Imagine supporting code written by someone else. Finding `myNiceAndCoolMathFunction`
    requires research. On the other hand, `mySum` is self-explanatory. Which code
    example would you rather support?'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`functionName` 必须选择易于记忆，并且应尽可能具有自描述性。想象一下支持其他人编写的代码。寻找 `myNiceAndCoolMathFunction`
    需要研究。另一方面，`mySum` 是自解释的。你更愿意支持哪个代码示例？'
- en: The Arduino core (and even C) follows a naming convention called camel case.
    The difference between two words, because we *cannot* use the blank/space character
    in a function name, is made by putting the first letter of words as uppercase
    characters. It isn't necessary, but it is recommended especially if you want to
    save time later. It's easier to read and makes the function self-explanatory.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 核心库（甚至 C 语言）遵循一个称为驼峰式命名的命名约定。两个单词之间的区别，因为我们*不能*在函数名中使用空白/空格字符，是通过将单词的首字母大写来实现的。这不是必需的，但如果你想在以后节省时间，则推荐这样做。它更容易阅读，并且使函数具有自解释性。
- en: '`mysum` is less readable than `mySum`, isn''t it? Arguments are a series of
    variable declarations. In our `mySum` example, we created two function arguments.
    But we could also have a function without arguments. Imagine a function that you
    need to call to produce an action that would always be the same, not depending
    on variables. You''d make it like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysum` 的可读性不如 `mySum`，对吧？参数是一系列变量声明。在我们的 `mySum` 示例中，我们创建了两个函数参数。但我们也可以有一个没有参数的函数。想象一下，你需要调用一个函数来执行一个始终相同的动作，不依赖于变量。你会这样写：'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Variables declared within a function are known only to the function containing
    them. This is what's known as "scope". Such variables declared within a function
    cannot be accessed anywhere else, but they can be "passed". Variables which can
    be passed are known as **arguments**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部声明的变量只对其包含它们的函数是已知的。这就是所谓的“作用域”。在函数内部声明的此类变量在其他任何地方都无法访问，但它们可以被“传递”。可以传递的变量被称为**参数**。
- en: Body and statements of functions
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数的体和语句
- en: As you probably intuitively understood, the body is the place where everything
    happens; it's where all of a function's instruction steps are constructed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能直觉理解的那样，函数体是所有事情发生的地方；它是所有函数指令步骤构建的地方。
- en: 'Imagine the body as a real, pure, and new block of source code. You can declare
    and define variables, add conditions, and play with loops. Imagine the body (of
    instructions) as where the sculptor''s clay is shaped and molded and comes out
    in the end with the desired effect; perhaps in one piece or many, perhaps in identical
    copies, and so on. It''s the manipulation of what there is, but remember: Garbage
    in, garbage out!'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数体想象成一个真实、纯净且全新的代码块。你可以声明和定义变量，添加条件，并玩转循环。将函数体（指令）想象成雕塑家的粘土被塑形和塑造，最终以期望的效果呈现出来；可能是一块或几块，可能是相同的副本，等等。这是对现有事物的操作，但请记住：垃圾输入，垃圾输出！
- en: 'You can also, as we just introduced, return a variable''s value. Let''s create
    the body of our `mySum` example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以，就像我们刚才介绍的，返回一个变量的值。让我们创建我们的 `mySum` 示例的函数体：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`int result;` declares the variable, and names it `result`. Its scope is the
    same as the scope of arguments. `result = m + n;` contains two operators, and
    you already know that `+` has a higher precedence than `=` which is pretty good,
    as the mathematical operation is made first and then the result is stored in the
    `result` variable. This is where the magic happens; take two operators, and make
    one out of them. Remember that, in a combination of multiple mathematical operations,
    do not forget the order of precedence; it''s critical so that we don''t get unexpected
    results.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`int result;` 声明了一个变量，并将其命名为 `result`。它的作用域与参数的作用域相同。`result = m + n;` 包含两个运算符，你已经知道
    `+` 的优先级高于 `=`，这很好，因为数学运算首先进行，然后将结果存储在 `result` 变量中。这就是魔法发生的地方；取两个运算符，将它们中的一个变成函数。记住，在多个数学运算的组合中，不要忘记优先级顺序；这是至关重要的，以免得到意外的结果。'
- en: 'At last, `return result;` is the statement that makes the function call resulting
    into a value. Let''s check an actual example of the Arduino code to understand
    this better:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`return result;` 是使函数调用返回值的语句。让我们通过一个实际的Arduino代码示例来更好地理解这一点：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you have just seen, the `mySum` function has been defined and called in the
    example. The most important statement is `currentResult = mySum(i,i+1);`. Of course,
    the `i` and `i+1` trick is interesting, but the most important thing to recognize
    here is the usage of the variable `currentResult` that was declared at the beginning
    of the`loop()` function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`mySum` 函数在示例中已经被定义并调用。最重要的语句是 `currentResult = mySum(i,i+1);`。当然，`i`
    和 `i+1` 的技巧很有趣，但在这里要认识到的是在 `loop()` 函数开始处声明的变量 `currentResult` 的使用。
- en: 'In programming, it''s important to recognize that everything at the right (contents)
    goes into the left (the new container). According to the precedence rules, a function
    call has a precedence of 2 against 16 for the `=` assignment operator. It means
    the call is made first and the function returns the result of the `+` operation,
    as we designed it. From this point of view, you just learned something very important:
    *The call statement of a function returning a result is a value*.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，重要的是要认识到右边的所有内容（内容）都进入左边（新容器）。根据优先级规则，函数调用相对于 `=` 赋值运算符的优先级为2对16。这意味着调用首先进行，函数返回
    `+` 操作的结果，正如我们设计的那样。从这个角度来看，你刚刚学到了一些非常重要的东西：*函数返回值的调用语句是一个值*。
- en: You can check *Appendix B, Operator Precedence in C and C++* for the entire
    precedencies list. As with all values within a variable, we can store it into
    another, here inside the integer variable `result`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看 *附录B，C和C++中的运算符优先级* 以获取完整的优先级列表。与变量内的所有值一样，我们可以将其存储到另一个变量中，这里是在整数变量 `result`
    中。
- en: Benefits of using functions
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数的好处
- en: Programming is about writing pieces of code for general and specific purposes.
    Using functions is one of the best ways of segmenting your code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 编程是关于为一般和特定目的编写代码片段。使用函数是分割你的代码的最佳方式之一。
- en: Easier coding and debugging
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更容易的编码和调试
- en: Functions can really help us to be better organized. While designing the program,
    we often use pseudo-codes and this is also the step when we notice that there
    are a lot of common statements. These common statements may often be put inside
    functions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 函数真的可以帮助我们更好地组织。在设计程序时，我们经常使用伪代码，这也是我们注意到有很多常见语句的步骤。这些常见语句通常可以放在函数中。
- en: The function/call pattern is also easier to debug. We have only one part of
    code where the function sits. If there is a problem, we can debug the function
    itself just once, and all the calls will then be fixed instead of modifying the
    whole part of the code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 函数/调用模式也更容易调试。函数所在的部分只有一段代码。如果有问题，我们只需调试一次函数本身，然后所有的调用都会被修复，而不是修改整个代码部分。
- en: '![Easier coding and debugging](img/7584_04_001.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![更易编码和调试](img/7584_04_001.jpg)'
- en: Functions make your code easier to debug
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 函数使你的代码更容易调试
- en: Better modularity helps reusability
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更好的模块化有助于重用性
- en: Some part of your code will be high level and general. For instance, at some
    point, you may need a series of statements that can cut an array into pieces,
    then regroup all values following a basic rule. This series could be the body
    of a function. In another way, coding a function that converts Fahrenheit units
    into Celsius could interest you. These two examples are general-purpose functions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你的一些代码将是高级和通用的。例如，在某个时候，你可能需要一系列可以切割数组并按照基本规则重新组合所有值的语句。这个系列可以是函数的主体。另一种方式是编写一个将华氏单位转换为摄氏单位的函数可能对你感兴趣。这两个例子都是通用函数。
- en: In contrast, you can also have a specific function whose sole purpose is to
    convert U.S. Dollars to French Francs. You may not call it very often, but if
    occasionally necessary, it is always ready to handle that task.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你也可以有一个特定功能的唯一目的是将美元转换为法国法郎。你可能不会经常调用它，但如果偶尔需要，它总是准备好处理这个任务。
- en: 'In both cases, the function can be used and of course, re-used. The idea behind
    this is to save time. It also means that you can grab some already existing functions
    and re-use them. Of course, it has to be done following some principles, such
    as:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，函数都可以使用，当然也可以重用。背后的想法是节省时间。这也意味着你可以抓取一些已经存在的函数并重用它们。当然，这必须遵循一些原则，例如：
- en: Code licensing
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码许可
- en: Respect the API of the function that can be a part of a library
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尊重可以作为库一部分的函数的API
- en: Good match for your purpose
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与你的目的相匹配
- en: '**Code licensing** issue is an important point. We are used to grabbing, testing,
    and copy/pasting things, but the code you find isn''t always in the public domain.
    You have to take care of the license file that is often included in a code release
    archive, and in the first line of the code too, where comments can help you understand
    the conditions to respect the re-use of it.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码许可**问题是一个重要点。我们习惯于抓取、测试和复制粘贴东西，但你找到的代码并不总是属于公共领域。你必须注意通常包含在代码发布存档中的许可文件，以及在代码的第一行，其中注释可以帮助你理解尊重其再使用的条件。'
- en: '**Application Programming Interface** (**API**) means you have to conform yourself
    to some documentation before using the material related to that API. I understand
    that purists would consider this a small abuse, but it is a pretty pragmatic definition.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序编程接口**（**API**）意味着在使用与该API相关的材料之前，你必须遵守一些文档。我理解纯粹主义者可能会认为这是一种轻微的滥用，但这是一种相当实用主义的定义。'
- en: Basically, an API defines specifications for routines, data structures, and
    other code entities that can be re-used inside other programs. An API specification
    can be documentation of a library. In that case, it would precisely define what
    you can and cannot do.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，一个API定义了可以在其他程序内部重用的例程、数据结构和其他代码实体的规范。API规范可以是库的文档。在这种情况下，它将精确地定义你可以做什么，不可以做什么。
- en: The good-match principle can seem obvious, but sometimes out of convenience
    we find an existing library and choose to use it rather than coding our own solution.
    Unfortunately, sometimes in the end we only add more complication than originally
    intended. Doing it ourselves may fulfil the simple need, and will certainly avoid
    the complexities and idiosyncrasies of a more comprehensive solution. There's
    also the avoidance of a potential performance hit; you don't buy a limo when all
    you really need is to walk to the supermarket just down the street.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的匹配原则可能看起来很明显，但有时出于方便，我们会找到一个现有的库并选择使用它而不是编写自己的解决方案。不幸的是，有时最终我们只是增加了比最初打算更多的复杂性。自己来做可能满足简单的需求，并且肯定会避免更全面解决方案的复杂性和特殊性。还有避免潜在的性能损失；当你真正需要的是走到街角的超市时，你不会买一辆豪华轿车。
- en: Better readability
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更好的可读性
- en: It is a consequence of the other benefits, but I want to make you understand
    that this is more vital than commenting your code. Better readability means saving
    time to focus on something else. It also means easier code upgrade and improvement
    steps.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是其他益处的结果，但我希望让你明白这一点比注释你的代码更为重要。更好的可读性意味着节省时间来专注于其他事情。这也意味着更容易进行代码升级和改进步骤。
- en: C standard mathematical functions and Arduino
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C标准数学函数和Arduino
- en: As we have already seen, almost all standard C and C++ entities supported by
    the compiler **avr-g++** should work with Arduino. This is also true for C mathematical
    functions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，几乎所有的由编译器**avr-g++**支持的C和C++标准实体都应该与Arduino兼容。这也适用于C数学函数。
- en: This group of functions is a part of the (famous) C standard library. A lot
    of functions of this group are inherited in C++. There are some differences between
    C and C++ in the use of complex numbers. C++ doesn't provide complex numbers handling
    from that library but from its own C++ standard library by using the class template
    `std::complex`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这组函数是（著名的）C标准库的一部分。这个组中的许多函数在C++中被继承。C和C++在复数的使用上存在一些差异。C++不从这个库中提供复数处理，而是通过其自己的C++标准库，使用类模板
    `std::complex` 来提供。
- en: Almost all these functions are designed to work with and manipulate floating-point
    numbers. In standard C, this library is known as `math.h` (a filename), which
    we mention in the header of a C program, so that we can use its functions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有这些函数都是为了与浮点数一起工作并对其进行操作而设计的。在标准C中，这个库被称为 `math.h`（一个文件名），我们在C程序的头部提到它，这样我们就可以使用它的函数。
- en: Trigonometric C functions in the Arduino core
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino核心中的三角函数
- en: We often need to make some trigonometric calculations, from determining distances
    an object has moved, to angular speed, and many other real-world properties. Sometimes,
    you'll need to do that inside Arduino itself because you'll use it as an autonomous
    smart unit without any computers in the neighborhood.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要进行一些三角计算，从确定物体移动的距离，到角速度，以及许多其他现实世界的属性。有时，你需要在Arduino本身内部做这些计算，因为你会将其用作一个没有附近任何计算机的自主智能单元。
- en: The Arduino core provides the classic trigonometric functions that can be summarized
    by writing their prototypes. A major part of these return results in radians.
    Let's begin by reviewing our trigonometry just a bit!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino核心提供了经典的三角函数，可以通过编写它们的原型来总结。这些函数中的大部分以弧度返回结果。让我们先简要回顾一下我们的三角学！
- en: Some prerequisites
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些先决条件
- en: I promise, I'll be quick and light. But the following lines of text will save
    you time looking for your old and torn school book. When I learn knowledge from
    specific fields, I personally like to have all I need close at hand.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我保证，我会快速且简洁。但以下这些文本将节省你寻找你那本旧且破旧的学校课本的时间。当我从特定领域学习知识时，我特别喜欢把所有需要的东西都放在手边。
- en: Difference between radians and degrees
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 弧度和度数之间的区别
- en: '**Radian** is the unit used by many trigonometric functions. Then, we have
    to be clear about radians and degrees, and especially how to convert one into
    the other. Here is the official radian definition: **Alpha** is a ratio between
    two distances and is in radian units.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**弧度**是许多三角函数使用的单位。然后，我们必须清楚弧度和度数，尤其是如何将一个转换为另一个。以下是官方的弧度定义：**Alpha**是两个距离之间的比率，并以弧度单位表示。'
- en: '![Difference between radians and degrees](img/7584_04_002.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![弧度和度数之间的区别](img/7584_04_002.jpg)'
- en: Radian definition
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 弧度定义
- en: '**Degree** is the 1/360 of a full rotation (complete circle). Considering these
    two definitions and the fact that a complete rotation equals 2π, we can convert
    one into the other:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**度**是一个完整旋转的1/360（完整圆）。考虑到这两个定义以及一个完整旋转等于2π的事实，我们可以将一个转换为另一个：'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: angleradian = angledegree x π/180
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: angleradian = angledegree x π/180
- en: angledegree = angleradian x 180/π
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: angledegree = angleradian x 180/π
- en: Cosine, sine, and tangent
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 余弦、正弦和正切
- en: 'Let''s see the trigonometric triangle example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看三角形的例子：
- en: '![Cosine, sine, and tangent](img/7584_04_003.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![余弦、正弦和正切](img/7584_04_003.jpg)'
- en: 'Considering the angle A in radians, we can define cosine, sine, and tangent
    as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到以弧度为角度A，我们可以定义余弦、正弦和正切如下：
- en: cos(A) = b/h
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cos(A) = b/h
- en: sin(A) = a/h
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sin(A) = a/h
- en: tan(A) = sin(A)/cos(A) = a/b
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tan(A) = sin(A)/cos(A) = a/b
- en: 'Cosine and sine evolve from -1 to 1 for value of angles in radians, while tangent
    has some special points where it isn''t defined and then evolves cyclically from
    -∞ to +∞. We can represent them on the same graph as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 余弦和正弦在弧度角度的值为-1到1之间演变，而正切有一些特殊点，在这些点上它没有定义，然后周期性地从-∞演变到+∞。我们可以如下在同一张图上表示它们：
- en: '![Cosine, sine, and tangent](img/7584_04_004.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![余弦、正弦和正切](img/7584_04_004.jpg)'
- en: Graphical cosine, sine, and tangent representation
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图形余弦、正弦和正切表示
- en: Yes, of course, those functions oscillate, infinitely reproducing the same evolutions.
    It is good to keep in mind that they can be used for pure calculations but also
    to avoid overly linear value evolution in the time by replacing linearity by smoother
    oscillations. We'll see that a bit later.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些函数会振荡，无限地复制相同的演变。记住它们不仅可以用于纯计算，还可以通过用更平滑的振荡代替线性值演变来避免时间上的过度线性演变。我们稍后会看到这一点。
- en: We know how to calculate a cosine/sine/tangent when we have an angle, but how
    to calculate an angle when we already have the cosine/sine/tangent?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个角度时，我们知道如何计算余弦/正弦/正切，但当我们已经有了余弦/正弦/正切时，如何计算角度呢？
- en: Arccosine, arcsine, and arctangent
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 反余弦、反正弦和反正切
- en: Arccosine, arcsine, and arctangent are called inverse trigonometric functions.
    These functions are used to calculate an angle when you already have the distance
    ratios that I mentioned before.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 反余弦、反正弦和反正切被称为反三角函数。这些函数用于计算角度，当你已经有了之前提到的距离比时。
- en: 'They are called inverse because this is the inverse/reciprocal process of the
    previously seen trigonometric function. Basically, these functions provide you
    an angle, but considering the periodicity, they provide a lot of angles. If k
    is an integer, we can write:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被称为反函数，因为这是之前看到的三角函数的逆/倒数过程。基本上，这些函数为你提供一个角度，但考虑到周期性，它们提供了很多角度。如果 k 是整数，我们可以写成：
- en: sin (A) = x ó A = arcsin(x) + 2kπ or y = π – arcsin(x) + 2kπ
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sin (A) = x ó A = arcsin(x) + 2kπ 或 y = π – arcsin(x) + 2kπ
- en: cos (A) = x ó A = arccos(x) + 2kπ or y = 2π – arccos (x) + 2kπ
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cos (A) = x ó A = arccos(x) + 2kπ 或 y = 2π – arccos (x) + 2kπ
- en: tan (A) = x ó A = arctan(x) + kπ
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tan (A) = x ó A = arctan(x) + kπ
- en: These are the right mathematical relationships. Practically, in usual cases,
    we can drop the full rotation cases and forget about the 2kπ of the cosine and
    sine cases and kπ of the tangent case.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是正确的数学关系。实际上，在通常情况下，我们可以忽略完整的旋转情况，并忘记余弦和正弦函数的 2kπ 以及正切函数的 kπ。
- en: Trigonometry functions
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三角函数
- en: '`Math.h` contains the trigonometry function''s prototype, so does the Arduino
    core:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.h` 包含三角函数的原型，Arduino 核心也是如此：'
- en: '`double cos (double x);` returns the cosine of `x` radians'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double cos (double x);` 返回 `x` 弧度的余弦值'
- en: '`double sin (double x);` returns the sine of `x` radians'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double sin (double x);` 返回 `x` 弧度的正弦值'
- en: '`double tan (double x);` returns the tangent of `x` radians'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double tan (double x);` 返回 `x` 弧度的正切值'
- en: '`double acos (double x);` returns A, the angle corresponding to cos (A) = `x`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double acos (double x);` 返回 A，对应于 cos (A) = `x` 的角度'
- en: '`double asin (double x);` returns A, the angle corresponding to sin (A) = `x`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double asin (double x);` 返回 A，对应于 sin (A) = `x` 的角度'
- en: '`double atan (double x);` returns A, the angle corresponding to tan (A) = `x`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double atan (double x);` 返回 A，对应于 tan (A) = `x` 的角度'
- en: '`double atan2 (double y, double x);` returns arctan (`y`/`x`)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double atan2 (double y, double x);` 返回 arctan (`y`/`x`)'
- en: Exponential functions and some others
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指数函数和一些其他函数
- en: 'Making calculations, even basic ones, involves other types of mathematical
    functions, namely power, absolute value, and so on. The Arduino core then implements
    those. Some mathematical functions are given as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 进行计算，即使是基本的计算，也涉及其他类型的数学函数，例如幂、绝对值等。Arduino 核心随后实现了这些函数。以下是一些数学函数的示例：
- en: '`double pow (double x, double y);` returns `x` to power `y`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double pow (double x, double y);` 返回 `x` 的 `y` 次幂'
- en: '`double exp (double x);` returns the exponential value of `x`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double exp (double x);` 返回 `x` 的指数值'
- en: '`double log (double x);` returns the natural logarithm of `x` with `x` > 0'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double log (double x);` 返回 `x` 的自然对数，其中 `x` > 0'
- en: '`double log10 (double x);` returns the logarithm of `x` to base 10 with `x`
    > 0'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double log10 (double x);` 返回 `x` 以 10 为底的对数，其中 `x` > 0'
- en: '`double square (double x);` returns the square of `x`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double square (double x);` 返回 `x` 的平方'
- en: '`double sqrt (double x);` returns the square root of `x` with `x` >= 0'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double sqrt (double x);` 返回 `x` 的平方根，其中 `x` >= 0'
- en: '`double fabs (double x);` returns the absolute value of `x`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double fabs (double x);` 返回 `x` 的绝对值'
- en: Of course, mathematical rules, especially considering range of values, have
    to be respected. This is why I added some conditions of `x` to the list.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，数学规则，特别是考虑到值的范围，必须得到尊重。这就是为什么我在列表中添加了一些关于 `x` 的条件。
- en: All these functions are very useful, even for solving small problems. One day,
    I was teaching someone at a workshop and had to explain about measuring temperature
    with a sensor. This student was quite motivated but didn't know about these functions
    because she only played with inputs and outputs without converting anything (because
    she basically didn't need that). We then learned these functions, and she ended
    by even optimizing her firmware, which made me so proud of her!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都非常有用，即使是解决小问题。有一天，我在一个研讨会上教某人，不得不解释如何使用传感器测量温度。这位学生相当有动力，但她不了解这些函数，因为她只是玩输入和输出，没有进行任何转换（因为她基本上不需要那样做）。然后我们学习了这些函数，她甚至优化了自己的固件，这让我为她感到非常自豪！
- en: Now, let's approach some methods of optimization.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨一些优化方法。
- en: Approaching calculation optimization
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接近计算优化
- en: This section is an approach. It means it doesn't contain all the advanced tips
    and tricks for programming optimizations, but contains the optimizations on pure
    calculation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分是一个方法。这意味着它不包含所有高级编程优化的技巧，但包含纯计算的优化。
- en: Generally, we design an idea, code a program, and then optimize it. It works
    fine for huge programs. For smaller ones, we can optimize while coding.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们设计一个想法，编写一个程序，然后优化它。对于大型程序来说，这很正常。对于较小的程序，我们可以在编码时进行优化。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Normally, our firmware is small and so I''d suggest that you consider this
    as a new rule: Write each statement keeping optimization in mind.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们的固件很小，所以我建议你考虑以下新规则：编写每个语句时都要考虑到优化。
- en: 'I could add something else right now: Don''t kill the readability of your code
    with too many cryptic optimization solutions; I thought of *pointers* while writing
    that. I''ll add a few lines about them in order to make you familiar with, at
    least, the concept.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在可以添加一些其他内容：不要用太多的神秘优化方案破坏你代码的可读性；我在写那的时候想到了*指针*。我会添加几行关于它们的介绍，以便让你至少熟悉这个概念。
- en: The power of the bit shift operation
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位移运算的幂
- en: If I consider an array to store things, I almost always choose the size as a
    power of two. Why? Because the compiler, instead of performing the array indexing
    by using a CPU-intensive multiply operation, can use the more efficient bit shift
    operation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我考虑一个数组来存储东西，我几乎总是选择2的幂作为大小。为什么？因为编译器，而不是通过使用CPU密集型的乘法操作来进行数组索引，可以使用更高效的位移操作。
- en: What are bit operations?
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位操作是什么？
- en: 'Some of you must have already understood the way I work; I''m using a lot of
    pretexts to teach you new things. Bitwise operators are specific operators for
    bits. Some cases require this kind of calculation. I can quote two cases that
    we''ll learn about in the next part of this book:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的一些人可能已经理解了我的工作方式；我使用了很多借口来教你们新东西。位运算符是针对位的具体运算符。有些情况下需要这种计算。我可以引用两个我们将在本书下一部分学习的情况：
- en: Using shift registers for multiplexing
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用移位寄存器进行复用
- en: Performing arithmetic operations, for powers of 2, involving the multiply and
    divide operator
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行涉及乘法和除法运算符的2的幂的算术运算
- en: There are four operators and two bit shift operators. Before we dive into it,
    let's learn a bit more about the binary numeral system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个运算符和两个位移运算符。在我们深入之前，让我们更多地了解二进制数制。
- en: Binary numeral system
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制数制
- en: 'We are used to counting using the decimal system, also called decimal numeral
    system or base-10 number system. In this system, we can count as:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯于使用十进制系统进行计数，也称为十进制数制或基-10数制。在这个系统中，我们可以这样计数：
- en: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...
- en: 'Binary numeral system is the system used under the hood in computers and digital
    electronic devices. It is also named base-2 system. In this system we count as
    follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数制是计算机和数字电子设备底层使用的系统。它也被称为基-2系统。在这个系统中，我们这样计数：
- en: 0, 1, 10, 11, 100, 101, 110, 111...
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 0, 1, 10, 11, 100, 101, 110, 111...
- en: Easily converting a binary number to a decimal number
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将二进制数轻松转换为十进制数
- en: A nice trick to convert from binary to decimal, start by counting the position
    of 0 and 1, starting from the index 0.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将二进制转换为十进制的一个小技巧，从索引0开始，先计算0和1的位置。
- en: 'Let''s take 110101\. It can be represented as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以110101为例。它可以表示如下：
- en: '| Positions | 0 | 1 | 2 | 3 | 4 | 5 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | 0 | 1 | 2 | 3 | 4 | 5 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '|   | 1 | 0 | 1 | 0 | 1 | 1 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|   | 1 | 0 | 1 | 0 | 1 | 1 |'
- en: 'Then, I can write this sum of multiplications and it equals the decimal version
    of my 110101 number:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以写出这个乘积之和，它等于我的110101数字的十进制版本：
- en: 1 x 20 + 0 x 21 + 1 x 22 + 0 x 23 + 1 x 24 + 1 x 25 = 1 + 4 + 16 + 32 = 53
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 1 x 20 + 0 x 21 + 1 x 22 + 0 x 23 + 1 x 24 + 1 x 25 = 1 + 4 + 16 + 32 = 53
- en: Each bit *decides* if we have to consider the power of 2, considering its position.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每一位 *决定* 我们是否需要考虑2的幂，考虑到其位置。
- en: AND, OR, XOR, and NOT operators
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与（AND）、或（OR）、异或（XOR）和非（NOT）运算符
- en: Let's have a look at these four operators.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这四个运算符。
- en: AND
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与（AND）
- en: 'The bitwise AND operator is written with a single ampersand: `&`. This operator
    operates on each bit position independently according to the following rules:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 按位与运算符用单个与号（`&`）表示。这个运算符根据以下规则独立地对每个位位置进行操作：
- en: 0 `&` 0 == 0
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 `&` 0 == 0
- en: 0 `&` 1 == 0
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 `&` 1 == 0
- en: 1 `&` 0 == 0
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 `&` 0 == 0
- en: 1 `&` 1 == 1
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 `&` 1 == 1
- en: 'Let''s take a real example with integers, which are a 16-bit value:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个实际的整数例子来说明，整数是一个16位的值：
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To find the result easily, we have to compare each bit one by one for each position
    while following the preceding rules.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了容易找到结果，我们必须遵循前面的规则，逐位比较每个位置的每个位。
- en: OR
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: OR
- en: 'The bitwise OR operator is written with a single vertical bar: `|`. It can
    be done by pressing *Alt* + *Shift* + *l* (letter L) on OSX and *Shift* + *\*
    on other PC keyboards. This operator operates on each bit position independently
    according to the following rules:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 按位或运算符用单个竖线表示：`|`。在 OSX 上，可以通过按 *Alt* + *Shift* + *l*（字母 L）来实现，在其他 PC 键盘上则是
    *Shift* + *\*。这个运算符根据以下规则独立地对每个位位置进行操作：
- en: 0 `|` 0 == 0
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 `|` 0 == 0
- en: 0 `|` 1 == 1
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 `|` 1 == 1
- en: 1 `|` 0 == 1
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 `|` 0 == 1
- en: 1 `|` 1 == 1
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 `|` 1 == 1
- en: XOR
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: XOR
- en: 'The bitwise XOR operator is written with a single caret symbol: `^`. This operator
    operates on each bit position independently according to the following rules:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 按位异或运算符用单个撇号符号表示：`^`。这个运算符根据以下规则独立地对每个位位置进行操作：
- en: 0 `^` 0 == 0
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 `^` 0 == 0
- en: 0 `^` 1 == 1
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 `^` 1 == 1
- en: 1 `^` 0 == 1
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 `^` 0 == 1
- en: 1 `^` 1 == 0
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 `^` 1 == 0
- en: It is the exclusive version of OR, thus the name XOR.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 XOR 的排他版本，因此得名 XOR。
- en: NOT
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: NOT
- en: 'The bitwise XOR operator is written with a tilde symbol: `~`. It is a unary
    operator, which means, if you remember this term correctly, it can apply to one
    number only. I call it the *bit changer* in my workshops. It changes each bit
    to its opposite:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 按位异或运算符用波浪线符号表示：`~`。它是一个一元运算符，也就是说，如果你正确地记住这个术语，它只能应用于一个数字。我在我的研讨会上称它为*位变换器*。它将每个位变换为其相反数：
- en: '`~`0 == 1'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~`0 == 1'
- en: '`~`1 == 0'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~`1 == 0'
- en: 'Let''s take a real example with integers, which are 16-bit values as you know:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个实际的整数例子来说明，正如你所知，整数是 16 位值：
- en: '[PRE7]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you already know, the `int` type in C is a signed type ([Chapter 3](ch03.html
    "Chapter 3. C Basics – Making You Stronger"), *C Basics – Making You Stronger*)
    that is able to encode numbers from -32,768 to 32,767—negative numbers too.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，C 语言中的 `int` 类型是一个有符号类型（[第 3 章](ch03.html "第 3 章。C 基础 – 使你更强壮"），*C 基础 –
    使你更强壮*），能够编码从 -32,768 到 32,767 的数字——包括负数。
- en: Bit shift operations
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按位移位操作
- en: 'Coming from C++, the left shift and the right shift operators are respectively
    symbolized by `<<` and `>>`. It is easy to remember, the double << goes to the
    left, and the other one >> to the right. Basically, it works like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 C++ 的左移和右移运算符分别用 `<<` 和 `>>` 表示。这很容易记住，双 << 表示向左移动，另一个 >> 表示向右移动。基本上，它的工作原理是这样的：
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is quite easy to see how it works. You shift all bits from a particular number
    of positions to the left or to the right. Some of you would have noticed that
    this is the same as multiplying or dividing by 2\. Doing `<< 1` means multiply
    by 2, `>> 1` means divide by 2\. `<< 3` means multiply by 8 (23), `>> 5` means
    divide by 32 (25), and so on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出它是如何工作的。你将所有位从特定数量的位置向左或向右移动。有些人可能已经注意到，这与乘以或除以 2 是相同的。`<< 1` 表示乘以 2，`>>
    1` 表示除以 2。`<< 3` 表示乘以 8（2^3），`>> 5` 表示除以 32（2^5），以此类推。
- en: It is all about performance
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这一切都是关于性能
- en: 'Bitwise operations are primitive actions directly supported by the processor.
    Especially with embedded systems, which are still not as powerful as normal computers,
    using bitwise operations can dramatically improve performance. I can write two
    new rules:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 按位操作是处理器直接支持的原始操作。特别是对于嵌入式系统，它们仍然不如普通计算机强大，使用按位操作可以显著提高性能。我可以写出两条新的规则：
- en: Using power of 2 as the array size drives the use of bit shift operators internally/implicitly
    while the CPU performs index calculations. As we just learned, multiplying/dividing
    by 2 can be done very efficiently and quickly with bit shift.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 2 的幂作为数组大小，在 CPU 执行索引计算时，会内部/隐式地驱动使用位移动运算符。正如我们刚刚学到的，乘以或除以 2 可以非常高效和快速地通过位移动来完成。
- en: All your multiplications and divisions by a power of 2 should be replaced by
    bit shifting.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有乘以或除以 2 的幂次的乘除运算都应该用位移动来替换。
- en: This is the nicest compromise between cryptic code and an efficient code. I
    used to do that quite often. Of course, we'll learn real cases using it. We are
    still in the most theoretical part of this book, but everything here will become
    clear quite soon.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在晦涩代码和高效代码之间最完美的折衷。我过去经常这样做。当然，我们将会学习使用它的实际案例。我们仍然处于这本书最理论的部分，但这里的一切很快就会变得清晰。
- en: The switch case labels optimization techniques
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: switch 语句标签优化技术
- en: The `switch`…`case` conditional structure can also be optimized while you are
    writing it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 `switch`…`case` 条件结构时，也可以对其进行优化。
- en: Optimizing the range of cases
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化案例范围
- en: The first rule is to place all cases of the considered switch in the narrowest
    range possible.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则是将考虑的switch的所有案例尽可能放在最窄的范围内。
- en: In such a case, the compiler produces what we call a *jump table of case labels*,
    instead of generating a huge `if`-`else`-`if` cascade. The jump table based `switch`…`case`
    statement 's performance is independent of the number of case entries in the `switch`
    statement.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器生成我们所说的“案例标签跳转表”，而不是生成巨大的`if`-`else`-`if`级联。基于跳转表的`switch`…`case`语句的性能与`switch`语句中案例条目的数量无关。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: So, place all cases of the switch in the narrowest range possible.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将所有switch的案例放在尽可能窄的范围内。
- en: Optimizing cases according to their frequency
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据频率优化案例
- en: The second rule is to place all cases sorted from the most frequently occurring
    to the least frequently occurring when you know the frequency.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则是，当你知道频率时，将所有案例按最常发生到最不常发生的顺序排序。
- en: As mentioned before, in cases where your `switch` statement contains cases placed
    far apart, because you cannot handle that in another way, the compiler replaces
    the `switch` statement and generates `if`-`else`-`if` cascades. It means it will
    always be better to reduce the potential number of comparisons; this also means
    that if the cases that are most probable are placed at the beginning, you maximize
    your chances to do that.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在`switch`语句包含相隔较远的案例的情况下，因为你不能以其他方式处理，编译器会替换`switch`语句并生成`if`-`else`-`if`级联。这意味着总是减少潜在的比较次数会更好；这也意味着如果最可能的案例被放在开始处，你就有更大的机会做到这一点。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: So, place all cases sorted from the most frequently occurring to the least frequently
    occurring.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将所有案例按最常发生到最不常发生的顺序排序。
- en: Smaller the scope, the better the board
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围越小，板子越好
- en: 'As I already mentioned when we talked about a variables'' scope, always use
    the smallest scope possible for any variables. Let''s check this example with
    a function named `myFunction`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在讨论变量作用域时已经提到的那样，始终为任何变量使用可能的最小作用域。让我们用名为`myFunction`的函数来检查这个例子：
- en: '[PRE9]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`temporaryVariable` is only required in one case, when `valueToTest` equals
    `1`. If I declare `temporaryVariable` outside of the `if` statement, whatever
    the value of `valueToTest`, `temporaryVariable` will be created.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`temporaryVariable`只在一种情况下需要，即`valueToTest`等于`1`。如果我在`if`语句之外声明`temporaryVariable`，无论`valueToTest`的值如何，`temporaryVariable`都会被创建。'
- en: In the example I cite, we save memory and processing; in all cases where `valueToTest`
    is not equal to `1`, the variable `temporaryVariable` is not even created.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我引用的例子中，我们节省了内存和处理时间；在所有`valueToTest`不等于`1`的情况下，变量`temporaryVariable`甚至没有被创建。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use the smallest scope possible for all your variables.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有变量使用可能的最小作用域。
- en: The Tao of returns
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回的道
- en: Functions are usually designed with a particular idea in mind, they are modules
    of code able to perform specific operations through the statements that they include
    and are also able to return a result. This concept provides a nice way to forget
    about all those specific operations performed inside the function when we are
    outside of the function. We know the function has been designed to provide you
    a result when you give arguments to it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通常是根据特定的想法设计的，它们是能够通过包含的语句执行特定操作的代码模块，并且也能够返回一个结果。这个概念提供了一个很好的方法，在我们不在函数内部时忘记函数内部执行的所有特定操作。我们知道函数被设计成当我们给它提供参数时提供结果。
- en: Again, this is a nice way to focus on the core of your program.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一种关注程序核心的好方法。
- en: Direct returns concept
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接返回的概念
- en: 'As you may have already understood, declaring a variable creates a place in
    memory. That place cannot be used by something else, of course. The process that
    creates the variable consumes processor time. Let''s take the same previous example
    detailed a bit more:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经理解的，声明一个变量会在内存中创建一个位置。当然，这个位置不能被其他东西使用。创建变量的过程会消耗处理器时间。让我们更详细地看看之前的例子：
- en: '[PRE10]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What could I improve to try to avoid the use of `temporaryVariable`? I could
    make a *direct return* as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我能做些什么来尝试避免使用`temporaryVariable`？我可以进行如下直接的返回：
- en: '[PRE11]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the longer version:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在更长的版本中：
- en: We were inside the `valueToTest == 1` case thus `valueToTest` equals `1`
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`valueToTest == 1`的案例中，因此`valueToTest`等于`1`
- en: I directly put the calculation in the `return` statement
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我直接在`return`语句中放入计算
- en: In that case, there is no more temporary variable creation. There are some cases
    where it can be more readable to write a lot of temporary variables. But now,
    you are aware that it is worth finding compromises between readability and efficiency.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，不再需要创建临时变量。有些情况下，写很多临时变量可能更易于阅读。但现在，你已经意识到在可读性和效率之间找到折衷是值得的。
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use a direct return instead of a lot of temporary variables.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用直接返回而不是很多临时变量。
- en: Use void if you don't need return
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果不需要返回值，请使用void
- en: I often read code including functions with a return type that didn't return
    anything. The compiler may warn you about that. But in case it didn't, you have
    to take care of it. A call to a function that provides a return type will always
    pass the return value even if nothing inside the function's body is really returned.
    This has a CPU cost.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常阅读包含没有返回值的函数返回类型的代码。编译器可能会警告你这一点。但如果没有警告，你必须注意这个问题。调用一个提供返回类型的函数时，总是会传递返回值，即使函数体内实际上没有返回任何内容。这会产生CPU开销。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use `void` as a return type for your functions if they don't return anything.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的函数不返回任何内容，请使用`void`作为返回类型。
- en: Secrets of lookup tables
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找表的秘密
- en: '**Lookup tables** are one of the most powerful tricks in the programming universe.
    They are arrays containing precalculated values and thus replace heavy runtime
    calculations by a simpler array index operation. For instance, imagine you want
    to track positions of something by reading distances coming from a bunch of distance
    sensors. You''ll have *trigonometric* and probably *power* calculations to perform.
    Because they can be time consuming for your processor, it would be smarter and
    cheaper to use array content reading instead of those calculations. This is the
    usual illustration for the use of lookup tables.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找表**是编程宇宙中最强大的技巧之一。它们是包含预先计算值的数组，因此通过简单的数组索引操作替换了复杂的运行时计算。例如，想象一下你想通过读取来自一组距离传感器的距离来跟踪某个东西的位置。你将需要进行*三角*和可能*幂*的计算。由于这些计算可能会消耗处理器的时间，使用数组内容读取而不是这些计算会更聪明、更经济。这是查找表使用的通常说明。'
- en: These lookup tables can be precalculated and stored in a static program's storage
    memory, or calculated at the program's initialization phase (in that case, we
    call them *prefetched lookup tables*).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查找表可以预先计算并存储在静态程序的存储内存中，或者计算在程序的初始化阶段（在这种情况下，我们称它们为*预取查找表*）。
- en: Some functions are particularly expensive, considering the CPU work. Trigonometric
    functions are one such function that can have bad consequences as the storage
    space and memory are limited in embedded systems. They are typically prefetched
    in code. Let's check how we can do that.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数在CPU工作方面特别昂贵。三角函数就是这样一种函数，在嵌入式系统中，由于存储空间和内存有限，它们可能会产生不良后果。它们通常在代码中被预取。让我们看看我们如何做到这一点。
- en: Table initialization
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表初始化
- en: We have to precalculate the cosine **Look Up Table** (**LUT**). We need to create
    a small precision system. While calling cos(x) we can have all values of x that
    we want. But if we want to prefetch values inside an array, which has by design
    a finite size, we have to calculate a finite number of values. Then, we cannot
    have our cos(x) result for all float values but only for those calculated.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须预先计算余弦**查找表**（**LUT**）。我们需要创建一个小的精度系统。在调用cos(x)时，我们可以拥有我们想要的任何x值。但如果我们想在具有设计上有限大小的数组中预取值，我们必须计算有限数量的值。然后，我们不能为所有浮点值计算余弦(x)的结果，而只能为计算出的那些值。
- en: I consider precision as an angle of 0.5 degrees. It means, for instance, that
    the result of cosine of 45 degrees will be equal to the cosine of 45 degrees 4
    minutes in our system. Fair enough.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为精度是0.5度的角度。这意味着，例如，在我们系统中，45度的余弦值将等于45度4分钟的余弦值。这是合理的。
- en: 'Let''s consider the Arduino code. You can find this code in the `Chapter04`/`CosLUT`/
    folder:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑Arduino代码。你可以在`Chapter04`/`CosLUT`/文件夹中找到这段代码：
- en: '[PRE12]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`cosLUT` is declared as an array of the type `float` with a special size. 360
    * 1/(precision in degrees) is just the number of elements we need in our array
    considering the precision. Here, precision is 0.5 degrees and of course, the declaration
    could be simplified as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`cosLUT`被声明为一个特殊大小的`float`类型数组。360 * 1/(精度，以度为单位)就是我们数组中需要的元素数量。在这里，精度是0.5度，当然，声明可以简化如下：'
- en: '[PRE13]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We also declared and defined a `DEG2RAD` constant that is useful to convert
    degrees to radians. We declared `cosinePrecision` and `cosinePeriod` in order
    to perform those calculations once.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明并定义了一个 `DEG2RAD` 常量，它有助于将度转换为弧度。我们声明了 `cosinePrecision` 和 `cosinePeriod`
    以执行这些计算一次。
- en: Then, we defined an `initCosineLUT()`function that performs the precalculation
    inside the `setup()` function. Inside its body, we can see a loop over index `i`,
    from `i=0` to the size of the array minus one. This loop precalculates values
    of cosine(x) for all values of x from 0 to 2π. I explicitly wrote the x as `i
    * DEG2RAD * precision` in order to keep the precision visible.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个 `initCosineLUT()` 函数，它在 `setup()` 函数内部执行预计算。在其主体中，我们可以看到一个从 `i=0`
    到数组大小的循环。这个循环预先计算了从 0 到 2π 的所有 x 值的余弦(x)值。我明确地将 x 写成 `i * DEG2RAD * precision`，以便保持精度可见。
- en: At the board initialization, it calculates all the lookup table values once
    and provides these for further calculation by a simple array index operation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在板初始化时，它计算所有查找表值一次，并通过简单的数组索引操作提供这些值以供进一步计算。
- en: Replacing pure calculation with array index operations
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用数组索引操作替换纯计算
- en: 'Now, let''s retrieve our cosine values. We can easily retrieve our values by
    accessing our LUT through another function, shown as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检索我们的余弦值。我们可以通过访问另一个函数来轻松检索我们的值，如下所示：
- en: '[PRE14]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`angle * 1 / cosinePrecision` gives us the angle considering the given precision
    of our LUT. We apply a modulo operation considering the `cosinePeriod` value to
    wrap values of higher angles to the limit of our LUT, and we have our index. We
    directly return the array value corresponding to our index.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`angle * 1 / cosinePrecision` 给出了考虑给定精度的 LUT 的角度。我们应用一个考虑 `cosinePeriod` 值的模运算，将更高角度的值包装到
    LUT 的限制内，我们得到了索引。我们直接返回与我们的索引对应的数组值。'
- en: We could also use this technique for root square prefetching. This is the way
    I used it in another language when I coded my first iOS application named **digital
    collisions** **(** [http://julienbayle.net/blog/2012/04/07/digital-collisions-1-1-new-features](http://julienbayle.net/blog/2012/04/07/digital-collisions-1-1-new-features)).
    If you didn't test it, this is an application about generative music and visuals
    based on physical collision algorithms. I needed a lot of distance and rotation
    calculations. Trust me, this technique turned the first sluggish prototype into
    a fast application.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用这种技术进行平方根预取。这是我使用另一种语言在编写我的第一个名为 **digital collisions** 的 iOS 应用程序时使用的方法（[http://julienbayle.net/blog/2012/04/07/digital-collisions-1-1-new-features](http://julienbayle.net/blog/2012/04/07/digital-collisions-1-1-new-features)）。如果你没有测试过，这是一个基于物理碰撞算法的生成音乐和视觉应用程序。我需要进行大量的距离和旋转计算。相信我，这种技术将第一个缓慢的原型变成了一个快速的应用程序。
- en: Taylor series expansion trick
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泰勒级数展开技巧
- en: There is another nice way to save CPU work that requires some math. I mean,
    a bit more advanced math. Following words are very simplified. But yes, we need
    to focus on the C side of things, and not totally on mathematics.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种节省CPU工作量的好方法，这需要一些数学知识。我的意思是，稍微高级一点的数学。以下内容非常简化。但确实，我们需要关注事情中的C部分，而不是完全关注数学。
- en: Taylor series expansions are a way to approximate almost every mathematical
    expression at a particular point (and around it) by using polynomial expressions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 泰勒级数展开是一种通过使用多项式表达式来近似特定点（及其周围）的几乎每个数学表达式的方法。
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A polynomial expression is similar to the following expression:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式表达式类似于以下表达式：
- en: P(x) = a + bx + cx2 + dx3
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: P(x) = a + bx + cx^2 + dx^3
- en: P(x) is a polynomial function with a degree 3\. a, b, c, and d are float numbers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: P(x)是一个三次多项式函数。a, b, c和d是浮点数。
- en: The idea behind a Taylor series is that we can approximate an expression by
    using the first term of the theoretical infinite sums that represent this expression.
    Let's take some examples.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 泰勒级数的理念是，我们可以通过使用表示该表达式的理论无限和的第一个项来近似一个表达式。让我们举一些例子。
- en: 'For instance, considering x evolving from -π and π; we can write the function
    sine as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑 x 从 -π 到 π 的变化；我们可以将正弦函数写成以下形式：
- en: sin(x) ≈ x - x3/6 + x5/120 - x7/5040
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: sin(x) ≈ x - x^3/6 + x^5/120 - x^7/5040
- en: 'The sign ≈ means "approximately equals". Inside a reasonable range, we can
    replace sin(x) by x - x3/6 + x5/120 - x7/5040\. There is no magic, just mathematical
    theorems. We can also write x evolving from -2 to 3 as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 ≈ 表示“约等于”。在合理范围内，我们可以用 x - x^3/6 + x^5/120 - x^7/5040 替换 sin(x)。这没有魔法，只是数学定理。我们也可以将
    x 从 -2 到 3 的变化写成以下形式：
- en: ex ≈ 1 + x + x2/2 + x3/6 + x4/24
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ex ≈ 1 + x + x^2/2 + x^3/6 + x^4/24
- en: I could add some other examples here, but you'll be able to find this in the
    *Appendix D, Some Useful Taylor Series for Calculation Optimization*. These techniques
    are some powerful tricks to save CPU time.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在这里添加一些其他示例，但你将在 *附录 D，一些有用的泰勒级数用于计算优化* 中找到这些。这些技术是一些节省 CPU 时间的强大技巧。
- en: The Arduino core even provides pointers
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino 核心甚至提供了指针
- en: 'Pointers are more complicated techniques for beginners in C programming but
    I want you to understand the concept. They are not data, but they point to the
    starting point of a piece of data. There are at least two ways to pass data to
    a function or something else:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是 C 编程初学者的更复杂的技术，但我希望你能理解这个概念。它们不是数据，而是指向数据起始点的指针。至少有两种方法可以将数据传递给一个函数或其他东西：
- en: Copy it and pass it
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制并传递它
- en: Pass a pointer to it
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向它传递一个指针
- en: In the first case, if the amount of data is too large our memory stack would
    explode because the whole data would be copied in the stack. We wouldn't have
    a choice other than a pointer pass.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，如果数据量太大，我们的内存堆栈就会爆炸，因为整个数据都会复制在堆栈中。我们除了指针传递外别无选择。
- en: In this case, we have the reference of the place where the data is stored in
    memory. We can operate exactly as we want but only by using pointers. Pointers
    are a smart way to deal with any type of data, especially arrays.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有数据存储在内存中的位置的引用。我们可以按照我们想要的任何方式操作，但只能通过使用指针。指针是处理任何类型数据，尤其是数组的智能方式。
- en: Time measure
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间测量
- en: Time is always something interesting to measure and to deal with, especially
    in embedded software that is, obviously, our main purpose here. The Arduino core
    includes several time functions that I'm going to talk about right now.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 时间总是测量和处理的有意思的东西，尤其是在嵌入式软件中，这显然是我们在这里的主要目的。Arduino 核心包括几个我将要讨论的时间函数。
- en: There is also a nice library that is smartly named **SimpleTimer Library** and
    designed as a GNU LGPL 2.1 + library by *Marcello Romani*. This is a good library
    based on the `millis()` core function which means the maximum resolution is 1
    ms. This will be more than enough for 99 percent of your future projects. *Marcello*
    even made a special version of the library for this book, based on `micros()`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个命名得非常巧妙的库，名为 **SimpleTimer Library**，由 *Marcello Romani* 设计，作为一个 GNU LGPL
    2.1 + 库。这是一个基于 `millis()` 核心函数的好库，这意味着最大分辨率是 1 毫秒。这对你未来 99% 的项目来说将绰绰有余。*Marcello*
    甚至为这本书制作了一个基于 `micros()` 的特殊版本库。
- en: The Arduino core library now also includes a native function that is able to
    have a resolution of 8 microseconds, which means you can measure time delta of
    1/8,000,000 of a second; quite precise, isn't it?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 核心库现在也包括一个能够达到 8 微秒分辨率的本地函数，这意味着你可以测量 1/8,000,000 秒的时间差；非常精确，不是吗？
- en: I'll also describe a higher resolution library **FlexiTimer2** in the last chapter
    of the book. It will provide a high-resolution, customizable timer.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我还会在书的最后一章描述一个更高分辨率的库 **FlexiTimer2**。它将提供一个高分辨率、可定制的计时器。
- en: Does the Arduino board own a watch?
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino 板子有自己的手表吗？
- en: The Arduino board chip provides its *uptime*. The *uptime* is the time since
    the board has started. It means you cannot natively store absolute time and date
    without keeping the board up and powered. Moreover, it will require you to set
    up the absolute time once and then keep the Arduino board powered. It is possible
    to keep the board autonomously powered. I also talk about that later in this book.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 板芯片提供其 *运行时间*。*运行时间* 是自板子启动以来的时间。这意味着你无法在不保持板子开启和供电的情况下，以原生方式存储绝对时间和日期。此外，它将要求你设置一次绝对时间，然后保持
    Arduino 板供电。可以自主地为板子供电。我会在本书的后面部分讨论这一点。
- en: The millis() function
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`millis()` 函数'
- en: The core function `millis()` returns the number of milliseconds since the board
    has been started the last time. For your information, 1 millisecond equals 1/1000
    of a second.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 核心函数 `millis()` 返回自板子上次启动以来的毫秒数。为了你的信息，1 毫秒等于 1/1000 秒。
- en: The Arduino core documentation also provides that this number will go back to
    zero after approximately 50 days (this is called the timer overflow). You can
    smile now, but imagine your latest installation artistically illustrating the
    concept of time in the MoMA in NYC which, after 50 days, would get totally messed
    up. You would be interested to know this information, wouldn't you? The return
    format of `millis()` is *unsigned long*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino核心文档还提供，这个数值在大约50天后会回到零（这被称为计时器溢出）。现在你可以笑了，但想象一下你的最新安装艺术性地在纽约市的MoMA中阐释时间概念，50天后会完全混乱。你肯定会对这个信息感兴趣，不是吗？`millis()`的返回格式是`unsigned
    long`。
- en: 'Here is an example you''ll have to upload to your board in the next few minutes.
    You can also find this code in the `Chapter04`/ `measuringUptime`/ folder:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个你将在接下来的几分钟内上传到板上的示例。你还可以在`Chapter04`/`measuringUptime`/文件夹中找到这段代码：
- en: '[PRE15]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Can you optimize this (only for pedagogical reasons as this is a very small
    program)? Yes, indeed, we can avoid the use of the `measuredTime` variable. It
    would look more like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你能优化这个（仅出于教学目的，因为这个程序非常小）吗？是的，我们确实可以避免使用`measuredTime`变量。它看起来会更像这样：
- en: '[PRE16]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is also beautiful in its simplicity, isn't it? I'm sure you'll agree. So
    upload this code on your board, start the Serial Monitor, and look at it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 它的简单性也很美，不是吗？我相信你会同意的。所以将这段代码上传到你的板上，启动串行监视器，看看它。
- en: The micros() function
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`micros()`函数'
- en: 'If you needed more precision, you could use the `micros()` function. It provides
    uptime with a precision of 8 microseconds as written before but with an overflow
    of approximately 70 minutes (significantly less than 50 days, right?). We gain
    precision but loose overflow time range. You can also find the following code
    in the `Chapter04`/`measuringUptimeMicros`/ folder:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更高的精度，可以使用`micros()`函数。它提供与之前所述的8微秒精度相同的工作时间，但大约有70分钟的溢出（远小于50天，对吧？）。我们获得了精度，但失去了溢出时间范围。你还可以在`Chapter04`/`measuringUptimeMicros`/文件夹中找到以下代码：
- en: '[PRE17]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Upload it and check the Serial Monitor.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 上传并检查串行监视器。
- en: Delay concept and the program flow
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟概念和程序流程
- en: Like Le Bourgeois Gentilhomme who spoke prose without even realizing it, you've
    already used the `delay()` core function and haven't realized it. Delaying an
    Arduino program can be done using the `delay()` and `delayMicroseconds()` functions
    directly in the `loop()` function.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 就像那位连自己说话都是散文的布尔乔亚绅士一样，你已经使用了`delay()`核心函数，却并未意识到。在`loop()`函数中，可以通过直接使用`delay()`和`delayMicroseconds()`函数来延迟Arduino程序。
- en: Both functions drive the program to make a pause. The only difference is that
    you have to provide a time in millisecond to `delay()` and a time in microseconds
    to `delayMicroseconds()`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都会使程序暂停。唯一的区别是，你必须为`delay()`提供一个毫秒数，为`delayMicroseconds()`提供一个微秒数。
- en: What does the program do during the delay?
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序在延迟期间做什么？
- en: Nothing. It waits. This sub-subsection isn't a joke. I want you to focus on
    this particular point because later it will be quite important.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 什么也不做。它等待。这个子子节并不是玩笑。我希望你能专注于这个特定的点，因为稍后它将非常重要。
- en: Note
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you call `delay` or `delayMicroseconds` in a program, it stops its execution
    for a certain amount of time.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在程序中调用`delay`或`delayMicroseconds`时，它会停止执行一段时间。
- en: 'Here is a small diagram illustrating what happens when we power on our Arduino:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小图解，说明了当我们打开Arduino时会发生什么：
- en: '![What does the program do during the delay?](img/7584_04_012.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![程序在延迟期间做什么？](img/7584_04_012.jpg)'
- en: One lifecycle of a Arduino's firmware
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino固件的一个生命周期
- en: 'Now here is a diagram of the firmware execution itself, which is the part that
    we will work with, in the next rows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是一个固件执行的图解，这是我们将在下一行中工作的部分：
- en: '![What does the program do during the delay?](img/7584_04_005.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![程序在延迟期间做什么？](img/7584_04_005.jpg)'
- en: The firmware life cycle with the main part looping
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 固件生命周期中的主要部分循环
- en: 'Accepting the fact that when `setup()` stops, the `loop()` function begins
    to loop, everything in `loop()` is continuous. Now look at the same things when
    delays happen:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接受这样一个事实：当`setup()`停止时，`loop()`函数开始循环，`loop()`中的所有内容都是连续的。现在看看当出现延迟时的情况：
- en: '![What does the program do during the delay?](img/7584_04_006.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![程序在延迟期间做什么？](img/7584_04_006.jpg)'
- en: The firmware life cycle with the main part looping and breaking when delay()
    is called
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`delay()`时，固件的主要部分循环，并中断
- en: The whole program breaks when `delay()` is called. The length of the break depends
    on the parameter passed to `delay()`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `delay()` 时，整个程序会中断。中断的长度取决于传递给 `delay()` 的参数。
- en: We can notice that everything is done sequentially and in time. If a statement
    execution takes a lot of time, Arduino's chip executes it, and then continues
    with the next task.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到，所有事情都是按顺序和按时完成的。如果一条语句执行需要很长时间，Arduino 的芯片会先执行它，然后继续下一个任务。
- en: In that very usual and common case, if one particular task (statements, function
    calls, or whatever) takes a lot of time, the whole program could be hung and produce
    a hiccup; consider the user experience.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种非常常见和普遍的情况下，如果某个特定任务（语句、函数调用或任何其他）需要很长时间，整个程序可能会挂起并产生中断；考虑用户体验。
- en: Imagine that concrete case in which you have to read sensors, flip-flop some
    switches, and write information to a display *at the same time*. If you do that
    sequentially and you have a lot of sensors, which is quite usual, you can have
    some lag and slowdown in the display of information because that task is executed
    after the other one in `loop()`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这样一个具体案例，你需要在同一时间读取传感器，切换一些开关，并将信息写入显示屏。如果你按顺序这样做，并且你有大量的传感器，这是相当常见的，那么在
    `loop()` 中执行这个任务会在其他任务之后，你可能会在信息显示上出现一些延迟和减速。
- en: '![What does the program do during the delay?](img/7584_04_007.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![程序在延迟期间做什么？](img/7584_04_007.jpg)'
- en: An Arduino board busy with many inputs and outputs
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一个忙于许多输入和输出的 Arduino 板
- en: 'I usually teach my students at least two concepts in dealing with that only-one-task
    property that can feel like a limitation:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常至少向我的学生传授两个处理这种单一任务属性（可能会感觉像是一种限制）的概念：
- en: Thread
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程
- en: Interrupt handler (and subsequent interrupt service routine concept)
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断处理程序（以及随后的中断服务例程概念）
- en: 'I obviously teach another one: *The polling*. **The polling is a special interrupt
    case from where we will begin.**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我显然还教授另一个：*轮询*。**轮询是一种特殊的中断情况，我们将从这里开始。**
- en: The polling concept – a special interrupt case
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投票概念 – 一种特殊的中断情况
- en: You know the poll term. I can summarize it as "ask, wait for an answer, and
    keep it somewhere".
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道轮询这个词。我可以将其总结为“询问，等待答案，并将其保存在某处”。
- en: 'If I wanted to create a code that reads inputs, and performs something when
    a particular condition would be verified with the value of these inputs, I would
    write this pseudo-code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想创建一个读取输入并当这些输入的值满足特定条件时执行某些操作的代码，我会编写以下伪代码：
- en: '[PRE18]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What could be annoying here? I cyclically poll new information and have to wait
    for it.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能有什么令人烦恼的地方？我循环地轮询新信息，并必须等待它。
- en: During this step, nothing more is done, but imagine that the input value remains
    the same for a long time. I'd request this value cyclically in the loop, constraining
    the other tasks to wait for nothing.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，没有做更多的事情，但想象一下输入值在很长时间内保持不变。我会在循环中周期性地请求这个值，将其他任务约束为等待。
- en: It sounds like a waste of time. Normally, polling is completely sufficient.
    It has to be written here instead of what other raw programmers could say to you.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是一种浪费时间的行为。通常，轮询是完全足够的。它必须在这里写，而不是其他原始程序员可能会告诉你的内容。
- en: We are creators, we need to make things communicate and work, and we can and
    like to test, don't we? Then, you just learned something important here.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是创造者，我们需要让事物相互沟通和运作，我们可以并且喜欢测试，不是吗？那么，你在这里就学到了一些重要的东西。
- en: Note
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't design complex program workarounds before having tested basic ones.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试基本解决方案之前，不要设计复杂的程序解决方案。
- en: One day, I asked some people to design basic code. Of course, as usual, they
    were connected to the Internet and I just agreed because we are almost all working
    like that today, right? Some people finished before others.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 有一天，我要求一些人设计基本代码。当然，像往常一样，他们连接到了互联网，我只是同意了，因为我们几乎所有人今天都在这样做，对吧？有些人比其他人先完成。
- en: Why? A lot of the people who finished later tried to build a nice multithreaded
    workaround using a messaging system and an external library. The intention was
    good, but in the time we had, they didn't finish and only had a nice Arduino board,
    some wired components, and a code that wasn't working on the table.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么呢？很多后来完成的人试图使用消息系统和外部库构建一个漂亮的多线程解决方案。他们的意图是好的，但在我们拥有的时间里，他们没有完成，只有一块漂亮的 Arduino
    板，一些有线组件，以及一些在桌子上无法工作的代码。
- en: Do you want to know what the others had on their desktop? A polling-based routine
    that was driving their circuits perfectly! Time wasted by this polling-based firmware
    was just totally unimportant considering the circuit.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道其他人桌面上的内容吗？一个基于投票的例行程序，它完美地驱动着他们的电路！考虑到电路，这种基于投票的固件浪费的时间完全不重要。
- en: Note
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Think about hardcore optimizations, but first test your basic code.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到核心优化，但首先测试你的基本代码。
- en: The interrupt handler concept
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中断处理程序的概念
- en: Polling is nice but a bit time consuming, as we just figured out. The best way
    would be to be able to control when the processor would have to deal with inputs
    or outputs in a smarter way.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询很好，但有点耗时，正如我们刚才发现的。最好的方法是有能力以更智能的方式控制处理器何时需要处理输入或输出。
- en: Imagine our previously drawn example with many inputs and outputs. Maybe, this
    is a system that has to react according to a user action. Usually, we can consider
    the user inputs as much slower than the system's ability to answer.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们之前绘制的具有许多输入和输出的例子。也许，这是一个必须根据用户操作做出反应的系统。通常，我们可以认为用户输入的速度比系统的响应能力慢得多。
- en: This means we could create a system that would interrupt the display as soon
    as a particular event would occur, such as a user input. This concept is called
    an *event-based interrupt system*.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以创建一个系统，当特定事件发生时，如用户输入，就会中断显示。这个概念被称为*基于事件的中断系统*。
- en: The *interrupt* is a signal. When a particular event occurs, an interrupt message
    is sent to the processor. Sometimes it is sent externally to the processor (hardware
    interrupt) and sometimes internally (software interrupt).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**中断**是一个信号。当特定事件发生时，会向处理器发送一个中断消息。有时它被发送到处理器外部（硬件中断），有时是内部（软件中断）。'
- en: This is how the disk controller or any external peripheral informs the processor
    of the main unit that it has to provide this or that at the right moment.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是磁盘控制器或任何外部外围设备如何通知主单元处理器在正确的时间提供这个或那个信息。
- en: The interrupt handler is a routine that handles the interrupt by doing something.
    For instance, on the move of the mouse, the computer operating system (commonly
    called the OS) has to redraw the cursor in another place. It would be crazy to
    let the processor itself test each millisecond whether the mouse has moved, because
    the CPU would be running at 100 percent utilization. It seems smarter to have
    a part of the hardware for that purpose. When the mouse movement occurs, it sends
    an interrupt to the processor, and this later redraws the mouse.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 中断处理程序是一种通过执行某些操作来处理中断的例程。例如，当鼠标移动时，计算机操作系统（通常称为OS）必须在另一个位置重新绘制光标。让处理器本身每毫秒都测试鼠标是否移动，这将是疯狂的，因为CPU将运行在100%的利用率。似乎有一个专门的硬件部分来做这件事更明智。当鼠标移动发生时，它会向处理器发送一个中断，然后处理器会重新绘制鼠标。
- en: In the case of our installation with a huge number of inputs and outputs, we
    can consider handling the user inputs with an interrupt. We would have to implement
    what is called an **Interrupt Service Routine** (**ISR**), which is a routine
    called only when a physical world event occurs, that is, when a sensor value changes
    or something like that.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们安装了大量的输入和输出的情况下，我们可以考虑使用中断来处理用户输入。我们不得不实现所谓的**中断服务例程**（**ISR**），这是一个仅在物理世界事件发生时调用的例程，即当传感器值改变或类似情况发生时。
- en: Arduino now provides a nice way to attach an interrupt to a function and it
    is now easy to design an ISR (even if we'll learn to do that a bit later). For
    instance, we can now react to the change of the value of an analog thermal sensor
    using ISR. In this case, we won't permanently poll the analog input, but we'll
    let our low-level Arduino part do that. Only when a value changes (rises or falls)
    depending on how we have attached the interrupt, would this act as a trigger and
    a special function would execute (for instance, the LCD display gets updated with
    the new value).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino现在提供了一种将中断附加到函数的好方法，现在设计ISR（即使我们稍后会学习如何做）变得容易。例如，我们现在可以使用ISR来响应模拟热传感器的值变化。在这种情况下，我们不会永久性地轮询模拟输入，而是让我们的低级Arduino部分来做。只有当值根据我们如何附加中断而变化（上升或下降）时，这才会作为触发器，并执行一个特殊函数（例如，LCD显示屏更新为新值）。
- en: Polling, ISR, and now, we'll evoke threads. Hang on!
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询、ISR，现在，我们将引入线程。请稍等！
- en: What is a thread?
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程是什么？
- en: A thread is a running program flow in which the processor executes a series
    of tasks, generally looping, but not necessarily.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是处理器执行一系列任务（通常循环，但不一定）的运行程序流程。
- en: With only one processor, it is usually done by *time-division multiplexing*,
    which means the processor switches between the different threads according to
    time, that is, context switching.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个处理器时，通常是通过*时分复用*来完成的，这意味着处理器根据时间在不同的线程之间切换，即上下文切换。
- en: '![What is a thread?](img/7584_04_008.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![什么是线程？](img/7584_04_008.jpg)'
- en: Time-division multiplexing provides multitasking
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 时分复用提供了多任务处理
- en: More advanced processors provide the *multithread* feature. These behave as
    if they would be more than just one, each part dealing with a task at the same
    time.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 更先进的处理器提供了*多线程*功能。它们表现得好像它们不仅仅是单个处理器，每个部分同时处理一个任务。
- en: '![What is a thread?](img/7584_04_009.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![什么是线程？](img/7584_04_009.jpg)'
- en: Real multithreading provides tasks happening at the same time
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的多线程提供了同时发生的任务
- en: Without going deeper into computer processors, as we aren't dealing with them
    right now, I can say threads are nice techniques to use in programming to make
    tasks run simultaneously.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在没有处理计算机处理器，所以不深入探讨计算机处理器，我可以告诉你，线程是在编程中用来使任务同时运行的不错的技术。
- en: Unfortunately, the Arduino core doesn't provide multithreading, nor does any
    other microcontroller. Because Arduino is an open source hardware project, some
    hackers have designed a variant of the Arduino board and created some Freeduino
    variant providing *concurrency*, an open source programming language, and an environment
    designed especially with multithreading in mind. This is out of topic here, but
    at least, you now have some leads if you are interested.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Arduino核心不提供多线程，其他任何微控制器也不提供。因为Arduino是一个开源硬件项目，一些黑客已经设计了一种Arduino板的变体，并创建了一些Freeduino变体，提供*并发*，一个开源编程语言，以及一个特别为多线程设计的环境。这超出了我们的话题，但至少，如果你对此感兴趣，你现在有一些线索。
- en: Let's move to the second solution to go beyond the one-task-at-a-time constraint,
    if we need it.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，让我们转向第二个解决方案，以超越一次只处理一个任务的限制。
- en: A real-life polling library example
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个现实生活中的轮询库示例
- en: As introduced in the first line of this section, Marcello's library is a very
    nice one. It provides a polling-based way to launch timed actions.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节第一行所述，Marcello的库是一个非常不错的库。它提供了一种基于轮询的方式来启动定时动作。
- en: Those actions are generally function calls. Functions that behave like that
    are sometimes known as callback functions. These functions are generally called
    as an argument to another piece of code.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动作通常是函数调用。表现像这样的函数有时被称为回调函数。这些函数通常作为另一个代码片段的参数被调用。
- en: Imagine that I want to make our precious LED on the Arduino board blink every
    120 milliseconds. I could use a delay but it would totally stop the program. Not
    smart enough.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想让Arduino板上的宝贵LED每120毫秒闪烁一次。我可以使用延迟，但这将完全停止程序。不够聪明。
- en: I could hack a hardware timer on the board, but that would be overkill. A more
    practical solution that I would use is a callback function with Marcello's `SimpleTimer`
    library. Polling provides a simple and inexpensive way (computationally speaking)
    to deal with applications that are not timer dependent while avoiding the use
    of interrupts that raise more complex problems like hardware timer overconsumption
    (hijacking), which leads to other complicated factors.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在板上黑客一个硬件定时器，但这将是过度杀鸡用牛刀。一个更实用的解决方案是我会使用Marcello的`SimpleTimer`库中的回调函数。轮询提供了一种简单且经济的方式（从计算的角度来看）来处理非定时器依赖的应用程序，同时避免了使用中断，这会引发更复杂的问题，如硬件定时器过度消耗（劫持），这会导致其他复杂因素。
- en: However, if you want to call a function every 5 milliseconds and that function
    needs 9 milliseconds to complete, it will be called every 9 milliseconds. In our
    case here, with 120 milliseconds required to produce a nice and eye-friendly,
    visible blink, we are very safe.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想要每5毫秒调用一个函数，而这个函数需要9毫秒才能完成，它将每9毫秒被调用一次。在我们的例子中，需要120毫秒来产生一个既美观又对眼睛友好的可见闪烁，我们非常安全。
- en: For your information, you don't need to wire anything more than the USB cable
    between the board and your computer. The board-soldered LED on Arduino is wired
    to digital pin 13\. Let's use it.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 仅供参考，你不需要在板子和你的电脑之间连接任何超过USB电缆的东西。Arduino板上焊接的LED连接到了数字引脚13。让我们使用它。
- en: But first, let's download the `SimpleTimer` library for your first use of an
    external library.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们下载`SimpleTimer`库，以便你第一次使用外部库。
- en: Installing an external library
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装外部库
- en: 'Download it from [http://playground.arduino.cc/Code/SimpleTimer](http://playground.arduino.cc/Code/SimpleTimer),
    and extract it somewhere on your computer. You will typically see a folder with
    at least two files inside:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 从[http://playground.arduino.cc/Code/SimpleTimer](http://playground.arduino.cc/Code/SimpleTimer)下载它，并在你的电脑上的某个位置解压。你通常会看到一个包含至少两个文件的文件夹：
- en: A header file (`.h` extension)
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头文件（`.h`扩展名）
- en: A source code file (`.cpp` extension)
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码文件（`.cpp`扩展名）
- en: 'Now, you can see for yourself what they are. Within these files, you have the
    source code. Open your sketchbook folder (see [Chapter 1](ch01.html "Chapter 1. Let''s
    Plug Things"), *Let''s Plug Things*), and move the library folder into the `libraries`
    folder if it exists, else create this special folder:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以亲自看看它们是什么。在这些文件中，你有源代码。打开你的草图簿文件夹（见[第1章](ch01.html "第1章. 让我们连接东西"), *让我们连接东西*），如果存在，将库文件夹移动到`libraries`文件夹中，否则创建这个特殊的文件夹：
- en: '![Installing an external library](img/7584_04_010.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![安装外部库](img/7584_04_010.jpg)'
- en: The header and the source code of SimpleTimer by Marcello Romani
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Marcello Romani编写的SimpleTimer的头文件和源代码
- en: The next time you'll start your Arduino IDE, if you go to **Sketch** | **Import
    Library**, you'll see a new library at the bottom.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 下次你启动Arduino IDE时，如果你去**草图** | **导入库**，你会在底部看到一个新库。
- en: '![Installing an external library](img/7584_04_011.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![安装外部库](img/7584_04_011.jpg)'
- en: In order to include a library, you can click on it in this menu and it will
    write `#include <libname.h>` in your code. You can also type this by yourself.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了包含一个库，你可以点击菜单中的它，它将在你的代码中写入`#include <libname.h>`。你也可以自己输入这个。
- en: Let's test the code
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让我们来测试一下代码
- en: 'Upload this next code and reboot Arduino; I''m going to explain how it works.
    You can also find this code in the `Chapter04`/`simpleTimerBlinker`/ folder:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 上传此代码并重新启动Arduino；我将解释它是如何工作的。你也可以在`Chapter04`/`simpleTimerBlinker`/文件夹中找到此代码：
- en: '[PRE19]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This library is easy to use in our case. You have to include it first, of course.
    Then you have to declare an instance of `SimpleTimer`, which is an object construct,
    by declaring it.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，这个库很容易使用。当然，你首先必须包含它。然后，你必须通过声明来创建`SimpleTimer`的实例，这是一个对象构造。
- en: Then I'm using a `currentLEDState` Boolean value to store the current state
    of the LED explicitly. At last, I declare/define `ledPin` with the number of the
    pin I need (in this case, 13) to make the LED blink. `setup()` is basically done
    with some initialization. The most important one here is the `timer.setInterval()`
    function.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我使用一个`currentLEDState`布尔值来显式存储LED的当前状态。最后，我声明/定义`ledPin`为所需的引脚号（在这种情况下，13）以使LED闪烁。`setup()`基本上是一些初始化。这里最重要的是`timer.setInterval()`函数。
- en: 'Maybe, this is your first method call. The object timer has and embeds some
    methods that we can use. One of them is `setInterval`, which takes two variables:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，这是你的第一次方法调用。对象timer包含一些我们可以使用的方法。其中之一是`setInterval`，它接受两个变量：
- en: A time interval
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个时间间隔
- en: A callback function
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数
- en: We are passing a function name here (a piece of code) to another piece of code.
    This is the structure of a typical callback system.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里传递一个函数名（一段代码）给另一段代码。这是典型回调系统的结构。
- en: '`loop()` is then designed by calling the `run()` method of the timer object
    at each run. This is required to use it. At least, the callback function `blink()`
    is defined with a small trick at the end.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop()`是通过在每次运行时调用计时器对象的`run()`方法来设计的。这是使用它的必要条件。至少，回调函数`blink()`在最后使用了一个小技巧。'
- en: 'The comparison is obvious. I test the current state of the LED, if it is already
    switched on, I switch it off, else I switch it on. Then, I invert the state, which
    is the trick. I''m using the `!` (not) unary operator on this Boolean variable
    in order to flip its value, and I assign the inverted value to the Boolean itself.
    I could have made this too:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 比较很明显。我测试LED的当前状态，如果它已经开启，我就将其关闭，否则将其开启。然后，我反转状态，这就是技巧。我正在使用`!`（非）一元运算符在这个布尔变量上以翻转其值，并将反转后的值赋给布尔变量本身。我本可以这样写：
- en: '[PRE20]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There's really no performance gain, one way or the other. It's simply a personal
    decision; use whichever you prefer.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，无论是哪种方式，都没有性能提升。这只是一个个人决定；使用你喜欢的任何一种。
- en: I'm personally considering the flip as a general action that has to be done
    every time, independent of the state. This is the reason why I proposed that you
    put it outside of the test structure.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人认为翻转是一个必须每次都做的通用动作，与状态无关。这就是为什么我建议你将其放在测试结构之外的原因。
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This completes the first part of this book. I hope you have been able to absorb
    and enjoy these first (huge) steps. If not, you may want to take the time to review
    something you may not have clarity on; it's always worth it to better understand
    what you're doing.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了本书的第一部分。我希望你已经能够吸收并享受这些（庞大）的第一步。如果还没有，你可能想要花些时间去回顾一下你可能不太清楚的地方；更好地理解你所做的事情总是值得的。
- en: We know a bit more about C and C++ programming, at least enough to lead us safely
    through the next two parts. We can now understand the basic tasks of Arduino,
    we can upload our firmware, and we can test them with the basic wiring.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对C和C++编程了解得更多一些，至少足够让我们安全地通过接下来的两部分。我们现在可以理解Arduino的基本任务，我们可以上传我们的固件，并且可以用基本的接线来测试它们。
- en: Now, we'll move a step further into a territory where things are more practical,
    and less theoretical. Prepare yourself to explore new physical worlds, where you
    can make things talk, and communicate with each other, where your computer will
    be able to respond to how you feel and react, and without wires sometimes! Again,
    you may want to take a little time to review something you might still be a little
    hazy on; knowledge is power.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进一步深入到一个更加实用、理论较少的领域。准备好去探索新的物理世界，在那里你可以让事物发声，相互交流，你的电脑将能够对你的感受和反应做出回应，有时甚至不需要电线！再次提醒，你可能想要花一点时间去回顾一下你可能仍然有些模糊的地方；知识就是力量。
- en: The future is now!
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 未来已经到来！
