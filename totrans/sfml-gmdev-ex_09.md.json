["```cpp\nclass C_Movable : public C_Base{\npublic:\n    ...\nprivate:\n    sf::Vector2f m_velocity;\n    float m_velocityMax;\n    sf::Vector2f m_speed;\n    sf::Vector2f m_acceleration;\n    Direction m_direction;\n};\n```", "```cpp\nC_Movable() : C_Base(Component::Movable),\n    m_velocityMax(0.f), m_direction((Direction)0)\n{}\n```", "```cpp\nvoid ReadIn(std::stringstream& l_stream){\n    l_stream >> m_velocityMax >> m_speed.x >> m_speed.y;\n\n    unsigned int dir = 0;\n    l_stream >> dir;\n    m_direction = (Direction)dir;\n}\n```", "```cpp\nvoid AddVelocity(const sf::Vector2f& l_vec){\n  m_velocity += l_vec;\n  if(std::abs(m_velocity.x) > m_velocityMax){\n    m_velocity.x = m_velocityMax *\n      (m_velocity.x / std::abs(m_velocity.x));\n  }\n\n  if(std::abs(m_velocity.y) > m_velocityMax){\n    m_velocity.y = m_velocityMax *\n      (m_velocity.y / std::abs(m_velocity.y));\n  }\n}\n```", "```cpp\nvoid ApplyFriction(const sf::Vector2f& l_vec){\n  if(m_velocity.x != 0 && l_vec.x != 0){\n    if(std::abs(m_velocity.x) - std::abs(l_vec.x) < 0){\n      m_velocity.x = 0;\n    } else {\n      m_velocity.x += (m_velocity.x > 0 ? l_vec.x * -1 : l_vec.x);\n    }\n  }\n\n  if(m_velocity.y != 0 && l_vec.y != 0){\n    if(std::abs(m_velocity.y) - std::abs(l_vec.y) < 0){\n      m_velocity.y = 0;\n    } else {\n      m_velocity.y += (m_velocity.y > 0 ? l_vec.y * -1 : l_vec.y);\n    }\n  }\n}\n```", "```cpp\nvoid Accelerate(const sf::Vector2f& l_vec){ \n    m_acceleration += l_vec;\n}\nvoid Accelerate(float l_x, float l_y){ \n    m_acceleration += sf::Vector2f(l_x,l_y);\n}\n```", "```cpp\nvoid Move(const Direction& l_dir){\n  if(l_dir == Direction::Up){\n    m_acceleration.y -= m_speed.y;\n  } else if (l_dir == Direction::Down){\n    m_acceleration.y += m_speed.y;\n  } else if (l_dir == Direction::Left){\n    m_acceleration.x -= m_speed.x;\n  } else if (l_dir == Direction::Right){\n    m_acceleration.x += m_speed.x;\n  }\n}\n```", "```cpp\nenum class Axis{ x, y };\nclass Map;\nclass S_Movement : public S_Base{\npublic:\n  ...\n  void SetMap(Map* l_gameMap);\nprivate:\n  void StopEntity(const EntityId& l_entity,\n    const Axis& l_axis);\n  void SetDirection(const EntityId& l_entity,\n    const Direction& l_dir);\n  const sf::Vector2f& GetTileFriction(unsigned int l_elevation, \n    unsigned int l_x, unsigned int l_y);\n  void MovementStep(float l_dT, C_Movable* l_movable,\n    C_Position* l_position);\n  Map* m_gameMap;\n};\n```", "```cpp\nS_Movement::S_Movement(SystemManager* l_systemMgr) \n  : S_Base(System::Movement,l_systemMgr)\n{\n  Bitmask req;\n  req.TurnOnBit((unsigned int)Component::Position);\n  req.TurnOnBit((unsigned int)Component::Movable);\n  m_requiredComponents.push_back(req);\n  req.Clear();\n\n  m_systemManager->GetMessageHandler()->\n    Subscribe(EntityMessage::Is_Moving,this);\n\n  m_gameMap = nullptr;\n}\n```", "```cpp\nvoid S_Movement::Update(float l_dT){\n  if (!m_gameMap){ return; }\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  for(auto &entity : m_entities){\n    C_Position* position = entities->\n      GetComponent<C_Position>(entity, Component::Position);\n    C_Movable* movable = entities->\n      GetComponent<C_Movable>(entity, Component::Movable);\n    MovementStep(l_dT, movable, position);\n    position->MoveBy(movable->GetVelocity() * l_dT);\n  }\n}\n```", "```cpp\nvoid S_Movement::MovementStep(float l_dT, C_Movable* l_movable,\n  C_Position* l_position)\n{\n  sf::Vector2f f_coefficient = \n    GetTileFriction(l_position->GetElevation(),\n    floor(l_position->GetPosition().x / Sheet::Tile_Size),\n    floor(l_position->GetPosition().y / Sheet::Tile_Size));\n\n  sf::Vector2f friction(l_movable->GetSpeed().x * f_coefficient.x,\n    l_movable->GetSpeed().y * f_coefficient.y);\n\n  l_movable->AddVelocity(l_movable->GetAcceleration() * l_dT);\n  l_movable->SetAcceleration(sf::Vector2f(0.0f, 0.0f));\n  l_movable->ApplyFriction(friction * l_dT);\n\n  float magnitude = sqrt(\n    (l_movable->GetVelocity().x * l_movable->GetVelocity().x) +\n    (l_movable->GetVelocity().y * l_movable->GetVelocity().y));\n\n  if (magnitude <= l_movable->GetMaxVelocity()){ return; }\n  float max_V = l_movable->GetMaxVelocity();\n  l_movable->SetVelocity(sf::Vector2f(\n    (l_movable->GetVelocity().x / magnitude) * max_V,\n    (l_movable->GetVelocity().y / magnitude) * max_V));\n}\n```", "```cpp\nconst sf::Vector2f& S_Movement::GetTileFriction(\n  unsigned int l_elevation, unsigned int l_x, unsigned int l_y)\n{\n  Tile* t = nullptr;\n  while (!t && l_elevation >= 0){\n    t = m_gameMap->GetTile(l_x, l_y, l_elevation);\n    --l_elevation;\n  }\n\n  return(t ? t->m_properties->m_friction :\n    m_gameMap->GetDefaultTile()->m_friction);\n}\n```", "```cpp\nvoid S_Movement::HandleEvent(const EntityId& l_entity, \n  const EntityEvent& l_event)\n{\n  switch(l_event){\n  case EntityEvent::Colliding_X:\n    StopEntity(l_entity,Axis::x); break;\n  case EntityEvent::Colliding_Y:\n    StopEntity(l_entity, Axis::y); break;\n  case EntityEvent::Moving_Left:\n    SetDirection(l_entity, Direction::Left); break;\n  case EntityEvent::Moving_Right:\n    SetDirection(l_entity, Direction::Right); break;\n  case EntityEvent::Moving_Up:\n    {\n      C_Movable* mov = m_systemManager->GetEntityManager()->\n        GetComponent<C_Movable>(l_entity,Component::Movable);\n      if(mov->GetVelocity().x == 0){\n        SetDirection(l_entity, Direction::Up);\n      }\n    }\n    break;\n  case EntityEvent::Moving_Down:\n    {\n      C_Movable* mov = m_systemManager->GetEntityManager()->\n        GetComponent<C_Movable>(l_entity,Component::Movable);\n      if(mov->GetVelocity().x == 0){\n        SetDirection(l_entity, Direction::Down);\n      }\n    }\n    break;\n  }\n}\n```", "```cpp\nvoid S_Movement::Notify(const Message& l_message){\n  EntityManager* eMgr = m_systemManager->GetEntityManager();\n  EntityMessage m = (EntityMessage)l_message.m_type;\n  switch(m){\n  case EntityMessage::Is_Moving:\n    {\n    if (!HasEntity(l_message.m_receiver)){ return; }\n    C_Movable* movable = eMgr->GetComponent<C_Movable>\n      (l_message.m_receiver, Component::Movable);\n    if (movable->GetVelocity() != sf::Vector2f(0.0f, 0.0f))\n    {\n      return;\n    }\n    m_systemManager->AddEvent(l_message.m_receiver,\n      (EventID)EntityEvent::Became_Idle);\n    }\n    break;\n  }\n}\n```", "```cpp\nvoid S_Movement::StopEntity(const EntityId& l_entity, \n  const Axis& l_axis)\n{\n  C_Movable* movable = m_systemManager->GetEntityManager()->\n    GetComponent<C_Movable>(l_entity,Component::Movable);\n  if(l_axis == Axis::x){\n    movable->SetVelocity(sf::Vector2f(0.f, movable->GetVelocity().y));\n  } else if(l_axis == Axis::y){\n    movable->SetVelocity(sf::Vector2f(movable->GetVelocity().x, 0.f));\n  }\n}\n```", "```cpp\nvoid S_Movement::SetDirection(const EntityId& l_entity, \n  const Direction& l_dir)\n{\n  C_Movable* movable = m_systemManager->GetEntityManager()->\n    GetComponent<C_Movable>(l_entity,Component::Movable);\n  movable->SetDirection(l_dir);\n\n  Message msg((MessageType)EntityMessage::Direction_Changed);\n  msg.m_receiver = l_entity;\n  msg.m_int = (int)l_dir;\n  m_systemManager->GetMessageHandler()->Dispatch(msg);\n}\n```", "```cpp\nvoid S_Movement::SetMap(Map* l_gameMap){ m_gameMap = l_gameMap; }\n```", "```cpp\nvoid State_Game::OnCreate(){\n  ...\n  m_stateMgr->GetContext()->m_systemManager->\n    GetSystem<S_Movement>(SYSTEM_MOVEMENT)->SetMap(m_gameMap);\n}\n```", "```cpp\nenum class EntityState{ Idle, Walking, Attacking, Hurt, Dying };\nclass C_State : public C_Base{\npublic:\n  C_State(): C_Base(Component::State){}\n  void ReadIn(std::stringstream& l_stream){\n    unsigned int state = 0;\n    l_stream >> state;\n    m_state = (EntityState)state;\n  }\n\n  EntityState GetState(){ return m_state; }\n  void SetState(const EntityState& l_state){\n    m_state = l_state;\n  }\nprivate:\n  EntityState m_state;\n};\n```", "```cpp\nS_State::S_State(SystemManager* l_systemMgr)\n  : S_Base(System::State,l_systemMgr)\n{\n  Bitmask req;\n  req.TurnOnBit((unsigned int)Component::State);\n  m_requiredComponents.push_back(req);\n\n  m_systemManager->GetMessageHandler()->\n    Subscribe(EntityMessage::Move,this);\n  m_systemManager->GetMessageHandler()->\n    Subscribe(EntityMessage::Switch_State,this);\n}\n```", "```cpp\nvoid S_State::Update(float l_dT){\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  for(auto &entity : m_entities){\n    C_State* state = entities->\n      GetComponent<C_State>(entity, Component::State);\n    if(state->GetState() == EntityState::Walking){\n      Message msg((MessageType)EntityMessage::Is_Moving);\n      msg.m_receiver = entity;\n      m_systemManager->GetMessageHandler()->Dispatch(msg);\n    }\n  }\n}\n```", "```cpp\nvoid S_State::HandleEvent(const EntityId& l_entity,\n  const EntityEvent& l_event)\n{\n  switch(l_event){\n  case EntityEvent::Became_Idle:\n    ChangeState(l_entity,EntityState::Idle,false);\n    break;\n  }\n}\n```", "```cpp\nvoid S_State::Notify(const Message& l_message){\n  if (!HasEntity(l_message.m_receiver)){ return; }\n  EntityMessage m = (EntityMessage)l_message.m_type;\n  switch(m){\n  case EntityMessage::Move:\n    {\n      C_State* state = m_systemManager->GetEntityManager()->\n        GetComponent<C_State>(l_message.m_receiver,\n        Component::State);\n      if (state->GetState() == EntityState::Dying){ return; }\n      EntityEvent e;\n      if (l_message.m_int == (int)Direction::Up){\n        e = EntityEvent::Moving_Up;\n      } else if (l_message.m_int == (int)Direction::Down){\n        e = EntityEvent::Moving_Down;\n      } else if(l_message.m_int == (int)Direction::Left){\n        e = EntityEvent::Moving_Left;\n      } else if (l_message.m_int == (int)Direction::Right){\n        e = EntityEvent::Moving_Right;\n      }\n\n      m_systemManager->AddEvent(l_message.m_receiver, (EventID)e);\n      ChangeState(l_message.m_receiver,\n        EntityState::Walking,false);\n    }\n    break;\n  case EntityMessage::Switch_State: \n    ChangeState(l_message.m_receiver,\n      (EntityState)l_message.m_int,false);\n    break;\n  }\n}\n```", "```cpp\nvoid S_State::ChangeState(const EntityId& l_entity, \n  const EntityState& l_state, const bool& l_force)\n{\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  C_State* state = entities->\n    GetComponent<C_State>(l_entity, Component::State);\n  if (!l_force && state->GetState() == EntityState::Dying){\n    return;\n  }\n  state->SetState(l_state);\n  Message msg((MessageType)EntityMessage::State_Changed);\n  msg.m_receiver = l_entity;\n  msg.m_int = (int)l_state;\n  m_systemManager->GetMessageHandler()->Dispatch(msg);\n}\n```", "```cpp\nclass C_Controller : public C_Base{\npublic:\n    C_Controller() : C_Base(COMPONENT_CONTROLLER){}\n    void ReadIn(std::stringstream& l_stream){}\n};\n```", "```cpp\nS_Control::S_Control(SystemManager* l_systemMgr)\n  :S_Base(System::Control,l_systemMgr)\n{\n  Bitmask req;\n  req.TurnOnBit((unsigned int)Component::Position);\n  req.TurnOnBit((unsigned int)Component::Movable);\n  req.TurnOnBit((unsigned int)Component::Controller);\n  m_requiredComponents.push_back(req);\n  req.Clear();\n}\n```", "```cpp\nvoid S_Control::HandleEvent(const EntityId& l_entity, \n  const EntityEvent& l_event)\n{\n  switch(l_event){\n  case EntityEvent::Moving_Left:\n    MoveEntity(l_entity,Direction::Left); break;\n  case EntityEvent::Moving_Right:\n    MoveEntity(l_entity, Direction::Right); break;\n  case EntityEvent::Moving_Up:\n    MoveEntity(l_entity, Direction::Up); break;\n  case EntityEvent::Moving_Down:\n    MoveEntity(l_entity, Direction::Down); break;\n  }\n}\n```", "```cpp\nvoid S_Control::MoveEntity(const EntityId& l_entity, \n  const Direction& l_dir)\n{\n  C_Movable* mov = m_systemManager->GetEntityManager()->\n    GetComponent<C_Movable>(l_entity, Component::Movable);\n  mov->Move(l_dir);\n}\n```", "```cpp\nS_SheetAnimation::S_SheetAnimation(SystemManager* l_systemMgr)\n  : S_Base(System::SheetAnimation,l_systemMgr)\n{\n  Bitmask req;\n  req.TurnOnBit((unsigned int)Component::SpriteSheet);\n  req.TurnOnBit((unsigned int)Component::State);\n  m_requiredComponents.push_back(req);\n\n  m_systemManager->GetMessageHandler()->\n    Subscribe(EntityMessage::State_Changed,this);\n}\n```", "```cpp\nvoid S_SheetAnimation::Update(float l_dT){\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  for(auto &entity : m_entities){\n    C_SpriteSheet* sheet = entities->\n      GetComponent<C_SpriteSheet>(entity, Component::SpriteSheet);\n    C_State* state = entities->\n      GetComponent<C_State>(entity, Component::State);\n\n    sheet->GetSpriteSheet()->Update(l_dT);\n\n    const std::string& animName = sheet->\n      GetSpriteSheet()->GetCurrentAnim()->GetName();\n    if(animName == \"Attack\"){\n      if(!sheet->GetSpriteSheet()->GetCurrentAnim()->IsPlaying())\n      {\n        Message msg((MessageType)EntityMessage::Switch_State);\n        msg.m_receiver = entity;\n        msg.m_int = (int)EntityState::Idle;\n        m_systemManager->GetMessageHandler()->Dispatch(msg);\n      } else if(sheet->GetSpriteSheet()->GetCurrentAnim()->IsInAction())\n      {\n        Message msg((MessageType)EntityMessage::Attack_Action);\n        msg.m_sender = entity;\n        m_systemManager->GetMessageHandler()->Dispatch(msg);\n      }\n    } else if(animName == \"Death\" &&\n      !sheet->GetSpriteSheet()->GetCurrentAnim()->IsPlaying())\n    {\n      Message msg((MessageType)EntityMessage::Dead);\n      msg.m_receiver = entity;\n      m_systemManager->GetMessageHandler()->Dispatch(msg);\n    }\n  }\n}\n```", "```cpp\nvoid S_SheetAnimation::Notify(const Message& l_message){\n  if(HasEntity(l_message.m_receiver)){\n    EntityMessage m = (EntityMessage)l_message.m_type;\n    switch(m){\n    case EntityMessage::State_Changed:\n      {\n        EntityState s = (EntityState)l_message.m_int;\n        switch(s){\n        case EntityState::Idle:\n          ChangeAnimation(l_message.m_receiver,\"Idle\",true,true);\n          break;\n        case EntityState::Walking:\n          ChangeAnimation(l_message.m_receiver,\"Walk\",true,true);\n          break;\n        case EntityState::Attacking:\n          ChangeAnimation(l_message.m_receiver,\n            \"Attack\",true,false);\n          break;\n        case EntityState::Hurt: break;\n        case EntityState::Dying:\n          ChangeAnimation(l_message.m_receiver,\n            \"Death\",true,false);\n          break;\n        }\n      }\n      break;\n    }\n  }\n}\n```", "```cpp\nvoid S_SheetAnimation::ChangeAnimation(const EntityId& l_entity, \n  const std::string& l_anim, bool l_play, bool l_loop)\n{\n  C_SpriteSheet* sheet = m_systemManager->GetEntityManager()->\n    GetComponent<C_SpriteSheet>(l_entity,Component::SpriteSheet);\n  sheet->GetSpriteSheet()->SetAnimation(l_anim,l_play,l_loop);\n}\n```", "```cpp\nenum class Origin{ Top_Left, Abs_Centre, Mid_Bottom };\n\nclass C_Collidable : public C_Base{\npublic:\n    ...\nprivate:\n    sf::FloatRect m_AABB;\n    sf::Vector2f m_offset;\n    Origin m_origin;\n\n    bool m_collidingOnX;\n    bool m_collidingOnY;\n};\n```", "```cpp\nC_Collidable(): C_Base(Component::Collidable), \n  m_origin(Origin::Mid_Bottom), m_collidingOnX(false),\n  m_collidingOnY(false)\n{}\n```", "```cpp\nvoid ReadIn(std::stringstream& l_stream){\n    unsigned int origin = 0;\n    l_stream >> m_AABB.width >> m_AABB.height >> m_offset.x>> m_offset.y >> origin;\n    m_origin = (Origin)origin;\n}\n```", "```cpp\nvoid CollideOnX(){ m_collidingOnX = true; }\nvoid CollideOnY(){ m_collidingOnY = true; }\nvoid ResetCollisionFlags(){\n    m_collidingOnX = false;\n    m_collidingOnY = false;\n}\nvoid SetSize(const sf::Vector2f& l_vec){\n    m_AABB.width      = l_vec.x;\n    m_AABB.height     = l_vec.y;\n}\n```", "```cpp\nvoid SetPosition(const sf::Vector2f& l_vec){\n   switch(m_origin){\n   case(Origin::Top_Left):\n      m_AABB.left = l_vec.x + m_offset.x;\n      m_AABB.top  = l_vec.y + m_offset.y;\n      break;\n   case(Origin::Abs_Centre):\n      m_AABB.left = l_vec.x - (m_AABB.width / 2) + m_offset.x;\n      m_AABB.top  = l_vec.y - (m_AABB.height / 2) + m_offset.y;\n      break;\n   case(Origin::Mid_Bottom):\n      m_AABB.left = l_vec.x - (m_AABB.width / 2) + m_offset.x;\n      m_AABB.top  = l_vec.y - m_AABB.height + m_offset.y;\n      break;\n   }\n}\n```", "```cpp\nstruct CollisionElement{\n  CollisionElement(float l_area, TileInfo* l_info,\n    const sf::FloatRect& l_bounds):m_area(l_area),\n    m_tile(l_info), m_tileBounds(l_bounds){}\n  float m_area;\n  TileInfo* m_tile;\n  sf::FloatRect m_tileBounds;\n};\n\nusing Collisions = std::vector<CollisionElement>;\n```", "```cpp\nS_Collision::S_Collision(SystemManager* l_systemMgr) \n  :S_Base(System::Collision,l_systemMgr)\n{\n  Bitmask req;\n  req.TurnOnBit((unsigned int)Component::Position);\n  req.TurnOnBit((unsigned int)Component::Collidable);\n  m_requiredComponents.push_back(req);\n  req.Clear();\n\n  m_gameMap = nullptr;\n}\n```", "```cpp\nvoid S_Collision::SetMap(Map* l_map){ m_gameMap = l_map; }\n```", "```cpp\nvoid S_Collision::Update(float l_dT){\n  if (!m_gameMap){ return; }\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  for(auto &entity : m_entities){\n    C_Position* position = entities->\n      GetComponent<C_Position>(entity, Component::Position);\n    C_Collidable* collidable = entities->\n      GetComponent<C_Collidable>(entity, Component::Collidable);\n    collidable->SetPosition(position->GetPosition());\n    collidable->ResetCollisionFlags();\n    CheckOutOfBounds(position, collidable);\n    MapCollisions(entity, position, collidable);\n  }\n  EntityCollisions();\n}\n```", "```cpp\nvoid S_Collision::CheckOutOfBounds(C_Position* l_pos,\n  C_Collidable* l_col)\n{\n  unsigned int TileSize = m_gameMap->GetTileSize();\n\n  if (l_pos->GetPosition().x < 0){\n    l_pos->SetPosition(0.0f, l_pos->GetPosition().y);\n    l_col->SetPosition(l_pos->GetPosition());\n  } else if (l_pos->GetPosition().x >\n    m_gameMap->GetMapSize().x * TileSize)\n  {\n    l_pos->SetPosition(m_gameMap->GetMapSize().x * TileSize,\n      l_pos->GetPosition().y);\n    l_col->SetPosition(l_pos->GetPosition());\n  }\n\n  if (l_pos->GetPosition().y < 0){\n    l_pos->SetPosition(l_pos->GetPosition().x, 0.0f);\n    l_col->SetPosition(l_pos->GetPosition());\n  } else if (l_pos->GetPosition().y >\n    m_gameMap->GetMapSize().y * TileSize)\n  {\n    l_pos->SetPosition(l_pos->GetPosition().x,\n      m_gameMap->GetMapSize().y * TileSize);\n    l_col->SetPosition(l_pos->GetPosition());\n  }\n}\n```", "```cpp\nvoid S_Collision::MapCollisions(const EntityId& l_entity,\n  C_Position* l_pos, C_Collidable* l_col)\n{\n  unsigned int TileSize = m_gameMap->GetTileSize();\n  Collisions c;\n\n  sf::FloatRect EntityAABB = l_col->GetCollidable();\n  int FromX = floor(EntityAABB.left / TileSize);\n  int ToX = floor((EntityAABB.left + EntityAABB.width)/TileSize);\n  int FromY = floor(EntityAABB.top / TileSize);\n  int ToY = floor((EntityAABB.top + EntityAABB.height)/TileSize);\n  ...\n}\n```", "```cpp\nfor (int x = FromX; x <= ToX; ++x){\n  for (int y = FromY; y <= ToY; ++y){\n    for (int l = 0; l < Sheet::Num_Layers; ++l){\n      Tile* t = m_gameMap->GetTile(x, y, l);\n      if (!t){ continue; }\n      if (!t->m_solid){ continue; }\n      sf::FloatRect TileAABB(x*TileSize, y*TileSize,TileSize, TileSize);\n      sf::FloatRect Intersection;\n      EntityAABB.intersects(TileAABB, Intersection);\n      float S = Intersection.width * Intersection.height;\n      c.emplace_back(S, t->m_properties, TileAABB);\n      break;\n    }\n  }\n}\n```", "```cpp\nif (c.empty()){ return; }\nstd::sort(c.begin(), c.end(),\n  [](CollisionElement& l_1, CollisionElement& l_2){\n    return l_1.m_area > l_2.m_area;\n});\n```", "```cpp\nfor (auto &col : c){\n  EntityAABB = l_col->GetCollidable();\n  if (!EntityAABB.intersects(col.m_tileBounds)){ continue; }\n  float xDiff = (EntityAABB.left + (EntityAABB.width / 2)) -\n    (col.m_tileBounds.left + (col.m_tileBounds.width / 2));\n  float yDiff = (EntityAABB.top + (EntityAABB.height / 2)) -\n    (col.m_tileBounds.top + (col.m_tileBounds.height / 2));\n  float resolve = 0;\n  if (std::abs(xDiff) > std::abs(yDiff)){\n    if (xDiff > 0){\n      resolve = (col.m_tileBounds.left + TileSize) -\n        EntityAABB.left;\n    } else {\n      resolve = -((EntityAABB.left + EntityAABB.width) -\n        col.m_tileBounds.left);\n    }\n    l_pos->MoveBy(resolve, 0);\n    l_col->SetPosition(l_pos->GetPosition());\n    m_systemManager->AddEvent(l_entity,\n      (EventID)EntityEvent::Colliding_X);\n    l_col->CollideOnX();\n  } else {\n    if (yDiff > 0){\n      resolve = (col.m_tileBounds.top + TileSize) -\n        EntityAABB.top;\n    } else {\n      resolve = -((EntityAABB.top + EntityAABB.height) -\n        col.m_tileBounds.top);\n    }\n    l_pos->MoveBy(0, resolve);\n    l_col->SetPosition(l_pos->GetPosition());\n    m_systemManager->AddEvent(l_entity,\n      (EventID)EntityEvent::Colliding_Y);\n    l_col->CollideOnY();\n  }\n}\n```", "```cpp\nvoid S_Collision::EntityCollisions(){\n  EntityManager* entities = m_systemManager->GetEntityManager();\n  for(auto itr = m_entities.begin();\n    itr != m_entities.end(); ++itr)\n  {\n    for(auto itr2 = std::next(itr);\n      itr2 != m_entities.end(); ++itr2){\n      C_Collidable* collidable1 = entities->\n        GetComponent<C_Collidable>(*itr, Component::Collidable);\n      C_Collidable* collidable2 = entities->\n        GetComponent<C_Collidable>(*itr2, Component::Collidable);\n      if(collidable1->GetCollidable().intersects(\n        collidable2->GetCollidable()))\n      {\n        // Entity-on-entity collision!\n      }\n    }\n  }\n}\n```", "```cpp\nvoid State_Game::OnCreate(){\n  ...\n  m_stateMgr->GetContext()->m_systemManager->\n    GetSystem<S_Collision>(SYSTEM_COLLISION)->SetMap(m_gameMap);\n  ...\n}\n```"]