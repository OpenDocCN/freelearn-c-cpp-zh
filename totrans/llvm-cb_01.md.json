["```cpp\n    $ cat testfile.ll\n    define i32 @test1(i32 %A) {\n     %B = add i32 %A, 0\n     ret i32 %B\n    }\n\n    define internal i32 @test(i32 %X, i32 %dead) {\n     ret i32 %X\n    }\n\n    define i32 @caller() {\n     %A = call i32 @test(i32 123, i32 456)\n     ret i32 %A\n    }\n\n    ```", "```cpp\n    $ opt –S –instcombine testfile.ll –o output1.ll\n\n    ```", "```cpp\n    $ cat output1.ll\n    ; ModuleID = 'testfile.ll'\n\n    define i32 @test1(i32 %A) {\n     ret i32 %A\n    }\n\n    define internal i32 @test(i32 %X, i32 %dead) {\n     ret i32 %X\n    }\n\n    define i32 @caller() {\n     %A = call i32 @test(i32 123, i32 456)\n     ret i32 %A\n    }\n\n    ```", "```cpp\n    $ opt –S –deadargelim testfile.ll –o output2.ll\n\n    ```", "```cpp\n    $ cat output2.ll\n    ; ModuleID = testfile.ll'\n\n    define i32 @test1(i32 %A) {\n     %B = add i32 %A, 0\n     ret i32 %B\n    }\n\n    define internal i32 @test(i32 %X) {\n     ret i32 %X\n    }\n\n    define i32 @caller() {\n     %A = call i32 @test(i32 123)\n     ret i32 %A\n    }\n\n    ```", "```cpp\n    -DCMAKE_CROSSCOMPILING=True\n    -DCMAKE_INSTALL_PREFIX= path-where-you-want-the-toolchain(optional)\n    -DLLVM_TABLEGEN=<path-to-host-installed-llvm-toolchain-bin>/llvm-tblgen\n    -DCLANG_TABLEGEN=< path-to-host-installed-llvm-toolchain-bin >/clang-tblgen\n    -DLLVM_DEFAULT_TARGET_TRIPLE=arm-linux-gnueabihf\n    -DLLVM_TARGET_ARCH=ARM\n    -DLLVM_TARGETS_TO_BUILD=ARM\n    -DCMAKE_CXX_FLAGS='-target armv7a-linux-gnueabihf -mcpu=cortex-a9 -I/usr/arm-linux-gnueabihf/include/c++/4.x.x/arm-linux-gnueabihf/ -I/usr/arm-linux-gnueabihf/include/ -mfloat-abi=hard -ccc-gcc-name arm-linux-gnueabihf-gcc'\n\n    ```", "```cpp\n    $ cmake -G Ninja <llvm-source-dir> <options above>\n\n    ```", "```cpp\n    $ CC='clang' CXX='clang++' cmake -G Ninja <source-dir> <options above>\n\n    ```", "```cpp\n    $ ninja\n\n    ```", "```cpp\n    $ ninja install\n\n    ```", "```cpp\n    $ cat multiply.c\n    int mult() {\n    int a =5;\n    int b = 3;\n    int c = a * b;\n    return c;\n    }\n\n    ```", "```cpp\n    $ clang -emit-llvm -S multiply.c -o multiply.ll\n\n    ```", "```cpp\n    $ cat multiply.ll\n    ; ModuleID = 'multiply.c'\n    target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n    target triple = \"x86_64-unknown-linux-gnu\"\n\n    ; Function Attrs: nounwind uwtable\n    define i32 @mult() #0 {\n     %a = alloca i32, align 4\n     %b = alloca i32, align 4\n     %c = alloca i32, align 4\n     store i32 5, i32* %a, align 4\n     store i32 3, i32* %b, align 4\n     %1 = load i32* %a, align 4\n     %2 = load i32* %b, align 4\n     %3 = mul nsw i32 %1, %2\n     store i32 %3, i32* %c, align 4\n     %4 = load i32* %c, align 4\n     ret i32 %4\n    }\n\n    ```", "```cpp\n    $ clang -cc1 -emit-llvm testfile.c -o testfile.ll\n\n    ```", "```cpp\n    $ cat test.ll\n    define i32 @mult(i32 %a, i32 %b) #0 {\n     %1 = mul nsw i32 %a, %b\n     ret i32 %1\n    }\n\n    ```", "```cpp\n    llvm-as test.ll –o test.bc\n\n    ```", "```cpp\n    $ llc test.bc –o test.s\n\n    ```", "```cpp\n    $ cat test.s\n    .text\n    .file \"test.bc\"\n    .globl mult\n    .align 16, 0x90\n    .type mult,@function\n    mult:                                   # @mult\n    .cfi_startproc\n    # BB#0:\n    Pushq  %rbp\n    .Ltmp0:\n    .cfi_def_cfa_offset 16\n    .Ltmp1:\n    .cfi_offset %rbp, -16\n    movq %rsp, %rbp\n    .Ltmp2:\n    .cfi_def_cfa_register %rbp\n    imull %esi, %edi\n    movl %edi, %eax\n    popq %rbp\n    retq\n    .Ltmp3:\n    .size mult, .Ltmp3-mult\n    .cfi_endproc\n\n    ```", "```cpp\n    $ clang -S test.bc -o test.s –fomit-frame-pointer # using the clang front end\n\n    ```", "```cpp\n    $ llvm-dis test.bc –o test.ll\n\n    ```", "```cpp\n    | $ cat test.ll\n    ; ModuleID = 'test.bc'\n\n    define i32 @mult(i32 %a, i32 %b) #0 {\n     %1 = mul nsw i32 %a, %b\n     ret i32 %1\n    }\n\n    ```", "```cpp\n$opt –passname input.ll –o output.ll\n\n```", "```cpp\n    $ cat multiply.c\n    int mult() {\n    int a =5;\n    int b = 3;\n    int c = a * b;\n    return c;\n    }\n\n    ```", "```cpp\n    $ clang -emit-llvm -S multiply.c -o multiply.ll\n    $ cat multiply.ll\n    ; ModuleID = 'multiply.c'\n    target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n    target triple = \"x86_64-unknown-linux-gnu\"\n\n    ; Function Attrs: nounwind uwtable\n    define i32 @mult() #0 {\n     %a = alloca i32, align 4\n     %b = alloca i32, align 4\n     %c = alloca i32, align 4\n     store i32 5, i32* %a, align 4\n     store i32 3, i32* %b, align 4\n     %1 = load i32* %a, align 4\n     %2 = load i32* %b, align 4\n     %3 = mul nsw i32 %1, %2\n     store i32 %3, i32* %c, align 4\n     %4 = load i32* %c, align 4\n     ret i32 %4\n    }\n\n    ```", "```cpp\n    $ opt -mem2reg -S multiply.ll -o multiply1.ll\n    $ cat multiply1.ll\n    ; ModuleID = 'multiply.ll'\n    target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n    target triple = \"x86_64-unknown-linux-gnu\"\n\n    ; Function Attrs: nounwind uwtable\n    define i32 @mult(i32 %a, i32 %b) #0 {\n     %1 = mul nsw i32 %a, %b\n     ret i32 %1\n    }\n\n    ```", "```cpp\n    $ cat test1.c\n    int func(int a) {\n    a = a*2;\n    return a;\n    }\n    $ cat test2.c\n    #include<stdio.h>\n    extern int func(int a);\n    int main() {\n    int num = 5;\n    num = func(num);\n    printf(\"number is %d\\n\", num);\n    return num;\n    }\n\n    ```", "```cpp\n    $ clang -emit-llvm -S test1.c -o test1.ll\n    $ clang -emit-llvm -S test2.c -o test2.ll\n    $ llvm-as test1.ll -o test1.bc\n    $ llvm-as test2.ll -o test2.bc\n\n    ```", "```cpp\n    $ llvm-link test1.bc test2.bc –o output.bc\n\n    ```", "```cpp\n| $ lli output.bc\n number is 10\n\n```", "```cpp\n    $ cat test.c\n    #include<stdio.h>\n    int main() {\n    printf(\"hello world\\n\");\n    return 0; }\n\n    ```", "```cpp\n    $ clang test.c\n    $ ./a.out\n    hello world\n\n    ```", "```cpp\n    $ cat test.c\n    #define MAX 100\n    void func() {\n    int a[MAX];\n    }\n\n    ```", "```cpp\n    $ clang test.c -E\n    # 1 \"test.c\"\n    # 1 \"<built-in>\" 1\n    # 1 \"<built-in>\" 3\n    # 308 \"<built-in>\" 3\n    # 1 \"<command line>\" 1\n    # 1 \"<built-in>\" 2\n    # 1 \"test.c\" 2\n\n    void func() {\n    int a[100];\n    }\n\n    ```", "```cpp\n    | $ clang -cc1 test.c -ast-dump\n    TranslationUnitDecl 0x3f72c50 <<invalid sloc>> <invalid sloc>|-TypedefDecl 0x3f73148 <<invalid sloc>> <invalid sloc> implicit __int128_t '__int128'|-TypedefDecl 0x3f731a8 <<invalid sloc>> <invalid sloc> implicit __uint128_t 'unsigned __int128'|-TypedefDecl 0x3f73518 <<invalid sloc>> <invalid sloc> implicit __builtin_va_list '__va_list_tag [1]'`-FunctionDecl 0x3f735b8 <test.c:3:1, line:5:1> line:3:6 func 'void ()'`-CompoundStmt 0x3f73790 <col:13, line:5:1>`-DeclStmt 0x3f73778 <line:4:1, col:11>`-VarDecl 0x3f73718 <col:1, col:10> col:5 a 'int [100]'\n\n    ```", "```cpp\n    |$ clang test.c -S -emit-llvm -o -\n    |; ModuleID = 'test.c'\n    |target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n    |target triple = \"x86_64-unknown-linux-gnu\"\n    |\n    |; Function Attrs: nounwind uwtable\n    |define void @func() #0 {\n    |%a = alloca [100 x i32], align 16\n    |ret void\n    |}\n\n    ```", "```cpp\n    |$ clang -S test.c -o -\n    |\t.text\n    |\t.file\t\"test.c\"\n    |\t.globl\tfunc\n    |\t.align\t16, 0x90\n    |\t.type\tfunc,@function\n    |func:                                   # @func\n    |\t.cfi_startproc\n    |# BB#0:\n    |\tpushq\t%rbp\n    |.Ltmp0:\n    |\t.cfi_def_cfa_offset 16\n    |.Ltmp1:\n    |\t.cfi_offset %rbp, -16\n    |\tmovq\t%rsp, %rbp\n    |.Ltmp2:\n    |\t.cfi_def_cfa_register %rbp\n    |\tpopq\t%rbp\n    |\tretq\n    |.Ltmp3:\n    |\t.size\tfunc, .Ltmp3-func\n    |\t.cfi_endproc\n\n    ```", "```cpp\n    |$ cat test.go\n    |package main\n    |import \"fmt\"\n    |func main() {\n    | fmt.Println(\"Test Message\")\n    |}\n\n    ```", "```cpp\n    $llgo -dump test.go\n    ; ModuleID = 'main'\n    target datalayout = \"e-p:64:64:64...\"\n    target triple = \"x86_64-unknown-linux\"\n    %0 = type { i8*, i8* }\n    ....\n\n    ```", "```cpp\n    $ cat testprog.c\n    #include<stdio.h>\n    int main() {\n    printf(\"hello world\");\n    }\n\n    ```", "```cpp\n    $ gcc testprog.c -S -O1 -o -\n     .file  \" testprog.c\"\n     .section  .rodata.str1.1,\"aMS\",@progbits,1\n    .LC0:\n     .string  \"Hello world!\"\n     .text\n    .globl main\n     .type  main, @function\n    main:\n     subq  $8, %rsp\n     movl  $.LC0, %edi\n     call  puts\n     movl  $0, %eax\n     addq  $8, %rsp\n     ret\n     .size  main, .-main\n\n    ```", "```cpp\n    $ gcc testprog.c -S -O1 -o - -fplugin=./dragonegg.so\n     .file  \" testprog.c\"\n    # Start of file scope inline assembly\n     .ident  \"GCC: (GNU) 4.5.0 20090928 (experimental) LLVM: 82450:82981\"\n    # End of file scope inline assembly\n\n     .text\n     .align  16\n     .globl  main\n     .type  main,@function\n    main:\n     subq  $8, %rsp\n     movl  $.L.str, %edi\n     call  puts\n     xorl  %eax, %eax\n     addq  $8, %rsp\n     ret\n     .size  main, .-main\n     .type  .L.str,@object\n     .section  .rodata.str1.1,\"aMS\",@progbits,1\n    .L.str:\n     .asciz  \"Hello world!\"\n     .size  .L.str, 13\n\n     .section  .note.GNU-stack,\"\",@progbits\n\n    ```"]