["```cpp\nvoid AGuardTower_CH5_1::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    FVector startLocation = _Arrow->GetComponentLocation();\n    FVector endLocation = _Arrow->GetComponentLocation() +         (_Arrow->GetForwardVector() * _DetectionRange);\n    FHitResult hit;\n    UKismetSystemLibrary::SphereTraceSingle(GetWorld(),startLocation,\n    endLocation,_DetectionRadius, UEngineTypes::\n        ConvertToTraceType(ECC_Visibility), false, {},\n            EDrawDebugTrace::ForOneFrame,hit, true);\n    ACharacter* otherCasted = Cast<AEliteUnit>(hit.GetActor());\n    _EnemySpotted = (otherCasted != nullptr);\n    if (!_EnemySpotted)\n    {\n        if (_RotateForward)\n        {\n            _LightPivot->AddLocalRotation(FRotator(0.0, 0.2, 0.0));\n            if (FMath::IsNearlyEqual                 (_LightPivot->GetRelativeRotation().Yaw, 40.f))\n            {\n                _RotateForward = false;\n            }\n        }\n        else\n        {\n            _LightPivot->AddLocalRotation(FRotator(0.0, -0.2, 0.0));\n            if (FMath::IsNearlyEqual                 (_LightPivot->GetRelativeRotation().Yaw, -40.f))\n            {\n                _RotateForward = true;\n            }\n        }\n    }\n}\n```", "```cpp\nprivate:\n    FOnTimelineFloat onTimeline_Update;\n    FOnTimelineEventStatic onTimeline_Finished;\n    UFUNCTION()\n    void Handle_RotateLight_Update(float val);\n    UFUNCTION()\n    void Handle_RotateLight_Finished();\n    void StartRotation();\n    void StopRotation();\nprotected:\n    UPROPERTY()\n    TObjectPtr<UTimelineComponent> T_RotateLight;\n    UPROPERTY(EditAnywhere)\n    TSoftObjectPointer<UCurveFloat> _Curve;\n```", "```cpp\nT_RotateLight = CreateDefaultSubobject<UTimelineComponent> (TEXT(\"T_RotateLight\"));\nonTimeline_Update.BindUFunction(this, FName(\"Handle_RotateLight_Update\"));\nonTimeline_Finished.BindUFunction(this, FName(\"Handle_RotateLight_Finished\"));\n```", "```cpp\nSuper::BeginPlay();\nif (_Curve == nullptr)\n{\n    return;\n}\nT_RotateLight->AddInterpFloat(_Curve, onTimeline_Update,     FName(\"Alpha\"));\nT_RotateLight->SetTimelineFinishedFunc(onTimeline_Finished);\nT_RotateLight->SetLooping(false);\nT_RotateLight->SetIgnoreTimeDilation(true);\nStartRotation();\n```", "```cpp\nvoid AGuardTower_CH5_3::Handle_RotateLight_Update(float val)\n{\n    _LightPivot->SetRelativeRotation(\n    FRotator(0.f, FMath::Lerp(-40.f, 40.f, val), 0.f));\n}\nvoid AGuardTower_CH5_3::Handle_RotateLight_Finished()\n{\n    _RotateForward = !_RotateForward;\n    StartRotation();\n}\n```", "```cpp\nif (_EnemyUnit != nullptr)\n{\n    return;\n}\n_EnemyUnit = Cast<AEliteUnit>(OtherActor);\nif (_EnemyUnit == nullptr)\n{\n    return;\n}\nFHitResult hit(ForceInit);\nFVector start = _Arrow->GetComponentLocation();\nFVector end = _EnemyUnit->GetActorLocation();\nif (UKismetSystemLibrary::LineTraceSingle(\n        GetWorld(), start, end,\n        UEngineTypes::ConvertToTraceType(ECC_Visibility),\n        false, {_EnemyUnit}, EDrawDebugTrace::ForDuration, hit,\n        true, FLinearColor::Red, FLinearColor::Green, 0.5f))\n{\n    return;\n}\n_EnemySpotted = true;\nStopRotation();\n```", "```cpp\nif(_EnemyUnit != OtherActor) {\n    return;\n}\n    _EnemySpotted = false;\n    _EnemyUnit = nullptr;\n    StartRotation();\n```", "```cpp\n_Sphere = CreateDefaultSubObject<USphereComponent>(TEXT(\"Sphere\"));\n_Sphere->SetupAttachment(_LightMesh);\n_Sphere->OnComponentBeginOverlap.AddDynamic(this, &AguardTower_CH5_3::OnSphereOverlapBegin);\n_Sphere->OnComponentEndOverlap.AddDynamic(this, &AguardTower_CH5_3::OnSphereOverlapEnd);\n```"]