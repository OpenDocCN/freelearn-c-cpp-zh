<html><head></head><body>
<div><h1 class="chapterNumber">9</h1>
<h1 class="chapterTitle" id="_idParaDest-566">Robustness and Performance</h1>
<p class="normal">C++ is often the first choice when it comes to selecting an object-oriented programming language with performance and flexibility as key goals. Modern C++ provides language and library features, such as rvalue references, move semantics, and smart pointers.</p>
<p class="normal">When combined with good practices for exception handling, constant correctness, type-safe conversions, resource allocation, and releasing, C++ enables developers to write better, more robust, and performant code. This chapter’s recipes address all of these essential topics.</p>
<p class="normal">This chapter includes the following recipes:</p>
<ul>
<li class="bulletList">Using exceptions for error handling</li>
<li class="bulletList">Using <code class="inlineCode">noexcept</code> for functions that do not throw exceptions</li>
<li class="bulletList">Ensuring constant correctness for a program</li>
<li class="bulletList">Creating compile-time constant expressions</li>
<li class="bulletList">Creating immediate functions</li>
<li class="bulletList">Optimizing code in constant-evaluated contexts</li>
<li class="bulletList">Using virtual function calls in constant expressions</li>
<li class="bulletList">Performing correct type casts</li>
<li class="bulletList">Implementing move semantics</li>
<li class="bulletList">Using <code class="inlineCode">unique_ptr</code> to uniquely own a memory resource</li>
<li class="bulletList">Using <code class="inlineCode">shared_ptr</code> to share a memory resource</li>
<li class="bulletList">Consistent comparison with the operator <code class="inlineCode">&lt;=&gt;</code></li>
<li class="bulletList">Comparing signed and unsigned integers safely</li>
</ul>
<p class="normal">We will start this chapter with a couple of recipes that deal with exceptions.</p>
<h1 class="heading-1" id="_idParaDest-567">Using exceptions for error handling</h1>
<p class="normal">Exceptions are <a id="_idIndexMarker1111"/>responses to exceptional circumstances that can appear when a program is running. They enable the transfer of the control flow to another part<a id="_idIndexMarker1112"/> of the program. Exceptions are a mechanism for simpler and more robust error handling, as opposed to returning error codes, which could greatly complicate and clutter the code. In this recipe, we will look at some key aspects related to throwing and handling exceptions.</p>
<h2 class="heading-2" id="_idParaDest-568">Getting ready</h2>
<p class="normal">This recipe requires you to have basic knowledge of the mechanisms of throwing exceptions (using the <code class="inlineCode">throw</code> statement) and catching exceptions (using <code class="inlineCode">try...catch</code> blocks). This recipe is focused on good practices around exceptions and not on the details of the exception mechanism in the C++ language.</p>
<h2 class="heading-2" id="_idParaDest-569">How to do it...</h2>
<p class="normal">Use the following practices to deal with exceptions:</p>
<ul>
<li class="bulletList">Throw exceptions by value:
        <pre class="programlisting code"><code class="hljs-code">void throwing_func()
{
  throw std::runtime_error("timed out");
}
void another_throwing_func()
{
  throw std::system_error(
    std::make_error_code(std::errc::timed_out));
}
</code></pre>
</li>
<li class="bulletList">Catch exceptions by reference, or in most cases, by constant reference:
        <pre class="programlisting code"><code class="hljs-code">try
{
  throwing_func(); // throws std::runtime_error
}
catch (std::exception const &amp; e)
{
  std::cout &lt;&lt; e.what() &lt;&lt; '\n';
}
</code></pre>
</li>
<li class="bulletList">Order <code class="inlineCode">catch</code> statements from the most derived class to the base class of the hierarchy<a id="_idIndexMarker1113"/> when catching multiple exceptions from a class hierarchy:
        <pre class="programlisting code"><code class="hljs-code">auto exprint = [](std::exception const &amp; e)
{
  std::cout &lt;&lt; e.what() &lt;&lt; '\n';
};
try
{
  another_throwing_func(); // throws std::system_error
                           // 1st catch statements catches it
}
catch (std::system_error const &amp; e)
{
  exprint(e);
}
catch (std::runtime_error const &amp; e)
{
  exprint(e);
}
catch (std::exception const &amp; e)
{
  exprint(e);
}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">catch(...)</code> to catch all exceptions, regardless of their type:
        <pre class="programlisting code"><code class="hljs-code">try
{
  throwing_func();
}
catch (std::exception const &amp; e)
{
  std::cout &lt;&lt; e.what() &lt;&lt; '\n';
}
catch (...)
{
  std::cout &lt;&lt; "unknown exception" &lt;&lt; '\n';
}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">throw;</code> to rethrow the current exception. This can be used to create a single exception-handling function for multiple exceptions.</li>
<li class="bulletList">Throw the exception object (for example, <code class="inlineCode">throw e;</code>) when you want to hide the <a id="_idIndexMarker1114"/>original location of the exception:
        <pre class="programlisting code"><code class="hljs-code">void handle_exception()
{
  try
  {
    throw; // throw current exception
  }
  catch (const std::logic_error &amp; e)
  { /* ... */ }
  catch (const std::runtime_error &amp; e)
  { /* ... */ }
  catch (const std::exception &amp; e)
  { /* ... */ }
}
try
{
  throwing_func();
}
catch (...)
{
  handle_exception();
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-570">How it works...</h2>
<p class="normal">Most functions have to indicate the success or failure of their execution. This can be achieved in different ways. Here are several possibilities:</p>
<ul>
<li class="bulletList">Return an error code (with a special value for success) to indicate the specific reason for failure:
        <pre class="programlisting code"><code class="hljs-code">int f1(int&amp; result)
{
  if (...) return 1;
  // do something
if (...) return 2;
  // do something more
  result = 42;
  return 0;
}
enum class error_codes {success, error_1, error_2};
error_codes f2(int&amp; result)
{
  if (...) return error_codes::error_1;
  // do something
if (...) return error_codes::error_2;
  // do something more
  result = 42;
  return error_codes::success;
}
</code></pre>
</li>
<li class="bulletList">A variation<a id="_idIndexMarker1115"/> of this is to return a Boolean value to only indicate success or failure:
        <pre class="programlisting code"><code class="hljs-code">bool g(int&amp; result)
{
  if (...) return false;
  // do something
if (...) return false;
  // do something more
  result = 42;
  return true;
}
</code></pre>
</li>
<li class="bulletList">Another alternative is to return invalid objects, null pointers, or empty <code class="inlineCode">std::optional&lt;T&gt;</code> objects:
        <pre class="programlisting code"><code class="hljs-code">std::optional&lt;int&gt; h()
{
  if (...) return {};
  // do something
if (...) return {};
  // do something more
return 42;
}
</code></pre>
</li>
</ul>
<p class="normal">In any case, the return value from the functions should be checked. This can lead to complex, cluttered, and hard-to-read and maintain real-world code. Moreover, the process of checking the return value of a function is always executed, regardless of whether the function was successful or failed. On the other hand, exceptions are thrown and handled only when a function fails, which should happen more rarely than successful <a id="_idIndexMarker1116"/>executions. This can actually lead to faster code than code that returns and tests error codes.</p>
<div><p class="normal">Exceptions and error codes are not mutually exclusive. Exceptions should be used only for transferring the control flow in exceptional situations, not for controlling the data flow in a program.</p>
</div>
<p class="normal">Class constructors are special functions that do not return any value. They are supposed to construct an object, but in the case of failure, they will not be able to indicate this with a return value. Exceptions should be a mechanism that constructors use to indicate failure. Together with the <strong class="keyWord">Resource Acquisition Is Initialization</strong> (<strong class="keyWord">RAII</strong>) idiom, this ensures the safe acquisition and release of resources in all situations. On the other hand, exceptions are not allowed to leave a destructor. When this happens, the program abnormally terminates with a call to <code class="inlineCode">std::terminate()</code>. This is the case for destructors called during stack unwinding, due to the occurrence of another exception. When an exception occurs, the stack is unwound from the point where the exception was thrown to the block where the exception is handled. This process involves the destruction of all local objects in all those stack frames.</p>
<p class="normal">If the destructor of an object that is being destroyed during this process throws an exception, another stack unwinding process should begin, which conflicts with the one already under way. Because of this, the program terminates abnormally.</p>
<div><p class="normal">The rule of thumb for dealing with exceptions in constructors and destructors is as follows:</p>
<ul>
<li class="bulletList">Use exceptions to indicate the errors that occur in constructors.</li>
<li class="bulletList">Do not throw or let exceptions leave destructors.</li>
</ul>
</div>
<p class="normal">It is possible to throw any type of exception. However, in most cases, you should throw temporaries and catch exceptions by constant reference. The reason for catching (constant) references is to avoid slicing the exception types. Let’s consider the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">class simple_error : public std::exception
{
public:
  virtual const char* what() const noexcept override
 {
    return "simple exception";
  }
};
try
{
   throw simple_error{};
}
catch (std::exception e)
{
   std::cout &lt;&lt; e.what() &lt;&lt; '\n'; // prints "Unknown exception"
}
</code></pre>
<p class="normal">We are <a id="_idIndexMarker1117"/>throwing a <code class="inlineCode">simple_error</code> object but catch a <code class="inlineCode">std::exception</code> object by value. This is the base type of <code class="inlineCode">simple_error</code>. The <em class="italic">slicing</em> process occurs, the derived type information is lost, and only the <code class="inlineCode">std::exception</code> part of the object is kept. Therefore, the printed message is <em class="italic">Unknown exception</em> and not <em class="italic">simple exception</em> as one would expect. Using a reference avoids the object slicing.</p>
<p class="normal">The following are some guidelines for exception throwing:</p>
<ul>
<li class="bulletList">Prefer throwing either standard exceptions or your own exceptions derived from <code class="inlineCode">std::exception</code> or another standard exception. The reason for this is that the standard library provides exception classes that are intended to be the first choice for representing exceptions. You should use the ones that are available already and when these are not good enough, build your own based on the standard ones. The main benefits of this are consistency and helping users catch exceptions via the base <code class="inlineCode">std::exception</code> class.</li>
<li class="bulletList">Avoid throwing exceptions of built-in types, such as integers. The reason for this is that numbers carry little information to the user, who must know what it represents, while an object can provide contextual information. For instance, the statement <code class="inlineCode">throw 13;</code> tells nothing to the user, but <code class="inlineCode">throw access_denied_exception{};</code> carries much more implicit information from the class name alone, and with the help of data members, it carries anything useful or necessary about the exceptional situation.</li>
<li class="bulletList">When using a library or framework that provides its own exception hierarchy, prefer throwing exceptions from this hierarchy or your own exceptions derived from it, at least in the parts of the code that are tightly related to it. The main reason for this is to keep the code that utilizes the library APIs consistent.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-571">There’s more...</h2>
<p class="normal">As mentioned in the <a id="_idIndexMarker1118"/>preceding section, when you need to create your own exception types, derive them from one of the standard exceptions that are available, unless you are using a library or framework with its own exception hierarchy. The C++ standard defines several categories of exceptions that need to be considered for this purpose:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">std::logic_error</code> represents an exception that indicates an error in the program logic, such as an invalid argument and an index beyond the bounds of a range. There are various standard-derived classes, such as <code class="inlineCode">std::invalid_argument</code>, <code class="inlineCode">std::out_of_range</code>, and <code class="inlineCode">std::length_error</code>.</li>
<li class="bulletList">The <code class="inlineCode">std::runtime_error</code> represents an exception that indicates an error beyond the scope of the program or that cannot be predicted due to various factors, including external ones, such as overflows and underflows or operating system errors. The C++ standard also provides several derived classes from <code class="inlineCode">std::runtime_error</code>, including <code class="inlineCode">std::overflow_error</code>, <code class="inlineCode">std::underflow_error</code>, <code class="inlineCode">std::system_error</code>, and <code class="inlineCode">std::format_error</code> in C++20.</li>
<li class="bulletList">Exceptions prefixed with <code class="inlineCode">bad_</code>, such as <code class="inlineCode">std::bad_alloc</code>, <code class="inlineCode">std::bad_cast</code>, and <code class="inlineCode">std::bad_function_call</code>, represent various errors in a program, such as failure to allocate memory and failure to dynamically cast or make a function call.</li>
</ul>
<p class="normal">The base class for all these exceptions is <code class="inlineCode">std::exception</code>. It has a non-throwing virtual method called <code class="inlineCode">what()</code> that returns a pointer to an array of characters representing the description of the error.</p>
<p class="normal">When you need to derive custom exceptions from a standard exception, use the appropriate category, such as logical or runtime error. If none of these categories is suitable, then you can derive directly from <code class="inlineCode">std::exception</code>. The following is a list of possible solutions you can use to derive from a standard exception:</p>
<ul>
<li class="bulletList">If you need to derive from <code class="inlineCode">std::exception</code>, then override the virtual method <code class="inlineCode">what()</code> to provide a description of the error:
        <pre class="programlisting code"><code class="hljs-code">class simple_error : public std::exception
{
public:
  virtual const char* what() const noexcept override
 {
    return "simple exception";
  }
};
</code></pre>
</li>
<li class="bulletList">If you<a id="_idIndexMarker1119"/> derive from <code class="inlineCode">std::logic_error</code> or <code class="inlineCode">std::runtime_error</code> and you only need to provide a static description that does not depend on runtime data, then pass the description text to the base class constructor:
        <pre class="programlisting code"><code class="hljs-code">class another_logic_error : public std::logic_error
{
public:
  another_logic_error():
    std::logic_error("simple logic exception")
  {}
};
</code></pre>
</li>
<li class="bulletList">If you derive from <code class="inlineCode">std::logic_error</code> or <code class="inlineCode">std::runtime_error</code> but the description message depends on runtime data, provide a constructor with parameters and use them to build the description message. You can either pass the description message to the base class constructor or return it from the overridden <code class="inlineCode">what()</code> method:
        <pre class="programlisting code"><code class="hljs-code">class advanced_error : public std::runtime_error
{
  int error_code;
  std::string make_message(int const e)
 {
    std::stringstream ss;
    ss &lt;&lt; "error with code " &lt;&lt; e;
    return ss.str();
  }
public:
  advanced_error(int const e) :
    std::runtime_error(make_message(e).c_str()),error_code(e)
  {
  }
  int error() const noexcept
 {
    return error_code;
  }
};
</code></pre>
</li>
</ul>
<p class="normal">For a complete <a id="_idIndexMarker1120"/>list of the standard exception classes, you can visit the <a href="https://en.cppreference.com/w/cpp/error/exception">https://en.cppreference.com/w/cpp/error/exception</a> page.</p>
<h2 class="heading-2" id="_idParaDest-572">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 8</em>, <em class="italic">Handling exceptions from thread functions</em>, to understand how to handle exceptions thrown in a worker thread from the main thread or the thread where it was joined</li>
<li class="bulletList"><em class="italic">Using noexcept for functions that do not throw exceptions</em>, to see how to inform the compiler that a function should not throw exceptions</li>
</ul>
<h1 class="heading-1" id="_idParaDest-573">Using noexcept for functions that do not throw exceptions</h1>
<p class="normal">Exception specification<a id="_idIndexMarker1121"/> is a language feature that can enable performance improvements, but on the other hand, when done incorrectly, it can abnormally terminate the program. The exception specification from C++03, which allowed you to indicate what types of exceptions a function could throw, was deprecated in C++11 and removed in C++17. It was replaced with the C++11 <code class="inlineCode">noexcept</code> specifier. Moreover, the use of the <code class="inlineCode">throw()</code> specifier to indicate that a function throws, without indicating what exception types have<a id="_idIndexMarker1122"/> also been deprecated in C++17 and completely removed in C++20. The <code class="inlineCode">noexcept</code> specifier only allows you to indicate that a function does not throw exceptions (as opposed to the old <code class="inlineCode">throw</code> specifier, which could indicate the list of types a function could throw). This recipe provides information about the modern exception specifications in C++, as well as guidelines on when to use them.</p>
<h2 class="heading-2" id="_idParaDest-574">How to do it...</h2>
<p class="normal">Use the <a id="_idIndexMarker1123"/>following constructs to specify or query exception specifications:</p>
<ul>
<li class="bulletList">Use <code class="inlineCode">noexcept</code> in a function declaration to indicate that the function is not throwing any exception:
        <pre class="programlisting code"><code class="hljs-code">void func_no_throw() noexcept
{
}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">noexcept(expr)</code> in a function declaration, such as template metaprogramming, to indicate that the function may or may not throw an exception based on a condition that evaluates to <code class="inlineCode">bool</code>:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
T generic_func_1()
 noexcept(std::is_nothrow_constructible_v&lt;T&gt;)
{
  return T{};
}
</code></pre>
</li>
<li class="bulletList">Use the <code class="inlineCode">noexcept</code> operator at compile time to check whether an expression is declared to not throw any exception:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
T generic_func_2() noexcept(noexcept(T{}))
{
  return T{};
}
template &lt;typename F, typename A&gt;
auto func(F&amp;&amp; f, A&amp;&amp; arg) noexcept
{
  static_assert(noexcept(f(arg)), "F is throwing!");
  return f(arg);
}
std::cout &lt;&lt; noexcept(generic_func_2&lt;int&gt;) &lt;&lt; '\n';
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-575">How it works...</h2>
<p class="normal">As of C++17, exception specification<a id="_idIndexMarker1124"/> is part of the function type, but not part of the function signature; it may appear as part of any function <a id="_idIndexMarker1125"/>declarator. Because exception specification is not part of the function signature, two function signatures cannot differ only in the exception specification. </p>
<p class="normal">Prior to C++17, exception specification was not part of the function type and could only appear as part of lambda declarators or top-level function declarators; they could not appear even in <code class="inlineCode">typedef</code> or type alias declarations. Further discussions on exception specification refer solely to the C++17 standard.</p>
<p class="normal">There are several ways in which the process of throwing an exception can be specified:</p>
<ul>
<li class="bulletList">If no exception specification is present, then the function could potentially throw exceptions.</li>
<li class="bulletList"><code class="inlineCode">noexcept(false)</code> is equivalent to no exception specification.</li>
<li class="bulletList"><code class="inlineCode">noexcept(true)</code> and <code class="inlineCode">noexcept</code> indicate that a function does not throw any exception.</li>
<li class="bulletList"><code class="inlineCode">throw()</code> was equivalent to <code class="inlineCode">noexcept(true)</code> but was deprecated in C++17 and removed altogether in C++20.</li>
</ul>
<div><p class="normal">Using exception specifications must be done with care because if an exception (either thrown directly or from another function that is called) leaves a function marked as non-throwing, the program is terminated immediately and abnormally with a call to <code class="inlineCode">std::terminate()</code>.</p>
</div>
<p class="normal">Pointers to the functions that do not throw exceptions can be implicitly converted to pointers to functions that may throw exceptions, but not vice versa. On the other hand, if a virtual function has a non-throwing exception specification, this indicates that all the declarations of all the overrides must preserve this specification unless an overridden function is declared as deleted.</p>
<p class="normal">At compile time, it is possible to check whether a function is declared to be non-throwing or not using the operator <code class="inlineCode">noexcept</code>. This operator takes an expression and returns <code class="inlineCode">true</code> if the expression is declared as either non-throwing or <code class="inlineCode">false</code>. It does not evaluate the expression it checks.</p>
<p class="normal">The <code class="inlineCode">noexcept</code> operator, along with the <code class="inlineCode">noexcept</code> specifier, is particularly useful in template metaprogramming to indicate whether a function may throw exceptions for some types. It is also used with <code class="inlineCode">static_assert</code> declarations to check whether an expression breaks the non-throwing guarantee of a function, as seen in the examples in the <em class="italic">How to do it...</em> section.</p>
<p class="normal">The <a id="_idIndexMarker1126"/>following code provides more examples of how the <code class="inlineCode">noexcept</code> operator works:</p>
<pre class="programlisting code"><code class="hljs-code">int double_it(int const i) noexcept
{
  return i + i;
}
int half_it(int const i)
{
  throw std::runtime_error("not implemented!");
}
struct foo
{
  foo() {}
};
std::cout &lt;&lt; std::boolalpha
  &lt;&lt; noexcept(func_no_throw()) &lt;&lt;  '\n' // true
  &lt;&lt; noexcept(generic_func_1&lt;int&gt;()) &lt;&lt;  '\n' // true
  &lt;&lt; noexcept(generic_func_1&lt;std::string&gt;()) &lt;&lt;  '\n'// true
  &lt;&lt; noexcept(generic_func_2&lt;int&gt;()) &lt;&lt; '\n' // true
  &lt;&lt; noexcept(generic_func_2&lt;std::string&gt;()) &lt;&lt;  '\n'// true
  &lt;&lt; noexcept(generic_func_2&lt;foo&gt;()) &lt;&lt;  '\n' // false
  &lt;&lt; noexcept(double_it(42)) &lt;&lt;  '\n' // true
  &lt;&lt; noexcept(half_it(42)) &lt;&lt;  '\n' // false
  &lt;&lt; noexcept(func(double_it, 42)) &lt;&lt;  '\n' // true
  &lt;&lt; noexcept(func(half_it, 42)) &lt;&lt; '\n';            // true
</code></pre>
<p class="normal">It is important<a id="_idIndexMarker1127"/> to note that the <code class="inlineCode">noexcept</code> specifier does not provide compile-time checking for exceptions. It only represents a way for users to inform the compiler that a function is not expected to throw exceptions. The compiler can use this to enable certain optimizations. An example is the <code class="inlineCode">std::vector</code>, which moves elements if their move constructor is <code class="inlineCode">noexcept</code> and copies them otherwise.</p>
<h2 class="heading-2" id="_idParaDest-576">There’s more...</h2>
<p class="normal">As mentioned earlier, a function<a id="_idIndexMarker1128"/> declared with the <code class="inlineCode">noexcept</code> specifier that exits due to an exception causes the program to terminate abnormally. Therefore, the <code class="inlineCode">noexcept</code> specifier should be used with caution. Its presence can enable code optimizations, which help increase performance while preserving the <em class="italic">strong exception guarantee</em>. An example of this is library containers.</p>
<div><p class="normal">The C++ language provides several levels of exception guarantees:</p>
<ul>
<li class="bulletList">The first level, <em class="italic">no exception guarantees</em>, does not provide any guarantees. If an exception occurs, there is nothing to indicate whether the program is left in a valid state. Resources could be leaked, memory can be corrupted, and object invariants may be broken.</li>
<li class="bulletList">The <em class="italic">basic exception guarantee</em> is the simplest level of guarantee, which ensures that after an exception is thrown, objects are left in a consistent and usable state, no resource leaks occur, and invariants are preserved.</li>
<li class="bulletList">The <em class="italic">strong exception guarantee</em> specifies that either an operation is completed successfully, or that it is completed with an exception that leaves the program in the same state it was in before the operation started. This ensures commit-or-rollback semantics.</li>
<li class="bulletList">The <em class="italic">no-throw exception guarantee</em> is actually the strongest of them all and specifies that an operation is guaranteed to not throw any exception and to complete successfully.</li>
</ul>
</div>
<p class="normal">Many standard containers provide some of their operations with a strong exception guarantee. An example is vector’s <code class="inlineCode">push_back()</code> method. This method could be optimized by using the move constructor or move assignment operator instead of the copy constructor or copy assignment operator of the vector’s element type. However, in order to preserve its strong exception guarantee, this can only be done if the move constructor or assignment operator does not throw exceptions. If either does, then the copy constructor or the assignment operator must be used instead.</p>
<p class="normal">The <code class="inlineCode">std::move_if_noexcept()</code> utility function does this if the move constructor of its type argument is marked with <code class="inlineCode">noexcept</code>. The ability to indicate that move constructors or move assignment operators do not throw exceptions is probably the most important scenario where <code class="inlineCode">noexcept</code> is used.</p>
<p class="normal">Consider the following<a id="_idIndexMarker1129"/> rules for the exception specification:</p>
<ul>
<li class="bulletList">If a function could potentially throw an exception, then do not use any exception specifier.</li>
<li class="bulletList">Mark only those functions with <code class="inlineCode">noexcept</code> that are guaranteed not to throw an exception.</li>
<li class="bulletList">Mark only those functions with <code class="inlineCode">noexcept(expression)</code> that could potentially throw exceptions based on a condition.</li>
</ul>
<p class="normal">These rules are important because, as already noted previously, throwing an exception from a <code class="inlineCode">noexcept</code> function will immediately terminate the program with a call to <code class="inlineCode">std::terminate()</code>.</p>
<h2 class="heading-2" id="_idParaDest-577">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using exceptions for error handling</em>, to explore the best practices for using exceptions in the C++ language</li>
</ul>
<h1 class="heading-1" id="_idParaDest-578">Ensuring constant correctness for a program</h1>
<p class="normal">Although<a id="_idIndexMarker1130"/> there is no formal definition, constant correctness means objects that are not supposed to be modified (are immutable) remain<a id="_idIndexMarker1131"/> unmodified. As a developer, you can enforce this by using the <code class="inlineCode">const</code> keyword for declaring parameters, variables, and member functions. In this recipe, we will explore the benefits of constant correctness and how to achieve it.</p>
<h2 class="heading-2" id="_idParaDest-579">How to do it...</h2>
<p class="normal">To ensure constant correctness for a program, you should always declare the following as constants:</p>
<ul>
<li class="bulletList">Parameters to functions that are not supposed to be modified within the function:
        <pre class="programlisting code"><code class="hljs-code">struct session {};
session connect(std::string const &amp; uri,
 int const timeout = 2000)
{
  /* do something */
return session { /* ... */ };
}
</code></pre>
</li>
<li class="bulletList">Class data members that do not change:
        <pre class="programlisting code"><code class="hljs-code">class user_settings
{
public:
  int const min_update_interval = 15;
  /* other members */
};
</code></pre>
</li>
<li class="bulletList">Class member<a id="_idIndexMarker1132"/> functions that do not <a id="_idIndexMarker1133"/>modify the object state, as seen from the outside:
        <pre class="programlisting code"><code class="hljs-code">class user_settings
{
  bool show_online;
public:
  bool can_show_online() const {return show_online;}
  /* other members */
};
</code></pre>
</li>
<li class="bulletList">Function locals whose values do not change throughout their lifetime:
        <pre class="programlisting code"><code class="hljs-code">user_settings get_user_settings()
{
  return user_settings {};
}
void update()
{
  user_settings const us = get_user_settings();
  if(us.can_show_online()) { /* do something */ }
  /* do more */
}
</code></pre>
</li>
<li class="bulletList">References that should be bound to a temporary (an rvalue) in order to extend the lifetime of the temporary to the lifetime of the (constant) reference:
        <pre class="programlisting code"><code class="hljs-code">std::string greetings()
{
   return "Hello, World!";
}
const std::string &amp; s = greetings(); // must use const
std::cout &lt;&lt; s &lt;&lt; std::endl;
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-580">How it works...</h2>
<p class="normal">Declaring <a id="_idIndexMarker1134"/>objects and member functions as <a id="_idIndexMarker1135"/>constant has several important benefits:</p>
<ul>
<li class="bulletList">You prevent both accidental and intentional changes of the object, which, in some cases, can result in incorrect program behavior.</li>
<li class="bulletList">You enable the compiler to perform better optimizations.</li>
<li class="bulletList">You document the semantics of the code for other users.</li>
</ul>
<div><p class="normal">Constant correctness is not a matter of personal style but a core principle that should guide C++ development.</p>
</div>
<p class="normal">Unfortunately, the importance of constant correctness has not been, and is still not, stressed enough in books, C++ communities, and working environments. But the rule of thumb is that everything that is not supposed to change should be declared as constant. This should be done all the time and not only at later stages of development, when you might need to clean up and refactor the code.</p>
<p class="normal">When you declare a parameter or variable as constant, you can either put the <code class="inlineCode">const</code> keyword before the type (<code class="inlineCode">const T c</code>) or after the type (<code class="inlineCode">T const c</code>). These two are equivalent, but regardless of which of the two styles you use, the reading of the declaration must be done from the right-hand side. <code class="inlineCode">const T c</code> is read as <em class="italic">c is a T that is constant</em> and <code class="inlineCode">T const c</code> as <em class="italic">c is a constant T</em>. This gets a little bit more complicated with pointers. The following table presents various pointer declarations and their meanings:</p>
<table class="table-container" id="table001-6">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Expression</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">T* p</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">p</code> is a non-constant pointer to a non-constant <code class="inlineCode">T</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">const T* p</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">p</code> is a non-constant pointer to a <code class="inlineCode">T</code> that is constant.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">T const * p</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">p</code> is a non-constant pointer to a constant <code class="inlineCode">T</code> (same as the prior point).</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">const T * const p</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">p</code> is a constant pointer to a <code class="inlineCode">T</code> that is constant.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">T const * const p</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">p</code> is a constant pointer to a constant <code class="inlineCode">T</code> (same as the prior point).</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">T** p</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">p</code> is a non-constant pointer to a non-constant pointer to a non-constant <code class="inlineCode">T</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">const T** p</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">p</code> is a non-constant pointer to a non-constant pointer to a constant <code class="inlineCode">T</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">T const ** p</code></p>
</td>
<td class="table-cell">
<p class="normal">Same as <code class="inlineCode">const T** p</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">const T* const * p</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">p</code> is a non-constant pointer to a constant pointer, which is a constant <code class="inlineCode">T</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">T const * const * p</code></p>
</td>
<td class="table-cell">
<p class="normal">Same as <code class="inlineCode">const T* const * p</code>.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 9.1: Example of pointer declarations and their meaning</p>
<div><p class="normal">Placing the <code class="inlineCode">const</code> keyword after the type is more natural because it is consistent with the direction the syntax is interpreted, from right to left. For this reason, all the examples in this book use this style.</p>
</div>
<p class="normal">When it <a id="_idIndexMarker1136"/>comes to references, the situation is similar: <code class="inlineCode">const T &amp; c</code> and <code class="inlineCode">T const &amp; c</code> are equivalent, which means <em class="italic">c is a reference to a constant T</em>. However, <code class="inlineCode">T const &amp; const c</code>, which would mean that <em class="italic">c is a constant reference to a constant T</em>, does not make sense because references—aliases of a variable—are<a id="_idIndexMarker1137"/> implicitly constant in the sense that they cannot be modified to represent an alias to another variable.</p>
<p class="normal">A non-constant pointer to a non-constant object, that is, <code class="inlineCode">T*</code>, can be implicitly converted to a non-constant pointer to a constant object, <code class="inlineCode">T const *</code>. However, <code class="inlineCode">T**</code> cannot be implicitly converted to <code class="inlineCode">T const **</code> (which is the same with <code class="inlineCode">const T**</code>). This is because this could lead to constant objects being modified through a pointer to a non-constant object, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">int const c = 42;
int* x;
int const ** p = &amp;x; // this is an actual error
*p = &amp;c;
*x = 0;              // this modifies c
</code></pre>
<p class="normal">If an object is <a id="_idIndexMarker1138"/>constant, only the constant functions of its class can be invoked. However, declaring a member function as constant does not mean that the function can only be called on constant objects; it could also mean that the function does not modify the state of the object, as seen from the outside. This is a key aspect, but it is usually misunderstood. A class has an internal state that it can expose to its clients through its public interface.</p>
<p class="normal">However, not<a id="_idIndexMarker1139"/> all the internal states might be exposed, and what is visible from the public interface might not have a direct representation in the internal state. (If you model order lines and have the item quantity and item selling price fields in the internal representation, then you might have a public method that exposes the order line amount by multiplying the quantity by the price.) Therefore, the state of an object, as visible from its public interface, is a logical state. Defining a method as constant is a statement that ensures the function does not alter the logical state. However, the compiler prevents you from modifying data members using such methods. To avoid this problem, data members that are supposed to be modified from constant methods should be declared <code class="inlineCode">mutable</code>.</p>
<p class="normal">In the following example, <code class="inlineCode">computation</code> is a class with the <code class="inlineCode">compute()</code> method, which performs a long-running computation operation. Because it does not affect the logical state of the object, this function is declared constant. However, to avoid computing the result of the same input again, the computed values are stored in a cache. To be able to modify the cache from the constant function, it is declared <code class="inlineCode">mutable</code>:</p>
<pre class="programlisting code"><code class="hljs-code">class computation
{
  double compute_value(double const input) const
 {
    /* long running operation */
return input + 42;
  }
  mutable std::map&lt;double, double&gt; cache;
public:
  double compute(double const input) const
 {
    auto it = cache.find(input);
    if(it != cache.end()) return it-&gt;second;
    auto result = compute_value(input);
    cache[input] = result;
    return result;
  }
};
</code></pre>
<p class="normal">A similar<a id="_idIndexMarker1140"/> situation is represented by the following class, which implements a thread-safe container. Access to shared internal data is protected with <code class="inlineCode">mutex</code>. The class provides methods such as adding and removing values, and also <a id="_idIndexMarker1141"/>methods such as <code class="inlineCode">contains()</code>, which indicate whether an item exists in the container. Because this member function is not intended to modify the logical state of the object, it is declared constant. However, access to the shared internal state must be protected with the mutex. In order to lock and unlock the mutex, both mutable operations (that modify the state of the object) and the mutex must be declared <code class="inlineCode">mutable</code>:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
class container
{
  std::vector&lt;T&gt;     data;
  mutable std::mutex mt;
public:
  void add(T const &amp; value)
 {
    std::lock_guard&lt;std::mutex&gt; lock(mt);
    data.push_back(value);
  }
  bool contains(T const &amp; value) const
 {
    std::lock_guard&lt;std::mutex&gt; lock(mt);
    return std::find(std::begin(data), std::end(data), value)
           != std::end(data);
  }
};
</code></pre>
<p class="normal">The <code class="inlineCode">mutable</code> specifier allows us to modify the class member on which it was used, even if the containing object is declared <code class="inlineCode">const</code>. This is the case of the <code class="inlineCode">mt</code> member of the <code class="inlineCode">std::mutex</code> type, which is modified even within the <code class="inlineCode">contains()</code> method, which is declared <code class="inlineCode">const</code>.</p>
<p class="normal">Sometimes, a <a id="_idIndexMarker1142"/>method or an operator is overloaded to <a id="_idIndexMarker1143"/>have both constant and non-constant versions. This is often the case with the subscript operator or methods that provide direct access to the internal state. The reason for this is that the method is supposed to be available for both constant and non-constant objects. The behavior should be different, though: for non-constant objects, the method should allow the client to modify the data it provides access to, but for constant objects, it should not. Therefore, the non-constant subscript operator returns a reference to a non-constant object, and the constant subscript operator returns a reference to a constant object:</p>
<pre class="programlisting code"><code class="hljs-code">class contact {};
class addressbook
{
  std::vector&lt;contact&gt; contacts;
public:
  contact&amp; operator[](size_t const index);
  contact const &amp; operator[](size_t const index) const;
};
</code></pre>
<div><p class="normal">It should be noted that, if a member function is constant, even if an object is constant, the data that’s returned by this member function may not be constant.</p>
</div>
<p class="normal">An important use case for the use of <code class="inlineCode">const</code> is to define references to temporary objects, as shown in the last bullet in the <em class="italic">How to do it…</em> section. A temporary is an rvalue and a non-<code class="inlineCode">const</code> lvalue reference cannot be bound to an rvalue. However, it is possible by making the lvalue reference <code class="inlineCode">const</code>. This has the effect of extending the lifetime of the temporary object to the lifetime of the constant reference. However, this only works for stack-based references but not for references that are members of objects.</p>
<h2 class="heading-2" id="_idParaDest-581">There’s more...</h2>
<p class="normal">The <code class="inlineCode">const</code> qualifier of an object can be removed with a <code class="inlineCode">const_cast</code> conversion, but this should only be used when you know that the object was not declared constant. You can read more about this in the <em class="italic">Performing correct type casts</em> recipe.</p>
<h2 class="heading-2" id="_idParaDest-582">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Creating compile-time constant expressions</em>, to learn about the <code class="inlineCode">constexpr</code> specifier and how to define variables and functions that can be evaluated at compile time</li>
<li class="bulletList"><em class="italic">Creating immediate functions</em>, to learn about the C++20 <code class="inlineCode">consteval</code> specifier, which is used to define functions that are guaranteed to be evaluated at compile time</li>
<li class="bulletList"><em class="italic">Performing correct type casts</em>, to learn about the best practices for performing correct casts in the C++ language</li>
</ul>
<h1 class="heading-1" id="_idParaDest-583">Creating compile-time constant expressions</h1>
<p class="normal">The <a id="_idIndexMarker1144"/>possibility to evaluate expressions at compile time improves runtime execution because there is less code to run and the compiler can perform additional optimizations. Compile-time constants can be not only literals (such as a number or string), but also the result of a function’s execution. If all the input values of a function (regardless of whether they are arguments, locals, or global variables) are known at compile time, the compiler can execute the function and have the result available at compile time. This is what generalized the constant expressions that were introduced in C++11, which were relaxed in C++14 and even further in C++20. The keyword <code class="inlineCode">constexpr</code> (short for <em class="italic">constant expression</em>) can be used to declare compile-time constant objects and functions. We have seen this in several examples in the previous chapters. Now, it’s time to learn how it actually works.</p>
<h2 class="heading-2" id="_idParaDest-584">Getting ready</h2>
<p class="normal">The way generalized constant expressions work has been relaxed in C++14 and C++20, but this introduced some breaking changes to C++11. For instance, in C++11, a <code class="inlineCode">constexpr</code> function was implicitly <code class="inlineCode">const</code>, but this is no longer the case in C++14. In this recipe, we will discuss generalized constant expressions, as defined in C++20.</p>
<h2 class="heading-2" id="_idParaDest-585">How to do it...</h2>
<p class="normal">Use <a id="_idIndexMarker1145"/>the <code class="inlineCode">constexpr</code> keyword when you want to:</p>
<ul>
<li class="bulletList">Define non-member functions that can be evaluated at compile time:
        <pre class="programlisting code"><code class="hljs-code">constexpr unsigned int factorial(unsigned int const n)
{
  return n &gt; 1 ? n * factorial(n-1) : 1;
}
</code></pre>
</li>
<li class="bulletList">Define constructors that can be executed at compile time to initialize <code class="inlineCode">constexpr</code> objects and member functions to be invoked during this period:
        <pre class="programlisting code"><code class="hljs-code">class point3d
{
  double const x_;
  double const y_;
  double const z_;
public:
  constexpr point3d(double const x = 0,
 double const y = 0,
 double const z = 0)
    :x_{x}, y_{y}, z_{z}
  {}
  constexpr double get_x() const {return x_;}
  constexpr double get_y() const {return y_;}
  constexpr double get_z() const {return z_;}
};
</code></pre>
</li>
<li class="bulletList">Define variables that can have their values evaluated at compile time:
        <pre class="programlisting code"><code class="hljs-code">constexpr unsigned int size = factorial(6);
char buffer[size] {0};
constexpr point3d p {0, 1, 2};
constexpr auto x = p.get_x();
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-586">How it works...</h2>
<p class="normal">The <code class="inlineCode">const</code> keyword<a id="_idIndexMarker1146"/> is used for declaring variables as constant at runtime; this means that, once initialized, they cannot be changed. However, evaluating the constant expression may still imply runtime computation. The <code class="inlineCode">constexpr</code> keyword is used for declaring variables that are constant at compile time or functions that can be executed at compile time. <code class="inlineCode">constexpr</code> functions and objects can replace macros and hardcoded literals without any performance penalties.</p>
<div><p class="normal">Declaring a function as <code class="inlineCode">constexpr</code> does not mean that it is always evaluated at compile time. It only enables the use of the function in expressions that are evaluated during compile time. This only happens if all the input values of the function can be evaluated at compile time. However, the function may also be invoked at runtime. The following code shows two invocations of the same function, first at compile time, and then at runtime:</p>
</div>
<pre class="programlisting code"><code class="hljs-code">constexpr unsigned int size = factorial(6);
// compile time evaluation
int n;
std::cin &gt;&gt; n;
auto result = factorial(n);
// runtime evaluation
</code></pre>
<p class="normal">There <a id="_idIndexMarker1147"/>are some restrictions in regard to where <code class="inlineCode">constexpr</code> can be used. These restrictions have evolved over time, with changes in C++14 and C++20. To keep the list in a reasonable form, only the requirements that need to be satisfied in C++20 are shown here:</p>
<ul>
<li class="bulletList">A variable that is <code class="inlineCode">constexpr</code> must satisfy the following requirements:<ul>
<li class="bulletList">Its type is a literal type.</li>
<li class="bulletList">It is initialized upon declaration.</li>
<li class="bulletList">The expression used for initializing the variable is a constant expression.</li>
<li class="bulletList">It must have constant destruction. This means that it must not be of a class type or an array of a class type; otherwise, the class type must have a <code class="inlineCode">constexpr</code> destructor.</li>
</ul>
</li>
<li class="bulletList">A function that is <code class="inlineCode">constexpr</code> must satisfy the following requirements:<ul>
<li class="bulletList">It is not a coroutine.</li>
<li class="bulletList">The return type and the type of all its parameters are all literal types.</li>
<li class="bulletList">There is at least one set of arguments for which the invocation of the function would produce a constant expression.</li>
<li class="bulletList">The function body must not contain <code class="inlineCode">goto</code> statements, labels (other than <code class="inlineCode">case</code> and <code class="inlineCode">default</code> in a switch), and local variables that are either of non-literal types or of static or thread storage duration. The restrictions mentioned in this bullet point were removed in C++23.</li>
</ul>
</li>
<li class="bulletList">A constructor that is <code class="inlineCode">constexpr</code> must satisfy the following requirements, in addition to the preceding ones required for functions:<ul>
<li class="bulletList">There is no virtual base class for the class.</li>
<li class="bulletList">All the constructors that initialize non-static data members, including base classes, must also be <code class="inlineCode">constexpr</code>.</li>
</ul>
</li>
<li class="bulletList">A destructor that is <code class="inlineCode">constexpr</code>, available only since C++20, must satisfy the following requirements, in addition to the preceding ones required for functions:<ul>
<li class="bulletList">There is no virtual base class for the class.</li>
<li class="bulletList">All the destructors that destroy non-static data members, including base classes, must also be <code class="inlineCode">constexpr</code>.</li>
</ul>
</li>
</ul>
<div><p class="normal">All the restrictions for <code class="inlineCode">constexpr</code> constructors and destructors mentioned here were removed in C++23.</p>
</div>
<div><p class="normal">For a complete list of requirements in different versions of the standard, you should read the online documentation available at <a href="https://en.cppreference.com/w/cpp/language/constexpr">https://en.cppreference.com/w/cpp/language/constexpr</a>.</p>
</div>
<p class="normal">A <a id="_idIndexMarker1148"/>function that is <code class="inlineCode">constexpr</code> is not implicitly <code class="inlineCode">const</code> (as of C++14), so you need to explicitly use the <code class="inlineCode">const</code> specifier if the function does not alter the logical state of the object. However, a function that is <code class="inlineCode">constexpr</code> is implicitly <code class="inlineCode">inline</code>. On the other hand, an object that is declared <code class="inlineCode">constexpr</code> is implicitly <code class="inlineCode">const</code>. The following two declarations are equivalent:</p>
<pre class="programlisting code"><code class="hljs-code">constexpr const unsigned int size = factorial(6);
constexpr unsigned int size = factorial(6);
</code></pre>
<p class="normal">There are situations when you may need to use both <code class="inlineCode">constexpr</code> and <code class="inlineCode">const</code> in a declaration, as they would refer to different parts of the declaration. In the following example, <code class="inlineCode">p</code> is a <code class="inlineCode">constexpr</code> pointer to a constant integer:</p>
<pre class="programlisting code"><code class="hljs-code">static constexpr int c = 42;
constexpr int const * p = &amp;c;
</code></pre>
<p class="normal">Reference variables can also be <code class="inlineCode">constexpr</code> if, and only if, they alias an object with static storage duration or a function. The following snippet provides an example:</p>
<pre class="programlisting code"><code class="hljs-code">static constexpr int const &amp; r = c;
</code></pre>
<p class="normal">In <a id="_idIndexMarker1149"/>this example, <code class="inlineCode">r</code> is a <code class="inlineCode">constexpr</code> reference that defines an alias for the compile-time constant variable <code class="inlineCode">c</code>, defined in the previous snippet.</p>
<p class="normal">Although you can define static <code class="inlineCode">constexpr</code> variables, doing so in a <code class="inlineCode">constexpr</code> function was not possible until C++23. The following snippet shows such an example:</p>
<pre class="programlisting code"><code class="hljs-code">constexpr char symbol_table(int const n)
{
  static constexpr char symbols[] = "!@#$%^&amp;*"; // error until C++23
return symbols[n % 8];
}
int main()
{
    constexpr char s = symbol_table(42);
    std::cout &lt;&lt; s &lt;&lt; '\n';
}
</code></pre>
<p class="normal">The declaration of the <code class="inlineCode">symbols</code> variable would generate a compiler error, prior to C++23. A possible workaround for this problem was to define the variable outside of the <code class="inlineCode">constexpr</code> function, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">static constexpr char symbols[] = "!@#$%^&amp;*"; // OK
constexpr char symbol_table(int const n)
{
  return symbols[n % 8];
}
</code></pre>
<p class="normal">This problem has been solved in C++23, which relaxed several <code class="inlineCode">constexpr</code> restrictions, making a workaround unnecessary. </p>
<p class="normal">One more aspect that should be mentioned on constexpr functions is related to exceptions. Since C++20, try-catch blocks are allowed in constexpr functions (their use was not possible prior to this version). However, throwing exceptions from constant expressions is not allowed. Although you can have a throw statement in a constexpr function, the behavior is as follows:</p>
<ul>
<li class="bulletList">When executed at runtime, it would behave as if it wasn’t declared constexpr.</li>
<li class="bulletList">When executed at compile time, if the execution path encounters a throw statement, a compiler error is emitted.</li>
</ul>
<p class="normal">This <a id="_idIndexMarker1150"/>is exemplified in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">constexpr int factorial2(int const n)
{
   if(n &lt;= 0) throw std::invalid_argument("n must be positive");
   return n &gt; 1 ? n * factorial2(n - 1) : 1;
}
int main()
{
   try
   {
      int a = factorial2(5);
      int b = factorial2(-5);
   }
   catch (std::exception const&amp; ex)
   {
      std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;
   }         
   constexpr int c = factorial2(5);
   constexpr int d = factorial2(-5); // error
}
</code></pre>
<p class="normal">In this snippet:</p>
<ul>
<li class="bulletList">The first two calls to <code class="inlineCode">factorial2()</code> are executed at runtime. The first executes successfully and returns <code class="inlineCode">60</code>. The second throws a <code class="inlineCode">std::invalid_argument</code> exception because the argument is negative.</li>
<li class="bulletList">The third call is evaluated at compile time because variable <code class="inlineCode">c</code> is declared <code class="inlineCode">constexpr</code> and all the function’s inputs are also known at compile time. The invocation is successful and the function evaluates to <code class="inlineCode">60</code>.</li>
<li class="bulletList">The fourth call is also evaluated at compile time, but since the argument is negative the path that throws an exception should execute. However, this is not allowed in constant expressions, and, therefore, the compiler issues an error.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-587">There’s more…</h2>
<p class="normal">In C++20, a <a id="_idIndexMarker1151"/>new specifier was added to the language. This specifier is called <code class="inlineCode">constinit</code> and is used to ensure that variables with static or thread storage duration have static initialization. In C++, the initialization of variables can be either static or dynamic. Static initialization can be either zero initialization (when the initial value of an object is set to zero) or constant initialization (when the initial value is set to a compile-time expression). The following snippet shows examples of zero and constant initialization:</p>
<pre class="programlisting code"><code class="hljs-code">struct foo
{
  int a;
  int b;
};
struct bar
{
  int   value;
  int*  ptr;
  constexpr bar() :value{ 0 }, ptr{ nullptr } {}
};
std::string text {};  // zero-initialized to unspecified value
double arr[10];       // zero-initialized to ten 0.0
int* ptr;             // zero-initialized to nullptr
foo f = foo();        // zero-initialized to a=0, b=0
foo const fc{ 1, 2 }; // const-initialized at runtime
constexpr bar b;      // const-initialized at compile-time
</code></pre>
<p class="normal">A variable that has static storage could have either static or dynamic initialization. In the latter case, hard-to-find bugs may appear. Imagine two static objects that are initialized in different translation units.</p>
<p class="normal">When the <a id="_idIndexMarker1152"/>initialization of one of the two objects depends on the other object, then the order they are initialized in is important. This is because the object that depends on the object must be initialized first. However, the order of the initialization of the translation units is not deterministic, so there is no guarantee of the order of these objects’ initialization. However, variables with static storage duration that have static initialization are initialized at compile time. This implies that these objects can be safely used when performing dynamic initialization of translation units.</p>
<p class="normal">This is what the new specifier, <code class="inlineCode">constinit</code>, is intended for. It ensures that a variable with static or thread-local storage has static initialization, and, therefore, its initialization is performed at compile time:</p>
<pre class="programlisting code"><code class="hljs-code">int f() { return 42; }
constexpr int g(bool const c) { return c ? 0 : f(); }
constinit int c = g(true);  // OK
constinit int d = g(false); /* error: variable does not have
                                      a constant initializer */
</code></pre>
<p class="normal">It can also be used in a non-initializing declaration to indicate that a variable with thread storage duration is already initialized, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">extern thread_local constinit int data;
int get_data() { return data; }
</code></pre>
<div><p class="normal">You cannot use more than one of the <code class="inlineCode">constexpr</code>, <code class="inlineCode">constinit</code>, and <code class="inlineCode">consteval</code> specifiers in the same declaration.</p>
</div>
<h2 class="heading-2" id="_idParaDest-588">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Creating immediate functions</em>, to learn about the C++20 <code class="inlineCode">consteval</code> specifier, which is used to define functions that are guaranteed to be evaluated at compile time</li>
<li class="bulletList"><em class="italic">Ensuring constant correctness for a program</em>, to explore the benefits of constant correctness and how to achieve it</li>
</ul>
<h1 class="heading-1" id="_idParaDest-589">Creating immediate functions</h1>
<p class="normal"><code class="inlineCode">constexpr</code> functions <a id="_idIndexMarker1153"/>enable the evaluation of functions at compile time, provided that all their inputs, if any, are also available at compile time. However, this is not a guarantee, and constexpr functions may also execute at runtime, as we have seen in the previous recipe, <em class="italic">Creating compile-time constant expressions</em>. In C++20, a new category of functions has been introduced: <em class="italic">immediate functions</em>. These are functions that are guaranteed to always be evaluated at compile time; otherwise, they produce errors. Immediate functions are useful as replacements for macros and may be important in the possible future development of the language with reflection and meta-classes.</p>
<h2 class="heading-2" id="_idParaDest-590">How to do it…</h2>
<p class="normal">Use the <code class="inlineCode">consteval</code> keyword <a id="_idIndexMarker1154"/>when you want to:</p>
<ul>
<li class="bulletList">Define non-member functions or function templates that must be evaluated at compile time:
        <pre class="programlisting code"><code class="hljs-code">consteval unsigned int factorial(unsigned int const n)
{
  return n &gt; 1 ? n * factorial(n-1) : 1;
}
</code></pre>
</li>
<li class="bulletList">Define constructors that must be executed at compile time to initialize <code class="inlineCode">constexpr</code> objects and member functions to be invoked only at compile time:
        <pre class="programlisting code"><code class="hljs-code">class point3d
{
  double x_;
  double y_;
  double z_;
public:
  consteval point3d(double const x = 0,
 double const y = 0,
 double const z = 0)
    :x_{x}, y_{y}, z_{z}
  {}
  consteval double get_x() const {return x_;}
  consteval double get_y() const {return y_;}
  consteval double get_z() const {return z_;}
};
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-591">How it works…</h2>
<p class="normal">The <code class="inlineCode">consteval</code> specifier was introduced in C++20. It can only be applied to functions and function templates and defines them as immediate functions. This means that any function invocation must be evaluated at compile time and therefore produce a compile-time constant expression. If the function cannot be evaluated at compile time, the program is ill-formed and the compiler issues an error.</p>
<p class="normal">The following rules apply<a id="_idIndexMarker1155"/> to immediate functions:</p>
<ul>
<li class="bulletList">Destructors, allocation, and deallocation functions cannot be immediate functions.</li>
<li class="bulletList">If any declaration of a function contains the <code class="inlineCode">consteval</code> specifier, then all the declarations of that function must also include it.</li>
<li class="bulletList">The <code class="inlineCode">consteval</code> specifier cannot be used together with <code class="inlineCode">constexpr</code> or <code class="inlineCode">constinit</code>.</li>
<li class="bulletList">An immediate function is an inline <code class="inlineCode">constexpr</code> function. Therefore, immediate functions and function templates must satisfy the requirements applicable to <code class="inlineCode">constexpr</code> functions.</li>
</ul>
<p class="normal">Here is how we can use the <code class="inlineCode">factorial()</code> function and the <code class="inlineCode">point3d</code> class defined in the previous section:</p>
<pre class="programlisting code"><code class="hljs-code">constexpr unsigned int f = factorial(6);
std::cout &lt;&lt; f &lt;&lt; '\n';
constexpr point3d p {0, 1, 2};
std::cout &lt;&lt; p.get_x() &lt;&lt; ' ' &lt;&lt; p.get_y() &lt;&lt; ' ' &lt;&lt; p.get_z() &lt;&lt; '\n';
</code></pre>
<p class="normal">However, the following sample produces compiler errors because the immediate function <code class="inlineCode">factorial()</code> and the constructor of <code class="inlineCode">point3d</code> cannot be evaluated at compile time:</p>
<pre class="programlisting code"><code class="hljs-code">unsigned int n;
std::cin &gt;&gt; n;
const unsigned int f2 = factorial(n); // error
double x = 0, y = 1, z = 2;
constexpr point3d p2 {x, y, z};       // error
</code></pre>
<p class="normal">It is not possible to<a id="_idIndexMarker1156"/> take the address on an immediate function unless it is also in a constant expression:</p>
<pre class="programlisting code"><code class="hljs-code">using pfact = unsigned int(unsigned int);
pfact* pf = factorial;
constexpr unsigned int f3 = pf(42);   // error
consteval auto addr_factorial()
{
  return &amp;factorial;
}
consteval unsigned int invoke_factorial(unsigned int const n)
{
  return addr_factorial()(n);
}
constexpr auto ptr = addr_factorial();
// ERROR: cannot take the pointer of an immediate function
constexpr unsigned int f2 = invoke_factorial(5);
// OK
</code></pre>
<p class="normal">Because immediate functions are not visible at runtime, their symbols are not emitted for them and debuggers will not be able to show them.</p>
<h2 class="heading-2" id="_idParaDest-592">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Ensuring constant correctness for a program</em>, to explore the benefits of constant correctness and how to achieve it</li>
<li class="bulletList"><em class="italic">Creating compile-time constant expressions</em>, to learn about the <code class="inlineCode">constexpr</code> specifier and how to define variables and functions that can be evaluated at compile time</li>
</ul>
<h1 class="heading-1" id="_idParaDest-593">Optimizing code in constant-evaluated contexts</h1>
<p class="normal">In the <a id="_idIndexMarker1157"/>previous two recipes, we learned<a id="_idIndexMarker1158"/> about <em class="italic">constexpr functions</em>, which allow functions to be evaluated at compile time if all their inputs are available at compile time, and <em class="italic">immediate functions</em> (in C++20), which are guaranteed to always be evaluated at compile time (or otherwise, produce an error). An <a id="_idIndexMarker1159"/>important aspect of <code class="inlineCode">constexpr</code> functions is constant-evaluated contexts; these are code paths where all expressions and functions are evaluated at compile time. A constant-evaluated context is useful for optimizing code more effectively. On the other hand, the invocation of immediate functions from <code class="inlineCode">constexpr</code> functions is only possible in C++23. In this recipe, we will learn about utilizing constant-evaluated contexts.</p>
<h2 class="heading-2" id="_idParaDest-594">How to do it…</h2>
<p class="normal">To <a id="_idIndexMarker1160"/>determine whether a function context is constant-evaluated in order to provide compile-time implementations use the following:</p>
<ul>
<li class="bulletList">In C++20, the <code class="inlineCode">std::is_constant_evaluated()</code> library function, available in the <code class="inlineCode">&lt;type_traits&gt;</code> header, with a regular <code class="inlineCode">if</code> statement:
        <pre class="programlisting code"><code class="hljs-code">constexpr double power(double base, int exponent)
{
   if(std::is_constant_evaluated())
   {
      double result = 1.0;
      if (exponent == 0)
      {
          return result;
      }
      else if (exponent &gt; 0) {
          for (int i = 0; i &lt; exponent; i++) {
              result *= base;
          }
      }
      else {
          exponent = -exponent;
          for (int i = 0; i &lt; exponent; i++) {
              result *= base;
          }
          result = 1.0 / result;
      }
      return result;
   }
   else
   {
       return std::pow(base, exponent);
   }
}
int main()
{
   constexpr double a = power(10, 5); // compile-time eval
   std::cout &lt;&lt; a &lt;&lt; '\n';
   double b = power(10, 5);           // runtime eval
   std::cout &lt;&lt; b &lt;&lt; '\n';
}
</code></pre>
</li>
<li class="bulletList">In C++23, the <code class="inlineCode">if consteval</code> statement, which<a id="_idIndexMarker1161"/> is a simplification (with additional benefits) of<a id="_idIndexMarker1162"/> the <code class="inlineCode">if(std::is_constant_evaluated())</code> statement:
        <pre class="programlisting code"><code class="hljs-code">constexpr double power(double base, int exponent)
{
   if consteval
   {
      double result = 1.0;
      if (exponent == 0)
      {
          return result;
      }
      else if (exponent &gt; 0) {
          for (int i = 0; i &lt; exponent; i++) {
              result *= base;
          }
      }
      else {
          exponent = -exponent;
          for (int i = 0; i &lt; exponent; i++) {
              result *= base;
          }
          result = 1.0 / result;
      }
      return result;
   }
   else
   {
       return std::pow(base, exponent);
   }
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-595">How it works…</h2>
<p class="normal">The C++20 standard <a id="_idIndexMarker1163"/>provides a library function (in the <code class="inlineCode">&lt;type_traits&gt;</code> header) called <code class="inlineCode">std::is_constant_evaluated()</code>, which detects whether its call occurs within a constant-evaluated context in a <code class="inlineCode">constexpr</code> function. In this case, it returns <code class="inlineCode">true</code>; otherwise, it returns <code class="inlineCode">false</code>. </p>
<p class="normal">This function<a id="_idIndexMarker1164"/> is used with a regular <code class="inlineCode">if</code> statement, as in the example provided in the previous section, where we computed the power of a number. The key takeaways from this implementation are the following:</p>
<ul>
<li class="bulletList">In a constant-evaluated context, we used an algorithm that can be executed by the compiler at compile time, to optimize the code.</li>
<li class="bulletList">In a non-constant evaluated context (i.e., at runtime) we invoke the <code class="inlineCode">std::pow()</code> function to compute the power.</li>
</ul>
<p class="normal">However, there are some “gotchas” with this function and the constant-evaluated contexts that you must be aware of:</p>
<ul>
<li class="bulletList">Just because the arguments of a function are known at compile time, it does not mean that a context is constant-evaluated. In the following snippet, the first invocation of the <code class="inlineCode">constexpr</code> function <code class="inlineCode">power()</code> is in a constant-evaluated context, but the second is not, even though all its arguments are known at compile time and the function is declared <code class="inlineCode">constexpr</code>:
        <pre class="programlisting code"><code class="hljs-code">constexpr double a = power(10, 5); // [1] compile-time eval
double b = power(10, 5);           // [2] runtime eval
</code></pre>
</li>
<li class="bulletList">If used with a <code class="inlineCode">constexpr</code> if statement, the <code class="inlineCode">std::is_constant_evaluated()</code> function always evaluates to <code class="inlineCode">true</code> (compilers such as GCC and Clang provide a warning for this subtle error):
        <pre class="programlisting code"><code class="hljs-code">constexpr double power(double base, int exponent)
{
   if constexpr (std::is_constant_evaluated())
 {
   }
}
</code></pre>
</li>
</ul>
<p class="normal">Here is an example of the reported error: </p>
<pre class="programlisting con"><code class="hljs-con">prog.cc: In function 'constexpr double power(double, int)':
prog.cc:10:45: warning: 'std::is_constant_evaluated' always evaluates to true in 'if constexpr' [-Wtautological-compare]
   10 |     if constexpr (std::is_constant_evaluated())
      |                   ~~~~~~~~~~~~~~~~~~~~~~~~~~^~
</code></pre>
<p class="normal">The C++23 standard provides a better alternative to the <code class="inlineCode">std::is_constant_evaluated()</code> function, the <code class="inlineCode">consteval if</code> statement. This has several benefits:</p>
<ul>
<li class="bulletList">Does not require the inclusion of a header</li>
<li class="bulletList">Avoids confusion about the correct form of the <code class="inlineCode">if</code> statement to use</li>
<li class="bulletList">Allows the invocation of immediate functions in a constant-evaluated context</li>
</ul>
<p class="normal">The <a id="_idIndexMarker1165"/>implementation<a id="_idIndexMarker1166"/> of the power function changes to the following in C++23:</p>
<pre class="programlisting code"><code class="hljs-code">constexpr double power(double base, int exponent)
{
   if consteval
   {
      /* ... */
   }
   else
   {
       return std::pow(base, exponent);
   }
}
</code></pre>
<p class="normal">The <code class="inlineCode">consteval</code> <code class="inlineCode">if</code> statement always requires braces. The negated form is also possible, either with <code class="inlineCode">!</code> or the <code class="inlineCode">not</code> keyword. In the following snippet, each of the two pairs of statements are equivalent:</p>
<pre class="programlisting code"><code class="hljs-code">if !consteval {/*statement*/}          // [1] equivalent to [2]
if consteval {} else {/*statement*/}   // [2]
if not consteval {/*statement1*/}      // [3] equivalent to [4]
else {/*statement2*/}              
if consteval {/*statement2*/}          // [4]
else {/*statement1*/}
</code></pre>
<p class="normal">The <code class="inlineCode">consteval</code> if statement is also important for allowing an immediate function to be invoked from<a id="_idIndexMarker1167"/> a constant-evaluated context in a <code class="inlineCode">constexpr</code> function. Let’s take the following C++20 example:</p>
<pre class="programlisting code"><code class="hljs-code">consteval int plus_one(int const i) 
{ 
   return i + 1; 
}
consteval int plus_two(int i)
{
   return plus_one(i) + 1;
}
constexpr int plus_two_alt(int const i)
{
   if (std::is_constant_evaluated())
   {
      return plus_one(i) + 1;
   } 
   else
   {
      return i + 2;
   }
}
</code></pre>
<p class="normal">Here, the <a id="_idIndexMarker1168"/>function <code class="inlineCode">plus_one()</code> is an immediate function and can be invoked from the <code class="inlineCode">plus_two()</code> function, which is also an immediate function. However, invoking it from the <code class="inlineCode">plus_two_alt()</code> function is not possible because it is not a constant expression, even though this is a <code class="inlineCode">constexpr</code> function and the context where the <code class="inlineCode">plus_one()</code> function is invoked is constant-evaluated.</p>
<p class="normal">This problem is solved by the C++23 <code class="inlineCode">consteval if</code> statement. This makes it possible for immediate functions to be invoked from a constant-evaluated context, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">constexpr int plus_two_alt(int const i)
{
   if consteval
   {
      return plus_one(i) + 1;
   } 
   else
   {
      return i + 2;
   }
}
</code></pre>
<p class="normal">With the <a id="_idIndexMarker1169"/>availability of the <code class="inlineCode">consteval if</code> statement, the <code class="inlineCode">std::is_constant_evaluated()</code> function becomes obsolete. In fact, it <a id="_idIndexMarker1170"/>can be implemented with a <code class="inlineCode">consteval if</code> statement as follows:</p>
<pre class="programlisting code"><code class="hljs-code">constexpr bool is_constant_evaluated() noexcept
{
   if consteval {
      return true;
   } else {
      return false;
   }
}
</code></pre>
<div><p class="normal">When using a C++23 compiler, you should always prefer the <code class="inlineCode">consteval if</code> statement over the obsolete <code class="inlineCode">std::is_constant_evaluated()</code> function.</p>
</div>
<h2 class="heading-2" id="_idParaDest-596">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Creating compile-time constant expressions,</em> to learn about the <code class="inlineCode">constexpr</code> specifier and how to define variables and functions that can be evaluated at compile time</li>
<li class="bulletList"><em class="italic">Creating immediate functions,</em> to learn about the C++20 <code class="inlineCode">consteval</code> specifier, which is used to define functions that are guaranteed to be evaluated at compile time</li>
</ul>
<h1 class="heading-1" id="_idParaDest-597">Using virtual function calls in constant expressions</h1>
<p class="normal">As a <a id="_idIndexMarker1171"/>multi-paradigm programming language, C++ includes support for object-oriented programming. Polymorphism, one of the core principles of object-oriented programming, has two forms in C++: compile-time polymorphism, with function and operator overloading, and runtime-polymorphism, with virtual functions. Virtual functions allow a derived class to override the implementation (of a function) in the base class. In C++20, however, virtual functions<a id="_idIndexMarker1172"/> are allowed in constant expressions, meaning they can be invoked at compile time. In this recipe, you will learn how that works.</p>
<h2 class="heading-2" id="_idParaDest-598">Getting ready</h2>
<p class="normal">In this recipe, we will use the following structure to represent the dimension of a document and, respectively, an envelope, in the ensuing examples:</p>
<pre class="programlisting code"><code class="hljs-code">struct dimension
{
   double width;
   double height;
};
</code></pre>
<h2 class="heading-2" id="_idParaDest-599">How to do it…</h2>
<p class="normal">You can move runtime polymorphism to the compile time by doing the following:</p>
<ul>
<li class="bulletList">Declare the virtual functions whose invocation you want to move to compile time as <code class="inlineCode">constexpr</code>.</li>
<li class="bulletList">Declare the destructor of the base class of the hierarchy as <code class="inlineCode">constexpr</code>.</li>
<li class="bulletList">Declare the overridden virtual function as <code class="inlineCode">constexpr</code>.</li>
<li class="bulletList">Invoke the <code class="inlineCode">constexpr</code> virtual function in a constant expression.</li>
</ul>
<p class="normal">An example is shown in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">struct document_type
{
   constexpr virtual ~document_type() {};
   constexpr virtual dimension size() const = 0;
};
struct document_a5 : document_type
{
   constexpr dimension size() const override { return { 148.5, 210 }; }
};
struct envelope_type
{
   constexpr virtual ~envelope_type() {}
   constexpr virtual dimension size() const = 0;
   constexpr virtual dimension max_enclosure_size() const = 0;
};
struct envelop_commercial_8 : envelope_type
{
   constexpr dimension size() const override { return { 219, 92 }; }
   constexpr dimension max_enclosure_size() const override 
 { return { 213, 86 }; }
};
constexpr bool document_fits_envelope(document_type const&amp; d, 
                                      envelope_type const&amp; e)
{
   return e.max_enclosure_size().width &gt;= d.size().width;
}
int main()
{
   constexpr envelop_commercial_8 e1;
   constexpr document_a5          d1;
   static_assert(document_fits_envelope(d1, e1));
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-600">How it works…</h2>
<p class="normal">Prior to C++20, virtual functions <a id="_idIndexMarker1173"/>could <a id="_idIndexMarker1174"/>not be <code class="inlineCode">constexpr</code>. However, the dynamic type of an object used in a constant expression must be known at compile time. As a result, the restriction of making virtual functions <code class="inlineCode">constexpr</code> has been lifted in C++20.</p>
<p class="normal">The advantage of having <code class="inlineCode">constexpr</code> virtual functions is that some computations can be moved from runtime to compile time. Although this will not impact many use cases in practice, an example was given in the previous section. Let’s elaborate on it for a better understanding.</p>
<p class="normal">We have a set of various paper sizes for documents. Examples include <em class="italic">A3</em>, <em class="italic">A4</em>, <em class="italic">A5</em>, <em class="italic">legal</em>, <em class="italic">letter</em>, and <em class="italic">half-letter</em>. These have different sizes. For instance, A5 is 148.5 mm x 210 mm, while letter is 215.9 mm x 279.4 mm. </p>
<p class="normal">On the other hand, we have envelopes of different types and sizes. For instance, we have an envelope that is 92 mm x 219 mm with a maximum enclosure size of 86 mm x 213 mm. We want to write a function that determines whether a folded paper of a certain type can be placed inside an envelope. Since the <a id="_idIndexMarker1175"/>sizes are standard, they are <a id="_idIndexMarker1176"/>known at compile time. This means we can perform this check at compile time instead of runtime.</p>
<p class="normal">For this purpose, in the <em class="italic">How to do it…</em> section, we have seen:</p>
<ul>
<li class="bulletList">A hierarchy of documents, with the base class called <code class="inlineCode">document_type</code>. This has two members: a virtual destructor and a virtual function called <code class="inlineCode">size()</code> that returns the size of the paper. Both of these functions are also <code class="inlineCode">constexpr</code>.</li>
<li class="bulletList">A hierarchy of envelopes, with the base class called <code class="inlineCode">envelope_type</code>. This has three members: a virtual destructor, a virtual function called <code class="inlineCode">size()</code>, which returns the size of the envelope, and a virtual function called <code class="inlineCode">max_enclosure_size()</code>, which returns the maximum size of a (folded) paper that can be placed in the envelope. All these are <code class="inlineCode">constexpr</code>.</li>
<li class="bulletList">A free function called <code class="inlineCode">document_fits_envelope()</code> determines whether a given document type fits a particular envelope type, by comparing the size of the width of the two. This is also a <code class="inlineCode">constexpr</code> function.</li>
</ul>
<p class="normal">Because all these functions mentioned are <code class="inlineCode">constexpr</code>, the <code class="inlineCode">document_fits_envelope()</code> function can be invoked in a constant expression, such as a <code class="inlineCode">static_assert</code>, given that the objects for which they are invoked are also <code class="inlineCode">constexpr</code>. In the code files that accompany the book you will find an elaborate example with various paper and envelope sizes.</p>
<p class="normal">You should keep in mind that:</p>
<ul>
<li class="bulletList">You can make an overridden virtual function <code class="inlineCode">constexpr</code>, even though the function it overrides in the base class is not defined as <code class="inlineCode">constexpr</code>. </li>
<li class="bulletList">The opposite is also possible, the overridden virtual function in the derived class can be non-<code class="inlineCode">constexpr</code>, although the function was defined as <code class="inlineCode">constexpr</code> in the base class.</li>
<li class="bulletList">If there<a id="_idIndexMarker1177"/> is a hierarchy on multiple levels and a virtual function has some overrides defined as <code class="inlineCode">constexpr</code> and some not, then the final overrider appropriate<a id="_idIndexMarker1178"/> for the object on which the function is invoked is considered to determine whether the virtual function is <code class="inlineCode">constexpr</code> or not.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-601">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 1</em>, <em class="italic">Using override and final for virtual methods,</em> to learn how to use the override and final specifiers on virtual methods and classes, respectively</li>
</ul>
<h1 class="heading-1" id="_idParaDest-602">Performing correct type casts</h1>
<p class="normal">It is often <a id="_idIndexMarker1179"/>the case that data has to be converted from one type into another type. Some conversions are necessary at compile time (such as <code class="inlineCode">double</code> to <code class="inlineCode">int</code>); others are necessary at runtime (such as upcasting and downcasting pointers to the classes in a hierarchy). The language supports compatibility with the C casting style in either the <code class="inlineCode">(type)expression</code> or <code class="inlineCode">type(expression)</code> form. However, this type of casting breaks the type safety of C++.</p>
<p class="normal">Therefore, the language also provides several conversions: <code class="inlineCode">static_cast</code>, <code class="inlineCode">dynamic_cast</code>, <code class="inlineCode">const_cast</code>, and <code class="inlineCode">reinterpret_cast</code>. They are used to better indicate intent and write safer code. In this recipe, we’ll look at how these casts can be used.</p>
<h2 class="heading-2" id="_idParaDest-603">How to do it...</h2>
<p class="normal">Use the following casts to perform type conversions:</p>
<ul>
<li class="bulletList">Use <code class="inlineCode">static_cast</code> to perform type casting of non-polymorphic types, including the casting of integers to enumerations, from floating-point to integral values, or from a pointer type to another pointer type, such as from a base class to a derived class (downcasting) or from a derived class to a base class (upcasting), but without any runtime checks:
        <pre class="programlisting code"><code class="hljs-code">enum options {one = 1, two, three};
int value = 1;
options op = static_cast&lt;options&gt;(value);
int x = 42, y = 13;
double d = static_cast&lt;double&gt;(x) / y;
int n = static_cast&lt;int&gt;(d);
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">dynamic_cast</code> to <a id="_idIndexMarker1180"/>perform type casting of pointers or references of polymorphic types from a base class to a derived class or the other way around. These checks are performed at runtime and may require <a id="_idIndexMarker1181"/>that <strong class="keyWord">run-time type information</strong> (<strong class="keyWord">RTTI</strong>) is enabled:
        <pre class="programlisting code"><code class="hljs-code">struct base
{
  virtual void run() {}
  virtual ~base() {}
};
struct derived : public base
{
};
derived d;
base b;
base* pb = dynamic_cast&lt;base*&gt;(&amp;d);         // OK
derived* pd = dynamic_cast&lt;derived*&gt;(&amp;b);   // fail
try
{
  base&amp; rb = dynamic_cast&lt;base&amp;&gt;(d);       // OK
  derived&amp; rd = dynamic_cast&lt;derived&amp;&gt;(b); // fail
}
catch (std::bad_cast const &amp; e)
{
  std::cout &lt;&lt; e.what() &lt;&lt; '\n';
}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">const_cast</code> to perform conversion between types with different <code class="inlineCode">const</code> and <code class="inlineCode">volatile</code> specifiers, such as removing <code class="inlineCode">const</code> from an object that was not declared as <code class="inlineCode">const</code>:
        <pre class="programlisting code"><code class="hljs-code">void old_api(char* str, unsigned int size)
{
  // do something without changing the string
}
std::string str{"sample"};
old_api(const_cast&lt;char*&gt;(str.c_str()),
        static_cast&lt;unsigned int&gt;(str.size()));
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">reinterpret_cast</code> to perform bit reinterpretation, such as conversion between<a id="_idIndexMarker1182"/> integers and pointer types, from pointer types to integers, or from a pointer type to any other pointer type, without involving any runtime checks:
        <pre class="programlisting code"><code class="hljs-code">class widget
{
public:
  typedef size_t data_type;
  void set_data(data_type d) { data = d; }
  data_type get_data() const { return data; }
private:
  data_type data;
};
widget w;
user_data* ud = new user_data();
// write
w.set_data(reinterpret_cast&lt;widget::data_type&gt;(ud));
// read
user_data* ud2 = reinterpret_cast&lt;user_data*&gt;(w.get_data());
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-604">How it works...</h2>
<p class="normal">The explicit type conversion, sometimes referred to<a id="_idIndexMarker1183"/> as <em class="italic">C-style casting</em> or <em class="italic">static casting</em>, is a<a id="_idIndexMarker1184"/> legacy of the compatibility of C++ with the C language and enables you to perform various conversions including the following:</p>
<ul>
<li class="bulletList">Between arithmetical types</li>
<li class="bulletList">Between pointer types</li>
<li class="bulletList">Between integral and pointer types</li>
<li class="bulletList">Between const or volatile qualified and unqualified types</li>
</ul>
<p class="normal">This <a id="_idIndexMarker1185"/>type of casting does not work well with polymorphic types or in templates. Because of this, C++ provides the four casts we saw in the examples earlier. Using these casts leads to several important benefits:</p>
<ul>
<li class="bulletList">They express user intent better, both to the compiler and others that read the code.</li>
<li class="bulletList">They enable safer conversion between various types (except for <code class="inlineCode">reinterpret_cast</code>).</li>
<li class="bulletList">They can be easily searched in the source code.</li>
</ul>
<p class="normal"><code class="inlineCode">static_cast</code> is <a id="_idIndexMarker1186"/>not a direct equivalent of explicit type conversion, or static casting, even though the name might suggest that. This cast is performed at compile time and can be used to perform implicit conversions, the reverse of implicit conversions, and conversion from pointers to types from a hierarchy of classes. It cannot be used to trigger a conversion between unrelated pointer types, though. For this reason, in the following example, converting from <code class="inlineCode">int*</code> to <code class="inlineCode">double*</code> using <code class="inlineCode">static_cast</code> produces a compiler error:</p>
<pre class="programlisting code"><code class="hljs-code">int* pi = new int{ 42 };
double* pd = static_cast&lt;double*&gt;(pi);   // compiler error
</code></pre>
<p class="normal">However, converting from <code class="inlineCode">base*</code> to <code class="inlineCode">derived*</code> (where <code class="inlineCode">base</code> and <code class="inlineCode">derived</code> are the classes shown in the <em class="italic">How to do it...</em> section) does not produce a compiler error but a runtime error when trying to use the newly obtained pointer:</p>
<pre class="programlisting code"><code class="hljs-code">base b;
derived* pd = static_cast&lt;derived*&gt;(&amp;b); // compilers OK, runtime error
base* pb1 = static_cast&lt;base*&gt;(pd);      // OK
</code></pre>
<p class="normal">On the other hand, <code class="inlineCode">static_cast</code> cannot be used to remove <code class="inlineCode">const</code> and <code class="inlineCode">volatile</code> qualifiers. The following snippet exemplifies this:</p>
<pre class="programlisting code"><code class="hljs-code">int const c = 42;
int* pc = static_cast&lt;int*&gt;(&amp;c);         // compiler error
</code></pre>
<p class="normal">Safely typecasting expressions up, down, or sideways along an inheritance hierarchy can be performed with <code class="inlineCode">dynamic_cast</code>. This cast is performed at runtime and requires that RTTI is enabled. Because of this, it incurs a runtime overhead. Dynamic casting can only be used for pointers and references. </p>
<p class="normal">When <code class="inlineCode">dynamic_cast</code> is used to convert an expression<a id="_idIndexMarker1187"/> into a pointer type and the operation fails, the result is a null pointer. When it is used to convert an expression into a reference type and the operation fails, a <code class="inlineCode">std::bad_cast</code> exception is thrown. Therefore, always put a <code class="inlineCode">dynamic_cast</code> conversion to a reference type within a <code class="inlineCode">try...catch</code> block.</p>
<div><p class="normal">RTTI is a mechanism that exposes information about object data types at runtime. This is available only for polymorphic types (types that have at least one virtual method, including a virtual destructor, which all base classes should have). RTTI is usually an optional compiler feature (or might not be supported at all), which means using this functionality may require using a compiler switch.</p>
</div>
<p class="normal">Though dynamic casting is performed at runtime, if you attempt to convert it between non-polymorphic types, you’ll get a compiler error:</p>
<pre class="programlisting code"><code class="hljs-code">struct struct1 {};
struct struct2 {};
struct1 s1;
struct2* ps2 = dynamic_cast&lt;struct2*&gt;(&amp;s1); // compiler error
</code></pre>
<p class="normal"><code class="inlineCode">reinterpret_cast</code> is more <a id="_idIndexMarker1188"/>like a compiler directive. It does not translate into any CPU instructions; it only instructs the compiler to interpret the binary representation of an expression as it was of another, specified type. This is a type-unsafe conversion and should be used with care. It can be used to convert expressions between integral types and pointers, pointer types, and function pointer types. Because no checks are done, <code class="inlineCode">reinterpret_cast</code> can be successfully used to convert expressions between unrelated types, such as from <code class="inlineCode">int*</code> to <code class="inlineCode">double*</code>, which produces undefined behavior:</p>
<pre class="programlisting code"><code class="hljs-code">int* pi = new int{ 42 };
double* pd = reinterpret_cast&lt;double*&gt;(pi);
</code></pre>
<p class="normal">A typical use of <code class="inlineCode">reinterpret_cast</code> is to convert expressions between types in code that uses operating system or vendor-specific APIs. Many APIs store user data in the form of a pointer or an integral type. Therefore, if you need to pass the address of a user-defined type to such APIs, you need to convert values of unrelated pointer types or a pointer type value into an integral type value. A similar example was provided in the previous section, where <code class="inlineCode">widget</code> was a class that stored user-defined data in a data member and provided methods for accessing it: <code class="inlineCode">set_data()</code> and <code class="inlineCode">get_data()</code>. If you need to store a<a id="_idIndexMarker1189"/> pointer to an object in <code class="inlineCode">widget</code>, then use <code class="inlineCode">reinterpret_cast</code>, as shown in this example.</p>
<p class="normal"><code class="inlineCode">const_cast</code> is similar to <code class="inlineCode">reinterpret_cast</code> in the sense that it is a compiler directive and does not translate into CPU instructions. It is used to cast away <code class="inlineCode">const</code> or <code class="inlineCode">volatile</code> qualifiers, an operation that none of the other three conversions discussed here can do.</p>
<div><p class="normal"><code class="inlineCode">const_cast</code> should only be used to remove <code class="inlineCode">const</code> or <code class="inlineCode">volatile</code> qualifiers when the object is not declared <code class="inlineCode">const</code> or <code class="inlineCode">volatile</code>. Anything else incurs undefined behavior, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">int const a = 42;
int const * p = &amp;a;
int* q = const_cast&lt;int*&gt;(p);
*q = 0; // undefined behavior
</code></pre>
<p class="normal">In this example, the variable <code class="inlineCode">p</code> points to an object (the variable <code class="inlineCode">a</code>) that was declared constant. By re­moving the <code class="inlineCode">const</code> qualifier, the attempt to modify the pointed object introduces undefined behavior.</p>
</div>
<h2 class="heading-2" id="_idParaDest-605">There’s more...</h2>
<p class="normal">When using explicit type conversion in the form <code class="inlineCode">(type)expression</code>, be aware that it will select the first choice from the following list that satisfies specific cast requirements:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><code class="inlineCode">const_cast&lt;type&gt;(expression)</code></li>
<li class="numberedList"><code class="inlineCode">static_cast&lt;type&gt;(expression)</code></li>
<li class="numberedList"><code class="inlineCode">static_cast&lt;type&gt;(expression) + const_cast&lt;type&gt;(expression)</code></li>
<li class="numberedList"><code class="inlineCode">reinterpret_cast&lt;type&gt;(expression)</code></li>
<li class="numberedList"><code class="inlineCode">reinterpret_cast&lt;type&gt;(expression) + const_cast&lt;type&gt;(expression)</code></li>
</ol>
<p class="normal">Moreover, unlike the specific C++ casts, static cast can be used to convert between incomplete class types. If both <code class="inlineCode">type</code> and <code class="inlineCode">expression</code> are pointers to incomplete types, then it is not specified whether <code class="inlineCode">static_cast</code> or <code class="inlineCode">reinterpret_cast</code> is selected.</p>
<h2 class="heading-2" id="_idParaDest-606">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Ensuring constant correctness for a program</em>, to explore the benefits of constant correctness and how to achieve it</li>
</ul>
<h1 class="heading-1" id="_idParaDest-607">Implementing move semantics</h1>
<p class="normal">Move semantics <a id="_idIndexMarker1190"/>is a key feature that drives the performance improvements of modern C++. They enable moving, rather than copying, resources, or, in general, objects that are expensive to copy. However, it requires that classes implement a move constructor and move assignment operator. These are provided by the compiler in some circumstances, but in practice, it is often the case that you have to explicitly write them. In this recipe, we will see how to implement the move constructor and the move assignment operator.</p>
<h2 class="heading-2" id="_idParaDest-608">Getting ready</h2>
<p class="normal">You are <a id="_idIndexMarker1191"/>expected to have basic knowledge of rvalue references and the special class functions (constructors, assignment operators, and destructors). We will demonstrate how to implement a move constructor and assignment operator using the following <code class="inlineCode">Buffer</code> class:</p>
<pre class="programlisting code"><code class="hljs-code">class Buffer
{
  unsigned char* ptr;
  size_t length;
public:
  Buffer(): ptr(nullptr), length(0)
  {}
  explicit Buffer(size_t const size):
    ptr(new unsigned char[size] {0}), length(size)
  {}
  ~Buffer()
  {
    delete[] ptr;
  }
  Buffer(Buffer const&amp; other):
    ptr(new unsigned char[other.length]),
    length(other.length)
  {
    std::copy(other.ptr, other.ptr + other.length, ptr);
  }
  Buffer&amp; operator=(Buffer const&amp; other)
  {
    if (this != &amp;other)
    {
      delete[] ptr;
      ptr = new unsigned char[other.length];
      length = other.length;
      std::copy(other.ptr, other.ptr + other.length, ptr);
    }
    return *this;
  }
  size_t size() const { return length;}
  unsigned char* data() const { return ptr; }
};
</code></pre>
<p class="normal">Let’s move <a id="_idIndexMarker1192"/>on to the next section, where you’ll learn how to modify this class in order to benefit from move semantics.</p>
<h2 class="heading-2" id="_idParaDest-609">How to do it...</h2>
<p class="normal">To implement the move constructor for a class, do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Write a constructor that takes an rvalue reference to the class type:
        <pre class="programlisting code"><code class="hljs-code">Buffer(Buffer&amp;&amp; other)
{
}
</code></pre>
</li>
<li class="numberedList">Assign all the data members from the rvalue reference to the current object. This can be done either in the body of the constructor, as follows, or in the initialization list, which is the preferred way:
        <pre class="programlisting code"><code class="hljs-code">ptr = other.ptr;
length = other.length;
</code></pre>
</li>
<li class="numberedList">Optionally, assign the data members from the rvalue reference to default values (to ensure the object that was moved is in a destructible state):
        <pre class="programlisting code"><code class="hljs-code">other.ptr = nullptr;
other.length = 0;
</code></pre>
</li>
</ol>
<p class="normal">Put all <a id="_idIndexMarker1193"/>together, the move constructor for the <code class="inlineCode">Buffer</code> class looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">Buffer(Buffer&amp;&amp; other)
{
  ptr = other.ptr;
  length = other.length;
  other.ptr = nullptr;
  other.length = 0;
}
</code></pre>
<p class="normal">To implement the move assignment operator for a class, do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Write an assignment operator that takes an rvalue reference to the class type and returns a reference to it:
        <pre class="programlisting code"><code class="hljs-code">Buffer&amp; operator=(Buffer&amp;&amp; other)
{
}
</code></pre>
</li>
<li class="numberedList">Check that the rvalue reference does not refer to the same object as <code class="inlineCode">this</code>, and if they are different, perform <em class="italic">steps 3</em> to <em class="italic">5</em>:
        <pre class="programlisting code"><code class="hljs-code">if (this != &amp;other)
{
}
</code></pre>
</li>
<li class="numberedList">Dispose of all the resources (such as memory, handles, and so on) from the current object:
        <pre class="programlisting code"><code class="hljs-code">delete[] ptr;
</code></pre>
</li>
<li class="numberedList">Assign all the data members from the rvalue reference to the current object:
        <pre class="programlisting code"><code class="hljs-code">ptr = other.ptr;
length = other.length;
</code></pre>
</li>
<li class="numberedList">Assign the data members from the rvalue reference to the default values:
        <pre class="programlisting code"><code class="hljs-code">other.ptr = nullptr;
other.length = 0;
</code></pre>
</li>
<li class="numberedList">Return a reference to the current object, regardless of whether <em class="italic">steps 3</em> to <em class="italic">5</em> were executed or not:
        <pre class="programlisting code"><code class="hljs-code">return *this;
</code></pre>
</li>
</ol>
<p class="normal">Put all together, the <a id="_idIndexMarker1194"/>move assignment operator for the <code class="inlineCode">Buffer</code> class looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">Buffer&amp; operator=(Buffer&amp;&amp; other)
{
  if (this != &amp;other)
  {
    delete[] ptr;
    ptr = other.ptr;
    length = other.length;
    other.ptr = nullptr;
    other.length = 0;
  }
  return *this;
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-610">How it works...</h2>
<p class="normal">The move constructor and move assignment operator are provided by default by the compiler unless a user-defined copy constructor, move constructor, copy assignment operator, move assignment operator, or destructor exists already. When provided by the compiler, they perform a movement in a member-wise manner. The move constructor invokes the move constructors of the class data members recursively; similarly, the move assignment operator invokes the move assignment operators of the class data members recursively.</p>
<p class="normal">Move, in this case, represents a performance benefit for objects that are too large to copy (such as a string or container) or for objects that are not supposed to be copied (such as the <code class="inlineCode">unique_ptr</code> smart pointer). Not all classes are supposed to implement both copy and move semantics. Some classes should only be movable, while others should be both copyable and movable. On the other hand, it does not make much sense for a class to be copyable but not moveable, though this can be technically achieved.</p>
<p class="normal">Not all <a id="_idIndexMarker1195"/>types benefit from move semantics. In the case of built-in types (such as <code class="inlineCode">bool</code>, <code class="inlineCode">int</code>, or <code class="inlineCode">double</code>), arrays, or PODs, the move is actually a copy operation. On the other hand, move semantics provide a performance benefit in the context of rvalues, that is, temporary objects. An rvalue is an object that does not have a name; it lives temporarily during the evaluation of an expression and is destroyed at the next semicolon:</p>
<pre class="programlisting code"><code class="hljs-code">T a;
T b = a;
T c = a + b;
</code></pre>
<p class="normal">In the preceding example, <code class="inlineCode">a</code>, <code class="inlineCode">b</code>, and <code class="inlineCode">c</code> are lvalues; they are objects that have a name that can be used to refer to the object at any point throughout its lifetime. On the other hand, when you evaluate the expression <code class="inlineCode">a+b</code>, the compiler creates a temporary object (which, in this case, is assigned to <code class="inlineCode">c</code>), which is then destroyed when a semicolon is encountered. These temporary objects are called rvalues because they usually appear on the right-hand side of an assignment expression. In C++11, we can refer to these objects through rvalue references, expressed with <code class="inlineCode">&amp;&amp;</code>.</p>
<p class="normal">Move semantics are important in the context of rvalues. This is because they allow you to take ownership of the resources from the temporary object that is destroyed, without the client being able to use it after the move operation is completed. On the other hand, lvalues cannot be moved; they can only be copied. This is because they can be accessed after the move operation, and the client expects the object to be in the same state. For instance, in the preceding example, the expression <code class="inlineCode">b = a</code> assigns <code class="inlineCode">a</code> to <code class="inlineCode">b</code>.</p>
<p class="normal">After this operation is complete, the object <code class="inlineCode">a</code>, which is an lvalue, can still be used by the client and should be in the same state as it was before. On the other hand, the result of <code class="inlineCode">a+b</code> is temporary, and its data can be safely moved to <code class="inlineCode">c</code>.</p>
<p class="normal">The move constructor is different from a copy constructor because it takes an rvalue reference to the class type <code class="inlineCode">T(T&amp;&amp;)</code>, as opposed to an lvalue reference in the case of the copy constructor <code class="inlineCode">T(T const&amp;)</code>. Similarly, the move assignment takes an rvalue reference, namely <code class="inlineCode">T&amp; operator=(T&amp;&amp;)</code>, as opposed to an lvalue reference for the copy assignment operator, namely <code class="inlineCode">T&amp; operator=(T const &amp;)</code>. This is true even though both return a reference to the <code class="inlineCode">T&amp;</code> class. The compiler selects the appropriate constructor or assignment operator based on the type of argument, rvalue, or lvalue.</p>
<p class="normal">When a <a id="_idIndexMarker1196"/>move constructor/assignment operator exists, an rvalue is moved automatically. lvalues can also be moved, but this requires an explicit casting to an rvalue reference. This can be done using the <code class="inlineCode">std::move()</code> function, which basically performs a <code class="inlineCode">static_cast&lt;T&amp;&amp;&gt;</code>:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;Buffer&gt; c;
c.push_back(Buffer(100));  // move
Buffer b(200);
c.push_back(b);            // copy
c.push_back(std::move(b)); // move
</code></pre>
<p class="normal">After an object is moved, it must remain in a valid state. However, there is no requirement regarding what this state should be. For consistency, you should set all member fields to their default value (numerical types to <code class="inlineCode">0</code>, pointers to <code class="inlineCode">nullptr</code>, Booleans to <code class="inlineCode">false</code>, and so on).</p>
<p class="normal">The following example shows the different ways in which <code class="inlineCode">Buffer</code> objects can be constructed and assigned:</p>
<pre class="programlisting code"><code class="hljs-code">Buffer b1;                // default constructor
Buffer b2(100);           // explicit constructor
Buffer b3(b2);            // copy constructor
b1 = b3;                  // assignment operator
Buffer b4(std::move(b1)); // move constructor
b3 = std::move(b4);       // move assignment
</code></pre>
<p class="normal">The constructor or assignment operator involved in the creation or assignment of the objects <code class="inlineCode">b1</code>, <code class="inlineCode">b2</code>, <code class="inlineCode">b3</code>, and <code class="inlineCode">b4</code> is mentioned in the comments on each line.</p>
<h2 class="heading-2" id="_idParaDest-611">There’s more...</h2>
<p class="normal">As seen with the <code class="inlineCode">Buffer</code> example, implementing both the move constructor and move assignment operator involves writing similar code (the entire code of the move constructor was also present in the move assignment operator). This can actually be avoided by calling the move assignment operator in the move constructor (or, alternatively, factor the assignment code into a private function that is invoked from both the move constructor and move assignment operator):</p>
<pre class="programlisting code"><code class="hljs-code">Buffer(Buffer&amp;&amp; other) : ptr(nullptr), length(0)
{
  *this = std::move(other);
}
</code></pre>
<p class="normal">There are two <a id="_idIndexMarker1197"/>points that must be noticed in this example:</p>
<ul>
<li class="bulletList">Member initialization in the constructor’s initialization list is necessary because these members could potentially be used in the move assignment operator later on (such as the <code class="inlineCode">ptr</code> member in this example).</li>
<li class="bulletList">Static casting of <code class="inlineCode">other</code> to an rvalue reference. Without this explicit conversion, the copy assignment operator would be called. This is because even if an rvalue is passed to this constructor as an argument, when it is assigned a name, it is bound to an lvalue. Therefore, <code class="inlineCode">other</code> is actually an lvalue, and it must be converted to an rvalue reference in order to invoke the move assignment operator.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-612">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 3</em>, <em class="italic">Defaulted and deleted functions</em>, to learn about the use of the <code class="inlineCode">default</code> specifier on special member functions and how to define functions as deleted with the <code class="inlineCode">delete</code> specifier</li>
</ul>
<h1 class="heading-1" id="_idParaDest-613">Using unique_ptr to uniquely own a memory resource</h1>
<p class="normal">Manual handling<a id="_idIndexMarker1198"/> of heap memory allocation and releasing it (with <code class="inlineCode">new</code> and <code class="inlineCode">delete</code>) is one of the most controversial features of C++. All allocations must be properly paired with a corresponding delete operation in the correct scope. If the memory allocation is done in a function and needs to be released before the function returns, for instance, then this has to happen on all the return paths, including the abnormal situation where a function returns because of an exception. C++11 features, such as rvalues and move semantics, have enabled the development of better smart pointers (since some, such as <code class="inlineCode">auto_ptr</code>, existed prior to C++11); these pointers can manage a memory resource and automatically release it when the smart pointer is destroyed. In this recipe, we will look at <code class="inlineCode">std::unique_ptr</code>, a smart pointer that owns and manages another object or an array of objects <a id="_idIndexMarker1199"/>allocated on the heap, and performs the disposal operation when the smart pointer goes out of scope.</p>
<h2 class="heading-2" id="_idParaDest-614">Getting ready</h2>
<p class="normal">In the following examples, we will use the ensuing class:</p>
<pre class="programlisting code"><code class="hljs-code">class foo
{
  int a;
  double b;
  std::string c;
public:
  foo(int const a = 0, double const b = 0, 
 std::string const &amp; c = "") :a(a), b(b), c(c)
  {}
  void print() const
 {
    std::cout &lt;&lt; '(' &lt;&lt; a &lt;&lt; ',' &lt;&lt; b &lt;&lt; ',' &lt;&lt; std::quoted(c) &lt;&lt; ')'
              &lt;&lt; '\n';
  }
};
</code></pre>
<p class="normal">For this recipe, you need to be familiar with move semantics and the <code class="inlineCode">std::move()</code> conversion function. The <code class="inlineCode">unique_ptr</code> class is available in the <code class="inlineCode">std</code> namespace in the <code class="inlineCode">&lt;memory&gt;</code> header.</p>
<h2 class="heading-2" id="_idParaDest-615">How to do it...</h2>
<p class="normal">The following is a list of typical operations you need to be aware of when working with <code class="inlineCode">std::unique_ptr</code>:</p>
<ul>
<li class="bulletList">Use the available overloaded constructors to create a <code class="inlineCode">std::unique_ptr</code> that manages objects or an array of objects through a pointer. The default constructor creates a pointer that does not manage any object:
        <pre class="programlisting code"><code class="hljs-code">std::unique_ptr&lt;int&gt;   pnull;
std::unique_ptr&lt;int&gt;   pi(new int(42));
std::unique_ptr&lt;int[]&gt; pa(new int[3]{ 1,2,3 });
std::unique_ptr&lt;foo&gt;   pf(new foo(42, 42.0, "42"));
</code></pre>
</li>
<li class="bulletList">Alternatively, use the <code class="inlineCode">std::make_unique()</code> function template, available in C++14, to create <code class="inlineCode">std::unique_ptr</code> objects:
        <pre class="programlisting code"><code class="hljs-code">std::unique_ptr&lt;int&gt;   pi = std::make_unique&lt;int&gt;(42);
std::unique_ptr&lt;int[]&gt; pa = std::make_unique&lt;int[]&gt;(3);
std::unique_ptr&lt;foo&gt;   pf = std::make_unique&lt;foo&gt;(42, 42.0, "42");
</code></pre>
</li>
<li class="bulletList">Use the <code class="inlineCode">std::make_unique_for_overwrite()</code> function template, available in C++20, to create a <code class="inlineCode">std::unique_ptr</code> to objects or an array of objects that are default initialized. These objects should later be overwritten with a determined value:
        <pre class="programlisting code"><code class="hljs-code">std::unique_ptr&lt;int&gt;   pi = std::make_unique_for_overwrite&lt;int&gt;();
std::unique_ptr&lt;foo[]&gt; pa = std::make_unique_for_overwrite&lt;foo[]&gt;();
</code></pre>
</li>
<li class="bulletList">Use<a id="_idIndexMarker1200"/> the overloaded constructor, which takes a custom deleter if the default <code class="inlineCode">delete</code> operator is not appropriate for destroying the managed object or array:
        <pre class="programlisting code"><code class="hljs-code">struct foo_deleter
{
  void operator()(foo* pf) const
 {
    std::cout &lt;&lt; "deleting foo..." &lt;&lt; '\n';
    delete pf;
  }
};
std::unique_ptr&lt;foo, foo_deleter&gt; pf(
 new foo(42, 42.0, "42"),
    foo_deleter());
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::move()</code> to transfer the ownership of an object from one <code class="inlineCode">std::unique_ptr</code> to another:
        <pre class="programlisting code"><code class="hljs-code">auto pi = std::make_unique&lt;int&gt;(42);
auto qi = std::move(pi);
assert(pi.get() == nullptr);
assert(qi.get() != nullptr);
</code></pre>
</li>
<li class="bulletList">To access<a id="_idIndexMarker1201"/> the raw pointer to the managed object, use <code class="inlineCode">get()</code> if you want to retain ownership of the object or <code class="inlineCode">release()</code> if you want to release the ownership as well:
        <pre class="programlisting code"><code class="hljs-code">void func(int* ptr)
{
  if (ptr != nullptr)
    std::cout &lt;&lt; *ptr &lt;&lt; '\n';
  else
    std::cout &lt;&lt; "null" &lt;&lt; '\n';
}
std::unique_ptr&lt;int&gt; pi;
func(pi.get()); // prints null
pi = std::make_unique&lt;int&gt;(42);
func(pi.get()); // prints 42
</code></pre>
</li>
<li class="bulletList">Dereference the pointer to the managed object using <code class="inlineCode">operator*</code> and <code class="inlineCode">operator-&gt;</code>:
        <pre class="programlisting code"><code class="hljs-code">auto pi = std::make_unique&lt;int&gt;(42);
*pi = 21;
auto pf1 = std::make_unique&lt;foo&gt;();
pf1-&gt;print(); // prints (0,0,"")
auto pf2 = std::make_unique&lt;foo&gt;(42, 42.0, "42");
pf2-&gt;print(); // prints (42,42,"42")
</code></pre>
</li>
<li class="bulletList">If <code class="inlineCode">std::unique_ptr</code> manages an array of objects, <code class="inlineCode">operator[]</code> can be used to access individual elements of the array:
        <pre class="programlisting code"><code class="hljs-code">std::unique_ptr&lt;int[]&gt; pa = std::make_unique&lt;int[]&gt;(3);
for (int i = 0; i &lt; 3; ++i)
  pa[i] = i + 1;
</code></pre>
</li>
<li class="bulletList">To check whether <code class="inlineCode">std::unique_ptr</code> can manage an object or not, use the explicit operator <code class="inlineCode">bool</code> or check whether <code class="inlineCode">get() != nullptr</code> (which is what the operator <code class="inlineCode">bool</code> does):
        <pre class="programlisting code"><code class="hljs-code">std::unique_ptr&lt;int&gt; pi(new int(42));
if (pi) std::cout &lt;&lt; "not null" &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::unique_ptr</code> objects can be stored in a container. Objects returned by <code class="inlineCode">make_unique()</code> can be stored directly. An lvalue object could be statically converted to an rvalue object with <code class="inlineCode">std::move()</code> if you want to give up the ownership <a id="_idIndexMarker1202"/>of the managed object to the <code class="inlineCode">std::unique_ptr</code> object in the container:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;std::unique_ptr&lt;foo&gt;&gt; data;
for (int i = 0; i &lt; 5; i++)
  data.push_back(
std::make_unique&lt;foo&gt;(i, i, std::to_string(i)));
auto pf = std::make_unique&lt;foo&gt;(42, 42.0, "42");
data.push_back(std::move(pf));
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-616">How it works...</h2>
<p class="normal"><code class="inlineCode">std::unique_ptr</code> is a smart pointer that manages an object or an array allocated on the heap through a raw pointer. It performs an appropriate disposal when the smart pointer goes out of scope, is assigned a new pointer with <code class="inlineCode">operator=</code>, or gives up ownership using the <code class="inlineCode">release()</code> method. By default, the operator <code class="inlineCode">delete</code> is used to dispose of the managed object. However, the user may supply a custom deleter when constructing the smart pointer. This deleter must be a function object, either an lvalue reference to a function object or a function, and this callable object must take a single argument of the type <code class="inlineCode">unique_ptr&lt;T, Deleter&gt;::pointer</code>.</p>
<p class="normal">C++14 has added the <code class="inlineCode">std::make_unique()</code> utility function template to create a <code class="inlineCode">std::unique_ptr</code>. It avoids memory leaks in some particular contexts, but it has some limitations:</p>
<ul>
<li class="bulletList">It can only be used to allocate arrays; you cannot use it to initialize them, which is possible with a <code class="inlineCode">std::unique_ptr</code> constructor.
    <p class="normal">The following two pieces of sample code are equivalent:</p>
<pre class="programlisting code"><code class="hljs-code">// allocate and initialize an array
std::unique_ptr&lt;int[]&gt; pa(new int[3]{ 1,2,3 });
// allocate and then initialize an array
std::unique_ptr&lt;int[]&gt; pa = std::make_unique&lt;int[]&gt;(3);
for (int i = 0; i &lt; 3; ++i)
  pa[i] = i + 1;
</code></pre></li>
</ul>
<ul>
<li class="bulletList">It cannot be used to create a <code class="inlineCode">std::unique_ptr</code> object with a user-defined deleter.</li>
</ul>
<p class="normal">As we just <a id="_idIndexMarker1203"/>mentioned, the great advantage of <code class="inlineCode">make_unique()</code> is that it helps us avoid memory leaks in some contexts where exceptions are being thrown. <code class="inlineCode">make_unique()</code> itself can throw <code class="inlineCode">std::bad_alloc</code> if the allocation fails or any exception is thrown by the constructor of the object it creates. Let’s consider the following example:</p>
<pre class="programlisting code"><code class="hljs-code">void some_function(std::unique_ptr&lt;foo&gt; p)
{ /* do something */ }
some_function(std::unique_ptr&lt;foo&gt;(new foo()));
some_function(std::make_unique&lt;foo&gt;());
</code></pre>
<p class="normal">Regardless of what happens with the allocation and construction of <code class="inlineCode">foo</code>, there will be no memory leaks, irrespective of whether you use <code class="inlineCode">make_unique()</code> or the constructor of <code class="inlineCode">std::unique_ptr</code>. However, this situation changes in a slightly different version of the code:</p>
<pre class="programlisting code"><code class="hljs-code">void some_other_function(std::unique_ptr&lt;foo&gt; p, int const v)
{
}
int function_that_throws()
{
  throw std::runtime_error("not implemented");
}
// possible memory leak
some_other_function(std::unique_ptr&lt;foo&gt;(new foo),
                    function_that_throws());
// no possible memory leak
some_other_function(std::make_unique&lt;foo&gt;(),
                    function_that_throws());
</code></pre>
<p class="normal">In this example, <code class="inlineCode">some_other_function()</code> has an extra parameter: an integer value. The integer argument that’s passed to this function is the returned value of another function. If this function call throws an exception, using the constructor of <code class="inlineCode">std::unique_ptr</code> to create the smart pointer can produce a memory leak. The reason for this is that, upon calling <code class="inlineCode">some_other_function()</code>, the compiler might first call <code class="inlineCode">foo</code>, then <code class="inlineCode">function_that_throws()</code>, and then the constructor of <code class="inlineCode">std::unique_ptr</code>. If <code class="inlineCode">function_that_throws()</code> throws an error, then the allocated <code class="inlineCode">foo</code> will leak. If the calling order is <code class="inlineCode">function_that_throws()</code> and then <code class="inlineCode">new foo()</code> and the constructor of <code class="inlineCode">unique_ptr</code>, a memory leak will not happen; this is because the stack starts unwinding before the <code class="inlineCode">foo</code> object is allocated. However, by using the <code class="inlineCode">make_unique()</code> function, this situation<a id="_idIndexMarker1204"/> is avoided. This is because the only calls made are to <code class="inlineCode">make_unique()</code> and <code class="inlineCode">function_that_throws()</code>. If <code class="inlineCode">function_that_throws()</code> is called first, then the <code class="inlineCode">foo</code> object will not be allocated at all. If <code class="inlineCode">make_unique()</code> is called first, the <code class="inlineCode">foo</code> object is constructed and its ownership is passed to <code class="inlineCode">std::unique_ptr</code>. If a later call to <code class="inlineCode">function_that_throws()</code> does throw, then <code class="inlineCode">std::unique_ptr</code> will be destroyed when the stack is unwound and the <code class="inlineCode">foo</code> object will be destroyed from the smart pointer’s destructor. C++17 fixed this problem by requiring any parameter to be fully evaluated before the next one is started.</p>
<p class="normal">In C++20, a new function, called <code class="inlineCode">std::make_unique_for_overwrite()</code>, has been added. This is similar to <code class="inlineCode">make_unique()</code> except that its default initializes the object or the array of objects. This function can be used in generic code where it’s unknown whether the type template parameter is trivially copyable or not. This function expresses the intent to create a pointer to an object that may not be initialized so that it should be overwritten later.</p>
<p class="normal">Constant <code class="inlineCode">std::unique_ptr</code> objects cannot transfer the ownership of a managed object or array to another <code class="inlineCode">std::unique_ptr</code> object. On the other hand, access to the raw pointer to the managed object can be obtained with either <code class="inlineCode">get()</code> or <code class="inlineCode">release()</code>. The first method only returns the underlying pointer, but the latter also releases the ownership of the managed object, hence the name. After a call to <code class="inlineCode">release()</code>, the <code class="inlineCode">std::unique_ptr</code> object will be empty and a call to <code class="inlineCode">get()</code> will return <code class="inlineCode">nullptr</code>.</p>
<p class="normal">A <code class="inlineCode">std::unique_ptr</code> that manages the object of a <code class="inlineCode">Derived</code> class can be implicitly converted to a <code class="inlineCode">std::unique_ptr</code> that manages an object of the class <code class="inlineCode">Base</code> if <code class="inlineCode">Derived</code> is derived from <code class="inlineCode">Base</code>. This implicit conversion is safe only if <code class="inlineCode">Base</code> has a virtual destructor (as all base classes should have); otherwise, undefined behavior is employed:</p>
<pre class="programlisting code"><code class="hljs-code">struct Base
{
  virtual ~Base()
  {
    std::cout &lt;&lt; "~Base()" &lt;&lt; '\n';
  }
};
struct Derived : public Base
{
  virtual ~Derived()
  {
    std::cout &lt;&lt; "~Derived()" &lt;&lt; '\n';
  }
};
std::unique_ptr&lt;Derived&gt; pd = std::make_unique&lt;Derived&gt;();
std::unique_ptr&lt;Base&gt; pb = std::move(pd);
</code></pre>
<p class="normal">The <a id="_idIndexMarker1205"/>output from running this snippet is as follows:</p>
<pre class="programlisting con"><code class="hljs-con">~Derived()
~Base()
</code></pre>
<p class="normal"><code class="inlineCode">std::unique_ptr</code> can be stored in containers, such as <code class="inlineCode">std::vector</code>. Because only one <code class="inlineCode">std::unique_ptr</code> object can own the managed object at any point, the smart pointer cannot be copied to the container; it has to be moved. This is possible with <code class="inlineCode">std::move()</code>, which performs a <code class="inlineCode">static_cast</code> to an rvalue reference type. This allows the ownership of the managed object to be transferred to the <code class="inlineCode">std::unique_ptr</code> object that is created in the container.</p>
<h2 class="heading-2" id="_idParaDest-617">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using shared_ptr to share a memory resource</em>, to learn about the <code class="inlineCode">std::shared_ptr</code> class, which represents a smart pointer that shares ownership of an object or array of objects allocated on the heap</li>
</ul>
<h1 class="heading-1" id="_idParaDest-618">Using shared_ptr to share a memory resource</h1>
<p class="normal">Managing <a id="_idIndexMarker1206"/>dynamically allocated objects or arrays with <code class="inlineCode">std::unique_ptr</code> is not possible when the object or array has to be shared. This is because a <code class="inlineCode">std::unique_ptr</code> retains its sole ownership. The C++ standard provides another smart pointer, called <code class="inlineCode">std::shared_ptr</code>; it is similar to <code class="inlineCode">std::unique_ptr</code> in many ways, but the difference is that it can share the ownership of an object or array with other <code class="inlineCode">std::shared_ptr</code> objects. In this recipe, we will see how <code class="inlineCode">std::shared_ptr</code> works and how it differs from <code class="inlineCode">std::uniqueu_ptr</code>. We will also look at <code class="inlineCode">std::weak_ptr</code>, which is a non-resource-owning smart pointer that holds a reference to an object managed by a <code class="inlineCode">std::shared_ptr</code>.</p>
<h2 class="heading-2" id="_idParaDest-619">Getting ready</h2>
<p class="normal">Make sure<a id="_idIndexMarker1207"/> you read the previous recipe, <em class="italic">Using unique_ptr to uniquely own a memory resource</em>, to become familiar with how <code class="inlineCode">unique_ptr</code> and <code class="inlineCode">make_unique()</code> work. We will use the <code class="inlineCode">foo</code>, <code class="inlineCode">foo_deleter</code>, <code class="inlineCode">Base</code>, and <code class="inlineCode">Derived</code> classes defined in this recipe, and also make several references to it.</p>
<p class="normal">Both the <code class="inlineCode">shared_ptr</code> and <code class="inlineCode">weak_ptr</code> classes, as well as the <code class="inlineCode">make_shared()</code> function template, are available in the <code class="inlineCode">std</code> namespace in the <code class="inlineCode">&lt;memory&gt;</code> header.</p>
<div><p class="normal">For simplicity and readability, we will not use the fully qualified names <code class="inlineCode">std::unique_ptr</code>, <code class="inlineCode">std::shared_ptr</code>, and <code class="inlineCode">std::weak_ptr</code> in this recipe, but <code class="inlineCode">unique_ptr</code>, <code class="inlineCode">shared_ptr</code>, and <code class="inlineCode">weak_ptr</code>.</p>
</div>
<h2 class="heading-2" id="_idParaDest-620">How to do it...</h2>
<p class="normal">The following is a list of the typical operations you need to be aware of when working with <code class="inlineCode">shared_ptr</code> and <code class="inlineCode">weak_ptr</code>:</p>
<ul>
<li class="bulletList">Use one of the available overloaded constructors to create a <code class="inlineCode">shared_ptr</code> that manages an object through a pointer. The default constructor creates an empty <code class="inlineCode">shared_ptr</code>, which does not manage any object:
        <pre class="programlisting code"><code class="hljs-code">std::shared_ptr&lt;int&gt; pnull1;
std::shared_ptr&lt;int&gt; pnull2(nullptr);
std::shared_ptr&lt;int&gt; pi1(new int(42));
std::shared_ptr&lt;int&gt; pi2 = pi1;
std::shared_ptr&lt;foo&gt; pf1(new foo());
std::shared_ptr&lt;foo&gt; pf2(new foo(42, 42.0, "42"));
</code></pre>
</li>
<li class="bulletList">Alternatively, use the <code class="inlineCode">std::make_shared()</code> function template, available since C++11, to create <code class="inlineCode">shared_ptr</code> objects:
        <pre class="programlisting code"><code class="hljs-code">std::shared_ptr&lt;int&gt; pi  = std::make_shared&lt;int&gt;(42);
std::shared_ptr&lt;foo&gt; pf1 = std::make_shared&lt;foo&gt;();
std::shared_ptr&lt;foo&gt; pf2 = std::make_shared&lt;foo&gt;(42, 42.0, "42");
</code></pre>
</li>
<li class="bulletList">Use<a id="_idIndexMarker1208"/> the <code class="inlineCode">std::make_shared_for_overwrite()</code> function template, available in C++20, to create <code class="inlineCode">shared_ptr</code>s to objects or arrays of objects that are default initialized. These objects should later be overwritten with a determined value:
        <pre class="programlisting code"><code class="hljs-code">std::shared_ptr&lt;int&gt; pi = std::make_shared_for_overwrite&lt;int&gt;();
std::shared_ptr&lt;foo[]&gt; pa = std::make_shared_for_overwrite&lt;foo[]&gt;(3);
</code></pre>
</li>
<li class="bulletList">Use the overloaded constructor, which takes a custom deleter if the default delete operation is not appropriate for destroying the managed object:
        <pre class="programlisting code"><code class="hljs-code">std::shared_ptr&lt;foo&gt; pf1(new foo(42, 42.0, "42"),
                         foo_deleter());
std::shared_ptr&lt;foo&gt; pf2(
 new foo(42, 42.0, "42"),
        [](foo* p) {
          std::cout &lt;&lt; "deleting foo from lambda..." &lt;&lt; '\n';
 delete p;});
</code></pre>
</li>
<li class="bulletList">Always specify a deleter when managing an array of objects. The deleter can either be a partial specialization of <code class="inlineCode">std::default_delete</code> for arrays or any function that takes a pointer to the template type:
        <pre class="programlisting code"><code class="hljs-code">std::shared_ptr&lt;int&gt; pa1(
 new int[3]{ 1, 2, 3 },
  std::default_delete&lt;int[]&gt;());
std::shared_ptr&lt;int&gt; pa2(
 new int[3]{ 1, 2, 3 },
  [](auto p) {delete[] p; });
</code></pre>
</li>
<li class="bulletList">To access the raw pointer to the managed object, use the <code class="inlineCode">get()</code> function:
        <pre class="programlisting code"><code class="hljs-code">void func(int* ptr)
{
  if (ptr != nullptr)
    std::cout &lt;&lt; *ptr &lt;&lt; '\n';
  else
    std::cout &lt;&lt; "null" &lt;&lt; '\n';
}
std::shared_ptr&lt;int&gt; pi;
func(pi.get());
pi = std::make_shared&lt;int&gt;(42);
func(pi.get());
</code></pre>
</li>
<li class="bulletList">Dereference <a id="_idIndexMarker1209"/>the pointer to the managed object using <code class="inlineCode">operator*</code> and <code class="inlineCode">operator-&gt;</code>:
        <pre class="programlisting code"><code class="hljs-code">std::shared_ptr&lt;int&gt; pi = std::make_shared&lt;int&gt;(42);
*pi = 21;
std::shared_ptr&lt;foo&gt; pf = std::make_shared&lt;foo&gt;(42, 42.0, "42");
pf-&gt;print();
</code></pre>
</li>
<li class="bulletList">If a <code class="inlineCode">shared_ptr</code> manages an array of objects, <code class="inlineCode">operator[]</code> can be used to access the individual elements of the array. This is only available in C++17:
        <pre class="programlisting code"><code class="hljs-code">std::shared_ptr&lt;int[]&gt; pa1(
 new int[3]{ 1, 2, 3 },
  std::default_delete&lt;int[]&gt;());
for (int i = 0; i &lt; 3; ++i)
  pa1[i] *= 2;
</code></pre>
</li>
<li class="bulletList">To check whether a <code class="inlineCode">shared_ptr</code> could manage an object or not, use the explicit operator <code class="inlineCode">bool</code> or check whether <code class="inlineCode">get() != nullptr</code> (which is what the operator <code class="inlineCode">bool</code> does):
        <pre class="programlisting code"><code class="hljs-code">std::shared_ptr&lt;int&gt; pnull;
if (pnull) std::cout &lt;&lt; "not null" &lt;&lt; '\n';
std::shared_ptr&lt;int&gt; pi(new int(42));
if (pi) std::cout &lt;&lt; "not null" &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">shared_ptr</code> objects can be stored in containers, such as <code class="inlineCode">std::vector</code>:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;std::shared_ptr&lt;foo&gt;&gt; data;
for (int i = 0; i &lt; 5; i++)
  data.push_back(
    std::make_shared&lt;foo&gt;(i, i, std::to_string(i)));
auto pf = std::make_shared&lt;foo&gt;(42, 42.0, "42");
data.push_back(std::move(pf));
assert(!pf);
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">weak_ptr</code> to<a id="_idIndexMarker1210"/> maintain a non-owning reference to a shared object, which can be later accessed through a <code class="inlineCode">shared_ptr</code> constructed from the <code class="inlineCode">weak_ptr</code> object:
        <pre class="programlisting code"><code class="hljs-code">auto sp1 = std::make_shared&lt;int&gt;(42);
assert(sp1.use_count() == 1);
std::weak_ptr&lt;int&gt; wpi = sp1;
assert(sp1.use_count() == 1);
auto sp2 = wpi.lock(); // sp2 type is std::shared_ptr&lt;int&gt;
assert(sp1.use_count() == 2);
assert(sp2.use_count() == 2);
sp1.reset();
assert(sp1.use_count() == 0);
assert(sp2.use_count() == 1);
</code></pre>
</li>
<li class="bulletList">Use the <code class="inlineCode">std::enable_shared_from_this</code> class template as the base class for a type when you need to create <code class="inlineCode">shared_ptr</code> objects for instances that are already managed by another <code class="inlineCode">shared_ptr</code> object:
        <pre class="programlisting code"><code class="hljs-code">struct Apprentice;
struct Master : std::enable_shared_from_this&lt;Master&gt;
{
  ~Master() { std::cout &lt;&lt; "~Master" &lt;&lt; '\n'; }
  void take_apprentice(std::shared_ptr&lt;Apprentice&gt; a);
private:
  std::shared_ptr&lt;Apprentice&gt; apprentice;
};
struct Apprentice
{
  ~Apprentice() { std::cout &lt;&lt; "~Apprentice" &lt;&lt; '\n'; }
  void take_master(std::weak_ptr&lt;Master&gt; m);
private:
  std::weak_ptr&lt;Master&gt; master;
};
void Master::take_apprentice(std::shared_ptr&lt;Apprentice&gt; a)
{
  apprentice = a;
  apprentice-&gt;take_master(shared_from_this());
}
void Apprentice::take_master(std::weak_ptr&lt;Master&gt; m)
{
  master = m;
}
auto m = std::make_shared&lt;Master&gt;();
auto a = std::make_shared&lt;Apprentice&gt;();
m-&gt;take_apprentice(a);
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-621">How it works...</h2>
<p class="normal"><code class="inlineCode">shared_ptr</code> is <a id="_idIndexMarker1211"/>very similar to <code class="inlineCode">unique_ptr</code> in many aspects; however, it serves a different purpose: sharing the ownership of an object or array. Two or more <code class="inlineCode">shared_ptr</code> smart pointers can manage the same dynamically allocated object or array, which is automatically destroyed when the last smart pointer goes out of scope, is assigned a new pointer with <code class="inlineCode">operator=</code>, or is reset with the method <code class="inlineCode">reset()</code>. By default, the object <a id="_idIndexMarker1212"/>is destroyed with <code class="inlineCode">operator delete</code>; however, the user could supply a custom deleter to the constructor, something that is not possible using <code class="inlineCode">std::make_shared()</code>. If <code class="inlineCode">shared_ptr</code> is used to manage an array of objects, a custom deleter must be supplied. In this case, you can use <code class="inlineCode">std::default_delete&lt;T[]&gt;</code>, which is a partial specialization of the <code class="inlineCode">std::default_delete</code> class template that uses <code class="inlineCode">operator delete[]</code> to delete the dynamically allocated array.</p>
<p class="normal">The utility function <code class="inlineCode">std::make_shared()</code> (available since C++11), unlike <code class="inlineCode">std::make_unique()</code>, which has only been available since C++14, should be used to create smart pointers unless you need to provide a custom deleter. The primary reason for this is the same as for <code class="inlineCode">make_unique()</code>: avoiding potential memory leaks in some contexts when an exception is thrown. For more information on this, read the explanation provided on <code class="inlineCode">std::make_unique()</code> in the previous recipe.</p>
<p class="normal">In C++20, a new function, called <code class="inlineCode">std::make_shared_for_overwrite()</code>, has been added. This is similar to <code class="inlineCode">make_shared()</code> except that it default initializes the object or the array of objects. This function can be used in generic code where it’s unknown whether the type template parameter is trivially copyable or not. This function expresses the intent to create a pointer to an object that may not be initialized so that it should be overwritten later.</p>
<p class="normal">Also, as in <a id="_idIndexMarker1213"/>the case of <code class="inlineCode">unique_ptr</code>, a <code class="inlineCode">shared_ptr</code> that manages an object of a <code class="inlineCode">Derived</code> class can be implicitly converted to a <code class="inlineCode">shared_ptr</code> that manages an object of the <code class="inlineCode">Base</code> class. This is possible if the <code class="inlineCode">Derived</code> class is derived from <code class="inlineCode">Base</code>. This implicit conversion is safe only if <code class="inlineCode">Base</code> has a virtual destructor (as all the base classes should have when objects are supposed to be deleted polymorphically through a pointer or reference to the base class); otherwise, undefined behavior is employed. In C++17, several new non-member functions have been added: <code class="inlineCode">std::static_pointer_cast()</code>, <code class="inlineCode">std::dynamic_pointer_cast()</code>, <code class="inlineCode">std::const_pointer_cast()</code>, and <code class="inlineCode">std::reinterpret_pointer_cast()</code>. These apply <code class="inlineCode">static_cast</code>, <code class="inlineCode">dynamic_cast</code>, <code class="inlineCode">const_cast</code>, and <code class="inlineCode">reinterpret_cast</code> to the stored pointer, returning a new <code class="inlineCode">shared_ptr</code> to the designated type.</p>
<p class="normal">In the following example, <code class="inlineCode">Base</code> and <code class="inlineCode">Derived</code> are the same classes we used in the previous recipe:</p>
<pre class="programlisting code"><code class="hljs-code">std::shared_ptr&lt;Derived&gt; pd = std::make_shared&lt;Derived&gt;();
std::shared_ptr&lt;Base&gt; pb = pd;
std::static_pointer_cast&lt;Derived&gt;(pb)-&gt;print();
</code></pre>
<p class="normal">There are situations when you need a smart pointer for a shared object but without it contributing to the shared ownership. Suppose you model a tree structure where a node has references to its children and they are represented by <code class="inlineCode">shared_ptr</code> objects. On the other hand, say a node needs to keep a reference to its parent. If this reference were also <code class="inlineCode">shared_ptr</code>, then it would create circular references and no object would ever be automatically destroyed.</p>
<p class="normal"><code class="inlineCode">weak_ptr</code> is a smart pointer that’s used to break such circular dependencies. It holds a non-owning reference to an object or array managed by a <code class="inlineCode">shared_ptr</code>. <code class="inlineCode">weak_ptr</code> can be created from a <code class="inlineCode">shared_ptr</code> object. In order to access the managed object, you need to get a temporary <code class="inlineCode">shared_ptr</code> object. To do so, we need to use the <code class="inlineCode">lock()</code> method. This method atomically checks whether the referred object still exists and returns either an empty <code class="inlineCode">shared_ptr</code>, if the object no longer exists, or a <code class="inlineCode">shared_ptr</code> that owns the object, if it still exists. Because <code class="inlineCode">weak_ptr</code> is a non-owning smart pointer, the referred object can be destroyed before <code class="inlineCode">weak_ptr</code> goes out of scope or when all the owning <code class="inlineCode">shared_ptr</code> objects <a id="_idIndexMarker1214"/>have been destroyed, reset, or assigned to other pointers. The method <code class="inlineCode">expired()</code> can be used to check whether the referenced object has been destroyed or is still available.</p>
<p class="normal">In the <em class="italic">How to do it...</em> section, the preceding example models a master-apprentice relationship. There is a <code class="inlineCode">Master</code> class and an <code class="inlineCode">Apprentice</code> class. The <code class="inlineCode">Master</code> class has a reference to an <code class="inlineCode">Apprentice</code> class and a method called <code class="inlineCode">take_apprentice()</code> to set the <code class="inlineCode">Apprentice</code> object. The <code class="inlineCode">Apprentice</code> class has a reference to a <code class="inlineCode">Master</code> class and the method <code class="inlineCode">take_master()</code> to set the <code class="inlineCode">Master</code> object. In order to avoid circular dependencies, one of these references must be represented by a <code class="inlineCode">weak_ptr</code>. In the proposed example, the <code class="inlineCode">Master</code> class had a <code class="inlineCode">shared_ptr</code> to own the <code class="inlineCode">Apprentice</code> object, and the <code class="inlineCode">Apprentice</code> class had a <code class="inlineCode">weak_ptr</code> to track a reference to the <code class="inlineCode">Master</code> object. This example, however, is a bit more complex because here, the <code class="inlineCode">Apprentice::take_master()</code> method is called from <code class="inlineCode">Master::take_apprentice()</code> and needs a <code class="inlineCode">weak_ptr&lt;Master&gt;</code>. In order to call it from within the <code class="inlineCode">Master</code> class, we must be able to create a <code class="inlineCode">shared_ptr&lt;Master&gt;</code> in the <code class="inlineCode">Master</code> class, using the <code class="inlineCode">this</code> pointer. The only way to do this in a safe manner is to use <code class="inlineCode">std::enable_shared_from_this</code>.</p>
<p class="normal"><code class="inlineCode">std::enable_shared_from_this</code> is a class template that must be used as a base class for all the classes where you need to create a <code class="inlineCode">shared_ptr</code> for the current object (the <code class="inlineCode">this</code> pointer) when this object is already managed by another <code class="inlineCode">shared_ptr</code>. Its type template parameter must be the class that derives from it, as in the curiously recurring template pattern. It has two methods: <code class="inlineCode">shared_from_this()</code>, which returns a <code class="inlineCode">shared_ptr</code>, which shares the ownership of the <code class="inlineCode">this</code> object, and <code class="inlineCode">weak_from_this()</code>, which returns a <code class="inlineCode">weak_ptr</code>, which shares a non-owning reference to the <code class="inlineCode">this</code> object. The latter method is only available in C++17. These methods can be called only on an object that is managed by an existing <code class="inlineCode">shared_ptr</code>; otherwise, they throw a <code class="inlineCode">std::bad_weak_ptr</code> exception, as of C++17. Prior to C++17, the behavior was undefined.</p>
<p class="normal">Not using <code class="inlineCode">std::enable_shared_from_this</code> and creating a <code class="inlineCode">shared_ptr&lt;T&gt;(this)</code> directly would lead to having multiple <code class="inlineCode">shared_ptr</code> objects managing the same object independently, without knowing each other. When this happens, the object ends up being destroyed multiple times by different <code class="inlineCode">shared_ptr</code> objects.</p>
<h2 class="heading-2" id="_idParaDest-622">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using unique_ptr to uniquely own a memory resource</em>, to learn about the <code class="inlineCode">std::unique_ptr</code> class, which represents a smart pointer that owns and manages another object or array of objects allocated on the heap</li>
</ul>
<h1 class="heading-1" id="_idParaDest-623">Consistent comparison with the operator &lt;=&gt;</h1>
<p class="normal">The <a id="_idIndexMarker1215"/>C++ language defines six relational operators that perform comparison: <code class="inlineCode">==</code>, <code class="inlineCode">!=</code>, <code class="inlineCode">&lt;</code>, <code class="inlineCode">&lt;=</code>, <code class="inlineCode">&gt;</code>, and <code class="inlineCode">&gt;=</code>. Although <code class="inlineCode">!=</code> can be implemented in terms of <code class="inlineCode">==</code>, and <code class="inlineCode">&lt;=</code>, <code class="inlineCode">&gt;=</code>, and <code class="inlineCode">&gt;</code> in terms of <code class="inlineCode">&lt;</code>, you still have to implement both <code class="inlineCode">==</code> and <code class="inlineCode">!=</code> if you want your user-defined type to support equality comparison, and <code class="inlineCode">&lt;</code>, <code class="inlineCode">&lt;=</code>, <code class="inlineCode">&gt;</code>, and <code class="inlineCode">&gt;=</code> if you want it to support ordering.</p>
<p class="normal">That means 6 functions if<a id="_idIndexMarker1216"/> you want objects of your type—let’s call it <code class="inlineCode">T</code>—to be comparable, 12 if you want them to be comparable with another type, <code class="inlineCode">U</code>, 18 if you also want values of a <code class="inlineCode">U</code> type to be comparable with your <code class="inlineCode">T</code> type, and so on. The new C++20 standard reduces this number to either one or two, or multiple of these (depending on the comparison with other types) by introducing a new comparison operator, called <em class="italic">the three-way comparison</em>, which<a id="_idIndexMarker1217"/> is designated with the symbol <code class="inlineCode">&lt;=&gt;</code>, for which reason it is popularly known <a id="_idIndexMarker1218"/>as the <em class="italic">spaceship operator</em>. This new operator helps us write less code, better describe the strength of relations, and avoid possible performance issues that come from manually implementing comparison operators in terms of others.</p>
<h2 class="heading-2" id="_idParaDest-624">Getting ready</h2>
<p class="normal">It is necessary to include the header <code class="inlineCode">&lt;compare&gt;</code> when defining or implementing the three-way comparison operator. This new C++20 header is part of the standard general utility library and provides classes, functions, and concepts for implementing comparison.</p>
<h2 class="heading-2" id="_idParaDest-625">How to do it…</h2>
<p class="normal">To optimally implement comparison in C++20, do the following:</p>
<ul>
<li class="bulletList">If you only want your type to support equality comparison (both <code class="inlineCode">==</code> and <code class="inlineCode">!=</code>), implement only the <code class="inlineCode">==</code> operator and return a <code class="inlineCode">bool</code>. You can default the implementation so that the compiler performs a member-wise comparison:
        <pre class="programlisting code"><code class="hljs-code">class foo
{
  int value;
public:
  foo(int const v):value(v){}
  bool operator==(foo const&amp;) const = default;
};
</code></pre>
</li>
<li class="bulletList">If you <a id="_idIndexMarker1219"/>want your type to support both equality and ordering and the default member-wise comparison will do, then only define the <code class="inlineCode">&lt;=&gt;</code> operator, returning <code class="inlineCode">auto</code>, and default its implementation:
        <pre class="programlisting code"><code class="hljs-code">class foo
{
  int value;
public:
  foo(int const v) :value(v) {}
  auto operator&lt;=&gt;(foo const&amp;) const = default;
};
</code></pre>
</li>
<li class="bulletList">If you want your type to support both equality and ordering and you need to perform custom comparison, then implement both the <code class="inlineCode">==</code> operator (for equality) and the <code class="inlineCode">&lt;=&gt;</code> operator (for ordering):
        <pre class="programlisting code"><code class="hljs-code">class foo
{
  int value;
public:
  foo(int const v) :value(v) {}
  bool operator==(foo const&amp; other) const
  { return value == other.value; }
  auto operator&lt;=&gt;(foo const&amp; other) const
  { return value &lt;=&gt; other.value; }
};
</code></pre>
</li>
</ul>
<p class="normal">When implementing the three-way comparison operator, follow these guidelines:</p>
<ul>
<li class="bulletList">Only implement the three-way comparison operator but always use the two-way comparison operators <code class="inlineCode">&lt;</code>, <code class="inlineCode">&lt;=</code>, <code class="inlineCode">&gt;</code>, and <code class="inlineCode">&gt;=</code> when comparing values.</li>
<li class="bulletList">Implement <a id="_idIndexMarker1220"/>the three-way comparison operator as a member function, even if you want the first operand of a comparison to be of a type other than your class.</li>
<li class="bulletList">Implement the three-way comparison operator as non-member functions only if you want implicit conversion on both arguments (that means comparing two objects, neither of which is of your class).</li>
</ul>
<h2 class="heading-2" id="_idParaDest-626">How it works…</h2>
<p class="normal">The new three-way comparison operator is similar to the <code class="inlineCode">memcmp()</code>/<code class="inlineCode">strcmp()</code> C functions and the <code class="inlineCode">std::string::compare()</code> method. These functions take two arguments and return an integer value that is smaller than zero if the first is less than the second, zero if they are equal, or greater than zero if the first argument is greater than the second. The three-way comparison operator does not return an integer but a value of a comparison category type.</p>
<p class="normal">This can be one of the following:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::strong_ordering</code> represents the result of a three-way comparison that supports all six relational operators, does not allow incomparable values (which means that at least one of <code class="inlineCode">a &lt; b</code>, <code class="inlineCode">a == b</code>, and <code class="inlineCode">a &gt; b</code> must be true), and implies substitutability. This is a property such that if <code class="inlineCode">a == b</code> and <code class="inlineCode">f</code> is a function that reads only comparison-salient state (accessible via the argument’s public constant members), then <code class="inlineCode">f(a) == f(b)</code>.</li>
<li class="bulletList"><code class="inlineCode">std::weak_ordering</code> supports all the six relational operators, does not support incomparable values (which means that none of <code class="inlineCode">a &lt; b</code>, <code class="inlineCode">a == b</code>, and <code class="inlineCode">a &gt; b</code> could be true), but also does not imply substitutability. A typical example of a type that defines weak ordering is a case-insensitive string type.</li>
<li class="bulletList"><code class="inlineCode">std::partial_ordering</code> supports all six relational operators but does not imply substitutability and has a value that might not be comparable (for instance, a floating-point <code class="inlineCode">NaN</code> cannot be compared to any other value).</li>
</ul>
<p class="normal">The <code class="inlineCode">std::strong_ordering</code> type is the strongest of all these category types. It is not implicitly convertible from any other category, but it implicitly converts to both <code class="inlineCode">std::weak_ordering</code> and <code class="inlineCode">std::partial_ordering</code>. <code class="inlineCode">std::weak_ordering</code> is also implicitly convertible to <code class="inlineCode">std::partial_ordering</code>. We’ve summarized all these properties in the following table:</p>
<table class="table-container" id="table002-5">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Category</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Operators</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Substitutability</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Comparable values</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Implicit conversion</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::strong_ordering</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">==</code>, <code class="inlineCode">!=</code>, <code class="inlineCode">&lt;</code>, <code class="inlineCode">&lt;=</code>, <code class="inlineCode">&gt;</code>, <code class="inlineCode">&gt;=</code></p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal"><img alt="" src="img/B21549_09_001.png"/></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::weak_ordering</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">==</code>, <code class="inlineCode">!=</code>, <code class="inlineCode">&lt;</code>, <code class="inlineCode">&lt;=</code>, <code class="inlineCode">&gt;</code>, <code class="inlineCode">&gt;=</code></p>
</td>
<td class="table-cell">
<p class="normal">No</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal"><img alt="" src="img/B21549_09_001.png"/></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::partial_ordering</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">==</code>, <code class="inlineCode">!=</code>, <code class="inlineCode">&lt;</code>, <code class="inlineCode">&lt;=</code>, <code class="inlineCode">&gt;</code>, <code class="inlineCode">&gt;=</code></p>
</td>
<td class="table-cell">
<p class="normal">No</p>
</td>
<td class="table-cell">
<p class="normal">No</p>
</td>
<td class="table-cell"/>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 9.2: Properties of the category types</p>
<p class="normal">These <a id="_idIndexMarker1221"/>comparison categories have values that are implicitly comparable with literal zero (but not with an integer variable that is zero). Their values are listed in the following table:</p>
<table class="table-container" id="table003-5">
<tbody>
<tr>
<td class="table-cell" rowspan="2">
<p class="normal"><strong class="keyWord">Category</strong></p>
</td>
<td class="table-cell" colspan="3">
<p class="normal"><strong class="keyWord">Numeric values</strong></p>
</td>
<td class="table-cell" rowspan="2">
<p class="normal"><strong class="keyWord">Non-numeric values</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">-1</p>
</td>
<td class="table-cell">
<p class="normal">0</p>
</td>
<td class="table-cell">
<p class="normal">1</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">strong_ordering</code></p>
</td>
<td class="table-cell">
<p class="normal">less</p>
</td>
<td class="table-cell">
<p class="normal">equal</p>
<p class="normal">equivalent</p>
</td>
<td class="table-cell">
<p class="normal">greater</p>
</td>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">weak_ordering</code></p>
</td>
<td class="table-cell">
<p class="normal">less</p>
</td>
<td class="table-cell">
<p class="normal">equivalent</p>
</td>
<td class="table-cell">
<p class="normal">greater</p>
</td>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">partial_ordering</code></p>
</td>
<td class="table-cell">
<p class="normal">less</p>
</td>
<td class="table-cell">
<p class="normal">equivalent</p>
</td>
<td class="table-cell">
<p class="normal">greater</p>
</td>
<td class="table-cell">
<p class="normal">unordered</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 9.3: The values of the comparison categories that are implicitly comparable to literal zero</p>
<p class="normal">To better understand how this works, let’s look at the following example:</p>
<pre class="programlisting code"><code class="hljs-code">class cost_unit_t
{
  // data members
public:
  std::strong_ordering operator&lt;=&gt;(cost_unit_t const &amp; other) const noexcept = default;
};
class project_t : public cost_unit_t
{
  int         id;
  int         type;
  std::string name;
public:
  bool operator==(project_t const&amp; other) const noexcept
  {
    return (cost_unit_t&amp;)(*this) == (cost_unit_t&amp;)other &amp;&amp;
           name == other.name &amp;&amp;
           type == other.type &amp;&amp;
           id == other.id;
  }
  std::strong_ordering operator&lt;=&gt;(project_t const &amp; other) const noexcept
  {
    // compare the base class members
if (auto cmp = (cost_unit_t&amp;)(*this) &lt;=&gt; (cost_unit_t&amp;)other;
        cmp != 0)
      return cmp;
    // compare this class members in custom order
if (auto cmp = name.compare(other.name); cmp != 0)
      return cmp &lt; 0 ? std::strong_ordering::less :
                       std::strong_ordering::greater;
    if (auto cmp = type &lt;=&gt; other.type; cmp != 0)
      return cmp;
    return id &lt;=&gt; other.id;
  }
};
</code></pre>
<p class="normal">Here, <code class="inlineCode">cost_unit_t</code> is a base <a id="_idIndexMarker1222"/>class that contains some (unspecified) data members and defines the <code class="inlineCode">&lt;=&gt;</code> operator, although it is default-implemented by the compiler. This means that the compiler will also provide the <code class="inlineCode">==</code> and <code class="inlineCode">!=</code> operators, not just <code class="inlineCode">&lt;</code>, <code class="inlineCode">&lt;=</code>, <code class="inlineCode">&gt;</code>, and <code class="inlineCode">&gt;=</code>. This class is derived by <code class="inlineCode">project_t</code>, which contains several data fields: an identifier for the project, a type, and a name. However, for this type, we cannot default the implementation of the operators, because we do not want to compare the fields member-wise, but in a custom order: first the name, then the type, and lastly the identifier. In this case, we implement both the <code class="inlineCode">==</code> operator, which returns a <code class="inlineCode">bool</code> and tests the member fields for equality, and the <code class="inlineCode">&lt;=&gt;</code> operator, which returns <code class="inlineCode">std::strong_ordering</code> and uses the <code class="inlineCode">&lt;=&gt;</code> operator itself to compare the values of its two arguments.</p>
<pre>employee_t</code> that models employees in a company. An employee can have a manager, and an employee who is a manager has people that they manage. Conceptually, such a type could look as follows:</pre>
<pre class="programlisting code"><code class="hljs-code">struct employee_t
{
  bool is_managed_by(employee_t const&amp;) const { /* ... */ }
  bool is_manager_of(employee_t const&amp;) const { /* ... */ }
  bool is_same(employee_t const&amp;) const { /* ... */ }
  bool operator==(employee_t const &amp; other) const
  {
    return is_same(other);
  }
  std::partial_ordering operator&lt;=&gt;(employee_t const&amp; other) const noexcept
  {
    if (is_same(other))
      return std::partial_ordering::equivalent;
    if (is_managed_by(other))
      return std::partial_ordering::less;
    if (is_manager_of(other))
      return std::partial_ordering::greater;
    return std::partial_ordering::unordered;
  }
};
</code></pre>
<p class="normal">The methods <code class="inlineCode">is_same()</code>, <code class="inlineCode">is_manager_of()</code>, and <code class="inlineCode">is_managed_by()</code> return the relationship of two employees. However, it is possible there are employees with no relationship; for instance, employees in different teams, or a team without a manager-subordinate structure. Here, we can implement equality and ordering. However, since we cannot compare all employees with each other, the <code class="inlineCode">&lt;=&gt;</code> operator must return a <code class="inlineCode">std::partial_ordering</code> value. The return value is <code class="inlineCode">partial_ordering::equivalent</code> if the values represent the same employee, <code class="inlineCode">partial_ordering::less</code> if the current employee is managed by the supplied one, <code class="inlineCode">partial_ordering::greater</code> if the current employee is the manager of the supplied one, and <code class="inlineCode">partial_ordering::unorder</code> in all other cases.</p>
<p class="normal">Let’s see<a id="_idIndexMarker1224"/> one more example to understand how the three-way comparison operator works. In the following sample, the <code class="inlineCode">ipv4</code> class models an IP version 4 address. It supports comparison with both other objects of the <code class="inlineCode">ipv4</code> type but also <code class="inlineCode">unsigned long</code> values (because there is a <code class="inlineCode">to_unlong()</code> method that converts the IP address into a 32-bit unsigned integral value):</p>
<pre class="programlisting code"><code class="hljs-code">struct ipv4
{
  explicit ipv4(unsigned char const a=0, unsigned char const b=0,
 unsigned char const c=0, unsigned char const d=0) noexcept :
    data{ a,b,c,d }
  {}
  unsigned long to_ulong() const noexcept
 {
    return
      (static_cast&lt;unsigned long&gt;(data[0]) &lt;&lt; 24) |
      (static_cast&lt;unsigned long&gt;(data[1]) &lt;&lt; 16) |
      (static_cast&lt;unsigned long&gt;(data[2]) &lt;&lt; 8) |
      static_cast&lt;unsigned long&gt;(data[3]);
  }
  auto operator&lt;=&gt;(ipv4 const&amp;) const noexcept = default;
  bool operator==(unsigned long const other) const noexcept
  {
    return to_ulong() == other;
  }
  std::strong_ordering
  operator&lt;=&gt;(unsigned long const other) const noexcept
  {
    return to_ulong() &lt;=&gt; other;
  }
private:
  std::array&lt;unsigned char, 4&gt; data;
};
</code></pre>
<p class="normal">In this example, we overloaded the <code class="inlineCode">&lt;=&gt;</code> operator and allowed it to be default implemented. But we also explicitly implemented overloads for <code class="inlineCode">operator==</code> and <code class="inlineCode">operator&lt;=&gt;</code>, which compare an <code class="inlineCode">ipv4</code> object with an <code class="inlineCode">unsigned long</code> value. Because of these operators, we can write any of the following:</p>
<pre class="programlisting code"><code class="hljs-code">ipv4 ip(127, 0, 0, 1);
if(ip == 0x7F000001) {}
if(ip != 0x7F000001) {}
if(0x7F000001 == ip) {}
if(0x7F000001 != ip) {}
if(ip &lt; 0x7F000001)  {}
if(0x7F000001 &lt; ip)  {}
</code></pre>
<p class="normal">There <a id="_idIndexMarker1225"/>are two things to notice here: the first is that although we only overloaded the <code class="inlineCode">==</code> operator, we can also use the <code class="inlineCode">!=</code> operator, and second, although we overloaded the <code class="inlineCode">==</code> operator and the <code class="inlineCode">&lt;=&gt;</code> operator to compare <code class="inlineCode">ipv4</code> values to <code class="inlineCode">unsigned long</code> values, we can also compare <code class="inlineCode">unsigned long</code> values to <code class="inlineCode">ipv4</code> values. This is because the compiler performs symmetrical overload resolution. That means that for an expression <code class="inlineCode">a@b</code> where <code class="inlineCode">@</code> is a two-way relational operator, it performs name lookup for <code class="inlineCode">a@b</code>, <code class="inlineCode">a&lt;=&gt;b</code>, and <code class="inlineCode">b&lt;=&gt;a</code>. The following table shows the list of all possible transformations of the relational operators:</p>
<table class="table-container" id="table004-4">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">a == b</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">b == a</code></p>
</td>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">a != b</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">!(a == b)</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">!(b == a)</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">a &lt;=&gt; b</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">0 &lt;=&gt; (b &lt;=&gt; a)</code></p>
</td>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">a &lt; b</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">(a &lt;=&gt; b) &lt; 0</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">0 &gt; (b &lt;=&gt; a)</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">a &lt;= b</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">(a &lt;=&gt; b) &lt;= 0</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">0 &gt;= (b &lt;=&gt; a)</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">a &gt; b</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">(a &lt;=&gt; b) &gt; 0</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">0 &lt; (b &lt;=&gt; a)</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">a &gt;= b</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">(a &lt;=&gt; b) &gt;= 0</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">0 &lt;= (b &lt;=&gt; a)</code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 9.4: The possible transformations of the relational operators</p>
<p class="normal">This greatly reduces the number of overloads you must explicitly provide for supporting comparison in different forms. The three-way comparison operator can be implemented either as a member or as a non-member function. In general, you should prefer the member implementation.</p>
<p class="normal">The non-member form should be used only when you want implicit conversion on both arguments. The following shows an example:</p>
<pre class="programlisting code"><code class="hljs-code">struct A { int i; };
struct B
{
  B(A a) : i(a.i) { }
  int i;
};
inline auto
operator&lt;=&gt;(B const&amp; lhs, B const&amp; rhs) noexcept
{
  return lhs.i &lt;=&gt; rhs.i;
}
assert(A{ 2 } &gt; A{ 1 });
</code></pre>
<p class="normal">Although<a id="_idIndexMarker1226"/> the <code class="inlineCode">&lt;=&gt;</code> operator is defined for the type <code class="inlineCode">B</code>, because it is a non-member and because <code class="inlineCode">A</code> can be implicitly converted to <code class="inlineCode">B</code>, we can perform a comparison on objects of the <code class="inlineCode">A</code> type.</p>
<h2 class="heading-2" id="_idParaDest-627">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 1</em>, <em class="italic">Simplifying code with class template argument deduction</em>, to learn how to use class templates without explicitly specifying template arguments</li>
<li class="bulletList"><em class="italic">Ensuring constant correctness for a program</em>, to explore the benefits of constant correctness and how to achieve it</li>
</ul>
<h1 class="heading-1" id="_idParaDest-628">Comparing signed and unsigned integers safely</h1>
<p class="normal">The C++ language <a id="_idIndexMarker1227"/>features a variety of integral types: <code class="inlineCode">short</code>, <code class="inlineCode">int</code>, <code class="inlineCode">long</code>, and <code class="inlineCode">long long</code>, as well as their unsigned counterparts <code class="inlineCode">unsigned short</code>, <code class="inlineCode">unsigned int</code>, <code class="inlineCode">unsigned long</code>, and <code class="inlineCode">unsigned long long</code>. In C++11, fixed-width<a id="_idIndexMarker1228"/> integer types were introduced, such as <code class="inlineCode">int32_t</code> and <code class="inlineCode">uint32_t</code>, and many similar others. Apart from these, there are also the types <code class="inlineCode">char</code>, <code class="inlineCode">signed char</code>, <code class="inlineCode">unsigned char</code>, <code class="inlineCode">wchar_t</code>, <code class="inlineCode">char8_t</code>, <code class="inlineCode">char16_t</code>, and <code class="inlineCode">char32_t</code>, although these are not supposed to store numbers but characters. Moreover, the type <code class="inlineCode">bool</code> used for storing the values <code class="inlineCode">true</code> or <code class="inlineCode">false</code> is also an integral type. The comparison of values of these types is a common operation but comparing signed and unsigned values is error-prone. Without some compiler-specific switches to flag these as warnings or errors, you can perform these operations and get unexpected results. For instance, the comparison <code class="inlineCode">-1 &lt; 42u</code> (comparing signed -1 with unsigned 42) would yield <code class="inlineCode">false</code>. The C++20 standard provides a set of <a id="_idIndexMarker1229"/>functions for performing a safe comparison of signed and unsigned values, which we will learn about in this recipe.</p>
<h2 class="heading-2" id="_idParaDest-629">How to do it…</h2>
<p class="normal">To perform a <a id="_idIndexMarker1230"/>safe comparison of signed and unsigned integer values that ensures negative signed integers always compare less than unsigned values, use one of the following comparison functions from the <code class="inlineCode">&lt;utility&gt;</code> header:</p>
<table class="table-container" id="table005-3">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Function</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Corresponding comparison operator</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::cmp_equal</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">==</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::cmp_not_equal</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">!=</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::cmp_less</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&lt;</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::cmp_less_equal</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&lt;=</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::cmp_greater</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&gt;</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::cmp_greater_equal</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">&gt;=</code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 9.5: New C++20 comparison functions and their corresponding comparison operator</p>
<p class="normal">The following snippet shows an example:</p>
<pre class="programlisting code"><code class="hljs-code">int a = -1;
unsigned int b = 42;
if (std::cmp_less(a, b)) // a is less than b so this returns true
{
   std::cout &lt;&lt; "-1 &lt; 42\n";
}
else
{
   std::cout &lt;&lt; "-1 &gt;= 42\n";
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-630">How it works…</h2>
<p class="normal">Comparing two signed or two unsigned values is straightforward but comparing a signed and unsigned integer is error prone. When such a comparison occurs, the signed value is converted to unsigned. For instance, integer -1 becomes 4294967295. The reason for this is that signed numbers are stored in memory as follows:</p>
<ul>
<li class="bulletList">The most significant bit indicates the sign: 0 for positive numbers and 1 for negative ones.</li>
<li class="bulletList">Negative values are stored by inverting the bits of the positive number and adding 1.</li>
</ul>
<p class="normal">This <a id="_idIndexMarker1231"/>representation is known as the <strong class="keyWord">two’s complement</strong>. For instance, assuming an 8-bit signed representation, value 1 is stored as <code class="inlineCode">0000001</code>, but the <a id="_idIndexMarker1232"/>value -1 is stored as <code class="inlineCode">11111111</code>. This is because the 7 least significant bits of the positive number are <code class="inlineCode">0000001</code>, which inverted are <code class="inlineCode">1111110</code>. By adding 1, we get <code class="inlineCode">1111111</code>. Together with the sign bit this makes <code class="inlineCode">11111111</code>. For 32-bit signed integers, the value -1 is stored as <code class="inlineCode">11111111'11111111'11111111'11111111</code>.</p>
<pre>signed</code> -1 and <code class="inlineCode">unsigned</code> 42 will print <em class="italic">-1 &gt;= 42</em> because the actual comparison occurs between <code class="inlineCode">unsigned</code> 4294967295 and <code class="inlineCode">unsigned</code> 42.</pre>
<pre class="programlisting code"><code class="hljs-code">int a = -1;
unsigned int b = 42;
if(a &lt; b)
{
   std::cout &lt;&lt; "-1 &lt; 42\n";
}
else
{
   std::cout &lt;&lt; "-1 &gt;= 42\n";
}
</code></pre>
<p class="normal">This is true for all the six equality (<code class="inlineCode">==</code>, <code class="inlineCode">!=</code>) and inequality (<code class="inlineCode">&lt;</code>, <code class="inlineCode">&lt;=</code>, <code class="inlineCode">&gt;</code>, <code class="inlineCode">&gt;=</code>) operators. To get the correct result, we need to check whether the signed values are negative. The correct condition for the <code class="inlineCode">if</code> statement shown previously is the following:</p>
<pre class="programlisting code"><code class="hljs-code">if(a &lt; 0 || static_cast&lt;unsigned int&gt;(a) &lt; b)
</code></pre>
<p class="normal">To ease<a id="_idIndexMarker1233"/> the writing of such expressions, the C++20 standard has introduced the six functions listed in <em class="italic">Table 9.5</em> that should be used as <a id="_idIndexMarker1234"/>replacements for the corresponding operator when comparing signed and unsigned integers.</p>
<pre class="programlisting code"><code class="hljs-code">if(std::cmp_less(a, b))
{
   std::cout &lt;&lt; "-1 &lt; 42\n";
}
else
{
   std::cout &lt;&lt; "-1 &gt;= 42\n";
}
</code></pre>
<p class="normal">A possible implementation for the <code class="inlineCode">std::cmp_less()</code> function is shown in the next snippet:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;class T, class U&gt;
constexpr bool cmp_less(T t, U u) noexcept
{
    if constexpr (std::is_signed_v&lt;T&gt; == std::is_signed_v&lt;U&gt;)
 return t &lt; u;
    else if constexpr (std::is_signed_v&lt;T&gt;)
        return t &lt; 0 || std::make_unsigned_t&lt;T&gt;(t) &lt; u;
    else
return u &gt;= 0 &amp;&amp; t &lt; std::make_unsigned_t&lt;U&gt;(u);
}
</code></pre>
<p class="normal">What this does is the following:</p>
<ul>
<li class="bulletList">If both arguments are signed, it uses the built-in <code class="inlineCode">&lt;</code> comparison operator to compare them.</li>
<li class="bulletList">If the first argument is signed and the second is unsigned, then it checks whether the first is native (a negative value is always less than a positive one) or compares the first argument cast to unsigned with the second argument using the built-in operator <code class="inlineCode">&lt;</code>.</li>
<li class="bulletList">If the first argument is unsigned, the second can be either signed or unsigned. The first argument can only be less than the second if the second is positive and the first is less than the second cast as unsigned.</li>
</ul>
<p class="normal">When you <a id="_idIndexMarker1235"/>use these functions, keep in mind that they only work for:</p>
<ul>
<li class="bulletList"><code class="inlineCode">short</code>, <code class="inlineCode">int</code>, <code class="inlineCode">long</code>, <code class="inlineCode">long long</code>, and their unsigned counterparts</li>
<li class="bulletList">Fixed-width integer types such as <code class="inlineCode">int32_t</code>, <code class="inlineCode">int_least32_t</code>, <code class="inlineCode">int_fast32_t</code> and their unsigned counterparts</li>
<li class="bulletList">Extended integer types (which are compiler-specific types such as <code class="inlineCode">__int64</code> or <code class="inlineCode">__int128</code> and their unsigned counterparts that most compilers support)</li>
</ul>
<p class="normal">The next<a id="_idIndexMarker1236"/> snippet provides an example for using extended types (in this case Microsoft specific) and standard fixed with integer types, respectively.</p>
<pre class="programlisting code"><code class="hljs-code">__int64 a = -1;
unsigned __int64 b = 42;
if (std::cmp_less(a, b))  // OK
{ }
int32_t  a = -1;
uint32_t b = 42;
if (std::cmp_less(a, b))  // OK
{ }
</code></pre>
<p class="normal">However, you cannot use them to compare enums, <code class="inlineCode">std::byte</code>, <code class="inlineCode">char</code>, <code class="inlineCode">char8_t</code>, <code class="inlineCode">char16_t</code>, <code class="inlineCode">char32_t</code>, <code class="inlineCode">wchar_t</code>, and <code class="inlineCode">bool</code>. In this case, you would get a compiler error: </p>
<pre class="programlisting code"><code class="hljs-code">if (std::cmp_equal(true, 1)) // error
{ }
</code></pre>
<h2 class="heading-2" id="_idParaDest-631">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 2</em>, <em class="italic">Understanding the various numeric types</em>, to learn about the available integral and floating-point types</li>
<li class="bulletList"><em class="italic">Performing correct type casts</em>, to learn the proper way of performing type casts in C++</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="Chapter_09.xhtml">https://discord.gg/7xRaTCeEhx</a></p>
<p class="normal"><img alt="" src="img/QR_Code2659294082093549796.png"/></p>
</div>
</body></html>