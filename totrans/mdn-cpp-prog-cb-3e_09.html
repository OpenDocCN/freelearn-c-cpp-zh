<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer142">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 class="chapterTitle" id="_idParaDest-566"><span class="koboSpan" id="kobo.2.1">Robustness and Performance</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">C++ is often the first choice when it comes to selecting an object-oriented programming language with performance and flexibility as key goals. </span><span class="koboSpan" id="kobo.3.2">Modern C++ provides language and library features, such as rvalue references, move semantics, and smart pointers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">When combined with good practices for exception handling, constant correctness, type-safe conversions, resource allocation, and releasing, C++ enables developers to write better, more robust, and performant code. </span><span class="koboSpan" id="kobo.4.2">This chapter’s recipes address all of these essential topics.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5.1">This chapter includes the following recipes:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6.1">Using exceptions for error handling</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.8.1">noexcept</span></code><span class="koboSpan" id="kobo.9.1"> for functions that do not throw exceptions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">Ensuring constant correctness for a program</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Creating compile-time constant expressions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Creating immediate functions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Optimizing code in constant-evaluated contexts</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Using virtual function calls in constant expressions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Performing correct type casts</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Implementing move semantics</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.18.1">unique_ptr</span></code><span class="koboSpan" id="kobo.19.1"> to uniquely own a memory resource</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.21.1">shared_ptr</span></code><span class="koboSpan" id="kobo.22.1"> to share a memory resource</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.23.1">Consistent comparison with the operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.24.1">&lt;=&gt;</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.25.1">Comparing signed and unsigned integers safely</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.26.1">We will start this chapter with a couple of recipes that deal with exceptions.</span></p>
<h1 class="heading-1" id="_idParaDest-567"><span class="koboSpan" id="kobo.27.1">Using exceptions for error handling</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.28.1">Exceptions are </span><a id="_idIndexMarker1111"/><span class="koboSpan" id="kobo.29.1">responses to exceptional circumstances that can appear when a program is running. </span><span class="koboSpan" id="kobo.29.2">They enable the transfer of the control flow to another part</span><a id="_idIndexMarker1112"/><span class="koboSpan" id="kobo.30.1"> of the program. </span><span class="koboSpan" id="kobo.30.2">Exceptions are a mechanism for simpler and more robust error handling, as opposed to returning error codes, which could greatly complicate and clutter the code. </span><span class="koboSpan" id="kobo.30.3">In this recipe, we will look at some key aspects related to throwing and handling exceptions.</span></p>
<h2 class="heading-2" id="_idParaDest-568"><span class="koboSpan" id="kobo.31.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.32.1">This recipe requires you to have basic knowledge of the mechanisms of throwing exceptions (using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.33.1">throw</span></code><span class="koboSpan" id="kobo.34.1"> statement) and catching exceptions (using </span><code class="inlineCode"><span class="koboSpan" id="kobo.35.1">try...catch</span></code><span class="koboSpan" id="kobo.36.1"> blocks). </span><span class="koboSpan" id="kobo.36.2">This recipe is focused on good practices around exceptions and not on the details of the exception mechanism in the C++ language.</span></p>
<h2 class="heading-2" id="_idParaDest-569"><span class="koboSpan" id="kobo.37.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.38.1">Use the following practices to deal with exceptions:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.39.1">Throw exceptions by value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.40.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.41.1">throwing_func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.42.1">()</span></span><span class="koboSpan" id="kobo.43.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.44.1">throw</span></span><span class="koboSpan" id="kobo.45.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.46.1">runtime_error</span></span><span class="koboSpan" id="kobo.47.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.48.1">"timed out"</span></span><span class="koboSpan" id="kobo.49.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.50.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.51.1">another_throwing_func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.52.1">()</span></span><span class="koboSpan" id="kobo.53.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.54.1">throw</span></span><span class="koboSpan" id="kobo.55.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.56.1">system_error</span></span><span class="koboSpan" id="kobo.57.1">(
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.58.1">make_error_code</span></span><span class="koboSpan" id="kobo.59.1">(std::errc::timed_out));
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.60.1">Catch exceptions by reference, or in most cases, by constant reference:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.61.1">try</span></span><span class="koboSpan" id="kobo.62.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.63.1">throwing_func</span></span><span class="koboSpan" id="kobo.64.1">(); // throws std::runtime_error
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.65.1">catch</span></span><span class="koboSpan" id="kobo.66.1"> (std::exception </span><span class="hljs-type"><span class="koboSpan" id="kobo.67.1">const</span></span><span class="koboSpan" id="kobo.68.1"> &amp; e)
{
  std::cout &lt;&lt; e.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.69.1">what</span></span><span class="koboSpan" id="kobo.70.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.71.1">'\n'</span></span><span class="koboSpan" id="kobo.72.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.73.1">Order </span><code class="inlineCode"><span class="koboSpan" id="kobo.74.1">catch</span></code><span class="koboSpan" id="kobo.75.1"> statements from the most derived class to the base class of the hierarchy</span><a id="_idIndexMarker1113"/><span class="koboSpan" id="kobo.76.1"> when catching multiple exceptions from a class hierarchy:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.77.1">auto</span></span><span class="koboSpan" id="kobo.78.1"> exprint = [](std::exception </span><span class="hljs-type"><span class="koboSpan" id="kobo.79.1">const</span></span><span class="koboSpan" id="kobo.80.1"> &amp; e)
{
  std::cout &lt;&lt; e.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.81.1">what</span></span><span class="koboSpan" id="kobo.82.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.83.1">'\n'</span></span><span class="koboSpan" id="kobo.84.1">;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.85.1">try</span></span><span class="koboSpan" id="kobo.86.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.87.1">another_throwing_func</span></span><span class="koboSpan" id="kobo.88.1">(); // throws std::system_error
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.89.1">                           // 1st catch statements catches it</span></span><span class="koboSpan" id="kobo.90.1">
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.91.1">catch</span></span><span class="koboSpan" id="kobo.92.1"> (std::system_error </span><span class="hljs-type"><span class="koboSpan" id="kobo.93.1">const</span></span><span class="koboSpan" id="kobo.94.1"> &amp; e)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.95.1">exprint</span></span><span class="koboSpan" id="kobo.96.1">(e);
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.97.1">catch</span></span><span class="koboSpan" id="kobo.98.1"> (std::runtime_error </span><span class="hljs-type"><span class="koboSpan" id="kobo.99.1">const</span></span><span class="koboSpan" id="kobo.100.1"> &amp; e)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.101.1">exprint</span></span><span class="koboSpan" id="kobo.102.1">(e);
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.103.1">catch</span></span><span class="koboSpan" id="kobo.104.1"> (std::exception </span><span class="hljs-type"><span class="koboSpan" id="kobo.105.1">const</span></span><span class="koboSpan" id="kobo.106.1"> &amp; e)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.107.1">exprint</span></span><span class="koboSpan" id="kobo.108.1">(e);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.109.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.110.1">catch(...)</span></code><span class="koboSpan" id="kobo.111.1"> to catch all exceptions, regardless of their type:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.112.1">try</span></span><span class="koboSpan" id="kobo.113.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.114.1">throwing_func</span></span><span class="koboSpan" id="kobo.115.1">();
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.116.1">catch</span></span><span class="koboSpan" id="kobo.117.1"> (std::exception </span><span class="hljs-type"><span class="koboSpan" id="kobo.118.1">const</span></span><span class="koboSpan" id="kobo.119.1"> &amp; e)
{
  std::cout &lt;&lt; e.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.120.1">what</span></span><span class="koboSpan" id="kobo.121.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.122.1">'\n'</span></span><span class="koboSpan" id="kobo.123.1">;
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.124.1">catch</span></span><span class="koboSpan" id="kobo.125.1"> (...)
{
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.126.1">"unknown exception"</span></span><span class="koboSpan" id="kobo.127.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.128.1">'\n'</span></span><span class="koboSpan" id="kobo.129.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.130.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.131.1">throw;</span></code><span class="koboSpan" id="kobo.132.1"> to rethrow the current exception. </span><span class="koboSpan" id="kobo.132.2">This can be used to create a single exception-handling function for multiple exceptions.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.133.1">Throw the exception object (for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.134.1">throw e;</span></code><span class="koboSpan" id="kobo.135.1">) when you want to hide the </span><a id="_idIndexMarker1114"/><span class="koboSpan" id="kobo.136.1">original location of the exception:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.137.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.138.1">handle_exception</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.139.1">()</span></span><span class="koboSpan" id="kobo.140.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.141.1">try</span></span><span class="koboSpan" id="kobo.142.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.143.1">throw</span></span><span class="koboSpan" id="kobo.144.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.145.1">// throw current exception</span></span><span class="koboSpan" id="kobo.146.1">
  }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.147.1">catch</span></span><span class="koboSpan" id="kobo.148.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.149.1">const</span></span><span class="koboSpan" id="kobo.150.1"> std::logic_error &amp; e)
  { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.151.1">/* ... </span><span class="koboSpan" id="kobo.151.2">*/</span></span><span class="koboSpan" id="kobo.152.1"> }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.153.1">catch</span></span><span class="koboSpan" id="kobo.154.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.155.1">const</span></span><span class="koboSpan" id="kobo.156.1"> std::runtime_error &amp; e)
  { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.157.1">/* ... </span><span class="koboSpan" id="kobo.157.2">*/</span></span><span class="koboSpan" id="kobo.158.1"> }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.159.1">catch</span></span><span class="koboSpan" id="kobo.160.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.161.1">const</span></span><span class="koboSpan" id="kobo.162.1"> std::exception &amp; e)
  { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.163.1">/* ... </span><span class="koboSpan" id="kobo.163.2">*/</span></span><span class="koboSpan" id="kobo.164.1"> }
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.165.1">try</span></span><span class="koboSpan" id="kobo.166.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.167.1">throwing_func</span></span><span class="koboSpan" id="kobo.168.1">();
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.169.1">catch</span></span><span class="koboSpan" id="kobo.170.1"> (...)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.171.1">handle_exception</span></span><span class="koboSpan" id="kobo.172.1">();
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-570"><span class="koboSpan" id="kobo.173.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.174.1">Most functions have to indicate the success or failure of their execution. </span><span class="koboSpan" id="kobo.174.2">This can be achieved in different ways. </span><span class="koboSpan" id="kobo.174.3">Here are several possibilities:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.175.1">Return an error code (with a special value for success) to indicate the specific reason for failure:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.176.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.177.1">f1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.178.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.179.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.180.1">&amp; result)</span></span><span class="koboSpan" id="kobo.181.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.182.1">if</span></span><span class="koboSpan" id="kobo.183.1"> (...) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.184.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.185.1">1</span></span><span class="koboSpan" id="kobo.186.1">;
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.187.1">// do something</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.188.1">if</span></span><span class="koboSpan" id="kobo.189.1"> (...) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.190.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.191.1">2</span></span><span class="koboSpan" id="kobo.192.1">;
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.193.1">// do something more</span></span><span class="koboSpan" id="kobo.194.1">
  result = </span><span class="hljs-number"><span class="koboSpan" id="kobo.195.1">42</span></span><span class="koboSpan" id="kobo.196.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.197.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.198.1">0</span></span><span class="koboSpan" id="kobo.199.1">;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.200.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.201.1">error_codes</span></span><span class="koboSpan" id="kobo.202.1"> {success, error_1, error_2};
</span><span class="hljs-function"><span class="koboSpan" id="kobo.203.1">error_codes </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.204.1">f2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.205.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.206.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.207.1">&amp; result)</span></span><span class="koboSpan" id="kobo.208.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.209.1">if</span></span><span class="koboSpan" id="kobo.210.1"> (...) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.211.1">return</span></span><span class="koboSpan" id="kobo.212.1"> error_codes::error_1;
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.213.1">// do something</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.214.1">if</span></span><span class="koboSpan" id="kobo.215.1"> (...) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.216.1">return</span></span><span class="koboSpan" id="kobo.217.1"> error_codes::error_2;
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.218.1">// do something more</span></span><span class="koboSpan" id="kobo.219.1">
  result = </span><span class="hljs-number"><span class="koboSpan" id="kobo.220.1">42</span></span><span class="koboSpan" id="kobo.221.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.222.1">return</span></span><span class="koboSpan" id="kobo.223.1"> error_codes::success;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.224.1">A variation</span><a id="_idIndexMarker1115"/><span class="koboSpan" id="kobo.225.1"> of this is to return a Boolean value to only indicate success or failure:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.226.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.227.1">g</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.228.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.229.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.230.1">&amp; result)</span></span><span class="koboSpan" id="kobo.231.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.232.1">if</span></span><span class="koboSpan" id="kobo.233.1"> (...) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.234.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.235.1">false</span></span><span class="koboSpan" id="kobo.236.1">;
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.237.1">// do something</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.238.1">if</span></span><span class="koboSpan" id="kobo.239.1"> (...) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.240.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.241.1">false</span></span><span class="koboSpan" id="kobo.242.1">;
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.243.1">// do something more</span></span><span class="koboSpan" id="kobo.244.1">
  result = </span><span class="hljs-number"><span class="koboSpan" id="kobo.245.1">42</span></span><span class="koboSpan" id="kobo.246.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.247.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.248.1">true</span></span><span class="koboSpan" id="kobo.249.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.250.1">Another alternative is to return invalid objects, null pointers, or empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">std::optional&lt;T&gt;</span></code><span class="koboSpan" id="kobo.252.1"> objects:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.253.1">std::optional&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.254.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.255.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.256.1">h</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.257.1">()</span></span><span class="koboSpan" id="kobo.258.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.259.1">if</span></span><span class="koboSpan" id="kobo.260.1"> (...) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.261.1">return</span></span><span class="koboSpan" id="kobo.262.1"> {};
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.263.1">// do something</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.264.1">if</span></span><span class="koboSpan" id="kobo.265.1"> (...) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.266.1">return</span></span><span class="koboSpan" id="kobo.267.1"> {};
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.268.1">// do something more</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.269.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.270.1">42</span></span><span class="koboSpan" id="kobo.271.1">;
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.272.1">In any case, the return value from the functions should be checked. </span><span class="koboSpan" id="kobo.272.2">This can lead to complex, cluttered, and hard-to-read and maintain real-world code. </span><span class="koboSpan" id="kobo.272.3">Moreover, the process of checking the return value of a function is always executed, regardless of whether the function was successful or failed. </span><span class="koboSpan" id="kobo.272.4">On the other hand, exceptions are thrown and handled only when a function fails, which should happen more rarely than successful </span><a id="_idIndexMarker1116"/><span class="koboSpan" id="kobo.273.1">executions. </span><span class="koboSpan" id="kobo.273.2">This can actually lead to faster code than code that returns and tests error codes.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.274.1">Exceptions and error codes are not mutually exclusive. </span><span class="koboSpan" id="kobo.274.2">Exceptions should be used only for transferring the control flow in exceptional situations, not for controlling the data flow in a program.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.275.1">Class constructors are special functions that do not return any value. </span><span class="koboSpan" id="kobo.275.2">They are supposed to construct an object, but in the case of failure, they will not be able to indicate this with a return value. </span><span class="koboSpan" id="kobo.275.3">Exceptions should be a mechanism that constructors use to indicate failure. </span><span class="koboSpan" id="kobo.275.4">Together with the </span><strong class="keyWord"><span class="koboSpan" id="kobo.276.1">Resource Acquisition Is Initialization</span></strong><span class="koboSpan" id="kobo.277.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.278.1">RAII</span></strong><span class="koboSpan" id="kobo.279.1">) idiom, this ensures the safe acquisition and release of resources in all situations. </span><span class="koboSpan" id="kobo.279.2">On the other hand, exceptions are not allowed to leave a destructor. </span><span class="koboSpan" id="kobo.279.3">When this happens, the program abnormally terminates with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.280.1">std::terminate()</span></code><span class="koboSpan" id="kobo.281.1">. </span><span class="koboSpan" id="kobo.281.2">This is the case for destructors called during stack unwinding, due to the occurrence of another exception. </span><span class="koboSpan" id="kobo.281.3">When an exception occurs, the stack is unwound from the point where the exception was thrown to the block where the exception is handled. </span><span class="koboSpan" id="kobo.281.4">This process involves the destruction of all local objects in all those stack frames.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.282.1">If the destructor of an object that is being destroyed during this process throws an exception, another stack unwinding process should begin, which conflicts with the one already under way. </span><span class="koboSpan" id="kobo.282.2">Because of this, the program terminates abnormally.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.283.1">The rule of thumb for dealing with exceptions in constructors and destructors is as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.284.1">Use exceptions to indicate the errors that occur in constructors.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.285.1">Do not throw or let exceptions leave destructors.</span></li>
</ul>
</div>
<p class="normal"><span class="koboSpan" id="kobo.286.1">It is possible to throw any type of exception. </span><span class="koboSpan" id="kobo.286.2">However, in most cases, you should throw temporaries and catch exceptions by constant reference. </span><span class="koboSpan" id="kobo.286.3">The reason for catching (constant) references is to avoid slicing the exception types. </span><span class="koboSpan" id="kobo.286.4">Let’s consider the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.287.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.288.1">simple_error</span></span><span class="koboSpan" id="kobo.289.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.290.1">public</span></span><span class="koboSpan" id="kobo.291.1"> std::exception
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.292.1">public</span></span><span class="koboSpan" id="kobo.293.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.294.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.295.1">const</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.296.1">char</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.297.1">* </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.298.1">what</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.299.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.300.1">const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.301.1">noexcept</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.302.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.303.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.304.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.305.1">"simple exception"</span></span><span class="koboSpan" id="kobo.306.1">;
  }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.307.1">try</span></span><span class="koboSpan" id="kobo.308.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.309.1">throw</span></span><span class="koboSpan" id="kobo.310.1"> simple_error{};
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.311.1">catch</span></span><span class="koboSpan" id="kobo.312.1"> (std::exception e)
{
   std::cout &lt;&lt; e.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.313.1">what</span></span><span class="koboSpan" id="kobo.314.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.315.1">'\n'</span></span><span class="koboSpan" id="kobo.316.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.317.1">// prints "Unknown exception"</span></span><span class="koboSpan" id="kobo.318.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.319.1">We are </span><a id="_idIndexMarker1117"/><span class="koboSpan" id="kobo.320.1">throwing a </span><code class="inlineCode"><span class="koboSpan" id="kobo.321.1">simple_error</span></code><span class="koboSpan" id="kobo.322.1"> object but catch a </span><code class="inlineCode"><span class="koboSpan" id="kobo.323.1">std::exception</span></code><span class="koboSpan" id="kobo.324.1"> object by value. </span><span class="koboSpan" id="kobo.324.2">This is the base type of </span><code class="inlineCode"><span class="koboSpan" id="kobo.325.1">simple_error</span></code><span class="koboSpan" id="kobo.326.1">. </span><span class="koboSpan" id="kobo.326.2">The </span><em class="italic"><span class="koboSpan" id="kobo.327.1">slicing</span></em><span class="koboSpan" id="kobo.328.1"> process occurs, the derived type information is lost, and only the </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">std::exception</span></code><span class="koboSpan" id="kobo.330.1"> part of the object is kept. </span><span class="koboSpan" id="kobo.330.2">Therefore, the printed message is </span><em class="italic"><span class="koboSpan" id="kobo.331.1">Unknown exception</span></em><span class="koboSpan" id="kobo.332.1"> and not </span><em class="italic"><span class="koboSpan" id="kobo.333.1">simple exception</span></em><span class="koboSpan" id="kobo.334.1"> as one would expect. </span><span class="koboSpan" id="kobo.334.2">Using a reference avoids the object slicing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.335.1">The following are some guidelines for exception throwing:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.336.1">Prefer throwing either standard exceptions or your own exceptions derived from </span><code class="inlineCode"><span class="koboSpan" id="kobo.337.1">std::exception</span></code><span class="koboSpan" id="kobo.338.1"> or another standard exception. </span><span class="koboSpan" id="kobo.338.2">The reason for this is that the standard library provides exception classes that are intended to be the first choice for representing exceptions. </span><span class="koboSpan" id="kobo.338.3">You should use the ones that are available already and when these are not good enough, build your own based on the standard ones. </span><span class="koboSpan" id="kobo.338.4">The main benefits of this are consistency and helping users catch exceptions via the base </span><code class="inlineCode"><span class="koboSpan" id="kobo.339.1">std::exception</span></code><span class="koboSpan" id="kobo.340.1"> class.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.341.1">Avoid throwing exceptions of built-in types, such as integers. </span><span class="koboSpan" id="kobo.341.2">The reason for this is that numbers carry little information to the user, who must know what it represents, while an object can provide contextual information. </span><span class="koboSpan" id="kobo.341.3">For instance, the statement </span><code class="inlineCode"><span class="koboSpan" id="kobo.342.1">throw 13;</span></code><span class="koboSpan" id="kobo.343.1"> tells nothing to the user, but </span><code class="inlineCode"><span class="koboSpan" id="kobo.344.1">throw access_denied_exception{};</span></code><span class="koboSpan" id="kobo.345.1"> carries much more implicit information from the class name alone, and with the help of data members, it carries anything useful or necessary about the exceptional situation.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.346.1">When using a library or framework that provides its own exception hierarchy, prefer throwing exceptions from this hierarchy or your own exceptions derived from it, at least in the parts of the code that are tightly related to it. </span><span class="koboSpan" id="kobo.346.2">The main reason for this is to keep the code that utilizes the library APIs consistent.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-571"><span class="koboSpan" id="kobo.347.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.348.1">As mentioned in the </span><a id="_idIndexMarker1118"/><span class="koboSpan" id="kobo.349.1">preceding section, when you need to create your own exception types, derive them from one of the standard exceptions that are available, unless you are using a library or framework with its own exception hierarchy. </span><span class="koboSpan" id="kobo.349.2">The C++ standard defines several categories of exceptions that need to be considered for this purpose:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.350.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.351.1">std::logic_error</span></code><span class="koboSpan" id="kobo.352.1"> represents an exception that indicates an error in the program logic, such as an invalid argument and an index beyond the bounds of a range. </span><span class="koboSpan" id="kobo.352.2">There are various standard-derived classes, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.353.1">std::invalid_argument</span></code><span class="koboSpan" id="kobo.354.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.355.1">std::out_of_range</span></code><span class="koboSpan" id="kobo.356.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.357.1">std::length_error</span></code><span class="koboSpan" id="kobo.358.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.359.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.360.1">std::runtime_error</span></code><span class="koboSpan" id="kobo.361.1"> represents an exception that indicates an error beyond the scope of the program or that cannot be predicted due to various factors, including external ones, such as overflows and underflows or operating system errors. </span><span class="koboSpan" id="kobo.361.2">The C++ standard also provides several derived classes from </span><code class="inlineCode"><span class="koboSpan" id="kobo.362.1">std::runtime_error</span></code><span class="koboSpan" id="kobo.363.1">, including </span><code class="inlineCode"><span class="koboSpan" id="kobo.364.1">std::overflow_error</span></code><span class="koboSpan" id="kobo.365.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.366.1">std::underflow_error</span></code><span class="koboSpan" id="kobo.367.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.368.1">std::system_error</span></code><span class="koboSpan" id="kobo.369.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.370.1">std::format_error</span></code><span class="koboSpan" id="kobo.371.1"> in C++20.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.372.1">Exceptions prefixed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.373.1">bad_</span></code><span class="koboSpan" id="kobo.374.1">, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.375.1">std::bad_alloc</span></code><span class="koboSpan" id="kobo.376.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.377.1">std::bad_cast</span></code><span class="koboSpan" id="kobo.378.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.379.1">std::bad_function_call</span></code><span class="koboSpan" id="kobo.380.1">, represent various errors in a program, such as failure to allocate memory and failure to dynamically cast or make a function call.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.381.1">The base class for all these exceptions is </span><code class="inlineCode"><span class="koboSpan" id="kobo.382.1">std::exception</span></code><span class="koboSpan" id="kobo.383.1">. </span><span class="koboSpan" id="kobo.383.2">It has a non-throwing virtual method called </span><code class="inlineCode"><span class="koboSpan" id="kobo.384.1">what()</span></code><span class="koboSpan" id="kobo.385.1"> that returns a pointer to an array of characters representing the description of the error.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.386.1">When you need to derive custom exceptions from a standard exception, use the appropriate category, such as logical or runtime error. </span><span class="koboSpan" id="kobo.386.2">If none of these categories is suitable, then you can derive directly from </span><code class="inlineCode"><span class="koboSpan" id="kobo.387.1">std::exception</span></code><span class="koboSpan" id="kobo.388.1">. </span><span class="koboSpan" id="kobo.388.2">The following is a list of possible solutions you can use to derive from a standard exception:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.389.1">If you need to derive from </span><code class="inlineCode"><span class="koboSpan" id="kobo.390.1">std::exception</span></code><span class="koboSpan" id="kobo.391.1">, then override the virtual method </span><code class="inlineCode"><span class="koboSpan" id="kobo.392.1">what()</span></code><span class="koboSpan" id="kobo.393.1"> to provide a description of the error:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.394.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.395.1">simple_error</span></span><span class="koboSpan" id="kobo.396.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.397.1">public</span></span><span class="koboSpan" id="kobo.398.1"> std::exception
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.399.1">public</span></span><span class="koboSpan" id="kobo.400.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.401.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.402.1">const</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.403.1">char</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.404.1">* </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.405.1">what</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.406.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.407.1">const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.408.1">noexcept</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.409.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.410.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.411.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.412.1">"simple exception"</span></span><span class="koboSpan" id="kobo.413.1">;
  }
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.414.1">If you</span><a id="_idIndexMarker1119"/><span class="koboSpan" id="kobo.415.1"> derive from </span><code class="inlineCode"><span class="koboSpan" id="kobo.416.1">std::logic_error</span></code><span class="koboSpan" id="kobo.417.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.418.1">std::runtime_error</span></code><span class="koboSpan" id="kobo.419.1"> and you only need to provide a static description that does not depend on runtime data, then pass the description text to the base class constructor:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.420.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.421.1">another_logic_error</span></span><span class="koboSpan" id="kobo.422.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.423.1">public</span></span><span class="koboSpan" id="kobo.424.1"> std::logic_error
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.425.1">public</span></span><span class="koboSpan" id="kobo.426.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.427.1">another_logic_error</span></span><span class="koboSpan" id="kobo.428.1">():
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.429.1">logic_error</span></span><span class="koboSpan" id="kobo.430.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.431.1">"simple logic exception"</span></span><span class="koboSpan" id="kobo.432.1">)
  {}
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.433.1">If you derive from </span><code class="inlineCode"><span class="koboSpan" id="kobo.434.1">std::logic_error</span></code><span class="koboSpan" id="kobo.435.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.436.1">std::runtime_error</span></code><span class="koboSpan" id="kobo.437.1"> but the description message depends on runtime data, provide a constructor with parameters and use them to build the description message. </span><span class="koboSpan" id="kobo.437.2">You can either pass the description message to the base class constructor or return it from the overridden </span><code class="inlineCode"><span class="koboSpan" id="kobo.438.1">what()</span></code><span class="koboSpan" id="kobo.439.1"> method:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.440.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.441.1">advanced_error</span></span><span class="koboSpan" id="kobo.442.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.443.1">public</span></span><span class="koboSpan" id="kobo.444.1"> std::runtime_error
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.445.1">int</span></span><span class="koboSpan" id="kobo.446.1"> error_code;
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.447.1">std::string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.448.1">make_message</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.449.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.450.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.451.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.452.1"> e)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.453.1">{
    std::stringstream ss;
    ss &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.454.1">"error with code "</span></span><span class="koboSpan" id="kobo.455.1"> &lt;&lt; e;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.456.1">return</span></span><span class="koboSpan" id="kobo.457.1"> ss.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.458.1">str</span></span><span class="koboSpan" id="kobo.459.1">();
  }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.460.1">public</span></span><span class="koboSpan" id="kobo.461.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.462.1">advanced_error</span></span><span class="koboSpan" id="kobo.463.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.464.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.465.1">const</span></span><span class="koboSpan" id="kobo.466.1"> e) :
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.467.1">runtime_error</span></span><span class="koboSpan" id="kobo.468.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.469.1">make_message</span></span><span class="koboSpan" id="kobo.470.1">(e).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.471.1">c_str</span></span><span class="koboSpan" id="kobo.472.1">()),</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.473.1">error_code</span></span><span class="koboSpan" id="kobo.474.1">(e)
  {
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.475.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.476.1">error</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.477.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.478.1">const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.479.1">noexcept</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.480.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.481.1">return</span></span><span class="koboSpan" id="kobo.482.1"> error_code;
  }
};
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.483.1">For a complete </span><a id="_idIndexMarker1120"/><span class="koboSpan" id="kobo.484.1">list of the standard exception classes, you can visit the </span><a href="https://en.cppreference.com/w/cpp/error/exception"><span class="url"><span class="koboSpan" id="kobo.485.1">https://en.cppreference.com/w/cpp/error/exception</span></span></a><span class="koboSpan" id="kobo.486.1"> page.</span></p>
<h2 class="heading-2" id="_idParaDest-572"><span class="koboSpan" id="kobo.487.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.488.1">Chapter 8</span></em><span class="koboSpan" id="kobo.489.1">, </span><em class="italic"><span class="koboSpan" id="kobo.490.1">Handling exceptions from thread functions</span></em><span class="koboSpan" id="kobo.491.1">, to understand how to handle exceptions thrown in a worker thread from the main thread or the thread where it was joined</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.492.1">Using noexcept for functions that do not throw exceptions</span></em><span class="koboSpan" id="kobo.493.1">, to see how to inform the compiler that a function should not throw exceptions</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-573"><span class="koboSpan" id="kobo.494.1">Using noexcept for functions that do not throw exceptions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.495.1">Exception specification</span><a id="_idIndexMarker1121"/><span class="koboSpan" id="kobo.496.1"> is a language feature that can enable performance improvements, but on the other hand, when done incorrectly, it can abnormally terminate the program. </span><span class="koboSpan" id="kobo.496.2">The exception specification from C++03, which allowed you to indicate what types of exceptions a function could throw, was deprecated in C++11 and removed in C++17. </span><span class="koboSpan" id="kobo.496.3">It was replaced with the C++11 </span><code class="inlineCode"><span class="koboSpan" id="kobo.497.1">noexcept</span></code><span class="koboSpan" id="kobo.498.1"> specifier. </span><span class="koboSpan" id="kobo.498.2">Moreover, the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.499.1">throw()</span></code><span class="koboSpan" id="kobo.500.1"> specifier to indicate that a function throws, without indicating what exception types have</span><a id="_idIndexMarker1122"/><span class="koboSpan" id="kobo.501.1"> also been deprecated in C++17 and completely removed in C++20. </span><span class="koboSpan" id="kobo.501.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">noexcept</span></code><span class="koboSpan" id="kobo.503.1"> specifier only allows you to indicate that a function does not throw exceptions (as opposed to the old </span><code class="inlineCode"><span class="koboSpan" id="kobo.504.1">throw</span></code><span class="koboSpan" id="kobo.505.1"> specifier, which could indicate the list of types a function could throw). </span><span class="koboSpan" id="kobo.505.2">This recipe provides information about the modern exception specifications in C++, as well as guidelines on when to use them.</span></p>
<h2 class="heading-2" id="_idParaDest-574"><span class="koboSpan" id="kobo.506.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.507.1">Use the </span><a id="_idIndexMarker1123"/><span class="koboSpan" id="kobo.508.1">following constructs to specify or query exception specifications:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.509.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.510.1">noexcept</span></code><span class="koboSpan" id="kobo.511.1"> in a function declaration to indicate that the function is not throwing any exception:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.512.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.513.1">func_no_throw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.514.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.515.1">noexcept</span></span><span class="koboSpan" id="kobo.516.1">
{
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.517.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.518.1">noexcept(expr)</span></code><span class="koboSpan" id="kobo.519.1"> in a function declaration, such as template metaprogramming, to indicate that the function may or may not throw an exception based on a condition that evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.520.1">bool</span></code><span class="koboSpan" id="kobo.521.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.522.1">template</span></span><span class="koboSpan" id="kobo.523.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.524.1">typename</span></span><span class="koboSpan" id="kobo.525.1"> T&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.526.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.527.1">generic_func_1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.528.1">()</span></span>
<span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.529.1">noexcept</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.530.1">(std::is_nothrow_constructible_v&lt;T&gt;)</span></span><span class="koboSpan" id="kobo.531.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.532.1">return</span></span><span class="koboSpan" id="kobo.533.1"> T{};
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.534.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.535.1">noexcept</span></code><span class="koboSpan" id="kobo.536.1"> operator at compile time to check whether an expression is declared to not throw any exception:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.537.1">template</span></span><span class="koboSpan" id="kobo.538.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.539.1">typename</span></span><span class="koboSpan" id="kobo.540.1"> T&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.541.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.542.1">generic_func_2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.543.1">()</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.544.1">noexcept</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.545.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.546.1">noexcept</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.547.1">(T{}))</span></span><span class="koboSpan" id="kobo.548.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.549.1">return</span></span><span class="koboSpan" id="kobo.550.1"> T{};
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.551.1">template</span></span><span class="koboSpan" id="kobo.552.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.553.1">typename</span></span><span class="koboSpan" id="kobo.554.1"> F, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.555.1">typename</span></span><span class="koboSpan" id="kobo.556.1"> A&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.557.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.558.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.559.1">(F&amp;&amp; f, A&amp;&amp; arg)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.560.1">noexcept</span></span><span class="koboSpan" id="kobo.561.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.562.1">static_assert</span></span><span class="koboSpan" id="kobo.563.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.564.1">noexcept</span></span><span class="koboSpan" id="kobo.565.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.566.1">f</span></span><span class="koboSpan" id="kobo.567.1">(arg)), </span><span class="hljs-string"><span class="koboSpan" id="kobo.568.1">"F is throwing!"</span></span><span class="koboSpan" id="kobo.569.1">);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.570.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.571.1">f</span></span><span class="koboSpan" id="kobo.572.1">(arg);
}
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.573.1">noexcept</span></span><span class="koboSpan" id="kobo.574.1">(generic_func_2&lt;int&gt;) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.575.1">'\n'</span></span><span class="koboSpan" id="kobo.576.1">;
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-575"><span class="koboSpan" id="kobo.577.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.578.1">As of C++17, exception specification</span><a id="_idIndexMarker1124"/><span class="koboSpan" id="kobo.579.1"> is part of the function type, but not part of the function signature; it may appear as part of any function </span><a id="_idIndexMarker1125"/><span class="koboSpan" id="kobo.580.1">declarator. </span><span class="koboSpan" id="kobo.580.2">Because exception specification is not part of the function signature, two function signatures cannot differ only in the exception specification. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.581.1">Prior to C++17, exception specification was not part of the function type and could only appear as part of lambda declarators or top-level function declarators; they could not appear even in </span><code class="inlineCode"><span class="koboSpan" id="kobo.582.1">typedef</span></code><span class="koboSpan" id="kobo.583.1"> or type alias declarations. </span><span class="koboSpan" id="kobo.583.2">Further discussions on exception specification refer solely to the C++17 standard.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.584.1">There are several ways in which the process of throwing an exception can be specified:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.585.1">If no exception specification is present, then the function could potentially throw exceptions.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.586.1">noexcept(false)</span></code><span class="koboSpan" id="kobo.587.1"> is equivalent to no exception specification.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.588.1">noexcept(true)</span></code><span class="koboSpan" id="kobo.589.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.590.1">noexcept</span></code><span class="koboSpan" id="kobo.591.1"> indicate that a function does not throw any exception.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.592.1">throw()</span></code><span class="koboSpan" id="kobo.593.1"> was equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.594.1">noexcept(true)</span></code><span class="koboSpan" id="kobo.595.1"> but was deprecated in C++17 and removed altogether in C++20.</span></li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.596.1">Using exception specifications must be done with care because if an exception (either thrown directly or from another function that is called) leaves a function marked as non-throwing, the program is terminated immediately and abnormally with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.597.1">std::terminate()</span></code><span class="koboSpan" id="kobo.598.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.599.1">Pointers to the functions that do not throw exceptions can be implicitly converted to pointers to functions that may throw exceptions, but not vice versa. </span><span class="koboSpan" id="kobo.599.2">On the other hand, if a virtual function has a non-throwing exception specification, this indicates that all the declarations of all the overrides must preserve this specification unless an overridden function is declared as deleted.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.600.1">At compile time, it is possible to check whether a function is declared to be non-throwing or not using the operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.601.1">noexcept</span></code><span class="koboSpan" id="kobo.602.1">. </span><span class="koboSpan" id="kobo.602.2">This operator takes an expression and returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.603.1">true</span></code><span class="koboSpan" id="kobo.604.1"> if the expression is declared as either non-throwing or </span><code class="inlineCode"><span class="koboSpan" id="kobo.605.1">false</span></code><span class="koboSpan" id="kobo.606.1">. </span><span class="koboSpan" id="kobo.606.2">It does not evaluate the expression it checks.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.607.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.608.1">noexcept</span></code><span class="koboSpan" id="kobo.609.1"> operator, along with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.610.1">noexcept</span></code><span class="koboSpan" id="kobo.611.1"> specifier, is particularly useful in template metaprogramming to indicate whether a function may throw exceptions for some types. </span><span class="koboSpan" id="kobo.611.2">It is also used with </span><code class="inlineCode"><span class="koboSpan" id="kobo.612.1">static_assert</span></code><span class="koboSpan" id="kobo.613.1"> declarations to check whether an expression breaks the non-throwing guarantee of a function, as seen in the examples in the </span><em class="italic"><span class="koboSpan" id="kobo.614.1">How to do it...</span></em><span class="koboSpan" id="kobo.615.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.616.1">The </span><a id="_idIndexMarker1126"/><span class="koboSpan" id="kobo.617.1">following code provides more examples of how the </span><code class="inlineCode"><span class="koboSpan" id="kobo.618.1">noexcept</span></code><span class="koboSpan" id="kobo.619.1"> operator works:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.620.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.621.1">double_it</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.622.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.623.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.624.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.625.1"> i)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.626.1">noexcept</span></span><span class="koboSpan" id="kobo.627.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.628.1">return</span></span><span class="koboSpan" id="kobo.629.1"> i + i;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.630.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.631.1">half_it</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.632.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.633.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.634.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.635.1"> i)</span></span><span class="koboSpan" id="kobo.636.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.637.1">throw</span></span><span class="koboSpan" id="kobo.638.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.639.1">runtime_error</span></span><span class="koboSpan" id="kobo.640.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.641.1">"not implemented!"</span></span><span class="koboSpan" id="kobo.642.1">);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.643.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.644.1">foo</span></span><span class="koboSpan" id="kobo.645.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.646.1">foo</span></span><span class="koboSpan" id="kobo.647.1">() {}
};
std::cout &lt;&lt; std::boolalpha
  &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.648.1">noexcept</span></span><span class="koboSpan" id="kobo.649.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.650.1">func_no_throw</span></span><span class="koboSpan" id="kobo.651.1">()) &lt;&lt;  </span><span class="hljs-string"><span class="koboSpan" id="kobo.652.1">'\n'</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.653.1">// true</span></span><span class="koboSpan" id="kobo.654.1">
  &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.655.1">noexcept</span></span><span class="koboSpan" id="kobo.656.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.657.1">generic_func_1</span></span><span class="koboSpan" id="kobo.658.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.659.1">int</span></span><span class="koboSpan" id="kobo.660.1">&gt;()) &lt;&lt;  </span><span class="hljs-string"><span class="koboSpan" id="kobo.661.1">'\n'</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.662.1">// true</span></span><span class="koboSpan" id="kobo.663.1">
  &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.664.1">noexcept</span></span><span class="koboSpan" id="kobo.665.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.666.1">generic_func_1</span></span><span class="koboSpan" id="kobo.667.1">&lt;std::string&gt;()) &lt;&lt;  </span><span class="hljs-string"><span class="koboSpan" id="kobo.668.1">'\n'</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.669.1">// true</span></span><span class="koboSpan" id="kobo.670.1">
  &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.671.1">noexcept</span></span><span class="koboSpan" id="kobo.672.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.673.1">generic_func_2</span></span><span class="koboSpan" id="kobo.674.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.675.1">int</span></span><span class="koboSpan" id="kobo.676.1">&gt;()) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.677.1">'\n'</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.678.1">// true</span></span><span class="koboSpan" id="kobo.679.1">
  &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.680.1">noexcept</span></span><span class="koboSpan" id="kobo.681.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.682.1">generic_func_2</span></span><span class="koboSpan" id="kobo.683.1">&lt;std::string&gt;()) &lt;&lt;  </span><span class="hljs-string"><span class="koboSpan" id="kobo.684.1">'\n'</span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.685.1">// true</span></span><span class="koboSpan" id="kobo.686.1">
  &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.687.1">noexcept</span></span><span class="koboSpan" id="kobo.688.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.689.1">generic_func_2</span></span><span class="koboSpan" id="kobo.690.1">&lt;foo&gt;()) &lt;&lt;  </span><span class="hljs-string"><span class="koboSpan" id="kobo.691.1">'\n'</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.692.1">// false</span></span><span class="koboSpan" id="kobo.693.1">
  &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.694.1">noexcept</span></span><span class="koboSpan" id="kobo.695.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.696.1">double_it</span></span><span class="koboSpan" id="kobo.697.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.698.1">42</span></span><span class="koboSpan" id="kobo.699.1">)) &lt;&lt;  </span><span class="hljs-string"><span class="koboSpan" id="kobo.700.1">'\n'</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.701.1">// true</span></span><span class="koboSpan" id="kobo.702.1">
  &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.703.1">noexcept</span></span><span class="koboSpan" id="kobo.704.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.705.1">half_it</span></span><span class="koboSpan" id="kobo.706.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.707.1">42</span></span><span class="koboSpan" id="kobo.708.1">)) &lt;&lt;  </span><span class="hljs-string"><span class="koboSpan" id="kobo.709.1">'\n'</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.710.1">// false</span></span><span class="koboSpan" id="kobo.711.1">
  &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.712.1">noexcept</span></span><span class="koboSpan" id="kobo.713.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.714.1">func</span></span><span class="koboSpan" id="kobo.715.1">(double_it, </span><span class="hljs-number"><span class="koboSpan" id="kobo.716.1">42</span></span><span class="koboSpan" id="kobo.717.1">)) &lt;&lt;  </span><span class="hljs-string"><span class="koboSpan" id="kobo.718.1">'\n'</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.719.1">// true</span></span><span class="koboSpan" id="kobo.720.1">
  &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.721.1">noexcept</span></span><span class="koboSpan" id="kobo.722.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.723.1">func</span></span><span class="koboSpan" id="kobo.724.1">(half_it, </span><span class="hljs-number"><span class="koboSpan" id="kobo.725.1">42</span></span><span class="koboSpan" id="kobo.726.1">)) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.727.1">'\n'</span></span><span class="koboSpan" id="kobo.728.1">;            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.729.1">// true</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.730.1">It is important</span><a id="_idIndexMarker1127"/><span class="koboSpan" id="kobo.731.1"> to note that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.732.1">noexcept</span></code><span class="koboSpan" id="kobo.733.1"> specifier does not provide compile-time checking for exceptions. </span><span class="koboSpan" id="kobo.733.2">It only represents a way for users to inform the compiler that a function is not expected to throw exceptions. </span><span class="koboSpan" id="kobo.733.3">The compiler can use this to enable certain optimizations. </span><span class="koboSpan" id="kobo.733.4">An example is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">std::vector</span></code><span class="koboSpan" id="kobo.735.1">, which moves elements if their move constructor is </span><code class="inlineCode"><span class="koboSpan" id="kobo.736.1">noexcept</span></code><span class="koboSpan" id="kobo.737.1"> and copies them otherwise.</span></p>
<h2 class="heading-2" id="_idParaDest-576"><span class="koboSpan" id="kobo.738.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.739.1">As mentioned earlier, a function</span><a id="_idIndexMarker1128"/><span class="koboSpan" id="kobo.740.1"> declared with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.741.1">noexcept</span></code><span class="koboSpan" id="kobo.742.1"> specifier that exits due to an exception causes the program to terminate abnormally. </span><span class="koboSpan" id="kobo.742.2">Therefore, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.743.1">noexcept</span></code><span class="koboSpan" id="kobo.744.1"> specifier should be used with caution. </span><span class="koboSpan" id="kobo.744.2">Its presence can enable code optimizations, which help increase performance while preserving the </span><em class="italic"><span class="koboSpan" id="kobo.745.1">strong exception guarantee</span></em><span class="koboSpan" id="kobo.746.1">. </span><span class="koboSpan" id="kobo.746.2">An example of this is library containers.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.747.1">The C++ language provides several levels of exception guarantees:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.748.1">The first level, </span><em class="italic"><span class="koboSpan" id="kobo.749.1">no exception guarantees</span></em><span class="koboSpan" id="kobo.750.1">, does not provide any guarantees. </span><span class="koboSpan" id="kobo.750.2">If an exception occurs, there is nothing to indicate whether the program is left in a valid state. </span><span class="koboSpan" id="kobo.750.3">Resources could be leaked, memory can be corrupted, and object invariants may be broken.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.751.1">The </span><em class="italic"><span class="koboSpan" id="kobo.752.1">basic exception guarantee</span></em><span class="koboSpan" id="kobo.753.1"> is the simplest level of guarantee, which ensures that after an exception is thrown, objects are left in a consistent and usable state, no resource leaks occur, and invariants are preserved.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.754.1">The </span><em class="italic"><span class="koboSpan" id="kobo.755.1">strong exception guarantee</span></em><span class="koboSpan" id="kobo.756.1"> specifies that either an operation is completed successfully, or that it is completed with an exception that leaves the program in the same state it was in before the operation started. </span><span class="koboSpan" id="kobo.756.2">This ensures commit-or-rollback semantics.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.757.1">The </span><em class="italic"><span class="koboSpan" id="kobo.758.1">no-throw exception guarantee</span></em><span class="koboSpan" id="kobo.759.1"> is actually the strongest of them all and specifies that an operation is guaranteed to not throw any exception and to complete successfully.</span></li>
</ul>
</div>
<p class="normal"><span class="koboSpan" id="kobo.760.1">Many standard containers provide some of their operations with a strong exception guarantee. </span><span class="koboSpan" id="kobo.760.2">An example is vector’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.761.1">push_back()</span></code><span class="koboSpan" id="kobo.762.1"> method. </span><span class="koboSpan" id="kobo.762.2">This method could be optimized by using the move constructor or move assignment operator instead of the copy constructor or copy assignment operator of the vector’s element type. </span><span class="koboSpan" id="kobo.762.3">However, in order to preserve its strong exception guarantee, this can only be done if the move constructor or assignment operator does not throw exceptions. </span><span class="koboSpan" id="kobo.762.4">If either does, then the copy constructor or the assignment operator must be used instead.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.763.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.764.1">std::move_if_noexcept()</span></code><span class="koboSpan" id="kobo.765.1"> utility function does this if the move constructor of its type argument is marked with </span><code class="inlineCode"><span class="koboSpan" id="kobo.766.1">noexcept</span></code><span class="koboSpan" id="kobo.767.1">. </span><span class="koboSpan" id="kobo.767.2">The ability to indicate that move constructors or move assignment operators do not throw exceptions is probably the most important scenario where </span><code class="inlineCode"><span class="koboSpan" id="kobo.768.1">noexcept</span></code><span class="koboSpan" id="kobo.769.1"> is used.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.770.1">Consider the following</span><a id="_idIndexMarker1129"/><span class="koboSpan" id="kobo.771.1"> rules for the exception specification:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.772.1">If a function could potentially throw an exception, then do not use any exception specifier.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.773.1">Mark only those functions with </span><code class="inlineCode"><span class="koboSpan" id="kobo.774.1">noexcept</span></code><span class="koboSpan" id="kobo.775.1"> that are guaranteed not to throw an exception.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.776.1">Mark only those functions with </span><code class="inlineCode"><span class="koboSpan" id="kobo.777.1">noexcept(expression)</span></code><span class="koboSpan" id="kobo.778.1"> that could potentially throw exceptions based on a condition.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.779.1">These rules are important because, as already noted previously, throwing an exception from a </span><code class="inlineCode"><span class="koboSpan" id="kobo.780.1">noexcept</span></code><span class="koboSpan" id="kobo.781.1"> function will immediately terminate the program with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.782.1">std::terminate()</span></code><span class="koboSpan" id="kobo.783.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-577"><span class="koboSpan" id="kobo.784.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.785.1">Using exceptions for error handling</span></em><span class="koboSpan" id="kobo.786.1">, to explore the best practices for using exceptions in the C++ language</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-578"><span class="koboSpan" id="kobo.787.1">Ensuring constant correctness for a program</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.788.1">Although</span><a id="_idIndexMarker1130"/><span class="koboSpan" id="kobo.789.1"> there is no formal definition, constant correctness means objects that are not supposed to be modified (are immutable) remain</span><a id="_idIndexMarker1131"/><span class="koboSpan" id="kobo.790.1"> unmodified. </span><span class="koboSpan" id="kobo.790.2">As a developer, you can enforce this by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.791.1">const</span></code><span class="koboSpan" id="kobo.792.1"> keyword for declaring parameters, variables, and member functions. </span><span class="koboSpan" id="kobo.792.2">In this recipe, we will explore the benefits of constant correctness and how to achieve it.</span></p>
<h2 class="heading-2" id="_idParaDest-579"><span class="koboSpan" id="kobo.793.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.794.1">To ensure constant correctness for a program, you should always declare the following as constants:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.795.1">Parameters to functions that are not supposed to be modified within the function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.796.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.797.1">session</span></span><span class="koboSpan" id="kobo.798.1"> {};
</span><span class="hljs-function"><span class="koboSpan" id="kobo.799.1">session </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.800.1">connect</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.801.1">(std::string </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.802.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.803.1"> &amp; uri,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.804.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.805.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.806.1"> timeout = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.807.1">2000</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.808.1">)</span></span><span class="koboSpan" id="kobo.809.1">
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.810.1">/* do something */</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.811.1">return</span></span><span class="koboSpan" id="kobo.812.1"> session { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.813.1">/* ... </span><span class="koboSpan" id="kobo.813.2">*/</span></span><span class="koboSpan" id="kobo.814.1"> };
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.815.1">Class data members that do not change:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.816.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.817.1">user_settings</span></span><span class="koboSpan" id="kobo.818.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.819.1">public</span></span><span class="koboSpan" id="kobo.820.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.821.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.822.1">const</span></span><span class="koboSpan" id="kobo.823.1"> min_update_interval = </span><span class="hljs-number"><span class="koboSpan" id="kobo.824.1">15</span></span><span class="koboSpan" id="kobo.825.1">;
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.826.1">/* other members */</span></span><span class="koboSpan" id="kobo.827.1">
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.828.1">Class member</span><a id="_idIndexMarker1132"/><span class="koboSpan" id="kobo.829.1"> functions that do not </span><a id="_idIndexMarker1133"/><span class="koboSpan" id="kobo.830.1">modify the object state, as seen from the outside:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.831.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.832.1">user_settings</span></span><span class="koboSpan" id="kobo.833.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.834.1">bool</span></span><span class="koboSpan" id="kobo.835.1"> show_online;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.836.1">public</span></span><span class="koboSpan" id="kobo.837.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.838.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.839.1">can_show_online</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.840.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.841.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.842.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.843.1">return</span></span><span class="koboSpan" id="kobo.844.1"> show_online;}
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.845.1">/* other members */</span></span><span class="koboSpan" id="kobo.846.1">
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.847.1">Function locals whose values do not change throughout their lifetime:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.848.1">user_settings </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.849.1">get_user_settings</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.850.1">()</span></span><span class="koboSpan" id="kobo.851.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.852.1">return</span></span><span class="koboSpan" id="kobo.853.1"> user_settings {};
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.854.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.855.1">update</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.856.1">()</span></span><span class="koboSpan" id="kobo.857.1">
{
  user_settings </span><span class="hljs-type"><span class="koboSpan" id="kobo.858.1">const</span></span><span class="koboSpan" id="kobo.859.1"> us = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.860.1">get_user_settings</span></span><span class="koboSpan" id="kobo.861.1">();
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.862.1">if</span></span><span class="koboSpan" id="kobo.863.1">(us.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.864.1">can_show_online</span></span><span class="koboSpan" id="kobo.865.1">()) { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.866.1">/* do something */</span></span><span class="koboSpan" id="kobo.867.1"> }
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.868.1">/* do more */</span></span><span class="koboSpan" id="kobo.869.1">
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.870.1">References that should be bound to a temporary (an rvalue) in order to extend the lifetime of the temporary to the lifetime of the (constant) reference:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.871.1">std::string </span><span class="hljs-title"><span class="koboSpan" id="kobo.872.1">greetings</span></span><span class="koboSpan" id="kobo.873.1">()
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.874.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.875.1">"Hello, World!"</span></span><span class="koboSpan" id="kobo.876.1">;
}
const std::string &amp; s = </span><span class="hljs-title"><span class="koboSpan" id="kobo.877.1">greetings</span></span><span class="koboSpan" id="kobo.878.1">(); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.879.1">// must use const</span></span><span class="koboSpan" id="kobo.880.1">
std::cout &lt;&lt; s &lt;&lt; std::endl;
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-580"><span class="koboSpan" id="kobo.881.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.882.1">Declaring </span><a id="_idIndexMarker1134"/><span class="koboSpan" id="kobo.883.1">objects and member functions as </span><a id="_idIndexMarker1135"/><span class="koboSpan" id="kobo.884.1">constant has several important benefits:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.885.1">You prevent both accidental and intentional changes of the object, which, in some cases, can result in incorrect program behavior.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.886.1">You enable the compiler to perform better optimizations.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.887.1">You document the semantics of the code for other users.</span></li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.888.1">Constant correctness is not a matter of personal style but a core principle that should guide C++ development.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.889.1">Unfortunately, the importance of constant correctness has not been, and is still not, stressed enough in books, C++ communities, and working environments. </span><span class="koboSpan" id="kobo.889.2">But the rule of thumb is that everything that is not supposed to change should be declared as constant. </span><span class="koboSpan" id="kobo.889.3">This should be done all the time and not only at later stages of development, when you might need to clean up and refactor the code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.890.1">When you declare a parameter or variable as constant, you can either put the </span><code class="inlineCode"><span class="koboSpan" id="kobo.891.1">const</span></code><span class="koboSpan" id="kobo.892.1"> keyword before the type (</span><code class="inlineCode"><span class="koboSpan" id="kobo.893.1">const T c</span></code><span class="koboSpan" id="kobo.894.1">) or after the type (</span><code class="inlineCode"><span class="koboSpan" id="kobo.895.1">T const c</span></code><span class="koboSpan" id="kobo.896.1">). </span><span class="koboSpan" id="kobo.896.2">These two are equivalent, but regardless of which of the two styles you use, the reading of the declaration must be done from the right-hand side. </span><code class="inlineCode"><span class="koboSpan" id="kobo.897.1">const T c</span></code><span class="koboSpan" id="kobo.898.1"> is read as </span><em class="italic"><span class="koboSpan" id="kobo.899.1">c is a T that is constant</span></em><span class="koboSpan" id="kobo.900.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.901.1">T const c</span></code><span class="koboSpan" id="kobo.902.1"> as </span><em class="italic"><span class="koboSpan" id="kobo.903.1">c is a constant T</span></em><span class="koboSpan" id="kobo.904.1">. </span><span class="koboSpan" id="kobo.904.2">This gets a little bit more complicated with pointers. </span><span class="koboSpan" id="kobo.904.3">The following table presents various pointer declarations and their meanings:</span></p>
<table class="table-container" id="table001-6">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.905.1">Expression</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.906.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.907.1">T* p</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.908.1">p</span></code><span class="koboSpan" id="kobo.909.1"> is a non-constant pointer to a non-constant </span><code class="inlineCode"><span class="koboSpan" id="kobo.910.1">T</span></code><span class="koboSpan" id="kobo.911.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.912.1">const T* p</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.913.1">p</span></code><span class="koboSpan" id="kobo.914.1"> is a non-constant pointer to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.915.1">T</span></code><span class="koboSpan" id="kobo.916.1"> that is constant.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.917.1">T const * p</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.918.1">p</span></code><span class="koboSpan" id="kobo.919.1"> is a non-constant pointer to a constant </span><code class="inlineCode"><span class="koboSpan" id="kobo.920.1">T</span></code><span class="koboSpan" id="kobo.921.1"> (same as the prior point).</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.922.1">const T * const p</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.923.1">p</span></code><span class="koboSpan" id="kobo.924.1"> is a constant pointer to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.925.1">T</span></code><span class="koboSpan" id="kobo.926.1"> that is constant.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.927.1">T const * const p</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.928.1">p</span></code><span class="koboSpan" id="kobo.929.1"> is a constant pointer to a constant </span><code class="inlineCode"><span class="koboSpan" id="kobo.930.1">T</span></code><span class="koboSpan" id="kobo.931.1"> (same as the prior point).</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.932.1">T** p</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.933.1">p</span></code><span class="koboSpan" id="kobo.934.1"> is a non-constant pointer to a non-constant pointer to a non-constant </span><code class="inlineCode"><span class="koboSpan" id="kobo.935.1">T</span></code><span class="koboSpan" id="kobo.936.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.937.1">const T** p</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.938.1">p</span></code><span class="koboSpan" id="kobo.939.1"> is a non-constant pointer to a non-constant pointer to a constant </span><code class="inlineCode"><span class="koboSpan" id="kobo.940.1">T</span></code><span class="koboSpan" id="kobo.941.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.942.1">T const ** p</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.943.1">Same as </span><code class="inlineCode"><span class="koboSpan" id="kobo.944.1">const T** p</span></code><span class="koboSpan" id="kobo.945.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.946.1">const T* const * p</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.947.1">p</span></code><span class="koboSpan" id="kobo.948.1"> is a non-constant pointer to a constant pointer, which is a constant </span><code class="inlineCode"><span class="koboSpan" id="kobo.949.1">T</span></code><span class="koboSpan" id="kobo.950.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.951.1">T const * const * p</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.952.1">Same as </span><code class="inlineCode"><span class="koboSpan" id="kobo.953.1">const T* const * p</span></code><span class="koboSpan" id="kobo.954.1">.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.955.1">Table 9.1: Example of pointer declarations and their meaning</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.956.1">Placing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.957.1">const</span></code><span class="koboSpan" id="kobo.958.1"> keyword after the type is more natural because it is consistent with the direction the syntax is interpreted, from right to left. </span><span class="koboSpan" id="kobo.958.2">For this reason, all the examples in this book use this style.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.959.1">When it </span><a id="_idIndexMarker1136"/><span class="koboSpan" id="kobo.960.1">comes to references, the situation is similar: </span><code class="inlineCode"><span class="koboSpan" id="kobo.961.1">const T &amp; c</span></code><span class="koboSpan" id="kobo.962.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.963.1">T const &amp; c</span></code><span class="koboSpan" id="kobo.964.1"> are equivalent, which means </span><em class="italic"><span class="koboSpan" id="kobo.965.1">c is a reference to a constant T</span></em><span class="koboSpan" id="kobo.966.1">. </span><span class="koboSpan" id="kobo.966.2">However, </span><code class="inlineCode"><span class="koboSpan" id="kobo.967.1">T const &amp; const c</span></code><span class="koboSpan" id="kobo.968.1">, which would mean that </span><em class="italic"><span class="koboSpan" id="kobo.969.1">c is a constant reference to a constant T</span></em><span class="koboSpan" id="kobo.970.1">, does not make sense because references—aliases of a variable—are</span><a id="_idIndexMarker1137"/><span class="koboSpan" id="kobo.971.1"> implicitly constant in the sense that they cannot be modified to represent an alias to another variable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.972.1">A non-constant pointer to a non-constant object, that is, </span><code class="inlineCode"><span class="koboSpan" id="kobo.973.1">T*</span></code><span class="koboSpan" id="kobo.974.1">, can be implicitly converted to a non-constant pointer to a constant object, </span><code class="inlineCode"><span class="koboSpan" id="kobo.975.1">T const *</span></code><span class="koboSpan" id="kobo.976.1">. </span><span class="koboSpan" id="kobo.976.2">However, </span><code class="inlineCode"><span class="koboSpan" id="kobo.977.1">T**</span></code><span class="koboSpan" id="kobo.978.1"> cannot be implicitly converted to </span><code class="inlineCode"><span class="koboSpan" id="kobo.979.1">T const **</span></code><span class="koboSpan" id="kobo.980.1"> (which is the same with </span><code class="inlineCode"><span class="koboSpan" id="kobo.981.1">const T**</span></code><span class="koboSpan" id="kobo.982.1">). </span><span class="koboSpan" id="kobo.982.2">This is because this could lead to constant objects being modified through a pointer to a non-constant object, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.983.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.984.1">const</span></span><span class="koboSpan" id="kobo.985.1"> c = </span><span class="hljs-number"><span class="koboSpan" id="kobo.986.1">42</span></span><span class="koboSpan" id="kobo.987.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.988.1">int</span></span><span class="koboSpan" id="kobo.989.1">* x;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.990.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.991.1">const</span></span><span class="koboSpan" id="kobo.992.1"> ** p = &amp;x; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.993.1">// this is an actual error</span></span><span class="koboSpan" id="kobo.994.1">
*p = &amp;c;
*x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.995.1">0</span></span><span class="koboSpan" id="kobo.996.1">;              </span><span class="hljs-comment"><span class="koboSpan" id="kobo.997.1">// this modifies c</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.998.1">If an object is </span><a id="_idIndexMarker1138"/><span class="koboSpan" id="kobo.999.1">constant, only the constant functions of its class can be invoked. </span><span class="koboSpan" id="kobo.999.2">However, declaring a member function as constant does not mean that the function can only be called on constant objects; it could also mean that the function does not modify the state of the object, as seen from the outside. </span><span class="koboSpan" id="kobo.999.3">This is a key aspect, but it is usually misunderstood. </span><span class="koboSpan" id="kobo.999.4">A class has an internal state that it can expose to its clients through its public interface.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1000.1">However, not</span><a id="_idIndexMarker1139"/><span class="koboSpan" id="kobo.1001.1"> all the internal states might be exposed, and what is visible from the public interface might not have a direct representation in the internal state. </span><span class="koboSpan" id="kobo.1001.2">(If you model order lines and have the item quantity and item selling price fields in the internal representation, then you might have a public method that exposes the order line amount by multiplying the quantity by the price.) Therefore, the state of an object, as visible from its public interface, is a logical state. </span><span class="koboSpan" id="kobo.1001.3">Defining a method as constant is a statement that ensures the function does not alter the logical state. </span><span class="koboSpan" id="kobo.1001.4">However, the compiler prevents you from modifying data members using such methods. </span><span class="koboSpan" id="kobo.1001.5">To avoid this problem, data members that are supposed to be modified from constant methods should be declared </span><code class="inlineCode"><span class="koboSpan" id="kobo.1002.1">mutable</span></code><span class="koboSpan" id="kobo.1003.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1004.1">In the following example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1005.1">computation</span></code><span class="koboSpan" id="kobo.1006.1"> is a class with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1007.1">compute()</span></code><span class="koboSpan" id="kobo.1008.1"> method, which performs a long-running computation operation. </span><span class="koboSpan" id="kobo.1008.2">Because it does not affect the logical state of the object, this function is declared constant. </span><span class="koboSpan" id="kobo.1008.3">However, to avoid computing the result of the same input again, the computed values are stored in a cache. </span><span class="koboSpan" id="kobo.1008.4">To be able to modify the cache from the constant function, it is declared </span><code class="inlineCode"><span class="koboSpan" id="kobo.1009.1">mutable</span></code><span class="koboSpan" id="kobo.1010.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1011.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1012.1">computation</span></span><span class="koboSpan" id="kobo.1013.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1014.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1015.1">compute_value</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1016.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1017.1">double</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1018.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1019.1"> input)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1020.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1021.1">{
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1022.1">/* long running operation */</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1023.1">return</span></span><span class="koboSpan" id="kobo.1024.1"> input + 42;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1025.1">mutable</span></span><span class="koboSpan" id="kobo.1026.1"> std::map&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1027.1">double</span></span><span class="koboSpan" id="kobo.1028.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1029.1">double</span></span><span class="koboSpan" id="kobo.1030.1">&gt; cache;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1031.1">public</span></span><span class="koboSpan" id="kobo.1032.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1033.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1034.1">compute</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1035.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1036.1">double</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1037.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1038.1"> input)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1039.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1040.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1041.1">auto</span></span><span class="koboSpan" id="kobo.1042.1"> it = cache.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1043.1">find</span></span><span class="koboSpan" id="kobo.1044.1">(input);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1045.1">if</span></span><span class="koboSpan" id="kobo.1046.1">(it != cache.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1047.1">end</span></span><span class="koboSpan" id="kobo.1048.1">()) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1049.1">return</span></span><span class="koboSpan" id="kobo.1050.1"> it-&gt;second;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1051.1">auto</span></span><span class="koboSpan" id="kobo.1052.1"> result = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1053.1">compute_value</span></span><span class="koboSpan" id="kobo.1054.1">(input);
    cache[input] = result;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1055.1">return</span></span><span class="koboSpan" id="kobo.1056.1"> result;
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1057.1">A similar</span><a id="_idIndexMarker1140"/><span class="koboSpan" id="kobo.1058.1"> situation is represented by the following class, which implements a thread-safe container. </span><span class="koboSpan" id="kobo.1058.2">Access to shared internal data is protected with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1059.1">mutex</span></code><span class="koboSpan" id="kobo.1060.1">. </span><span class="koboSpan" id="kobo.1060.2">The class provides methods such as adding and removing values, and also </span><a id="_idIndexMarker1141"/><span class="koboSpan" id="kobo.1061.1">methods such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1062.1">contains()</span></code><span class="koboSpan" id="kobo.1063.1">, which indicate whether an item exists in the container. </span><span class="koboSpan" id="kobo.1063.2">Because this member function is not intended to modify the logical state of the object, it is declared constant. </span><span class="koboSpan" id="kobo.1063.3">However, access to the shared internal state must be protected with the mutex. </span><span class="koboSpan" id="kobo.1063.4">In order to lock and unlock the mutex, both mutable operations (that modify the state of the object) and the mutex must be declared </span><code class="inlineCode"><span class="koboSpan" id="kobo.1064.1">mutable</span></code><span class="koboSpan" id="kobo.1065.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1066.1">template</span></span><span class="koboSpan" id="kobo.1067.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1068.1">typename</span></span><span class="koboSpan" id="kobo.1069.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1070.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1071.1">container</span></span><span class="koboSpan" id="kobo.1072.1">
{
  std::vector&lt;T&gt;     data;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1073.1">mutable</span></span><span class="koboSpan" id="kobo.1074.1"> std::mutex mt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1075.1">public</span></span><span class="koboSpan" id="kobo.1076.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1077.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1078.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1079.1">(T </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1080.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1081.1"> &amp; value)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1082.1">{
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.1083.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1084.1">lock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1085.1">(mt)</span></span><span class="koboSpan" id="kobo.1086.1">;
    data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1087.1">push_back</span></span><span class="koboSpan" id="kobo.1088.1">(value);
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1089.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1090.1">contains</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1091.1">(T </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1092.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1093.1"> &amp; value)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1094.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1095.1">{
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.1096.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1097.1">lock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1098.1">(mt)</span></span><span class="koboSpan" id="kobo.1099.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1100.1">return</span></span><span class="koboSpan" id="kobo.1101.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1102.1">find</span></span><span class="koboSpan" id="kobo.1103.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1104.1">begin</span></span><span class="koboSpan" id="kobo.1105.1">(data), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1106.1">end</span></span><span class="koboSpan" id="kobo.1107.1">(data), value)
           != std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1108.1">end</span></span><span class="koboSpan" id="kobo.1109.1">(data);
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1110.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1111.1">mutable</span></code><span class="koboSpan" id="kobo.1112.1"> specifier allows us to modify the class member on which it was used, even if the containing object is declared </span><code class="inlineCode"><span class="koboSpan" id="kobo.1113.1">const</span></code><span class="koboSpan" id="kobo.1114.1">. </span><span class="koboSpan" id="kobo.1114.2">This is the case of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1115.1">mt</span></code><span class="koboSpan" id="kobo.1116.1"> member of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1117.1">std::mutex</span></code><span class="koboSpan" id="kobo.1118.1"> type, which is modified even within the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1119.1">contains()</span></code><span class="koboSpan" id="kobo.1120.1"> method, which is declared </span><code class="inlineCode"><span class="koboSpan" id="kobo.1121.1">const</span></code><span class="koboSpan" id="kobo.1122.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1123.1">Sometimes, a </span><a id="_idIndexMarker1142"/><span class="koboSpan" id="kobo.1124.1">method or an operator is overloaded to </span><a id="_idIndexMarker1143"/><span class="koboSpan" id="kobo.1125.1">have both constant and non-constant versions. </span><span class="koboSpan" id="kobo.1125.2">This is often the case with the subscript operator or methods that provide direct access to the internal state. </span><span class="koboSpan" id="kobo.1125.3">The reason for this is that the method is supposed to be available for both constant and non-constant objects. </span><span class="koboSpan" id="kobo.1125.4">The behavior should be different, though: for non-constant objects, the method should allow the client to modify the data it provides access to, but for constant objects, it should not. </span><span class="koboSpan" id="kobo.1125.5">Therefore, the non-constant subscript operator returns a reference to a non-constant object, and the constant subscript operator returns a reference to a constant object:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1126.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1127.1">contact</span></span><span class="koboSpan" id="kobo.1128.1"> {};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1129.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1130.1">addressbook</span></span><span class="koboSpan" id="kobo.1131.1">
{
  std::vector&lt;contact&gt; contacts;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1132.1">public</span></span><span class="koboSpan" id="kobo.1133.1">:
  contact&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1134.1">operator</span></span><span class="koboSpan" id="kobo.1135.1">[](</span><span class="hljs-type"><span class="koboSpan" id="kobo.1136.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1137.1">const</span></span><span class="koboSpan" id="kobo.1138.1"> index);
  contact </span><span class="hljs-type"><span class="koboSpan" id="kobo.1139.1">const</span></span><span class="koboSpan" id="kobo.1140.1"> &amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1141.1">operator</span></span><span class="koboSpan" id="kobo.1142.1">[](</span><span class="hljs-type"><span class="koboSpan" id="kobo.1143.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1144.1">const</span></span><span class="koboSpan" id="kobo.1145.1"> index) </span><span class="hljs-type"><span class="koboSpan" id="kobo.1146.1">const</span></span><span class="koboSpan" id="kobo.1147.1">;
};
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1148.1">It should be noted that, if a member function is constant, even if an object is constant, the data that’s returned by this member function may not be constant.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1149.1">An important use case for the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1150.1">const</span></code><span class="koboSpan" id="kobo.1151.1"> is to define references to temporary objects, as shown in the last bullet in the </span><em class="italic"><span class="koboSpan" id="kobo.1152.1">How to do it…</span></em><span class="koboSpan" id="kobo.1153.1"> section. </span><span class="koboSpan" id="kobo.1153.2">A temporary is an rvalue and a non-</span><code class="inlineCode"><span class="koboSpan" id="kobo.1154.1">const</span></code><span class="koboSpan" id="kobo.1155.1"> lvalue reference cannot be bound to an rvalue. </span><span class="koboSpan" id="kobo.1155.2">However, it is possible by making the lvalue reference </span><code class="inlineCode"><span class="koboSpan" id="kobo.1156.1">const</span></code><span class="koboSpan" id="kobo.1157.1">. </span><span class="koboSpan" id="kobo.1157.2">This has the effect of extending the lifetime of the temporary object to the lifetime of the constant reference. </span><span class="koboSpan" id="kobo.1157.3">However, this only works for stack-based references but not for references that are members of objects.</span></p>
<h2 class="heading-2" id="_idParaDest-581"><span class="koboSpan" id="kobo.1158.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1159.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1160.1">const</span></code><span class="koboSpan" id="kobo.1161.1"> qualifier of an object can be removed with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1162.1">const_cast</span></code><span class="koboSpan" id="kobo.1163.1"> conversion, but this should only be used when you know that the object was not declared constant. </span><span class="koboSpan" id="kobo.1163.2">You can read more about this in the </span><em class="italic"><span class="koboSpan" id="kobo.1164.1">Performing correct type casts</span></em><span class="koboSpan" id="kobo.1165.1"> recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-582"><span class="koboSpan" id="kobo.1166.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1167.1">Creating compile-time constant expressions</span></em><span class="koboSpan" id="kobo.1168.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1169.1">constexpr</span></code><span class="koboSpan" id="kobo.1170.1"> specifier and how to define variables and functions that can be evaluated at compile time</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1171.1">Creating immediate functions</span></em><span class="koboSpan" id="kobo.1172.1">, to learn about the C++20 </span><code class="inlineCode"><span class="koboSpan" id="kobo.1173.1">consteval</span></code><span class="koboSpan" id="kobo.1174.1"> specifier, which is used to define functions that are guaranteed to be evaluated at compile time</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1175.1">Performing correct type casts</span></em><span class="koboSpan" id="kobo.1176.1">, to learn about the best practices for performing correct casts in the C++ language</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-583"><span class="koboSpan" id="kobo.1177.1">Creating compile-time constant expressions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1178.1">The </span><a id="_idIndexMarker1144"/><span class="koboSpan" id="kobo.1179.1">possibility to evaluate expressions at compile time improves runtime execution because there is less code to run and the compiler can perform additional optimizations. </span><span class="koboSpan" id="kobo.1179.2">Compile-time constants can be not only literals (such as a number or string), but also the result of a function’s execution. </span><span class="koboSpan" id="kobo.1179.3">If all the input values of a function (regardless of whether they are arguments, locals, or global variables) are known at compile time, the compiler can execute the function and have the result available at compile time. </span><span class="koboSpan" id="kobo.1179.4">This is what generalized the constant expressions that were introduced in C++11, which were relaxed in C++14 and even further in C++20. </span><span class="koboSpan" id="kobo.1179.5">The keyword </span><code class="inlineCode"><span class="koboSpan" id="kobo.1180.1">constexpr</span></code><span class="koboSpan" id="kobo.1181.1"> (short for </span><em class="italic"><span class="koboSpan" id="kobo.1182.1">constant expression</span></em><span class="koboSpan" id="kobo.1183.1">) can be used to declare compile-time constant objects and functions. </span><span class="koboSpan" id="kobo.1183.2">We have seen this in several examples in the previous chapters. </span><span class="koboSpan" id="kobo.1183.3">Now, it’s time to learn how it actually works.</span></p>
<h2 class="heading-2" id="_idParaDest-584"><span class="koboSpan" id="kobo.1184.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1185.1">The way generalized constant expressions work has been relaxed in C++14 and C++20, but this introduced some breaking changes to C++11. </span><span class="koboSpan" id="kobo.1185.2">For instance, in C++11, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1186.1">constexpr</span></code><span class="koboSpan" id="kobo.1187.1"> function was implicitly </span><code class="inlineCode"><span class="koboSpan" id="kobo.1188.1">const</span></code><span class="koboSpan" id="kobo.1189.1">, but this is no longer the case in C++14. </span><span class="koboSpan" id="kobo.1189.2">In this recipe, we will discuss generalized constant expressions, as defined in C++20.</span></p>
<h2 class="heading-2" id="_idParaDest-585"><span class="koboSpan" id="kobo.1190.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1191.1">Use </span><a id="_idIndexMarker1145"/><span class="koboSpan" id="kobo.1192.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1193.1">constexpr</span></code><span class="koboSpan" id="kobo.1194.1"> keyword when you want to:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1195.1">Define non-member functions that can be evaluated at compile time:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1196.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1197.1">unsigned</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1198.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1199.1">factorial</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1200.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1201.1">unsigned</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1202.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1203.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1204.1"> n)</span></span><span class="koboSpan" id="kobo.1205.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1206.1">return</span></span><span class="koboSpan" id="kobo.1207.1"> n &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1208.1">1</span></span><span class="koboSpan" id="kobo.1209.1"> ? </span><span class="koboSpan" id="kobo.1209.2">n * </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1210.1">factorial</span></span><span class="koboSpan" id="kobo.1211.1">(n</span><span class="hljs-number"><span class="koboSpan" id="kobo.1212.1">-1</span></span><span class="koboSpan" id="kobo.1213.1">) : </span><span class="hljs-number"><span class="koboSpan" id="kobo.1214.1">1</span></span><span class="koboSpan" id="kobo.1215.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1216.1">Define constructors that can be executed at compile time to initialize </span><code class="inlineCode"><span class="koboSpan" id="kobo.1217.1">constexpr</span></code><span class="koboSpan" id="kobo.1218.1"> objects and member functions to be invoked during this period:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1219.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1220.1">point3d</span></span><span class="koboSpan" id="kobo.1221.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1222.1">double</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1223.1">const</span></span><span class="koboSpan" id="kobo.1224.1"> x_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1225.1">double</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1226.1">const</span></span><span class="koboSpan" id="kobo.1227.1"> y_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1228.1">double</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1229.1">const</span></span><span class="koboSpan" id="kobo.1230.1"> z_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1231.1">public</span></span><span class="koboSpan" id="kobo.1232.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1233.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1234.1">point3d</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1235.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1236.1">double</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1237.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1238.1"> x = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1239.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1240.1">,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1241.1">double</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1242.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1243.1"> y = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1244.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1245.1">,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1246.1">double</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1247.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1248.1"> z = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1249.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1250.1">)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.1251.1">    :x_{</span></span><span class="koboSpan" id="kobo.1252.1">x}, y_{y}, z_{z}
  {}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1253.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1254.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1255.1">get_x</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1256.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1257.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1258.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1259.1">return</span></span><span class="koboSpan" id="kobo.1260.1"> x_;}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1261.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1262.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1263.1">get_y</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1264.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1265.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1266.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1267.1">return</span></span><span class="koboSpan" id="kobo.1268.1"> y_;}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1269.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1270.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1271.1">get_z</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1272.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1273.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1274.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1275.1">return</span></span><span class="koboSpan" id="kobo.1276.1"> z_;}
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1277.1">Define variables that can have their values evaluated at compile time:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1278.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1279.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1280.1">int</span></span><span class="koboSpan" id="kobo.1281.1"> size = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1282.1">factorial</span></span><span class="koboSpan" id="kobo.1283.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1284.1">6</span></span><span class="koboSpan" id="kobo.1285.1">);
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1286.1">char</span></span><span class="koboSpan" id="kobo.1287.1"> buffer[size] {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1288.1">0</span></span><span class="koboSpan" id="kobo.1289.1">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1290.1">constexpr</span></span><span class="koboSpan" id="kobo.1291.1"> point3d p {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1292.1">0</span></span><span class="koboSpan" id="kobo.1293.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1294.1">1</span></span><span class="koboSpan" id="kobo.1295.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1296.1">2</span></span><span class="koboSpan" id="kobo.1297.1">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1298.1">constexpr</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1299.1">auto</span></span><span class="koboSpan" id="kobo.1300.1"> x = p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1301.1">get_x</span></span><span class="koboSpan" id="kobo.1302.1">();
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-586"><span class="koboSpan" id="kobo.1303.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1304.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1305.1">const</span></code><span class="koboSpan" id="kobo.1306.1"> keyword</span><a id="_idIndexMarker1146"/><span class="koboSpan" id="kobo.1307.1"> is used for declaring variables as constant at runtime; this means that, once initialized, they cannot be changed. </span><span class="koboSpan" id="kobo.1307.2">However, evaluating the constant expression may still imply runtime computation. </span><span class="koboSpan" id="kobo.1307.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1308.1">constexpr</span></code><span class="koboSpan" id="kobo.1309.1"> keyword is used for declaring variables that are constant at compile time or functions that can be executed at compile time. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1310.1">constexpr</span></code><span class="koboSpan" id="kobo.1311.1"> functions and objects can replace macros and hardcoded literals without any performance penalties.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1312.1">Declaring a function as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1313.1">constexpr</span></code><span class="koboSpan" id="kobo.1314.1"> does not mean that it is always evaluated at compile time. </span><span class="koboSpan" id="kobo.1314.2">It only enables the use of the function in expressions that are evaluated during compile time. </span><span class="koboSpan" id="kobo.1314.3">This only happens if all the input values of the function can be evaluated at compile time. </span><span class="koboSpan" id="kobo.1314.4">However, the function may also be invoked at runtime. </span><span class="koboSpan" id="kobo.1314.5">The following code shows two invocations of the same function, first at compile time, and then at runtime:</span></p>
</div>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1315.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1316.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1317.1">int</span></span><span class="koboSpan" id="kobo.1318.1"> size = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1319.1">factorial</span></span><span class="koboSpan" id="kobo.1320.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1321.1">6</span></span><span class="koboSpan" id="kobo.1322.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1323.1">// compile time evaluation</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1324.1">int</span></span><span class="koboSpan" id="kobo.1325.1"> n;
std::cin &gt;&gt; n;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1326.1">auto</span></span><span class="koboSpan" id="kobo.1327.1"> result = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1328.1">factorial</span></span><span class="koboSpan" id="kobo.1329.1">(n);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1330.1">// runtime evaluation</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1331.1">There </span><a id="_idIndexMarker1147"/><span class="koboSpan" id="kobo.1332.1">are some restrictions in regard to where </span><code class="inlineCode"><span class="koboSpan" id="kobo.1333.1">constexpr</span></code><span class="koboSpan" id="kobo.1334.1"> can be used. </span><span class="koboSpan" id="kobo.1334.2">These restrictions have evolved over time, with changes in C++14 and C++20. </span><span class="koboSpan" id="kobo.1334.3">To keep the list in a reasonable form, only the requirements that need to be satisfied in C++20 are shown here:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1335.1">A variable that is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1336.1">constexpr</span></code><span class="koboSpan" id="kobo.1337.1"> must satisfy the following requirements:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1338.1">Its type is a literal type.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1339.1">It is initialized upon declaration.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1340.1">The expression used for initializing the variable is a constant expression.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1341.1">It must have constant destruction. </span><span class="koboSpan" id="kobo.1341.2">This means that it must not be of a class type or an array of a class type; otherwise, the class type must have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1342.1">constexpr</span></code><span class="koboSpan" id="kobo.1343.1"> destructor.</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1344.1">A function that is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1345.1">constexpr</span></code><span class="koboSpan" id="kobo.1346.1"> must satisfy the following requirements:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1347.1">It is not a coroutine.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1348.1">The return type and the type of all its parameters are all literal types.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1349.1">There is at least one set of arguments for which the invocation of the function would produce a constant expression.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1350.1">The function body must not contain </span><code class="inlineCode"><span class="koboSpan" id="kobo.1351.1">goto</span></code><span class="koboSpan" id="kobo.1352.1"> statements, labels (other than </span><code class="inlineCode"><span class="koboSpan" id="kobo.1353.1">case</span></code><span class="koboSpan" id="kobo.1354.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1355.1">default</span></code><span class="koboSpan" id="kobo.1356.1"> in a switch), and local variables that are either of non-literal types or of static or thread storage duration. </span><span class="koboSpan" id="kobo.1356.2">The restrictions mentioned in this bullet point were removed in C++23.</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1357.1">A constructor that is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1358.1">constexpr</span></code><span class="koboSpan" id="kobo.1359.1"> must satisfy the following requirements, in addition to the preceding ones required for functions:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1360.1">There is no virtual base class for the class.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1361.1">All the constructors that initialize non-static data members, including base classes, must also be </span><code class="inlineCode"><span class="koboSpan" id="kobo.1362.1">constexpr</span></code><span class="koboSpan" id="kobo.1363.1">.</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1364.1">A destructor that is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1365.1">constexpr</span></code><span class="koboSpan" id="kobo.1366.1">, available only since C++20, must satisfy the following requirements, in addition to the preceding ones required for functions:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1367.1">There is no virtual base class for the class.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1368.1">All the destructors that destroy non-static data members, including base classes, must also be </span><code class="inlineCode"><span class="koboSpan" id="kobo.1369.1">constexpr</span></code><span class="koboSpan" id="kobo.1370.1">.</span></li>
</ul>
</li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1371.1">All the restrictions for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1372.1">constexpr</span></code><span class="koboSpan" id="kobo.1373.1"> constructors and destructors mentioned here were removed in C++23.</span></p>
</div>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.1374.1">For a complete list of requirements in different versions of the standard, you should read the online documentation available at </span><a href="https://en.cppreference.com/w/cpp/language/constexpr"><span class="url"><span class="koboSpan" id="kobo.1375.1">https://en.cppreference.com/w/cpp/language/constexpr</span></span></a><span class="koboSpan" id="kobo.1376.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1377.1">A </span><a id="_idIndexMarker1148"/><span class="koboSpan" id="kobo.1378.1">function that is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1379.1">constexpr</span></code><span class="koboSpan" id="kobo.1380.1"> is not implicitly </span><code class="inlineCode"><span class="koboSpan" id="kobo.1381.1">const</span></code><span class="koboSpan" id="kobo.1382.1"> (as of C++14), so you need to explicitly use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1383.1">const</span></code><span class="koboSpan" id="kobo.1384.1"> specifier if the function does not alter the logical state of the object. </span><span class="koboSpan" id="kobo.1384.2">However, a function that is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1385.1">constexpr</span></code><span class="koboSpan" id="kobo.1386.1"> is implicitly </span><code class="inlineCode"><span class="koboSpan" id="kobo.1387.1">inline</span></code><span class="koboSpan" id="kobo.1388.1">. </span><span class="koboSpan" id="kobo.1388.2">On the other hand, an object that is declared </span><code class="inlineCode"><span class="koboSpan" id="kobo.1389.1">constexpr</span></code><span class="koboSpan" id="kobo.1390.1"> is implicitly </span><code class="inlineCode"><span class="koboSpan" id="kobo.1391.1">const</span></code><span class="koboSpan" id="kobo.1392.1">. </span><span class="koboSpan" id="kobo.1392.2">The following two declarations are equivalent:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1393.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1394.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1395.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1396.1">int</span></span><span class="koboSpan" id="kobo.1397.1"> size = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1398.1">factorial</span></span><span class="koboSpan" id="kobo.1399.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1400.1">6</span></span><span class="koboSpan" id="kobo.1401.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1402.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1403.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1404.1">int</span></span><span class="koboSpan" id="kobo.1405.1"> size = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1406.1">factorial</span></span><span class="koboSpan" id="kobo.1407.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1408.1">6</span></span><span class="koboSpan" id="kobo.1409.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1410.1">There are situations when you may need to use both </span><code class="inlineCode"><span class="koboSpan" id="kobo.1411.1">constexpr</span></code><span class="koboSpan" id="kobo.1412.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1413.1">const</span></code><span class="koboSpan" id="kobo.1414.1"> in a declaration, as they would refer to different parts of the declaration. </span><span class="koboSpan" id="kobo.1414.2">In the following example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1415.1">p</span></code><span class="koboSpan" id="kobo.1416.1"> is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1417.1">constexpr</span></code><span class="koboSpan" id="kobo.1418.1"> pointer to a constant integer:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1419.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1420.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1421.1">int</span></span><span class="koboSpan" id="kobo.1422.1"> c = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1423.1">42</span></span><span class="koboSpan" id="kobo.1424.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1425.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1426.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1427.1">const</span></span><span class="koboSpan" id="kobo.1428.1"> * p = &amp;c;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1429.1">Reference variables can also be </span><code class="inlineCode"><span class="koboSpan" id="kobo.1430.1">constexpr</span></code><span class="koboSpan" id="kobo.1431.1"> if, and only if, they alias an object with static storage duration or a function. </span><span class="koboSpan" id="kobo.1431.2">The following snippet provides an example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1432.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1433.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1434.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1435.1">const</span></span><span class="koboSpan" id="kobo.1436.1"> &amp; r = c;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1437.1">In </span><a id="_idIndexMarker1149"/><span class="koboSpan" id="kobo.1438.1">this example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1439.1">r</span></code><span class="koboSpan" id="kobo.1440.1"> is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1441.1">constexpr</span></code><span class="koboSpan" id="kobo.1442.1"> reference that defines an alias for the compile-time constant variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.1443.1">c</span></code><span class="koboSpan" id="kobo.1444.1">, defined in the previous snippet.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1445.1">Although you can define static </span><code class="inlineCode"><span class="koboSpan" id="kobo.1446.1">constexpr</span></code><span class="koboSpan" id="kobo.1447.1"> variables, doing so in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1448.1">constexpr</span></code><span class="koboSpan" id="kobo.1449.1"> function was not possible until C++23. </span><span class="koboSpan" id="kobo.1449.2">The following snippet shows such an example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1450.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1451.1">char</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1452.1">symbol_table</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1453.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1454.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1455.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1456.1"> n)</span></span><span class="koboSpan" id="kobo.1457.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1458.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1459.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1460.1">char</span></span><span class="koboSpan" id="kobo.1461.1"> symbols[] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1462.1">"!@#$%^&amp;*"</span></span><span class="koboSpan" id="kobo.1463.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1464.1">// error until C++23</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1465.1">return</span></span><span class="koboSpan" id="kobo.1466.1"> symbols[n % </span><span class="hljs-number"><span class="koboSpan" id="kobo.1467.1">8</span></span><span class="koboSpan" id="kobo.1468.1">];
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1469.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1470.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1471.1">()</span></span><span class="koboSpan" id="kobo.1472.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1473.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1474.1">char</span></span><span class="koboSpan" id="kobo.1475.1"> s = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1476.1">symbol_table</span></span><span class="koboSpan" id="kobo.1477.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1478.1">42</span></span><span class="koboSpan" id="kobo.1479.1">);
    std::cout &lt;&lt; s &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1480.1">'\n'</span></span><span class="koboSpan" id="kobo.1481.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1482.1">The declaration of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1483.1">symbols</span></code><span class="koboSpan" id="kobo.1484.1"> variable would generate a compiler error, prior to C++23. </span><span class="koboSpan" id="kobo.1484.2">A possible workaround for this problem was to define the variable outside of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1485.1">constexpr</span></code><span class="koboSpan" id="kobo.1486.1"> function, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1487.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1488.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1489.1">char</span></span><span class="koboSpan" id="kobo.1490.1"> symbols[] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1491.1">"!@#$%^&amp;*"</span></span><span class="koboSpan" id="kobo.1492.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1493.1">// OK</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1494.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1495.1">char</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1496.1">symbol_table</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1497.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1498.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1499.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1500.1"> n)</span></span><span class="koboSpan" id="kobo.1501.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1502.1">return</span></span><span class="koboSpan" id="kobo.1503.1"> symbols[n % </span><span class="hljs-number"><span class="koboSpan" id="kobo.1504.1">8</span></span><span class="koboSpan" id="kobo.1505.1">];
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1506.1">This problem has been solved in C++23, which relaxed several </span><code class="inlineCode"><span class="koboSpan" id="kobo.1507.1">constexpr</span></code><span class="koboSpan" id="kobo.1508.1"> restrictions, making a workaround unnecessary. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1509.1">One more aspect that should be mentioned on constexpr functions is related to exceptions. </span><span class="koboSpan" id="kobo.1509.2">Since C++20, try-catch blocks are allowed in constexpr functions (their use was not possible prior to this version). </span><span class="koboSpan" id="kobo.1509.3">However, throwing exceptions from constant expressions is not allowed. </span><span class="koboSpan" id="kobo.1509.4">Although you can have a throw statement in a constexpr function, the behavior is as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1510.1">When executed at runtime, it would behave as if it wasn’t declared constexpr.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1511.1">When executed at compile time, if the execution path encounters a throw statement, a compiler error is emitted.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1512.1">This </span><a id="_idIndexMarker1150"/><span class="koboSpan" id="kobo.1513.1">is exemplified in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1514.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1515.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1516.1">factorial2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1517.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1518.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1519.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1520.1"> n)</span></span><span class="koboSpan" id="kobo.1521.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1522.1">if</span></span><span class="koboSpan" id="kobo.1523.1">(n &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1524.1">0</span></span><span class="koboSpan" id="kobo.1525.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1526.1">throw</span></span><span class="koboSpan" id="kobo.1527.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1528.1">invalid_argument</span></span><span class="koboSpan" id="kobo.1529.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1530.1">"n must be positive"</span></span><span class="koboSpan" id="kobo.1531.1">);
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1532.1">return</span></span><span class="koboSpan" id="kobo.1533.1"> n &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1534.1">1</span></span><span class="koboSpan" id="kobo.1535.1"> ? </span><span class="koboSpan" id="kobo.1535.2">n * </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1536.1">factorial2</span></span><span class="koboSpan" id="kobo.1537.1">(n - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1538.1">1</span></span><span class="koboSpan" id="kobo.1539.1">) : </span><span class="hljs-number"><span class="koboSpan" id="kobo.1540.1">1</span></span><span class="koboSpan" id="kobo.1541.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1542.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1543.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1544.1">()</span></span><span class="koboSpan" id="kobo.1545.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1546.1">try</span></span><span class="koboSpan" id="kobo.1547.1">
   {
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.1548.1">int</span></span><span class="koboSpan" id="kobo.1549.1"> a = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1550.1">factorial2</span></span><span class="koboSpan" id="kobo.1551.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1552.1">5</span></span><span class="koboSpan" id="kobo.1553.1">);
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.1554.1">int</span></span><span class="koboSpan" id="kobo.1555.1"> b = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1556.1">factorial2</span></span><span class="koboSpan" id="kobo.1557.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1558.1">-5</span></span><span class="koboSpan" id="kobo.1559.1">);
   }
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1560.1">catch</span></span><span class="koboSpan" id="kobo.1561.1"> (std::exception </span><span class="hljs-type"><span class="koboSpan" id="kobo.1562.1">const</span></span><span class="koboSpan" id="kobo.1563.1">&amp; ex)
   {
      std::cout &lt;&lt; ex.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1564.1">what</span></span><span class="koboSpan" id="kobo.1565.1">() &lt;&lt; std::endl;
   }         
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1566.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1567.1">int</span></span><span class="koboSpan" id="kobo.1568.1"> c = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1569.1">factorial2</span></span><span class="koboSpan" id="kobo.1570.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1571.1">5</span></span><span class="koboSpan" id="kobo.1572.1">);
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1573.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1574.1">int</span></span><span class="koboSpan" id="kobo.1575.1"> d = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1576.1">factorial2</span></span><span class="koboSpan" id="kobo.1577.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1578.1">-5</span></span><span class="koboSpan" id="kobo.1579.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1580.1">// error</span></span><span class="koboSpan" id="kobo.1581.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1582.1">In this snippet:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1583.1">The first two calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1584.1">factorial2()</span></code><span class="koboSpan" id="kobo.1585.1"> are executed at runtime. </span><span class="koboSpan" id="kobo.1585.2">The first executes successfully and returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.1586.1">60</span></code><span class="koboSpan" id="kobo.1587.1">. </span><span class="koboSpan" id="kobo.1587.2">The second throws a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1588.1">std::invalid_argument</span></code><span class="koboSpan" id="kobo.1589.1"> exception because the argument is negative.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1590.1">The third call is evaluated at compile time because variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.1591.1">c</span></code><span class="koboSpan" id="kobo.1592.1"> is declared </span><code class="inlineCode"><span class="koboSpan" id="kobo.1593.1">constexpr</span></code><span class="koboSpan" id="kobo.1594.1"> and all the function’s inputs are also known at compile time. </span><span class="koboSpan" id="kobo.1594.2">The invocation is successful and the function evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1595.1">60</span></code><span class="koboSpan" id="kobo.1596.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1597.1">The fourth call is also evaluated at compile time, but since the argument is negative the path that throws an exception should execute. </span><span class="koboSpan" id="kobo.1597.2">However, this is not allowed in constant expressions, and, therefore, the compiler issues an error.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-587"><span class="koboSpan" id="kobo.1598.1">There’s more…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1599.1">In C++20, a </span><a id="_idIndexMarker1151"/><span class="koboSpan" id="kobo.1600.1">new specifier was added to the language. </span><span class="koboSpan" id="kobo.1600.2">This specifier is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1601.1">constinit</span></code><span class="koboSpan" id="kobo.1602.1"> and is used to ensure that variables with static or thread storage duration have static initialization. </span><span class="koboSpan" id="kobo.1602.2">In C++, the initialization of variables can be either static or dynamic. </span><span class="koboSpan" id="kobo.1602.3">Static initialization can be either zero initialization (when the initial value of an object is set to zero) or constant initialization (when the initial value is set to a compile-time expression). </span><span class="koboSpan" id="kobo.1602.4">The following snippet shows examples of zero and constant initialization:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1603.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1604.1">foo</span></span><span class="koboSpan" id="kobo.1605.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1606.1">int</span></span><span class="koboSpan" id="kobo.1607.1"> a;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1608.1">int</span></span><span class="koboSpan" id="kobo.1609.1"> b;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1610.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1611.1">bar</span></span><span class="koboSpan" id="kobo.1612.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1613.1">int</span></span><span class="koboSpan" id="kobo.1614.1">   value;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1615.1">int</span></span><span class="koboSpan" id="kobo.1616.1">*  ptr;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1617.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1618.1">bar</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1619.1">()</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1620.1"> :value{</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1621.1">0</span></span><span class="koboSpan" id="kobo.1622.1"> }, ptr{ </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1623.1">nullptr</span></span><span class="koboSpan" id="kobo.1624.1"> } {}
};
std::string text {};  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1625.1">// zero-initialized to unspecified value</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1626.1">double</span></span><span class="koboSpan" id="kobo.1627.1"> arr[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1628.1">10</span></span><span class="koboSpan" id="kobo.1629.1">];       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1630.1">// zero-initialized to ten 0.0</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1631.1">int</span></span><span class="koboSpan" id="kobo.1632.1">* ptr;             </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1633.1">// zero-initialized to nullptr</span></span><span class="koboSpan" id="kobo.1634.1">
foo f = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1635.1">foo</span></span><span class="koboSpan" id="kobo.1636.1">();        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1637.1">// zero-initialized to a=0, b=0</span></span><span class="koboSpan" id="kobo.1638.1">
foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.1639.1">const</span></span><span class="koboSpan" id="kobo.1640.1"> fc{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1641.1">1</span></span><span class="koboSpan" id="kobo.1642.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1643.1">2</span></span><span class="koboSpan" id="kobo.1644.1"> }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1645.1">// const-initialized at runtime</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1646.1">constexpr</span></span><span class="koboSpan" id="kobo.1647.1"> bar b;      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1648.1">// const-initialized at compile-time</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1649.1">A variable that has static storage could have either static or dynamic initialization. </span><span class="koboSpan" id="kobo.1649.2">In the latter case, hard-to-find bugs may appear. </span><span class="koboSpan" id="kobo.1649.3">Imagine two static objects that are initialized in different translation units.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1650.1">When the </span><a id="_idIndexMarker1152"/><span class="koboSpan" id="kobo.1651.1">initialization of one of the two objects depends on the other object, then the order they are initialized in is important. </span><span class="koboSpan" id="kobo.1651.2">This is because the object that depends on the object must be initialized first. </span><span class="koboSpan" id="kobo.1651.3">However, the order of the initialization of the translation units is not deterministic, so there is no guarantee of the order of these objects’ initialization. </span><span class="koboSpan" id="kobo.1651.4">However, variables with static storage duration that have static initialization are initialized at compile time. </span><span class="koboSpan" id="kobo.1651.5">This implies that these objects can be safely used when performing dynamic initialization of translation units.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1652.1">This is what the new specifier, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1653.1">constinit</span></code><span class="koboSpan" id="kobo.1654.1">, is intended for. </span><span class="koboSpan" id="kobo.1654.2">It ensures that a variable with static or thread-local storage has static initialization, and, therefore, its initialization is performed at compile time:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1655.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1656.1">f</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1657.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1658.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1659.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1660.1">42</span></span><span class="koboSpan" id="kobo.1661.1">; }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1662.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1663.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1664.1">g</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1665.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1666.1">bool</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1667.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1668.1"> c)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1669.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1670.1">return</span></span><span class="koboSpan" id="kobo.1671.1"> c ? </span><span class="hljs-number"><span class="koboSpan" id="kobo.1672.1">0</span></span><span class="koboSpan" id="kobo.1673.1"> : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1674.1">f</span></span><span class="koboSpan" id="kobo.1675.1">(); }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1676.1">constinit</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1677.1">int</span></span><span class="koboSpan" id="kobo.1678.1"> c = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1679.1">g</span></span><span class="koboSpan" id="kobo.1680.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1681.1">true</span></span><span class="koboSpan" id="kobo.1682.1">);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1683.1">// OK</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1684.1">constinit</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1685.1">int</span></span><span class="koboSpan" id="kobo.1686.1"> d = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1687.1">g</span></span><span class="koboSpan" id="kobo.1688.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1689.1">false</span></span><span class="koboSpan" id="kobo.1690.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1691.1">/* error: variable does not have</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1692.1">                                      a constant initializer */</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1693.1">It can also be used in a non-initializing declaration to indicate that a variable with thread storage duration is already initialized, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1694.1">extern</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1695.1">thread_local</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1696.1">constinit</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1697.1">int</span></span><span class="koboSpan" id="kobo.1698.1"> data;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1699.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1700.1">get_data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1701.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1702.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1703.1">return</span></span><span class="koboSpan" id="kobo.1704.1"> data; }
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1705.1">You cannot use more than one of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1706.1">constexpr</span></code><span class="koboSpan" id="kobo.1707.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1708.1">constinit</span></code><span class="koboSpan" id="kobo.1709.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1710.1">consteval</span></code><span class="koboSpan" id="kobo.1711.1"> specifiers in the same declaration.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-588"><span class="koboSpan" id="kobo.1712.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1713.1">Creating immediate functions</span></em><span class="koboSpan" id="kobo.1714.1">, to learn about the C++20 </span><code class="inlineCode"><span class="koboSpan" id="kobo.1715.1">consteval</span></code><span class="koboSpan" id="kobo.1716.1"> specifier, which is used to define functions that are guaranteed to be evaluated at compile time</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1717.1">Ensuring constant correctness for a program</span></em><span class="koboSpan" id="kobo.1718.1">, to explore the benefits of constant correctness and how to achieve it</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-589"><span class="koboSpan" id="kobo.1719.1">Creating immediate functions</span></h1>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1720.1">constexpr</span></code><span class="koboSpan" id="kobo.1721.1"> functions </span><a id="_idIndexMarker1153"/><span class="koboSpan" id="kobo.1722.1">enable the evaluation of functions at compile time, provided that all their inputs, if any, are also available at compile time. </span><span class="koboSpan" id="kobo.1722.2">However, this is not a guarantee, and constexpr functions may also execute at runtime, as we have seen in the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.1723.1">Creating compile-time constant expressions</span></em><span class="koboSpan" id="kobo.1724.1">. </span><span class="koboSpan" id="kobo.1724.2">In C++20, a new category of functions has been introduced: </span><em class="italic"><span class="koboSpan" id="kobo.1725.1">immediate functions</span></em><span class="koboSpan" id="kobo.1726.1">. </span><span class="koboSpan" id="kobo.1726.2">These are functions that are guaranteed to always be evaluated at compile time; otherwise, they produce errors. </span><span class="koboSpan" id="kobo.1726.3">Immediate functions are useful as replacements for macros and may be important in the possible future development of the language with reflection and meta-classes.</span></p>
<h2 class="heading-2" id="_idParaDest-590"><span class="koboSpan" id="kobo.1727.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1728.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1729.1">consteval</span></code><span class="koboSpan" id="kobo.1730.1"> keyword </span><a id="_idIndexMarker1154"/><span class="koboSpan" id="kobo.1731.1">when you want to:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1732.1">Define non-member functions or function templates that must be evaluated at compile time:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1733.1">consteval</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1734.1">unsigned</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1735.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1736.1">factorial</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1737.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1738.1">unsigned</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1739.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1740.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1741.1"> n)</span></span><span class="koboSpan" id="kobo.1742.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1743.1">return</span></span><span class="koboSpan" id="kobo.1744.1"> n &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1745.1">1</span></span><span class="koboSpan" id="kobo.1746.1"> ? </span><span class="koboSpan" id="kobo.1746.2">n * </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1747.1">factorial</span></span><span class="koboSpan" id="kobo.1748.1">(n</span><span class="hljs-number"><span class="koboSpan" id="kobo.1749.1">-1</span></span><span class="koboSpan" id="kobo.1750.1">) : </span><span class="hljs-number"><span class="koboSpan" id="kobo.1751.1">1</span></span><span class="koboSpan" id="kobo.1752.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1753.1">Define constructors that must be executed at compile time to initialize </span><code class="inlineCode"><span class="koboSpan" id="kobo.1754.1">constexpr</span></code><span class="koboSpan" id="kobo.1755.1"> objects and member functions to be invoked only at compile time:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1756.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1757.1">point3d</span></span><span class="koboSpan" id="kobo.1758.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1759.1">double</span></span><span class="koboSpan" id="kobo.1760.1"> x_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1761.1">double</span></span><span class="koboSpan" id="kobo.1762.1"> y_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1763.1">double</span></span><span class="koboSpan" id="kobo.1764.1"> z_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1765.1">public</span></span><span class="koboSpan" id="kobo.1766.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1767.1">consteval</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1768.1">point3d</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1769.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1770.1">double</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1771.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1772.1"> x = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1773.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1774.1">,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1775.1">double</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1776.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1777.1"> y = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1778.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1779.1">,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1780.1">double</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1781.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1782.1"> z = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1783.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1784.1">)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.1785.1">    :x_{</span></span><span class="koboSpan" id="kobo.1786.1">x}, y_{y}, z_{z}
  {}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1787.1">consteval</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1788.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1789.1">get_x</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1790.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1791.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1792.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1793.1">return</span></span><span class="koboSpan" id="kobo.1794.1"> x_;}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1795.1">consteval</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1796.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1797.1">get_y</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1798.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1799.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1800.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1801.1">return</span></span><span class="koboSpan" id="kobo.1802.1"> y_;}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1803.1">consteval</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1804.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1805.1">get_z</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1806.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1807.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1808.1">{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1809.1">return</span></span><span class="koboSpan" id="kobo.1810.1"> z_;}
};
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-591"><span class="koboSpan" id="kobo.1811.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1812.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1813.1">consteval</span></code><span class="koboSpan" id="kobo.1814.1"> specifier was introduced in C++20. </span><span class="koboSpan" id="kobo.1814.2">It can only be applied to functions and function templates and defines them as immediate functions. </span><span class="koboSpan" id="kobo.1814.3">This means that any function invocation must be evaluated at compile time and therefore produce a compile-time constant expression. </span><span class="koboSpan" id="kobo.1814.4">If the function cannot be evaluated at compile time, the program is ill-formed and the compiler issues an error.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1815.1">The following rules apply</span><a id="_idIndexMarker1155"/><span class="koboSpan" id="kobo.1816.1"> to immediate functions:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1817.1">Destructors, allocation, and deallocation functions cannot be immediate functions.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1818.1">If any declaration of a function contains the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1819.1">consteval</span></code><span class="koboSpan" id="kobo.1820.1"> specifier, then all the declarations of that function must also include it.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1821.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1822.1">consteval</span></code><span class="koboSpan" id="kobo.1823.1"> specifier cannot be used together with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1824.1">constexpr</span></code><span class="koboSpan" id="kobo.1825.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1826.1">constinit</span></code><span class="koboSpan" id="kobo.1827.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1828.1">An immediate function is an inline </span><code class="inlineCode"><span class="koboSpan" id="kobo.1829.1">constexpr</span></code><span class="koboSpan" id="kobo.1830.1"> function. </span><span class="koboSpan" id="kobo.1830.2">Therefore, immediate functions and function templates must satisfy the requirements applicable to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1831.1">constexpr</span></code><span class="koboSpan" id="kobo.1832.1"> functions.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1833.1">Here is how we can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1834.1">factorial()</span></code><span class="koboSpan" id="kobo.1835.1"> function and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1836.1">point3d</span></code><span class="koboSpan" id="kobo.1837.1"> class defined in the previous section:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1838.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1839.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1840.1">int</span></span><span class="koboSpan" id="kobo.1841.1"> f = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1842.1">factorial</span></span><span class="koboSpan" id="kobo.1843.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1844.1">6</span></span><span class="koboSpan" id="kobo.1845.1">);
std::cout &lt;&lt; f &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1846.1">'\n'</span></span><span class="koboSpan" id="kobo.1847.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1848.1">constexpr</span></span><span class="koboSpan" id="kobo.1849.1"> point3d p {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1850.1">0</span></span><span class="koboSpan" id="kobo.1851.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1852.1">1</span></span><span class="koboSpan" id="kobo.1853.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1854.1">2</span></span><span class="koboSpan" id="kobo.1855.1">};
std::cout &lt;&lt; p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1856.1">get_x</span></span><span class="koboSpan" id="kobo.1857.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1858.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1859.1"> '</span></span><span class="koboSpan" id="kobo.1860.1"> &lt;&lt; p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1861.1">get_y</span></span><span class="koboSpan" id="kobo.1862.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1863.1">' '</span></span><span class="koboSpan" id="kobo.1864.1"> &lt;&lt; p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1865.1">get_z</span></span><span class="koboSpan" id="kobo.1866.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1867.1">'\n'</span></span><span class="koboSpan" id="kobo.1868.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1869.1">However, the following sample produces compiler errors because the immediate function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1870.1">factorial()</span></code><span class="koboSpan" id="kobo.1871.1"> and the constructor of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1872.1">point3d</span></code><span class="koboSpan" id="kobo.1873.1"> cannot be evaluated at compile time:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1874.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1875.1">int</span></span><span class="koboSpan" id="kobo.1876.1"> n;
std::cin &gt;&gt; n;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1877.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1878.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1879.1">int</span></span><span class="koboSpan" id="kobo.1880.1"> f2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1881.1">factorial</span></span><span class="koboSpan" id="kobo.1882.1">(n); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1883.1">// error</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1884.1">double</span></span><span class="koboSpan" id="kobo.1885.1"> x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1886.1">0</span></span><span class="koboSpan" id="kobo.1887.1">, y = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1888.1">1</span></span><span class="koboSpan" id="kobo.1889.1">, z = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1890.1">2</span></span><span class="koboSpan" id="kobo.1891.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1892.1">constexpr</span></span><span class="koboSpan" id="kobo.1893.1"> point3d p2 {x, y, z};       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1894.1">// error</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1895.1">It is not possible to</span><a id="_idIndexMarker1156"/><span class="koboSpan" id="kobo.1896.1"> take the address on an immediate function unless it is also in a constant expression:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1897.1">using</span></span><span class="koboSpan" id="kobo.1898.1"> pfact = </span><span class="hljs-type"><span class="koboSpan" id="kobo.1899.1">unsigned</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1900.1">int</span></span><span class="koboSpan" id="kobo.1901.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1902.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1903.1">int</span></span><span class="koboSpan" id="kobo.1904.1">);
pfact* pf = factorial;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1905.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1906.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1907.1">int</span></span><span class="koboSpan" id="kobo.1908.1"> f3 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1909.1">pf</span></span><span class="koboSpan" id="kobo.1910.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1911.1">42</span></span><span class="koboSpan" id="kobo.1912.1">);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1913.1">// error</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1914.1">consteval</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1915.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1916.1">addr_factorial</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1917.1">()</span></span><span class="koboSpan" id="kobo.1918.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1919.1">return</span></span><span class="koboSpan" id="kobo.1920.1"> &amp;factorial;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1921.1">consteval</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1922.1">unsigned</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1923.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1924.1">invoke_factorial</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1925.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1926.1">unsigned</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1927.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1928.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1929.1"> n)</span></span><span class="koboSpan" id="kobo.1930.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1931.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1932.1">addr_factorial</span></span><span class="koboSpan" id="kobo.1933.1">()(n);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1934.1">constexpr</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1935.1">auto</span></span><span class="koboSpan" id="kobo.1936.1"> ptr = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1937.1">addr_factorial</span></span><span class="koboSpan" id="kobo.1938.1">();
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1939.1">// ERROR: cannot take the pointer of an immediate function</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1940.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1941.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1942.1">int</span></span><span class="koboSpan" id="kobo.1943.1"> f2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1944.1">invoke_factorial</span></span><span class="koboSpan" id="kobo.1945.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1946.1">5</span></span><span class="koboSpan" id="kobo.1947.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1948.1">// OK</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1949.1">Because immediate functions are not visible at runtime, their symbols are not emitted for them and debuggers will not be able to show them.</span></p>
<h2 class="heading-2" id="_idParaDest-592"><span class="koboSpan" id="kobo.1950.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1951.1">Ensuring constant correctness for a program</span></em><span class="koboSpan" id="kobo.1952.1">, to explore the benefits of constant correctness and how to achieve it</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1953.1">Creating compile-time constant expressions</span></em><span class="koboSpan" id="kobo.1954.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1955.1">constexpr</span></code><span class="koboSpan" id="kobo.1956.1"> specifier and how to define variables and functions that can be evaluated at compile time</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-593"><span class="koboSpan" id="kobo.1957.1">Optimizing code in constant-evaluated contexts</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1958.1">In the </span><a id="_idIndexMarker1157"/><span class="koboSpan" id="kobo.1959.1">previous two recipes, we learned</span><a id="_idIndexMarker1158"/><span class="koboSpan" id="kobo.1960.1"> about </span><em class="italic"><span class="koboSpan" id="kobo.1961.1">constexpr functions</span></em><span class="koboSpan" id="kobo.1962.1">, which allow functions to be evaluated at compile time if all their inputs are available at compile time, and </span><em class="italic"><span class="koboSpan" id="kobo.1963.1">immediate functions</span></em><span class="koboSpan" id="kobo.1964.1"> (in C++20), which are guaranteed to always be evaluated at compile time (or otherwise, produce an error). </span><span class="koboSpan" id="kobo.1964.2">An </span><a id="_idIndexMarker1159"/><span class="koboSpan" id="kobo.1965.1">important aspect of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1966.1">constexpr</span></code><span class="koboSpan" id="kobo.1967.1"> functions is constant-evaluated contexts; these are code paths where all expressions and functions are evaluated at compile time. </span><span class="koboSpan" id="kobo.1967.2">A constant-evaluated context is useful for optimizing code more effectively. </span><span class="koboSpan" id="kobo.1967.3">On the other hand, the invocation of immediate functions from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1968.1">constexpr</span></code><span class="koboSpan" id="kobo.1969.1"> functions is only possible in C++23. </span><span class="koboSpan" id="kobo.1969.2">In this recipe, we will learn about utilizing constant-evaluated contexts.</span></p>
<h2 class="heading-2" id="_idParaDest-594"><span class="koboSpan" id="kobo.1970.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1971.1">To </span><a id="_idIndexMarker1160"/><span class="koboSpan" id="kobo.1972.1">determine whether a function context is constant-evaluated in order to provide compile-time implementations use the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1973.1">In C++20, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1974.1">std::is_constant_evaluated()</span></code><span class="koboSpan" id="kobo.1975.1"> library function, available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1976.1">&lt;type_traits&gt;</span></code><span class="koboSpan" id="kobo.1977.1"> header, with a regular </span><code class="inlineCode"><span class="koboSpan" id="kobo.1978.1">if</span></code><span class="koboSpan" id="kobo.1979.1"> statement:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1980.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1981.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1982.1">power</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1983.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1984.1">double</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1985.1"> base, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1986.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1987.1"> exponent)</span></span><span class="koboSpan" id="kobo.1988.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1989.1">if</span></span><span class="koboSpan" id="kobo.1990.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1991.1">is_constant_evaluated</span></span><span class="koboSpan" id="kobo.1992.1">())
   {
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.1993.1">double</span></span><span class="koboSpan" id="kobo.1994.1"> result = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1995.1">1.0</span></span><span class="koboSpan" id="kobo.1996.1">;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1997.1">if</span></span><span class="koboSpan" id="kobo.1998.1"> (exponent == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1999.1">0</span></span><span class="koboSpan" id="kobo.2000.1">)
      {
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2001.1">return</span></span><span class="koboSpan" id="kobo.2002.1"> result;
      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2003.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2004.1">if</span></span><span class="koboSpan" id="kobo.2005.1"> (exponent &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2006.1">0</span></span><span class="koboSpan" id="kobo.2007.1">) {
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2008.1">for</span></span><span class="koboSpan" id="kobo.2009.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.2010.1">int</span></span><span class="koboSpan" id="kobo.2011.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2012.1">0</span></span><span class="koboSpan" id="kobo.2013.1">; i &lt; exponent; i++) {
              result *= base;
          }
      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2014.1">else</span></span><span class="koboSpan" id="kobo.2015.1"> {
          exponent = -exponent;
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2016.1">for</span></span><span class="koboSpan" id="kobo.2017.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.2018.1">int</span></span><span class="koboSpan" id="kobo.2019.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2020.1">0</span></span><span class="koboSpan" id="kobo.2021.1">; i &lt; exponent; i++) {
              result *= base;
          }
          result = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2022.1">1.0</span></span><span class="koboSpan" id="kobo.2023.1"> / result;
      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2024.1">return</span></span><span class="koboSpan" id="kobo.2025.1"> result;
   }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2026.1">else</span></span><span class="koboSpan" id="kobo.2027.1">
   {
       </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2028.1">return</span></span><span class="koboSpan" id="kobo.2029.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2030.1">pow</span></span><span class="koboSpan" id="kobo.2031.1">(base, exponent);
   }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2032.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2033.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2034.1">()</span></span><span class="koboSpan" id="kobo.2035.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2036.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2037.1">double</span></span><span class="koboSpan" id="kobo.2038.1"> a = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2039.1">power</span></span><span class="koboSpan" id="kobo.2040.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2041.1">10</span></span><span class="koboSpan" id="kobo.2042.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2043.1">5</span></span><span class="koboSpan" id="kobo.2044.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2045.1">// compile-time eval</span></span><span class="koboSpan" id="kobo.2046.1">
   std::cout &lt;&lt; a &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2047.1">'\n'</span></span><span class="koboSpan" id="kobo.2048.1">;
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2049.1">double</span></span><span class="koboSpan" id="kobo.2050.1"> b = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2051.1">power</span></span><span class="koboSpan" id="kobo.2052.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2053.1">10</span></span><span class="koboSpan" id="kobo.2054.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2055.1">5</span></span><span class="koboSpan" id="kobo.2056.1">);           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2057.1">// runtime eval</span></span><span class="koboSpan" id="kobo.2058.1">
   std::cout &lt;&lt; b &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2059.1">'\n'</span></span><span class="koboSpan" id="kobo.2060.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2061.1">In C++23, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2062.1">if consteval</span></code><span class="koboSpan" id="kobo.2063.1"> statement, which</span><a id="_idIndexMarker1161"/><span class="koboSpan" id="kobo.2064.1"> is a simplification (with additional benefits) of</span><a id="_idIndexMarker1162"/><span class="koboSpan" id="kobo.2065.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2066.1">if(std::is_constant_evaluated())</span></code><span class="koboSpan" id="kobo.2067.1"> statement:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2068.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2069.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2070.1">power</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2071.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2072.1">double</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2073.1"> base, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2074.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2075.1"> exponent)</span></span><span class="koboSpan" id="kobo.2076.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2077.1">if</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2078.1">consteval</span></span><span class="koboSpan" id="kobo.2079.1">
   {
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.2080.1">double</span></span><span class="koboSpan" id="kobo.2081.1"> result = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2082.1">1.0</span></span><span class="koboSpan" id="kobo.2083.1">;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2084.1">if</span></span><span class="koboSpan" id="kobo.2085.1"> (exponent == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2086.1">0</span></span><span class="koboSpan" id="kobo.2087.1">)
      {
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2088.1">return</span></span><span class="koboSpan" id="kobo.2089.1"> result;
      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2090.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2091.1">if</span></span><span class="koboSpan" id="kobo.2092.1"> (exponent &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2093.1">0</span></span><span class="koboSpan" id="kobo.2094.1">) {
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2095.1">for</span></span><span class="koboSpan" id="kobo.2096.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.2097.1">int</span></span><span class="koboSpan" id="kobo.2098.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2099.1">0</span></span><span class="koboSpan" id="kobo.2100.1">; i &lt; exponent; i++) {
              result *= base;
          }
      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2101.1">else</span></span><span class="koboSpan" id="kobo.2102.1"> {
          exponent = -exponent;
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2103.1">for</span></span><span class="koboSpan" id="kobo.2104.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.2105.1">int</span></span><span class="koboSpan" id="kobo.2106.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2107.1">0</span></span><span class="koboSpan" id="kobo.2108.1">; i &lt; exponent; i++) {
              result *= base;
          }
          result = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2109.1">1.0</span></span><span class="koboSpan" id="kobo.2110.1"> / result;
      }
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2111.1">return</span></span><span class="koboSpan" id="kobo.2112.1"> result;
   }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2113.1">else</span></span><span class="koboSpan" id="kobo.2114.1">
   {
       </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2115.1">return</span></span><span class="koboSpan" id="kobo.2116.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2117.1">pow</span></span><span class="koboSpan" id="kobo.2118.1">(base, exponent);
   }
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-595"><span class="koboSpan" id="kobo.2119.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2120.1">The C++20 standard </span><a id="_idIndexMarker1163"/><span class="koboSpan" id="kobo.2121.1">provides a library function (in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2122.1">&lt;type_traits&gt;</span></code><span class="koboSpan" id="kobo.2123.1"> header) called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2124.1">std::is_constant_evaluated()</span></code><span class="koboSpan" id="kobo.2125.1">, which detects whether its call occurs within a constant-evaluated context in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2126.1">constexpr</span></code><span class="koboSpan" id="kobo.2127.1"> function. </span><span class="koboSpan" id="kobo.2127.2">In this case, it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.2128.1">true</span></code><span class="koboSpan" id="kobo.2129.1">; otherwise, it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.2130.1">false</span></code><span class="koboSpan" id="kobo.2131.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2132.1">This function</span><a id="_idIndexMarker1164"/><span class="koboSpan" id="kobo.2133.1"> is used with a regular </span><code class="inlineCode"><span class="koboSpan" id="kobo.2134.1">if</span></code><span class="koboSpan" id="kobo.2135.1"> statement, as in the example provided in the previous section, where we computed the power of a number. </span><span class="koboSpan" id="kobo.2135.2">The key takeaways from this implementation are the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2136.1">In a constant-evaluated context, we used an algorithm that can be executed by the compiler at compile time, to optimize the code.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2137.1">In a non-constant evaluated context (i.e., at runtime) we invoke the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2138.1">std::pow()</span></code><span class="koboSpan" id="kobo.2139.1"> function to compute the power.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2140.1">However, there are some “gotchas” with this function and the constant-evaluated contexts that you must be aware of:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2141.1">Just because the arguments of a function are known at compile time, it does not mean that a context is constant-evaluated. </span><span class="koboSpan" id="kobo.2141.2">In the following snippet, the first invocation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2142.1">constexpr</span></code><span class="koboSpan" id="kobo.2143.1"> function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2144.1">power()</span></code><span class="koboSpan" id="kobo.2145.1"> is in a constant-evaluated context, but the second is not, even though all its arguments are known at compile time and the function is declared </span><code class="inlineCode"><span class="koboSpan" id="kobo.2146.1">constexpr</span></code><span class="koboSpan" id="kobo.2147.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2148.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2149.1">double</span></span><span class="koboSpan" id="kobo.2150.1"> a = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2151.1">power</span></span><span class="koboSpan" id="kobo.2152.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2153.1">10</span></span><span class="koboSpan" id="kobo.2154.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2155.1">5</span></span><span class="koboSpan" id="kobo.2156.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2157.1">// [1] compile-time eval</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.2158.1">double</span></span><span class="koboSpan" id="kobo.2159.1"> b = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2160.1">power</span></span><span class="koboSpan" id="kobo.2161.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2162.1">10</span></span><span class="koboSpan" id="kobo.2163.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2164.1">5</span></span><span class="koboSpan" id="kobo.2165.1">);           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2166.1">// [2] runtime eval</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2167.1">If used with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2168.1">constexpr</span></code><span class="koboSpan" id="kobo.2169.1"> if statement, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2170.1">std::is_constant_evaluated()</span></code><span class="koboSpan" id="kobo.2171.1"> function always evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2172.1">true</span></code><span class="koboSpan" id="kobo.2173.1"> (compilers such as GCC and Clang provide a warning for this subtle error):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2174.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2175.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2176.1">power</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2177.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2178.1">double</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2179.1"> base, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2180.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2181.1"> exponent)</span></span><span class="koboSpan" id="kobo.2182.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2183.1">if</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2184.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.2185.1">(std::is_constant_evaluated())</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2186.1">{
   }
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2187.1">Here is an example of the reported error: </span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2188.1">prog.cc: In function 'constexpr double power(double, int)':
prog.cc:10:45: warning: 'std::is_constant_evaluated' always evaluates to true in 'if constexpr' [-Wtautological-compare]
   10 |     if constexpr (std::is_constant_evaluated())
      |                   ~~~~~~~~~~~~~~~~~~~~~~~~~~^~
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2189.1">The C++23 standard provides a better alternative to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2190.1">std::is_constant_evaluated()</span></code><span class="koboSpan" id="kobo.2191.1"> function, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2192.1">consteval if</span></code><span class="koboSpan" id="kobo.2193.1"> statement. </span><span class="koboSpan" id="kobo.2193.2">This has several benefits:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2194.1">Does not require the inclusion of a header</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2195.1">Avoids confusion about the correct form of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2196.1">if</span></code><span class="koboSpan" id="kobo.2197.1"> statement to use</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2198.1">Allows the invocation of immediate functions in a constant-evaluated context</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2199.1">The </span><a id="_idIndexMarker1165"/><span class="koboSpan" id="kobo.2200.1">implementation</span><a id="_idIndexMarker1166"/><span class="koboSpan" id="kobo.2201.1"> of the power function changes to the following in C++23:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2202.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2203.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2204.1">power</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2205.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2206.1">double</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2207.1"> base, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2208.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2209.1"> exponent)</span></span><span class="koboSpan" id="kobo.2210.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2211.1">if</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2212.1">consteval</span></span><span class="koboSpan" id="kobo.2213.1">
   {
      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2214.1">/* ... </span><span class="koboSpan" id="kobo.2214.2">*/</span></span><span class="koboSpan" id="kobo.2215.1">
   }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2216.1">else</span></span><span class="koboSpan" id="kobo.2217.1">
   {
       </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2218.1">return</span></span><span class="koboSpan" id="kobo.2219.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2220.1">pow</span></span><span class="koboSpan" id="kobo.2221.1">(base, exponent);
   }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2222.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2223.1">consteval</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.2224.1">if</span></code><span class="koboSpan" id="kobo.2225.1"> statement always requires braces. </span><span class="koboSpan" id="kobo.2225.2">The negated form is also possible, either with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2226.1">!</span></code><span class="koboSpan" id="kobo.2227.1"> or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2228.1">not</span></code><span class="koboSpan" id="kobo.2229.1"> keyword. </span><span class="koboSpan" id="kobo.2229.2">In the following snippet, each of the two pairs of statements are equivalent:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2230.1">if</span></span><span class="koboSpan" id="kobo.2231.1"> !</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2232.1">consteval</span></span><span class="koboSpan" id="kobo.2233.1"> {</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2234.1">/*statement*/</span></span><span class="koboSpan" id="kobo.2235.1">}          </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2236.1">// [1] equivalent to [2]</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2237.1">if</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2238.1">consteval</span></span><span class="koboSpan" id="kobo.2239.1"> {} </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2240.1">else</span></span><span class="koboSpan" id="kobo.2241.1"> {</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2242.1">/*statement*/</span></span><span class="koboSpan" id="kobo.2243.1">}   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2244.1">// [2]</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2245.1">if</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2246.1">not</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2247.1">consteval</span></span><span class="koboSpan" id="kobo.2248.1"> {</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2249.1">/*statement1*/</span></span><span class="koboSpan" id="kobo.2250.1">}      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2251.1">// [3] equivalent to [4]</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2252.1">else</span></span><span class="koboSpan" id="kobo.2253.1"> {</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2254.1">/*statement2*/</span></span><span class="koboSpan" id="kobo.2255.1">}              
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2256.1">if</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2257.1">consteval</span></span><span class="koboSpan" id="kobo.2258.1"> {</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2259.1">/*statement2*/</span></span><span class="koboSpan" id="kobo.2260.1">}          </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2261.1">// [4]</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2262.1">else</span></span><span class="koboSpan" id="kobo.2263.1"> {</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2264.1">/*statement1*/</span></span><span class="koboSpan" id="kobo.2265.1">}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2266.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2267.1">consteval</span></code><span class="koboSpan" id="kobo.2268.1"> if statement is also important for allowing an immediate function to be invoked from</span><a id="_idIndexMarker1167"/><span class="koboSpan" id="kobo.2269.1"> a constant-evaluated context in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2270.1">constexpr</span></code><span class="koboSpan" id="kobo.2271.1"> function. </span><span class="koboSpan" id="kobo.2271.2">Let’s take the following C++20 example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2272.1">consteval</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2273.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2274.1">plus_one</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2275.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2276.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2277.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2278.1"> i)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2279.1">
{ 
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2280.1">return</span></span><span class="koboSpan" id="kobo.2281.1"> i + </span><span class="hljs-number"><span class="koboSpan" id="kobo.2282.1">1</span></span><span class="koboSpan" id="kobo.2283.1">; 
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2284.1">consteval</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2285.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2286.1">plus_two</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2287.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2288.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2289.1"> i)</span></span><span class="koboSpan" id="kobo.2290.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2291.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2292.1">plus_one</span></span><span class="koboSpan" id="kobo.2293.1">(i) + </span><span class="hljs-number"><span class="koboSpan" id="kobo.2294.1">1</span></span><span class="koboSpan" id="kobo.2295.1">;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2296.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2297.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2298.1">plus_two_alt</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2299.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2300.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2301.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2302.1"> i)</span></span><span class="koboSpan" id="kobo.2303.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2304.1">if</span></span><span class="koboSpan" id="kobo.2305.1"> (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2306.1">is_constant_evaluated</span></span><span class="koboSpan" id="kobo.2307.1">())
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2308.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2309.1">plus_one</span></span><span class="koboSpan" id="kobo.2310.1">(i) + </span><span class="hljs-number"><span class="koboSpan" id="kobo.2311.1">1</span></span><span class="koboSpan" id="kobo.2312.1">;
   } 
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2313.1">else</span></span><span class="koboSpan" id="kobo.2314.1">
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2315.1">return</span></span><span class="koboSpan" id="kobo.2316.1"> i + </span><span class="hljs-number"><span class="koboSpan" id="kobo.2317.1">2</span></span><span class="koboSpan" id="kobo.2318.1">;
   }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2319.1">Here, the </span><a id="_idIndexMarker1168"/><span class="koboSpan" id="kobo.2320.1">function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2321.1">plus_one()</span></code><span class="koboSpan" id="kobo.2322.1"> is an immediate function and can be invoked from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2323.1">plus_two()</span></code><span class="koboSpan" id="kobo.2324.1"> function, which is also an immediate function. </span><span class="koboSpan" id="kobo.2324.2">However, invoking it from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2325.1">plus_two_alt()</span></code><span class="koboSpan" id="kobo.2326.1"> function is not possible because it is not a constant expression, even though this is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2327.1">constexpr</span></code><span class="koboSpan" id="kobo.2328.1"> function and the context where the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2329.1">plus_one()</span></code><span class="koboSpan" id="kobo.2330.1"> function is invoked is constant-evaluated.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2331.1">This problem is solved by the C++23 </span><code class="inlineCode"><span class="koboSpan" id="kobo.2332.1">consteval if</span></code><span class="koboSpan" id="kobo.2333.1"> statement. </span><span class="koboSpan" id="kobo.2333.2">This makes it possible for immediate functions to be invoked from a constant-evaluated context, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2334.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2335.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2336.1">plus_two_alt</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2337.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2338.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2339.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2340.1"> i)</span></span><span class="koboSpan" id="kobo.2341.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2342.1">if</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2343.1">consteval</span></span><span class="koboSpan" id="kobo.2344.1">
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2345.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2346.1">plus_one</span></span><span class="koboSpan" id="kobo.2347.1">(i) + </span><span class="hljs-number"><span class="koboSpan" id="kobo.2348.1">1</span></span><span class="koboSpan" id="kobo.2349.1">;
   } 
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2350.1">else</span></span><span class="koboSpan" id="kobo.2351.1">
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2352.1">return</span></span><span class="koboSpan" id="kobo.2353.1"> i + </span><span class="hljs-number"><span class="koboSpan" id="kobo.2354.1">2</span></span><span class="koboSpan" id="kobo.2355.1">;
   }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2356.1">With the </span><a id="_idIndexMarker1169"/><span class="koboSpan" id="kobo.2357.1">availability of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2358.1">consteval if</span></code><span class="koboSpan" id="kobo.2359.1"> statement, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2360.1">std::is_constant_evaluated()</span></code><span class="koboSpan" id="kobo.2361.1"> function becomes obsolete. </span><span class="koboSpan" id="kobo.2361.2">In fact, it </span><a id="_idIndexMarker1170"/><span class="koboSpan" id="kobo.2362.1">can be implemented with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2363.1">consteval if</span></code><span class="koboSpan" id="kobo.2364.1"> statement as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2365.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2366.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2367.1">is_constant_evaluated</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2368.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2369.1">noexcept</span></span><span class="koboSpan" id="kobo.2370.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2371.1">if</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2372.1">consteval</span></span><span class="koboSpan" id="kobo.2373.1"> {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2374.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.2375.1">true</span></span><span class="koboSpan" id="kobo.2376.1">;
   } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2377.1">else</span></span><span class="koboSpan" id="kobo.2378.1"> {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2379.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.2380.1">false</span></span><span class="koboSpan" id="kobo.2381.1">;
   }
}
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2382.1">When using a C++23 compiler, you should always prefer the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2383.1">consteval if</span></code><span class="koboSpan" id="kobo.2384.1"> statement over the obsolete </span><code class="inlineCode"><span class="koboSpan" id="kobo.2385.1">std::is_constant_evaluated()</span></code><span class="koboSpan" id="kobo.2386.1"> function.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-596"><span class="koboSpan" id="kobo.2387.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2388.1">Creating compile-time constant expressions,</span></em><span class="koboSpan" id="kobo.2389.1"> to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2390.1">constexpr</span></code><span class="koboSpan" id="kobo.2391.1"> specifier and how to define variables and functions that can be evaluated at compile time</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2392.1">Creating immediate functions,</span></em><span class="koboSpan" id="kobo.2393.1"> to learn about the C++20 </span><code class="inlineCode"><span class="koboSpan" id="kobo.2394.1">consteval</span></code><span class="koboSpan" id="kobo.2395.1"> specifier, which is used to define functions that are guaranteed to be evaluated at compile time</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-597"><span class="koboSpan" id="kobo.2396.1">Using virtual function calls in constant expressions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2397.1">As a </span><a id="_idIndexMarker1171"/><span class="koboSpan" id="kobo.2398.1">multi-paradigm programming language, C++ includes support for object-oriented programming. </span><span class="koboSpan" id="kobo.2398.2">Polymorphism, one of the core principles of object-oriented programming, has two forms in C++: compile-time polymorphism, with function and operator overloading, and runtime-polymorphism, with virtual functions. </span><span class="koboSpan" id="kobo.2398.3">Virtual functions allow a derived class to override the implementation (of a function) in the base class. </span><span class="koboSpan" id="kobo.2398.4">In C++20, however, virtual functions</span><a id="_idIndexMarker1172"/><span class="koboSpan" id="kobo.2399.1"> are allowed in constant expressions, meaning they can be invoked at compile time. </span><span class="koboSpan" id="kobo.2399.2">In this recipe, you will learn how that works.</span></p>
<h2 class="heading-2" id="_idParaDest-598"><span class="koboSpan" id="kobo.2400.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2401.1">In this recipe, we will use the following structure to represent the dimension of a document and, respectively, an envelope, in the ensuing examples:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2402.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2403.1">dimension</span></span><span class="koboSpan" id="kobo.2404.1">
{
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2405.1">double</span></span><span class="koboSpan" id="kobo.2406.1"> width;
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2407.1">double</span></span><span class="koboSpan" id="kobo.2408.1"> height;
};
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-599"><span class="koboSpan" id="kobo.2409.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2410.1">You can move runtime polymorphism to the compile time by doing the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2411.1">Declare the virtual functions whose invocation you want to move to compile time as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2412.1">constexpr</span></code><span class="koboSpan" id="kobo.2413.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2414.1">Declare the destructor of the base class of the hierarchy as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2415.1">constexpr</span></code><span class="koboSpan" id="kobo.2416.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2417.1">Declare the overridden virtual function as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2418.1">constexpr</span></code><span class="koboSpan" id="kobo.2419.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2420.1">Invoke the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2421.1">constexpr</span></code><span class="koboSpan" id="kobo.2422.1"> virtual function in a constant expression.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2423.1">An example is shown in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2424.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2425.1">document_type</span></span><span class="koboSpan" id="kobo.2426.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2427.1">constexpr</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2428.1">virtual</span></span><span class="koboSpan" id="kobo.2429.1"> ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2430.1">document_type</span></span><span class="koboSpan" id="kobo.2431.1">() {};
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2432.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2433.1">virtual</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2434.1"> dimension </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2435.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2436.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2437.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2438.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2439.1">0</span></span><span class="koboSpan" id="kobo.2440.1">;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2441.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2442.1">document_a5</span></span><span class="koboSpan" id="kobo.2443.1"> : document_type
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2444.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2445.1"> dimension </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2446.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2447.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2448.1">const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2449.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2450.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2451.1">return</span></span><span class="koboSpan" id="kobo.2452.1"> { </span><span class="hljs-number"><span class="koboSpan" id="kobo.2453.1">148.5</span></span><span class="koboSpan" id="kobo.2454.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2455.1">210</span></span><span class="koboSpan" id="kobo.2456.1"> }; }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2457.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2458.1">envelope_type</span></span><span class="koboSpan" id="kobo.2459.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2460.1">constexpr</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2461.1">virtual</span></span><span class="koboSpan" id="kobo.2462.1"> ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2463.1">envelope_type</span></span><span class="koboSpan" id="kobo.2464.1">() {}
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2465.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2466.1">virtual</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2467.1"> dimension </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2468.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2469.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2470.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2471.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2472.1">0</span></span><span class="koboSpan" id="kobo.2473.1">;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2474.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2475.1">virtual</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2476.1"> dimension </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2477.1">max_enclosure_size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2478.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2479.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2480.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2481.1">0</span></span><span class="koboSpan" id="kobo.2482.1">;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2483.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2484.1">envelop_commercial_8</span></span><span class="koboSpan" id="kobo.2485.1"> : envelope_type
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2486.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2487.1"> dimension </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2488.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2489.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2490.1">const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2491.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2492.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2493.1">return</span></span><span class="koboSpan" id="kobo.2494.1"> { </span><span class="hljs-number"><span class="koboSpan" id="kobo.2495.1">219</span></span><span class="koboSpan" id="kobo.2496.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2497.1">92</span></span><span class="koboSpan" id="kobo.2498.1"> }; }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2499.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2500.1"> dimension </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2501.1">max_enclosure_size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2502.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2503.1">const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2504.1">override</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2505.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2506.1">return</span></span><span class="koboSpan" id="kobo.2507.1"> { </span><span class="hljs-number"><span class="koboSpan" id="kobo.2508.1">213</span></span><span class="koboSpan" id="kobo.2509.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2510.1">86</span></span><span class="koboSpan" id="kobo.2511.1"> }; }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2512.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2513.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2514.1">document_fits_envelope</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2515.1">(document_type </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2516.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2517.1">&amp; d, </span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.2518.1">                                      envelope_type </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2519.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2520.1">&amp; e)</span></span><span class="koboSpan" id="kobo.2521.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2522.1">return</span></span><span class="koboSpan" id="kobo.2523.1"> e.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2524.1">max_enclosure_size</span></span><span class="koboSpan" id="kobo.2525.1">().width &gt;= d.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2526.1">size</span></span><span class="koboSpan" id="kobo.2527.1">().width;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2528.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2529.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2530.1">()</span></span><span class="koboSpan" id="kobo.2531.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2532.1">constexpr</span></span><span class="koboSpan" id="kobo.2533.1"> envelop_commercial_8 e1;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2534.1">constexpr</span></span><span class="koboSpan" id="kobo.2535.1"> document_a5          d1;
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2536.1">static_assert</span></span><span class="koboSpan" id="kobo.2537.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2538.1">document_fits_envelope</span></span><span class="koboSpan" id="kobo.2539.1">(d1, e1));
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-600"><span class="koboSpan" id="kobo.2540.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2541.1">Prior to C++20, virtual functions </span><a id="_idIndexMarker1173"/><span class="koboSpan" id="kobo.2542.1">could </span><a id="_idIndexMarker1174"/><span class="koboSpan" id="kobo.2543.1">not be </span><code class="inlineCode"><span class="koboSpan" id="kobo.2544.1">constexpr</span></code><span class="koboSpan" id="kobo.2545.1">. </span><span class="koboSpan" id="kobo.2545.2">However, the dynamic type of an object used in a constant expression must be known at compile time. </span><span class="koboSpan" id="kobo.2545.3">As a result, the restriction of making virtual functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2546.1">constexpr</span></code><span class="koboSpan" id="kobo.2547.1"> has been lifted in C++20.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2548.1">The advantage of having </span><code class="inlineCode"><span class="koboSpan" id="kobo.2549.1">constexpr</span></code><span class="koboSpan" id="kobo.2550.1"> virtual functions is that some computations can be moved from runtime to compile time. </span><span class="koboSpan" id="kobo.2550.2">Although this will not impact many use cases in practice, an example was given in the previous section. </span><span class="koboSpan" id="kobo.2550.3">Let’s elaborate on it for a better understanding.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2551.1">We have a set of various paper sizes for documents. </span><span class="koboSpan" id="kobo.2551.2">Examples include </span><em class="italic"><span class="koboSpan" id="kobo.2552.1">A3</span></em><span class="koboSpan" id="kobo.2553.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2554.1">A4</span></em><span class="koboSpan" id="kobo.2555.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2556.1">A5</span></em><span class="koboSpan" id="kobo.2557.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2558.1">legal</span></em><span class="koboSpan" id="kobo.2559.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2560.1">letter</span></em><span class="koboSpan" id="kobo.2561.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.2562.1">half-letter</span></em><span class="koboSpan" id="kobo.2563.1">. </span><span class="koboSpan" id="kobo.2563.2">These have different sizes. </span><span class="koboSpan" id="kobo.2563.3">For instance, A5 is 148.5 mm x 210 mm, while letter is 215.9 mm x 279.4 mm. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2564.1">On the other hand, we have envelopes of different types and sizes. </span><span class="koboSpan" id="kobo.2564.2">For instance, we have an envelope that is 92 mm x 219 mm with a maximum enclosure size of 86 mm x 213 mm. </span><span class="koboSpan" id="kobo.2564.3">We want to write a function that determines whether a folded paper of a certain type can be placed inside an envelope. </span><span class="koboSpan" id="kobo.2564.4">Since the </span><a id="_idIndexMarker1175"/><span class="koboSpan" id="kobo.2565.1">sizes are standard, they are </span><a id="_idIndexMarker1176"/><span class="koboSpan" id="kobo.2566.1">known at compile time. </span><span class="koboSpan" id="kobo.2566.2">This means we can perform this check at compile time instead of runtime.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2567.1">For this purpose, in the </span><em class="italic"><span class="koboSpan" id="kobo.2568.1">How to do it…</span></em><span class="koboSpan" id="kobo.2569.1"> section, we have seen:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2570.1">A hierarchy of documents, with the base class called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2571.1">document_type</span></code><span class="koboSpan" id="kobo.2572.1">. </span><span class="koboSpan" id="kobo.2572.2">This has two members: a virtual destructor and a virtual function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2573.1">size()</span></code><span class="koboSpan" id="kobo.2574.1"> that returns the size of the paper. </span><span class="koboSpan" id="kobo.2574.2">Both of these functions are also </span><code class="inlineCode"><span class="koboSpan" id="kobo.2575.1">constexpr</span></code><span class="koboSpan" id="kobo.2576.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2577.1">A hierarchy of envelopes, with the base class called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2578.1">envelope_type</span></code><span class="koboSpan" id="kobo.2579.1">. </span><span class="koboSpan" id="kobo.2579.2">This has three members: a virtual destructor, a virtual function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2580.1">size()</span></code><span class="koboSpan" id="kobo.2581.1">, which returns the size of the envelope, and a virtual function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2582.1">max_enclosure_size()</span></code><span class="koboSpan" id="kobo.2583.1">, which returns the maximum size of a (folded) paper that can be placed in the envelope. </span><span class="koboSpan" id="kobo.2583.2">All these are </span><code class="inlineCode"><span class="koboSpan" id="kobo.2584.1">constexpr</span></code><span class="koboSpan" id="kobo.2585.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2586.1">A free function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2587.1">document_fits_envelope()</span></code><span class="koboSpan" id="kobo.2588.1"> determines whether a given document type fits a particular envelope type, by comparing the size of the width of the two. </span><span class="koboSpan" id="kobo.2588.2">This is also a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2589.1">constexpr</span></code><span class="koboSpan" id="kobo.2590.1"> function.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2591.1">Because all these functions mentioned are </span><code class="inlineCode"><span class="koboSpan" id="kobo.2592.1">constexpr</span></code><span class="koboSpan" id="kobo.2593.1">, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2594.1">document_fits_envelope()</span></code><span class="koboSpan" id="kobo.2595.1"> function can be invoked in a constant expression, such as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2596.1">static_assert</span></code><span class="koboSpan" id="kobo.2597.1">, given that the objects for which they are invoked are also </span><code class="inlineCode"><span class="koboSpan" id="kobo.2598.1">constexpr</span></code><span class="koboSpan" id="kobo.2599.1">. </span><span class="koboSpan" id="kobo.2599.2">In the code files that accompany the book you will find an elaborate example with various paper and envelope sizes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2600.1">You should keep in mind that:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2601.1">You can make an overridden virtual function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2602.1">constexpr</span></code><span class="koboSpan" id="kobo.2603.1">, even though the function it overrides in the base class is not defined as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2604.1">constexpr</span></code><span class="koboSpan" id="kobo.2605.1">. </span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2606.1">The opposite is also possible, the overridden virtual function in the derived class can be non-</span><code class="inlineCode"><span class="koboSpan" id="kobo.2607.1">constexpr</span></code><span class="koboSpan" id="kobo.2608.1">, although the function was defined as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2609.1">constexpr</span></code><span class="koboSpan" id="kobo.2610.1"> in the base class.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2611.1">If there</span><a id="_idIndexMarker1177"/><span class="koboSpan" id="kobo.2612.1"> is a hierarchy on multiple levels and a virtual function has some overrides defined as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2613.1">constexpr</span></code><span class="koboSpan" id="kobo.2614.1"> and some not, then the final overrider appropriate</span><a id="_idIndexMarker1178"/><span class="koboSpan" id="kobo.2615.1"> for the object on which the function is invoked is considered to determine whether the virtual function is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2616.1">constexpr</span></code><span class="koboSpan" id="kobo.2617.1"> or not.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-601"><span class="koboSpan" id="kobo.2618.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.2619.1">Chapter 1</span></em><span class="koboSpan" id="kobo.2620.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2621.1">Using override and final for virtual methods,</span></em><span class="koboSpan" id="kobo.2622.1"> to learn how to use the override and final specifiers on virtual methods and classes, respectively</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-602"><span class="koboSpan" id="kobo.2623.1">Performing correct type casts</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2624.1">It is often </span><a id="_idIndexMarker1179"/><span class="koboSpan" id="kobo.2625.1">the case that data has to be converted from one type into another type. </span><span class="koboSpan" id="kobo.2625.2">Some conversions are necessary at compile time (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2626.1">double</span></code><span class="koboSpan" id="kobo.2627.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2628.1">int</span></code><span class="koboSpan" id="kobo.2629.1">); others are necessary at runtime (such as upcasting and downcasting pointers to the classes in a hierarchy). </span><span class="koboSpan" id="kobo.2629.2">The language supports compatibility with the C casting style in either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2630.1">(type)expression</span></code><span class="koboSpan" id="kobo.2631.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2632.1">type(expression)</span></code><span class="koboSpan" id="kobo.2633.1"> form. </span><span class="koboSpan" id="kobo.2633.2">However, this type of casting breaks the type safety of C++.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2634.1">Therefore, the language also provides several conversions: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2635.1">static_cast</span></code><span class="koboSpan" id="kobo.2636.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2637.1">dynamic_cast</span></code><span class="koboSpan" id="kobo.2638.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2639.1">const_cast</span></code><span class="koboSpan" id="kobo.2640.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2641.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.2642.1">. </span><span class="koboSpan" id="kobo.2642.2">They are used to better indicate intent and write safer code. </span><span class="koboSpan" id="kobo.2642.3">In this recipe, we’ll look at how these casts can be used.</span></p>
<h2 class="heading-2" id="_idParaDest-603"><span class="koboSpan" id="kobo.2643.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2644.1">Use the following casts to perform type conversions:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2645.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2646.1">static_cast</span></code><span class="koboSpan" id="kobo.2647.1"> to perform type casting of non-polymorphic types, including the casting of integers to enumerations, from floating-point to integral values, or from a pointer type to another pointer type, such as from a base class to a derived class (downcasting) or from a derived class to a base class (upcasting), but without any runtime checks:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2648.1">enum</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2649.1">options</span></span><span class="koboSpan" id="kobo.2650.1"> {one = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2651.1">1</span></span><span class="koboSpan" id="kobo.2652.1">, two, three};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2653.1">int</span></span><span class="koboSpan" id="kobo.2654.1"> value = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2655.1">1</span></span><span class="koboSpan" id="kobo.2656.1">;
options op = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2657.1">static_cast</span></span><span class="koboSpan" id="kobo.2658.1">&lt;options&gt;(value);
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2659.1">int</span></span><span class="koboSpan" id="kobo.2660.1"> x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2661.1">42</span></span><span class="koboSpan" id="kobo.2662.1">, y = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2663.1">13</span></span><span class="koboSpan" id="kobo.2664.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2665.1">double</span></span><span class="koboSpan" id="kobo.2666.1"> d = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2667.1">static_cast</span></span><span class="koboSpan" id="kobo.2668.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2669.1">double</span></span><span class="koboSpan" id="kobo.2670.1">&gt;(x) / y;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2671.1">int</span></span><span class="koboSpan" id="kobo.2672.1"> n = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2673.1">static_cast</span></span><span class="koboSpan" id="kobo.2674.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2675.1">int</span></span><span class="koboSpan" id="kobo.2676.1">&gt;(d);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2677.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2678.1">dynamic_cast</span></code><span class="koboSpan" id="kobo.2679.1"> to </span><a id="_idIndexMarker1180"/><span class="koboSpan" id="kobo.2680.1">perform type casting of pointers or references of polymorphic types from a base class to a derived class or the other way around. </span><span class="koboSpan" id="kobo.2680.2">These checks are performed at runtime and may require </span><a id="_idIndexMarker1181"/><span class="koboSpan" id="kobo.2681.1">that </span><strong class="keyWord"><span class="koboSpan" id="kobo.2682.1">run-time type information</span></strong><span class="koboSpan" id="kobo.2683.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.2684.1">RTTI</span></strong><span class="koboSpan" id="kobo.2685.1">) is enabled:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2686.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2687.1">base</span></span><span class="koboSpan" id="kobo.2688.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2689.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2690.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2691.1">run</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2692.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2693.1">{}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2694.1">virtual</span></span><span class="koboSpan" id="kobo.2695.1"> ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2696.1">base</span></span><span class="koboSpan" id="kobo.2697.1">() {}
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2698.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2699.1">derived</span></span><span class="koboSpan" id="kobo.2700.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2701.1">public</span></span><span class="koboSpan" id="kobo.2702.1"> base
{
};
derived d;
base b;
base* pb = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2703.1">dynamic_cast</span></span><span class="koboSpan" id="kobo.2704.1">&lt;base*&gt;(&amp;d);         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2705.1">// OK</span></span><span class="koboSpan" id="kobo.2706.1">
derived* pd = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2707.1">dynamic_cast</span></span><span class="koboSpan" id="kobo.2708.1">&lt;derived*&gt;(&amp;b);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2709.1">// fail</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2710.1">try</span></span><span class="koboSpan" id="kobo.2711.1">
{
  base&amp; rb = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2712.1">dynamic_cast</span></span><span class="koboSpan" id="kobo.2713.1">&lt;base&amp;&gt;(d);       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2714.1">// OK</span></span><span class="koboSpan" id="kobo.2715.1">
  derived&amp; rd = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2716.1">dynamic_cast</span></span><span class="koboSpan" id="kobo.2717.1">&lt;derived&amp;&gt;(b); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2718.1">// fail</span></span><span class="koboSpan" id="kobo.2719.1">
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2720.1">catch</span></span><span class="koboSpan" id="kobo.2721.1"> (std::bad_cast </span><span class="hljs-type"><span class="koboSpan" id="kobo.2722.1">const</span></span><span class="koboSpan" id="kobo.2723.1"> &amp; e)
{
  std::cout &lt;&lt; e.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2724.1">what</span></span><span class="koboSpan" id="kobo.2725.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2726.1">'\n'</span></span><span class="koboSpan" id="kobo.2727.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2728.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2729.1">const_cast</span></code><span class="koboSpan" id="kobo.2730.1"> to perform conversion between types with different </span><code class="inlineCode"><span class="koboSpan" id="kobo.2731.1">const</span></code><span class="koboSpan" id="kobo.2732.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2733.1">volatile</span></code><span class="koboSpan" id="kobo.2734.1"> specifiers, such as removing </span><code class="inlineCode"><span class="koboSpan" id="kobo.2735.1">const</span></code><span class="koboSpan" id="kobo.2736.1"> from an object that was not declared as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2737.1">const</span></code><span class="koboSpan" id="kobo.2738.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2739.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2740.1">old_api</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2741.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2742.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2743.1">* str, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2744.1">unsigned</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2745.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2746.1"> size)</span></span><span class="koboSpan" id="kobo.2747.1">
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2748.1">// do something without changing the string</span></span><span class="koboSpan" id="kobo.2749.1">
}
std::string str{</span><span class="hljs-string"><span class="koboSpan" id="kobo.2750.1">"sample"</span></span><span class="koboSpan" id="kobo.2751.1">};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2752.1">old_api</span></span><span class="koboSpan" id="kobo.2753.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2754.1">const_cast</span></span><span class="koboSpan" id="kobo.2755.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2756.1">char</span></span><span class="koboSpan" id="kobo.2757.1">*&gt;(str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2758.1">c_str</span></span><span class="koboSpan" id="kobo.2759.1">()),
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2760.1">static_cast</span></span><span class="koboSpan" id="kobo.2761.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2762.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2763.1">int</span></span><span class="koboSpan" id="kobo.2764.1">&gt;(str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2765.1">size</span></span><span class="koboSpan" id="kobo.2766.1">()));
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2767.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2768.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.2769.1"> to perform bit reinterpretation, such as conversion between</span><a id="_idIndexMarker1182"/><span class="koboSpan" id="kobo.2770.1"> integers and pointer types, from pointer types to integers, or from a pointer type to any other pointer type, without involving any runtime checks:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2771.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2772.1">widget</span></span><span class="koboSpan" id="kobo.2773.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2774.1">public</span></span><span class="koboSpan" id="kobo.2775.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2776.1">typedef</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2777.1">size_t</span></span><span class="koboSpan" id="kobo.2778.1"> data_type;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2779.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2780.1">set_data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2781.1">(data_type d)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2782.1">{ data = d; }
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.2783.1">data_type </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2784.1">get_data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2785.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2786.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2787.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2788.1">return</span></span><span class="koboSpan" id="kobo.2789.1"> data; }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2790.1">private</span></span><span class="koboSpan" id="kobo.2791.1">:
  data_type data;
};
widget w;
user_data* ud = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2792.1">new</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2793.1">user_data</span></span><span class="koboSpan" id="kobo.2794.1">();
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2795.1">// write</span></span><span class="koboSpan" id="kobo.2796.1">
w.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2797.1">set_data</span></span><span class="koboSpan" id="kobo.2798.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2799.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.2800.1">&lt;widget::data_type&gt;(ud));
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2801.1">// read</span></span><span class="koboSpan" id="kobo.2802.1">
user_data* ud2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2803.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.2804.1">&lt;user_data*&gt;(w.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2805.1">get_data</span></span><span class="koboSpan" id="kobo.2806.1">());
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-604"><span class="koboSpan" id="kobo.2807.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2808.1">The explicit type conversion, sometimes referred to</span><a id="_idIndexMarker1183"/><span class="koboSpan" id="kobo.2809.1"> as </span><em class="italic"><span class="koboSpan" id="kobo.2810.1">C-style casting</span></em><span class="koboSpan" id="kobo.2811.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.2812.1">static casting</span></em><span class="koboSpan" id="kobo.2813.1">, is a</span><a id="_idIndexMarker1184"/><span class="koboSpan" id="kobo.2814.1"> legacy of the compatibility of C++ with the C language and enables you to perform various conversions including the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2815.1">Between arithmetical types</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2816.1">Between pointer types</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2817.1">Between integral and pointer types</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2818.1">Between const or volatile qualified and unqualified types</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2819.1">This </span><a id="_idIndexMarker1185"/><span class="koboSpan" id="kobo.2820.1">type of casting does not work well with polymorphic types or in templates. </span><span class="koboSpan" id="kobo.2820.2">Because of this, C++ provides the four casts we saw in the examples earlier. </span><span class="koboSpan" id="kobo.2820.3">Using these casts leads to several important benefits:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2821.1">They express user intent better, both to the compiler and others that read the code.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2822.1">They enable safer conversion between various types (except for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2823.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.2824.1">).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2825.1">They can be easily searched in the source code.</span></li>
</ul>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2826.1">static_cast</span></code><span class="koboSpan" id="kobo.2827.1"> is </span><a id="_idIndexMarker1186"/><span class="koboSpan" id="kobo.2828.1">not a direct equivalent of explicit type conversion, or static casting, even though the name might suggest that. </span><span class="koboSpan" id="kobo.2828.2">This cast is performed at compile time and can be used to perform implicit conversions, the reverse of implicit conversions, and conversion from pointers to types from a hierarchy of classes. </span><span class="koboSpan" id="kobo.2828.3">It cannot be used to trigger a conversion between unrelated pointer types, though. </span><span class="koboSpan" id="kobo.2828.4">For this reason, in the following example, converting from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2829.1">int*</span></code><span class="koboSpan" id="kobo.2830.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2831.1">double*</span></code><span class="koboSpan" id="kobo.2832.1"> using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2833.1">static_cast</span></code><span class="koboSpan" id="kobo.2834.1"> produces a compiler error:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2835.1">int</span></span><span class="koboSpan" id="kobo.2836.1">* pi = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2837.1">new</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2838.1">int</span></span><span class="koboSpan" id="kobo.2839.1">{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2840.1">42</span></span><span class="koboSpan" id="kobo.2841.1"> };
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2842.1">double</span></span><span class="koboSpan" id="kobo.2843.1">* pd = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2844.1">static_cast</span></span><span class="koboSpan" id="kobo.2845.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2846.1">double</span></span><span class="koboSpan" id="kobo.2847.1">*&gt;(pi);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2848.1">// compiler error</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2849.1">However, converting from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2850.1">base*</span></code><span class="koboSpan" id="kobo.2851.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2852.1">derived*</span></code><span class="koboSpan" id="kobo.2853.1"> (where </span><code class="inlineCode"><span class="koboSpan" id="kobo.2854.1">base</span></code><span class="koboSpan" id="kobo.2855.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2856.1">derived</span></code><span class="koboSpan" id="kobo.2857.1"> are the classes shown in the </span><em class="italic"><span class="koboSpan" id="kobo.2858.1">How to do it...</span></em><span class="koboSpan" id="kobo.2859.1"> section) does not produce a compiler error but a runtime error when trying to use the newly obtained pointer:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2860.1">base b;
derived* pd = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2861.1">static_cast</span></span><span class="koboSpan" id="kobo.2862.1">&lt;derived*&gt;(&amp;b); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2863.1">// compilers OK, runtime error</span></span><span class="koboSpan" id="kobo.2864.1">
base* pb1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2865.1">static_cast</span></span><span class="koboSpan" id="kobo.2866.1">&lt;base*&gt;(pd);      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2867.1">// OK</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2868.1">On the other hand, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2869.1">static_cast</span></code><span class="koboSpan" id="kobo.2870.1"> cannot be used to remove </span><code class="inlineCode"><span class="koboSpan" id="kobo.2871.1">const</span></code><span class="koboSpan" id="kobo.2872.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2873.1">volatile</span></code><span class="koboSpan" id="kobo.2874.1"> qualifiers. </span><span class="koboSpan" id="kobo.2874.2">The following snippet exemplifies this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2875.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2876.1">const</span></span><span class="koboSpan" id="kobo.2877.1"> c = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2878.1">42</span></span><span class="koboSpan" id="kobo.2879.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2880.1">int</span></span><span class="koboSpan" id="kobo.2881.1">* pc = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2882.1">static_cast</span></span><span class="koboSpan" id="kobo.2883.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2884.1">int</span></span><span class="koboSpan" id="kobo.2885.1">*&gt;(&amp;c);         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2886.1">// compiler error</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2887.1">Safely typecasting expressions up, down, or sideways along an inheritance hierarchy can be performed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2888.1">dynamic_cast</span></code><span class="koboSpan" id="kobo.2889.1">. </span><span class="koboSpan" id="kobo.2889.2">This cast is performed at runtime and requires that RTTI is enabled. </span><span class="koboSpan" id="kobo.2889.3">Because of this, it incurs a runtime overhead. </span><span class="koboSpan" id="kobo.2889.4">Dynamic casting can only be used for pointers and references. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2890.1">When </span><code class="inlineCode"><span class="koboSpan" id="kobo.2891.1">dynamic_cast</span></code><span class="koboSpan" id="kobo.2892.1"> is used to convert an expression</span><a id="_idIndexMarker1187"/><span class="koboSpan" id="kobo.2893.1"> into a pointer type and the operation fails, the result is a null pointer. </span><span class="koboSpan" id="kobo.2893.2">When it is used to convert an expression into a reference type and the operation fails, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2894.1">std::bad_cast</span></code><span class="koboSpan" id="kobo.2895.1"> exception is thrown. </span><span class="koboSpan" id="kobo.2895.2">Therefore, always put a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2896.1">dynamic_cast</span></code><span class="koboSpan" id="kobo.2897.1"> conversion to a reference type within a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2898.1">try...catch</span></code><span class="koboSpan" id="kobo.2899.1"> block.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2900.1">RTTI is a mechanism that exposes information about object data types at runtime. </span><span class="koboSpan" id="kobo.2900.2">This is available only for polymorphic types (types that have at least one virtual method, including a virtual destructor, which all base classes should have). </span><span class="koboSpan" id="kobo.2900.3">RTTI is usually an optional compiler feature (or might not be supported at all), which means using this functionality may require using a compiler switch.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2901.1">Though dynamic casting is performed at runtime, if you attempt to convert it between non-polymorphic types, you’ll get a compiler error:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2902.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2903.1">struct1</span></span><span class="koboSpan" id="kobo.2904.1"> {};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2905.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2906.1">struct2</span></span><span class="koboSpan" id="kobo.2907.1"> {};
struct1 s1;
struct2* ps2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2908.1">dynamic_cast</span></span><span class="koboSpan" id="kobo.2909.1">&lt;struct2*&gt;(&amp;s1); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2910.1">// compiler error</span></span>
</code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2911.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.2912.1"> is more </span><a id="_idIndexMarker1188"/><span class="koboSpan" id="kobo.2913.1">like a compiler directive. </span><span class="koboSpan" id="kobo.2913.2">It does not translate into any CPU instructions; it only instructs the compiler to interpret the binary representation of an expression as it was of another, specified type. </span><span class="koboSpan" id="kobo.2913.3">This is a type-unsafe conversion and should be used with care. </span><span class="koboSpan" id="kobo.2913.4">It can be used to convert expressions between integral types and pointers, pointer types, and function pointer types. </span><span class="koboSpan" id="kobo.2913.5">Because no checks are done, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2914.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.2915.1"> can be successfully used to convert expressions between unrelated types, such as from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2916.1">int*</span></code><span class="koboSpan" id="kobo.2917.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2918.1">double*</span></code><span class="koboSpan" id="kobo.2919.1">, which produces undefined behavior:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2920.1">int</span></span><span class="koboSpan" id="kobo.2921.1">* pi = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2922.1">new</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2923.1">int</span></span><span class="koboSpan" id="kobo.2924.1">{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2925.1">42</span></span><span class="koboSpan" id="kobo.2926.1"> };
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2927.1">double</span></span><span class="koboSpan" id="kobo.2928.1">* pd = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2929.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.2930.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2931.1">double</span></span><span class="koboSpan" id="kobo.2932.1">*&gt;(pi);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2933.1">A typical use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2934.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.2935.1"> is to convert expressions between types in code that uses operating system or vendor-specific APIs. </span><span class="koboSpan" id="kobo.2935.2">Many APIs store user data in the form of a pointer or an integral type. </span><span class="koboSpan" id="kobo.2935.3">Therefore, if you need to pass the address of a user-defined type to such APIs, you need to convert values of unrelated pointer types or a pointer type value into an integral type value. </span><span class="koboSpan" id="kobo.2935.4">A similar example was provided in the previous section, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.2936.1">widget</span></code><span class="koboSpan" id="kobo.2937.1"> was a class that stored user-defined data in a data member and provided methods for accessing it: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2938.1">set_data()</span></code><span class="koboSpan" id="kobo.2939.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2940.1">get_data()</span></code><span class="koboSpan" id="kobo.2941.1">. </span><span class="koboSpan" id="kobo.2941.2">If you need to store a</span><a id="_idIndexMarker1189"/><span class="koboSpan" id="kobo.2942.1"> pointer to an object in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2943.1">widget</span></code><span class="koboSpan" id="kobo.2944.1">, then use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2945.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.2946.1">, as shown in this example.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2947.1">const_cast</span></code><span class="koboSpan" id="kobo.2948.1"> is similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2949.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.2950.1"> in the sense that it is a compiler directive and does not translate into CPU instructions. </span><span class="koboSpan" id="kobo.2950.2">It is used to cast away </span><code class="inlineCode"><span class="koboSpan" id="kobo.2951.1">const</span></code><span class="koboSpan" id="kobo.2952.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2953.1">volatile</span></code><span class="koboSpan" id="kobo.2954.1"> qualifiers, an operation that none of the other three conversions discussed here can do.</span></p>
<div class="packt_tip">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2955.1">const_cast</span></code><span class="koboSpan" id="kobo.2956.1"> should only be used to remove </span><code class="inlineCode"><span class="koboSpan" id="kobo.2957.1">const</span></code><span class="koboSpan" id="kobo.2958.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2959.1">volatile</span></code><span class="koboSpan" id="kobo.2960.1"> qualifiers when the object is not declared </span><code class="inlineCode"><span class="koboSpan" id="kobo.2961.1">const</span></code><span class="koboSpan" id="kobo.2962.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2963.1">volatile</span></code><span class="koboSpan" id="kobo.2964.1">. </span><span class="koboSpan" id="kobo.2964.2">Anything else incurs undefined behavior, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2965.1">int</span></span> <span class="hljs-variable"><span class="koboSpan" id="kobo.2966.1">const</span></span><span class="koboSpan" id="kobo.2967.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2968.1">42</span></span><span class="koboSpan" id="kobo.2969.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2970.1">int</span></span> <span class="hljs-variable"><span class="koboSpan" id="kobo.2971.1">const</span></span><span class="koboSpan" id="kobo.2972.1"> * p = &amp;a;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2973.1">int</span></span><span class="koboSpan" id="kobo.2974.1">* q = const_cast&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2975.1">int</span></span><span class="koboSpan" id="kobo.2976.1">*&gt;(p);
*q = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2977.1">0</span></span><span class="koboSpan" id="kobo.2978.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2979.1">// undefined behavior</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2980.1">In this example, the variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.2981.1">p</span></code><span class="koboSpan" id="kobo.2982.1"> points to an object (the variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.2983.1">a</span></code><span class="koboSpan" id="kobo.2984.1">) that was declared constant. </span><span class="koboSpan" id="kobo.2984.2">By re­moving the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2985.1">const</span></code><span class="koboSpan" id="kobo.2986.1"> qualifier, the attempt to modify the pointed object introduces undefined behavior.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-605"><span class="koboSpan" id="kobo.2987.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2988.1">When using explicit type conversion in the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.2989.1">(type)expression</span></code><span class="koboSpan" id="kobo.2990.1">, be aware that it will select the first choice from the following list that satisfies specific cast requirements:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><code class="inlineCode"><span class="koboSpan" id="kobo.2991.1">const_cast&lt;type&gt;(expression)</span></code></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.2992.1">static_cast&lt;type&gt;(expression)</span></code></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.2993.1">static_cast&lt;type&gt;(expression) + const_cast&lt;type&gt;(expression)</span></code></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.2994.1">reinterpret_cast&lt;type&gt;(expression)</span></code></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.2995.1">reinterpret_cast&lt;type&gt;(expression) + const_cast&lt;type&gt;(expression)</span></code></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.2996.1">Moreover, unlike the specific C++ casts, static cast can be used to convert between incomplete class types. </span><span class="koboSpan" id="kobo.2996.2">If both </span><code class="inlineCode"><span class="koboSpan" id="kobo.2997.1">type</span></code><span class="koboSpan" id="kobo.2998.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2999.1">expression</span></code><span class="koboSpan" id="kobo.3000.1"> are pointers to incomplete types, then it is not specified whether </span><code class="inlineCode"><span class="koboSpan" id="kobo.3001.1">static_cast</span></code><span class="koboSpan" id="kobo.3002.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3003.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.3004.1"> is selected.</span></p>
<h2 class="heading-2" id="_idParaDest-606"><span class="koboSpan" id="kobo.3005.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3006.1">Ensuring constant correctness for a program</span></em><span class="koboSpan" id="kobo.3007.1">, to explore the benefits of constant correctness and how to achieve it</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-607"><span class="koboSpan" id="kobo.3008.1">Implementing move semantics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3009.1">Move semantics </span><a id="_idIndexMarker1190"/><span class="koboSpan" id="kobo.3010.1">is a key feature that drives the performance improvements of modern C++. </span><span class="koboSpan" id="kobo.3010.2">They enable moving, rather than copying, resources, or, in general, objects that are expensive to copy. </span><span class="koboSpan" id="kobo.3010.3">However, it requires that classes implement a move constructor and move assignment operator. </span><span class="koboSpan" id="kobo.3010.4">These are provided by the compiler in some circumstances, but in practice, it is often the case that you have to explicitly write them. </span><span class="koboSpan" id="kobo.3010.5">In this recipe, we will see how to implement the move constructor and the move assignment operator.</span></p>
<h2 class="heading-2" id="_idParaDest-608"><span class="koboSpan" id="kobo.3011.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3012.1">You are </span><a id="_idIndexMarker1191"/><span class="koboSpan" id="kobo.3013.1">expected to have basic knowledge of rvalue references and the special class functions (constructors, assignment operators, and destructors). </span><span class="koboSpan" id="kobo.3013.2">We will demonstrate how to implement a move constructor and assignment operator using the following </span><code class="inlineCode"><span class="koboSpan" id="kobo.3014.1">Buffer</span></code><span class="koboSpan" id="kobo.3015.1"> class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3016.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3017.1">Buffer</span></span><span class="koboSpan" id="kobo.3018.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3019.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3020.1">char</span></span><span class="koboSpan" id="kobo.3021.1">* ptr;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3022.1">size_t</span></span><span class="koboSpan" id="kobo.3023.1"> length;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3024.1">public</span></span><span class="koboSpan" id="kobo.3025.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3026.1">Buffer</span></span><span class="koboSpan" id="kobo.3027.1">(): </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3028.1">ptr</span></span><span class="koboSpan" id="kobo.3029.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.3030.1">nullptr</span></span><span class="koboSpan" id="kobo.3031.1">), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3032.1">length</span></span><span class="koboSpan" id="kobo.3033.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3034.1">0</span></span><span class="koboSpan" id="kobo.3035.1">)
  {}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3036.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3037.1">Buffer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3038.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3039.1">size_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3040.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3041.1"> size)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3042.1">:</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.3043.1">    ptr(new unsigned char[size] {</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3044.1">0</span></span><span class="koboSpan" id="kobo.3045.1">}), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3046.1">length</span></span><span class="koboSpan" id="kobo.3047.1">(size)
  {}
  ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3048.1">Buffer</span></span><span class="koboSpan" id="kobo.3049.1">()
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3050.1">delete</span></span><span class="koboSpan" id="kobo.3051.1">[] ptr;
  }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3052.1">Buffer</span></span><span class="koboSpan" id="kobo.3053.1">(Buffer </span><span class="hljs-type"><span class="koboSpan" id="kobo.3054.1">const</span></span><span class="koboSpan" id="kobo.3055.1">&amp; other):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3056.1">ptr</span></span><span class="koboSpan" id="kobo.3057.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3058.1">new</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3059.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3060.1">char</span></span><span class="koboSpan" id="kobo.3061.1">[other.length]),
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3062.1">length</span></span><span class="koboSpan" id="kobo.3063.1">(other.length)
  {
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3064.1">copy</span></span><span class="koboSpan" id="kobo.3065.1">(other.ptr, other.ptr + other.length, ptr);
  }
  Buffer&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3066.1">operator</span></span><span class="koboSpan" id="kobo.3067.1">=(Buffer </span><span class="hljs-type"><span class="koboSpan" id="kobo.3068.1">const</span></span><span class="koboSpan" id="kobo.3069.1">&amp; other)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3070.1">if</span></span><span class="koboSpan" id="kobo.3071.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3072.1">this</span></span><span class="koboSpan" id="kobo.3073.1"> != &amp;other)
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3074.1">delete</span></span><span class="koboSpan" id="kobo.3075.1">[] ptr;
      ptr = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3076.1">new</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3077.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3078.1">char</span></span><span class="koboSpan" id="kobo.3079.1">[other.length];
      length = other.length;
      std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3080.1">copy</span></span><span class="koboSpan" id="kobo.3081.1">(other.ptr, other.ptr + other.length, ptr);
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3082.1">return</span></span><span class="koboSpan" id="kobo.3083.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3084.1">this</span></span><span class="koboSpan" id="kobo.3085.1">;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3086.1">size_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3087.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3088.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3089.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3090.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3091.1">return</span></span><span class="koboSpan" id="kobo.3092.1"> length;}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3093.1">unsigned</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3094.1">char</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3095.1">* </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3096.1">data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3097.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3098.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3099.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3100.1">return</span></span><span class="koboSpan" id="kobo.3101.1"> ptr; }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3102.1">Let’s move </span><a id="_idIndexMarker1192"/><span class="koboSpan" id="kobo.3103.1">on to the next section, where you’ll learn how to modify this class in order to benefit from move semantics.</span></p>
<h2 class="heading-2" id="_idParaDest-609"><span class="koboSpan" id="kobo.3104.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3105.1">To implement the move constructor for a class, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.3106.1">Write a constructor that takes an rvalue reference to the class type:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.3107.1">Buffer</span></span><span class="koboSpan" id="kobo.3108.1">(Buffer&amp;&amp; other)
{
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3109.1">Assign all the data members from the rvalue reference to the current object. </span><span class="koboSpan" id="kobo.3109.2">This can be done either in the body of the constructor, as follows, or in the initialization list, which is the preferred way:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3110.1">ptr = other.ptr;
length = other.length;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3111.1">Optionally, assign the data members from the rvalue reference to default values (to ensure the object that was moved is in a destructible state):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3112.1">other.ptr = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3113.1">nullptr</span></span><span class="koboSpan" id="kobo.3114.1">;
other.length = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3115.1">0</span></span><span class="koboSpan" id="kobo.3116.1">;
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.3117.1">Put all </span><a id="_idIndexMarker1193"/><span class="koboSpan" id="kobo.3118.1">together, the move constructor for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3119.1">Buffer</span></code><span class="koboSpan" id="kobo.3120.1"> class looks like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.3121.1">Buffer</span></span><span class="koboSpan" id="kobo.3122.1">(Buffer&amp;&amp; other)
{
  ptr = other.ptr;
  length = other.length;
  other.ptr = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3123.1">nullptr</span></span><span class="koboSpan" id="kobo.3124.1">;
  other.length = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3125.1">0</span></span><span class="koboSpan" id="kobo.3126.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3127.1">To implement the move assignment operator for a class, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.3128.1">Write an assignment operator that takes an rvalue reference to the class type and returns a reference to it:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3129.1">Buffer&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3130.1">operator</span></span><span class="koboSpan" id="kobo.3131.1">=(Buffer&amp;&amp; other)
{
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3132.1">Check that the rvalue reference does not refer to the same object as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3133.1">this</span></code><span class="koboSpan" id="kobo.3134.1">, and if they are different, perform </span><em class="italic"><span class="koboSpan" id="kobo.3135.1">steps 3</span></em><span class="koboSpan" id="kobo.3136.1"> to </span><em class="italic"><span class="koboSpan" id="kobo.3137.1">5</span></em><span class="koboSpan" id="kobo.3138.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3139.1">if</span></span><span class="koboSpan" id="kobo.3140.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3141.1">this</span></span><span class="koboSpan" id="kobo.3142.1"> != &amp;other)
{
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3143.1">Dispose of all the resources (such as memory, handles, and so on) from the current object:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3144.1">delete</span></span><span class="koboSpan" id="kobo.3145.1">[] ptr;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3146.1">Assign all the data members from the rvalue reference to the current object:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3147.1">ptr = other.ptr;
length = other.length;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3148.1">Assign the data members from the rvalue reference to the default values:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3149.1">other.ptr = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3150.1">nullptr</span></span><span class="koboSpan" id="kobo.3151.1">;
other.length = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3152.1">0</span></span><span class="koboSpan" id="kobo.3153.1">;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3154.1">Return a reference to the current object, regardless of whether </span><em class="italic"><span class="koboSpan" id="kobo.3155.1">steps 3</span></em><span class="koboSpan" id="kobo.3156.1"> to </span><em class="italic"><span class="koboSpan" id="kobo.3157.1">5</span></em><span class="koboSpan" id="kobo.3158.1"> were executed or not:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3159.1">return</span></span><span class="koboSpan" id="kobo.3160.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3161.1">this</span></span><span class="koboSpan" id="kobo.3162.1">;
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.3163.1">Put all together, the </span><a id="_idIndexMarker1194"/><span class="koboSpan" id="kobo.3164.1">move assignment operator for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3165.1">Buffer</span></code><span class="koboSpan" id="kobo.3166.1"> class looks like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3167.1">Buffer&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3168.1">operator</span></span><span class="koboSpan" id="kobo.3169.1">=(Buffer&amp;&amp; other)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3170.1">if</span></span><span class="koboSpan" id="kobo.3171.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3172.1">this</span></span><span class="koboSpan" id="kobo.3173.1"> != &amp;other)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3174.1">delete</span></span><span class="koboSpan" id="kobo.3175.1">[] ptr;
    ptr = other.ptr;
    length = other.length;
    other.ptr = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3176.1">nullptr</span></span><span class="koboSpan" id="kobo.3177.1">;
    other.length = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3178.1">0</span></span><span class="koboSpan" id="kobo.3179.1">;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3180.1">return</span></span><span class="koboSpan" id="kobo.3181.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3182.1">this</span></span><span class="koboSpan" id="kobo.3183.1">;
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-610"><span class="koboSpan" id="kobo.3184.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3185.1">The move constructor and move assignment operator are provided by default by the compiler unless a user-defined copy constructor, move constructor, copy assignment operator, move assignment operator, or destructor exists already. </span><span class="koboSpan" id="kobo.3185.2">When provided by the compiler, they perform a movement in a member-wise manner. </span><span class="koboSpan" id="kobo.3185.3">The move constructor invokes the move constructors of the class data members recursively; similarly, the move assignment operator invokes the move assignment operators of the class data members recursively.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3186.1">Move, in this case, represents a performance benefit for objects that are too large to copy (such as a string or container) or for objects that are not supposed to be copied (such as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3187.1">unique_ptr</span></code><span class="koboSpan" id="kobo.3188.1"> smart pointer). </span><span class="koboSpan" id="kobo.3188.2">Not all classes are supposed to implement both copy and move semantics. </span><span class="koboSpan" id="kobo.3188.3">Some classes should only be movable, while others should be both copyable and movable. </span><span class="koboSpan" id="kobo.3188.4">On the other hand, it does not make much sense for a class to be copyable but not moveable, though this can be technically achieved.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3189.1">Not all </span><a id="_idIndexMarker1195"/><span class="koboSpan" id="kobo.3190.1">types benefit from move semantics. </span><span class="koboSpan" id="kobo.3190.2">In the case of built-in types (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3191.1">bool</span></code><span class="koboSpan" id="kobo.3192.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3193.1">int</span></code><span class="koboSpan" id="kobo.3194.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3195.1">double</span></code><span class="koboSpan" id="kobo.3196.1">), arrays, or PODs, the move is actually a copy operation. </span><span class="koboSpan" id="kobo.3196.2">On the other hand, move semantics provide a performance benefit in the context of rvalues, that is, temporary objects. </span><span class="koboSpan" id="kobo.3196.3">An rvalue is an object that does not have a name; it lives temporarily during the evaluation of an expression and is destroyed at the next semicolon:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3197.1">T a;
T b = a;
T c = a + b;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3198.1">In the preceding example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3199.1">a</span></code><span class="koboSpan" id="kobo.3200.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3201.1">b</span></code><span class="koboSpan" id="kobo.3202.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3203.1">c</span></code><span class="koboSpan" id="kobo.3204.1"> are lvalues; they are objects that have a name that can be used to refer to the object at any point throughout its lifetime. </span><span class="koboSpan" id="kobo.3204.2">On the other hand, when you evaluate the expression </span><code class="inlineCode"><span class="koboSpan" id="kobo.3205.1">a+b</span></code><span class="koboSpan" id="kobo.3206.1">, the compiler creates a temporary object (which, in this case, is assigned to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3207.1">c</span></code><span class="koboSpan" id="kobo.3208.1">), which is then destroyed when a semicolon is encountered. </span><span class="koboSpan" id="kobo.3208.2">These temporary objects are called rvalues because they usually appear on the right-hand side of an assignment expression. </span><span class="koboSpan" id="kobo.3208.3">In C++11, we can refer to these objects through rvalue references, expressed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3209.1">&amp;&amp;</span></code><span class="koboSpan" id="kobo.3210.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3211.1">Move semantics are important in the context of rvalues. </span><span class="koboSpan" id="kobo.3211.2">This is because they allow you to take ownership of the resources from the temporary object that is destroyed, without the client being able to use it after the move operation is completed. </span><span class="koboSpan" id="kobo.3211.3">On the other hand, lvalues cannot be moved; they can only be copied. </span><span class="koboSpan" id="kobo.3211.4">This is because they can be accessed after the move operation, and the client expects the object to be in the same state. </span><span class="koboSpan" id="kobo.3211.5">For instance, in the preceding example, the expression </span><code class="inlineCode"><span class="koboSpan" id="kobo.3212.1">b = a</span></code><span class="koboSpan" id="kobo.3213.1"> assigns </span><code class="inlineCode"><span class="koboSpan" id="kobo.3214.1">a</span></code><span class="koboSpan" id="kobo.3215.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3216.1">b</span></code><span class="koboSpan" id="kobo.3217.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3218.1">After this operation is complete, the object </span><code class="inlineCode"><span class="koboSpan" id="kobo.3219.1">a</span></code><span class="koboSpan" id="kobo.3220.1">, which is an lvalue, can still be used by the client and should be in the same state as it was before. </span><span class="koboSpan" id="kobo.3220.2">On the other hand, the result of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3221.1">a+b</span></code><span class="koboSpan" id="kobo.3222.1"> is temporary, and its data can be safely moved to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3223.1">c</span></code><span class="koboSpan" id="kobo.3224.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3225.1">The move constructor is different from a copy constructor because it takes an rvalue reference to the class type </span><code class="inlineCode"><span class="koboSpan" id="kobo.3226.1">T(T&amp;&amp;)</span></code><span class="koboSpan" id="kobo.3227.1">, as opposed to an lvalue reference in the case of the copy constructor </span><code class="inlineCode"><span class="koboSpan" id="kobo.3228.1">T(T const&amp;)</span></code><span class="koboSpan" id="kobo.3229.1">. </span><span class="koboSpan" id="kobo.3229.2">Similarly, the move assignment takes an rvalue reference, namely </span><code class="inlineCode"><span class="koboSpan" id="kobo.3230.1">T&amp; operator=(T&amp;&amp;)</span></code><span class="koboSpan" id="kobo.3231.1">, as opposed to an lvalue reference for the copy assignment operator, namely </span><code class="inlineCode"><span class="koboSpan" id="kobo.3232.1">T&amp; operator=(T const &amp;)</span></code><span class="koboSpan" id="kobo.3233.1">. </span><span class="koboSpan" id="kobo.3233.2">This is true even though both return a reference to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3234.1">T&amp;</span></code><span class="koboSpan" id="kobo.3235.1"> class. </span><span class="koboSpan" id="kobo.3235.2">The compiler selects the appropriate constructor or assignment operator based on the type of argument, rvalue, or lvalue.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3236.1">When a </span><a id="_idIndexMarker1196"/><span class="koboSpan" id="kobo.3237.1">move constructor/assignment operator exists, an rvalue is moved automatically. </span><span class="koboSpan" id="kobo.3237.2">lvalues can also be moved, but this requires an explicit casting to an rvalue reference. </span><span class="koboSpan" id="kobo.3237.3">This can be done using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3238.1">std::move()</span></code><span class="koboSpan" id="kobo.3239.1"> function, which basically performs a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3240.1">static_cast&lt;T&amp;&amp;&gt;</span></code><span class="koboSpan" id="kobo.3241.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3242.1">std::vector&lt;Buffer&gt; c;
c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3243.1">push_back</span></span><span class="koboSpan" id="kobo.3244.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3245.1">Buffer</span></span><span class="koboSpan" id="kobo.3246.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3247.1">100</span></span><span class="koboSpan" id="kobo.3248.1">));  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3249.1">// move</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.3250.1">Buffer </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3251.1">b</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3252.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3253.1">200</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3254.1">)</span></span><span class="koboSpan" id="kobo.3255.1">;
c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3256.1">push_back</span></span><span class="koboSpan" id="kobo.3257.1">(b);            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3258.1">// copy</span></span><span class="koboSpan" id="kobo.3259.1">
c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3260.1">push_back</span></span><span class="koboSpan" id="kobo.3261.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3262.1">move</span></span><span class="koboSpan" id="kobo.3263.1">(b)); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3264.1">// move</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3265.1">After an object is moved, it must remain in a valid state. </span><span class="koboSpan" id="kobo.3265.2">However, there is no requirement regarding what this state should be. </span><span class="koboSpan" id="kobo.3265.3">For consistency, you should set all member fields to their default value (numerical types to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3266.1">0</span></code><span class="koboSpan" id="kobo.3267.1">, pointers to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3268.1">nullptr</span></code><span class="koboSpan" id="kobo.3269.1">, Booleans to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3270.1">false</span></code><span class="koboSpan" id="kobo.3271.1">, and so on).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3272.1">The following example shows the different ways in which </span><code class="inlineCode"><span class="koboSpan" id="kobo.3273.1">Buffer</span></code><span class="koboSpan" id="kobo.3274.1"> objects can be constructed and assigned:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3275.1">Buffer b1;                </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3276.1">// default constructor</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.3277.1">Buffer </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3278.1">b2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3279.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3280.1">100</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3281.1">)</span></span><span class="koboSpan" id="kobo.3282.1">;           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3283.1">// explicit constructor</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.3284.1">Buffer </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3285.1">b3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3286.1">(b2)</span></span><span class="koboSpan" id="kobo.3287.1">;            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3288.1">// copy constructor</span></span><span class="koboSpan" id="kobo.3289.1">
b1 = b3;                  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3290.1">// assignment operator</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.3291.1">Buffer </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3292.1">b4</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3293.1">(std::move(b1))</span></span><span class="koboSpan" id="kobo.3294.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3295.1">// move constructor</span></span><span class="koboSpan" id="kobo.3296.1">
b3 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3297.1">move</span></span><span class="koboSpan" id="kobo.3298.1">(b4);       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3299.1">// move assignment</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3300.1">The constructor or assignment operator involved in the creation or assignment of the objects </span><code class="inlineCode"><span class="koboSpan" id="kobo.3301.1">b1</span></code><span class="koboSpan" id="kobo.3302.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3303.1">b2</span></code><span class="koboSpan" id="kobo.3304.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3305.1">b3</span></code><span class="koboSpan" id="kobo.3306.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3307.1">b4</span></code><span class="koboSpan" id="kobo.3308.1"> is mentioned in the comments on each line.</span></p>
<h2 class="heading-2" id="_idParaDest-611"><span class="koboSpan" id="kobo.3309.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3310.1">As seen with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3311.1">Buffer</span></code><span class="koboSpan" id="kobo.3312.1"> example, implementing both the move constructor and move assignment operator involves writing similar code (the entire code of the move constructor was also present in the move assignment operator). </span><span class="koboSpan" id="kobo.3312.2">This can actually be avoided by calling the move assignment operator in the move constructor (or, alternatively, factor the assignment code into a private function that is invoked from both the move constructor and move assignment operator):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.3313.1">Buffer</span></span><span class="koboSpan" id="kobo.3314.1">(Buffer&amp;&amp; other) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3315.1">ptr</span></span><span class="koboSpan" id="kobo.3316.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.3317.1">nullptr</span></span><span class="koboSpan" id="kobo.3318.1">), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3319.1">length</span></span><span class="koboSpan" id="kobo.3320.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3321.1">0</span></span><span class="koboSpan" id="kobo.3322.1">)
{
  *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3323.1">this</span></span><span class="koboSpan" id="kobo.3324.1"> = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3325.1">move</span></span><span class="koboSpan" id="kobo.3326.1">(other);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3327.1">There are two </span><a id="_idIndexMarker1197"/><span class="koboSpan" id="kobo.3328.1">points that must be noticed in this example:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3329.1">Member initialization in the constructor’s initialization list is necessary because these members could potentially be used in the move assignment operator later on (such as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3330.1">ptr</span></code><span class="koboSpan" id="kobo.3331.1"> member in this example).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3332.1">Static casting of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3333.1">other</span></code><span class="koboSpan" id="kobo.3334.1"> to an rvalue reference. </span><span class="koboSpan" id="kobo.3334.2">Without this explicit conversion, the copy assignment operator would be called. </span><span class="koboSpan" id="kobo.3334.3">This is because even if an rvalue is passed to this constructor as an argument, when it is assigned a name, it is bound to an lvalue. </span><span class="koboSpan" id="kobo.3334.4">Therefore, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3335.1">other</span></code><span class="koboSpan" id="kobo.3336.1"> is actually an lvalue, and it must be converted to an rvalue reference in order to invoke the move assignment operator.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-612"><span class="koboSpan" id="kobo.3337.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.3338.1">Chapter 3</span></em><span class="koboSpan" id="kobo.3339.1">, </span><em class="italic"><span class="koboSpan" id="kobo.3340.1">Defaulted and deleted functions</span></em><span class="koboSpan" id="kobo.3341.1">, to learn about the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3342.1">default</span></code><span class="koboSpan" id="kobo.3343.1"> specifier on special member functions and how to define functions as deleted with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3344.1">delete</span></code><span class="koboSpan" id="kobo.3345.1"> specifier</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-613"><span class="koboSpan" id="kobo.3346.1">Using unique_ptr to uniquely own a memory resource</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3347.1">Manual handling</span><a id="_idIndexMarker1198"/><span class="koboSpan" id="kobo.3348.1"> of heap memory allocation and releasing it (with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3349.1">new</span></code><span class="koboSpan" id="kobo.3350.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3351.1">delete</span></code><span class="koboSpan" id="kobo.3352.1">) is one of the most controversial features of C++. </span><span class="koboSpan" id="kobo.3352.2">All allocations must be properly paired with a corresponding delete operation in the correct scope. </span><span class="koboSpan" id="kobo.3352.3">If the memory allocation is done in a function and needs to be released before the function returns, for instance, then this has to happen on all the return paths, including the abnormal situation where a function returns because of an exception. </span><span class="koboSpan" id="kobo.3352.4">C++11 features, such as rvalues and move semantics, have enabled the development of better smart pointers (since some, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3353.1">auto_ptr</span></code><span class="koboSpan" id="kobo.3354.1">, existed prior to C++11); these pointers can manage a memory resource and automatically release it when the smart pointer is destroyed. </span><span class="koboSpan" id="kobo.3354.2">In this recipe, we will look at </span><code class="inlineCode"><span class="koboSpan" id="kobo.3355.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3356.1">, a smart pointer that owns and manages another object or an array of objects </span><a id="_idIndexMarker1199"/><span class="koboSpan" id="kobo.3357.1">allocated on the heap, and performs the disposal operation when the smart pointer goes out of scope.</span></p>
<h2 class="heading-2" id="_idParaDest-614"><span class="koboSpan" id="kobo.3358.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3359.1">In the following examples, we will use the ensuing class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3360.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3361.1">foo</span></span><span class="koboSpan" id="kobo.3362.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3363.1">int</span></span><span class="koboSpan" id="kobo.3364.1"> a;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3365.1">double</span></span><span class="koboSpan" id="kobo.3366.1"> b;
  std::string c;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3367.1">public</span></span><span class="koboSpan" id="kobo.3368.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3369.1">foo</span></span><span class="koboSpan" id="kobo.3370.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.3371.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3372.1">const</span></span><span class="koboSpan" id="kobo.3373.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3374.1">0</span></span><span class="koboSpan" id="kobo.3375.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3376.1">double</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3377.1">const</span></span><span class="koboSpan" id="kobo.3378.1"> b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3379.1">0</span></span><span class="koboSpan" id="kobo.3380.1">, 
</span><span class="hljs-built_in"> </span><span class="koboSpan" id="kobo.3381.1">std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.3382.1">const</span></span><span class="koboSpan" id="kobo.3383.1"> &amp; c = </span><span class="hljs-string"><span class="koboSpan" id="kobo.3384.1">""</span></span><span class="koboSpan" id="kobo.3385.1">) :</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3386.1">a</span></span><span class="koboSpan" id="kobo.3387.1">(a), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3388.1">b</span></span><span class="koboSpan" id="kobo.3389.1">(b), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3390.1">c</span></span><span class="koboSpan" id="kobo.3391.1">(c)
  {}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3392.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3393.1">print</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3394.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3395.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.3396.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3397.1">'('</span></span><span class="koboSpan" id="kobo.3398.1"> &lt;&lt; a &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3399.1">','</span></span><span class="koboSpan" id="kobo.3400.1"> &lt;&lt; b &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3401.1">','</span></span><span class="koboSpan" id="kobo.3402.1"> &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3403.1">quoted</span></span><span class="koboSpan" id="kobo.3404.1">(c) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3405.1">')'</span></span><span class="koboSpan" id="kobo.3406.1">
              &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3407.1">'\n'</span></span><span class="koboSpan" id="kobo.3408.1">;
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3409.1">For this recipe, you need to be familiar with move semantics and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3410.1">std::move()</span></code><span class="koboSpan" id="kobo.3411.1"> conversion function. </span><span class="koboSpan" id="kobo.3411.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3412.1">unique_ptr</span></code><span class="koboSpan" id="kobo.3413.1"> class is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3414.1">std</span></code><span class="koboSpan" id="kobo.3415.1"> namespace in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3416.1">&lt;memory&gt;</span></code><span class="koboSpan" id="kobo.3417.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-615"><span class="koboSpan" id="kobo.3418.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3419.1">The following is a list of typical operations you need to be aware of when working with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3420.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3421.1">:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3422.1">Use the available overloaded constructors to create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3423.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3424.1"> that manages objects or an array of objects through a pointer. </span><span class="koboSpan" id="kobo.3424.2">The default constructor creates a pointer that does not manage any object:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3425.1">std::unique_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3426.1">int</span></span><span class="koboSpan" id="kobo.3427.1">&gt;   pnull;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.3428.1">std::unique_ptr&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3429.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3430.1">&gt;   </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3431.1">pi</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3432.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3433.1">new</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3434.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3435.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3436.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3437.1">))</span></span><span class="koboSpan" id="kobo.3438.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.3439.1">std::unique_ptr&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3440.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3441.1">[]&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3442.1">pa</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3443.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3444.1">new</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3445.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3446.1">[</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3447.1">3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3448.1">]{ </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3449.1">1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3450.1">,</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3451.1">2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3452.1">,</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3453.1">3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3454.1"> })</span></span><span class="koboSpan" id="kobo.3455.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.3456.1">std::unique_ptr&lt;foo&gt;   </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3457.1">pf</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3458.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3459.1">new</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3460.1"> foo(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3461.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3462.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3463.1">42.0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3464.1">, </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3465.1">"42"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3466.1">))</span></span><span class="koboSpan" id="kobo.3467.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3468.1">Alternatively, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3469.1">std::make_unique()</span></code><span class="koboSpan" id="kobo.3470.1"> function template, available in C++14, to create </span><code class="inlineCode"><span class="koboSpan" id="kobo.3471.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3472.1"> objects:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3473.1">std::unique_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3474.1">int</span></span><span class="koboSpan" id="kobo.3475.1">&gt;   pi = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3476.1">make_unique</span></span><span class="koboSpan" id="kobo.3477.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3478.1">int</span></span><span class="koboSpan" id="kobo.3479.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3480.1">42</span></span><span class="koboSpan" id="kobo.3481.1">);
std::unique_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3482.1">int</span></span><span class="koboSpan" id="kobo.3483.1">[]&gt; pa = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3484.1">make_unique</span></span><span class="koboSpan" id="kobo.3485.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3486.1">int</span></span><span class="koboSpan" id="kobo.3487.1">[]&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3488.1">3</span></span><span class="koboSpan" id="kobo.3489.1">);
std::unique_ptr&lt;foo&gt;   pf = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3490.1">make_unique</span></span><span class="koboSpan" id="kobo.3491.1">&lt;foo&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3492.1">42</span></span><span class="koboSpan" id="kobo.3493.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3494.1">42.0</span></span><span class="koboSpan" id="kobo.3495.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3496.1">"42"</span></span><span class="koboSpan" id="kobo.3497.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3498.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3499.1">std::make_unique_for_overwrite()</span></code><span class="koboSpan" id="kobo.3500.1"> function template, available in C++20, to create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3501.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3502.1"> to objects or an array of objects that are default initialized. </span><span class="koboSpan" id="kobo.3502.2">These objects should later be overwritten with a determined value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3503.1">std::unique_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3504.1">int</span></span><span class="koboSpan" id="kobo.3505.1">&gt;   pi = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3506.1">make_unique_for_overwrite</span></span><span class="koboSpan" id="kobo.3507.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3508.1">int</span></span><span class="koboSpan" id="kobo.3509.1">&gt;();
std::unique_ptr&lt;foo[]&gt; pa = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3510.1">make_unique_for_overwrite</span></span><span class="koboSpan" id="kobo.3511.1">&lt;foo[]&gt;();
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3512.1">Use</span><a id="_idIndexMarker1200"/><span class="koboSpan" id="kobo.3513.1"> the overloaded constructor, which takes a custom deleter if the default </span><code class="inlineCode"><span class="koboSpan" id="kobo.3514.1">delete</span></code><span class="koboSpan" id="kobo.3515.1"> operator is not appropriate for destroying the managed object or array:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3516.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3517.1">foo_deleter</span></span><span class="koboSpan" id="kobo.3518.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3519.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3520.1">operator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3521.1">()(foo* pf)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3522.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.3523.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3524.1">"deleting foo..."</span></span><span class="koboSpan" id="kobo.3525.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3526.1">'\n'</span></span><span class="koboSpan" id="kobo.3527.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3528.1">delete</span></span><span class="koboSpan" id="kobo.3529.1"> pf;
  }
};
</span><span class="hljs-function"><span class="koboSpan" id="kobo.3530.1">std::unique_ptr&lt;foo, foo_deleter&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3531.1">pf</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3532.1">(</span></span>
<span class="hljs-params"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3533.1">new</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3534.1"> foo(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3535.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3536.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3537.1">42.0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3538.1">, </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3539.1">"42"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3540.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.3541.1">    foo_deleter())</span></span><span class="koboSpan" id="kobo.3542.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3543.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3544.1">std::move()</span></code><span class="koboSpan" id="kobo.3545.1"> to transfer the ownership of an object from one </span><code class="inlineCode"><span class="koboSpan" id="kobo.3546.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3547.1"> to another:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3548.1">auto</span></span><span class="koboSpan" id="kobo.3549.1"> pi = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3550.1">make_unique</span></span><span class="koboSpan" id="kobo.3551.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3552.1">int</span></span><span class="koboSpan" id="kobo.3553.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3554.1">42</span></span><span class="koboSpan" id="kobo.3555.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3556.1">auto</span></span><span class="koboSpan" id="kobo.3557.1"> qi = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3558.1">move</span></span><span class="koboSpan" id="kobo.3559.1">(pi);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3560.1">assert</span></span><span class="koboSpan" id="kobo.3561.1">(pi.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3562.1">get</span></span><span class="koboSpan" id="kobo.3563.1">() == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3564.1">nullptr</span></span><span class="koboSpan" id="kobo.3565.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3566.1">assert</span></span><span class="koboSpan" id="kobo.3567.1">(qi.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3568.1">get</span></span><span class="koboSpan" id="kobo.3569.1">() != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3570.1">nullptr</span></span><span class="koboSpan" id="kobo.3571.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3572.1">To access</span><a id="_idIndexMarker1201"/><span class="koboSpan" id="kobo.3573.1"> the raw pointer to the managed object, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3574.1">get()</span></code><span class="koboSpan" id="kobo.3575.1"> if you want to retain ownership of the object or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3576.1">release()</span></code><span class="koboSpan" id="kobo.3577.1"> if you want to release the ownership as well:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3578.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3579.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3580.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3581.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3582.1">* ptr)</span></span><span class="koboSpan" id="kobo.3583.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3584.1">if</span></span><span class="koboSpan" id="kobo.3585.1"> (ptr != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.3586.1">nullptr</span></span><span class="koboSpan" id="kobo.3587.1">)
    std::cout &lt;&lt; *ptr &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3588.1">'\n'</span></span><span class="koboSpan" id="kobo.3589.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3590.1">else</span></span><span class="koboSpan" id="kobo.3591.1">
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3592.1">"null"</span></span><span class="koboSpan" id="kobo.3593.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3594.1">'\n'</span></span><span class="koboSpan" id="kobo.3595.1">;
}
std::unique_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3596.1">int</span></span><span class="koboSpan" id="kobo.3597.1">&gt; pi;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3598.1">func</span></span><span class="koboSpan" id="kobo.3599.1">(pi.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3600.1">get</span></span><span class="koboSpan" id="kobo.3601.1">()); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3602.1">// prints null</span></span><span class="koboSpan" id="kobo.3603.1">
pi = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3604.1">make_unique</span></span><span class="koboSpan" id="kobo.3605.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3606.1">int</span></span><span class="koboSpan" id="kobo.3607.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3608.1">42</span></span><span class="koboSpan" id="kobo.3609.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3610.1">func</span></span><span class="koboSpan" id="kobo.3611.1">(pi.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3612.1">get</span></span><span class="koboSpan" id="kobo.3613.1">()); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3614.1">// prints 42</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3615.1">Dereference the pointer to the managed object using </span><code class="inlineCode"><span class="koboSpan" id="kobo.3616.1">operator*</span></code><span class="koboSpan" id="kobo.3617.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3618.1">operator-&gt;</span></code><span class="koboSpan" id="kobo.3619.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3620.1">auto</span></span><span class="koboSpan" id="kobo.3621.1"> pi = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3622.1">make_unique</span></span><span class="koboSpan" id="kobo.3623.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3624.1">int</span></span><span class="koboSpan" id="kobo.3625.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3626.1">42</span></span><span class="koboSpan" id="kobo.3627.1">);
*pi = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3628.1">21</span></span><span class="koboSpan" id="kobo.3629.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3630.1">auto</span></span><span class="koboSpan" id="kobo.3631.1"> pf1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3632.1">make_unique</span></span><span class="koboSpan" id="kobo.3633.1">&lt;foo&gt;();
pf1-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3634.1">print</span></span><span class="koboSpan" id="kobo.3635.1">(); // prints (0,0,"")
auto pf2 = std::make_unique&lt;foo&gt;(42, 42.0, "42");
pf2-&gt;print(); // prints (42,42,"42")
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3636.1">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.3637.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3638.1"> manages an array of objects, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3639.1">operator[]</span></code><span class="koboSpan" id="kobo.3640.1"> can be used to access individual elements of the array:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3641.1">std::unique_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3642.1">int</span></span><span class="koboSpan" id="kobo.3643.1">[]&gt; pa = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3644.1">make_unique</span></span><span class="koboSpan" id="kobo.3645.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3646.1">int</span></span><span class="koboSpan" id="kobo.3647.1">[]&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3648.1">3</span></span><span class="koboSpan" id="kobo.3649.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3650.1">for</span></span><span class="koboSpan" id="kobo.3651.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.3652.1">int</span></span><span class="koboSpan" id="kobo.3653.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3654.1">0</span></span><span class="koboSpan" id="kobo.3655.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.3656.1">3</span></span><span class="koboSpan" id="kobo.3657.1">; ++i)
  pa[i] = i + </span><span class="hljs-number"><span class="koboSpan" id="kobo.3658.1">1</span></span><span class="koboSpan" id="kobo.3659.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3660.1">To check whether </span><code class="inlineCode"><span class="koboSpan" id="kobo.3661.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3662.1"> can manage an object or not, use the explicit operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.3663.1">bool</span></code><span class="koboSpan" id="kobo.3664.1"> or check whether </span><code class="inlineCode"><span class="koboSpan" id="kobo.3665.1">get() != nullptr</span></code><span class="koboSpan" id="kobo.3666.1"> (which is what the operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.3667.1">bool</span></code><span class="koboSpan" id="kobo.3668.1"> does):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.3669.1">std::unique_ptr&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3670.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3671.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3672.1">pi</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3673.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3674.1">new</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3675.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3676.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3677.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3678.1">))</span></span><span class="koboSpan" id="kobo.3679.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3680.1">if</span></span><span class="koboSpan" id="kobo.3681.1"> (pi) std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3682.1">"not null"</span></span><span class="koboSpan" id="kobo.3683.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3684.1">'\n'</span></span><span class="koboSpan" id="kobo.3685.1">;
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3686.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3687.1"> objects can be stored in a container. </span><span class="koboSpan" id="kobo.3687.2">Objects returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.3688.1">make_unique()</span></code><span class="koboSpan" id="kobo.3689.1"> can be stored directly. </span><span class="koboSpan" id="kobo.3689.2">An lvalue object could be statically converted to an rvalue object with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3690.1">std::move()</span></code><span class="koboSpan" id="kobo.3691.1"> if you want to give up the ownership </span><a id="_idIndexMarker1202"/><span class="koboSpan" id="kobo.3692.1">of the managed object to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3693.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3694.1"> object in the container:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3695.1">std::vector&lt;std::unique_ptr&lt;foo&gt;&gt; data;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3696.1">for</span></span><span class="koboSpan" id="kobo.3697.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.3698.1">int</span></span><span class="koboSpan" id="kobo.3699.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3700.1">0</span></span><span class="koboSpan" id="kobo.3701.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.3702.1">5</span></span><span class="koboSpan" id="kobo.3703.1">; i++)
  data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3704.1">push_back</span></span><span class="koboSpan" id="kobo.3705.1">(
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3706.1">make_unique</span></span><span class="koboSpan" id="kobo.3707.1">&lt;foo&gt;(i, i, std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3708.1">to_string</span></span><span class="koboSpan" id="kobo.3709.1">(i)));
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3710.1">auto</span></span><span class="koboSpan" id="kobo.3711.1"> pf = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3712.1">make_unique</span></span><span class="koboSpan" id="kobo.3713.1">&lt;foo&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3714.1">42</span></span><span class="koboSpan" id="kobo.3715.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3716.1">42.0</span></span><span class="koboSpan" id="kobo.3717.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.3718.1">"42"</span></span><span class="koboSpan" id="kobo.3719.1">);
data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3720.1">push_back</span></span><span class="koboSpan" id="kobo.3721.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3722.1">move</span></span><span class="koboSpan" id="kobo.3723.1">(pf));
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-616"><span class="koboSpan" id="kobo.3724.1">How it works...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3725.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3726.1"> is a smart pointer that manages an object or an array allocated on the heap through a raw pointer. </span><span class="koboSpan" id="kobo.3726.2">It performs an appropriate disposal when the smart pointer goes out of scope, is assigned a new pointer with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3727.1">operator=</span></code><span class="koboSpan" id="kobo.3728.1">, or gives up ownership using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3729.1">release()</span></code><span class="koboSpan" id="kobo.3730.1"> method. </span><span class="koboSpan" id="kobo.3730.2">By default, the operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.3731.1">delete</span></code><span class="koboSpan" id="kobo.3732.1"> is used to dispose of the managed object. </span><span class="koboSpan" id="kobo.3732.2">However, the user may supply a custom deleter when constructing the smart pointer. </span><span class="koboSpan" id="kobo.3732.3">This deleter must be a function object, either an lvalue reference to a function object or a function, and this callable object must take a single argument of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.3733.1">unique_ptr&lt;T, Deleter&gt;::pointer</span></code><span class="koboSpan" id="kobo.3734.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3735.1">C++14 has added the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3736.1">std::make_unique()</span></code><span class="koboSpan" id="kobo.3737.1"> utility function template to create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3738.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3739.1">. </span><span class="koboSpan" id="kobo.3739.2">It avoids memory leaks in some particular contexts, but it has some limitations:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3740.1">It can only be used to allocate arrays; you cannot use it to initialize them, which is possible with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3741.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3742.1"> constructor.
    </span><p class="normal"><span class="koboSpan" id="kobo.3743.1">The following two pieces of sample code are equivalent:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.3744.1">// allocate and initialize an array</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.3745.1">std::unique_ptr&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3746.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3747.1">[]&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3748.1">pa</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3749.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3750.1">new</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3751.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3752.1">[</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3753.1">3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3754.1">]{ </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3755.1">1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3756.1">,</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3757.1">2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3758.1">,</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3759.1">3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3760.1"> })</span></span><span class="koboSpan" id="kobo.3761.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3762.1">// allocate and then initialize an array</span></span><span class="koboSpan" id="kobo.3763.1">
std::unique_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3764.1">int</span></span><span class="koboSpan" id="kobo.3765.1">[]&gt; pa = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3766.1">make_unique</span></span><span class="koboSpan" id="kobo.3767.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3768.1">int</span></span><span class="koboSpan" id="kobo.3769.1">[]&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3770.1">3</span></span><span class="koboSpan" id="kobo.3771.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3772.1">for</span></span><span class="koboSpan" id="kobo.3773.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.3774.1">int</span></span><span class="koboSpan" id="kobo.3775.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3776.1">0</span></span><span class="koboSpan" id="kobo.3777.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.3778.1">3</span></span><span class="koboSpan" id="kobo.3779.1">; ++i)
  pa[i] = i + </span><span class="hljs-number"><span class="koboSpan" id="kobo.3780.1">1</span></span><span class="koboSpan" id="kobo.3781.1">;
</span></code></pre></li>
</ul>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3782.1">It cannot be used to create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3783.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3784.1"> object with a user-defined deleter.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3785.1">As we just </span><a id="_idIndexMarker1203"/><span class="koboSpan" id="kobo.3786.1">mentioned, the great advantage of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3787.1">make_unique()</span></code><span class="koboSpan" id="kobo.3788.1"> is that it helps us avoid memory leaks in some contexts where exceptions are being thrown. </span><code class="inlineCode"><span class="koboSpan" id="kobo.3789.1">make_unique()</span></code><span class="koboSpan" id="kobo.3790.1"> itself can throw </span><code class="inlineCode"><span class="koboSpan" id="kobo.3791.1">std::bad_alloc</span></code><span class="koboSpan" id="kobo.3792.1"> if the allocation fails or any exception is thrown by the constructor of the object it creates. </span><span class="koboSpan" id="kobo.3792.2">Let’s consider the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3793.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3794.1">some_function</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3795.1">(std::unique_ptr&lt;foo&gt; p)</span></span><span class="koboSpan" id="kobo.3796.1">
{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3797.1">/* do something */</span></span><span class="koboSpan" id="kobo.3798.1"> }
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3799.1">some_function</span></span><span class="koboSpan" id="kobo.3800.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3801.1">unique_ptr</span></span><span class="koboSpan" id="kobo.3802.1">&lt;foo&gt;(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3803.1">new</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3804.1">foo</span></span><span class="koboSpan" id="kobo.3805.1">()));
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3806.1">some_function</span></span><span class="koboSpan" id="kobo.3807.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3808.1">make_unique</span></span><span class="koboSpan" id="kobo.3809.1">&lt;foo&gt;());
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3810.1">Regardless of what happens with the allocation and construction of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3811.1">foo</span></code><span class="koboSpan" id="kobo.3812.1">, there will be no memory leaks, irrespective of whether you use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3813.1">make_unique()</span></code><span class="koboSpan" id="kobo.3814.1"> or the constructor of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3815.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3816.1">. </span><span class="koboSpan" id="kobo.3816.2">However, this situation changes in a slightly different version of the code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3817.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3818.1">some_other_function</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3819.1">(std::unique_ptr&lt;foo&gt; p, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3820.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3821.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3822.1"> v)</span></span><span class="koboSpan" id="kobo.3823.1">
{
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3824.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3825.1">function_that_throws</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3826.1">()</span></span><span class="koboSpan" id="kobo.3827.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3828.1">throw</span></span><span class="koboSpan" id="kobo.3829.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3830.1">runtime_error</span></span><span class="koboSpan" id="kobo.3831.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3832.1">"not implemented"</span></span><span class="koboSpan" id="kobo.3833.1">);
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3834.1">// possible memory leak</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.3835.1">some_other_function</span></span><span class="koboSpan" id="kobo.3836.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3837.1">unique_ptr</span></span><span class="koboSpan" id="kobo.3838.1">&lt;foo&gt;(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3839.1">new</span></span><span class="koboSpan" id="kobo.3840.1"> foo),
                    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3841.1">function_that_throws</span></span><span class="koboSpan" id="kobo.3842.1">());
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3843.1">// no possible memory leak</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.3844.1">some_other_function</span></span><span class="koboSpan" id="kobo.3845.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3846.1">make_unique</span></span><span class="koboSpan" id="kobo.3847.1">&lt;foo&gt;(),
                    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3848.1">function_that_throws</span></span><span class="koboSpan" id="kobo.3849.1">());
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3850.1">In this example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3851.1">some_other_function()</span></code><span class="koboSpan" id="kobo.3852.1"> has an extra parameter: an integer value. </span><span class="koboSpan" id="kobo.3852.2">The integer argument that’s passed to this function is the returned value of another function. </span><span class="koboSpan" id="kobo.3852.3">If this function call throws an exception, using the constructor of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3853.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3854.1"> to create the smart pointer can produce a memory leak. </span><span class="koboSpan" id="kobo.3854.2">The reason for this is that, upon calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.3855.1">some_other_function()</span></code><span class="koboSpan" id="kobo.3856.1">, the compiler might first call </span><code class="inlineCode"><span class="koboSpan" id="kobo.3857.1">foo</span></code><span class="koboSpan" id="kobo.3858.1">, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.3859.1">function_that_throws()</span></code><span class="koboSpan" id="kobo.3860.1">, and then the constructor of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3861.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3862.1">. </span><span class="koboSpan" id="kobo.3862.2">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.3863.1">function_that_throws()</span></code><span class="koboSpan" id="kobo.3864.1"> throws an error, then the allocated </span><code class="inlineCode"><span class="koboSpan" id="kobo.3865.1">foo</span></code><span class="koboSpan" id="kobo.3866.1"> will leak. </span><span class="koboSpan" id="kobo.3866.2">If the calling order is </span><code class="inlineCode"><span class="koboSpan" id="kobo.3867.1">function_that_throws()</span></code><span class="koboSpan" id="kobo.3868.1"> and then </span><code class="inlineCode"><span class="koboSpan" id="kobo.3869.1">new foo()</span></code><span class="koboSpan" id="kobo.3870.1"> and the constructor of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3871.1">unique_ptr</span></code><span class="koboSpan" id="kobo.3872.1">, a memory leak will not happen; this is because the stack starts unwinding before the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3873.1">foo</span></code><span class="koboSpan" id="kobo.3874.1"> object is allocated. </span><span class="koboSpan" id="kobo.3874.2">However, by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3875.1">make_unique()</span></code><span class="koboSpan" id="kobo.3876.1"> function, this situation</span><a id="_idIndexMarker1204"/><span class="koboSpan" id="kobo.3877.1"> is avoided. </span><span class="koboSpan" id="kobo.3877.2">This is because the only calls made are to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3878.1">make_unique()</span></code><span class="koboSpan" id="kobo.3879.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3880.1">function_that_throws()</span></code><span class="koboSpan" id="kobo.3881.1">. </span><span class="koboSpan" id="kobo.3881.2">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.3882.1">function_that_throws()</span></code><span class="koboSpan" id="kobo.3883.1"> is called first, then the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3884.1">foo</span></code><span class="koboSpan" id="kobo.3885.1"> object will not be allocated at all. </span><span class="koboSpan" id="kobo.3885.2">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.3886.1">make_unique()</span></code><span class="koboSpan" id="kobo.3887.1"> is called first, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3888.1">foo</span></code><span class="koboSpan" id="kobo.3889.1"> object is constructed and its ownership is passed to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3890.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3891.1">. </span><span class="koboSpan" id="kobo.3891.2">If a later call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3892.1">function_that_throws()</span></code><span class="koboSpan" id="kobo.3893.1"> does throw, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.3894.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3895.1"> will be destroyed when the stack is unwound and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3896.1">foo</span></code><span class="koboSpan" id="kobo.3897.1"> object will be destroyed from the smart pointer’s destructor. </span><span class="koboSpan" id="kobo.3897.2">C++17 fixed this problem by requiring any parameter to be fully evaluated before the next one is started.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3898.1">In C++20, a new function, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3899.1">std::make_unique_for_overwrite()</span></code><span class="koboSpan" id="kobo.3900.1">, has been added. </span><span class="koboSpan" id="kobo.3900.2">This is similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3901.1">make_unique()</span></code><span class="koboSpan" id="kobo.3902.1"> except that its default initializes the object or the array of objects. </span><span class="koboSpan" id="kobo.3902.2">This function can be used in generic code where it’s unknown whether the type template parameter is trivially copyable or not. </span><span class="koboSpan" id="kobo.3902.3">This function expresses the intent to create a pointer to an object that may not be initialized so that it should be overwritten later.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3903.1">Constant </span><code class="inlineCode"><span class="koboSpan" id="kobo.3904.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3905.1"> objects cannot transfer the ownership of a managed object or array to another </span><code class="inlineCode"><span class="koboSpan" id="kobo.3906.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3907.1"> object. </span><span class="koboSpan" id="kobo.3907.2">On the other hand, access to the raw pointer to the managed object can be obtained with either </span><code class="inlineCode"><span class="koboSpan" id="kobo.3908.1">get()</span></code><span class="koboSpan" id="kobo.3909.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3910.1">release()</span></code><span class="koboSpan" id="kobo.3911.1">. </span><span class="koboSpan" id="kobo.3911.2">The first method only returns the underlying pointer, but the latter also releases the ownership of the managed object, hence the name. </span><span class="koboSpan" id="kobo.3911.3">After a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3912.1">release()</span></code><span class="koboSpan" id="kobo.3913.1">, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3914.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3915.1"> object will be empty and a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3916.1">get()</span></code><span class="koboSpan" id="kobo.3917.1"> will return </span><code class="inlineCode"><span class="koboSpan" id="kobo.3918.1">nullptr</span></code><span class="koboSpan" id="kobo.3919.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3920.1">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.3921.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3922.1"> that manages the object of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3923.1">Derived</span></code><span class="koboSpan" id="kobo.3924.1"> class can be implicitly converted to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3925.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3926.1"> that manages an object of the class </span><code class="inlineCode"><span class="koboSpan" id="kobo.3927.1">Base</span></code><span class="koboSpan" id="kobo.3928.1"> if </span><code class="inlineCode"><span class="koboSpan" id="kobo.3929.1">Derived</span></code><span class="koboSpan" id="kobo.3930.1"> is derived from </span><code class="inlineCode"><span class="koboSpan" id="kobo.3931.1">Base</span></code><span class="koboSpan" id="kobo.3932.1">. </span><span class="koboSpan" id="kobo.3932.2">This implicit conversion is safe only if </span><code class="inlineCode"><span class="koboSpan" id="kobo.3933.1">Base</span></code><span class="koboSpan" id="kobo.3934.1"> has a virtual destructor (as all base classes should have); otherwise, undefined behavior is employed:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3935.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3936.1">Base</span></span><span class="koboSpan" id="kobo.3937.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3938.1">virtual</span></span><span class="koboSpan" id="kobo.3939.1"> ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3940.1">Base</span></span><span class="koboSpan" id="kobo.3941.1">()
  {
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3942.1">"~Base()"</span></span><span class="koboSpan" id="kobo.3943.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3944.1">'\n'</span></span><span class="koboSpan" id="kobo.3945.1">;
  }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3946.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3947.1">Derived</span></span><span class="koboSpan" id="kobo.3948.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3949.1">public</span></span><span class="koboSpan" id="kobo.3950.1"> Base
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3951.1">virtual</span></span><span class="koboSpan" id="kobo.3952.1"> ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3953.1">Derived</span></span><span class="koboSpan" id="kobo.3954.1">()
  {
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3955.1">"~Derived()"</span></span><span class="koboSpan" id="kobo.3956.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3957.1">'\n'</span></span><span class="koboSpan" id="kobo.3958.1">;
  }
};
std::unique_ptr&lt;Derived&gt; pd = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3959.1">make_unique</span></span><span class="koboSpan" id="kobo.3960.1">&lt;Derived&gt;();
std::unique_ptr&lt;Base&gt; pb = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3961.1">move</span></span><span class="koboSpan" id="kobo.3962.1">(pd);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3963.1">The </span><a id="_idIndexMarker1205"/><span class="koboSpan" id="kobo.3964.1">output from running this snippet is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3965.1">~Derived()
~Base()
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3966.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3967.1"> can be stored in containers, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3968.1">std::vector</span></code><span class="koboSpan" id="kobo.3969.1">. </span><span class="koboSpan" id="kobo.3969.2">Because only one </span><code class="inlineCode"><span class="koboSpan" id="kobo.3970.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3971.1"> object can own the managed object at any point, the smart pointer cannot be copied to the container; it has to be moved. </span><span class="koboSpan" id="kobo.3971.2">This is possible with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3972.1">std::move()</span></code><span class="koboSpan" id="kobo.3973.1">, which performs a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3974.1">static_cast</span></code><span class="koboSpan" id="kobo.3975.1"> to an rvalue reference type. </span><span class="koboSpan" id="kobo.3975.2">This allows the ownership of the managed object to be transferred to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3976.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3977.1"> object that is created in the container.</span></p>
<h2 class="heading-2" id="_idParaDest-617"><span class="koboSpan" id="kobo.3978.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3979.1">Using shared_ptr to share a memory resource</span></em><span class="koboSpan" id="kobo.3980.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3981.1">std::shared_ptr</span></code><span class="koboSpan" id="kobo.3982.1"> class, which represents a smart pointer that shares ownership of an object or array of objects allocated on the heap</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-618"><span class="koboSpan" id="kobo.3983.1">Using shared_ptr to share a memory resource</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3984.1">Managing </span><a id="_idIndexMarker1206"/><span class="koboSpan" id="kobo.3985.1">dynamically allocated objects or arrays with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3986.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3987.1"> is not possible when the object or array has to be shared. </span><span class="koboSpan" id="kobo.3987.2">This is because a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3988.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3989.1"> retains its sole ownership. </span><span class="koboSpan" id="kobo.3989.2">The C++ standard provides another smart pointer, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3990.1">std::shared_ptr</span></code><span class="koboSpan" id="kobo.3991.1">; it is similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3992.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.3993.1"> in many ways, but the difference is that it can share the ownership of an object or array with other </span><code class="inlineCode"><span class="koboSpan" id="kobo.3994.1">std::shared_ptr</span></code><span class="koboSpan" id="kobo.3995.1"> objects. </span><span class="koboSpan" id="kobo.3995.2">In this recipe, we will see how </span><code class="inlineCode"><span class="koboSpan" id="kobo.3996.1">std::shared_ptr</span></code><span class="koboSpan" id="kobo.3997.1"> works and how it differs from </span><code class="inlineCode"><span class="koboSpan" id="kobo.3998.1">std::uniqueu_ptr</span></code><span class="koboSpan" id="kobo.3999.1">. </span><span class="koboSpan" id="kobo.3999.2">We will also look at </span><code class="inlineCode"><span class="koboSpan" id="kobo.4000.1">std::weak_ptr</span></code><span class="koboSpan" id="kobo.4001.1">, which is a non-resource-owning smart pointer that holds a reference to an object managed by a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4002.1">std::shared_ptr</span></code><span class="koboSpan" id="kobo.4003.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-619"><span class="koboSpan" id="kobo.4004.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4005.1">Make sure</span><a id="_idIndexMarker1207"/><span class="koboSpan" id="kobo.4006.1"> you read the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.4007.1">Using unique_ptr to uniquely own a memory resource</span></em><span class="koboSpan" id="kobo.4008.1">, to become familiar with how </span><code class="inlineCode"><span class="koboSpan" id="kobo.4009.1">unique_ptr</span></code><span class="koboSpan" id="kobo.4010.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4011.1">make_unique()</span></code><span class="koboSpan" id="kobo.4012.1"> work. </span><span class="koboSpan" id="kobo.4012.2">We will use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4013.1">foo</span></code><span class="koboSpan" id="kobo.4014.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4015.1">foo_deleter</span></code><span class="koboSpan" id="kobo.4016.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4017.1">Base</span></code><span class="koboSpan" id="kobo.4018.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4019.1">Derived</span></code><span class="koboSpan" id="kobo.4020.1"> classes defined in this recipe, and also make several references to it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4021.1">Both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4022.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4023.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4024.1">weak_ptr</span></code><span class="koboSpan" id="kobo.4025.1"> classes, as well as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4026.1">make_shared()</span></code><span class="koboSpan" id="kobo.4027.1"> function template, are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4028.1">std</span></code><span class="koboSpan" id="kobo.4029.1"> namespace in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4030.1">&lt;memory&gt;</span></code><span class="koboSpan" id="kobo.4031.1"> header.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.4032.1">For simplicity and readability, we will not use the fully qualified names </span><code class="inlineCode"><span class="koboSpan" id="kobo.4033.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.4034.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4035.1">std::shared_ptr</span></code><span class="koboSpan" id="kobo.4036.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4037.1">std::weak_ptr</span></code><span class="koboSpan" id="kobo.4038.1"> in this recipe, but </span><code class="inlineCode"><span class="koboSpan" id="kobo.4039.1">unique_ptr</span></code><span class="koboSpan" id="kobo.4040.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4041.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4042.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4043.1">weak_ptr</span></code><span class="koboSpan" id="kobo.4044.1">.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-620"><span class="koboSpan" id="kobo.4045.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4046.1">The following is a list of the typical operations you need to be aware of when working with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4047.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4048.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4049.1">weak_ptr</span></code><span class="koboSpan" id="kobo.4050.1">:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4051.1">Use one of the available overloaded constructors to create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4052.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4053.1"> that manages an object through a pointer. </span><span class="koboSpan" id="kobo.4053.2">The default constructor creates an empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.4054.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4055.1">, which does not manage any object:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4056.1">std::shared_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4057.1">int</span></span><span class="koboSpan" id="kobo.4058.1">&gt; pnull1;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4059.1">std::shared_ptr&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4060.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4061.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4062.1">pnull2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4063.1">(</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.4064.1">nullptr</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4065.1">)</span></span><span class="koboSpan" id="kobo.4066.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4067.1">std::shared_ptr&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4068.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4069.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4070.1">pi1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4071.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4072.1">new</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4073.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4074.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4075.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4076.1">))</span></span><span class="koboSpan" id="kobo.4077.1">;
std::shared_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4078.1">int</span></span><span class="koboSpan" id="kobo.4079.1">&gt; pi2 = pi1;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4080.1">std::shared_ptr&lt;foo&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4081.1">pf1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4082.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4083.1">new</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4084.1"> foo())</span></span><span class="koboSpan" id="kobo.4085.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4086.1">std::shared_ptr&lt;foo&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4087.1">pf2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4088.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4089.1">new</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4090.1"> foo(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4091.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4092.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4093.1">42.0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4094.1">, </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4095.1">"42"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4096.1">))</span></span><span class="koboSpan" id="kobo.4097.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4098.1">Alternatively, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4099.1">std::make_shared()</span></code><span class="koboSpan" id="kobo.4100.1"> function template, available since C++11, to create </span><code class="inlineCode"><span class="koboSpan" id="kobo.4101.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4102.1"> objects:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4103.1">std::shared_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4104.1">int</span></span><span class="koboSpan" id="kobo.4105.1">&gt; pi  = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4106.1">make_shared</span></span><span class="koboSpan" id="kobo.4107.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4108.1">int</span></span><span class="koboSpan" id="kobo.4109.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4110.1">42</span></span><span class="koboSpan" id="kobo.4111.1">);
std::shared_ptr&lt;foo&gt; pf1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4112.1">make_shared</span></span><span class="koboSpan" id="kobo.4113.1">&lt;foo&gt;();
std::shared_ptr&lt;foo&gt; pf2 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4114.1">make_shared</span></span><span class="koboSpan" id="kobo.4115.1">&lt;foo&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4116.1">42</span></span><span class="koboSpan" id="kobo.4117.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4118.1">42.0</span></span><span class="koboSpan" id="kobo.4119.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4120.1">"42"</span></span><span class="koboSpan" id="kobo.4121.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4122.1">Use</span><a id="_idIndexMarker1208"/><span class="koboSpan" id="kobo.4123.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4124.1">std::make_shared_for_overwrite()</span></code><span class="koboSpan" id="kobo.4125.1"> function template, available in C++20, to create </span><code class="inlineCode"><span class="koboSpan" id="kobo.4126.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4127.1">s to objects or arrays of objects that are default initialized. </span><span class="koboSpan" id="kobo.4127.2">These objects should later be overwritten with a determined value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4128.1">std::shared_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4129.1">int</span></span><span class="koboSpan" id="kobo.4130.1">&gt; pi = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4131.1">make_shared_for_overwrite</span></span><span class="koboSpan" id="kobo.4132.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4133.1">int</span></span><span class="koboSpan" id="kobo.4134.1">&gt;();
std::shared_ptr&lt;foo[]&gt; pa = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4135.1">make_shared_for_overwrite</span></span><span class="koboSpan" id="kobo.4136.1">&lt;foo[]&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4137.1">3</span></span><span class="koboSpan" id="kobo.4138.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4139.1">Use the overloaded constructor, which takes a custom deleter if the default delete operation is not appropriate for destroying the managed object:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.4140.1">std::shared_ptr&lt;foo&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4141.1">pf1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4142.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4143.1">new</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4144.1"> foo(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4145.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4146.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4147.1">42.0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4148.1">, </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4149.1">"42"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4150.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.4151.1">                         foo_deleter())</span></span><span class="koboSpan" id="kobo.4152.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4153.1">std::shared_ptr&lt;foo&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4154.1">pf2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4155.1">(</span></span>
<span class="hljs-params"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4156.1">new</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4157.1"> foo(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4158.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4159.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4160.1">42.0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4161.1">, </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4162.1">"42"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4163.1">),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.4164.1">        [](foo* p) {</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.4165.1">          std::cout &lt;&lt; </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4166.1">"deleting foo from lambda..."</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4167.1"> &lt;&lt; </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4168.1">'\n'</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4169.1">;</span></span>
<span class="hljs-params"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4170.1">delete</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4171.1"> p;})</span></span><span class="koboSpan" id="kobo.4172.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4173.1">Always specify a deleter when managing an array of objects. </span><span class="koboSpan" id="kobo.4173.2">The deleter can either be a partial specialization of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4174.1">std::default_delete</span></code><span class="koboSpan" id="kobo.4175.1"> for arrays or any function that takes a pointer to the template type:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.4176.1">std::shared_ptr&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4177.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4178.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4179.1">pa1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4180.1">(</span></span>
<span class="hljs-params"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4181.1">new</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4182.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4183.1">[</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4184.1">3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4185.1">]{ </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4186.1">1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4187.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4188.1">2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4189.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4190.1">3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4191.1"> },</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.4192.1">  std::default_delete&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4193.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4194.1">[]&gt;())</span></span><span class="koboSpan" id="kobo.4195.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4196.1">std::shared_ptr&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4197.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4198.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4199.1">pa2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4200.1">(</span></span>
<span class="hljs-params"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4201.1">new</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4202.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4203.1">[</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4204.1">3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4205.1">]{ </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4206.1">1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4207.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4208.1">2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4209.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4210.1">3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4211.1"> },</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.4212.1">  [](</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4213.1">auto</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4214.1"> p) {</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4215.1">delete</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4216.1">[] p; })</span></span><span class="koboSpan" id="kobo.4217.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4218.1">To access the raw pointer to the managed object, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4219.1">get()</span></code><span class="koboSpan" id="kobo.4220.1"> function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4221.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4222.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4223.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4224.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4225.1">* ptr)</span></span><span class="koboSpan" id="kobo.4226.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4227.1">if</span></span><span class="koboSpan" id="kobo.4228.1"> (ptr != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.4229.1">nullptr</span></span><span class="koboSpan" id="kobo.4230.1">)
    std::cout &lt;&lt; *ptr &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4231.1">'\n'</span></span><span class="koboSpan" id="kobo.4232.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4233.1">else</span></span><span class="koboSpan" id="kobo.4234.1">
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4235.1">"null"</span></span><span class="koboSpan" id="kobo.4236.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4237.1">'\n'</span></span><span class="koboSpan" id="kobo.4238.1">;
}
std::shared_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4239.1">int</span></span><span class="koboSpan" id="kobo.4240.1">&gt; pi;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4241.1">func</span></span><span class="koboSpan" id="kobo.4242.1">(pi.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4243.1">get</span></span><span class="koboSpan" id="kobo.4244.1">());
pi = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4245.1">make_shared</span></span><span class="koboSpan" id="kobo.4246.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4247.1">int</span></span><span class="koboSpan" id="kobo.4248.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4249.1">42</span></span><span class="koboSpan" id="kobo.4250.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4251.1">func</span></span><span class="koboSpan" id="kobo.4252.1">(pi.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4253.1">get</span></span><span class="koboSpan" id="kobo.4254.1">());
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4255.1">Dereference </span><a id="_idIndexMarker1209"/><span class="koboSpan" id="kobo.4256.1">the pointer to the managed object using </span><code class="inlineCode"><span class="koboSpan" id="kobo.4257.1">operator*</span></code><span class="koboSpan" id="kobo.4258.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4259.1">operator-&gt;</span></code><span class="koboSpan" id="kobo.4260.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4261.1">std::shared_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4262.1">int</span></span><span class="koboSpan" id="kobo.4263.1">&gt; pi = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4264.1">make_shared</span></span><span class="koboSpan" id="kobo.4265.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4266.1">int</span></span><span class="koboSpan" id="kobo.4267.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4268.1">42</span></span><span class="koboSpan" id="kobo.4269.1">);
*pi = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4270.1">21</span></span><span class="koboSpan" id="kobo.4271.1">;
std::shared_ptr&lt;foo&gt; pf = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4272.1">make_shared</span></span><span class="koboSpan" id="kobo.4273.1">&lt;foo&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4274.1">42</span></span><span class="koboSpan" id="kobo.4275.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4276.1">42.0</span></span><span class="koboSpan" id="kobo.4277.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4278.1">"42"</span></span><span class="koboSpan" id="kobo.4279.1">);
pf-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4280.1">print</span></span><span class="koboSpan" id="kobo.4281.1">();
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4282.1">If a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4283.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4284.1"> manages an array of objects, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4285.1">operator[]</span></code><span class="koboSpan" id="kobo.4286.1"> can be used to access the individual elements of the array. </span><span class="koboSpan" id="kobo.4286.2">This is only available in C++17:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.4287.1">std::shared_ptr&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4288.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4289.1">[]&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4290.1">pa1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4291.1">(</span></span>
<span class="hljs-params"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4292.1">new</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4293.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4294.1">[</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4295.1">3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4296.1">]{ </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4297.1">1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4298.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4299.1">2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4300.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4301.1">3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4302.1"> },</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.4303.1">  std::default_delete&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4304.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4305.1">[]&gt;())</span></span><span class="koboSpan" id="kobo.4306.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4307.1">for</span></span><span class="koboSpan" id="kobo.4308.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.4309.1">int</span></span><span class="koboSpan" id="kobo.4310.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4311.1">0</span></span><span class="koboSpan" id="kobo.4312.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.4313.1">3</span></span><span class="koboSpan" id="kobo.4314.1">; ++i)
  pa1[i] *= </span><span class="hljs-number"><span class="koboSpan" id="kobo.4315.1">2</span></span><span class="koboSpan" id="kobo.4316.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4317.1">To check whether a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4318.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4319.1"> could manage an object or not, use the explicit operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.4320.1">bool</span></code><span class="koboSpan" id="kobo.4321.1"> or check whether </span><code class="inlineCode"><span class="koboSpan" id="kobo.4322.1">get() != nullptr</span></code><span class="koboSpan" id="kobo.4323.1"> (which is what the operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.4324.1">bool</span></code><span class="koboSpan" id="kobo.4325.1"> does):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4326.1">std::shared_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4327.1">int</span></span><span class="koboSpan" id="kobo.4328.1">&gt; pnull;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4329.1">if</span></span><span class="koboSpan" id="kobo.4330.1"> (pnull) std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4331.1">"not null"</span></span><span class="koboSpan" id="kobo.4332.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4333.1">'\n'</span></span><span class="koboSpan" id="kobo.4334.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4335.1">std::shared_ptr&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4336.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4337.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4338.1">pi</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4339.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4340.1">new</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4341.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4342.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4343.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4344.1">))</span></span><span class="koboSpan" id="kobo.4345.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4346.1">if</span></span><span class="koboSpan" id="kobo.4347.1"> (pi) std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4348.1">"not null"</span></span><span class="koboSpan" id="kobo.4349.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4350.1">'\n'</span></span><span class="koboSpan" id="kobo.4351.1">;
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4352.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4353.1"> objects can be stored in containers, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4354.1">std::vector</span></code><span class="koboSpan" id="kobo.4355.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4356.1">std::vector&lt;std::shared_ptr&lt;foo&gt;&gt; data;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4357.1">for</span></span><span class="koboSpan" id="kobo.4358.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.4359.1">int</span></span><span class="koboSpan" id="kobo.4360.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4361.1">0</span></span><span class="koboSpan" id="kobo.4362.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.4363.1">5</span></span><span class="koboSpan" id="kobo.4364.1">; i++)
  data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4365.1">push_back</span></span><span class="koboSpan" id="kobo.4366.1">(
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4367.1">make_shared</span></span><span class="koboSpan" id="kobo.4368.1">&lt;foo&gt;(i, i, std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4369.1">to_string</span></span><span class="koboSpan" id="kobo.4370.1">(i)));
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4371.1">auto</span></span><span class="koboSpan" id="kobo.4372.1"> pf = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4373.1">make_shared</span></span><span class="koboSpan" id="kobo.4374.1">&lt;foo&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4375.1">42</span></span><span class="koboSpan" id="kobo.4376.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4377.1">42.0</span></span><span class="koboSpan" id="kobo.4378.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4379.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4380.1">42"</span></span><span class="koboSpan" id="kobo.4381.1">);
data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4382.1">push_back</span></span><span class="koboSpan" id="kobo.4383.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4384.1">move</span></span><span class="koboSpan" id="kobo.4385.1">(pf));
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4386.1">assert</span></span><span class="koboSpan" id="kobo.4387.1">(!pf);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4388.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4389.1">weak_ptr</span></code><span class="koboSpan" id="kobo.4390.1"> to</span><a id="_idIndexMarker1210"/><span class="koboSpan" id="kobo.4391.1"> maintain a non-owning reference to a shared object, which can be later accessed through a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4392.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4393.1"> constructed from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4394.1">weak_ptr</span></code><span class="koboSpan" id="kobo.4395.1"> object:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4396.1">auto</span></span><span class="koboSpan" id="kobo.4397.1"> sp1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4398.1">make_shared</span></span><span class="koboSpan" id="kobo.4399.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4400.1">int</span></span><span class="koboSpan" id="kobo.4401.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4402.1">42</span></span><span class="koboSpan" id="kobo.4403.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4404.1">assert</span></span><span class="koboSpan" id="kobo.4405.1">(sp1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4406.1">use_count</span></span><span class="koboSpan" id="kobo.4407.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.4408.1">1</span></span><span class="koboSpan" id="kobo.4409.1">);
std::weak_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4410.1">int</span></span><span class="koboSpan" id="kobo.4411.1">&gt; wpi = sp1;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4412.1">assert</span></span><span class="koboSpan" id="kobo.4413.1">(sp1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4414.1">use_count</span></span><span class="koboSpan" id="kobo.4415.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.4416.1">1</span></span><span class="koboSpan" id="kobo.4417.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4418.1">auto</span></span><span class="koboSpan" id="kobo.4419.1"> sp2 = wpi.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4420.1">lock</span></span><span class="koboSpan" id="kobo.4421.1">(); // sp2 type is std::shared_ptr&lt;int&gt;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4422.1">assert</span></span><span class="koboSpan" id="kobo.4423.1">(sp1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4424.1">use_count</span></span><span class="koboSpan" id="kobo.4425.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.4426.1">2</span></span><span class="koboSpan" id="kobo.4427.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4428.1">assert</span></span><span class="koboSpan" id="kobo.4429.1">(sp2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4430.1">use_count</span></span><span class="koboSpan" id="kobo.4431.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.4432.1">2</span></span><span class="koboSpan" id="kobo.4433.1">);
sp1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4434.1">reset</span></span><span class="koboSpan" id="kobo.4435.1">();
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4436.1">assert</span></span><span class="koboSpan" id="kobo.4437.1">(sp1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4438.1">use_count</span></span><span class="koboSpan" id="kobo.4439.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.4440.1">0</span></span><span class="koboSpan" id="kobo.4441.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4442.1">assert</span></span><span class="koboSpan" id="kobo.4443.1">(sp2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4444.1">use_count</span></span><span class="koboSpan" id="kobo.4445.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.4446.1">1</span></span><span class="koboSpan" id="kobo.4447.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4448.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4449.1">std::enable_shared_from_this</span></code><span class="koboSpan" id="kobo.4450.1"> class template as the base class for a type when you need to create </span><code class="inlineCode"><span class="koboSpan" id="kobo.4451.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4452.1"> objects for instances that are already managed by another </span><code class="inlineCode"><span class="koboSpan" id="kobo.4453.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4454.1"> object:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4455.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4456.1">Apprentice</span></span><span class="koboSpan" id="kobo.4457.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4458.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4459.1">Master</span></span><span class="koboSpan" id="kobo.4460.1"> : std::enable_shared_from_this&lt;Master&gt;
{
  ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4461.1">Master</span></span><span class="koboSpan" id="kobo.4462.1">() { std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4463.1">"~Master"</span></span><span class="koboSpan" id="kobo.4464.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4465.1">'\n'</span></span><span class="koboSpan" id="kobo.4466.1">; }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.4467.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4468.1">take_apprentice</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4469.1">(std::shared_ptr&lt;Apprentice&gt; a)</span></span><span class="koboSpan" id="kobo.4470.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4471.1">private</span></span><span class="koboSpan" id="kobo.4472.1">:
  std::shared_ptr&lt;Apprentice&gt; apprentice;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4473.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4474.1">Apprentice</span></span><span class="koboSpan" id="kobo.4475.1">
{
  ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4476.1">Apprentice</span></span><span class="koboSpan" id="kobo.4477.1">() { std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4478.1">"~Apprentice"</span></span><span class="koboSpan" id="kobo.4479.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4480.1">'\n'</span></span><span class="koboSpan" id="kobo.4481.1">; }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.4482.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4483.1">take_master</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4484.1">(std::weak_ptr&lt;Master&gt; m)</span></span><span class="koboSpan" id="kobo.4485.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4486.1">private</span></span><span class="koboSpan" id="kobo.4487.1">:
  std::weak_ptr&lt;Master&gt; master;
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4488.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4489.1">Master::take_apprentice</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4490.1">(std::shared_ptr&lt;Apprentice&gt; a)</span></span><span class="koboSpan" id="kobo.4491.1">
{
  apprentice = a;
  apprentice-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4492.1">take_master</span></span><span class="koboSpan" id="kobo.4493.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4494.1">shared_from_this</span></span><span class="koboSpan" id="kobo.4495.1">());
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4496.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4497.1">Apprentice::take_master</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4498.1">(std::weak_ptr&lt;Master&gt; m)</span></span><span class="koboSpan" id="kobo.4499.1">
{
  master = m;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4500.1">auto</span></span><span class="koboSpan" id="kobo.4501.1"> m = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4502.1">make_shared</span></span><span class="koboSpan" id="kobo.4503.1">&lt;Master&gt;();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4504.1">auto</span></span><span class="koboSpan" id="kobo.4505.1"> a = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4506.1">make_shared</span></span><span class="koboSpan" id="kobo.4507.1">&lt;Apprentice&gt;();
m-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4508.1">take_apprentice</span></span><span class="koboSpan" id="kobo.4509.1">(a);
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-621"><span class="koboSpan" id="kobo.4510.1">How it works...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4511.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4512.1"> is </span><a id="_idIndexMarker1211"/><span class="koboSpan" id="kobo.4513.1">very similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4514.1">unique_ptr</span></code><span class="koboSpan" id="kobo.4515.1"> in many aspects; however, it serves a different purpose: sharing the ownership of an object or array. </span><span class="koboSpan" id="kobo.4515.2">Two or more </span><code class="inlineCode"><span class="koboSpan" id="kobo.4516.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4517.1"> smart pointers can manage the same dynamically allocated object or array, which is automatically destroyed when the last smart pointer goes out of scope, is assigned a new pointer with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4518.1">operator=</span></code><span class="koboSpan" id="kobo.4519.1">, or is reset with the method </span><code class="inlineCode"><span class="koboSpan" id="kobo.4520.1">reset()</span></code><span class="koboSpan" id="kobo.4521.1">. </span><span class="koboSpan" id="kobo.4521.2">By default, the object </span><a id="_idIndexMarker1212"/><span class="koboSpan" id="kobo.4522.1">is destroyed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4523.1">operator delete</span></code><span class="koboSpan" id="kobo.4524.1">; however, the user could supply a custom deleter to the constructor, something that is not possible using </span><code class="inlineCode"><span class="koboSpan" id="kobo.4525.1">std::make_shared()</span></code><span class="koboSpan" id="kobo.4526.1">. </span><span class="koboSpan" id="kobo.4526.2">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.4527.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4528.1"> is used to manage an array of objects, a custom deleter must be supplied. </span><span class="koboSpan" id="kobo.4528.2">In this case, you can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4529.1">std::default_delete&lt;T[]&gt;</span></code><span class="koboSpan" id="kobo.4530.1">, which is a partial specialization of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4531.1">std::default_delete</span></code><span class="koboSpan" id="kobo.4532.1"> class template that uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.4533.1">operator delete[]</span></code><span class="koboSpan" id="kobo.4534.1"> to delete the dynamically allocated array.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4535.1">The utility function </span><code class="inlineCode"><span class="koboSpan" id="kobo.4536.1">std::make_shared()</span></code><span class="koboSpan" id="kobo.4537.1"> (available since C++11), unlike </span><code class="inlineCode"><span class="koboSpan" id="kobo.4538.1">std::make_unique()</span></code><span class="koboSpan" id="kobo.4539.1">, which has only been available since C++14, should be used to create smart pointers unless you need to provide a custom deleter. </span><span class="koboSpan" id="kobo.4539.2">The primary reason for this is the same as for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4540.1">make_unique()</span></code><span class="koboSpan" id="kobo.4541.1">: avoiding potential memory leaks in some contexts when an exception is thrown. </span><span class="koboSpan" id="kobo.4541.2">For more information on this, read the explanation provided on </span><code class="inlineCode"><span class="koboSpan" id="kobo.4542.1">std::make_unique()</span></code><span class="koboSpan" id="kobo.4543.1"> in the previous recipe.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4544.1">In C++20, a new function, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4545.1">std::make_shared_for_overwrite()</span></code><span class="koboSpan" id="kobo.4546.1">, has been added. </span><span class="koboSpan" id="kobo.4546.2">This is similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4547.1">make_shared()</span></code><span class="koboSpan" id="kobo.4548.1"> except that it default initializes the object or the array of objects. </span><span class="koboSpan" id="kobo.4548.2">This function can be used in generic code where it’s unknown whether the type template parameter is trivially copyable or not. </span><span class="koboSpan" id="kobo.4548.3">This function expresses the intent to create a pointer to an object that may not be initialized so that it should be overwritten later.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4549.1">Also, as in </span><a id="_idIndexMarker1213"/><span class="koboSpan" id="kobo.4550.1">the case of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4551.1">unique_ptr</span></code><span class="koboSpan" id="kobo.4552.1">, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4553.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4554.1"> that manages an object of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4555.1">Derived</span></code><span class="koboSpan" id="kobo.4556.1"> class can be implicitly converted to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4557.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4558.1"> that manages an object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4559.1">Base</span></code><span class="koboSpan" id="kobo.4560.1"> class. </span><span class="koboSpan" id="kobo.4560.2">This is possible if the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4561.1">Derived</span></code><span class="koboSpan" id="kobo.4562.1"> class is derived from </span><code class="inlineCode"><span class="koboSpan" id="kobo.4563.1">Base</span></code><span class="koboSpan" id="kobo.4564.1">. </span><span class="koboSpan" id="kobo.4564.2">This implicit conversion is safe only if </span><code class="inlineCode"><span class="koboSpan" id="kobo.4565.1">Base</span></code><span class="koboSpan" id="kobo.4566.1"> has a virtual destructor (as all the base classes should have when objects are supposed to be deleted polymorphically through a pointer or reference to the base class); otherwise, undefined behavior is employed. </span><span class="koboSpan" id="kobo.4566.2">In C++17, several new non-member functions have been added: </span><code class="inlineCode"><span class="koboSpan" id="kobo.4567.1">std::static_pointer_cast()</span></code><span class="koboSpan" id="kobo.4568.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4569.1">std::dynamic_pointer_cast()</span></code><span class="koboSpan" id="kobo.4570.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4571.1">std::const_pointer_cast()</span></code><span class="koboSpan" id="kobo.4572.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4573.1">std::reinterpret_pointer_cast()</span></code><span class="koboSpan" id="kobo.4574.1">. </span><span class="koboSpan" id="kobo.4574.2">These apply </span><code class="inlineCode"><span class="koboSpan" id="kobo.4575.1">static_cast</span></code><span class="koboSpan" id="kobo.4576.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4577.1">dynamic_cast</span></code><span class="koboSpan" id="kobo.4578.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4579.1">const_cast</span></code><span class="koboSpan" id="kobo.4580.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4581.1">reinterpret_cast</span></code><span class="koboSpan" id="kobo.4582.1"> to the stored pointer, returning a new </span><code class="inlineCode"><span class="koboSpan" id="kobo.4583.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4584.1"> to the designated type.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4585.1">In the following example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4586.1">Base</span></code><span class="koboSpan" id="kobo.4587.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4588.1">Derived</span></code><span class="koboSpan" id="kobo.4589.1"> are the same classes we used in the previous recipe:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4590.1">std::shared_ptr&lt;Derived&gt; pd = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4591.1">make_shared</span></span><span class="koboSpan" id="kobo.4592.1">&lt;Derived&gt;();
std::shared_ptr&lt;Base&gt; pb = pd;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4593.1">static_pointer_cast</span></span><span class="koboSpan" id="kobo.4594.1">&lt;Derived&gt;(pb)-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4595.1">print</span></span><span class="koboSpan" id="kobo.4596.1">();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4597.1">There are situations when you need a smart pointer for a shared object but without it contributing to the shared ownership. </span><span class="koboSpan" id="kobo.4597.2">Suppose you model a tree structure where a node has references to its children and they are represented by </span><code class="inlineCode"><span class="koboSpan" id="kobo.4598.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4599.1"> objects. </span><span class="koboSpan" id="kobo.4599.2">On the other hand, say a node needs to keep a reference to its parent. </span><span class="koboSpan" id="kobo.4599.3">If this reference were also </span><code class="inlineCode"><span class="koboSpan" id="kobo.4600.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4601.1">, then it would create circular references and no object would ever be automatically destroyed.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4602.1">weak_ptr</span></code><span class="koboSpan" id="kobo.4603.1"> is a smart pointer that’s used to break such circular dependencies. </span><span class="koboSpan" id="kobo.4603.2">It holds a non-owning reference to an object or array managed by a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4604.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4605.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.4606.1">weak_ptr</span></code><span class="koboSpan" id="kobo.4607.1"> can be created from a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4608.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4609.1"> object. </span><span class="koboSpan" id="kobo.4609.2">In order to access the managed object, you need to get a temporary </span><code class="inlineCode"><span class="koboSpan" id="kobo.4610.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4611.1"> object. </span><span class="koboSpan" id="kobo.4611.2">To do so, we need to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4612.1">lock()</span></code><span class="koboSpan" id="kobo.4613.1"> method. </span><span class="koboSpan" id="kobo.4613.2">This method atomically checks whether the referred object still exists and returns either an empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.4614.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4615.1">, if the object no longer exists, or a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4616.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4617.1"> that owns the object, if it still exists. </span><span class="koboSpan" id="kobo.4617.2">Because </span><code class="inlineCode"><span class="koboSpan" id="kobo.4618.1">weak_ptr</span></code><span class="koboSpan" id="kobo.4619.1"> is a non-owning smart pointer, the referred object can be destroyed before </span><code class="inlineCode"><span class="koboSpan" id="kobo.4620.1">weak_ptr</span></code><span class="koboSpan" id="kobo.4621.1"> goes out of scope or when all the owning </span><code class="inlineCode"><span class="koboSpan" id="kobo.4622.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4623.1"> objects </span><a id="_idIndexMarker1214"/><span class="koboSpan" id="kobo.4624.1">have been destroyed, reset, or assigned to other pointers. </span><span class="koboSpan" id="kobo.4624.2">The method </span><code class="inlineCode"><span class="koboSpan" id="kobo.4625.1">expired()</span></code><span class="koboSpan" id="kobo.4626.1"> can be used to check whether the referenced object has been destroyed or is still available.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4627.1">In the </span><em class="italic"><span class="koboSpan" id="kobo.4628.1">How to do it...</span></em><span class="koboSpan" id="kobo.4629.1"> section, the preceding example models a master-apprentice relationship. </span><span class="koboSpan" id="kobo.4629.2">There is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4630.1">Master</span></code><span class="koboSpan" id="kobo.4631.1"> class and an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4632.1">Apprentice</span></code><span class="koboSpan" id="kobo.4633.1"> class. </span><span class="koboSpan" id="kobo.4633.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4634.1">Master</span></code><span class="koboSpan" id="kobo.4635.1"> class has a reference to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4636.1">Apprentice</span></code><span class="koboSpan" id="kobo.4637.1"> class and a method called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4638.1">take_apprentice()</span></code><span class="koboSpan" id="kobo.4639.1"> to set the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4640.1">Apprentice</span></code><span class="koboSpan" id="kobo.4641.1"> object. </span><span class="koboSpan" id="kobo.4641.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4642.1">Apprentice</span></code><span class="koboSpan" id="kobo.4643.1"> class has a reference to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4644.1">Master</span></code><span class="koboSpan" id="kobo.4645.1"> class and the method </span><code class="inlineCode"><span class="koboSpan" id="kobo.4646.1">take_master()</span></code><span class="koboSpan" id="kobo.4647.1"> to set the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4648.1">Master</span></code><span class="koboSpan" id="kobo.4649.1"> object. </span><span class="koboSpan" id="kobo.4649.2">In order to avoid circular dependencies, one of these references must be represented by a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4650.1">weak_ptr</span></code><span class="koboSpan" id="kobo.4651.1">. </span><span class="koboSpan" id="kobo.4651.2">In the proposed example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4652.1">Master</span></code><span class="koboSpan" id="kobo.4653.1"> class had a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4654.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4655.1"> to own the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4656.1">Apprentice</span></code><span class="koboSpan" id="kobo.4657.1"> object, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4658.1">Apprentice</span></code><span class="koboSpan" id="kobo.4659.1"> class had a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4660.1">weak_ptr</span></code><span class="koboSpan" id="kobo.4661.1"> to track a reference to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4662.1">Master</span></code><span class="koboSpan" id="kobo.4663.1"> object. </span><span class="koboSpan" id="kobo.4663.2">This example, however, is a bit more complex because here, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4664.1">Apprentice::take_master()</span></code><span class="koboSpan" id="kobo.4665.1"> method is called from </span><code class="inlineCode"><span class="koboSpan" id="kobo.4666.1">Master::take_apprentice()</span></code><span class="koboSpan" id="kobo.4667.1"> and needs a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4668.1">weak_ptr&lt;Master&gt;</span></code><span class="koboSpan" id="kobo.4669.1">. </span><span class="koboSpan" id="kobo.4669.2">In order to call it from within the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4670.1">Master</span></code><span class="koboSpan" id="kobo.4671.1"> class, we must be able to create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4672.1">shared_ptr&lt;Master&gt;</span></code><span class="koboSpan" id="kobo.4673.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4674.1">Master</span></code><span class="koboSpan" id="kobo.4675.1"> class, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4676.1">this</span></code><span class="koboSpan" id="kobo.4677.1"> pointer. </span><span class="koboSpan" id="kobo.4677.2">The only way to do this in a safe manner is to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4678.1">std::enable_shared_from_this</span></code><span class="koboSpan" id="kobo.4679.1">.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4680.1">std::enable_shared_from_this</span></code><span class="koboSpan" id="kobo.4681.1"> is a class template that must be used as a base class for all the classes where you need to create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4682.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4683.1"> for the current object (the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4684.1">this</span></code><span class="koboSpan" id="kobo.4685.1"> pointer) when this object is already managed by another </span><code class="inlineCode"><span class="koboSpan" id="kobo.4686.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4687.1">. </span><span class="koboSpan" id="kobo.4687.2">Its type template parameter must be the class that derives from it, as in the curiously recurring template pattern. </span><span class="koboSpan" id="kobo.4687.3">It has two methods: </span><code class="inlineCode"><span class="koboSpan" id="kobo.4688.1">shared_from_this()</span></code><span class="koboSpan" id="kobo.4689.1">, which returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4690.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4691.1">, which shares the ownership of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4692.1">this</span></code><span class="koboSpan" id="kobo.4693.1"> object, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4694.1">weak_from_this()</span></code><span class="koboSpan" id="kobo.4695.1">, which returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4696.1">weak_ptr</span></code><span class="koboSpan" id="kobo.4697.1">, which shares a non-owning reference to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4698.1">this</span></code><span class="koboSpan" id="kobo.4699.1"> object. </span><span class="koboSpan" id="kobo.4699.2">The latter method is only available in C++17. </span><span class="koboSpan" id="kobo.4699.3">These methods can be called only on an object that is managed by an existing </span><code class="inlineCode"><span class="koboSpan" id="kobo.4700.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4701.1">; otherwise, they throw a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4702.1">std::bad_weak_ptr</span></code><span class="koboSpan" id="kobo.4703.1"> exception, as of C++17. </span><span class="koboSpan" id="kobo.4703.2">Prior to C++17, the behavior was undefined.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4704.1">Not using </span><code class="inlineCode"><span class="koboSpan" id="kobo.4705.1">std::enable_shared_from_this</span></code><span class="koboSpan" id="kobo.4706.1"> and creating a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4707.1">shared_ptr&lt;T&gt;(this)</span></code><span class="koboSpan" id="kobo.4708.1"> directly would lead to having multiple </span><code class="inlineCode"><span class="koboSpan" id="kobo.4709.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4710.1"> objects managing the same object independently, without knowing each other. </span><span class="koboSpan" id="kobo.4710.2">When this happens, the object ends up being destroyed multiple times by different </span><code class="inlineCode"><span class="koboSpan" id="kobo.4711.1">shared_ptr</span></code><span class="koboSpan" id="kobo.4712.1"> objects.</span></p>
<h2 class="heading-2" id="_idParaDest-622"><span class="koboSpan" id="kobo.4713.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4714.1">Using unique_ptr to uniquely own a memory resource</span></em><span class="koboSpan" id="kobo.4715.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4716.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.4717.1"> class, which represents a smart pointer that owns and manages another object or array of objects allocated on the heap</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-623"><span class="koboSpan" id="kobo.4718.1">Consistent comparison with the operator &lt;=&gt;</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4719.1">The </span><a id="_idIndexMarker1215"/><span class="koboSpan" id="kobo.4720.1">C++ language defines six relational operators that perform comparison: </span><code class="inlineCode"><span class="koboSpan" id="kobo.4721.1">==</span></code><span class="koboSpan" id="kobo.4722.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4723.1">!=</span></code><span class="koboSpan" id="kobo.4724.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4725.1">&lt;</span></code><span class="koboSpan" id="kobo.4726.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4727.1">&lt;=</span></code><span class="koboSpan" id="kobo.4728.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4729.1">&gt;</span></code><span class="koboSpan" id="kobo.4730.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4731.1">&gt;=</span></code><span class="koboSpan" id="kobo.4732.1">. </span><span class="koboSpan" id="kobo.4732.2">Although </span><code class="inlineCode"><span class="koboSpan" id="kobo.4733.1">!=</span></code><span class="koboSpan" id="kobo.4734.1"> can be implemented in terms of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4735.1">==</span></code><span class="koboSpan" id="kobo.4736.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4737.1">&lt;=</span></code><span class="koboSpan" id="kobo.4738.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4739.1">&gt;=</span></code><span class="koboSpan" id="kobo.4740.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4741.1">&gt;</span></code><span class="koboSpan" id="kobo.4742.1"> in terms of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4743.1">&lt;</span></code><span class="koboSpan" id="kobo.4744.1">, you still have to implement both </span><code class="inlineCode"><span class="koboSpan" id="kobo.4745.1">==</span></code><span class="koboSpan" id="kobo.4746.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4747.1">!=</span></code><span class="koboSpan" id="kobo.4748.1"> if you want your user-defined type to support equality comparison, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4749.1">&lt;</span></code><span class="koboSpan" id="kobo.4750.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4751.1">&lt;=</span></code><span class="koboSpan" id="kobo.4752.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4753.1">&gt;</span></code><span class="koboSpan" id="kobo.4754.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4755.1">&gt;=</span></code><span class="koboSpan" id="kobo.4756.1"> if you want it to support ordering.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4757.1">That means 6 functions if</span><a id="_idIndexMarker1216"/><span class="koboSpan" id="kobo.4758.1"> you want objects of your type—let’s call it </span><code class="inlineCode"><span class="koboSpan" id="kobo.4759.1">T</span></code><span class="koboSpan" id="kobo.4760.1">—to be comparable, 12 if you want them to be comparable with another type, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4761.1">U</span></code><span class="koboSpan" id="kobo.4762.1">, 18 if you also want values of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4763.1">U</span></code><span class="koboSpan" id="kobo.4764.1"> type to be comparable with your </span><code class="inlineCode"><span class="koboSpan" id="kobo.4765.1">T</span></code><span class="koboSpan" id="kobo.4766.1"> type, and so on. </span><span class="koboSpan" id="kobo.4766.2">The new C++20 standard reduces this number to either one or two, or multiple of these (depending on the comparison with other types) by introducing a new comparison operator, called </span><em class="italic"><span class="koboSpan" id="kobo.4767.1">the three-way comparison</span></em><span class="koboSpan" id="kobo.4768.1">, which</span><a id="_idIndexMarker1217"/><span class="koboSpan" id="kobo.4769.1"> is designated with the symbol </span><code class="inlineCode"><span class="koboSpan" id="kobo.4770.1">&lt;=&gt;</span></code><span class="koboSpan" id="kobo.4771.1">, for which reason it is popularly known </span><a id="_idIndexMarker1218"/><span class="koboSpan" id="kobo.4772.1">as the </span><em class="italic"><span class="koboSpan" id="kobo.4773.1">spaceship operator</span></em><span class="koboSpan" id="kobo.4774.1">. </span><span class="koboSpan" id="kobo.4774.2">This new operator helps us write less code, better describe the strength of relations, and avoid possible performance issues that come from manually implementing comparison operators in terms of others.</span></p>
<h2 class="heading-2" id="_idParaDest-624"><span class="koboSpan" id="kobo.4775.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4776.1">It is necessary to include the header </span><code class="inlineCode"><span class="koboSpan" id="kobo.4777.1">&lt;compare&gt;</span></code><span class="koboSpan" id="kobo.4778.1"> when defining or implementing the three-way comparison operator. </span><span class="koboSpan" id="kobo.4778.2">This new C++20 header is part of the standard general utility library and provides classes, functions, and concepts for implementing comparison.</span></p>
<h2 class="heading-2" id="_idParaDest-625"><span class="koboSpan" id="kobo.4779.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4780.1">To optimally implement comparison in C++20, do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4781.1">If you only want your type to support equality comparison (both </span><code class="inlineCode"><span class="koboSpan" id="kobo.4782.1">==</span></code><span class="koboSpan" id="kobo.4783.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4784.1">!=</span></code><span class="koboSpan" id="kobo.4785.1">), implement only the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4786.1">==</span></code><span class="koboSpan" id="kobo.4787.1"> operator and return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4788.1">bool</span></code><span class="koboSpan" id="kobo.4789.1">. </span><span class="koboSpan" id="kobo.4789.2">You can default the implementation so that the compiler performs a member-wise comparison:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4790.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4791.1">foo</span></span><span class="koboSpan" id="kobo.4792.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.4793.1">int</span></span><span class="koboSpan" id="kobo.4794.1"> value;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4795.1">public</span></span><span class="koboSpan" id="kobo.4796.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4797.1">foo</span></span><span class="koboSpan" id="kobo.4798.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.4799.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4800.1">const</span></span><span class="koboSpan" id="kobo.4801.1"> v):</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4802.1">value</span></span><span class="koboSpan" id="kobo.4803.1">(v){}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.4804.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4805.1">operator</span></span><span class="koboSpan" id="kobo.4806.1">==(foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.4807.1">const</span></span><span class="koboSpan" id="kobo.4808.1">&amp;) </span><span class="hljs-type"><span class="koboSpan" id="kobo.4809.1">const</span></span><span class="koboSpan" id="kobo.4810.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4811.1">default</span></span><span class="koboSpan" id="kobo.4812.1">;
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4813.1">If you </span><a id="_idIndexMarker1219"/><span class="koboSpan" id="kobo.4814.1">want your type to support both equality and ordering and the default member-wise comparison will do, then only define the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4815.1">&lt;=&gt;</span></code><span class="koboSpan" id="kobo.4816.1"> operator, returning </span><code class="inlineCode"><span class="koboSpan" id="kobo.4817.1">auto</span></code><span class="koboSpan" id="kobo.4818.1">, and default its implementation:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4819.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4820.1">foo</span></span><span class="koboSpan" id="kobo.4821.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.4822.1">int</span></span><span class="koboSpan" id="kobo.4823.1"> value;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4824.1">public</span></span><span class="koboSpan" id="kobo.4825.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4826.1">foo</span></span><span class="koboSpan" id="kobo.4827.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.4828.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4829.1">const</span></span><span class="koboSpan" id="kobo.4830.1"> v) :</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4831.1">value</span></span><span class="koboSpan" id="kobo.4832.1">(v) {}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4833.1">auto</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.4834.1">operator</span></span><span class="koboSpan" id="kobo.4835.1">&lt;=&gt;(foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.4836.1">const</span></span><span class="koboSpan" id="kobo.4837.1">&amp;) </span><span class="hljs-type"><span class="koboSpan" id="kobo.4838.1">const</span></span><span class="koboSpan" id="kobo.4839.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4840.1">default</span></span><span class="koboSpan" id="kobo.4841.1">;
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4842.1">If you want your type to support both equality and ordering and you need to perform custom comparison, then implement both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4843.1">==</span></code><span class="koboSpan" id="kobo.4844.1"> operator (for equality) and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4845.1">&lt;=&gt;</span></code><span class="koboSpan" id="kobo.4846.1"> operator (for ordering):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4847.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4848.1">foo</span></span><span class="koboSpan" id="kobo.4849.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.4850.1">int</span></span><span class="koboSpan" id="kobo.4851.1"> value;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4852.1">public</span></span><span class="koboSpan" id="kobo.4853.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4854.1">foo</span></span><span class="koboSpan" id="kobo.4855.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.4856.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4857.1">const</span></span><span class="koboSpan" id="kobo.4858.1"> v) :</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4859.1">value</span></span><span class="koboSpan" id="kobo.4860.1">(v) {}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.4861.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4862.1">operator</span></span><span class="koboSpan" id="kobo.4863.1">==(foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.4864.1">const</span></span><span class="koboSpan" id="kobo.4865.1">&amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.4866.1">const</span></span><span class="koboSpan" id="kobo.4867.1">
  { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4868.1">return</span></span><span class="koboSpan" id="kobo.4869.1"> value == other.value; }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4870.1">auto</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.4871.1">operator</span></span><span class="koboSpan" id="kobo.4872.1">&lt;=&gt;(foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.4873.1">const</span></span><span class="koboSpan" id="kobo.4874.1">&amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.4875.1">const</span></span><span class="koboSpan" id="kobo.4876.1">
  { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4877.1">return</span></span><span class="koboSpan" id="kobo.4878.1"> value &lt;=&gt; other.value; }
};
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4879.1">When implementing the three-way comparison operator, follow these guidelines:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4880.1">Only implement the three-way comparison operator but always use the two-way comparison operators </span><code class="inlineCode"><span class="koboSpan" id="kobo.4881.1">&lt;</span></code><span class="koboSpan" id="kobo.4882.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4883.1">&lt;=</span></code><span class="koboSpan" id="kobo.4884.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4885.1">&gt;</span></code><span class="koboSpan" id="kobo.4886.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4887.1">&gt;=</span></code><span class="koboSpan" id="kobo.4888.1"> when comparing values.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4889.1">Implement </span><a id="_idIndexMarker1220"/><span class="koboSpan" id="kobo.4890.1">the three-way comparison operator as a member function, even if you want the first operand of a comparison to be of a type other than your class.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4891.1">Implement the three-way comparison operator as non-member functions only if you want implicit conversion on both arguments (that means comparing two objects, neither of which is of your class).</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-626"><span class="koboSpan" id="kobo.4892.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4893.1">The new three-way comparison operator is similar to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4894.1">memcmp()</span></code><span class="koboSpan" id="kobo.4895.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.4896.1">strcmp()</span></code><span class="koboSpan" id="kobo.4897.1"> C functions and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4898.1">std::string::compare()</span></code><span class="koboSpan" id="kobo.4899.1"> method. </span><span class="koboSpan" id="kobo.4899.2">These functions take two arguments and return an integer value that is smaller than zero if the first is less than the second, zero if they are equal, or greater than zero if the first argument is greater than the second. </span><span class="koboSpan" id="kobo.4899.3">The three-way comparison operator does not return an integer but a value of a comparison category type.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4900.1">This can be one of the following:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4901.1">std::strong_ordering</span></code><span class="koboSpan" id="kobo.4902.1"> represents the result of a three-way comparison that supports all six relational operators, does not allow incomparable values (which means that at least one of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4903.1">a &lt; b</span></code><span class="koboSpan" id="kobo.4904.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4905.1">a == b</span></code><span class="koboSpan" id="kobo.4906.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4907.1">a &gt; b</span></code><span class="koboSpan" id="kobo.4908.1"> must be true), and implies substitutability. </span><span class="koboSpan" id="kobo.4908.2">This is a property such that if </span><code class="inlineCode"><span class="koboSpan" id="kobo.4909.1">a == b</span></code><span class="koboSpan" id="kobo.4910.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4911.1">f</span></code><span class="koboSpan" id="kobo.4912.1"> is a function that reads only comparison-salient state (accessible via the argument’s public constant members), then </span><code class="inlineCode"><span class="koboSpan" id="kobo.4913.1">f(a) == f(b)</span></code><span class="koboSpan" id="kobo.4914.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4915.1">std::weak_ordering</span></code><span class="koboSpan" id="kobo.4916.1"> supports all the six relational operators, does not support incomparable values (which means that none of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4917.1">a &lt; b</span></code><span class="koboSpan" id="kobo.4918.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4919.1">a == b</span></code><span class="koboSpan" id="kobo.4920.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4921.1">a &gt; b</span></code><span class="koboSpan" id="kobo.4922.1"> could be true), but also does not imply substitutability. </span><span class="koboSpan" id="kobo.4922.2">A typical example of a type that defines weak ordering is a case-insensitive string type.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4923.1">std::partial_ordering</span></code><span class="koboSpan" id="kobo.4924.1"> supports all six relational operators but does not imply substitutability and has a value that might not be comparable (for instance, a floating-point </span><code class="inlineCode"><span class="koboSpan" id="kobo.4925.1">NaN</span></code><span class="koboSpan" id="kobo.4926.1"> cannot be compared to any other value).</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4927.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4928.1">std::strong_ordering</span></code><span class="koboSpan" id="kobo.4929.1"> type is the strongest of all these category types. </span><span class="koboSpan" id="kobo.4929.2">It is not implicitly convertible from any other category, but it implicitly converts to both </span><code class="inlineCode"><span class="koboSpan" id="kobo.4930.1">std::weak_ordering</span></code><span class="koboSpan" id="kobo.4931.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4932.1">std::partial_ordering</span></code><span class="koboSpan" id="kobo.4933.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.4934.1">std::weak_ordering</span></code><span class="koboSpan" id="kobo.4935.1"> is also implicitly convertible to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4936.1">std::partial_ordering</span></code><span class="koboSpan" id="kobo.4937.1">. </span><span class="koboSpan" id="kobo.4937.2">We’ve summarized all these properties in the following table:</span></p>
<table class="table-container" id="table002-5">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4938.1">Category</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4939.1">Operators</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4940.1">Substitutability</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4941.1">Comparable values</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4942.1">Implicit conversion</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4943.1">std::strong_ordering</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4944.1">==</span></code><span class="koboSpan" id="kobo.4945.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4946.1">!=</span></code><span class="koboSpan" id="kobo.4947.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4948.1">&lt;</span></code><span class="koboSpan" id="kobo.4949.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4950.1">&lt;=</span></code><span class="koboSpan" id="kobo.4951.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4952.1">&gt;</span></code><span class="koboSpan" id="kobo.4953.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4954.1">&gt;=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4955.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4956.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4957.1"><img alt="" src="../Images/B21549_09_001.png"/></span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4958.1">std::weak_ordering</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4959.1">==</span></code><span class="koboSpan" id="kobo.4960.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4961.1">!=</span></code><span class="koboSpan" id="kobo.4962.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4963.1">&lt;</span></code><span class="koboSpan" id="kobo.4964.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4965.1">&lt;=</span></code><span class="koboSpan" id="kobo.4966.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4967.1">&gt;</span></code><span class="koboSpan" id="kobo.4968.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4969.1">&gt;=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4970.1">No</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4971.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4972.1"><img alt="" src="../Images/B21549_09_001.png"/></span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4973.1">std::partial_ordering</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4974.1">==</span></code><span class="koboSpan" id="kobo.4975.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4976.1">!=</span></code><span class="koboSpan" id="kobo.4977.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4978.1">&lt;</span></code><span class="koboSpan" id="kobo.4979.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4980.1">&lt;=</span></code><span class="koboSpan" id="kobo.4981.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4982.1">&gt;</span></code><span class="koboSpan" id="kobo.4983.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4984.1">&gt;=</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4985.1">No</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4986.1">No</span></p>
</td>
<td class="table-cell"/>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.4987.1">Table 9.2: Properties of the category types</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4988.1">These </span><a id="_idIndexMarker1221"/><span class="koboSpan" id="kobo.4989.1">comparison categories have values that are implicitly comparable with literal zero (but not with an integer variable that is zero). </span><span class="koboSpan" id="kobo.4989.2">Their values are listed in the following table:</span></p>
<table class="table-container" id="table003-5">
<tbody>
<tr>
<td class="table-cell" rowspan="2">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4990.1">Category</span></strong></p>
</td>
<td class="table-cell" colspan="3">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4991.1">Numeric values</span></strong></p>
</td>
<td class="table-cell" rowspan="2">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4992.1">Non-numeric values</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4993.1">-1</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4994.1">0</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4995.1">1</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4996.1">strong_ordering</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4997.1">less</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4998.1">equal</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4999.1">equivalent</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5000.1">greater</span></p>
</td>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5001.1">weak_ordering</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5002.1">less</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5003.1">equivalent</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5004.1">greater</span></p>
</td>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5005.1">partial_ordering</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5006.1">less</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5007.1">equivalent</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5008.1">greater</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5009.1">unordered</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.5010.1">Table 9.3: The values of the comparison categories that are implicitly comparable to literal zero</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5011.1">To better understand how this works, let’s look at the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5012.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5013.1">cost_unit_t</span></span><span class="koboSpan" id="kobo.5014.1">
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5015.1">// data members</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5016.1">public</span></span><span class="koboSpan" id="kobo.5017.1">:
  std::strong_ordering </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5018.1">operator</span></span><span class="koboSpan" id="kobo.5019.1">&lt;=&gt;(</span><span class="hljs-type"><span class="koboSpan" id="kobo.5020.1">cost_unit_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5021.1">const</span></span><span class="koboSpan" id="kobo.5022.1"> &amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.5023.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5024.1">noexcept</span></span><span class="koboSpan" id="kobo.5025.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5026.1">default</span></span><span class="koboSpan" id="kobo.5027.1">;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5028.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5029.1">project_t</span></span><span class="koboSpan" id="kobo.5030.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5031.1">public</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5032.1">cost_unit_t</span></span><span class="koboSpan" id="kobo.5033.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5034.1">int</span></span><span class="koboSpan" id="kobo.5035.1">         id;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5036.1">int</span></span><span class="koboSpan" id="kobo.5037.1">         type;
  std::string name;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5038.1">public</span></span><span class="koboSpan" id="kobo.5039.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5040.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5041.1">operator</span></span><span class="koboSpan" id="kobo.5042.1">==(</span><span class="hljs-type"><span class="koboSpan" id="kobo.5043.1">project_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5044.1">const</span></span><span class="koboSpan" id="kobo.5045.1">&amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.5046.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5047.1">noexcept</span></span><span class="koboSpan" id="kobo.5048.1">
  {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5049.1">return</span></span><span class="koboSpan" id="kobo.5050.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.5051.1">cost_unit_t</span></span><span class="koboSpan" id="kobo.5052.1">&amp;)(*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5053.1">this</span></span><span class="koboSpan" id="kobo.5054.1">) == (</span><span class="hljs-type"><span class="koboSpan" id="kobo.5055.1">cost_unit_t</span></span><span class="koboSpan" id="kobo.5056.1">&amp;)other &amp;&amp;
           name == other.name &amp;&amp;
           type == other.type &amp;&amp;
           id == other.id;
  }
  std::strong_ordering </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5057.1">operator</span></span><span class="koboSpan" id="kobo.5058.1">&lt;=&gt;(</span><span class="hljs-type"><span class="koboSpan" id="kobo.5059.1">project_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5060.1">const</span></span><span class="koboSpan" id="kobo.5061.1"> &amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.5062.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5063.1">noexcept</span></span><span class="koboSpan" id="kobo.5064.1">
  {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5065.1">// compare the base class members</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5066.1">if</span></span><span class="koboSpan" id="kobo.5067.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5068.1">auto</span></span><span class="koboSpan" id="kobo.5069.1"> cmp = (</span><span class="hljs-type"><span class="koboSpan" id="kobo.5070.1">cost_unit_t</span></span><span class="koboSpan" id="kobo.5071.1">&amp;)(*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5072.1">this</span></span><span class="koboSpan" id="kobo.5073.1">) &lt;=&gt; (</span><span class="hljs-type"><span class="koboSpan" id="kobo.5074.1">cost_unit_t</span></span><span class="koboSpan" id="kobo.5075.1">&amp;)other;
        cmp != </span><span class="hljs-number"><span class="koboSpan" id="kobo.5076.1">0</span></span><span class="koboSpan" id="kobo.5077.1">)
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5078.1">return</span></span><span class="koboSpan" id="kobo.5079.1"> cmp;
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5080.1">// compare this class members in custom order</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5081.1">if</span></span><span class="koboSpan" id="kobo.5082.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5083.1">auto</span></span><span class="koboSpan" id="kobo.5084.1"> cmp = name.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5085.1">compare</span></span><span class="koboSpan" id="kobo.5086.1">(other.name); cmp != </span><span class="hljs-number"><span class="koboSpan" id="kobo.5087.1">0</span></span><span class="koboSpan" id="kobo.5088.1">)
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5089.1">return</span></span><span class="koboSpan" id="kobo.5090.1"> cmp &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.5091.1">0</span></span><span class="koboSpan" id="kobo.5092.1"> ? </span><span class="koboSpan" id="kobo.5092.2">std::strong_ordering::less :
                       std::strong_ordering::greater;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5093.1">if</span></span><span class="koboSpan" id="kobo.5094.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5095.1">auto</span></span><span class="koboSpan" id="kobo.5096.1"> cmp = type &lt;=&gt; other.type; cmp != </span><span class="hljs-number"><span class="koboSpan" id="kobo.5097.1">0</span></span><span class="koboSpan" id="kobo.5098.1">)
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5099.1">return</span></span><span class="koboSpan" id="kobo.5100.1"> cmp;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5101.1">return</span></span><span class="koboSpan" id="kobo.5102.1"> id &lt;=&gt; other.id;
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5103.1">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5104.1">cost_unit_t</span></code><span class="koboSpan" id="kobo.5105.1"> is a base </span><a id="_idIndexMarker1222"/><span class="koboSpan" id="kobo.5106.1">class that contains some (unspecified) data members and defines the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5107.1">&lt;=&gt;</span></code><span class="koboSpan" id="kobo.5108.1"> operator, although it is default-implemented by the compiler. </span><span class="koboSpan" id="kobo.5108.2">This means that the compiler will also provide the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5109.1">==</span></code><span class="koboSpan" id="kobo.5110.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5111.1">!=</span></code><span class="koboSpan" id="kobo.5112.1"> operators, not just </span><code class="inlineCode"><span class="koboSpan" id="kobo.5113.1">&lt;</span></code><span class="koboSpan" id="kobo.5114.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5115.1">&lt;=</span></code><span class="koboSpan" id="kobo.5116.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5117.1">&gt;</span></code><span class="koboSpan" id="kobo.5118.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5119.1">&gt;=</span></code><span class="koboSpan" id="kobo.5120.1">. </span><span class="koboSpan" id="kobo.5120.2">This class is derived by </span><code class="inlineCode"><span class="koboSpan" id="kobo.5121.1">project_t</span></code><span class="koboSpan" id="kobo.5122.1">, which contains several data fields: an identifier for the project, a type, and a name. </span><span class="koboSpan" id="kobo.5122.2">However, for this type, we cannot default the implementation of the operators, because we do not want to compare the fields member-wise, but in a custom order: first the name, then the type, and lastly the identifier. </span><span class="koboSpan" id="kobo.5122.3">In this case, we implement both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5123.1">==</span></code><span class="koboSpan" id="kobo.5124.1"> operator, which returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5125.1">bool</span></code><span class="koboSpan" id="kobo.5126.1"> and tests the member fields for equality, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5127.1">&lt;=&gt;</span></code><span class="koboSpan" id="kobo.5128.1"> operator, which returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.5129.1">std::strong_ordering</span></code><span class="koboSpan" id="kobo.5130.1"> and uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5131.1">&lt;=&gt;</span></code><span class="koboSpan" id="kobo.5132.1"> operator itself to compare the values of its two arguments.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5133.1">The following </span><a id="_idIndexMarker1223"/><span class="koboSpan" id="kobo.5134.1">code snippet shows a type called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5135.1">employee_t</span></code><span class="koboSpan" id="kobo.5136.1"> that models employees in a company. </span><span class="koboSpan" id="kobo.5136.2">An employee can have a manager, and an employee who is a manager has people that they manage. </span><span class="koboSpan" id="kobo.5136.3">Conceptually, such a type could look as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5137.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5138.1">employee_t</span></span><span class="koboSpan" id="kobo.5139.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5140.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5141.1">is_managed_by</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5142.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5143.1">employee_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5144.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5145.1">&amp;)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5146.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.5147.1">{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5148.1">/* ... </span><span class="koboSpan" id="kobo.5148.2">*/</span></span><span class="koboSpan" id="kobo.5149.1"> }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5150.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5151.1">is_manager_of</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5152.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5153.1">employee_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5154.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5155.1">&amp;)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5156.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.5157.1">{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5158.1">/* ... </span><span class="koboSpan" id="kobo.5158.2">*/</span></span><span class="koboSpan" id="kobo.5159.1"> }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5160.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5161.1">is_same</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5162.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5163.1">employee_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5164.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5165.1">&amp;)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5166.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.5167.1">{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5168.1">/* ... </span><span class="koboSpan" id="kobo.5168.2">*/</span></span><span class="koboSpan" id="kobo.5169.1"> }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5170.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5171.1">operator</span></span><span class="koboSpan" id="kobo.5172.1">==(</span><span class="hljs-type"><span class="koboSpan" id="kobo.5173.1">employee_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5174.1">const</span></span><span class="koboSpan" id="kobo.5175.1"> &amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.5176.1">const</span></span><span class="koboSpan" id="kobo.5177.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5178.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5179.1">is_same</span></span><span class="koboSpan" id="kobo.5180.1">(other);
  }
  std::partial_ordering </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5181.1">operator</span></span><span class="koboSpan" id="kobo.5182.1">&lt;=&gt;(</span><span class="hljs-type"><span class="koboSpan" id="kobo.5183.1">employee_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5184.1">const</span></span><span class="koboSpan" id="kobo.5185.1">&amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.5186.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5187.1">noexcept</span></span><span class="koboSpan" id="kobo.5188.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5189.1">if</span></span><span class="koboSpan" id="kobo.5190.1"> (</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5191.1">is_same</span></span><span class="koboSpan" id="kobo.5192.1">(other))
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5193.1">return</span></span><span class="koboSpan" id="kobo.5194.1"> std::partial_ordering::equivalent;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5195.1">if</span></span><span class="koboSpan" id="kobo.5196.1"> (</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5197.1">is_managed_by</span></span><span class="koboSpan" id="kobo.5198.1">(other))
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5199.1">return</span></span><span class="koboSpan" id="kobo.5200.1"> std::partial_ordering::less;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5201.1">if</span></span><span class="koboSpan" id="kobo.5202.1"> (</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5203.1">is_manager_of</span></span><span class="koboSpan" id="kobo.5204.1">(other))
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5205.1">return</span></span><span class="koboSpan" id="kobo.5206.1"> std::partial_ordering::greater;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5207.1">return</span></span><span class="koboSpan" id="kobo.5208.1"> std::partial_ordering::unordered;
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5209.1">The methods </span><code class="inlineCode"><span class="koboSpan" id="kobo.5210.1">is_same()</span></code><span class="koboSpan" id="kobo.5211.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5212.1">is_manager_of()</span></code><span class="koboSpan" id="kobo.5213.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5214.1">is_managed_by()</span></code><span class="koboSpan" id="kobo.5215.1"> return the relationship of two employees. </span><span class="koboSpan" id="kobo.5215.2">However, it is possible there are employees with no relationship; for instance, employees in different teams, or a team without a manager-subordinate structure. </span><span class="koboSpan" id="kobo.5215.3">Here, we can implement equality and ordering. </span><span class="koboSpan" id="kobo.5215.4">However, since we cannot compare all employees with each other, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5216.1">&lt;=&gt;</span></code><span class="koboSpan" id="kobo.5217.1"> operator must return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5218.1">std::partial_ordering</span></code><span class="koboSpan" id="kobo.5219.1"> value. </span><span class="koboSpan" id="kobo.5219.2">The return value is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5220.1">partial_ordering::equivalent</span></code><span class="koboSpan" id="kobo.5221.1"> if the values represent the same employee, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5222.1">partial_ordering::less</span></code><span class="koboSpan" id="kobo.5223.1"> if the current employee is managed by the supplied one, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5224.1">partial_ordering::greater</span></code><span class="koboSpan" id="kobo.5225.1"> if the current employee is the manager of the supplied one, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5226.1">partial_ordering::unorder</span></code><span class="koboSpan" id="kobo.5227.1"> in all other cases.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5228.1">Let’s see</span><a id="_idIndexMarker1224"/><span class="koboSpan" id="kobo.5229.1"> one more example to understand how the three-way comparison operator works. </span><span class="koboSpan" id="kobo.5229.2">In the following sample, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5230.1">ipv4</span></code><span class="koboSpan" id="kobo.5231.1"> class models an IP version 4 address. </span><span class="koboSpan" id="kobo.5231.2">It supports comparison with both other objects of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5232.1">ipv4</span></code><span class="koboSpan" id="kobo.5233.1"> type but also </span><code class="inlineCode"><span class="koboSpan" id="kobo.5234.1">unsigned long</span></code><span class="koboSpan" id="kobo.5235.1"> values (because there is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5236.1">to_unlong()</span></code><span class="koboSpan" id="kobo.5237.1"> method that converts the IP address into a 32-bit unsigned integral value):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5238.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5239.1">ipv4</span></span><span class="koboSpan" id="kobo.5240.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5241.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5242.1">ipv4</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5243.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5244.1">unsigned</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5245.1">char</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5246.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5247.1"> a=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.5248.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5249.1">, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5250.1">unsigned</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5251.1">char</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5252.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5253.1"> b=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.5254.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5255.1">,</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5256.1">unsigned</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5257.1">char</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5258.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5259.1"> c=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.5260.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5261.1">, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5262.1">unsigned</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5263.1">char</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5264.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5265.1"> d=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.5266.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5267.1">)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5268.1">noexcept</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5269.1"> :</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.5270.1">    data{</span></span><span class="koboSpan" id="kobo.5271.1"> a,b,c,d }
  {}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5272.1">unsigned</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5273.1">long</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5274.1">to_ulong</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5275.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5276.1">const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5277.1">noexcept</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.5278.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5279.1">return</span></span><span class="koboSpan" id="kobo.5280.1">
      (</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5281.1">static_cast</span></span><span class="koboSpan" id="kobo.5282.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5283.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5284.1">long</span></span><span class="koboSpan" id="kobo.5285.1">&gt;(data[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5286.1">0</span></span><span class="koboSpan" id="kobo.5287.1">]) &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.5288.1">24</span></span><span class="koboSpan" id="kobo.5289.1">) |
      (</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5290.1">static_cast</span></span><span class="koboSpan" id="kobo.5291.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5292.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5293.1">long</span></span><span class="koboSpan" id="kobo.5294.1">&gt;(data[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5295.1">1</span></span><span class="koboSpan" id="kobo.5296.1">]) &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.5297.1">16</span></span><span class="koboSpan" id="kobo.5298.1">) |
      (</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5299.1">static_cast</span></span><span class="koboSpan" id="kobo.5300.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5301.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5302.1">long</span></span><span class="koboSpan" id="kobo.5303.1">&gt;(data[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5304.1">2</span></span><span class="koboSpan" id="kobo.5305.1">]) &lt;&lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.5306.1">8</span></span><span class="koboSpan" id="kobo.5307.1">) |
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5308.1">static_cast</span></span><span class="koboSpan" id="kobo.5309.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5310.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5311.1">long</span></span><span class="koboSpan" id="kobo.5312.1">&gt;(data[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5313.1">3</span></span><span class="koboSpan" id="kobo.5314.1">]);
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5315.1">auto</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5316.1">operator</span></span><span class="koboSpan" id="kobo.5317.1">&lt;=&gt;(ipv4 </span><span class="hljs-type"><span class="koboSpan" id="kobo.5318.1">const</span></span><span class="koboSpan" id="kobo.5319.1">&amp;) </span><span class="hljs-type"><span class="koboSpan" id="kobo.5320.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5321.1">noexcept</span></span><span class="koboSpan" id="kobo.5322.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5323.1">default</span></span><span class="koboSpan" id="kobo.5324.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5325.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5326.1">operator</span></span><span class="koboSpan" id="kobo.5327.1">==(</span><span class="hljs-type"><span class="koboSpan" id="kobo.5328.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5329.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5330.1">const</span></span><span class="koboSpan" id="kobo.5331.1"> other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.5332.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5333.1">noexcept</span></span><span class="koboSpan" id="kobo.5334.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5335.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5336.1">to_ulong</span></span><span class="koboSpan" id="kobo.5337.1">() == other;
  }
  std::strong_ordering
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5338.1">operator</span></span><span class="koboSpan" id="kobo.5339.1">&lt;=&gt;(</span><span class="hljs-type"><span class="koboSpan" id="kobo.5340.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5341.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5342.1">const</span></span><span class="koboSpan" id="kobo.5343.1"> other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.5344.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5345.1">noexcept</span></span><span class="koboSpan" id="kobo.5346.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5347.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5348.1">to_ulong</span></span><span class="koboSpan" id="kobo.5349.1">() &lt;=&gt; other;
  }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5350.1">private</span></span><span class="koboSpan" id="kobo.5351.1">:
  std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5352.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5353.1">char</span></span><span class="koboSpan" id="kobo.5354.1">, 4&gt; data;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5355.1">In this example, we overloaded the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5356.1">&lt;=&gt;</span></code><span class="koboSpan" id="kobo.5357.1"> operator and allowed it to be default implemented. </span><span class="koboSpan" id="kobo.5357.2">But we also explicitly implemented overloads for </span><code class="inlineCode"><span class="koboSpan" id="kobo.5358.1">operator==</span></code><span class="koboSpan" id="kobo.5359.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5360.1">operator&lt;=&gt;</span></code><span class="koboSpan" id="kobo.5361.1">, which compare an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5362.1">ipv4</span></code><span class="koboSpan" id="kobo.5363.1"> object with an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5364.1">unsigned long</span></code><span class="koboSpan" id="kobo.5365.1"> value. </span><span class="koboSpan" id="kobo.5365.2">Because of these operators, we can write any of the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.5366.1">ipv4 </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5367.1">ip</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5368.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.5369.1">127</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5370.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.5371.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5372.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.5373.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5374.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.5375.1">1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5376.1">)</span></span><span class="koboSpan" id="kobo.5377.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5378.1">if</span></span><span class="koboSpan" id="kobo.5379.1">(ip == </span><span class="hljs-number"><span class="koboSpan" id="kobo.5380.1">0x7F000001</span></span><span class="koboSpan" id="kobo.5381.1">) {}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5382.1">if</span></span><span class="koboSpan" id="kobo.5383.1">(ip != </span><span class="hljs-number"><span class="koboSpan" id="kobo.5384.1">0x7F000001</span></span><span class="koboSpan" id="kobo.5385.1">) {}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5386.1">if</span></span><span class="koboSpan" id="kobo.5387.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5388.1">0x7F000001</span></span><span class="koboSpan" id="kobo.5389.1"> == ip) {}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5390.1">if</span></span><span class="koboSpan" id="kobo.5391.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5392.1">0x7F000001</span></span><span class="koboSpan" id="kobo.5393.1"> != ip) {}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5394.1">if</span></span><span class="koboSpan" id="kobo.5395.1">(ip &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.5396.1">0x7F000001</span></span><span class="koboSpan" id="kobo.5397.1">)  {}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5398.1">if</span></span><span class="koboSpan" id="kobo.5399.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5400.1">0x7F000001</span></span><span class="koboSpan" id="kobo.5401.1"> &lt; ip)  {}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5402.1">There </span><a id="_idIndexMarker1225"/><span class="koboSpan" id="kobo.5403.1">are two things to notice here: the first is that although we only overloaded the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5404.1">==</span></code><span class="koboSpan" id="kobo.5405.1"> operator, we can also use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5406.1">!=</span></code><span class="koboSpan" id="kobo.5407.1"> operator, and second, although we overloaded the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5408.1">==</span></code><span class="koboSpan" id="kobo.5409.1"> operator and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5410.1">&lt;=&gt;</span></code><span class="koboSpan" id="kobo.5411.1"> operator to compare </span><code class="inlineCode"><span class="koboSpan" id="kobo.5412.1">ipv4</span></code><span class="koboSpan" id="kobo.5413.1"> values to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5414.1">unsigned long</span></code><span class="koboSpan" id="kobo.5415.1"> values, we can also compare </span><code class="inlineCode"><span class="koboSpan" id="kobo.5416.1">unsigned long</span></code><span class="koboSpan" id="kobo.5417.1"> values to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5418.1">ipv4</span></code><span class="koboSpan" id="kobo.5419.1"> values. </span><span class="koboSpan" id="kobo.5419.2">This is because the compiler performs symmetrical overload resolution. </span><span class="koboSpan" id="kobo.5419.3">That means that for an expression </span><code class="inlineCode"><span class="koboSpan" id="kobo.5420.1">a@b</span></code><span class="koboSpan" id="kobo.5421.1"> where </span><code class="inlineCode"><span class="koboSpan" id="kobo.5422.1">@</span></code><span class="koboSpan" id="kobo.5423.1"> is a two-way relational operator, it performs name lookup for </span><code class="inlineCode"><span class="koboSpan" id="kobo.5424.1">a@b</span></code><span class="koboSpan" id="kobo.5425.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5426.1">a&lt;=&gt;b</span></code><span class="koboSpan" id="kobo.5427.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5428.1">b&lt;=&gt;a</span></code><span class="koboSpan" id="kobo.5429.1">. </span><span class="koboSpan" id="kobo.5429.2">The following table shows the list of all possible transformations of the relational operators:</span></p>
<table class="table-container" id="table004-4">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5430.1">a == b</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5431.1">b == a</span></code></p>
</td>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5432.1">a != b</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5433.1">!(a == b)</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5434.1">!(b == a)</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5435.1">a &lt;=&gt; b</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5436.1">0 &lt;=&gt; (b &lt;=&gt; a)</span></code></p>
</td>
<td class="table-cell"/>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5437.1">a &lt; b</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5438.1">(a &lt;=&gt; b) &lt; 0</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5439.1">0 &gt; (b &lt;=&gt; a)</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5440.1">a &lt;= b</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5441.1">(a &lt;=&gt; b) &lt;= 0</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5442.1">0 &gt;= (b &lt;=&gt; a)</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5443.1">a &gt; b</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5444.1">(a &lt;=&gt; b) &gt; 0</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5445.1">0 &lt; (b &lt;=&gt; a)</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5446.1">a &gt;= b</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5447.1">(a &lt;=&gt; b) &gt;= 0</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5448.1">0 &lt;= (b &lt;=&gt; a)</span></code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.5449.1">Table 9.4: The possible transformations of the relational operators</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5450.1">This greatly reduces the number of overloads you must explicitly provide for supporting comparison in different forms. </span><span class="koboSpan" id="kobo.5450.2">The three-way comparison operator can be implemented either as a member or as a non-member function. </span><span class="koboSpan" id="kobo.5450.3">In general, you should prefer the member implementation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5451.1">The non-member form should be used only when you want implicit conversion on both arguments. </span><span class="koboSpan" id="kobo.5451.2">The following shows an example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5452.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5453.1">A</span></span><span class="koboSpan" id="kobo.5454.1"> { </span><span class="hljs-type"><span class="koboSpan" id="kobo.5455.1">int</span></span><span class="koboSpan" id="kobo.5456.1"> i; };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5457.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5458.1">B</span></span><span class="koboSpan" id="kobo.5459.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5460.1">B</span></span><span class="koboSpan" id="kobo.5461.1">(A a) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5462.1">i</span></span><span class="koboSpan" id="kobo.5463.1">(a.i) { }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5464.1">int</span></span><span class="koboSpan" id="kobo.5465.1"> i;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5466.1">inline</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5467.1">auto</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.5468.1">operator</span></span><span class="koboSpan" id="kobo.5469.1">&lt;=&gt;(B </span><span class="hljs-type"><span class="koboSpan" id="kobo.5470.1">const</span></span><span class="koboSpan" id="kobo.5471.1">&amp; lhs, B </span><span class="hljs-type"><span class="koboSpan" id="kobo.5472.1">const</span></span><span class="koboSpan" id="kobo.5473.1">&amp; rhs) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5474.1">noexcept</span></span><span class="koboSpan" id="kobo.5475.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5476.1">return</span></span><span class="koboSpan" id="kobo.5477.1"> lhs.i &lt;=&gt; rhs.i;
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5478.1">assert</span></span><span class="koboSpan" id="kobo.5479.1">(A{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.5480.1">2</span></span><span class="koboSpan" id="kobo.5481.1"> } &gt; A{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.5482.1">1</span></span><span class="koboSpan" id="kobo.5483.1"> });
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5484.1">Although</span><a id="_idIndexMarker1226"/><span class="koboSpan" id="kobo.5485.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5486.1">&lt;=&gt;</span></code><span class="koboSpan" id="kobo.5487.1"> operator is defined for the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.5488.1">B</span></code><span class="koboSpan" id="kobo.5489.1">, because it is a non-member and because </span><code class="inlineCode"><span class="koboSpan" id="kobo.5490.1">A</span></code><span class="koboSpan" id="kobo.5491.1"> can be implicitly converted to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5492.1">B</span></code><span class="koboSpan" id="kobo.5493.1">, we can perform a comparison on objects of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5494.1">A</span></code><span class="koboSpan" id="kobo.5495.1"> type.</span></p>
<h2 class="heading-2" id="_idParaDest-627"><span class="koboSpan" id="kobo.5496.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.5497.1">Chapter 1</span></em><span class="koboSpan" id="kobo.5498.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5499.1">Simplifying code with class template argument deduction</span></em><span class="koboSpan" id="kobo.5500.1">, to learn how to use class templates without explicitly specifying template arguments</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5501.1">Ensuring constant correctness for a program</span></em><span class="koboSpan" id="kobo.5502.1">, to explore the benefits of constant correctness and how to achieve it</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-628"><span class="koboSpan" id="kobo.5503.1">Comparing signed and unsigned integers safely</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5504.1">The C++ language </span><a id="_idIndexMarker1227"/><span class="koboSpan" id="kobo.5505.1">features a variety of integral types: </span><code class="inlineCode"><span class="koboSpan" id="kobo.5506.1">short</span></code><span class="koboSpan" id="kobo.5507.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5508.1">int</span></code><span class="koboSpan" id="kobo.5509.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5510.1">long</span></code><span class="koboSpan" id="kobo.5511.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5512.1">long long</span></code><span class="koboSpan" id="kobo.5513.1">, as well as their unsigned counterparts </span><code class="inlineCode"><span class="koboSpan" id="kobo.5514.1">unsigned short</span></code><span class="koboSpan" id="kobo.5515.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5516.1">unsigned int</span></code><span class="koboSpan" id="kobo.5517.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5518.1">unsigned long</span></code><span class="koboSpan" id="kobo.5519.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5520.1">unsigned long long</span></code><span class="koboSpan" id="kobo.5521.1">. </span><span class="koboSpan" id="kobo.5521.2">In C++11, fixed-width</span><a id="_idIndexMarker1228"/><span class="koboSpan" id="kobo.5522.1"> integer types were introduced, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5523.1">int32_t</span></code><span class="koboSpan" id="kobo.5524.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5525.1">uint32_t</span></code><span class="koboSpan" id="kobo.5526.1">, and many similar others. </span><span class="koboSpan" id="kobo.5526.2">Apart from these, there are also the types </span><code class="inlineCode"><span class="koboSpan" id="kobo.5527.1">char</span></code><span class="koboSpan" id="kobo.5528.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5529.1">signed char</span></code><span class="koboSpan" id="kobo.5530.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5531.1">unsigned char</span></code><span class="koboSpan" id="kobo.5532.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5533.1">wchar_t</span></code><span class="koboSpan" id="kobo.5534.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5535.1">char8_t</span></code><span class="koboSpan" id="kobo.5536.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5537.1">char16_t</span></code><span class="koboSpan" id="kobo.5538.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5539.1">char32_t</span></code><span class="koboSpan" id="kobo.5540.1">, although these are not supposed to store numbers but characters. </span><span class="koboSpan" id="kobo.5540.2">Moreover, the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.5541.1">bool</span></code><span class="koboSpan" id="kobo.5542.1"> used for storing the values </span><code class="inlineCode"><span class="koboSpan" id="kobo.5543.1">true</span></code><span class="koboSpan" id="kobo.5544.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.5545.1">false</span></code><span class="koboSpan" id="kobo.5546.1"> is also an integral type. </span><span class="koboSpan" id="kobo.5546.2">The comparison of values of these types is a common operation but comparing signed and unsigned values is error-prone. </span><span class="koboSpan" id="kobo.5546.3">Without some compiler-specific switches to flag these as warnings or errors, you can perform these operations and get unexpected results. </span><span class="koboSpan" id="kobo.5546.4">For instance, the comparison </span><code class="inlineCode"><span class="koboSpan" id="kobo.5547.1">-1 &lt; 42u</span></code><span class="koboSpan" id="kobo.5548.1"> (comparing signed -1 with unsigned 42) would yield </span><code class="inlineCode"><span class="koboSpan" id="kobo.5549.1">false</span></code><span class="koboSpan" id="kobo.5550.1">. </span><span class="koboSpan" id="kobo.5550.2">The C++20 standard provides a set of </span><a id="_idIndexMarker1229"/><span class="koboSpan" id="kobo.5551.1">functions for performing a safe comparison of signed and unsigned values, which we will learn about in this recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-629"><span class="koboSpan" id="kobo.5552.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5553.1">To perform a </span><a id="_idIndexMarker1230"/><span class="koboSpan" id="kobo.5554.1">safe comparison of signed and unsigned integer values that ensures negative signed integers always compare less than unsigned values, use one of the following comparison functions from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5555.1">&lt;utility&gt;</span></code><span class="koboSpan" id="kobo.5556.1"> header:</span></p>
<table class="table-container" id="table005-3">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.5557.1">Function</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.5558.1">Corresponding comparison operator</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5559.1">std::cmp_equal</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5560.1">==</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5561.1">std::cmp_not_equal</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5562.1">!=</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5563.1">std::cmp_less</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5564.1">&lt;</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5565.1">std::cmp_less_equal</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5566.1">&lt;=</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5567.1">std::cmp_greater</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5568.1">&gt;</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5569.1">std::cmp_greater_equal</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5570.1">&gt;=</span></code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.5571.1">Table 9.5: New C++20 comparison functions and their corresponding comparison operator</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5572.1">The following snippet shows an example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.5573.1">int</span></span><span class="koboSpan" id="kobo.5574.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5575.1">-1</span></span><span class="koboSpan" id="kobo.5576.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.5577.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5578.1">int</span></span><span class="koboSpan" id="kobo.5579.1"> b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5580.1">42</span></span><span class="koboSpan" id="kobo.5581.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5582.1">if</span></span><span class="koboSpan" id="kobo.5583.1"> (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5584.1">cmp_less</span></span><span class="koboSpan" id="kobo.5585.1">(a, b)) </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5586.1">// a is less than b so this returns true</span></span><span class="koboSpan" id="kobo.5587.1">
{
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5588.1">"-1 &lt; 42\n"</span></span><span class="koboSpan" id="kobo.5589.1">;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5590.1">else</span></span><span class="koboSpan" id="kobo.5591.1">
{
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5592.1">"-1 &gt;= 42\n"</span></span><span class="koboSpan" id="kobo.5593.1">;
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-630"><span class="koboSpan" id="kobo.5594.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5595.1">Comparing two signed or two unsigned values is straightforward but comparing a signed and unsigned integer is error prone. </span><span class="koboSpan" id="kobo.5595.2">When such a comparison occurs, the signed value is converted to unsigned. </span><span class="koboSpan" id="kobo.5595.3">For instance, integer -1 becomes 4294967295. </span><span class="koboSpan" id="kobo.5595.4">The reason for this is that signed numbers are stored in memory as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5596.1">The most significant bit indicates the sign: 0 for positive numbers and 1 for negative ones.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5597.1">Negative values are stored by inverting the bits of the positive number and adding 1.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5598.1">This </span><a id="_idIndexMarker1231"/><span class="koboSpan" id="kobo.5599.1">representation is known as the </span><strong class="keyWord"><span class="koboSpan" id="kobo.5600.1">two’s complement</span></strong><span class="koboSpan" id="kobo.5601.1">. </span><span class="koboSpan" id="kobo.5601.2">For instance, assuming an 8-bit signed representation, value 1 is stored as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5602.1">0000001</span></code><span class="koboSpan" id="kobo.5603.1">, but the </span><a id="_idIndexMarker1232"/><span class="koboSpan" id="kobo.5604.1">value -1 is stored as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5605.1">11111111</span></code><span class="koboSpan" id="kobo.5606.1">. </span><span class="koboSpan" id="kobo.5606.2">This is because the 7 least significant bits of the positive number are </span><code class="inlineCode"><span class="koboSpan" id="kobo.5607.1">0000001</span></code><span class="koboSpan" id="kobo.5608.1">, which inverted are </span><code class="inlineCode"><span class="koboSpan" id="kobo.5609.1">1111110</span></code><span class="koboSpan" id="kobo.5610.1">. </span><span class="koboSpan" id="kobo.5610.2">By adding 1, we get </span><code class="inlineCode"><span class="koboSpan" id="kobo.5611.1">1111111</span></code><span class="koboSpan" id="kobo.5612.1">. </span><span class="koboSpan" id="kobo.5612.2">Together with the sign bit this makes </span><code class="inlineCode"><span class="koboSpan" id="kobo.5613.1">11111111</span></code><span class="koboSpan" id="kobo.5614.1">. </span><span class="koboSpan" id="kobo.5614.2">For 32-bit signed integers, the value -1 is stored as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5615.1">11111111'11111111'11111111'11111111</span></code><span class="koboSpan" id="kobo.5616.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5617.1">On the other hand, unsigned values don’t have a sign bit. </span><span class="koboSpan" id="kobo.5617.2">The 8-bit binary value </span><code class="inlineCode"><span class="koboSpan" id="kobo.5618.1">11111111</span></code><span class="koboSpan" id="kobo.5619.1"> is decimal 255, and the 32-bit binary value </span><code class="inlineCode"><span class="koboSpan" id="kobo.5620.1">11111111'11111111'11111111'11111111</span></code><span class="koboSpan" id="kobo.5621.1"> is decimal 4294967295. </span><span class="koboSpan" id="kobo.5621.2">When we cast the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5622.1">signed</span></code><span class="koboSpan" id="kobo.5623.1"> value of -1 to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5624.1">unsigned</span></code><span class="koboSpan" id="kobo.5625.1">, it becomes 4294967295. </span><span class="koboSpan" id="kobo.5625.2">Therefore, the following snippet comparing </span><code class="inlineCode"><span class="koboSpan" id="kobo.5626.1">signed</span></code><span class="koboSpan" id="kobo.5627.1"> -1 and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5628.1">unsigned</span></code><span class="koboSpan" id="kobo.5629.1"> 42 will print </span><em class="italic"><span class="koboSpan" id="kobo.5630.1">-1 &gt;= 42</span></em><span class="koboSpan" id="kobo.5631.1"> because the actual comparison occurs between </span><code class="inlineCode"><span class="koboSpan" id="kobo.5632.1">unsigned</span></code><span class="koboSpan" id="kobo.5633.1"> 4294967295 and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5634.1">unsigned</span></code><span class="koboSpan" id="kobo.5635.1"> 42.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.5636.1">int</span></span><span class="koboSpan" id="kobo.5637.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5638.1">-1</span></span><span class="koboSpan" id="kobo.5639.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.5640.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5641.1">int</span></span><span class="koboSpan" id="kobo.5642.1"> b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5643.1">42</span></span><span class="koboSpan" id="kobo.5644.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5645.1">if</span></span><span class="koboSpan" id="kobo.5646.1">(a &lt; b)
{
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5647.1">"-1 &lt; 42\n"</span></span><span class="koboSpan" id="kobo.5648.1">;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5649.1">else</span></span><span class="koboSpan" id="kobo.5650.1">
{
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5651.1">"-1 &gt;= 42\n"</span></span><span class="koboSpan" id="kobo.5652.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5653.1">This is true for all the six equality (</span><code class="inlineCode"><span class="koboSpan" id="kobo.5654.1">==</span></code><span class="koboSpan" id="kobo.5655.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5656.1">!=</span></code><span class="koboSpan" id="kobo.5657.1">) and inequality (</span><code class="inlineCode"><span class="koboSpan" id="kobo.5658.1">&lt;</span></code><span class="koboSpan" id="kobo.5659.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5660.1">&lt;=</span></code><span class="koboSpan" id="kobo.5661.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5662.1">&gt;</span></code><span class="koboSpan" id="kobo.5663.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5664.1">&gt;=</span></code><span class="koboSpan" id="kobo.5665.1">) operators. </span><span class="koboSpan" id="kobo.5665.2">To get the correct result, we need to check whether the signed values are negative. </span><span class="koboSpan" id="kobo.5665.3">The correct condition for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5666.1">if</span></code><span class="koboSpan" id="kobo.5667.1"> statement shown previously is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5668.1">if</span></span><span class="koboSpan" id="kobo.5669.1">(a &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.5670.1">0</span></span><span class="koboSpan" id="kobo.5671.1"> || </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5672.1">static_cast</span></span><span class="koboSpan" id="kobo.5673.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5674.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5675.1">int</span></span><span class="koboSpan" id="kobo.5676.1">&gt;(a) &lt; b)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5677.1">To ease</span><a id="_idIndexMarker1233"/><span class="koboSpan" id="kobo.5678.1"> the writing of such expressions, the C++20 standard has introduced the six functions listed in </span><em class="italic"><span class="koboSpan" id="kobo.5679.1">Table 9.5</span></em><span class="koboSpan" id="kobo.5680.1"> that should be used as </span><a id="_idIndexMarker1234"/><span class="koboSpan" id="kobo.5681.1">replacements for the corresponding operator when comparing signed and unsigned integers.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5682.1">if</span></span><span class="koboSpan" id="kobo.5683.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5684.1">cmp_less</span></span><span class="koboSpan" id="kobo.5685.1">(a, b))
{
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5686.1">"-1 &lt; 42\n"</span></span><span class="koboSpan" id="kobo.5687.1">;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5688.1">else</span></span><span class="koboSpan" id="kobo.5689.1">
{
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5690.1">"-1 &gt;= 42\n"</span></span><span class="koboSpan" id="kobo.5691.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5692.1">A possible implementation for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5693.1">std::cmp_less()</span></code><span class="koboSpan" id="kobo.5694.1"> function is shown in the next snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5695.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5696.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5697.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5698.1"> T, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5699.1">class</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5700.1"> U&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5701.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5702.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5703.1">cmp_less</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5704.1">(T t, U u)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5705.1">noexcept</span></span><span class="koboSpan" id="kobo.5706.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5707.1">if</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5708.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.5709.1">(std::is_signed_v&lt;T&gt; == std::is_signed_v&lt;U&gt;)</span></span>
<span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5710.1">return</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5711.1"> t &lt; u</span></span><span class="koboSpan" id="kobo.5712.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5713.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5714.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5715.1">constexpr</span></span><span class="koboSpan" id="kobo.5716.1"> (std::is_signed_v&lt;T&gt;)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5717.1">return</span></span><span class="koboSpan" id="kobo.5718.1"> t &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.5719.1">0</span></span><span class="koboSpan" id="kobo.5720.1"> || std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5721.1">make_unsigned_t</span></span><span class="koboSpan" id="kobo.5722.1">&lt;T&gt;(t) &lt; u;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5723.1">else</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5724.1">return</span></span><span class="koboSpan" id="kobo.5725.1"> u &gt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.5726.1">0</span></span><span class="koboSpan" id="kobo.5727.1"> &amp;&amp; t &lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5728.1">make_unsigned_t</span></span><span class="koboSpan" id="kobo.5729.1">&lt;U&gt;(u);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5730.1">What this does is the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5731.1">If both arguments are signed, it uses the built-in </span><code class="inlineCode"><span class="koboSpan" id="kobo.5732.1">&lt;</span></code><span class="koboSpan" id="kobo.5733.1"> comparison operator to compare them.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5734.1">If the first argument is signed and the second is unsigned, then it checks whether the first is native (a negative value is always less than a positive one) or compares the first argument cast to unsigned with the second argument using the built-in operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.5735.1">&lt;</span></code><span class="koboSpan" id="kobo.5736.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5737.1">If the first argument is unsigned, the second can be either signed or unsigned. </span><span class="koboSpan" id="kobo.5737.2">The first argument can only be less than the second if the second is positive and the first is less than the second cast as unsigned.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5738.1">When you </span><a id="_idIndexMarker1235"/><span class="koboSpan" id="kobo.5739.1">use these functions, keep in mind that they only work for:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.5740.1">short</span></code><span class="koboSpan" id="kobo.5741.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5742.1">int</span></code><span class="koboSpan" id="kobo.5743.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5744.1">long</span></code><span class="koboSpan" id="kobo.5745.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5746.1">long long</span></code><span class="koboSpan" id="kobo.5747.1">, and their unsigned counterparts</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5748.1">Fixed-width integer types such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5749.1">int32_t</span></code><span class="koboSpan" id="kobo.5750.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5751.1">int_least32_t</span></code><span class="koboSpan" id="kobo.5752.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5753.1">int_fast32_t</span></code><span class="koboSpan" id="kobo.5754.1"> and their unsigned counterparts</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5755.1">Extended integer types (which are compiler-specific types such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5756.1">__int64</span></code><span class="koboSpan" id="kobo.5757.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.5758.1">__int128</span></code><span class="koboSpan" id="kobo.5759.1"> and their unsigned counterparts that most compilers support)</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5760.1">The next</span><a id="_idIndexMarker1236"/><span class="koboSpan" id="kobo.5761.1"> snippet provides an example for using extended types (in this case Microsoft specific) and standard fixed with integer types, respectively.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5762.1">__int64 a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5763.1">-1</span></span><span class="koboSpan" id="kobo.5764.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.5765.1">unsigned</span></span><span class="koboSpan" id="kobo.5766.1"> __int64 b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5767.1">42</span></span><span class="koboSpan" id="kobo.5768.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5769.1">if</span></span><span class="koboSpan" id="kobo.5770.1"> (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5771.1">cmp_less</span></span><span class="koboSpan" id="kobo.5772.1">(a, b))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5773.1">// OK</span></span><span class="koboSpan" id="kobo.5774.1">
{ }
</span><span class="hljs-type"><span class="koboSpan" id="kobo.5775.1">int32_t</span></span><span class="koboSpan" id="kobo.5776.1">  a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5777.1">-1</span></span><span class="koboSpan" id="kobo.5778.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.5779.1">uint32_t</span></span><span class="koboSpan" id="kobo.5780.1"> b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5781.1">42</span></span><span class="koboSpan" id="kobo.5782.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5783.1">if</span></span><span class="koboSpan" id="kobo.5784.1"> (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5785.1">cmp_less</span></span><span class="koboSpan" id="kobo.5786.1">(a, b))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5787.1">// OK</span></span><span class="koboSpan" id="kobo.5788.1">
{ }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5789.1">However, you cannot use them to compare enums, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5790.1">std::byte</span></code><span class="koboSpan" id="kobo.5791.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5792.1">char</span></code><span class="koboSpan" id="kobo.5793.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5794.1">char8_t</span></code><span class="koboSpan" id="kobo.5795.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5796.1">char16_t</span></code><span class="koboSpan" id="kobo.5797.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5798.1">char32_t</span></code><span class="koboSpan" id="kobo.5799.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5800.1">wchar_t</span></code><span class="koboSpan" id="kobo.5801.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5802.1">bool</span></code><span class="koboSpan" id="kobo.5803.1">. </span><span class="koboSpan" id="kobo.5803.2">In this case, you would get a compiler error: </span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5804.1">if</span></span><span class="koboSpan" id="kobo.5805.1"> (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5806.1">cmp_equal</span></span><span class="koboSpan" id="kobo.5807.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.5808.1">true</span></span><span class="koboSpan" id="kobo.5809.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5810.1">1</span></span><span class="koboSpan" id="kobo.5811.1">)) </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5812.1">// error</span></span><span class="koboSpan" id="kobo.5813.1">
{ }
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-631"><span class="koboSpan" id="kobo.5814.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.5815.1">Chapter 2</span></em><span class="koboSpan" id="kobo.5816.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5817.1">Understanding the various numeric types</span></em><span class="koboSpan" id="kobo.5818.1">, to learn about the available integral and floating-point types</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5819.1">Performing correct type casts</span></em><span class="koboSpan" id="kobo.5820.1">, to learn the proper way of performing type casts in C++</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.5821.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5822.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="Chapter_09.xhtml"><span class="url"><span class="koboSpan" id="kobo.5823.1">https://discord.gg/7xRaTCeEhx</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.5824.1"><img alt="" src="../Images/QR_Code2659294082093549796.png"/></span></p>
</div>
</body></html>