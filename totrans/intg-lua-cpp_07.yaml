- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with C++ Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to call C++ code from Lua and how to
    register C++ modules. You might have observed that you can create objects in C++
    and register them to Lua, but how about creating C++ objects freely in Lua? This
    is what we will set out to achieve in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn about the following topics and export C++ types to Lua in a top-down
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use the Lua registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use userdata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting C++ type to Lua
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You can access the source code for this chapter at [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter07](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter07).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous chapter showed you how to register C++ modules; you must have finished
    coding the questions. You can check out the answers in the `begin` folder, which
    can be found in this book’s GitHub repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, due to its complexity, we are adopting a top-down approach
    so that you only get a working implementation toward the end of this chapter.
    You can always check the `end` folder in this book’s GitHub repository if you
    prefer to see the complete code from the beginning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Lua registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Lua registry** is a global table that can be accessed by all C/C++ code.
    It is one of the places that C++ code can keep state across different function
    calls. You cannot access this table in Lua code unless you use the Lua *debug*
    library. However, you should not use the debug library in production code; so,
    the registry is for C/C++ code only.
  prefs: []
  type: TYPE_NORMAL
- en: The registry versus upvalues
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about Lua *upvalues*. An *upvalue* keeps
    a state for a specific Lua C function across calls. The *registry*, on the other
    hand, can be accessed by all Lua C functions.
  prefs: []
  type: TYPE_NORMAL
- en: To export C++ types to Lua, we will use Lua userdata to represent the type and
    the registry so that we have a metatable for functions for the type. We will learn
    about the registry first, then the userdata, and finally put everything together
    to export C++ types to Lua.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add support for the registry in our Lua executor so that we know how to
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting the registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the registry is a table, we must get a value with a key and set a value
    with a key. We can use `LuaValue` to represent different types of Lua values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `LuaExecutor.h`, add the following function declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`getRegistry` will return the value from the registry for `key`. `setRegistry`
    will set `value` with `key` to the registry.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s implement them and learn which Lua library functions can be used.
    In `LuaExecutor.cc`, implement `getRegistry`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks simple, right? It reuses two pieces of knowledge we have come across
    from the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: We use `lua_gettable` to get a value from a table, where the top of the stack
    is the key and the table is located in the position in the stack specified by
    the function parameter. We learned about this in *Chapter 5*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to upvalues, the registry is a special use case regarding the Lua stack,
    so it also has a pseudo-index called `LUA_REGISTRYINDEX`. We first encountered
    this pseudo-index in *Chapter 6*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By combining these two points, we get an even simpler implementation compared
    to getting a value for a normal table. This is because we do not need to push
    the table onto the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will implement `setRegistry`. In `LuaExecutor.cc`, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This only needs to call one Lua library function: `lua_settable`. `value` is
    located on top of the stack and `key` is located second to the top. This simplicity
    is due to the great design of the Lua API regarding the pseudo-index.'
  prefs: []
  type: TYPE_NORMAL
- en: With our Lua executor extended, let’s test it to see how the registry works.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `main.cpp`, replace the test code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The test code is doing the following, separated by newlines:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates `LuaExecutor` and a listener, as usual
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the registry with a key-value pair using some strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the key to another value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prints out the key, the initial value, and the current value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have done everything correctly, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous chapter, we used an upvalue to store a light userdata. Now,
    let’s test light userdata with the registry. Replace the registry operations with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used light userdata as the key and a string as a value explaining
    what the key is. You should see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Your key address will differ in each run.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the registry and reviewed light userdata, let’s learn
    about Lua userdata.
  prefs: []
  type: TYPE_NORMAL
- en: How to use userdata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From this section onwards, we will transform the `Destinations` class from the
    previous chapter and register it to Lua as a type so that Lua code can create
    objects from it. Before we dive into the details, let’s make some high-level changes
    to show what we want at the project level.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the C++ type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we passed a name to the constructor for the `Destinations`
    class because we created its instances in C++ and needed to set a name to Lua
    for each instance.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will export the C++ type to Lua. Lua will create the object
    and assign it a name. All changes will be in the `Destinations` class. The mechanism
    we implemented in the Lua executor to register C++ modules is flexible enough
    to support the registration of C++ types as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reflect this change and difference, we will change the constructor and how
    the module name is provided. In `Destinations.h`, change the constructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, delete the following private member variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will register a type instead of an instance. We can use a static variable
    for the Lua table name. You can change the constructor in `Destinations.cc` accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s reimplement how to provide the Lua type/table name. In `Destinations.cc`,
    change `luaName` so that it uses a static variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Add a string constant called `NAME` with a value of `Destinations` at the beginning
    of the anonymous namespace and return it in `luaName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, change the test code in `main.cpp`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Compared to the code at the end of *Chapter 6*, the only change here is that
    we removed the parameter to the constructor for the `Destinations` class.
  prefs: []
  type: TYPE_NORMAL
- en: This is what we want on the C++ side. Make sure it compiles. From now on, we
    will focus on re-wrapping the `Destinations` class and making `script.lua` create
    objects from it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s learn about userdata.
  prefs: []
  type: TYPE_NORMAL
- en: What is userdata?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we exported an instance of the class as a table and
    the class member functions as table functions. To export a type directly, we will
    create a userdata instead of a table.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 2*, we learned that userdata is one of the basic types in Lua, but
    we did not dive into the details. In the previous chapter, we used lightuserdata.
    Is there any difference between userdata and lightuserdata?
  prefs: []
  type: TYPE_NORMAL
- en: A userdata is an arbitrary sequence of data that’s created from C/C++ code by
    calling the Lua library and Lua treats it transparently. On the other hand, lightuserdata
    must be a C/C++ pointer.
  prefs: []
  type: TYPE_NORMAL
- en: What makes userdata more suitable to represent new types, is that, like a table,
    you can set metamethods and metatables to it. This is how you provide type functions
    and make it a useful type in Lua.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming in Lua
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 5*, we learned about object-oriented programming in Lua and the
    `__index` metatable. If this sounds unfamiliar, please revisit that chapter before
    continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at what we should put into the userdata so that we can export
    C++ types.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the userdata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create userdata, Lua provides the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This function allocates a consecutive memory block with a length of `size` bytes
    as a userdata and pushes a reference to the userdata onto the stack. You can also
    attach user values to the userdata. The count of user values is passed in `nuvalue`.
    We will not use user values, so we will pass `0`. `lua_newuserdatauv` returns
    the address of the raw memory that’s been allocated.
  prefs: []
  type: TYPE_NORMAL
- en: Since Lua is written in C, you can use `lua_newuserdatauv` to allocate a C array
    or structure. Lua will even take care of deallocating it during garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: With C++, we want the userdata to represent a class. It is not portable or convenient
    to call this Lua library function to allocate a C++ class. So, we will take matters
    into our own hands – we will create the C++ object on our own and make the userdata
    a pointer to the object.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling
  prefs: []
  type: TYPE_NORMAL
- en: Although we are integrating Lua into C++, we have chosen to decouple the C++
    side and the Lua side as much as possible and only expose the necessary interfaces.
    C++ memory management is a complex topic already. We have chosen to let C++ manage
    the C++ object creation and only use Lua userdata to keep a pointer and as a garbage
    collection signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by writing a Lua C function for object creation. In `Destinations.cc`,
    at the end of the anonymous namespace, add a function called `luaNew`. Add it
    to the `REGS` vector as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`luaNew` will be responsible for creating `Destinations` instances. This is
    a three-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create an instance of the class in the heap with `new` and store its
    pointer in `obj`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call `lua_newuserdatauv` to create a userdata to hold the pointer in
    `obj`. `userdata` will have a size of `sizeof(obj)`, which is the size of a C++
    object pointer. Because `lua_newuserdatauv` returns the pointer to the raw memory
    and we have made this memory hold a pointer to the `Destinations` instance, we
    need to save the address of the allocated memory as a pointer to a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we make `*userdata` point to `obj`. Since `userdata` is already on
    top of the stack, we can return `1` to return the allocated userdata to Lua.
  prefs: []
  type: TYPE_NORMAL
- en: When Lua code creates a `Destinations` instance via `luaNew`, the Lua side will
    get a userdata.
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to a pointer
  prefs: []
  type: TYPE_NORMAL
- en: C++ allows you to create a pointer to a pointer. In such a case, one pointer
    holds the address of the other pointer. This is not frequently used in pure C++
    code but can be useful for interacting with C APIs. The Lua library is a C library.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s prepare `script.lua` so that it can use the C++ type.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Lua script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Replace the content of `script.lua`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This first part of the script is similar to the script we used for the previous
    chapter, except that we changed to `Destinations.new()` with the new table name
    and we switched to use the object calling convention with colons. The second part
    of the script is a repetition of the first part with different city names. This
    is to demonstrate that we can create many `Destinations` instances in Lua.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the project at this point, you will see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For now, this is expected. Because we returned a userdata instead of a table
    to Lua, so far, it is just a raw piece of memory that’s transparent to Lua. Lua
    does not know how to call a method on a piece of raw memory. As explained earlier,
    we need to set a metatable to the userdata for this to work. We will do this next
    to put everything together.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting C++ types to Lua
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we returned the pointer to the class instance to Lua
    as a userdata. In this section, we will export member functions for the userdata.
    To do this, we need to set the metatable for the userdata.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a metatable for the userdata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 5*, we learned that each table can have a metatable. Similarly,
    each userdata can also have a metatable. In *Chapter 2*, we learned that in Lua
    code, the metatable needs to be set during object creation.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we need to set the metatable during object creation in C++ code. Instead
    of creating a new metatable for each object, we can create a single metatable
    and store it in the registry. Then, each object only needs to reference this single
    metatable. This will increase efficiency and reduce memory footprint. The Lua
    library even provides helper functions for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s see the code; an explanation will follow. Replace the content
    for `luaNew`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the code here is separated by newlines. In this case, we have
    only inserted the second section. The rest of the code is kept as-is. Additionally,
    we declared a new constant called `METATABLE_NAME`. You can put this after the
    `NAME` constant. The second code section does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it gets the metatable containing the `METATABLE_NAME` key from the registry.
    The `luaL_getmetatable` library function is used for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it’s not found, the metatable is created. We will expand on this detail later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the code section sets the metatable to the userdata with `lua_setmetatable`.
    This library function expects the metatable to be on top of the stack. In our
    case, the position of the userdata in the stack is specified via the `1` parameter.
    `lua_setmetatable` will pop the metatable from the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To understand this better, see the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Setting the metatable](img/B20927_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Setting the metatable
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows how the stack’s state changes when the metatable
    is already in the registry.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at the case when the metatable is not in the registry.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a metatable for the userdata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our implementation, the metatable is created when a class instance is created
    from Lua for the first time. Specifically, the code to create the metatable is
    as follows; this was copied from the previous code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When we need to create the metatable, the stack’s state changes, as shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Creating the metatable](img/B20927_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Creating the metatable
  prefs: []
  type: TYPE_NORMAL
- en: Eight steps are involved in this process. Steps 4 to 7 deal with creating the
    new metatable.
  prefs: []
  type: TYPE_NORMAL
- en: Creates a userdata with `lua_newuserdatauv` that holds a pointer to the class
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tries to get a metatable from the registry with `luaL_getmetatable`. The metatable
    does not exist yet, so we will get a nil value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pops the nil value from the stack with `lua_pop`. Because it is not useful and
    is on top of the userdata in the stack, we need to return the userdata as the
    top of the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates an empty metatable in the registry with `luaL_newmetatable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pushes a copy of the reference to the metatable onto the stack with `lua_pushvalue`.
    Now, we have two references to the same metatable; we will use these in the next
    step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets the `__index` field of the metatable as itself with `lua_setfield`. This
    ensures that we do not need to create another table for the `__index` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets the type functions in `REGS` to the metatable with `luaL_setfuncs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets the metatable to the userdata with `lua_setmetatable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, when the Lua code calls a method on the userdata object, it will
    dispatch to the proper Lua C function wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: How can we get the object in C++ in the Lua C wrapper function?
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we used upvalue. Although this can still work, it is
    no longer suitable here. Let’s make object retrieval in C++ work again.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the object in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In `script.lua`, we have changed the Lua code so that it uses the object calling
    convention with colons. This means that the object will be passed to the Lua C
    functions as the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the object reference, rewrite the `getObj` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This function is called from Lua C wrapper functions to get the object reference.
    This was first implemented in the previous chapter using an upvalue.
  prefs: []
  type: TYPE_NORMAL
- en: First, using the Lua `luaL_checkudata` library function, we check that the first
    argument is a userdata with a metatable in the `METATABLE_NAME` registry. This
    is a security measure to ensure that the Lua code does not pass an object of another
    type. The check on the metatable’s name works because only C/C++ code can access
    the registry.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we return the first argument as a userdata cast to `Destinations **` and
    dereferenced to get the object pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are now passing the object from Lua in the calls, we need to modify
    our wrapper functions slightly.
  prefs: []
  type: TYPE_NORMAL
- en: Making wrappers work again
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `luaWish` and `luaWent`, we were expecting a list of cities. Now, we need
    to exclude the first argument. There is only one character to change. Rewrite
    `luaWish`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We only changed `i = 1` to `i = 2` for the `for` loop. You can do the same for
    `luaWent`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have exported the `Destinations` C++ type to Lua, let’s test it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have adopted a top-down approach in this chapter, all the test code
    is complete. Now, we only need to run the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve been following along, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines are from the first object that was created in `script.lua`.
    The last two lines are from the second object that was created.
  prefs: []
  type: TYPE_NORMAL
- en: If you have made any errors in the code, you will see some error output here.
    Go back and see what you have missed. In this chapter, the code is a continuation
    of the previous chapter, but the stack’s state is quite complex.
  prefs: []
  type: TYPE_NORMAL
- en: Should we say, “Congratulations”? Wait a moment; have you discovered something
    we missed in the exported type?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s print something in the constructor and the destructor to trace the object’s
    life cycle. Rewrite the constructor and the destructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The constructor and the destructor simply output the object pointer value in
    hex format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the project again and see what you get. You should see something similar
    to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Three instances are created, but only one is destroyed! The one that gets destroyed
    is the one that was created in `main.cpp` and was serving as the prototype for
    the `Destinations` type. This means that we are leaking objects in Lua!
  prefs: []
  type: TYPE_NORMAL
- en: We need to fix this!
  prefs: []
  type: TYPE_NORMAL
- en: Providing a finalizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Are you wondering why there is a memory leak?
  prefs: []
  type: TYPE_NORMAL
- en: This is because Lua uses garbage collection. We allocate a userdata and use
    it as a pointer. It is this pointer that gets garbage collected when the userdata
    is out of scope in Lua. The C++ object itself is not deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Lua supports using userdata in this way perfectly fine, but you need to help
    Lua delete the object when the associated userdata is garbage collected. To help
    Lua, you can provide a `__gc` metamethod in the metatable. This is called a **finalizer**.
    It is invoked during the garbage collection process to delete your real object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s provide a finalizer named `luaDelete` for the `Destinations` type. Add
    another Lua C function above `luaNew`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Easy, right? Lua passes the userdata object to the finalizer during garbage
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s register it. In `luaNew`, add two more lines, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This sets the `__gc` metamethod for the metatable to our `luaDelete` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interactions between Lua and C++ can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Object creation and destruction](img/B20927_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Object creation and destruction
  prefs: []
  type: TYPE_NORMAL
- en: When Lua code creates an object of the `Destinations` class, it triggers a call
    to `luaNew`, which creates the C++ object and returns its pointer as a userdata.
    When Lua is done with the object, after a while, garbage collection is triggered
    and the `luaDelete` C++ finalizer is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the project again. You should see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have created three instances and destroyed three instances.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to export C++ types to Lua so that Lua code
    can create C++ objects. We also learned about the registry and the userdata type.
    Last but not least, we implemented a finalizer for garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: The work in this chapter is based on registering C++ modules from the previous
    chapter. You can choose to export a C++ class or C++ class instances. It is a
    matter of design choice and your project’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to implement a template class to help
    export C++ types to Lua.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `main.cpp`, we created an instance of `Destinations` and registered it to
    Lua. In Lua code, this instance is used to create more instances. This is fine,
    considering that Lua uses prototype-based object-oriented programming as well.
    If you want to make your C++ code more like C++’s way of doing things, you can
    create a factory class for `Destinations` and register the factory to Lua. Do
    this and make the factory only export the `luaNew` function. You shouldn’t need
    to change `script.lua` or the Lua C wrapper function implementations.
  prefs: []
  type: TYPE_NORMAL
