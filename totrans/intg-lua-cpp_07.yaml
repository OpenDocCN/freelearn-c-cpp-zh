- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Working with C++ Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与C++类型一起工作
- en: In the previous chapter, we learned how to call C++ code from Lua and how to
    register C++ modules. You might have observed that you can create objects in C++
    and register them to Lua, but how about creating C++ objects freely in Lua? This
    is what we will set out to achieve in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在Lua中调用C++代码以及如何注册C++模块。你可能已经注意到，你可以在C++中创建对象并将它们注册到Lua中，但如何在Lua中自由创建C++对象呢？这正是本章我们将要实现的目标。
- en: 'We will learn about the following topics and export C++ types to Lua in a top-down
    approach:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习以下主题，并采用自顶向下的方法将C++类型导出到Lua：
- en: How to use the Lua registry
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Lua注册表
- en: How to use userdata
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用userdata
- en: Exporting C++ type to Lua
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将C++类型导出到Lua
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the technical requirements for this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: You can access the source code for this chapter at [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter07](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter07).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以访问本章的源代码，请访问[https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter07](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter07)。
- en: The previous chapter showed you how to register C++ modules; you must have finished
    coding the questions. You can check out the answers in the `begin` folder, which
    can be found in this book’s GitHub repository.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一章向您展示了如何注册C++模块；您必须已经完成了编码问题。您可以在本书GitHub仓库中的`begin`文件夹中查看答案。
- en: In this chapter, due to its complexity, we are adopting a top-down approach
    so that you only get a working implementation toward the end of this chapter.
    You can always check the `end` folder in this book’s GitHub repository if you
    prefer to see the complete code from the beginning.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于本章内容复杂，我们采用自顶向下的方法，以便你能在本章末尾获得一个可工作的实现。如果你更喜欢从开始就看到完整的代码，可以查看本书GitHub仓库中的`end`文件夹。
- en: How to use the Lua registry
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用Lua注册表
- en: The **Lua registry** is a global table that can be accessed by all C/C++ code.
    It is one of the places that C++ code can keep state across different function
    calls. You cannot access this table in Lua code unless you use the Lua *debug*
    library. However, you should not use the debug library in production code; so,
    the registry is for C/C++ code only.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lua注册表**是一个全局表，可以被所有C/C++代码访问。这是C++代码可以在不同函数调用之间保持状态的地方之一。除非你使用Lua *debug*库，否则你无法在Lua代码中访问这个表。然而，你不应该在生产代码中使用debug库；因此，注册表仅适用于C/C++代码。'
- en: The registry versus upvalues
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表与upvalues的比较
- en: In the previous chapter, we learned about Lua *upvalues*. An *upvalue* keeps
    a state for a specific Lua C function across calls. The *registry*, on the other
    hand, can be accessed by all Lua C functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了Lua *upvalues*。一个*upvalue*在调用之间保持特定Lua C函数的状态。另一方面，*注册表*可以被所有Lua
    C函数访问。
- en: To export C++ types to Lua, we will use Lua userdata to represent the type and
    the registry so that we have a metatable for functions for the type. We will learn
    about the registry first, then the userdata, and finally put everything together
    to export C++ types to Lua.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要将C++类型导出到Lua，我们将使用Lua userdata来表示类型和注册表，以便我们为类型提供函数的元表。我们首先学习注册表，然后是userdata，最后将所有内容组合起来以将C++类型导出到Lua。
- en: Let’s add support for the registry in our Lua executor so that we know how to
    use it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Lua执行器中添加对注册表的支持，以便我们知道如何使用它。
- en: Supporting the registry
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持注册表
- en: Since the registry is a table, we must get a value with a key and set a value
    with a key. We can use `LuaValue` to represent different types of Lua values.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于注册表是一个表，我们必须使用键来获取值，并使用键来设置值。我们可以使用`LuaValue`来表示不同类型的Lua值。
- en: 'In `LuaExecutor.h`, add the following function declarations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LuaExecutor.h`中添加以下函数声明：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`getRegistry` will return the value from the registry for `key`. `setRegistry`
    will set `value` with `key` to the registry.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRegistry`将返回注册表中`key`对应的值。`setRegistry`将使用`key`将`value`设置到注册表中。'
- en: 'Now, let’s implement them and learn which Lua library functions can be used.
    In `LuaExecutor.cc`, implement `getRegistry`, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现它们并学习哪些Lua库函数可以使用。在`LuaExecutor.cc`中实现`getRegistry`，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This looks simple, right? It reuses two pieces of knowledge we have come across
    from the previous chapters:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单，对吧？它重用了我们从上一章中学到的两个知识点：
- en: We use `lua_gettable` to get a value from a table, where the top of the stack
    is the key and the table is located in the position in the stack specified by
    the function parameter. We learned about this in *Chapter 5*.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`lua_gettable`从一个表中获取值，其中栈顶是密钥，表位于由函数参数指定的栈中的位置。我们在*第5章*中学习了这一点。
- en: Similar to upvalues, the registry is a special use case regarding the Lua stack,
    so it also has a pseudo-index called `LUA_REGISTRYINDEX`. We first encountered
    this pseudo-index in *Chapter 6*.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与upvalues类似，注册是关于Lua栈的特殊用例，因此它也有一个名为`LUA_REGISTRYINDEX`的伪索引。我们第一次遇到这个伪索引是在*第6章*。
- en: By combining these two points, we get an even simpler implementation compared
    to getting a value for a normal table. This is because we do not need to push
    the table onto the stack.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过结合这两点，我们得到了一个比获取普通表值更简单的实现。这是因为我们不需要将表推入栈中。
- en: 'Next, we will implement `setRegistry`. In `LuaExecutor.cc`, add the following
    code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`setRegistry`。在`LuaExecutor.cc`中添加以下代码：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This only needs to call one Lua library function: `lua_settable`. `value` is
    located on top of the stack and `key` is located second to the top. This simplicity
    is due to the great design of the Lua API regarding the pseudo-index.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这只需要调用一个Lua库函数：`lua_settable`。`value`位于栈顶，`key`位于次顶。这种简单性归功于Lua API在伪索引方面的优秀设计。
- en: With our Lua executor extended, let’s test it to see how the registry works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展我们的Lua执行器，让我们测试它以查看注册是如何工作的。
- en: Testing the registry
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试注册
- en: 'In `main.cpp`, replace the test code, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.cpp`中替换测试代码，如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The test code is doing the following, separated by newlines:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码执行以下操作，通过换行符分隔：
- en: Creates `LuaExecutor` and a listener, as usual
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`LuaExecutor`和监听器，就像往常一样
- en: Sets the registry with a key-value pair using some strings
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一些字符串设置一个键值对到注册中
- en: Sets the key to another value
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将密钥设置为另一个值
- en: Prints out the key, the initial value, and the current value
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印出密钥、初始值和当前值
- en: 'If you have done everything correctly, you should see the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一切操作正确，您应该看到以下输出：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the previous chapter, we used an upvalue to store a light userdata. Now,
    let’s test light userdata with the registry. Replace the registry operations with
    the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用一个upvalue来存储light userdata。现在，让我们通过注册来测试light userdata。用以下操作替换注册操作：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we used light userdata as the key and a string as a value explaining
    what the key is. You should see an output similar to the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用light userdata作为密钥，并使用一个字符串作为值来解释密钥的含义。您应该看到以下类似的输出：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Your key address will differ in each run.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您的密钥地址在每次运行中都会不同。
- en: Now that we’ve covered the registry and reviewed light userdata, let’s learn
    about Lua userdata.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了注册并回顾了light userdata，让我们来了解Lua userdata。
- en: How to use userdata
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用userdata
- en: From this section onwards, we will transform the `Destinations` class from the
    previous chapter and register it to Lua as a type so that Lua code can create
    objects from it. Before we dive into the details, let’s make some high-level changes
    to show what we want at the project level.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节开始，我们将把上一章的`Destinations`类转换并注册到Lua中作为一个类型，这样Lua代码就可以从中创建对象。在我们深入细节之前，让我们做一些高级的修改来展示我们在项目层面想要实现的内容。
- en: Preparing the C++ type
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备C++类型
- en: In the previous chapter, we passed a name to the constructor for the `Destinations`
    class because we created its instances in C++ and needed to set a name to Lua
    for each instance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们向`Destinations`类的构造函数传递一个名称，因为我们是在C++中创建其实例，并且需要为每个实例设置一个Lua名称。
- en: In this chapter, we will export the C++ type to Lua. Lua will create the object
    and assign it a name. All changes will be in the `Destinations` class. The mechanism
    we implemented in the Lua executor to register C++ modules is flexible enough
    to support the registration of C++ types as well.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将导出C++类型到Lua。Lua将创建对象并给它一个名字。所有更改都将发生在`Destinations`类中。我们在Lua执行器中实现的注册C++模块的机制足够灵活，可以支持C++类型的注册。
- en: 'To reflect this change and difference, we will change the constructor and how
    the module name is provided. In `Destinations.h`, change the constructor, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反映这个变化和差异，我们将修改构造函数以及模块名称的提供方式。在`Destinations.h`中修改构造函数，如下所示：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, delete the following private member variable:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，删除以下私有成员变量：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will register a type instead of an instance. We can use a static variable
    for the Lua table name. You can change the constructor in `Destinations.cc` accordingly:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将注册一个类型而不是一个实例。我们可以使用静态变量作为 Lua 表的名称。你可以在 `Destinations.cc` 中相应地更改构造函数：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let’s reimplement how to provide the Lua type/table name. In `Destinations.cc`,
    change `luaName` so that it uses a static variable:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新实现如何提供 Lua 类型/表名称。在 `Destinations.cc` 中更改 `luaName`，使其使用静态变量：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Add a string constant called `NAME` with a value of `Destinations` at the beginning
    of the anonymous namespace and return it in `luaName`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在匿名命名空间的开头添加一个名为 `NAME` 的字符串常量，其值为 `Destinations`，并在 `luaName` 中返回它。
- en: 'Finally, change the test code in `main.cpp`, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更改 `main.cpp` 中的测试代码，如下所示：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Compared to the code at the end of *Chapter 6*, the only change here is that
    we removed the parameter to the constructor for the `Destinations` class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *第六章* 末尾的代码相比，这里唯一的改变是我们移除了 `Destinations` 类构造函数的参数。
- en: This is what we want on the C++ side. Make sure it compiles. From now on, we
    will focus on re-wrapping the `Destinations` class and making `script.lua` create
    objects from it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们希望在 C++ 端实现的内容。确保它能编译。从现在开始，我们将专注于重新封装 `Destinations` 类，并让 `script.lua`
    从它创建对象。
- en: Next, let’s learn about userdata.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解 userdata。
- en: What is userdata?
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 userdata？
- en: In the previous chapter, we exported an instance of the class as a table and
    the class member functions as table functions. To export a type directly, we will
    create a userdata instead of a table.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们将类的实例作为表导出，并将类成员函数作为表函数。要直接导出类型，我们将创建 userdata 而不是表。
- en: In *Chapter 2*, we learned that userdata is one of the basic types in Lua, but
    we did not dive into the details. In the previous chapter, we used lightuserdata.
    Is there any difference between userdata and lightuserdata?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第二章* 中，我们了解到 userdata 是 Lua 中的基本类型之一，但我们没有深入探讨其细节。在前一章中，我们使用了 lightuserdata。userdata
    和 lightuserdata 之间有什么区别？
- en: A userdata is an arbitrary sequence of data that’s created from C/C++ code by
    calling the Lua library and Lua treats it transparently. On the other hand, lightuserdata
    must be a C/C++ pointer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: userdata 是由 Lua 库通过调用 C/C++ 代码创建的任意数据序列，Lua 对其进行透明处理。另一方面，lightuserdata 必须是
    C/C++ 指针。
- en: What makes userdata more suitable to represent new types, is that, like a table,
    you can set metamethods and metatables to it. This is how you provide type functions
    and make it a useful type in Lua.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使 userdata 更适合表示新类型的原因之一是，像表一样，你可以为其设置元方法和元表。这就是你提供类型函数并使其在 Lua 中成为有用类型的方式。
- en: Object-oriented programming in Lua
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 中的面向对象编程
- en: In *Chapter 5*, we learned about object-oriented programming in Lua and the
    `__index` metatable. If this sounds unfamiliar, please revisit that chapter before
    continuing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第五章* 中，我们学习了 Lua 中的面向对象编程和 `__index` 元表。如果这听起来不熟悉，请在继续之前回顾那章。
- en: Now, let’s look at what we should put into the userdata so that we can export
    C++ types.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们应该将什么放入 userdata 中，以便我们可以导出 C++ 类型。
- en: Designing the userdata
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计 userdata
- en: 'To create userdata, Lua provides the following function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 userdata，Lua 提供了以下函数：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function allocates a consecutive memory block with a length of `size` bytes
    as a userdata and pushes a reference to the userdata onto the stack. You can also
    attach user values to the userdata. The count of user values is passed in `nuvalue`.
    We will not use user values, so we will pass `0`. `lua_newuserdatauv` returns
    the address of the raw memory that’s been allocated.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数分配了一个长度为 `size` 字节的连续内存块作为 userdata，并将 userdata 的引用压入堆栈。你还可以将用户值附加到 userdata
    上。用户值的数量通过 `nuvalue` 传入。我们不会使用用户值，所以我们将传入 `0`。`lua_newuserdatauv` 返回已分配的原始内存的地址。
- en: Since Lua is written in C, you can use `lua_newuserdatauv` to allocate a C array
    or structure. Lua will even take care of deallocating it during garbage collection.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Lua 是用 C 编写的，你可以使用 `lua_newuserdatauv` 来分配 C 数组或结构。Lua 甚至会在垃圾回收期间负责释放它。
- en: With C++, we want the userdata to represent a class. It is not portable or convenient
    to call this Lua library function to allocate a C++ class. So, we will take matters
    into our own hands – we will create the C++ object on our own and make the userdata
    a pointer to the object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C++，我们希望 userdata 表示一个类。调用这个 Lua 库函数来分配 C++ 类既不便携也不方便。因此，我们将自己动手——我们将自己创建
    C++ 对象，并使 userdata 成为对象的指针。
- en: Decoupling
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 解耦
- en: Although we are integrating Lua into C++, we have chosen to decouple the C++
    side and the Lua side as much as possible and only expose the necessary interfaces.
    C++ memory management is a complex topic already. We have chosen to let C++ manage
    the C++ object creation and only use Lua userdata to keep a pointer and as a garbage
    collection signal.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将 Lua 集成到 C++ 中，但我们选择尽可能地将 C++ 方面和 Lua 方面解耦，并且只公开必要的接口。C++ 内存管理已经是一个复杂的话题。我们选择让
    C++ 管理 C++ 对象的创建，并且只使用 Lua userdata 来保持指针并作为垃圾回收信号。
- en: 'Let’s start by writing a Lua C function for object creation. In `Destinations.cc`,
    at the end of the anonymous namespace, add a function called `luaNew`. Add it
    to the `REGS` vector as well:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写一个用于对象创建的 Lua C 函数开始。在 `Destinations.cc` 的匿名命名空间末尾，添加一个名为 `luaNew` 的函数。同时将其添加到
    `REGS` 向量中：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`luaNew` will be responsible for creating `Destinations` instances. This is
    a three-step process:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`luaNew` 将负责创建 `Destinations` 实例。这是一个三步过程：'
- en: First, we create an instance of the class in the heap with `new` and store its
    pointer in `obj`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `new` 在堆中创建类的实例，并将其指针存储在 `obj` 中。
- en: Then, we call `lua_newuserdatauv` to create a userdata to hold the pointer in
    `obj`. `userdata` will have a size of `sizeof(obj)`, which is the size of a C++
    object pointer. Because `lua_newuserdatauv` returns the pointer to the raw memory
    and we have made this memory hold a pointer to the `Destinations` instance, we
    need to save the address of the allocated memory as a pointer to a pointer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用 `lua_newuserdatauv` 来创建一个 userdata，用于存储 `obj` 中的指针。`userdata` 的大小将是
    `sizeof(obj)`，即 C++ 对象指针的大小。因为 `lua_newuserdatauv` 返回原始内存的指针，而我们已使此内存包含指向 `Destinations`
    实例的指针，所以我们需要将分配的内存地址保存为一个指向指针的指针。
- en: Finally, we make `*userdata` point to `obj`. Since `userdata` is already on
    top of the stack, we can return `1` to return the allocated userdata to Lua.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `*userdata` 指向 `obj`。由于 `userdata` 已经在栈顶，我们可以返回 `1` 以将分配的 userdata 返回给
    Lua。
- en: When Lua code creates a `Destinations` instance via `luaNew`, the Lua side will
    get a userdata.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Lua 代码通过 `luaNew` 创建 `Destinations` 实例时，Lua 方面将获得一个 userdata。
- en: A pointer to a pointer
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 指向指针的指针
- en: C++ allows you to create a pointer to a pointer. In such a case, one pointer
    holds the address of the other pointer. This is not frequently used in pure C++
    code but can be useful for interacting with C APIs. The Lua library is a C library.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 允许你创建一个指向指针的指针。在这种情况下，一个指针包含另一个指针的地址。这在纯 C++ 代码中不常用，但与 C APIs 交互时可能很有用。Lua
    库是一个 C 库。
- en: Next, let’s prepare `script.lua` so that it can use the C++ type.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们准备 `script.lua`，以便它可以使用 C++ 类型。
- en: Preparing the Lua script
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备 Lua 脚本
- en: 'Replace the content of `script.lua`, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 替换 `script.lua` 的内容，如下所示：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This first part of the script is similar to the script we used for the previous
    chapter, except that we changed to `Destinations.new()` with the new table name
    and we switched to use the object calling convention with colons. The second part
    of the script is a repetition of the first part with different city names. This
    is to demonstrate that we can create many `Destinations` instances in Lua.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的这个第一部分与上一章中使用的脚本类似，除了我们改为使用新的表名 `Destinations.new()`，并且我们切换到使用带有冒号的对象调用约定。脚本的第二部分是第一部分的重复，但使用了不同的城市名称。这是为了演示我们可以在
    Lua 中创建许多 `Destinations` 实例。
- en: 'If you run the project at this point, you will see the following error:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你此时运行项目，你将看到以下错误：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For now, this is expected. Because we returned a userdata instead of a table
    to Lua, so far, it is just a raw piece of memory that’s transparent to Lua. Lua
    does not know how to call a method on a piece of raw memory. As explained earlier,
    we need to set a metatable to the userdata for this to work. We will do this next
    to put everything together.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这是预期的。因为我们向 Lua 返回了 userdata 而不是 table，所以到目前为止，它只是一个对 Lua 来说透明的原始内存块。Lua
    不知道如何在原始内存块上调用方法。如前所述，我们需要为 userdata 设置一个元表才能使其工作。我们将在下一步中这样做，以便将所有内容组合在一起。
- en: Exporting C++ types to Lua
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 C++ 类型导出到 Lua
- en: In the previous section, we returned the pointer to the class instance to Lua
    as a userdata. In this section, we will export member functions for the userdata.
    To do this, we need to set the metatable for the userdata.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们将类实例的指针作为 userdata 返回给 Lua。在本节中，我们将为 userdata 导出成员函数。为此，我们需要为 userdata
    设置元表。
- en: Setting a metatable for the userdata
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 userdata 设置元表
- en: In *Chapter 5*, we learned that each table can have a metatable. Similarly,
    each userdata can also have a metatable. In *Chapter 2*, we learned that in Lua
    code, the metatable needs to be set during object creation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第五章* 中，我们了解到每个表都可以有一个元表。同样，每个 userdata 也可以有一个元表。在 *第二章* 中，我们了解到在 Lua 代码中，元表需要在对象创建时设置。
- en: Here, we need to set the metatable during object creation in C++ code. Instead
    of creating a new metatable for each object, we can create a single metatable
    and store it in the registry. Then, each object only needs to reference this single
    metatable. This will increase efficiency and reduce memory footprint. The Lua
    library even provides helper functions for this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，我们需要在 C++ 代码中设置元表，而不是为每个对象创建一个新的元表，我们可以创建一个单独的元表并将其存储在注册表中。然后，每个对象只需要引用这个单一的元表。这将提高效率并减少内存占用。Lua
    库甚至为此提供了辅助函数。
- en: 'First, let’s see the code; an explanation will follow. Replace the content
    for `luaNew`, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看代码；解释将随后进行。将 `luaNew` 的内容替换如下：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, the code here is separated by newlines. In this case, we have
    only inserted the second section. The rest of the code is kept as-is. Additionally,
    we declared a new constant called `METATABLE_NAME`. You can put this after the
    `NAME` constant. The second code section does the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里的代码通过换行符分隔。在这种情况下，我们只插入了第二部分。其余的代码保持不变。此外，我们声明了一个新的常量 `METATABLE_NAME`。您可以将它放在
    `NAME` 常量之后。第二段代码执行以下操作：
- en: First, it gets the metatable containing the `METATABLE_NAME` key from the registry.
    The `luaL_getmetatable` library function is used for this.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它从注册表中获取包含 `METATABLE_NAME` 键的元表。为此使用了 `luaL_getmetatable` 库函数。
- en: If it’s not found, the metatable is created. We will expand on this detail later.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找不到，则创建元表。我们将在稍后详细说明这一点。
- en: Finally, the code section sets the metatable to the userdata with `lua_setmetatable`.
    This library function expects the metatable to be on top of the stack. In our
    case, the position of the userdata in the stack is specified via the `1` parameter.
    `lua_setmetatable` will pop the metatable from the stack.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，代码部分使用 `lua_setmetatable` 将元表设置到 userdata 上。这个库函数期望元表位于栈顶。在我们的情况下，userdata
    在栈中的位置通过 `1` 参数指定。`lua_setmetatable` 将从栈中弹出元表。
- en: 'To understand this better, see the following figure:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，请参阅以下图：
- en: '![Figure 7.1 – Setting the metatable](img/B20927_07_01.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 设置元表](img/B20927_07_01.jpg)'
- en: Figure 7.1 – Setting the metatable
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 设置元表
- en: The preceding figure shows how the stack’s state changes when the metatable
    is already in the registry.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了当元表已经在注册表中时，栈的状态如何变化。
- en: Next, let’s look at the case when the metatable is not in the registry.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看当元表不在注册表中时的案例。
- en: Creating a metatable for the userdata
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 userdata 创建元表
- en: 'In our implementation, the metatable is created when a class instance is created
    from Lua for the first time. Specifically, the code to create the metatable is
    as follows; this was copied from the previous code listing:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，当 Lua 首次从 Lua 创建类实例时创建元表。具体来说，创建元表的代码如下；这是从之前的代码列表中复制的：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we need to create the metatable, the stack’s state changes, as shown in
    the following figure:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要创建元表时，栈的状态会发生变化，如下面的图所示：
- en: '![Figure 7.2 – Creating the metatable](img/B20927_07_02.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 创建元表](img/B20927_07_02.jpg)'
- en: Figure 7.2 – Creating the metatable
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 创建元表
- en: Eight steps are involved in this process. Steps 4 to 7 deal with creating the
    new metatable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程涉及八个步骤。步骤 4 到 7 处理创建新的元表。
- en: Creates a userdata with `lua_newuserdatauv` that holds a pointer to the class
    instance.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `lua_newuserdatauv` 创建一个 userdata，它包含对类实例的指针。
- en: Tries to get a metatable from the registry with `luaL_getmetatable`. The metatable
    does not exist yet, so we will get a nil value.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用 `luaL_getmetatable` 从注册表中获取元表。元表尚不存在，因此我们将得到一个 nil 值。
- en: Pops the nil value from the stack with `lua_pop`. Because it is not useful and
    is on top of the userdata in the stack, we need to return the userdata as the
    top of the stack.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `lua_pop` 从栈中弹出 nil 值。因为它没有用，并且位于 userdata 之上，我们需要将 userdata 作为栈顶返回。
- en: Creates an empty metatable in the registry with `luaL_newmetatable`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `luaL_newmetatable` 在注册表中创建一个空的元表。
- en: Pushes a copy of the reference to the metatable onto the stack with `lua_pushvalue`.
    Now, we have two references to the same metatable; we will use these in the next
    step.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`lua_pushvalue`将元表的引用副本推送到堆栈上。现在，我们有指向同一元表的两个引用；我们将在下一步中使用这些引用。
- en: Sets the `__index` field of the metatable as itself with `lua_setfield`. This
    ensures that we do not need to create another table for the `__index` field.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`lua_setfield`将元表的`__index`字段设置为自身。这确保了我们不需要为`__index`字段创建另一个表。
- en: Sets the type functions in `REGS` to the metatable with `luaL_setfuncs`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`luaL_setfuncs`将`REGS`中的类型函数设置为元表。
- en: Sets the metatable to the userdata with `lua_setmetatable`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`lua_setmetatable`将元表设置为userdata。
- en: With this, when the Lua code calls a method on the userdata object, it will
    dispatch to the proper Lua C function wrapper.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，当Lua代码在userdata对象上调用方法时，它将调度到适当的Lua C函数包装器。
- en: How can we get the object in C++ in the Lua C wrapper function?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在Lua C包装函数中获取对象？
- en: In the previous chapter, we used upvalue. Although this can still work, it is
    no longer suitable here. Let’s make object retrieval in C++ work again.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了upvalue。尽管这仍然可以工作，但在这里已经不再适用了。让我们让C++中的对象检索再次工作。
- en: Getting the object in C++
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C++中获取对象
- en: In `script.lua`, we have changed the Lua code so that it uses the object calling
    convention with colons. This means that the object will be passed to the Lua C
    functions as the first argument.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`script.lua`中，我们已更改Lua代码，使其使用带有冒号的对象调用约定。这意味着对象将被作为第一个参数传递给Lua C函数。
- en: 'To get the object reference, rewrite the `getObj` function, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取对象引用，重写`getObj`函数，如下所示：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function is called from Lua C wrapper functions to get the object reference.
    This was first implemented in the previous chapter using an upvalue.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从Lua C包装函数中调用以获取对象引用。这最初是在上一章中使用upvalue实现的。
- en: First, using the Lua `luaL_checkudata` library function, we check that the first
    argument is a userdata with a metatable in the `METATABLE_NAME` registry. This
    is a security measure to ensure that the Lua code does not pass an object of another
    type. The check on the metatable’s name works because only C/C++ code can access
    the registry.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用Lua的`luaL_checkudata`库函数，我们检查第一个参数是否是具有`METATABLE_NAME`注册表中元表的userdata。这是一个安全措施，以确保Lua代码不会传递其他类型的对象。对元表名称的检查之所以有效，是因为只有C/C++代码可以访问注册表。
- en: Then, we return the first argument as a userdata cast to `Destinations **` and
    dereferenced to get the object pointer.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将第一个参数作为`Destinations **`的用户数据类型转换并解引用以获取对象指针。
- en: Since we are now passing the object from Lua in the calls, we need to modify
    our wrapper functions slightly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在在调用中从Lua传递对象，我们需要稍微修改我们的包装函数。
- en: Making wrappers work again
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让包装器再次工作
- en: 'In `luaWish` and `luaWent`, we were expecting a list of cities. Now, we need
    to exclude the first argument. There is only one character to change. Rewrite
    `luaWish`, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`luaWish`和`luaWent`中，我们期望得到一个城市列表。现在，我们需要排除第一个参数。只有一个字符需要更改。重写`luaWish`，如下所示：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We only changed `i = 1` to `i = 2` for the `for` loop. You can do the same for
    `luaWent`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只将`for`循环中的`i = 1`更改为`i = 2`。你也可以对`luaWent`做同样的操作。
- en: Now that we have exported the `Destinations` C++ type to Lua, let’s test it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将`Destinations` C++类型导出到Lua中，让我们测试一下。
- en: Testing it out
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试一下
- en: Since we have adopted a top-down approach in this chapter, all the test code
    is complete. Now, we only need to run the project.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本章中采用了自顶向下的方法，所有测试代码都已完成。现在，我们只需要运行项目。
- en: 'If you’ve been following along, you should see the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在跟随，你应该看到以下输出：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first two lines are from the first object that was created in `script.lua`.
    The last two lines are from the second object that was created.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行来自`script.lua`中创建的第一个对象。最后两行来自创建的第二个对象。
- en: If you have made any errors in the code, you will see some error output here.
    Go back and see what you have missed. In this chapter, the code is a continuation
    of the previous chapter, but the stack’s state is quite complex.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你代码中有任何错误，你将在这里看到一些错误输出。回去看看你遗漏了什么。在本章中，代码是上一章的延续，但堆栈的状态相当复杂。
- en: Should we say, “Congratulations”? Wait a moment; have you discovered something
    we missed in the exported type?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该说“恭喜”吗？等等；你发现我们遗漏在导出类型中的东西了吗？
- en: 'Let’s print something in the constructor and the destructor to trace the object’s
    life cycle. Rewrite the constructor and the destructor, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在构造函数和析构函数中打印一些内容来追踪对象的生命周期。重写构造函数和析构函数，如下所示：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The constructor and the destructor simply output the object pointer value in
    hex format.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和析构函数只是简单地以十六进制格式输出对象指针值。
- en: 'Run the project again and see what you get. You should see something similar
    to the following output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目并查看结果。你应该会看到以下类似的输出：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Three instances are created, but only one is destroyed! The one that gets destroyed
    is the one that was created in `main.cpp` and was serving as the prototype for
    the `Destinations` type. This means that we are leaking objects in Lua!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了三个实例，但只有一个被销毁！被销毁的是在 `main.cpp` 中创建的，作为 `Destinations` 类原型的那个。这意味着我们在 Lua
    中泄漏了对象！
- en: We need to fix this!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修复这个问题！
- en: Providing a finalizer
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供一个终结器
- en: Are you wondering why there is a memory leak?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道为什么会有内存泄漏吗？
- en: This is because Lua uses garbage collection. We allocate a userdata and use
    it as a pointer. It is this pointer that gets garbage collected when the userdata
    is out of scope in Lua. The C++ object itself is not deleted.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Lua 使用垃圾回收。我们分配一个 userdata 并将其用作指针。当 userdata 在 Lua 中超出作用域时，这个指针会被垃圾回收。C++
    对象本身不会被删除。
- en: Lua supports using userdata in this way perfectly fine, but you need to help
    Lua delete the object when the associated userdata is garbage collected. To help
    Lua, you can provide a `__gc` metamethod in the metatable. This is called a **finalizer**.
    It is invoked during the garbage collection process to delete your real object.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 完美支持以这种方式使用 userdata，但你需要在关联的 userdata 被垃圾回收时帮助 Lua 删除对象。为了帮助 Lua，你可以在元表中提供一个
    `__gc` 元方法。这被称为**终结器**。它在垃圾回收过程中被调用以删除你的实际对象。
- en: 'Let’s provide a finalizer named `luaDelete` for the `Destinations` type. Add
    another Lua C function above `luaNew`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `Destinations` 类型提供一个名为 `luaDelete` 的终结器。在 `luaNew` 之上添加另一个 Lua C 函数：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Easy, right? Lua passes the userdata object to the finalizer during garbage
    collection.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？Lua 在垃圾回收期间将 userdata 对象传递给终结器。
- en: 'Now, let’s register it. In `luaNew`, add two more lines, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进行注册。在 `luaNew` 中添加两行，如下所示：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This sets the `__gc` metamethod for the metatable to our `luaDelete` function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将元表中的 `__gc` 元方法设置为我们的 `luaDelete` 函数。
- en: 'The interactions between Lua and C++ can be seen in the following diagram:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 和 C++ 之间的交互可以在以下图中看到：
- en: '![Figure 7.3 – Object creation and destruction](img/B20927_07_03.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 对象创建和销毁](img/B20927_07_03.jpg)'
- en: Figure 7.3 – Object creation and destruction
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 对象创建和销毁
- en: When Lua code creates an object of the `Destinations` class, it triggers a call
    to `luaNew`, which creates the C++ object and returns its pointer as a userdata.
    When Lua is done with the object, after a while, garbage collection is triggered
    and the `luaDelete` C++ finalizer is called.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Lua 代码创建 `Destinations` 类的对象时，它会触发对 `luaNew` 的调用，该调用创建 C++ 对象并返回其指针作为 userdata。当
    Lua 完成对该对象的处理后，一段时间后，会触发垃圾回收并调用 `luaDelete` C++ 终结器。
- en: 'Let’s run the project again. You should see an output similar to the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行项目。你应该会看到以下类似的输出：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With that, we have created three instances and destroyed three instances.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们已经创建了三个实例并销毁了三个实例。
- en: Congratulations!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to export C++ types to Lua so that Lua code
    can create C++ objects. We also learned about the registry and the userdata type.
    Last but not least, we implemented a finalizer for garbage collection.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将 C++ 类型导出到 Lua，以便 Lua 代码可以创建 C++ 对象。我们还了解了注册表和 userdata 类型。最后但同样重要的是，我们实现了垃圾回收的终结器。
- en: The work in this chapter is based on registering C++ modules from the previous
    chapter. You can choose to export a C++ class or C++ class instances. It is a
    matter of design choice and your project’s needs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的工作基于上一章中注册的 C++ 模块。你可以选择导出 C++ 类或 C++ 类实例。这是一个设计选择，取决于你的项目需求。
- en: In the next chapter, we will learn how to implement a template class to help
    export C++ types to Lua.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何实现模板类以帮助将 C++ 类型导出到 Lua。
- en: Exercise
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In `main.cpp`, we created an instance of `Destinations` and registered it to
    Lua. In Lua code, this instance is used to create more instances. This is fine,
    considering that Lua uses prototype-based object-oriented programming as well.
    If you want to make your C++ code more like C++’s way of doing things, you can
    create a factory class for `Destinations` and register the factory to Lua. Do
    this and make the factory only export the `luaNew` function. You shouldn’t need
    to change `script.lua` or the Lua C wrapper function implementations.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.cpp` 文件中，我们创建了一个 `Destinations` 实例并将其注册到 Lua 中。在 Lua 代码中，这个实例被用来创建更多的实例。考虑到
    Lua 使用基于原型的面向对象编程，这是可以的。如果你想使你的 C++ 代码更接近 C++ 的编程方式，你可以为 `Destinations` 创建一个工厂类并将工厂注册到
    Lua 中。这样做，并让工厂只导出 `luaNew` 函数。你不需要修改 `script.lua` 或 Lua C 封装函数的实现。
