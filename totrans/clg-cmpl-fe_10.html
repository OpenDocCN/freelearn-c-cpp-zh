<html><head></head><body>
<div><div><h1 data-number="2.4" class="calibre5">8</h1>
<h1 id="sigil_toc_id_134" class="calibre5"><a id="x1-1520008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>IDE Support and Clangd</h1>
<p class="hidden">This chapter is <a id="dx1-152001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>about the <strong class="calibre12">Language Server Protocol (LSP) </strong>and how you can utilize it to enhance your <strong class="calibre12">Integrated Development Environment</strong> <strong class="calibre12">(IDE)</strong>. Our <a id="dx1-152002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>primary IDE of choice is <strong class="calibre12">Visual Studio Code (VS Code)</strong>. LLVM <a id="dx1-152003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>has its own implementation of LSP known as <strong class="calibre12">Clangd</strong>. We will <a id="dx1-152004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>begin by describing LSP and exploring how Clangd leverages it to extend the capabilities provided by the IDE. Finally, we will conclude with examples of how various Clang tools, such as Clang-Tidy and Clang-Format, can be seamlessly integrated into the IDE through Clangd.</p>
<p class="hidden">We will cover the following topics in this chapter:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">What is Language Server Protocol (LSP) and how does it improve an IDE’s capabilities?</p></li>
<li class="calibre14"><p class="calibre15">How VS Code and Clangd (the Clang LSP server) can be installed</p></li>
<li class="calibre14"><p class="calibre15">How LSP is used to connect VS Code and Clangd, through an example</p></li>
<li class="calibre14"><p class="calibre15">How Clangd is integrated with other Clang tools</p></li>
<li class="calibre14"><p class="calibre15">Why performance matters for Clangd and what optimizations were made to make Clangd fast</p></li>
</ul>
<p class="hidden"><a id="x1-152005r478" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h2 data-number="2.4.1" id="sigil_toc_id_135" class="likechapterhead">8.1  <a id="x1-1530001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Technical requirements</h2>
<p class="hidden">The source code for this chapter is located in the <code class="calibre13">chapter8 </code>folder of the book’s GitHub repository: <a href="https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter8" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter8</a> <a id="x1-153001r480" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h2 data-number="2.4.2" id="sigil_toc_id_136" class="likechapterhead">8.2  <a id="x1-1540002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Language Server Protocol</h2>
<p class="hidden">An IDE is a software application or platform that provides a comprehensive set of tools and features to assist developers in creating, editing, debugging, and managing software code. An IDE typically includes a code <a id="dx1-154001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>editor with syntax highlighting, debugging capabilities, project management features, version control integration, and, often, plugins or extensions to support various programming languages and frameworks.</p>
<p class="hidden">Popular examples of IDEs are Visual Studio/VS Code, IntelliJ IDEA, Emacs, and Vim. These tools are designed to streamline the development process, making it easier for developers to write, test, and maintain their code efficiently.</p>
<p class="hidden">A typical IDE supports multiple languages, and integrating each language can be a challenging task. Each language requires specific support, which can be visualized in <a href="#Figure8.1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.1</a>. It’s worth noting that there are many similarities in the development process of different programming languages. For example, the languages shown in <a href="#Figure8.1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.1</a> have a code navigation feature that allows developers to quickly locate and view the definition of a symbol or identifier within their code base.</p>
<div><div><img src="img/Figure8.1_B19722.png" alt="Figure 8.1: Programming languages integration in IDEs " class="calibre43"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 8.1</strong>: Programming languages integration in IDEs </p>
</div>
<p class="hidden">The feature will be referred to as <strong class="calibre12">go-to definition </strong>in this chapter. Such similarities suggest a way to simplify the <a id="dx1-154004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>relationships shown in <a href="#Figure8.1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.1</a> by introducing an intermediate level called the <strong class="calibre12">Language Server Protocol</strong>, or <strong class="calibre12">LSP</strong>, as shown here:</p>
<div><img src="img/Figure8.2_B19722.png" alt="Figure 8.2: Programming languages integration in IDEs using LSP " class="calibre43"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 8.2</strong>: Programming languages integration in IDEs using LSP </p>
<p class="hidden">The <strong class="calibre12">LSP </strong>project was initiated by Microsoft in 2015 as part of its efforts to improve VS Code, a lightweight, open source code editor. Microsoft recognized the need for a standardized way to provide rich language services across different programming languages within VS Code and other code editors.</p>
<p class="hidden">LSP quickly gained popularity and adoption in the developer community. Many code editors and IDEs, including VS Code, Emacs, and Eclipse, began implementing support for LSP.</p>
<p class="hidden">Language server implementations <a id="dx1-154007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>emerged for various programming languages. These language servers, developed by both Microsoft and the open source community, offered language-specific intelligence and services, making it easier to integrate language features into different editors.</p>
<p class="hidden">In this chapter, we will explore <strong class="calibre12">Clangd</strong>, a language <a id="dx1-154008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>server that is part of clang-tools-extra. Clangd leverages the Clang compiler frontend and offers a comprehensive suite of code analysis and language support features. Clangd assists developers with intelligent code completion, semantic analysis, and real-time diagnostics, helping them to write code more efficiently and catch errors early in the development process. We will delve into Clangd in detail here, starting with a real example of the interaction between the IDE (VS Code) and Clangd. We will begin with the environment setup, including the Clangd build and VS Code setup. <a id="x1-154009r481" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h2 data-number="2.4.3" id="sigil_toc_id_137" class="likechapterhead">8.3  <a id="x1-1550003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Environment setup</h2>
<p class="hidden">We will begin our environment <a id="dx1-155001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>setup by building Clangd. Then, we will install VS Code, set up the Clangd extension, and configure Clangd within it. <a id="x1-155002r469" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h3 data-number="2.4.3.1" id="sigil_toc_id_138" class="likesectionhead">8.3.1  <a id="x1-1560001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clangd build</h3>
<p class="hidden">It’s worth building Clangd in release mode, as we did for LLDB in <a href="B19722_01.xhtml#x1-290003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 1.3.3</em></a><em class="calibre11">,</em> <em class="calibre11">The LLVM debugger, its build, and usage</em>. This is <a id="dx1-156001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>because performance is crucial in IDEs. For instance, Clangd requires building an AST to provide code navigation functionality. If a user modifies a document, the document should be rebuilt, and the navigation functionality will not be available until the rebuild process is completed. This can result in delays in IDE responses. To prevent IDE slowness in responses, we should ensure that Clangd is built with all the required optimizations. You can use the following project configuration command:</p>
<pre id="listing-54" class="source-code">cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=../install -DLLVM_TARGETS_TO_BUILD="X86" -DLLVM_ENABLE_PROJECTS="clang;clang-tools-extra" ../llvm</pre>
<p class="hidden"><a id="x1-156003r3" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-156004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.3</strong>: Release configuration for Clangd build </p>
<p class="hidden">The command has to be run from the <code class="calibre13">release </code>folder that we created in <a href="B19722_01.xhtml#x1-290003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 1.3.3</em></a><em class="calibre11">, The LLVM debugger, its build, and usage</em>, as shown in <a href="B19722_01.xhtml#x1-29011r8" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.8</a>. As you can see, we have enabled two projects in <a href="#x1-156003r3" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.3</a>: <code class="calibre13">clang </code>and <code class="calibre13">clang-tools-extra </code>.</p>
<p class="hidden">You can use the following <a id="dx1-156005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>command to build and install Clangd:</p>
<pre id="verbatim-113" class="console">$ ninja install-clangd -j $(nproc)</pre>
<p class="hidden">This command will utilize the maximum available threads on the system and install the binary into the folder specified in our CMake command in <a href="#x1-156003r3" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.3</a>, which is the <code class="calibre13">install </code>folder under the LLVM source tree.</p>
<p class="hidden">After building the Clangd binary, our next step will include installing VS Code and configuring it to work with Clangd. <a id="x1-156006r485" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="2.4.3.2" id="sigil_toc_id_139" class="likesectionhead">8.3.2  <a id="x1-1570002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>VS Code installation and setup</h3>
<p class="hidden">You can download and install VS Code <a id="dx1-157001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>from the VS Code website: <a href="https://code.visualstudio.com/download" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://code.visualstudio.com/download</a>.</p>
<p class="hidden">The first step after <a id="dx1-157002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>running VS Code is to install the <strong class="calibre12">Clangd </strong>extension. An open source extension is available to work with Clangd via LSP. The extension’s source code can be found on GitHub: <a href="https://github.com/clangd/vscode-clangd" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://github.com/clangd/vscode-clangd</a>. However, we can easily install the latest version of the extension directly from within VS Code.</p>
<p class="hidden">To do this, press <em class="calibre11">Ctrl+Shift+X </em>(or <img src="img/Mac_icon.png" alt="The Apple Key" class="calibre44"/> <em class="calibre11">+Shift+X </em>for macOS) to open the extensions panel. Search for <code class="calibre13">Clangd </code>and click the <strong class="calibre12">Install </strong>button.</p>
<div><img src="img/file4.png" alt="Figure 8.4: Installing the Clangd extension " class="calibre45"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 8.4</strong>: Installing the Clangd extension </p>
<p class="hidden">After installing the extension, we <a id="dx1-157005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>need to set it up. The main <a id="dx1-157006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>step is to specify the path to the Clangd executable.</p>
<p class="hidden">You can access this setting via the <strong class="calibre12">File — Preferences — Settings </strong>menu or by pressing <em class="calibre11">Ctrl + , </em>(or <img src="img/Mac_icon.png" alt="The Apple Key" class="calibre44"/> <em class="calibre11">+, </em>for macOS), as shown in the following screenshot:</p>
<div><img src="img/file5.png" alt="Figure 8.5: Setting up the Clangd extension " class="calibre45"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 8.5</strong>: Setting up the Clangd extension </p>
<p class="hidden">As shown in <a href="#Figure8.5" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.5</a>, we have <a id="dx1-157009" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>configured the Clangd path to be <code class="calibre13">/home/ivanmurashko</code> <code class="calibre13">/clangbook/llvm-project/install/bin/clangd </code>. This path was used during the installation of the Clangd binary in <a href="#x1-1560001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 8.3.1</em></a><em class="calibre11">, Clangd build</em>.</p>
<p class="hidden">You can open your favorite C/C++ source file and <a id="dx1-157010" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>try to navigate through it. For instance, you can search for a definition for a token, switch between a source and a header, and so on. In our next example, we will investigate how navigation, and especially go-to definition, works through LSP.</p>

<p class="hidden">Important note</p>

<p class="hidden">Our setup works only for simple projects that do not require special compilation flags. If your project requires special configuration to build, then you have to use a generated <code class="calibre13">compile</code><code class="calibre13">_commands.json</code> file that should be placed at the root of your project. This file <a id="dx1-157011" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>should contain a <strong class="calibre12">Compilation Database </strong>(<strong class="calibre12">CDB</strong>) in JSON format, specifying compilation flags for each file in your project. For more information about the setup, please refer to <a href="B19722_09.xhtml#x1-1880003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Figure</em><em class="calibre11"> 9.5</em></a><em class="calibre11">, Clangd</em> <em class="calibre11">Setup for Large Projects</em>.</p>

<p class="hidden">With the required components installed, we are now ready for an LSP demo where we will emulate typical development activities in an IDE (open and modify a document, jump to a token definition, etc.) and explore how it’s represented via LSP. <a id="x1-157012r484" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>



<h2 data-number="2.4.4" id="sigil_toc_id_140" class="likechapterhead">8.4  <a id="x1-1580004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>LSP demo</h2>
<p class="hidden">In this brief LSP demo, we will demonstrate <a id="dx1-158001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>how Clangd opens a file and finds a symbol’s definition. Clangd features a comprehensive logging subsystem that offers valuable insights into its interaction with the IDE. We will use the log subsystem to obtain the necessary information. <a id="x1-158002r487" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h3 data-number="2.4.4.1" id="sigil_toc_id_141" class="likesectionhead">8.4.1  <a id="x1-1590001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Demo description</h3>
<p class="hidden">In our example, we open a test file as <a id="dx1-159001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>shown in the following screenshot and retrieve the definition of the <code class="calibre13">doPrivateWork</code> token:</p>
<div><img src="img/file6.png" alt="Figure 8.6: Go-to definition and hover for the doPrivateWork token " class="calibre46"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 8.6</strong>: Go-to definition and hover for the <code class="calibre13">doPrivateWork </code>token </p>
<p class="hidden">VS Code communicates with Clangd via standard input/output, and we will use Clangd logs to capture the interaction.</p>
<p class="hidden">This can be achieved by setting up a wrapper <a id="dx1-159004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>shell script instead of using the actual clangd binary in the VS Code settings:</p>
<div><img src="img/file7.png" alt="Figure 8.7: Wrapper shell script setup in VS Code " class="calibre47"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 8.7</strong>: Wrapper shell script setup in VS Code </p>
<p class="hidden">We can use the following script, <code class="calibre13">clangd.sh </code>:</p>
<pre class="source-code">1 #!/bin/sh 
 
2 $HOME/clangbook/llvm-project/install/bin/clangd -log verbose -pretty 2&gt; /tmp/clangd.log</pre>
<p class="hidden"><a id="x1-159010r8" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-159011" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.8</strong>: Wrapper shell script for clangd </p>
<p class="hidden">In <a href="#x1-159010r8" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.8</a>, we use two log options:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">The first one, <code class="calibre13">-log verbose </code>, activates verbose logging to ensure that actual LSP messages from and to Clangd will be logged.</p></li>
<li class="calibre14"><p class="calibre15">The second option, <code class="calibre13">-pretty </code>, is used to provide nicely formatted JSON messages. We also redirect stderr output to the log file, <code class="calibre13">/tmp/clangd.log </code>, in our case.</p></li>
</ul>
<p class="hidden">As a result, the file will contain <a id="dx1-159012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>logs from our example session. We can view these logs using the following command::</p>
<pre id="verbatim-114" class="console">$ cat /tmp/clangd.log</pre>
<p class="hidden">In the logs, we can find <code class="calibre13">"textDocument/definition" </code>that was sent by VS Code:</p>
<pre id="verbatim-115" class="console">V[16:24:39.336] &lt;&lt;&lt; {
  "id": 13,
  "jsonrpc": "2.0",
  "method": "textDocument/definition",
  "params": {
    "position": {
      "character": 26,
      "line": 7
    },</pre>
<pre id="verbatim-116" class="console">    "textDocument": {
      "uri": "file:///home/ivanmurashko/clangbook/helper.hpp"
    }
  }
}</pre>
<p class="hidden"><a id="x1-159013r9" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-159014" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.9</strong>: The ”textDocument/definition” request sent by the IDE </p>
<p class="hidden">The request sent by the IDE is received <a id="dx1-159015" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>and processed by Clangd. The corresponding log is recorded as follows:</p>
<pre id="verbatim-117" class="console">I[16:24:39.336] &lt;-- textDocument/definition(13)
V[16:24:39.336] ASTWorker running Definitions on version 1 of /home/.../
helper.hpp</pre>
<p class="hidden"><a id="x1-159016r10" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-159017" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.10</strong>: Handling of the ”textDocument/definition” request in Clangd </p>
<p class="hidden">Finally, Clangd creates the response and sends it to the IDE. The corresponding log record shows that the reply was sent:</p>
<pre id="verbatim-118" class="console">I[16:24:39.336] --&gt; reply:textDocument/definition(13) 0 ms
V[16:24:39.336] &gt;&gt;&gt; {
  "id": 13,
  "jsonrpc": "2.0",
  "result": [
    {
      "range": {
        "end": {
          "character": 20,
          "line": 10
        },</pre>
<pre id="verbatim-119" class="console">        "start": {
          "character": 7,
          "line": 10
        }
      },
      "uri": "file:///home/ivanmurashko/clangbook/helper.hpp"
    }
  ]
}</pre>
<p class="hidden"><a id="x1-159018r11" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-159019" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.11</strong>: The ”textDocument/definition” reply from Clangd </p>
<p class="hidden">The logs will be our primary <a id="dx1-159020" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>tool to investigate LSP internals. Let’s dive into more complex examples. <a id="x1-159021r491" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="2.4.4.2" id="sigil_toc_id_142" class="likesectionhead">8.4.2  <a id="x1-1600002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>LSP session</h3>
<p class="hidden">An LSP session consists of several requests to and responses from the Clangd server. It starts with an <code class="calibre13">"initialize" </code>request. Then, we open a document, and VS Code sends a <code class="calibre13">"textDocument/didOpen" </code>notification. After the request, Clangd will periodically respond with <code class="calibre13">"textDocument/publishDiagnostics"</code> notifications when the state of the opened file changes. For example, this occurs <a id="dx1-160001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>when compilation is finished and its ready to process navigation requests. Next, we initiate a go-to definition request for a token, and Clangd responds with the location information for the found definition. We also investigate how Clangd processes file modifications that are notified by the client via <code class="calibre13">"textDocument</code> <code class="calibre13">/didChange" </code>notifications. We finish our session with a <code class="calibre13">"textDocument/didClose"</code> request when we close the opened file. A diagram depicting the interaction is presented in the following figure:</p>
<div><div><img src="img/Figure8.12_B19722.png" alt="Figure 8.12: LSP session example " class="calibre48"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 8.12</strong>: LSP session example </p>
</div>
<p class="hidden">Let’s look at the example in detail. We will start with the <code class="calibre13">"initialize"</code> request.</p>

<h4 data-number="2.4.4.2.1" class="sigil_not_in_toc"><a id="x1-1610002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Initialization</h4>
<p class="hidden">To establish communication, the client (code editor or IDE) and the language server exchange JSON-RPC messages. The initialization process begins with the client sending an <code class="calibre13">"initialize" </code>request to the <a id="dx1-161001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>language server, specifying the capabilities it supports. The actual request sent by VS Code is quite large, and a simplified version, where some parts of the request are replaced with <code class="calibre13">"..." </code>, is shown as follows:</p>
<pre id="listing-55" class="source-code">1{ 
 
2   "id": 0, 
 
3   "jsonrpc": "2.0", 
 

4   "method": "initialize", 
 
5   "params": { 
 

6     "capabilities": { 
 
7       ... 
 

8       "textDocument": { 
 
9         ... 
 

10         "definition": { 
 

11           "dynamicRegistration": true, 
 

12           "linkSupport": true 
 
13         }, 
 
14         ... 
 

15     }, 
 
16     "clientInfo": { 
 

17       "name": "Visual Studio Code", 
 

18       "version": "1.85.1" 
 
19     }, 
 
20     ... 
 
21   } 
 
22 }</pre>
<p class="hidden"><a id="x1-161024r13" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-161025" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.13</strong>: VS Code to Clangd (initialize request) </p>
<p class="hidden">In the request, the client (VS Code) tells <a id="dx1-161026" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the server (Clangd) what capabilities are supported on the client side; for example, at <em class="calibre11">Lines 10-13 </em>in <a href="#x1-161024r13" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.13</a>, the client says that it supports the <code class="calibre13">"textDocument/definition" </code>request type that is used for go-to definition requests.</p>
<p class="hidden">The language server replies to the request with a response that contains capabilities supported by the server:</p>
<pre id="listing-56" class="source-code">1{ 
 
2   "id": 0, 
 
3   "jsonrpc": "2.0", 
 

4   "result": { 
 
5     "capabilities": { 
 
6       ... 
 

7       "definitionProvider": true, 
 
8       ... 
 
9     }, 
 

10     "serverInfo": { 
 
11       "name": "clangd", 
 

12       "version": "clangd version 16.0.6 (https://github.com/llvm/llvm-project.git 7cbf1a2591520c2491aa35339f227775f4d3adf6) linux x86_64-unknown-linux-gnu" 
 

13     } 
 
14   } 
 
15 }</pre>
<p class="hidden"><a id="x1-161042r14" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-161043" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.14</strong>: Clangd to VS Code (initialize reply) </p>
<p class="hidden">As we can see, the same <code class="calibre13">id </code>is used to <a id="dx1-161044" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>connect the request with its reply. Clangd replied that it supports go-to definition requests as specified in <em class="calibre11">Line</em> <em class="calibre11">7 </em>in <a href="#x1-161042r14" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.14</a>. Thus our client (VS Code) can send the navigation request to the server, which we will explore later in <a href="#x1-1630002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Figure</em><em class="calibre11"> 8.19</em></a><em class="calibre11">, Go-to</em> <em class="calibre11">definition</em>.</p>
<p class="hidden">VS Code acknowledges the initialization by sending an <code class="calibre13">"initialized"</code> notification:</p>
<pre id="listing-57" class="source-code">1{ 
 
2   "jsonrpc": "2.0", 
 
3   "method": "initialized" 
 
4 }</pre>
<p class="hidden">Contrary to the <code class="calibre13">"initialize" </code>request, there is a notification, and it does not expect any response from the server. As a result, it does not have an <code class="calibre13">"id" </code>field. The <code class="calibre13">"initialized" </code>notification can be sent only once, and it <a id="dx1-161049" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>should be received before any other requests or notifications are sent from the client side. After the initialization, we are ready to open a document and send the corresponding <code class="calibre13">"textDocument/didOpen"</code> notification.</p>


<h4 data-number="2.4.4.2.2" class="sigil_not_in_toc"><a id="x1-1620002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Open document</h4>
<p class="hidden">When a developer opens a C++ source file, the client sends a <code class="calibre13">"textDocument/didOpen" </code>notification to inform the language <a id="dx1-162001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>server about the newly opened file. In our example, the opened file is located at <code class="calibre13">/home/ivanmurashko/clangbook/helper.hpp </code>, and the corresponding notification sent by VS Code will look like this:</p>
<pre id="listing-58" class="source-code">{ 
 
  "jsonrpc": "2.0", 
 
  "method": "textDocument/didOpen", 
 

  "params": { 
 
   "textDocument": { 
 

     "languageId": "cpp", 
 
     "text": "#pragma once\n\nnamespace clangbook {\nclass Helper {\npublic:\n  Helper(){};\n\n  void doWork() { doPrivateWork(); }\n\nprivate:\n  void doPrivateWork() {}\n};\n}; // namespace clangbook\n", 
 

     "uri": "file:///home/ivanmurashko/clangbook/helper.hpp",</pre>
<pre id="listing-59" class="source-code">     "version": 1 
 
   } 
 
  } 
 
}</pre>
<p class="hidden"><a id="x1-162014r15" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-162015" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.15</strong>: VS Code to Clangd (didOpen notification) </p>
<p class="hidden">As we can see, VS Code sends the notification with parameters included in the <code class="calibre13">"params/</code> <code class="calibre13">textDocument" </code>field. These parameters consist of the filename in the <code class="calibre13">"uri"</code> field and the source file text within the <code class="calibre13">"text" </code>field.</p>
<p class="hidden">Clangd starts compiling the file upon receiving the ’didOpen’ notification. It builds an AST and extracts semantic information about different tokens from it. The server uses this information to distinguish between different tokens with the same name. For example, we can use a token named ’foo’ that may <a id="dx1-162016" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>serve as a class member or a local variable depending on the scope in which it is used, as shown in the following code fragment:</p>
<pre class="source-code">1 class TestClass { 
 
2 public: 
 
3   int foo(){return 0}; 
 

4 }; 
 
5  
 
6 int main() { 
 
7   TestClass test; 
 

8   int foo = test.foo(); 
 
9   return foo; 
 
10 }</pre>
<p class="hidden"><a id="x1-162028r16" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-162029" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.16</strong>: Occurrences of the ’foo’ token in foo.hpp </p>
<p class="hidden">As we can see in <em class="calibre11">Line 8</em>, we use the <code class="calibre13">’foo’ </code>token two times: as a function call and in a local variable definition.</p>
<p class="hidden">The go-to definition request will be delayed until the compilation process is finished. It’s worth noting that the majority of requests are put in a queue and wait until the compilation process is finished. The rule has some exemptions, and some requests can be executed without an AST with a limited provided functionality. One of the examples is the code-formatting requests. The code formatting does not require an AST and therefore the formatting functionality can be provided before the AST is built.</p>
<p class="hidden">If the state of the file is changed, then Clangd will notify VS Code with the <code class="calibre13">"textDocument/publishDiagnostics" </code>notification. For example, when the compilation process is finished, then Clangd will <a id="dx1-162030" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>send the notification to VS Code:</p>
<pre id="listing-60" class="source-code">1{ 
 
2   "jsonrpc": "2.0", 
 
3   "method": "textDocument/publishDiagnostics", 
 

4   "params": { 
 
5    "diagnostics": [], 
 

6    "uri": "file:///home/ivanmurashko/clangbook/helper.hpp", 
 

7    "version": 1 
 
8   } 
 
9 }</pre>
<p class="hidden"><a id="x1-162040r17" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-162041" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.17</strong>: Clangd to VS Code (publishDiagnostics notification) </p>
<p class="hidden">As we can see, there are no compilation errors; <code class="calibre13">params/diagnostics </code>is empty. It will contain errors or warning descriptions if our code contains a compilation error or warning, as shown here:</p>
<pre id="listing-61" class="source-code">1{ 
 
2   "jsonrpc": "2.0", 
 
3   "method": "textDocument/publishDiagnostics", 
 

4   "params": { 
 
5    "diagnostics": [ 
 
6      { 
 

7        "code": "expected_semi_after_expr", 
 

8        "message": "Expected ’;’ after expression (fix available)", 
 

9        "range": { 
 
10          "end": { 
 

11            "character": 35, 
 
12            "line": 7 
 

13          }, 
 
14          "start": { 
 
15            "character": 34, 
 

16            "line": 7 
 
17          } 
 
18        }, 
 

19        "relatedInformation": [], 
 
20        "severity": 1, 
 

21        "source": "clang" 
 
22      } 
 
23    ], 
 

24    "uri": "file:///home/ivanmurashko/clangbook/helper.hpp", 
 

25    "version": 5 
 
26   } 
 
27 }</pre>
<p class="hidden"><a id="x1-162069r18" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-162070" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.18</strong>: Clangd to VS Code (publishDiagnostics with compilation error) </p>
<p class="hidden">VS Code processes the diagnostics <a id="dx1-162071" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>and displays it, as shown in the following screenshot:</p>
<div><img src="img/file8.png" alt="Figure 8.19: Compilation error in helper.hpp " class="calibre46"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 8.19</strong>: Compilation error in helper.hpp </p>
<p class="hidden">After the compilation <a id="dx1-162074" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>finished and we got <code class="calibre13">"textDocument/publishDiagnostics" </code>, Clangd is ready to process navigation requests, such as <code class="calibre13">"textDocument/definition"</code> (go-to definition).</p>


<h4 data-number="2.4.4.2.3" class="sigil_not_in_toc"><a id="x1-1630002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Go-to definition</h4>
<p class="hidden">To find the <a id="dx1-163001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>definition of a symbol in a C++ file, the client sends a <code class="calibre13">"textDocument/</code> <code class="calibre13">definition" </code>request to the language server:</p>
<pre id="listing-62" class="source-code">1{ 
 
2   "id": 13, 
 
3   "jsonrpc": "2.0", 
 

4   "method": "textDocument/definition", 
 

5   "params": { 
 
6    "position": { 
 
7      "character": 26, 
 

8      "line": 7 
 
9    }, 
 
10    "textDocument": { 
 

11      "uri": "file:///home/ivanmurashko/clangbook/helper.hpp" 
 

12    } 
 
13   } 
 
14 }</pre>
<p class="hidden"><a id="x1-163016r20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-163017" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.20</strong>: VS Code to Clangd (textDocument/definition request) </p>
<p class="hidden">The line position is specified as 7 instead of the actual line 8 in the editor, as shown in <a href="#Figure8.6" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.6</a>. This is because line numbering starts at 0.</p>
<p class="hidden">The language server responds with the definition location in the C++ code:</p>
<pre id="listing-63" class="source-code">1{ 
 
2   "id": 13, 
 
3   "jsonrpc": "2.0", 
 
4   "result": [ 
 

5    { 
 
6      "range": { 
 
7        "end": { 
 

8          "character": 20, 
 
9          "line": 10 
 

10        }, 
 
11        "start": { 
 
12          "character": 7, 
 

13          "line": 10 
 
14        } 
 
15      }, 
 

16      "uri": "file:///home/ivanmurashko/clangbook/helper.hpp" 
 

17    } 
 
18   ] 
 
19 }</pre>
<p class="hidden"><a id="x1-163037r21" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-163038" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.21</strong>: Clangd to VS Code (textDocument/definition response) </p>
<p class="hidden">As we can see, the server responded <a id="dx1-163039" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>with the actual position of the definition. Another popular action in the IDE is document modification. This functionality is served by the <code class="calibre13">"textDocument/didChange" </code>notification. Let’s look at it.</p>


<h4 data-number="2.4.4.2.4" class="sigil_not_in_toc"><a id="x1-1640002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Change document</h4>
<p class="hidden">As part of the <a id="dx1-164001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>document modification, let’s insert a comment, <code class="calibre13">//</code> <code class="calibre13">Constructor</code>, at <em class="calibre11">Line 6</em>, as shown in this screenshot:</p>
<div><img src="img/file9.png" alt="Figure 8.22: Change document " class="calibre49"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 8.22</strong>: Change document </p>
<p class="hidden">VS Code will detect that the document has been modified and notify the LSP server (Clangd) using the following notification:</p>
<pre id="listing-64" class="source-code">1{ 
 
2   "jsonrpc": "2.0", 
 
3   "method": "textDocument/didChange", 
 

4   "params": { 
 
5     "contentChanges": [ 
 

6       { 
 
7         "range": { 
 
8           "end": { 
 

9             "character": 13, 
 
10             "line": 5 
 

11           }, 
 
12           "start": { 
 
13             "character": 13, 
 

14             "line": 5 
 
15           } 
 
16         }, 
 

17         "rangeLength": 0, 
 
18         "text": "// Constructor" 
 

19       } 
 
20     ], 
 
21     "textDocument": { 
 

22       "uri": "file:///home/ivanmurashko/clangbook/helper.hpp", 
 

23       "version": 2 
 
24     } 
 
25   } 
 
26 }</pre>
<p class="hidden"><a id="x1-164030r23" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-164031" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.23</strong>: VS Code to Clangd (didChange notification) </p>
<p class="hidden">As we can see, the notification <a id="dx1-164032" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>contains the range specification and the text for replacing the specified range in the document. One important part of the notification is the <code class="calibre13">"version" </code>field, which specifies the version of the document.</p>
<p class="hidden">We can observe that <code class="calibre13">version </code>changed from 1, as used in the document open (see <em class="calibre11">Line 9 </em>in <a href="#x1-162014r15" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.15</a>), to 2 for the document modification (see <em class="calibre11">Line 23 </em>in <a href="#x1-164030r23" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.23</a>).</p>
<p class="hidden">Clangd starts the document compilation because the document modification can cause a significant change in the resulting AST, which is used for navigation requests. Once the compilation is finished, the server will <a id="dx1-164033" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>respond with the corresponding <code class="calibre13">"textDocument/publishDiagnostics" </code>notification, as shown here:</p>
<pre id="listing-65" class="source-code">1{ 
 
2   "jsonrpc": "2.0", 
 
3   "method": "textDocument/publishDiagnostics", 
 

4   "params": { 
 
5     "diagnostics": [], 
 

6     "uri": "file:///home/ivanmurashko/clangbook/helper.hpp", 
 

7     "version": 2 
 
8 }</pre>
<p class="hidden"><a id="x1-164042r24" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-164043" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.24</strong>: Clangd to VS Code (publishDiagnostics notification) </p>
<p class="hidden">As we can see, the diagnostic was sent for the modified document because it contains the version field pointing to version 2, which corresponds to the modified document, as seen in <em class="calibre11">Line 7 </em>of <a href="#x1-164042r24" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.24</a>.</p>
<p class="hidden">Our last action in the example is to close the document. Let’s take a closer look at it.</p>


<h4 data-number="2.4.4.2.5" class="sigil_not_in_toc"><a id="x1-1650002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Closing a document</h4>
<p class="hidden">When we finish our work <a id="dx1-165001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>with the document and close it, VS Code sends a <code class="calibre13">"textDocument/didClose" </code>notification to the language server:</p>
<pre id="listing-66" class="source-code">1{ 
 
2   "jsonrpc": "2.0", 
 
3   "method": "textDocument/didClose", 
 

4   "params": { 
 
5    "textDocument": { 
 

6      "uri": "file:///home/ivanmurashko/clangbook/helper.hpp" 
 

7    } 
 
8   } 
 
9 }</pre>
<p class="hidden"><a id="x1-165011r25" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-165012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.25</strong>: VS Code to Clangd (textDocument/didClose request) </p>
<p class="hidden">After receiving the request, Clangd will remove the document from its internal structures. Clangd will not send any updates for the document anymore, thus it will empty out the list of diagnostics shown on the client (e.g., in the <strong class="calibre12">Problems </strong>pane of VS Code) by sending the final empty <code class="calibre13">"textDocument/publishDiagnostics" </code>message, as shown here:</p>
<pre id="listing-67" class="source-code">1{ 
 
2   "jsonrpc": "2.0", 
 
3   "method": "textDocument/publishDiagnostics", 
 

4   "params": { 
 
5    "diagnostics": [], 
 

6    "uri": "file:///home/ivanmurashko/clangbook/helper.hpp" 
 

7   } 
 
8 }</pre>
<p class="hidden"><a id="x1-165021r26" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-165022" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.26</strong>: Clangd to VS Code (textDocument/didClose request) </p>
<p class="hidden">The shown example demonstrates the typical interactions between Clangd and VS Code. The provided example utilizes functionality from the Clang frontend, that is, basic Clang functionality. On the other hand, Clangd has a <a id="dx1-165023" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>strong connection with other Clang tools, such as Clang-Format and Clang-Tidy, and can reuse the functionality provided by these tools. Let’s take a closer look at this. <a id="x1-165024r490" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>




<h2 data-number="2.4.5" id="sigil_toc_id_143" class="likechapterhead">8.5  <a id="x1-1660005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Integration with Clang tools</h2>
<p class="hidden">Clangd takes advantage of the LLVM module architecture and has a very strong integration with other Clang tools. In particular, Clangd uses Clang-Format libraries to provide formatting functionality <a id="dx1-166001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>and Clang-Tidy libraries (such as libraries with clang-tidy checks) to support linters in the IDE. The integration is schematically shown in the following figure:</p>
<div><div><img src="img/Figure8.27_B19722.png" alt="Figure 8.27: VS Code with LSP extension and Clangd server for C++ " class="calibre50"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 8.27</strong>: VS Code with LSP extension and Clangd server for C++ </p>
</div>
<p class="hidden">The configuration from <code class="calibre13">.clang-format </code>(see <a href="B19722_07.xhtml#x1-1470001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 7.4.1</em></a><em class="calibre11">, Clang-Format</em> <em class="calibre11">configuration and usage examples</em>) is used for formatting, and from <code class="calibre13">.clang-tidy</code> (see <a href="B19722_05.xhtml#x1-1080002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Figure</em><em class="calibre11"> 5.12</em></a><em class="calibre11">, Clang-Tidy configuration</em>) for linters. Let’s see how the formatting works in Clangd. <a id="x1-166004r499" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h3 data-number="2.4.5.1" id="sigil_toc_id_144" class="likesectionhead">8.5.1  <a id="x1-1670001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clangd support for code formatting using LSP messages</h3>
<p class="hidden">Clangd provides <a id="dx1-167001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>robust support for code formatting. This <a id="dx1-167002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>feature is essential for developers to maintain consistent code <a id="dx1-167003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>styles and readability in their C and C++ projects. Clangd leverages LSP messages, primarily the <code class="calibre13">"textDocument/formatting" </code>and <code class="calibre13">"textDocument/rangeFormatting" </code>requests, to achieve this functionality.</p>

<h4 data-number="2.4.5.1.1" class="sigil_not_in_toc"><a id="x1-1680001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Formatting entire documents</h4>
<p class="hidden">The <code class="calibre13">"textDocument/formatting" </code>request is <a id="dx1-168001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>used when a developer wants to format the entire content of a document. This request is typically initiated by the user in VS Code by pressing <em class="calibre11">Ctrl + Shift + I </em>(or <img src="img/Mac_icon.png" alt="The Apple Key" class="calibre44"/> <em class="calibre11">+ Shift + I </em>for macOS); the IDE sends a <code class="calibre13">"textDocument/formatting" </code>request to Clangd for the entire document:</p>
<pre id="listing-68" class="source-code">1{ 
 
2   "id": 9, 
 
3   "jsonrpc": "2.0", 
 

4   "method": "textDocument/formatting", 
 
5   "params": { 
 

6    "options": { 
 
7      "insertSpaces": true, 
 

8      "tabSize": 4 
 
9    }, 
 
10    "textDocument": { 
 

11      "uri": "file:///home/ivanmurashko/clangbook/helper.hpp" 
 

12    } 
 
13   } 
 
14 }</pre>
<p class="hidden"><a id="x1-168016r28" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-168017" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.28</strong>: VS Code to Clangd (textDocument/formatting request) </p>
<p class="hidden">Clangd processes this request by utilizing the code style configuration specified in the project’s <code class="calibre13">.clang-format </code>file. The <code class="calibre13">.clang-format </code>file contains formatting rules and preferences, allowing developers to define their desired code style; see <a href="B19722_07.xhtml#x1-1470001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 7.4.1</em></a><em class="calibre11">, Clang-Format configuration and usage</em> <em class="calibre11">examples</em>.</p>
<p class="hidden">The response contains the <a id="dx1-168018" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>list of modifications to be applied to the opened document:</p>
<pre id="listing-69" class="source-code">1{ 
 
2   "id": 9, 
 
3   "jsonrpc": "2.0", 
 
4   "result": [ 
 
5    { 
 

6      "newText": "\n  ", 
 
7      "range": { 
 

8        "end": { 
 
9          "character": 0, 
 

10          "line": 5 
 
11        }, 
 
12        "start": { 
 

13          "character": 7, 
 
14          "line": 4 
 
15        } 
 

16      } 
 
17    } 
 
18   ] 
 
19 }</pre>
<p class="hidden"><a id="x1-168038r29" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-168039" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.29</strong>: Clangd to VS Code (textDocument/formatting response) </p>
<p class="hidden">In the example, we should replace the text at the specified range at <em class="calibre11">Lines 7-16 </em>in <a href="#x1-168038r29" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.29</a> with new text specified at <em class="calibre11">Line 6</em>.</p>


<h4 data-number="2.4.5.1.2" class="sigil_not_in_toc"><a id="x1-1690001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Formatting specific code ranges</h4>
<p class="hidden">In addition to <a id="dx1-169001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>formatting entire documents, Clangd also supports formatting specific code ranges within a document. This is achieved using the <code class="calibre13">"textDocument/rangeFormatting" </code>request. Developers can select a range within the code, such as a function, a block of code, or even just a few lines, and request formatting for <a id="dx1-169002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>that specific range, as shown in the following screenshot:</p>
<div><img src="img/file10.png" alt="Figure 8.30: Reformatting a specific code range in helper.hpp " class="calibre51"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 8.30</strong>: Reformatting a specific code range in helper.hpp </p>
<p class="hidden">When selecting the menu item or pressing <em class="calibre11">Ctrl + K </em>and then <em class="calibre11">Ctrl + F </em>(or <img src="img/Mac_icon.png" alt="The Apple Key" class="calibre44"/> <em class="calibre11">+ K</em> and then <img src="img/Mac_icon.png" alt="The Apple Key" class="calibre44"/> <em class="calibre11">+ F </em>for macOS), VS Code will send the following request to Clangd:</p>
<pre id="listing-70" class="source-code">1{ 
 
2   "id": 89, 
 
3   "jsonrpc": "2.0", 
 

4   "method": "textDocument/rangeFormatting", 
 

5   "params": { 
 
6    "options": { 
 
7      "insertSpaces": true, 
 

8      "tabSize": 4 
 
9    }, 
 
10    "range": { 
 
11      "end": { 
 

12        "character": 2, 
 
13        "line": 10 
 

14      }, 
 
15      "start": { 
 
16        "character": 0, 
 

17        "line": 3 
 
18      } 
 
19    }, 
 
20    "textDocument": { 
 

21      "uri": "file:///home/ivanmurashko/clangbook/helper.hpp" 
 

22    } 
 
23   } 
 
24 }</pre>
<p class="hidden"><a id="x1-169029r31" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-169030" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.31</strong>: VS Code to Clangd (textDocument/rangeFormatting request) </p>
<p class="hidden">The <code class="calibre13">"textDocument/rangeFormatting" </code>request specifies the range to be formatted within the document, and Clangd applies the <a id="dx1-169031" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>same formatting rules from the <code class="calibre13">.clang-format </code>file to this specific code segment. The response will be similar to the one used for the formatting request and will contain the modification that should be applied to the original text, as shown in <a href="#x1-168038r29" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.29</a>. The only difference will be the method name, which should be <code class="calibre13">"textDocument/rangeFormatting" </code>in this case.</p>
<p class="hidden">Another tool that is integrated via Clangd is Clang-Tidy, and it utilizes the LSP protocol in a different manner compared to the formatting functionality that we just described. <a id="x1-169032r523" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>



<h3 data-number="2.4.5.2" id="sigil_toc_id_145" class="likesectionhead">8.5.2  <a id="x1-1700002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clang-Tidy</h3>
<p class="hidden">As we can see, Clangd uses specific LSP <a id="dx1-170001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>methods to implement integration with Clang-Format:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><code class="calibre13">"textDocument/formatting"</code></p></li>
<li class="calibre14"><p class="calibre15"><code class="calibre13">"textDocument/rangeFormatting"</code></p></li>
</ul>
<p class="hidden">On the other hand, the integration <a id="dx1-170002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>with Clang-Tidy is implemented differently, and it reuses the <code class="calibre13">"publishDiagnostics" </code>notification to report linter warnings and errors.</p>
<p class="hidden">Let’s investigate how it works and create a custom Clang-Tidy configuration as the first step.</p>

<h4 data-number="2.4.5.2.1" class="sigil_not_in_toc"><a id="x1-1710002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clang-Tidy integration with LSP</h4>
<p class="hidden">We will run the misc-methodrename <a id="dx1-171001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>check that we recently created for testing method renaming, see <a href="B19722_07.xhtml#x1-1410003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 7.3</em></a><em class="calibre11">, Clang-Tidy as a code modification tool</em>. Our Clang-Tidy configuration will look like this:</p>
<pre class="source-code">1 Checks: ’-*,misc-methodrename’</pre>
<p class="hidden"><a id="x1-171004r32" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-171005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.32</strong>: .clang-tidy config for IDE integration </p>
<p class="hidden">The <code class="calibre13">.clang-tidy </code>file with the configuration should be placed in the folder with our test project.</p>
<p class="hidden">If we rename our helper class to <code class="calibre13">TestHelper</code>, we will be able to observe that the lint check we created in <a href="B19722_07.xhtml#x1-1410003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 7.3</em></a><em class="calibre11">, Clang-Tidy as a code modification</em> <em class="calibre11">tool</em> will start reporting diagnostics about the incorrect method name used for the test class. The corresponding diagnostic is displayed in the drop-down pane and in the <strong class="calibre12">PROBLEMS </strong>tab, as we can see in the following screenshot:</p>
<div><img src="img/file11.png" alt="Figure 8.33: Clang-Tidy integration " class="calibre52"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 8.33</strong>: Clang-Tidy integration </p>
<p class="hidden">The message is displayed as <a id="dx1-171008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>part of diagnostics. Specifically, the following notification is sent from Clang to VS Code:</p>
<pre id="listing-71" class="source-code">1{ 
 
2   "jsonrpc": "2.0", 
 
3   "method": "textDocument/publishDiagnostics", 
 

4   "params": { 
 
5    "diagnostics": [ 
 
6      { 
 

7        "code": "misc-methodrename", 
 

8        "codeDescription": { 
 
9          "href": "https://clang.llvm.org/extra/clang-tidy/checks/misc/ 
 

10                    methodrename.html" 
 
11        }, 
 

12        "message": "Method ’testdoWork’ does not have ’test_’ prefix (fix available)", 
 

13        "range": { 
 
14          "end": { 
 

15            "character": 17, 
 
16            "line": 6 
 

17          }, 
 
18          "start": { 
 
19            "character": 7, 
 

20            "line": 6 
 
21          } 
 
22        }, 
 

23        "relatedInformation": [], 
 
24        "severity": 2, 
 

25        "source": "clang-tidy" 
 
26      } 
 
27    ], 
 

28    "uri": "file:///home/ivanmurashko/clangbook/helper.hpp", 
 

29    "version": 11 
 
30   }</pre>
<p class="hidden"><a id="x1-171039r34" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-171040" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.34</strong>: Clangd to VS Code (publishDiagnostics notification) </p>
<p class="hidden">As we can see in the figure (<em class="calibre11">Line 11</em>), a fix for the problem is also available. There is an amazing opportunity to apply Clang-Tidy <a id="dx1-171041" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>fixes in the IDE. Let’s explore how the functionality is implemented with LSP.</p>


<h4 data-number="2.4.5.2.2" class="sigil_not_in_toc"><a id="x1-1720002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Applying fixes in the IDE</h4>
<p class="hidden">The fixes can be applied in the IDE and the functionality is provided via the <code class="calibre13">"textDocument/codeAction" </code>method. The method is used by VS Code to prompt Clangd to compute commands for the <a id="dx1-172001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>specific document and range. The most important parts of the command are provided in the following example:</p>
<pre id="listing-72" class="source-code">1{ 
 
2   "id": 98, 
 
3   "jsonrpc": "2.0", 
 

4   "method": "textDocument/codeAction", 
 

5   "params": { 
 
6     "context": { 
 

7       "diagnostics": [ 
 
8         { 
 

9           "code": "misc-methodrename", 
 
10           ... 
 

11           "range": ..., 
 
12       ... 
 
13     }, 
 
14     ... 
 
15   } 
 

16 }</pre>
<p class="hidden"><a id="x1-172018r35" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-172019" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.35</strong>: VS Code to Clangd (textDocument/codeAction request) </p>
<p class="hidden">The most important part of the request is at <em class="calibre11">Lines 7-11</em>, where we can see a copy of the original diagnostics notification. This information will be used to retrieve the necessary document modifications provided by <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">FixItHint</code> in the activated check. Consequently, Clangd can respond with the action that <a id="dx1-172020" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>describes the required modification to be made:</p>
<pre id="listing-73" class="source-code">1{ 
 
2   "id": 98, 
 
3   "jsonrpc": "2.0", 
 
4   "result": [ 
 

5    { 
 
6      "diagnostics": [ 
 
7        ... 
 

8      ], 
 
9      "edit": { 
 
10        "changes": { 
 




11          "file:///home/ivanmurashko/clangbook/helper.hpp": [ 
 

12            { 
 
13              "newText": "test_", 
 

14              "range": { 
 
15                "end": { 
 

16                  "character": 7, 
 
17                  "line": 6 
 

18                }, 
 
19                "start": { 
 

20                  "character": 7, 
 
21                  "line": 6 
 

22                } 
 
23              } 
 
24            } 
 
25      ... 
 

26    } 
 
27   ] 
 
28 }</pre>
<p class="hidden"><a id="x1-172049r36" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-172050" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.36</strong>: Clangd to VS Code (codeAction response) </p>
<p class="hidden">The <code class="calibre13">"edit" </code>field in <a href="#x1-172049r36" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.36</a> is the most important part of the response, as it describes the changes to be applied to the original text.</p>
<p class="hidden">The integration with Clang-Tidy is possible without extra computation because the AST is built for navigation and diagnostics purposes by Clangd core. The AST can be used as the seed for Clang-Tidy checks, eliminating the <a id="dx1-172051" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>need to run a separate Clang-Tidy executable to retrieve messages from the linter. This is not the only optimization made in Clangd; let’s now look at another example of performance optimizations in Clangd. <a id="x1-172052r521" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>




<h2 data-number="2.4.6" id="sigil_toc_id_146" class="likechapterhead">8.6  <a id="x1-1730006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Performance optimizations</h2>
<p class="hidden">Obtaining a smooth IDE experience with accurate results provided without visible delays is a challenging task. One of the <a id="dx1-173001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>ways to achieve this experience is through compiler performance optimization, as good navigation can be provided with well-parsed source code. Clangd offers excellent examples of performance optimization, which we will explore in some detail. We will start with the optimizations for code modifications. <a id="x1-173002r530" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h3 data-number="2.4.6.1" id="sigil_toc_id_147" class="likesectionhead">8.6.1  <a id="x1-1740001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Optimizations for modified documents</h3>
<p class="hidden">As we saw in <a href="#x1-1620002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Line</em><em class="calibre11"> 4</em></a><em class="calibre11">, Open document</em>, navigation support requires the AST as the basic data structure, so we have to <a id="dx1-174001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>use the Clang frontend to obtain it. Additionally, we have to <a id="dx1-174002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>rebuild the AST when there are document modifications. Document modification is a common activity for developers, and we won’t be able to provide a good IDE experience if we always start the build process from scratch.</p>

<h4 data-number="2.4.6.1.1" class="sigil_not_in_toc"><a id="x1-1750001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Source code preamble</h4>
<p class="hidden">To gain insights into the ideas <a id="dx1-175001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>used to speed up AST building for modified documents, let’s examine a simple C++ program:</p>
<pre class="source-code">1 #include &lt;iostream&gt; 
 
2  
 
3 int main() { 
 

4   std::cout &lt;&lt; "Hello world!" &lt;&lt; std::endl; 
 

5   return 0; 
 
6 }</pre>
<p class="hidden"><a id="x1-175009r37" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-175010" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.37</strong>: C++ program: helloworld.cpp </p>
<p class="hidden">The program has six lines of code, but the conclusion can be deceptive. The <code class="calibre13">#</code><code class="calibre13">include</code> directive inserts a lot of additional code. We can estimate the amount of code inserted by the preprocessor if we run Clang with the <code class="calibre13">-E </code>command-line option and calculate the number of lines, as follows:</p>
<pre id="verbatim-120" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang -E helloworld.cpp | wc -l
36215 </pre>
<p class="hidden"><a id="x1-175011r38" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-175012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.38</strong>: Number of lines in the post-processed program </p>
<p class="hidden">where <code class="calibre13">&lt;...&gt; </code>is the folder where llvm-project was cloned; see <a href="B19722_01.xhtml#x1-25005r1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.1</a>.</p>
<p class="hidden">As we can see, the code that <a id="dx1-175013" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>should be parsed contains more than 36,000 lines of code. This is a common pattern, and the majority of the code to be compiled is inserted from included headers. The part of the document located at the beginning of the source file and containing the include <a id="dx1-175014" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>directives is called the <strong class="calibre12">preamble</strong>.</p>
<p class="hidden">It’s worth noting that preamble modifications are possible but rare, for instance, when we insert a new header. The majority of the modifications are located in the code outside the preamble.</p>
<p class="hidden">The primary idea for performance optimization is to cache the preamble AST and reuse it for any compilation of a modified document.</p>


<h4 data-number="2.4.6.1.2" class="sigil_not_in_toc"><a id="x1-1760001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>AST build at Clangd</h4>
<p class="hidden">The performance optimization made in Clangd involves a two-part compilation process. In the first part, the preamble that contains all included header files is compiled into a precompiled header; see <a href="B19722_10.xhtml#x1-1920002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 10.2</em></a><em class="calibre11">, Precompiled headers</em>. This precompiled header is then used in the second stage of the compilation process to build the AST.</p>
<p class="hidden">This complex process serves as a <a id="dx1-176001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>performance optimization, especially when a user makes changes to a file that requires recompilation. Although a significant portion of compilation time is spent on header files, these files are typically not modified frequently. To address this, Clangd caches the AST for header files within the precompiled header file.</p>
<p class="hidden">As a result, when modifications are <a id="dx1-176002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>made outside header files, Clangd does not need to rebuild them from scratch. Instead, it can reuse the cached AST for headers, significantly improving compilation performance and reducing the time needed for recompilation when working with header files. If a user modification affects header files, then the entire AST should be rebuilt, resulting in a cache miss in such cases. It’s worth noting that modifications to headers are not as common as modifications to the primary source code (outside the included headers). Therefore, we can expect a pretty good cache hit rate for ordinary document modifications.</p>
<p class="hidden">The precompiled header can be stored on a disk as a temporary file but can also reside in memory, which can also be considered a performance optimization.</p>
<p class="hidden">The cached preamble is a powerful tool that significantly improves Clangd’s performance in processing document changes made by a user. On the other hand, we should always consider edge cases that involve preamble modification. The preamble can be modified in two main ways:</p>
<ol class="calibre6">
<li class="calibre7"><div><p class="calibre15"><strong class="calibre12">Explicitly</strong>: When the user explicitly modifies the preamble, for instance, by inserting a new header into it or deleting an existing one</p>
</div></li>
<li class="calibre7"><div><p class="calibre15"><strong class="calibre12">Implicitly</strong>: When the user implicitly modifies the preamble, for instance, by modifying the headers that are included in the preamble</p>
</div></li>
</ol>
<p class="hidden">The first one can be easily detected via a <code class="calibre13">"textDocument/didChange"</code> notification that affects the range where the preamble is located. The second one is tricky, and Clangd should monitor <a id="dx1-176007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the modifications in <a id="dx1-176008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the included headers to correctly process navigation requests.</p>
<p class="hidden">Clangd also has some modifications aimed at making preamble compilation faster. Some of these modifications required specific processing in Clang. Let’s delve into it in detail. <a id="x1-176009r540" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>



<h3 data-number="2.4.6.2" id="sigil_toc_id_148" class="likesectionhead">8.6.2  <a id="x1-1770002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Building preamble optimization</h3>
<p class="hidden">An interesting optimization can be applied to function bodies. A function body can be considered an essential part of primary indexing because it contains symbols that a user can click on, such as getting a <a id="dx1-177001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>definition for the symbol. This primarily applies to function bodies that are visible to the user in the IDE. On the other hand, many functions and their implementations (bodies) are hidden from the user in included headers. As a result, the user cannot request information <a id="dx1-177002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>about symbols from such function bodies. However, these bodies are visible to the compiler because it resolves include directives and parses the header files from the directives. The time spent by the compiler can be significant, considering that a complex project can have numerous dependencies, resulting in many header files being included in the document opened by the user. One obvious optimization is to skip function bodies when parsing header files from the preamble. This can be achieved using a special frontend option:</p>
<pre id="listing-74" class="source-code">/// FrontendOptions - Options for controlling the behavior of the frontend. 
 

class FrontendOptions { 
 
  ... 
 
  /// Skip over function bodies to speed up parsing in cases where you do not need 
 

  /// them (e.g., with code completion). 
 

  unsigned SkipFunctionBodies : 1;</pre>
<pre id="listing-75" class="source-code">  ... 
 
};</pre>
<p class="hidden"><a id="x1-177011r39" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-177012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.39</strong>: The FrontendOptions class from clang/Frontend/FrontendOptions.h </p>
<p class="hidden">Clangd utilizes <a id="dx1-177013" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>this option when building the <a id="dx1-177014" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>preamble in the following manner:</p>
<pre id="listing-76" class="source-code">1std::shared_ptr&lt;const PreambleData&gt; 
 

2 buildPreamble(PathRef FileName, CompilerInvocation CI, 
 

3               const ParseInputs &amp;Inputs, bool StoreInMemory, 
 

4               PreambleParsedCallback PreambleCallback, 
 

5               PreambleBuildStats *Stats) { 
 
6   ... 
 

7   // Skip function bodies when building the preamble to speed up building 
 

8   // the preamble and make it smaller. 
 

9   assert(!CI.getFrontendOpts().SkipFunctionBodies); 
 

10   CI.getFrontendOpts().SkipFunctionBodies = true; 
 

11   ... 
 
12   auto BuiltPreamble = PrecompiledPreamble::Build(...); 
 

13   ... 
 
14   // When building the AST for the main file, we do want the function 
 

15   // bodies. 
 
16   CI.getFrontendOpts().SkipFunctionBodies = false; 
 

17   ... 
 
18 };</pre>
<p class="hidden"><a id="x1-177033r40" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-177034" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 8.40</strong>: buildPreamble from clang-tools-extra/clangd/Preamble.cpp </p>
<p class="hidden">As we can see, Clangd uses the frontend option to skip function bodies in headers but disables it just before building the AST for the main document; see <em class="calibre11">Lines 10</em> <em class="calibre11">and 16 </em>in <a href="#x1-177033r40" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 8.40</a>.</p>
<p class="hidden">Such optimization <a id="dx1-177035" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>can significantly improve the document readiness time (when the opened document is ready for navigation requests from the user) for complex C++ source files.</p>
<p class="hidden">While the performance optimizations <a id="dx1-177036" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>discussed here offer valuable insights into Clangd’s efficiency, it’s important to note that Clangd employs a multitude of other techniques to ensure its reliability and speed. Clangd serves as an excellent platform for experimenting with and implementing various optimization strategies, making it a versatile environment for performance enhancements and innovations. <a id="x1-177037r539" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>



<h2 data-number="2.4.7" id="sigil_toc_id_149" class="likechapterhead">8.7  <a id="x1-1780007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Summary</h2>
<p class="hidden">In this chapter, we acquired knowledge of LSP, a protocol used to provide developer tools integration with IDEs. We explored Clangd, an LSP server that is part of LLVM and can be considered as a prime example of how it integrates various tools discussed in the book. Clangd utilizes the Clang frontend to display compilation errors and leverages the AST as a fundamental data structure that provides information for navigation requests, such as go-to definition requests. Additionally, Clangd is seamlessly integrated with other tools covered in previous chapters, such as Clang-Tidy and Clang-Format. This integration showcases the significant benefits of the LLVM/Clang module structure. <a id="x1-178001r549" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h2 data-number="2.4.8" id="sigil_toc_id_150" class="likechapterhead">8.8  <a id="x1-1790008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Further reading</h2>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">Language Server Protocol specification: <a href="https://microsoft.github.io/language-server-protocol/" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://microsoft.github.io/language-server-protocol/</a></p></li>
<li class="calibre14"><p class="calibre15">Clangd documentation: <a href="https://clangd.llvm.org/" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://clangd.llvm.org/</a></p></li>
</ul>
<p class="hidden"><a id="x1-179001r303" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


</div>
</div>
</body></html>