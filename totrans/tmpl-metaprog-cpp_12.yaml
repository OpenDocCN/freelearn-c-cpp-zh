- en: '*Chapter 9*: The Ranges Library'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous chapter was dedicated to understanding the three main pillars
    of the standard library: containers, iterators, and algorithms. Throughout that
    chapter, we used the abstract concept of range to represent a sequence of elements
    delimited by two iterators. The C++20 standard makes it easier to work with ranges
    by providing a ranges library, consisting of two main parts: on one hand, types
    that define non-owning ranges and adaptations of ranges, and on the other hand,
    algorithms that work with these range types and do not require iterators to define
    a range of elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this final chapter, we will address the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving from abstract ranges to the ranges library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding range concepts and views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the constrained algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own range adaptor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good understanding of the content
    of the ranges library and you will be able to write your own range adaptor.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin the chapter with a transition from the abstract concept of a range
    to the C++20 ranges library.
  prefs: []
  type: TYPE_NORMAL
- en: Advancing from abstract ranges to the ranges library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have used the term *range* many times in the previous chapter. A `std::vector`,
    `std::list`, and `std::map` are concrete implementations of the range abstraction.
    They have ownership of the elements and they are implemented using various data
    structures, such as arrays, linked-lists, or trees. The standard algorithms are
    generic. They are container-agnostic. They know nothing about `std::vector`, `std::list`,
    or `std::map`. They handle range abstractions with the help of iterators. However,
    this has a shortcoming: we always need to retrieve a beginning and end iterator
    from a container. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are few cases when you need to process only a part of the container’s
    elements. In the vast majority of cases, you just have to write `v.begin()` and
    `v.end()` over and over again. This includes variations such as calls to `cbegin()`/`cend()`,
    `rbegin()`/`rend()`, or the stand-alone functions `std::begin()`/`std::end()`,
    and so on. Ideally, we would prefer to shorten all this and be able to write the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, we often need to compose operations. Most of the time that
    involves many operations and code that is too verbose even when using standard
    algorithms. Let’s consider the following example: given a sequence of integers,
    we want to print to the console the square of all even numbers, except the first
    two, in descending order of their value (not their position in the sequence).
    There are multiple ways to solve the problem. The following is a possible solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'I believe most people would agree that, although anyone familiar with the standard
    algorithms can easily read this code, it’s still a lot to write. It also requires
    a temporary container and repetitive calls to `begin`/`end`. Therefore, I also
    expect most people would more easily understand the following version of the previous
    code, and probably prefer to write it as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the C++20 standard provides with the help of the ranges library.
    This has two main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Views** or **range adaptors**, which represent non-owning iterable sequences.
    They enable us to compose operations more easily such as in the last example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constrained algorithms**, which enable us to operate on concrete ranges (standard
    containers or ranges) and not on abstract ranges delimited with a pair of iterators
    (although that’s possible too).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore these two offerings of the ranges library in the next sections,
    and we will begin with ranges.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding range concepts and views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term *range* refers to an abstraction that defines a sequence of elements
    bounded by start and end iterators. A range, therefore, represents an iterable
    sequence of elements. However, such a sequence can be defined in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: With a begin iterator and an end sentinel. Such a sequence is iterated from
    the beginning to the end. A **sentinel** is an object that indicates the end of
    the sequence. It can have the same type as the iterator type or it can be of a
    different type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a start object and a size (number of elements), representing a so-called
    counted sequence. Such a sequence is iterated *N* times (where *N* represents
    the size) from the start.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a start and a predicate, representing a so-called conditionally terminated
    sequence. Such a sequence is iterated from the start until the predicate returns
    false.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With only a start value, representing a so-called unbounded sequence. Such a
    sequence can be iterated indefinitely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these kinds of iterable sequences are considered ranges. Because a range
    is an abstraction, the C++20 library defines a series of concepts to describe
    requirements for range types. These are available in the `<ranges>` header and
    the `std::ranges` namespace. The following table presents the list of range concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.1](img/Table_9.01_B18367.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 9.1
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library defines a series of access functions for containers and
    arrays. These include `std::begin` and `std::end` instead of member functions
    `begin` and `end`, `std::size` instead of member function `size`, and so on. These
    are called `<ranges>` and `<iterator>` headers and the `std::ranges` namespace.
    They are listed in the next table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.2](img/Table_9.02_B18367.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 9.2
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of some of these functions is demonstrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we used a type called `std::views::iota`. As the namespace
    implies, this is a view. A **view** is a range with additional restrictions. Views
    are lightweight objects with non-owning semantics. They present a view of an underlying
    sequence of elements (a range) in a way that does not require copying or mutating
    the sequence. The key feature is lazy evaluation. That means that regardless of
    the transformation they apply, they perform it only when an element is requested
    (iterated) and not when the view is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a series of views provided with C++20, and new views have been also
    included in C++23\. Views are available in the `<ranges>` header and `std::ranges`
    namespace in the form, `std::ranges::abc_view`, such as `std::ranges::iota_view`.
    However, for convenience of use, in the `std::views` namespace, a variable template
    of the form, `std::views::abc`, such as `std::views::iota`, also exists. This
    is what we saw in the previous example. Here are two equivalent examples for using
    `iota`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iota` view is part of a special category of views called **factories**.
    These factories are views over newly generated ranges. The following factories
    are available in the ranges library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.3](img/Table_9.03_B18367.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 9.3
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are wondering why `empty_view` and `single_view` are useful, the answer
    should not be hard to find. These are useful in template code that handles ranges
    where empty ranges or ranges with one element are valid inputs. You don’t want
    multiple overloads of a function template for handling these special cases; instead,
    you can pass an `empty_view` or `single_view` range. The following snippets show
    several examples of using these factories. These snippets should be self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'For `iota_view`, we have already seen a couple of examples with a bounded view.
    The next snippet shows again an example not only using a bounded view generated
    with `iota` but also an unbounded view, also generated with `iota`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This last example utilizes another view called `take_view`. This produces a
    view of the first *N* elements (in our example, `9`) of another view (in our case,
    the unbounded view produced with `iota`). We will discuss more about this shortly.
    But first, let’s take an example using the fourth view factory, `basic_iostream_view`.
    Let’s consider we have a list of article prices in a text, separated by a space.
    We need to print the total sum of these prices. There are different ways to solve
    it, but a possible solution is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted part can be replaced with the following two lines of code that
    use `basic_iostream_view` or, more precisely, the `istream_view` alias template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'What the `istream_view` range factory is doing is applying the operator `>>`
    repeatedly on the `istringstream` object and producing a value each time it is
    applied. You cannot specify a delimiter; it only works with whitespaces. If you
    prefer to use standard algorithms rather than handcrafted loops, you can use the
    `ranges::for_each` constrained algorithm to produce the same result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The examples given so far in this chapter included views such as `filter`,
    `take`, `drop`, and `reverse`. These are just a few of the standard views available
    in C++20\. More are being added to C++23, and probably even more to future standard
    versions. The entire set of standard views is listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.4](img/Table_9.04a_B18367.jpg)![Table 9.4](img/Table_9.04b_B18367.jpg)![Table
    9.4](img/Table_9.04c_B18367.jpg)![Table 9.4](img/Table_9.04d_B18367.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 9.4
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the views (range adaptors) listed in the previous table, there are
    a few more that can be useful in some particular scenarios. For completeness,
    these are listed in the next table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.5'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_9.05a_B18367.jpg)![Table 9.5'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_9.05b_B18367.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.5
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have enumerated all the standard range adaptors, let’s take a look
    at more examples using some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring more examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Previously, in this section, we saw the following example (this time with explicit
    namespaces):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually the shorter and more readable version of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The first version is possible because the pipe operator (`|`) is overloaded
    to simplify the composition of views in a more human-readable form. Some range
    adaptors take one argument, and some may take multiple arguments. The following
    rules apply:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a range adaptor `A` takes one argument, a view `V`, then `A(V)` and `V|A`
    are equivalent. Such a range adaptor is `reverse_view`, and an example is shown
    here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If a range adaptor `A` takes multiple arguments, a view `V` and `args…`, then
    `A(V, args…)`, `A(args…)(V)`, and `V|A(args…)` are equivalent. Such a range adaptor
    is `take_view`, and an example is shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So far, we have seen the likes of `filter`, `transform`, `reverse`, and `drop`
    put to use. To complete this part of the chapter, let’s take a series of examples
    to demonstrate the use of the views from *Table 8.7*. In all the following examples,
    we will consider `rv` as an alias for the `std::ranges::views` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the last two odd numbers from a sequence, in reverse order:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the subsequence of consecutive numbers smaller than 10 from a range that
    does not include the first consecutive odd numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the first elements, the second elements, and, respectively, the third
    elements from a sequence of tuples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print all the elements from a vector of vectors of integers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print all the elements from a vector of vectors of integers but insert a 0
    between the elements of each vector. The range adaptor `join_with` is new to C++23
    and may not be supported yet by compilers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the individual words from a sentence, where the delimited is a space:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a view of tuples from the elements of an array of integers and a vector
    of doubles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a view with the multiplied elements of an array of integers and a vector
    of doubles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the pairs of adjacent elements of a sequence of integers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the values obtained from multiplying each three consecutive values from
    a sequence of integers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These examples will hopefully help you understand the possible use cases for
    each of the available views. You can find more examples in the source code accompanying
    the book, as well as in the articles mentioned in the *Further reading* section.
    In the next section, we will discuss the other part of the ranges library, the
    constrained algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the constrained algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard library provides over one hundred general-purpose algorithms.
    As we discussed in the introductory section for the ranges library earlier, these
    have one thing in common: they work with abstract ranges with the help of iterators.
    They take iterators as arguments and they sometimes return iterators. That makes
    it cumbersome to repeatedly use with standard containers or arrays. Here is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we have a vector `v` and an array `arr`, and we copy the odd
    elements from each of these two to a second vector, `o`. For this, the `std::copy_if`
    algorithm is used. This takes begin and end input iterators (defining the input
    range), an output iterator to a second range, where the copied elements will be
    inserted, and a unary predicate (in this example, a lambda expression). What it
    returns is an iterator to the destination range past the last copied element.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the declaration of the `std::copy_if` algorithm, we will find
    the following two overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The first overload is the one used and described here. The second overload was
    introduced in C++17\. This allows you to specify an execution policy such as parallel
    or sequential. This basically enables the parallel execution of the standard algorithms.
    However, this is not relevant to the topic of this chapter, and we will not explore
    it further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the standard algorithms have a new constrained version in the `std::ranges`
    namespace. These algorithms are found in the `<algorithm>`, `<numeric>`, and `<memory>`
    headers and have the following traits:'
  prefs: []
  type: TYPE_NORMAL
- en: They have the same name as the existing algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have overloads that allow you to specify a range, either with a begin iterator
    and an end sentinel, or as a single range argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have modified return types that provide more information about the execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They support projections to apply to the processed elements. A **projection**
    is an entity that can be invoked. It can be a pointer to a member, a lambda expression,
    or a function pointer. Such a projection is applied to the range element *before*
    the algorithm logic uses the element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how the overloads of the `std::ranges::copy_if` algorithm are declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'If these seem more difficult to read, it is because they have more arguments,
    constraints, and longer type names. The good part, however, is that they make
    the code easier to write. Here is the previous snippet rewritten to use `std::ranges::copy_if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'These examples show two things: how to copy elements from a `std::vector` object
    and an array and how to copy elements from a view (a range adaptor). What they
    don’t show is projections. This was briefly mentioned earlier. We’ll discuss it
    with more details and examples here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A projection is an invocable entity. It’s basically a function adaptor. It
    affects the predicate, providing a way to perform function composition. It does
    not provide a way to change the algorithm. For instance, let’s say we have the
    following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, for the purpose of the explanation, let’s also consider the following
    sequence of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'Projections allow you to perform composition on the predicate. For instance,
    let’s say we want to copy to a second vector all the items whose names begin with
    the letter *p*. We can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can also write the following equivalent example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: The projection, in this example, is the pointer-to-member expression `&Item::name`
    that is applied to each `Item` element before executing the predicate (which is
    a lambda expression here). This can be useful when you already have reusable function
    objects or lambda expressions and you don’t want to write another one for passing
    different types of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'What projects cannot be used for, in this manner, is transforming a range from
    one type into another. For instance, you cannot just copy the names of the items
    from `std::vector<Item>` to `std::vector<std::string>`. This requires the use
    of the `std::ranges::transform` range adaptor, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: There are many constrained algorithms, but we will not list them here. Instead,
    you can check them all either directly in the standard, or on the [https://en.cppreference.com/w/cpp/algorithm/ranges](https://en.cppreference.com/w/cpp/algorithm/ranges)
    page.
  prefs: []
  type: TYPE_NORMAL
- en: The last topic that we’ll address in this chapter is writing a custom range
    adaptor.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own range adaptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard library contains a series of range adaptors that can be used for
    solving many different tasks. More are being added in newer versions of the standard.
    However, there can be situations when you’d like to create your own range adaptor
    to use with others from the range library. This is not actually a trivial task.
    For this reason, in this final section of the chapter, we will explore the steps
    you need to follow to write such a range adaptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we will consider a range adaptor that takes every *Nth* element
    of a range and skips the others. We will call this adaptor `step_view`. We can
    use it to write code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: The first loop will print all the numbers from one to nine. The second loop
    will print all the odd numbers, 1, 3, 5, 7, 9\. The third loop will print 1, 4,
    7\. Lastly, the fourth loop will print 1, 3, 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this possible, we need to implement the following entities:'
  prefs: []
  type: TYPE_NORMAL
- en: A class template that defines the range adaptor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A deduction guide to help with class template argument deduction for the range
    adaptor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class template that defines the iterator type for the range adaptor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class template that defines the sentinel type for the range adaptor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overloaded pipe operator (`|`) and helper functors, required for its implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A compile-time constant global object to simplify the use of the range adaptor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take them one by one and learn how to define them. We’ll start with the
    sentinel class. A **sentinel** is an abstraction of a past-the-end iterator. It
    allows us to check whether an iteration reached the end of a range. A sentinel
    makes it possible for the end iterator to have a different type than the range
    iterators. Sentinels cannot be dereferenced or incremented. Here is how it can
    be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'The sentinel is constructed from an iterator and contains a member function
    called `is_at_end` that checks whether the stored range iterator is equal to the
    range iterator stored in a `step_iterator` object. This type, `step_iterator`,
    is a class template that defines the iterator type for our range adaptor, which
    we call `step_view`. Here is an implementation of this iterator type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'This type must have several members:'
  prefs: []
  type: TYPE_NORMAL
- en: The alias template called `base` that represents the type of the underlying
    range iterator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The alias template called `value_type` that represents the type of elements
    of an underlying range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overloaded operators `++` and `*`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overloaded operator `==` compares this object with a sentinel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of the `++` operator uses the `std::ranges::next` constrained
    algorithm to increment an iterator with *N* positions, but not past the end of
    the range.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the `step_iterator` and `step_sentinel` pair for the `step_view`
    range adaptor, you must make sure this pair is actually well-formed. For this,
    we must ensure that the `step_iterator` type is an input iterator, and that the
    `step_sentinel` type is indeed a sentinel type for the `step_iterator` type. This
    can be done with the help of the following `static_assert` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: 'The `step_iterator` type is used in the implementation of the `step_view` range
    adaptor. At a minimum, this could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a pattern that must be followed when defining a range adaptor. This
    pattern is represented by the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: The class template must have a template argument that meets the `std::ranges::view`
    concept.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class template should be derived from `std::ranges:view_interface`. This
    takes a template argument itself and that should be the range adaptor class. This
    is basically an implementation of the CRTP that we learned about in [*Chapter
    7*](B18367_07_ePub.xhtml#_idTextAnchor123), *Patterns and Idioms*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class must have a default constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class must have a `base` member function that returns the underlying range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class must have a `begin` member function that returns an iterator to the
    first element in the range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class must have an `end` member function that returns either an iterator
    to the one-past-the-last element of the range or a sentinel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For ranges that meet the requirements of the `std::ranges::sized_range` concept,
    this class must also contain a member function called `size` that returns the
    number of elements in the range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to make it possible to use class template argument deduction for the
    `step_view` class, a user-defined deduction guide should be defined. These were
    discussed in [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064), *Advanced Template
    Concepts*. Such a guide should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make it possible to compose this range adaptor with others using
    the pipe iterator (`|`), this operator must be overloaded. However, we need some
    helper function object, which is shown in the next listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: The `step_view_fn_closure` class is a function object that stores a value representing
    the number of elements to skip for each iterator. Its overloaded call operator
    takes a range as an argument and returns a `step_view` object created from the
    range and the value for the number of steps to jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we want to make it possible to write code in a similar manner to what
    is available in the standard library, which provides a compile-time global object
    in the `std::views` namespace for each range adaptor that exists. For instance,
    instead of `std::ranges::transform_view`, you could use `std::views::transform`.
    Similarly, instead of `step_view` (in some namespace), we want to have an object,
    `views::step`. To do so, we need yet another function object, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: 'The `step_view_fn` type is a function object that has two overloads for the
    call operator: one takes a range and an integer and returns a `step_view` object,
    and the other takes an integer and returns a closure for this value, or, more
    precisely, an instance of `step_view_fn_closure` that we saw earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: Having all these implemented, we can successfully run the code shown at the
    beginning of this section. We have completed the implementation of a simple range
    adaptor. Hopefully, this should give you a sense of what writing range adaptors
    takes. The ranges library is significantly complex when you look at the details.
    In this chapter, you have learned some basics about the content of the library,
    how it can simplify your code, and how you can extend it with custom features.
    This knowledge should be a starting point for you should you want to learn more
    using other resources.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter of the book, we explored the C++20 ranges library. We
    started the discussion with a transition from the abstract concept of a range
    to the new ranges library. We learned about the content of this library and how
    it can help us write simpler code. We focused the discussion on range adapters
    but also looked at constrained algorithms. At the end of the chapter, we learned
    how to write a custom range adaptor that can be used in combination with standard
    adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a range?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a view in the range library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are constrained algorithms?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a sentinel?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you check that a sentinel type corresponds to an iterator type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*A beginner’s guide to C++ Ranges and Views*, Hannes Hauswedell, [https://hannes.hauswedell.net/post/2019/11/30/range_intro/](https://hannes.hauswedell.net/post/2019/11/30/range_intro/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tutorial: Writing your first view from scratch (C++20/P0789)*, Hannes Hauswedell,
    [https://hannes.hauswedell.net/post/2018/04/11/view1/](https://hannes.hauswedell.net/post/2018/04/11/view1/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C++20 Range Adaptors and Range Factories*, Barry Revzin, [https://brevzin.github.io/c++/2021/02/28/ranges-reference/](https://brevzin.github.io/c++/2021/02/28/ranges-reference/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Implementing a better views::split*, Barry Revzin, [https://brevzin.github.io/c++/2020/07/06/split-view/](https://brevzin.github.io/c++/2020/07/06/split-view/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Projections are Function Adaptors*, Barry Revzin, [https://brevzin.github.io/c++/2022/02/13/projections-function-adaptors/](https://brevzin.github.io/c++/2022/02/13/projections-function-adaptors/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tutorial: C++20’s Iterator Sentinels*, Jonathan Müller, [https://www.foonathan.net/2020/03/iterator-sentinel/](https://www.foonathan.net/2020/03/iterator-sentinel/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Standard Ranges*, Eric Niebrel, [https://ericniebler.com/2018/12/05/standard-ranges/](https://ericniebler.com/2018/12/05/standard-ranges/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Zip*, Tim Song, [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*From range projections to projected ranges*, Oleksandr Koval, [https://oleksandrkvl.github.io/2021/10/11/projected-ranges.html](https://oleksandrkvl.github.io/2021/10/11/projected-ranges.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Item 30 - Create custom composable views*, Wesley Shillingford, [https://cppuniverse.com/EverydayCpp20/RangesCustomViews](https://cppuniverse.com/EverydayCpp20/RangesCustomViews)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A custom C++20 range view*, Marius Bancila, [https://mariusbancila.ro/blog/2020/06/06/a-custom-cpp20-range-view/](https://mariusbancila.ro/blog/2020/06/06/a-custom-cpp20-range-view/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*New C++23 Range Adaptors*, Marius Bancila, [https://mariusbancila.ro/blog/2022/03/16/new-cpp23-range-adaptors/](https://mariusbancila.ro/blog/2022/03/16/new-cpp23-range-adaptors/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C++ Code Samples Before and After Ranges*, Marius Bancila, [https://mariusbancila.ro/blog/2019/01/20/cpp-code-samples-before-and-after-ranges/](https://mariusbancila.ro/blog/2019/01/20/cpp-code-samples-before-and-after-ranges/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
