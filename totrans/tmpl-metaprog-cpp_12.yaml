- en: '*Chapter 9*: The Ranges Library'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：范围库'
- en: 'The previous chapter was dedicated to understanding the three main pillars
    of the standard library: containers, iterators, and algorithms. Throughout that
    chapter, we used the abstract concept of range to represent a sequence of elements
    delimited by two iterators. The C++20 standard makes it easier to work with ranges
    by providing a ranges library, consisting of two main parts: on one hand, types
    that define non-owning ranges and adaptations of ranges, and on the other hand,
    algorithms that work with these range types and do not require iterators to define
    a range of elements.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章致力于理解标准库的三个主要支柱：容器、迭代器和算法。在整个章节中，我们使用了范围这个抽象概念来表示由两个迭代器分隔的元素序列。C++20 标准通过提供一个范围库来简化与范围的工作，该库由两个主要部分组成：一方面，定义非拥有范围和范围适配器的类型，另一方面，与这些范围类型一起工作的算法，并且不需要迭代器来定义元素的范围。
- en: 'In this final chapter, we will address the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将讨论以下主题：
- en: Moving from abstract ranges to the ranges library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从抽象范围到范围库的过渡
- en: Understanding range concepts and views
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解范围概念和视图
- en: Understanding the constrained algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解约束算法
- en: Writing your own range adaptor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的范围适配器
- en: By the end of this chapter, you will have a good understanding of the content
    of the ranges library and you will be able to write your own range adaptor.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将很好地理解范围库的内容，并且能够编写自己的范围适配器。
- en: Let’s begin the chapter with a transition from the abstract concept of a range
    to the C++20 ranges library.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从范围这个抽象概念过渡到 C++20 范围库开始本章。
- en: Advancing from abstract ranges to the ranges library
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从抽象范围到范围库的进步
- en: 'We have used the term *range* many times in the previous chapter. A `std::vector`,
    `std::list`, and `std::map` are concrete implementations of the range abstraction.
    They have ownership of the elements and they are implemented using various data
    structures, such as arrays, linked-lists, or trees. The standard algorithms are
    generic. They are container-agnostic. They know nothing about `std::vector`, `std::list`,
    or `std::map`. They handle range abstractions with the help of iterators. However,
    this has a shortcoming: we always need to retrieve a beginning and end iterator
    from a container. Here are some examples:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们多次使用了术语 *范围*。`std::vector`、`std::list` 和 `std::map` 是范围抽象的具体实现。它们拥有元素的所有权，并且使用各种数据结构实现，例如数组、链表或树。标准算法是通用的。它们对容器不可知。它们对
    `std::vector`、`std::list` 或 `std::map` 一无所知。它们通过迭代器处理范围抽象。然而，这有一个缺点：我们总是需要从一个容器中检索开始和结束迭代器。以下是一些例子：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are few cases when you need to process only a part of the container’s
    elements. In the vast majority of cases, you just have to write `v.begin()` and
    `v.end()` over and over again. This includes variations such as calls to `cbegin()`/`cend()`,
    `rbegin()`/`rend()`, or the stand-alone functions `std::begin()`/`std::end()`,
    and so on. Ideally, we would prefer to shorten all this and be able to write the
    following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要仅处理容器部分元素的情况下很少。在绝大多数情况下，你只需要反复编写 `v.begin()` 和 `v.end()`。这包括 `cbegin()`/`cend()`、`rbegin()`/`rend()`
    或独立的函数 `std::begin()`/`std::end()` 等变体。理想情况下，我们希望缩短所有这些，并能够编写以下内容：
- en: '[PRE8]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On the other hand, we often need to compose operations. Most of the time that
    involves many operations and code that is too verbose even when using standard
    algorithms. Let’s consider the following example: given a sequence of integers,
    we want to print to the console the square of all even numbers, except the first
    two, in descending order of their value (not their position in the sequence).
    There are multiple ways to solve the problem. The following is a possible solution:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们经常需要组合操作。大多数时候，这涉及到许多操作和代码，即使使用标准算法，代码也过于冗长。让我们考虑以下示例：给定一个整数序列，我们想要按值（而不是位置）降序打印控制台上的所有偶数的平方，除了前两个。解决这个问题有多种方法。以下是一个可能的解决方案：
- en: '[PRE16]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'I believe most people would agree that, although anyone familiar with the standard
    algorithms can easily read this code, it’s still a lot to write. It also requires
    a temporary container and repetitive calls to `begin`/`end`. Therefore, I also
    expect most people would more easily understand the following version of the previous
    code, and probably prefer to write it as such:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信大多数人都会同意，尽管熟悉标准算法的任何人都可以轻松阅读此代码，但它仍然需要写很多。它还要求一个临时容器和重复调用 `begin`/`end`。因此，我也期待大多数人会更容易理解以下版本的先前代码，并且可能更喜欢这样编写：
- en: '[PRE34]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is what the C++20 standard provides with the help of the ranges library.
    This has two main components:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 C++20 标准借助范围库提供的功能。这有两个主要组成部分：
- en: '**Views** or **range adaptors**, which represent non-owning iterable sequences.
    They enable us to compose operations more easily such as in the last example.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图** 或 **范围适配器**，它们表示非拥有可迭代序列。这使得我们更容易组合操作，如最后一个示例所示。'
- en: '**Constrained algorithms**, which enable us to operate on concrete ranges (standard
    containers or ranges) and not on abstract ranges delimited with a pair of iterators
    (although that’s possible too).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**约束算法**，它使我们能够对具体范围（标准容器或范围）进行操作，而不是对由一对迭代器界定的抽象范围进行操作（尽管这也是可能的）。'
- en: We will explore these two offerings of the ranges library in the next sections,
    and we will begin with ranges.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中探讨范围库的这两个提供项，我们将从范围开始。
- en: Understanding range concepts and views
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解范围概念和视图
- en: 'The term *range* refers to an abstraction that defines a sequence of elements
    bounded by start and end iterators. A range, therefore, represents an iterable
    sequence of elements. However, such a sequence can be defined in several ways:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *范围* 指的是一个抽象概念，它定义了由起始和结束迭代器界定的元素序列。因此，范围代表了一个可迭代的元素序列。然而，这样的序列可以通过多种方式定义：
- en: With a begin iterator and an end sentinel. Such a sequence is iterated from
    the beginning to the end. A **sentinel** is an object that indicates the end of
    the sequence. It can have the same type as the iterator type or it can be of a
    different type.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用起始迭代器和结束哨兵。此类序列从起始位置迭代到结束位置。一个 **哨兵** 是一个指示序列结束的对象。它可以与迭代器类型相同，也可以是不同类型。
- en: With a start object and a size (number of elements), representing a so-called
    counted sequence. Such a sequence is iterated *N* times (where *N* represents
    the size) from the start.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用起始对象和大小（元素数量），表示所谓的计数序列。此类序列从起始位置迭代 *N* 次（其中 *N* 代表大小）。
- en: With a start and a predicate, representing a so-called conditionally terminated
    sequence. Such a sequence is iterated from the start until the predicate returns
    false.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用起始值和谓词，表示所谓的条件终止序列。此类序列从起始位置迭代，直到谓词返回 false。
- en: With only a start value, representing a so-called unbounded sequence. Such a
    sequence can be iterated indefinitely.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只使用起始值，表示所谓的无界序列。此类序列可以无限迭代。
- en: 'All these kinds of iterable sequences are considered ranges. Because a range
    is an abstraction, the C++20 library defines a series of concepts to describe
    requirements for range types. These are available in the `<ranges>` header and
    the `std::ranges` namespace. The following table presents the list of range concepts:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些可迭代序列都被视为范围。因为范围是一个抽象概念，C++20 库定义了一系列概念来描述范围类型的必要条件。这些概念可以在 `<ranges>` 头文件和
    `std::ranges` 命名空间中找到。下表展示了范围概念的列表：
- en: '![Table 9.1](img/Table_9.01_B18367.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![表 9.1](img/Table_9.01_B18367.jpg)'
- en: Table 9.1
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1
- en: 'The standard library defines a series of access functions for containers and
    arrays. These include `std::begin` and `std::end` instead of member functions
    `begin` and `end`, `std::size` instead of member function `size`, and so on. These
    are called `<ranges>` and `<iterator>` headers and the `std::ranges` namespace.
    They are listed in the next table:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库为容器和数组定义了一系列访问函数。这些包括 `std::begin` 和 `std::end` 而不是成员函数 `begin` 和 `end`，`std::size`
    而不是成员函数 `size` 等。这些被称为 `<ranges>` 和 `<iterator>` 头文件以及 `std::ranges` 命名空间。它们列在下一表中：
- en: '![Table 9.2](img/Table_9.02_B18367.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![表 9.2](img/Table_9.02_B18367.jpg)'
- en: Table 9.2
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.2
- en: 'The use of some of these functions is demonstrated in the following snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了这些函数的一些用法：
- en: '[PRE42]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this snippet, we used a type called `std::views::iota`. As the namespace
    implies, this is a view. A **view** is a range with additional restrictions. Views
    are lightweight objects with non-owning semantics. They present a view of an underlying
    sequence of elements (a range) in a way that does not require copying or mutating
    the sequence. The key feature is lazy evaluation. That means that regardless of
    the transformation they apply, they perform it only when an element is requested
    (iterated) and not when the view is created.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们使用了一种名为 `std::views::iota` 的类型。正如命名空间所暗示的，这是一个视图。**视图**是一个带有额外限制的范围。视图是轻量级对象，具有非拥有语义。它们以一种不需要复制或修改序列的方式呈现底层元素序列（范围）的视图。其关键特性是延迟评估。这意味着无论它们应用何种转换，它们仅在请求（迭代）元素时执行，而不是在创建视图时执行。
- en: 'There is a series of views provided with C++20, and new views have been also
    included in C++23\. Views are available in the `<ranges>` header and `std::ranges`
    namespace in the form, `std::ranges::abc_view`, such as `std::ranges::iota_view`.
    However, for convenience of use, in the `std::views` namespace, a variable template
    of the form, `std::views::abc`, such as `std::views::iota`, also exists. This
    is what we saw in the previous example. Here are two equivalent examples for using
    `iota`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 提供了一系列视图，C++23 也增加了新的视图。视图在 `<ranges>` 头文件和 `std::ranges` 命名空间中以 `std::ranges::abc_view`
    的形式提供，例如 `std::ranges::iota_view`。然而，为了使用方便，在 `std::views` 命名空间中，也存在形式为 `std::views::abc`
    的变量模板，例如 `std::views::iota`。这正是我们在上一个示例中看到的。以下是使用 `iota` 的两个等效示例：
- en: '[PRE55]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `iota` view is part of a special category of views called **factories**.
    These factories are views over newly generated ranges. The following factories
    are available in the ranges library:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`iota` 视图是称为 **工厂** 的特殊视图类别的一部分。这些工厂是新生成范围上的视图。以下是在范围库中可用的工厂：'
- en: '![Table 9.3](img/Table_9.03_B18367.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![表 9.3](img/Table_9.03_B18367.jpg)'
- en: Table 9.3
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.3
- en: 'If you are wondering why `empty_view` and `single_view` are useful, the answer
    should not be hard to find. These are useful in template code that handles ranges
    where empty ranges or ranges with one element are valid inputs. You don’t want
    multiple overloads of a function template for handling these special cases; instead,
    you can pass an `empty_view` or `single_view` range. The following snippets show
    several examples of using these factories. These snippets should be self-explanatory:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么 `empty_view` 和 `single_view` 有用，答案应该不难找到。这些在处理空范围或只有一个元素的范围的模板代码中很有用。你不想为处理这些特殊情况有多个函数模板的重载；相反，你可以传递一个
    `empty_view` 或 `single_view` 范围。以下是一些使用这些工厂的示例片段。这些片段应该是自解释的：
- en: '[PRE61]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'For `iota_view`, we have already seen a couple of examples with a bounded view.
    The next snippet shows again an example not only using a bounded view generated
    with `iota` but also an unbounded view, also generated with `iota`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `iota_view`，我们已经看到了一些使用有界视图的示例。下一个片段再次展示了不仅使用由 `iota` 生成的有界视图，还使用由 `iota`
    生成的无界视图的示例：
- en: '[PRE69]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This last example utilizes another view called `take_view`. This produces a
    view of the first *N* elements (in our example, `9`) of another view (in our case,
    the unbounded view produced with `iota`). We will discuss more about this shortly.
    But first, let’s take an example using the fourth view factory, `basic_iostream_view`.
    Let’s consider we have a list of article prices in a text, separated by a space.
    We need to print the total sum of these prices. There are different ways to solve
    it, but a possible solution is given here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例利用了另一个名为 `take_view` 的视图。它产生另一个视图的前 *N* 个元素（在我们的例子中，是 `9`）的视图（在我们的情况下，是使用
    `iota` 产生的无界视图）。我们将在稍后讨论更多关于这个话题的内容。但首先，让我们用一个示例来使用第四个视图工厂，`basic_iostream_view`。让我们考虑我们有一个文本中的文章价格列表，这些价格由空格分隔。我们需要打印这些价格的总和。有不同方法可以解决这个问题，但这里给出了一种可能的解决方案：
- en: '[PRE78]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The highlighted part can be replaced with the following two lines of code that
    use `basic_iostream_view` or, more precisely, the `istream_view` alias template:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的部分可以用以下两行代码替换，这些代码使用 `basic_iostream_view` 或更精确地说，使用 `istream_view` 别名模板：
- en: '[PRE89]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'What the `istream_view` range factory is doing is applying the operator `>>`
    repeatedly on the `istringstream` object and producing a value each time it is
    applied. You cannot specify a delimiter; it only works with whitespaces. If you
    prefer to use standard algorithms rather than handcrafted loops, you can use the
    `ranges::for_each` constrained algorithm to produce the same result, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`istream_view` 范围工厂所做的是在 `istringstream` 对象上反复应用操作符 `>>`，每次应用都会产生一个值。您不能指定分隔符；它只与空白符一起工作。如果您更喜欢使用标准算法而不是手工编写的循环，可以使用
    `ranges::for_each` 限制算法以相同的方式产生结果，如下所示：'
- en: '[PRE94]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The examples given so far in this chapter included views such as `filter`,
    `take`, `drop`, and `reverse`. These are just a few of the standard views available
    in C++20\. More are being added to C++23, and probably even more to future standard
    versions. The entire set of standard views is listed in the following table:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中给出的示例包括了 `filter`、`take`、`drop` 和 `reverse` 等视图。这些只是 C++20 中可用的标准视图中的一小部分。C++23
    中正在添加更多，未来标准版本可能还会添加更多。以下表格列出了整个标准视图集：
- en: '![Table 9.4](img/Table_9.04a_B18367.jpg)![Table 9.4](img/Table_9.04b_B18367.jpg)![Table
    9.4](img/Table_9.04c_B18367.jpg)![Table 9.4](img/Table_9.04d_B18367.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![表 9.4](img/Table_9.04a_B18367.jpg)![表 9.4](img/Table_9.04b_B18367.jpg)![表
    9.4](img/Table_9.04c_B18367.jpg)![表 9.4](img/Table_9.04d_B18367.jpg)'
- en: Table 9.4
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.4
- en: 'Apart from the views (range adaptors) listed in the previous table, there are
    a few more that can be useful in some particular scenarios. For completeness,
    these are listed in the next table:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前表中列出的视图（范围适配器）之外，还有一些在其他特定场景中可能很有用的视图。为了完整性，这些视图列在下一个表中：
- en: '![Table 9.5'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 9.5'
- en: '](img/Table_9.05a_B18367.jpg)![Table 9.5'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_9.05a_B18367.jpg)![表 9.5'
- en: '](img/Table_9.05b_B18367.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_9.05b_B18367.jpg)'
- en: Table 9.5
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.5
- en: Now that we have enumerated all the standard range adaptors, let’s take a look
    at more examples using some of them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经列举了所有标准范围适配器，让我们看看使用其中一些的更多示例。
- en: Exploring more examples
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索更多示例
- en: 'Previously, in this section, we saw the following example (this time with explicit
    namespaces):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节之前，我们看到了以下示例（这次带有显式命名空间）：
- en: '[PRE98]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This is actually the shorter and more readable version of the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是以下内容的更简短、更易读的版本：
- en: '[PRE105]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The first version is possible because the pipe operator (`|`) is overloaded
    to simplify the composition of views in a more human-readable form. Some range
    adaptors take one argument, and some may take multiple arguments. The following
    rules apply:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个版本是可能的，因为管道操作符（`|`）被重载以简化以更易读的形式组合视图。一些范围适配器接受一个参数，而一些可能接受多个参数。以下规则适用：
- en: 'If a range adaptor `A` takes one argument, a view `V`, then `A(V)` and `V|A`
    are equivalent. Such a range adaptor is `reverse_view`, and an example is shown
    here:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果范围适配器 `A` 接受一个参数，一个视图 `V`，那么 `A(V)` 和 `V|A` 是等价的。这样的范围适配器是 `reverse_view`，以下是一个示例：
- en: '[PRE114]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'If a range adaptor `A` takes multiple arguments, a view `V` and `args…`, then
    `A(V, args…)`, `A(args…)(V)`, and `V|A(args…)` are equivalent. Such a range adaptor
    is `take_view`, and an example is shown here:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果范围适配器 `A` 接受多个参数，一个视图 `V` 和 `args…`，那么 `A(V, args…)`、`A(args…)(V)` 和 `V|A(args…)`
    是等价的。这样的范围适配器是 `take_view`，以下是一个示例：
- en: '[PRE115]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'So far, we have seen the likes of `filter`, `transform`, `reverse`, and `drop`
    put to use. To complete this part of the chapter, let’s take a series of examples
    to demonstrate the use of the views from *Table 8.7*. In all the following examples,
    we will consider `rv` as an alias for the `std::ranges::views` namespace:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了 `filter`、`transform`、`reverse` 和 `drop` 的应用。为了完成本章的这一部分，让我们通过一系列示例来展示
    *表 8.7* 中视图的使用。在所有以下示例中，我们将考虑 `rv` 作为 `std::ranges::views` 命名空间的别名：
- en: 'Print the last two odd numbers from a sequence, in reverse order:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以相反的顺序打印序列中的最后两个奇数：
- en: '[PRE116]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Print the subsequence of consecutive numbers smaller than 10 from a range that
    does not include the first consecutive odd numbers:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印一个范围中连续小于 10 的数字子序列，但不包括第一个连续的奇数：
- en: '[PRE117]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Print the first elements, the second elements, and, respectively, the third
    elements from a sequence of tuples:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印序列中的第一个元素、第二个元素，以及分别的第三个元素：
- en: '[PRE118]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Print all the elements from a vector of vectors of integers:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印整数向量向量的所有元素：
- en: '[PRE119]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Print all the elements from a vector of vectors of integers but insert a 0
    between the elements of each vector. The range adaptor `join_with` is new to C++23
    and may not be supported yet by compilers:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印整数向量向量的所有元素，但每个向量元素之间插入一个 0。范围适配器 `join_with` 是 C++23 中的新功能，可能尚未被编译器支持：
- en: '[PRE120]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Print the individual words from a sentence, where the delimited is a space:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个句子中打印出单独的单词，其中分隔符是空格：
- en: '[PRE121]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Create a view of tuples from the elements of an array of integers and a vector
    of doubles:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从整数数组和双精度浮点向量元素创建元组的视图：
- en: '[PRE122]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Create a view with the multiplied elements of an array of integers and a vector
    of doubles:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个由整数数组和双精度浮点向量元素相乘的元素的视图：
- en: '[PRE123]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Print the pairs of adjacent elements of a sequence of integers:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印整数序列相邻元素的配对：
- en: '[PRE124]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Print the values obtained from multiplying each three consecutive values from
    a sequence of integers:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印从整数序列中乘以每个三个连续值得到的结果：
- en: '[PRE125]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: These examples will hopefully help you understand the possible use cases for
    each of the available views. You can find more examples in the source code accompanying
    the book, as well as in the articles mentioned in the *Further reading* section.
    In the next section, we will discuss the other part of the ranges library, the
    constrained algorithms.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这些例子能帮助您理解每个可用视图的可能用例。您可以在本书的源代码中找到更多示例，以及在本节中提到的*进一步阅读*部分的文章中。在下一节中，我们将讨论
    ranges 库的另一个部分，即约束算法。
- en: Understanding the constrained algorithms
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解约束算法
- en: 'The standard library provides over one hundred general-purpose algorithms.
    As we discussed in the introductory section for the ranges library earlier, these
    have one thing in common: they work with abstract ranges with the help of iterators.
    They take iterators as arguments and they sometimes return iterators. That makes
    it cumbersome to repeatedly use with standard containers or arrays. Here is an
    example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了超过一百个通用算法。正如我们之前在 ranges 库的介绍部分所讨论的，它们有一个共同点：它们在迭代器的帮助下与抽象范围一起工作。它们接受迭代器作为参数，有时返回迭代器。这使得它们在标准容器或数组上重复使用变得繁琐。以下是一个例子：
- en: '[PRE126]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: In this snippet, we have a vector `v` and an array `arr`, and we copy the odd
    elements from each of these two to a second vector, `o`. For this, the `std::copy_if`
    algorithm is used. This takes begin and end input iterators (defining the input
    range), an output iterator to a second range, where the copied elements will be
    inserted, and a unary predicate (in this example, a lambda expression). What it
    returns is an iterator to the destination range past the last copied element.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们有一个向量 `v` 和一个数组 `arr`，我们将这两个中的奇数元素复制到一个第二个向量 `o` 中。为此，使用了 `std::copy_if`
    算法。它接受开始和结束输入迭代器（定义输入范围），一个输出迭代器到第二个范围，其中复制的元素将被插入，以及一个一元谓词（在这个例子中，是一个lambda表达式）。它返回的是指向目标范围中最后一个复制元素之后的迭代器。
- en: 'If we look at the declaration of the `std::copy_if` algorithm, we will find
    the following two overloads:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `std::copy_if` 算法的声明，我们将找到以下两个重载：
- en: '[PRE136]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The first overload is the one used and described here. The second overload was
    introduced in C++17\. This allows you to specify an execution policy such as parallel
    or sequential. This basically enables the parallel execution of the standard algorithms.
    However, this is not relevant to the topic of this chapter, and we will not explore
    it further.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重载是这里使用和描述的重载。第二个重载是在 C++17 中引入的。这允许您指定一个执行策略，如并行或顺序。这基本上使得标准算法的并行执行成为可能。然而，这与本章的主题无关，我们不会进一步探讨。
- en: 'Most of the standard algorithms have a new constrained version in the `std::ranges`
    namespace. These algorithms are found in the `<algorithm>`, `<numeric>`, and `<memory>`
    headers and have the following traits:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数标准算法在 `std::ranges` 命名空间中都有一个新约束版本。这些算法位于 `<algorithm>`、`<numeric>` 和 `<memory>`
    头文件中，并具有以下特性：
- en: They have the same name as the existing algorithms.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们与现有算法具有相同的名称。
- en: They have overloads that allow you to specify a range, either with a begin iterator
    and an end sentinel, or as a single range argument.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有重载，允许您指定一个范围，无论是使用开始迭代器和结束哨兵，还是作为一个单独的范围参数。
- en: They have modified return types that provide more information about the execution.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有修改后的返回类型，提供了关于执行更多信息的说明。
- en: They support projections to apply to the processed elements. A **projection**
    is an entity that can be invoked. It can be a pointer to a member, a lambda expression,
    or a function pointer. Such a projection is applied to the range element *before*
    the algorithm logic uses the element.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们支持投影以应用于处理后的元素。**投影**是一个可以调用的实体。它可以是一个成员指针、一个lambda表达式或函数指针。这样的投影在算法逻辑使用元素之前应用于范围元素。
- en: 'Here is how the overloads of the `std::ranges::copy_if` algorithm are declared:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何声明`std::ranges::copy_if`算法的重载的：
- en: '[PRE148]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'If these seem more difficult to read, it is because they have more arguments,
    constraints, and longer type names. The good part, however, is that they make
    the code easier to write. Here is the previous snippet rewritten to use `std::ranges::copy_if`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些看起来更难阅读，那是因为它们有更多的参数、约束和更长的类型名。然而，好处是它们使得代码更容易编写。以下是之前代码片段的重写，使用了`std::ranges::copy_if`：
- en: '[PRE170]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'These examples show two things: how to copy elements from a `std::vector` object
    and an array and how to copy elements from a view (a range adaptor). What they
    don’t show is projections. This was briefly mentioned earlier. We’ll discuss it
    with more details and examples here.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了两个事情：如何从`std::vector`对象和数组中复制元素，以及如何从视图（范围适配器）中复制元素。它们没有展示的是投影。这之前已经简要提到过。在这里，我们将更详细地讨论它，并提供更多示例。
- en: 'A projection is an invocable entity. It’s basically a function adaptor. It
    affects the predicate, providing a way to perform function composition. It does
    not provide a way to change the algorithm. For instance, let’s say we have the
    following type:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 投影是一个可调用的实体。它基本上是一个函数适配器。它影响谓词，提供了一种执行函数组合的方式。它不提供改变算法的方法。例如，假设我们有以下类型：
- en: '[PRE180]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Also, for the purpose of the explanation, let’s also consider the following
    sequence of elements:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了解释的目的，让我们也考虑以下元素序列：
- en: '[PRE186]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Projections allow you to perform composition on the predicate. For instance,
    let’s say we want to copy to a second vector all the items whose names begin with
    the letter *p*. We can write the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 投影允许你在谓词上执行组合。例如，假设我们想要将所有以字母*p*开头的项复制到第二个向量中。我们可以编写以下代码：
- en: '[PRE191]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'However, we can also write the following equivalent example:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以编写以下等效示例：
- en: '[PRE196]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: The projection, in this example, is the pointer-to-member expression `&Item::name`
    that is applied to each `Item` element before executing the predicate (which is
    a lambda expression here). This can be useful when you already have reusable function
    objects or lambda expressions and you don’t want to write another one for passing
    different types of arguments.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，投影是应用于每个`Item`元素并在执行谓词（这里是一个lambda表达式）之前应用的成员指针表达式`&Item::name`。这在你已经有可重用的函数对象或lambda表达式，并且不想为传递不同类型的参数编写另一个时非常有用。
- en: 'What projects cannot be used for, in this manner, is transforming a range from
    one type into another. For instance, you cannot just copy the names of the items
    from `std::vector<Item>` to `std::vector<std::string>`. This requires the use
    of the `std::ranges::transform` range adaptor, as shown in the following snippet:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，项目无法用于将范围从一种类型转换为另一种类型。例如，你不能直接将`std::vector<Item>`中的项的名称复制到`std::vector<std::string>`中。这需要使用`std::ranges::transform`范围适配器，如下面的代码片段所示：
- en: '[PRE202]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: There are many constrained algorithms, but we will not list them here. Instead,
    you can check them all either directly in the standard, or on the [https://en.cppreference.com/w/cpp/algorithm/ranges](https://en.cppreference.com/w/cpp/algorithm/ranges)
    page.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多受限算法，但在此我们不会列出它们。相反，你可以在标准中直接查看它们，或者在[https://en.cppreference.com/w/cpp/algorithm/ranges](https://en.cppreference.com/w/cpp/algorithm/ranges)页面上查看。
- en: The last topic that we’ll address in this chapter is writing a custom range
    adaptor.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的最后一个主题是编写自定义范围适配器。
- en: Writing your own range adaptor
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自己的范围适配器
- en: The standard library contains a series of range adaptors that can be used for
    solving many different tasks. More are being added in newer versions of the standard.
    However, there can be situations when you’d like to create your own range adaptor
    to use with others from the range library. This is not actually a trivial task.
    For this reason, in this final section of the chapter, we will explore the steps
    you need to follow to write such a range adaptor.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库包含一系列范围适配器，可用于解决许多不同的任务。在新版标准中，还在不断添加更多。然而，可能会有一些情况，你希望创建自己的范围适配器，以便与范围库中的其他适配器一起使用。这实际上并不是一个简单任务。因此，在本章的最后部分，我们将探讨编写此类范围适配器所需遵循的步骤。
- en: 'For this purpose, we will consider a range adaptor that takes every *Nth* element
    of a range and skips the others. We will call this adaptor `step_view`. We can
    use it to write code as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将考虑一个范围适配器，它取范围中的每个*Nth*元素并跳过其他元素。我们将把这个适配器称为`step_view`。我们可以用它来编写如下代码：
- en: '[PRE207]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: The first loop will print all the numbers from one to nine. The second loop
    will print all the odd numbers, 1, 3, 5, 7, 9\. The third loop will print 1, 4,
    7\. Lastly, the fourth loop will print 1, 3, 5.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个循环将打印从一到九的所有数字。第二个循环将打印所有奇数，1, 3, 5, 7, 9。第三个循环将打印 1, 4, 7。最后，第四个循环将打印 1,
    3, 5。
- en: 'To make this possible, we need to implement the following entities:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这成为可能，我们需要实现以下实体：
- en: A class template that defines the range adaptor
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义范围适配器的类模板
- en: A deduction guide to help with class template argument deduction for the range
    adaptor
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个推导指南，帮助进行范围适配器的类模板参数推导
- en: A class template that defines the iterator type for the range adaptor
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义范围适配器迭代器类型的类模板
- en: A class template that defines the sentinel type for the range adaptor
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义范围适配器哨兵类型的类模板
- en: An overloaded pipe operator (`|`) and helper functors, required for its implementation
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个重载的管道运算符 (`|`) 和辅助函数，这是其实现所必需的
- en: A compile-time constant global object to simplify the use of the range adaptor
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个编译时常量全局对象，用于简化范围适配器的使用
- en: 'Let’s take them one by one and learn how to define them. We’ll start with the
    sentinel class. A **sentinel** is an abstraction of a past-the-end iterator. It
    allows us to check whether an iteration reached the end of a range. A sentinel
    makes it possible for the end iterator to have a different type than the range
    iterators. Sentinels cannot be dereferenced or incremented. Here is how it can
    be defined:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一了解它们，并学习如何定义它们。我们将从哨兵类开始。**哨兵**是超出末尾迭代器的抽象。它允许我们检查迭代是否到达范围的末尾。哨兵使得末尾迭代器可以与范围迭代器具有不同的类型。哨兵不能解引用或增加。以下是它的定义方式：
- en: '[PRE216]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'The sentinel is constructed from an iterator and contains a member function
    called `is_at_end` that checks whether the stored range iterator is equal to the
    range iterator stored in a `step_iterator` object. This type, `step_iterator`,
    is a class template that defines the iterator type for our range adaptor, which
    we call `step_view`. Here is an implementation of this iterator type:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 哨兵从一个迭代器构建，并包含一个名为 `is_at_end` 的成员函数，该函数检查存储的范围迭代器是否等于存储在 `step_iterator` 对象中的范围迭代器。这种类型，`step_iterator`，是一个类模板，定义了我们的范围适配器的迭代器类型，我们称之为
    `step_view`。以下是此迭代器类型的实现：
- en: '[PRE236]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'This type must have several members:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型必须具有几个成员：
- en: The alias template called `base` that represents the type of the underlying
    range iterator.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `base` 的别名模板，表示底层范围迭代器的类型。
- en: The alias template called `value_type` that represents the type of elements
    of an underlying range.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `value_type` 的别名模板，表示底层范围元素的类型。
- en: The overloaded operators `++` and `*`.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载的运算符 `++` 和 `*`。
- en: The overloaded operator `==` compares this object with a sentinel.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载的运算符 `==` 将此对象与哨兵进行比较。
- en: The implementation of the `++` operator uses the `std::ranges::next` constrained
    algorithm to increment an iterator with *N* positions, but not past the end of
    the range.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`++` 运算符的实现使用了 `std::ranges::next` 限制性算法来增加一个具有 *N* 个位置的迭代器，但不会超出范围的末尾。'
- en: 'In order to use the `step_iterator` and `step_sentinel` pair for the `step_view`
    range adaptor, you must make sure this pair is actually well-formed. For this,
    we must ensure that the `step_iterator` type is an input iterator, and that the
    `step_sentinel` type is indeed a sentinel type for the `step_iterator` type. This
    can be done with the help of the following `static_assert` statements:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `step_iterator` 和 `step_sentinel` 对对 `step_view` 范围适配器，你必须确保这个对实际上是良好形成的。为此，我们必须确保
    `step_iterator` 类型是一个输入迭代器，并且 `step_sentinel` 类型确实是 `step_iterator` 类型的哨兵类型。这可以通过以下
    `static_assert` 语句来完成：
- en: '[PRE276]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: 'The `step_iterator` type is used in the implementation of the `step_view` range
    adaptor. At a minimum, this could look as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`step_iterator` 类型用于 `step_view` 范围适配器的实现。至少，它可能看起来如下：'
- en: '[PRE286]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: 'There is a pattern that must be followed when defining a range adaptor. This
    pattern is represented by the following aspects:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 定义范围适配器时必须遵循一个模式。这个模式由以下方面表示：
- en: The class template must have a template argument that meets the `std::ranges::view`
    concept.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类模板必须有一个模板参数，该参数满足 `std::ranges::view` 概念。
- en: The class template should be derived from `std::ranges:view_interface`. This
    takes a template argument itself and that should be the range adaptor class. This
    is basically an implementation of the CRTP that we learned about in [*Chapter
    7*](B18367_07_ePub.xhtml#_idTextAnchor123), *Patterns and Idioms*.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类模板应该从`std::ranges:view_interface`派生。它本身也接受一个模板参数，这应该是范围适配器类。这基本上是我们学到的CRTP的实现，如[*第7章*](B18367_07_ePub.xhtml#_idTextAnchor123)，*模式和惯用语*中所述。
- en: The class must have a default constructor.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类必须有一个默认构造函数。
- en: The class must have a `base` member function that returns the underlying range.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类必须有一个`base`成员函数，该函数返回底层范围。
- en: The class must have a `begin` member function that returns an iterator to the
    first element in the range.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类必须有一个`begin`成员函数，该函数返回范围第一个元素的迭代器。
- en: The class must have an `end` member function that returns either an iterator
    to the one-past-the-last element of the range or a sentinel.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类必须有一个`end`成员函数，该函数返回范围最后一个元素之后的一个迭代器或一个哨兵。
- en: For ranges that meet the requirements of the `std::ranges::sized_range` concept,
    this class must also contain a member function called `size` that returns the
    number of elements in the range.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于满足`std::ranges::sized_range`概念要求的范围，此类还必须包含一个名为`size`的成员函数，该函数返回范围中的元素数。
- en: 'In order to make it possible to use class template argument deduction for the
    `step_view` class, a user-defined deduction guide should be defined. These were
    discussed in [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064), *Advanced Template
    Concepts*. Such a guide should look as follows:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使能够使用类模板参数推导来为`step_view`类进行推导，应该定义一个用户定义的推导指南。这些在[*第4章*](B18367_04_ePub.xhtml#_idTextAnchor064)，*高级模板概念*中进行了讨论。这样的指南应该如下所示：
- en: '[PRE346]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: 'In order to make it possible to compose this range adaptor with others using
    the pipe iterator (`|`), this operator must be overloaded. However, we need some
    helper function object, which is shown in the next listing:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使能够使用管道迭代器（`|`）将此范围适配器与其他适配器组合，此操作符必须被重载。然而，我们需要一些辅助函数对象，如下所示：
- en: '[PRE350]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: The `step_view_fn_closure` class is a function object that stores a value representing
    the number of elements to skip for each iterator. Its overloaded call operator
    takes a range as an argument and returns a `step_view` object created from the
    range and the value for the number of steps to jump.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`step_view_fn_closure`类是一个函数对象，它存储一个表示每个迭代器要跳过的元素数的值。其重载的调用操作符接受一个范围作为参数，并返回一个由范围和跳步数值创建的`step_view`对象。'
- en: 'Finally, we want to make it possible to write code in a similar manner to what
    is available in the standard library, which provides a compile-time global object
    in the `std::views` namespace for each range adaptor that exists. For instance,
    instead of `std::ranges::transform_view`, you could use `std::views::transform`.
    Similarly, instead of `step_view` (in some namespace), we want to have an object,
    `views::step`. To do so, we need yet another function object, as shown next:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望使代码能够以类似于标准库中可用的方式编写，标准库为每个存在的范围适配器在`std::views`命名空间中提供了一个编译时全局对象。例如，而不是使用`std::ranges::transform_view`，你可以使用`std::views::transform`。同样，而不是使用（在某些命名空间中的）`step_view`，我们希望有一个对象，`views::step`。为了做到这一点，我们需要另一个函数对象，如下所示：
- en: '[PRE373]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: 'The `step_view_fn` type is a function object that has two overloads for the
    call operator: one takes a range and an integer and returns a `step_view` object,
    and the other takes an integer and returns a closure for this value, or, more
    precisely, an instance of `step_view_fn_closure` that we saw earlier.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`step_view_fn`类型是一个函数对象，它有两个重载的调用操作符：一个接受一个范围和一个整数，并返回一个`step_view`对象；另一个接受一个整数并返回一个用于此值的闭包，或者更准确地说，是一个`step_view_fn_closure`实例，这是我们之前看到的。'
- en: Having all these implemented, we can successfully run the code shown at the
    beginning of this section. We have completed the implementation of a simple range
    adaptor. Hopefully, this should give you a sense of what writing range adaptors
    takes. The ranges library is significantly complex when you look at the details.
    In this chapter, you have learned some basics about the content of the library,
    how it can simplify your code, and how you can extend it with custom features.
    This knowledge should be a starting point for you should you want to learn more
    using other resources.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了所有这些之后，我们可以成功运行本节开头所示的代码。我们已经完成了简单范围适配器的实现。希望这能给你一个编写范围适配器的概念。当你查看细节时，ranges
    库非常复杂。在本章中，你学习了关于库内容的一些基础知识，它如何简化你的代码，以及如何通过自定义功能来扩展它。如果你想要使用其他资源学习更多，这些知识应该是一个起点。
- en: Summary
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter of the book, we explored the C++20 ranges library. We
    started the discussion with a transition from the abstract concept of a range
    to the new ranges library. We learned about the content of this library and how
    it can help us write simpler code. We focused the discussion on range adapters
    but also looked at constrained algorithms. At the end of the chapter, we learned
    how to write a custom range adaptor that can be used in combination with standard
    adapters.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章，我们探讨了 C++20 范围库。我们从一个范围的概念过渡到新的范围库开始讨论。我们了解了这个库的内容以及它如何帮助我们编写更简单的代码。我们重点讨论了范围适配器，但也看了约束算法。在本章的结尾，我们学习了如何编写一个自定义范围适配器，它可以与标准适配器一起使用。
- en: Questions
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a range?
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是范围？
- en: What is a view in the range library?
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 范围库中的视图是什么？
- en: What are constrained algorithms?
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是约束算法？
- en: What is a sentinel?
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是哨兵？
- en: How can you check that a sentinel type corresponds to an iterator type?
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何检查哨兵类型是否对应迭代器类型？
- en: Further reading
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*A beginner’s guide to C++ Ranges and Views*, Hannes Hauswedell, [https://hannes.hauswedell.net/post/2019/11/30/range_intro/](https://hannes.hauswedell.net/post/2019/11/30/range_intro/)'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++ Ranges 和 Views 入门指南*，汉内斯·豪斯韦德尔，[https://hannes.hauswedell.net/post/2019/11/30/range_intro/](https://hannes.hauswedell.net/post/2019/11/30/range_intro/)'
- en: '*Tutorial: Writing your first view from scratch (C++20/P0789)*, Hannes Hauswedell,
    [https://hannes.hauswedell.net/post/2018/04/11/view1/](https://hannes.hauswedell.net/post/2018/04/11/view1/)'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*教程：从头开始编写第一个视图（C++20/P0789）*，汉内斯·豪斯韦德尔，[https://hannes.hauswedell.net/post/2018/04/11/view1/](https://hannes.hauswedell.net/post/2018/04/11/view1/)'
- en: '*C++20 Range Adaptors and Range Factories*, Barry Revzin, [https://brevzin.github.io/c++/2021/02/28/ranges-reference/](https://brevzin.github.io/c++/2021/02/28/ranges-reference/)'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++20 范围适配器和范围工厂*，巴里·雷维津，[https://brevzin.github.io/c++/2021/02/28/ranges-reference/](https://brevzin.github.io/c++/2021/02/28/ranges-reference/)'
- en: '*Implementing a better views::split*, Barry Revzin, [https://brevzin.github.io/c++/2020/07/06/split-view/](https://brevzin.github.io/c++/2020/07/06/split-view/)'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现更好的 views::split*，巴里·雷维津，[https://brevzin.github.io/c++/2020/07/06/split-view/](https://brevzin.github.io/c++/2020/07/06/split-view/)'
- en: '*Projections are Function Adaptors*, Barry Revzin, [https://brevzin.github.io/c++/2022/02/13/projections-function-adaptors/](https://brevzin.github.io/c++/2022/02/13/projections-function-adaptors/)'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*投影是函数适配器*，巴里·雷维津，[https://brevzin.github.io/c++/2022/02/13/projections-function-adaptors/](https://brevzin.github.io/c++/2022/02/13/projections-function-adaptors/)'
- en: '*Tutorial: C++20’s Iterator Sentinels*, Jonathan Müller, [https://www.foonathan.net/2020/03/iterator-sentinel/](https://www.foonathan.net/2020/03/iterator-sentinel/)'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*教程：C++20 的迭代器哨兵*，乔纳森·穆勒，[https://www.foonathan.net/2020/03/iterator-sentinel/](https://www.foonathan.net/2020/03/iterator-sentinel/)'
- en: '*Standard Ranges*, Eric Niebrel, [https://ericniebler.com/2018/12/05/standard-ranges/](https://ericniebler.com/2018/12/05/standard-ranges/)'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标准范围*，埃里克·尼布勒，[https://ericniebler.com/2018/12/05/standard-ranges/](https://ericniebler.com/2018/12/05/standard-ranges/)'
- en: '*Zip*, Tim Song, [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html)'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Zip*，蒂姆·宋，[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html)'
- en: '*From range projections to projected ranges*, Oleksandr Koval, [https://oleksandrkvl.github.io/2021/10/11/projected-ranges.html](https://oleksandrkvl.github.io/2021/10/11/projected-ranges.html)'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从范围投影到投影范围*，奥列克桑德·科瓦尔，[https://oleksandrkvl.github.io/2021/10/11/projected-ranges.html](https://oleksandrkvl.github.io/2021/10/11/projected-ranges.html)'
- en: '*Item 30 - Create custom composable views*, Wesley Shillingford, [https://cppuniverse.com/EverydayCpp20/RangesCustomViews](https://cppuniverse.com/EverydayCpp20/RangesCustomViews)'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*项目30 - 创建自定义可组合视图*，韦斯利·希林福德，[https://cppuniverse.com/EverydayCpp20/RangesCustomViews](https://cppuniverse.com/EverydayCpp20/RangesCustomViews)'
- en: '*A custom C++20 range view*, Marius Bancila, [https://mariusbancila.ro/blog/2020/06/06/a-custom-cpp20-range-view/](https://mariusbancila.ro/blog/2020/06/06/a-custom-cpp20-range-view/)'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自定义C++20范围视图*，马里乌斯·班奇拉，[https://mariusbancila.ro/blog/2020/06/06/a-custom-cpp20-range-view/](https://mariusbancila.ro/blog/2020/06/06/a-custom-cpp20-range-view/)'
- en: '*New C++23 Range Adaptors*, Marius Bancila, [https://mariusbancila.ro/blog/2022/03/16/new-cpp23-range-adaptors/](https://mariusbancila.ro/blog/2022/03/16/new-cpp23-range-adaptors/)'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*新的C++23范围适配器*，马里乌斯·班奇拉，[https://mariusbancila.ro/blog/2022/03/16/new-cpp23-range-adaptors/](https://mariusbancila.ro/blog/2022/03/16/new-cpp23-range-adaptors/)'
- en: '*C++ Code Samples Before and After Ranges*, Marius Bancila, [https://mariusbancila.ro/blog/2019/01/20/cpp-code-samples-before-and-after-ranges/](https://mariusbancila.ro/blog/2019/01/20/cpp-code-samples-before-and-after-ranges/)'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在范围之前和之后的C++代码示例*，马里乌斯·班奇拉，[https://mariusbancila.ro/blog/2019/01/20/cpp-code-samples-before-and-after-ranges/](https://mariusbancila.ro/blog/2019/01/20/cpp-code-samples-before-and-after-ranges/)'
