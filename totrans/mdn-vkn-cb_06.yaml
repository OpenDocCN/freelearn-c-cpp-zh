- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Anti-Aliasing Techniques
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抗锯齿技术
- en: Anti-aliasing can be achieved in many ways, the most common being the one usually
    provided by the graphics API. In this chapter, we start by looking at how to enable
    and use the anti-aliasing provided by Vulkan, going over a multitude of other
    techniques that are more suitable for other use cases that require better anti-aliasing
    or that need a different algorithm altogether, such as temporal anti-aliasing.
    In this chapter, we will guide you through various anti-aliasing techniques, starting
    from enabling and using the one provided by Vulkan to exploring other more advanced
    and suitable methods for different use cases. The goal is to empower you with
    the knowledge and skills to choose and implement the most appropriate anti-aliasing
    technique for your specific needs, thereby improving the visual quality of your
    rendered graphics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 抗锯齿可以通过多种方式实现，最常见的是通常由图形 API 提供的方式。在本章中，我们首先探讨如何启用和使用 Vulkan 提供的抗锯齿，然后介绍许多更适合其他需要更好抗锯齿或需要不同算法的其他用例的技术，例如时间抗锯齿。在本章中，我们将引导您了解各种抗锯齿技术，从启用和使用
    Vulkan 提供的技术开始，探索针对不同用例的更高级和更合适的方法。目标是让您具备选择和实现最适合您特定需求的最合适的抗锯齿技术的知识和技能，从而提高您渲染图形的视觉效果。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Enabling and using Vulkan’s MSAA
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用和使用 Vulkan 的 MSAA
- en: Applying FXAA
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用 FXAA
- en: Utilizing TAA
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 TAA
- en: Applying DLSS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用 DLSS
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to make sure you have VS 2022 installed along
    with the Vulkan SDK. Basic familiarity with the C++ programming language and an
    understanding of OpenGL or any other graphics API will be useful. Please revisit
    [*Chapter 1*](B18491_01.xhtml#_idTextAnchor019)*, Vulkan Core Concepts*, under
    the *Technical requirements* section for details on setting up and building executables
    for this chapter. This chapter has multiple recipes, which can be launched using
    the following executables:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要确保已安装 VS 2022 以及 Vulkan SDK。对 C++ 编程语言的基本熟悉程度以及对 OpenGL 或任何其他图形 API
    的理解将很有用。请重新查看 *技术要求* 部分的 [*第 1 章*](B18491_01.xhtml#_idTextAnchor019)*，Vulkan 核心概念*，以获取有关设置和构建本章可执行文件的详细信息。本章包含多个配方，可以使用以下可执行文件启动：
- en: '`Chapter06_MSAA.exe`'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Chapter06_MSAA.exe`'
- en: '`Chapter06_FXAA.exe`'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Chapter06_FXAA.exe`'
- en: '`Chapter06_TAA.exe`'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Chapter06_TAA.exe`'
- en: '`Chapter06_DLSS.exe`'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Chapter06_DLSS.exe`'
- en: Enabling and using Vulkan’s MSAA
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用和使用 Vulkan 的 MSAA
- en: 'MSAA is an anti-aliasing technique that is used to reduce the jagged edges
    that can appear on curved lines and diagonal edges. Here’s an overview of how
    it works:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MSAA 是一种用于减少可能出现在曲线线和斜边上的锯齿边缘的抗锯齿技术。以下是它的工作概述：
- en: '**Multiple samples**: Instead of sampling a pixel once (like in regular rendering),
    MSAA takes multiple samples within each pixel. For example, 4 x MSAA needs 4 samples
    while 8 x MSAA needs 8 samples. The fragment shader runs for each one of the samples,
    and their output is stored for processing in *step 3*.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多个样本**：与常规渲染中只采样一次像素不同，MSAA 在每个像素内进行多次采样。例如，4 x MSAA 需要 4 个样本，而 8 x MSAA
    需要 8 个样本。片段着色器为每个样本运行，并将它们的输出存储在 *步骤 3* 中进行处理。'
- en: '**Edge detection**: MSAA only multi-samples pixels that are at the edges of
    geometry. This makes it more performance-efficient compared to techniques such
    as super-sampling, which samples the entire image at a higher resolution.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**边缘检测**：MSAA 只对几何形状边缘的像素进行多采样。与超采样等技术相比，它更高效，后者在更高分辨率下对整个图像进行采样。'
- en: '**Combining samples**: Once the samples are taken, they are averaged (or resolved)
    into a single-color value for the pixel. If some of the samples are within an
    object and some are outside it, the final pixel color will be a blend, creating
    a smoother transition and thereby reducing the appearance of jagged edges.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合并样本**：一旦采样完成，它们将被平均（或解析）为像素的单色值。如果一些样本在对象内部，而一些样本在外部，则最终像素颜色将是一个混合色，从而创建更平滑的过渡，并减少锯齿边缘的出现。'
- en: In this recipe, we will describe what steps you need to take to enable MSAA
    in Vulkan, as it is provided by the API.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将描述您需要采取的步骤来在 Vulkan 中启用 MSAA，因为它由 API 提供。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Enabling MSAA in Vulkan requires changes to multiple locations in the source
    code. The following are high-level steps to implement MSAA:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vulkan 中启用 MSAA 需要修改源代码中的多个位置。以下是实现 MSAA 的高级步骤：
- en: First, you need to ensure that the system supports MSAA. Additionally, you need
    to determine the maximum number of samples per pixel that are supported.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要确保系统支持MSAA。此外，你还需要确定每像素支持的样本数最大值。
- en: Textures need to be created with the number of samples they support.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 纹理需要创建为支持相应数量的样本。
- en: Additional textures need to be created to serve as the output after combining
    the samples (also referred to as resolve attachments).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要创建额外的纹理，作为合并样本后的输出（也称为解决附件）。
- en: Render passes need to specify the number of samples per attachment and provide
    extra information about the resolve attachments.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染通道需要指定每个附件的样本数，并提供关于解决附件的额外信息。
- en: Finally, framebuffers need to refer to the resolve attachments.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，帧缓冲区需要引用解决附件。
- en: Rendering with MSAA involves images with sample counts greater than 1\. However,
    these multi-sampled images cannot be presented directly using `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`.
    The `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` layout is designed for single-sampled images
    that are ready for presentation, with one color value per pixel. That’s why a
    *resolve* operation is needed to convert the multi-sampled image into a single-sampled
    image. The final anti-aliased output, which is suitable for presentation, needs
    to be written to another image with a sample count of `VK_SAMPLE_COUNT_1_BIT`.
    This implies that every color attachment with a sample count greater than 1 requires
    an associated attachment with a sample count equal to `VK_SAMPLE_COUNT_1_BIT`.
    These additional attachments, known as resolve attachments, are used to store
    the final anti-aliased output. During the resolve operation, the values from the
    multi-samples are combined and written into the *resolve* attachment, creating
    the final single-sample image that can be presented.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MSAA进行渲染涉及样本数大于1的图像。然而，这些多样本图像不能直接使用`VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`进行展示。`VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`布局是为准备展示的单样本图像设计的，每个像素有一个颜色值。这就是为什么需要一个*解决*操作来将多样本图像转换为单样本图像。最终的抗锯齿输出，适合展示，需要写入另一个具有`VK_SAMPLE_COUNT_1_BIT`样本数的图像。这意味着每个样本数大于1的颜色附件都需要一个具有`VK_SAMPLE_COUNT_1_BIT`样本数的关联附件。这些附加的附件，称为解决附件，用于存储最终的抗锯齿输出。在解决操作期间，多样本的值被合并并写入到*解决*附件中，创建出可以展示的最终单样本图像。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Enabling MSAA in Vulkan is not difficult but needs changes in multiple parts
    of the code. Here’s a step-by-step guide on how to do it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中启用MSAA并不困难，但需要在代码的多个部分进行更改。以下是如何一步步实现的指南：
- en: 'In the following code block, we deal with `VkPhysicalDeviceProperties` objects,
    specifically focusing on the `framebufferColorSampleCounts` and `framebufferDepthSampleCounts`
    properties. These properties help us determine the maximum number of samples per
    pixel supported for color and depth respectively. This capability is hardware-dependent,
    which makes it necessary to check it first before usage. The maximum supported
    value is found in the following:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们处理`VkPhysicalDeviceProperties`对象，特别是关注`framebufferColorSampleCounts`和`framebufferDepthSampleCounts`属性。这些属性帮助我们确定每像素支持的颜色和深度样本数的最大值。这种能力取决于硬件，因此在使用之前必须先进行检查。最大支持值如下：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The maximum number of samples is provided as a bit field of type `VkSampleCountFlagBits`,
    with flags such as `VK_SAMPLE_COUNT_1_BIT`, `VK_SAMPLE_COUNT_2_BIT`, `VK_SAMPLE_COUNT_4_BIT`,
    and so on, up to `VK_SAMPLE_COUNT_64_BIT`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最大样本数以`VkSampleCountFlagBits`类型的位字段提供，标志包括`VK_SAMPLE_COUNT_1_BIT`、`VK_SAMPLE_COUNT_2_BIT`、`VK_SAMPLE_COUNT_4_BIT`等，直到`VK_SAMPLE_COUNT_64_BIT`。
- en: 'During image creation, the number of samples that a texture supports must be
    specified. This is done by setting the `samples` member of the `VkImageCreateInfo`
    structure, which is of type `VkSampleCountFlagBits`, such as the following:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图像创建过程中，必须指定纹理支持的样本数。这是通过设置`VkImageCreateInfo`结构体的`samples`成员来完成的，该成员的类型为`VkSampleCountFlagBits`，例如以下内容：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'While creating a render pass, the attachment descriptions must indicate the
    sample count by setting the `VkAttachmentDescription::samples` field:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建渲染通道时，附件描述必须通过设置`VkAttachmentDescription::samples`字段来指示样本数：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An instance of the `VkAttachmentDescription` structure needs to be added to
    the render pass’s list of attachments, `VkSubpassDescription::pColorAttachments`,
    for each resolve attachment in the render pass. The resolve attachments must have
    their samples field set to `VK_SAMPLE_COUNT_1_BIT`, as the resolution of the multi-sampled
    image results in a single sample per pixel. This is because the multiple samples
    from the multi-sampled image are resolved into one final color value for that
    pixel. Here is how you can create and configure such a `VkAttachmentDescription`
    instance:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要将 `VkAttachmentDescription` 结构的实例添加到渲染通道附件列表 `VkSubpassDescription::pColorAttachments`
    中，对于渲染通道中的每个解决附件。解决附件必须将其样本字段设置为 `VK_SAMPLE_COUNT_1_BIT`，因为多采样图像的分辨率导致每个像素只有一个样本。这是因为来自多采样图像的多个样本被解析为该像素的一个最终颜色值。以下是如何创建和配置此类
    `VkAttachmentDescription` 实例的方法：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'An instance of the `VkAttachmentReference` structure must be created to reference
    this resolve attachment:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须创建 `VkAttachmentReference` 结构的实例来引用此解决附件：
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `VkAttachmentReference::attachment` field is an integer that points to the
    resolve attachment at the corresponding index of the `VkRenderPassCreateInfo::pAttachments`
    array.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`VkAttachmentReference::attachment` 字段是一个整数，它指向 `VkRenderPassCreateInfo::pAttachments`
    数组中相应索引的解决附件。'
- en: Finally, the list of attachment references that describe the resolve attachments
    is added to the `VkSubpassDescription::pResolveAttachments` field.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，描述解决附件的附件引用列表被添加到 `VkSubpassDescription::pResolveAttachments` 字段中。
- en: '*Figure 6**.1* illustrates how each component is set up and how they are referenced
    by a render pass and subpass description structures. The depth/stencil attachment
    must have the same sample count as the color attachments, and the number of resolve
    attachments must be equal to the number of color attachments.'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 6.1* 展示了每个组件的设置方式以及它们如何由渲染通道和子通道描述结构引用。深度/模板附件必须具有与颜色附件相同的样本计数，并且解决附件的数量必须等于颜色附件的数量。'
- en: '![Figure 6.1 – Render pass configuration](img/B18491_06_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 渲染通道配置](img/B18491_06_01.jpg)'
- en: Figure 6.1 – Render pass configuration
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 渲染通道配置
- en: In the preceding diagram, we showcased the configuration of texture sample count
    and its reference by both the render pass and subpass description structures.
    This arrangement is crucial for enabling MSAA in Vulkan.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们展示了纹理采样计数配置及其由渲染通道和子通道描述结构引用的方式。这种配置对于在 Vulkan 中启用 MSAA 至关重要。
- en: Applying FXAA
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用 FXAA
- en: FXAA is a screen-space anti-aliasing technique that can be implemented as an
    extra full-screen post-process pass. FXAA works by identifying edges in the image
    and then smoothing them to reduce the appearance of aliasing. Without the need
    for any additional information from the scene, FXAA can be easily integrated into
    existing code. It’s also fast because it processes only the final rendered image
    pixels and some of their neighbors. In this recipe, you will learn about the FXAA
    technique. You will understand how it functions as a screen-space anti-aliasing
    method, how it can be applied through a post-process pass, and why it is a beneficial
    tool due to its ease of integration and speed. Note that FXAA is generally applied
    before gamma correction or any sRGB conversion. The reason for this is that FXAA
    works best on linear RGB data. If you apply FXAA after gamma correction or sRGB
    conversion, it may result in incorrect edge detection and thus less effective
    anti-aliasing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: FXAA 是一种屏幕空间抗锯齿技术，它可以作为一个额外的全屏后处理通道实现。FXAA 通过识别图像中的边缘并对其进行平滑处理来减少锯齿的出现。由于不需要从场景中获取任何额外的信息，FXAA
    可以轻松地集成到现有代码中。它还因为只处理最终渲染图像的像素及其一些邻居而非常快速。在本食谱中，你将了解 FXAA 技术。你将理解它作为屏幕空间抗锯齿方法的功能，如何通过后处理通道应用它，以及为什么它是一个有益的工具，因为它易于集成且速度快。请注意，FXAA
    通常在伽玛校正或任何 sRGB 转换之前应用。这是因为 FXAA 在线性 RGB 数据上工作得最好。如果你在伽玛校正或 sRGB 转换后应用 FXAA，可能会导致边缘检测错误，从而降低抗锯齿效果。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The FXAA algorithm is implemented in our repository by the `FXAAPass` class,
    found in the `source/enginecore/passes/FXAA.cpp` and `FXAA.hpp` files. The shader
    used by the pass is located at `source/enginecore/resources/shaders/fxaa.frag`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: FXAA 算法通过 `FXAAPass` 类在我们的仓库中实现，该类位于 `source/enginecore/passes/FXAA.cpp` 和 `FXAA.hpp`
    文件中。该通道使用的着色器位于 `source/enginecore/resources/shaders/fxaa.frag`。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The algorithm can be implemented entirely in a fragment shader that uses the
    final render image as input. The shader also needs the size of the viewport, which
    can be provided as a push constant:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 算法可以完全在片段着色器中实现，该着色器使用最终渲染图像作为输入。着色器还需要视口大小，这可以作为推送常量提供：
- en: 'The shader is simple in terms of input and output and only needs an input texture
    and the size of the viewport for processing:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 着色器在输入和输出方面都很简单，只需要一个输入纹理和视口大小来处理：
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The FXAA algorithm operates on the luminance of the pixels, so we need a function
    to convert RGB values to luminance:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FXAA 算法作用于像素的亮度，因此我们需要一个函数将 RGB 值转换为亮度：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here are some constants for the edge-detection part:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有一些用于边缘检测部分的常量：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To simplify the code, we’ll use an array to store the luminance and RGB values
    for the neighboring pixels. We’ll also use constants to help refer to elements
    of the vector without using just integers:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化代码，我们将使用一个数组来存储相邻像素的亮度和 RGB 值。我们还将使用常量来帮助引用向量元素，而不仅仅是整数：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The algorithm is encapsulated in the `applyFXAA` function that takes the screen
    coordinates in pixels, the rendered image to be processed, and the size of the
    viewport:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法封装在 `applyFXAA` 函数中，该函数接受像素屏幕坐标、要处理的渲染图像以及视口大小：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first step is to compute the luminance and the RGB values of all eight
    neighboring pixels, as well as the range between the lowest and the highest luminance.
    If the value is below a certain threshold, we don’t perform the anti-aliasing.
    The **threshold** is used to determine whether a pixel is on an edge; its value
    represents the minimum difference in luminance that must exist between a pixel
    and its neighbors for that pixel to be considered part of an edge:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是计算所有八个相邻像素的亮度和 RGB 值，以及最低和最高亮度的范围。如果值低于某个阈值，则不执行抗锯齿。**阈值**用于确定像素是否在边缘上；其值表示像素与其邻居之间必须存在的最小亮度差异，以便该像素被视为边缘的一部分：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The difference between the average luminance of all neighboring pixels and
    the center pixels tells us whether we need to perform the anti-aliasing algorithm
    and the amount of blending required. It also clamps the blend amount between 0
    and `PIXEL_BLEND_LIMIT_TO_REDUCE_BLURRING` to reduce blurring:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有相邻像素的平均亮度和中心像素之间的差异告诉我们是否需要执行抗锯齿算法以及所需的混合量。它还将混合量限制在 0 和 `PIXEL_BLEND_LIMIT_TO_REDUCE_BLURRING`
    之间，以减少模糊：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next step consists of determining whether the edge is more vertical than
    horizontal and initializing the variables that will be used to find the edge endpoints,
    with the `findEndPointPosition` function:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是确定边缘是否比水平方向更垂直，并使用 `findEndPointPosition` 函数初始化用于找到边缘端点的变量：
- en: '[PRE12]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `findEndPointPosition` function returns `1` if it deems antialiasing is
    needed and `0` otherwise. It also returns the coordinate of the texel that will
    be blended with the pixel being anti-aliased. We will investigate the `findEndPointPosition`
    function in *step 11*:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`findEndPointPosition` 函数在认为需要抗锯齿时返回 `1`，否则返回 `0`。它还会返回将要与正在抗锯齿的像素混合的纹理像素的坐标。我们将在
    *步骤 11* 中研究 `findEndPointPosition` 函数：'
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the return value is `1.0`, we perform the antialiasing by blending the original
    pixel’s color with the color from the texel at the `outPosToFetchTexelForEdgeAntiAliasing`
    coordinate. The blending factor to use (`pixelblendAmount`) was computed previously,
    in *step 7*:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果返回值是 `1.0`，我们将通过将原始像素的颜色与 `outPosToFetchTexelForEdgeAntiAliasing` 坐标处的纹理像素的颜色混合来执行抗锯齿。要使用的混合因子（`pixelblendAmount`）已在
    *步骤 7* 中计算：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `findEndPointPosition` function performs an important task – it traverses
    the image in search of edge endpoints, moving in both directions from the central
    pixel that’s being processed. To accomplish this, it requires several pieces of
    information. First, it needs the texture that’s being processed, which is the
    image that the function will traverse. Next, it requires the coordinate of the
    pixel being processed, which serves as the starting point for the function’s traversal.
    The function also needs to know the luminance, or brightness, of the pixel. In
    addition, it must be aware of the luminance of the highest contrast pixel, an
    element that is determined based on whether the edge being examined is more horizontal
    or more vertical. Another crucial piece of information is the step length, which,
    like the luminance of the highest contrast pixel, is also dependent on the angle
    of the edge. The function needs the length of one pixel in texture coordinates
    for accurate image traversal. Finally, it requires a flag that indicates whether
    the edge is more horizontal or more vertical to correctly understand the edge’s
    orientation. It returns `1` if it deems anti-aliasing needs to be performed and
    `0` otherwise. It also returns the coordinate of the pixel that contains the RGB
    value to be used for the anti-aliasing:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`findEndPointPosition` 函数执行一项重要任务——它遍历图像以寻找边缘端点，从正在处理的中心像素向两个方向移动。为了完成这项任务，它需要一些信息。首先，它需要正在处理的纹理，即函数将遍历的图像。接下来，它需要正在处理的像素的坐标，这作为函数遍历的起点。函数还需要知道像素的亮度，或亮度。此外，它必须了解最高对比度像素的亮度，这是一个基于正在检查的边缘是更水平还是更垂直而确定的元素。另一条关键信息是步长，它，就像最高对比度像素的亮度一样，也取决于边缘的角度。函数需要纹理坐标中一个像素的长度，以便准确遍历图像。最后，它需要一个标志，指示边缘是更水平还是更垂直，以正确理解边缘的方向。如果它认为需要进行抗锯齿处理，则返回
    `1`，否则返回 `0`。它还返回包含用于抗锯齿的 RGB 值的像素坐标：'
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Depending on whether the edge is horizontal or not, the function initializes
    the direction and position of the high-contrast pixel:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据边缘是否水平，该函数初始化高对比度像素的方向和位置：
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Before we proceed to start looking for the edge endpoints, we need to set up
    some variables used in the loop:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始寻找边缘端点之前，我们需要设置一些在循环中使用的变量：
- en: '[PRE17]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The loop iterates a maximum of `NUM_LOOP_FOR_EDGE_DETECTION` times. It checks
    for edges by looking at the luminance differences in both the positive and negative
    directions from the middle pixel. The edge is detected when the luminance difference
    between two consecutive points in one direction exceeds a threshold (we will look
    at the `processDirection` function in *step 20*):'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环最多迭代 `NUM_LOOP_FOR_EDGE_DETECTION` 次。它通过检查从中间像素的正负方向上的亮度差异来寻找边缘。当同一方向上连续两个点的亮度差异超过阈值时，就会检测到边缘（我们将在
    *步骤 20* 中查看 `processDirection` 函数）：
- en: '[PRE18]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The function now calculates the distances from the middle pixel to the detected
    edge endpoints, in both the negative and positive directions:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数现在计算从中间像素到检测到的边缘端点的距离，包括负方向和正方向：
- en: '[PRE19]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It also checks which endpoint is closer to the middle pixel:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还检查哪个端点更接近中间像素：
- en: '[PRE20]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Anti-aliasing is deemed necessary, based on the luminance difference between
    the endpoint that is closer to the middle pixel and the middle pixel itself:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据接近中间像素的端点和中间像素本身的亮度差异，认为需要进行抗锯齿处理：
- en: '[PRE21]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using the distances to the edge endpoints, the following code snippet calculates
    the pixel offset that is required for anti-aliasing:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用到边缘端点的距离，以下代码片段计算所需的抗锯齿像素偏移量：
- en: '[PRE22]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The function returns `1.0` if edge anti-aliasing is required and `0.0` otherwise:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要边缘抗锯齿，则函数返回 `1.0`，否则返回 `0.0`：
- en: '[PRE23]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `processDirection` inspects the luma values of pixels in a certain direction
    (given by `edgeIncrement`) to check for high contrast or edges. It will continue
    to inspect positions in this direction until a certain contrast condition is met.
    Once the condition is met, it will set the `doneGoingThroughDir` flag to `true`,
    signaling that it’s done processing in this direction:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`processDirection` 检查一定方向（由 `edgeIncrement` 给出）中像素的亮度值，以检查高对比度或边缘。它将继续检查该方向上的位置，直到满足一定的对比度条件。一旦满足条件，它将设置
    `doneGoingThroughDir` 标志为 `true`，表示它已在该方向上完成处理：'
- en: '[PRE24]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The fragment code calls `applyFXAA`, which returns the new color to output
    from the shader:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段代码调用 `applyFXAA`，该函数从着色器返回新的输出颜色：
- en: '[PRE25]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And there you have it – the recipe for applying FXAA, a powerful tool for smoothing
    out jaggies in your graphics. As we wrap this up, remember that the beauty of
    FXAA lies not just in its ability to enhance visual output but also in its flexibility
    and ease of integration into existing systems.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——应用FXAA的配方就完成了，FXAA是一种强大的工具，可以平滑掉图形中的锯齿。随着我们结束这个话题，请记住，FXAA的美丽之处不仅在于其增强视觉输出的能力，还在于其灵活性和易于集成到现有系统中的便利性。
- en: Utilizing TAA
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用TAA
- en: Unlike the previously discussed anti-aliasing methods, which only consider spatial
    information, TAA is based on temporal information – that is, it utilizes both
    the current and previous frames to smooth out these aliasing artifacts. The reason
    aliasing artifacts happens is because of insufficient samples; TAA solves this
    by sampling data over the frame sequence, significantly reducing the pressure
    on a single frame.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前讨论的抗走样方法不同，这些方法只考虑空间信息，而TAA基于时间信息——也就是说，它利用当前帧和前一帧来平滑这些走样伪影。走样伪影发生的原因是样本不足；TAA通过在帧序列上采样数据来解决此问题，显著减轻了单个帧的压力。
- en: 'The basic idea is to apply subpixel jittering – that is, slightly shift the
    projection matrix of the camera for each new frame. This results in slightly different
    viewpoints for each frame, giving us more information about the scene than a static
    viewpoint would. When sampling textures during rendering, the resulting color
    value can be different due to the jitter. This creates a different aliasing pattern
    per frame, which, when accumulated over time, averages out and reduces the visible
    aliasing in the scene. This is demonstrated in the following screenshot in *Figure
    6**.2*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是应用子像素抖动——也就是说，为每个新帧稍微移动相机的投影矩阵。这导致每个帧的视角略有不同，比静态视角提供了更多关于场景的信息。在渲染期间采样纹理时，由于抖动，产生的颜色值可能会有所不同。这为每个帧创建了一个不同的走样模式，随着时间的积累，平均出来并减少了场景中可见的走样。这在上面的截图*图6.2*中得到了演示。
- en: '![Figure 6.2 – A temporal anti-aliasing overview](img/B18491_06_02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 时间抗走样概述](img/B18491_06_02.jpg)'
- en: Figure 6.2 – A temporal anti-aliasing overview
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 时间抗走样概述
- en: The concept outlined here performs exceptionally well for static scenes. However,
    in scenarios where either the objects or the camera is in motion, consecutive
    frames can exhibit substantial differences. This can lead to a visual artifact
    where moving objects appear to leave behind a series of their *ghosts*, creating
    what is known as the **ghosting** effect.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里概述的概念在静态场景中表现非常出色。然而，在物体或相机处于运动状态的情况下，连续帧可能会表现出显著差异。这可能导致视觉伪影，移动物体似乎留下了一系列它们的*幽灵*，形成了所谓的**拖影**效果。
- en: To get rid of ghosting, we use what is commonly called a **velocity** buffer,
    and the motion in the scene is captured using motion vectors. For each pixel,
    a motion vector is calculated that represents how much a pixel has moved compared
    to the previous frame. The result is a velocity buffer that stores these motion
    vectors. The previously rendered frame is then re-projected onto the current frame
    using the velocity buffer. This means that for each pixel, the color of the corresponding
    pixel in the previous frame is looked up using the motion vector. This color is
    then blended with the current color of the pixel, which results in a smoothing
    of the colors over time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除拖影，我们使用通常所说的**速度缓冲区**，并且使用运动矢量来捕捉场景中的运动。对于每个像素，计算一个运动矢量，表示像素相对于前一帧移动了多少。结果是存储这些运动矢量的速度缓冲区。然后使用速度缓冲区将先前渲染的帧重新投影到当前帧上。这意味着对于每个像素，使用运动矢量查找前一帧中相应像素的颜色。然后将这种颜色与像素的当前颜色混合，从而在时间上平滑颜色。
- en: '*Figure 6**.3* shows a high-level overview of the TAA algorithm:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.3*展示了TAA算法的高级概述：'
- en: '![Figure 6.3 – A TAA frame overview](img/B18491_06_03.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – TAA帧概述](img/B18491_06_03.jpg)'
- en: Figure 6.3 – A TAA frame overview
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – TAA帧概述
- en: In this recipe, you will learn how to implement TAA, an advanced technique that
    can significantly reduce flickering and provide smoother visuals in your graphics.
    You’ll understand the intricacies of TAA and how to adeptly integrate it into
    your code, adding another powerful tool to your graphics rendering toolbox.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何实现TAA，这是一种高级技术，可以显著减少闪烁并提供更平滑的视觉效果。你将了解TAA的复杂性以及如何巧妙地将其集成到代码中，为你的图形渲染工具箱添加另一个强大的工具。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the repository, the TAA algorithm is implemented by the `TAAComputePass`
    class, located in the `source/enginecore/passes/TAAComputePass.hpp` and `cpp`
    files. The shaders are implemented using a compute shader, located in `source/enginecore/resources/shaders/taaresolve.comp`
    and `source/enginecore/resources/shaders/taahistorycopyandsharpen.comp`. TAA example
    can be launched by running the `Chapter06_TAA` executable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库中，TAA算法是通过位于`source/enginecore/passes/TAAComputePass.hpp`和`cpp`文件的`TAAComputePass`类实现的。着色器使用计算着色器实现，位于`source/enginecore/resources/shaders/taaresolve.comp`和`source/enginecore/resources/shaders/taahistorycopyandsharpen.comp`。可以通过运行`Chapter06_TAA`可执行文件来启动TAA示例。
- en: '*Figure 6**.4* illustrates the flow of the TAA algorithm:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6**.4*展示了TAA算法的流程：'
- en: '![Figure 6.4 – A TAA algorithm in a deferred renderer](img/B18491_06_04.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 在延迟渲染器中的TAA算法](img/B18491_06_04.jpg)'
- en: Figure 6.4 – A TAA algorithm in a deferred renderer
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 在延迟渲染器中的TAA算法
- en: 'TAA is implemented as a two-step compute shader:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: TAA（时间抗锯齿）被实现为一个两步的计算着色器：
- en: The first step is the TAA resolve shader, which takes `ColorTexture`, `DepthTexture`,
    `HistoryTexture`, and `VelocityTexture` as input and writes to an intermediate
    image. The velocity, color, and depth texture are produced from the `Gbuffer`
    pass in the given example; however, conceptually, the same could be produced in
    forward rendering as well.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是TAA解析着色器，它接受`ColorTexture`、`DepthTexture`、`HistoryTexture`和`VelocityTexture`作为输入，并将结果写入一个中间图像。在给定的示例中，速度、颜色和深度纹理是从`Gbuffer`传递中产生的；然而，从概念上讲，这些也可以在正向渲染中产生。
- en: 'The second step is running a compute shader that is responsible for the following:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是运行一个计算着色器，该着色器负责以下操作：
- en: Copying the results of the previously produced intermediate texture into a history
    texture.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前产生的中间纹理结果复制到历史纹理中。
- en: Refining these intermediate results, we don’t need to generate an additional
    texture to store the refined results, instead, we can utilize the provided `ColorTexture`
    in the TAA resolve shader. This is the same `ColorTexture` that eventually gets
    displayed. A known downside of TAA is the potential of causing a minor blur in
    the image. To mitigate this, a sharpening filter is applied post-TAA. This sharpening
    phase is designed to intensify the edges and intricate details in the image, thereby
    reinstating some of the sharpness that might have been compromised during the
    TAA resolve process.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 精炼这些中间结果时，我们不需要生成额外的纹理来存储精炼后的结果，相反，我们可以利用TAA解析着色器中提供的`ColorTexture`。这正是最终将被显示的`ColorTexture`。TAA的一个已知缺点是可能会在图像中造成轻微的模糊。为了减轻这一点，在TAA之后应用了一个锐化过滤器。这个锐化阶段旨在增强图像的边缘和复杂细节，从而恢复在TAA解析过程中可能受损的一些锐度。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To implement TAA, we first need to construct a jitter matrix. This matrix will
    be used in tandem with the **Model-View-Projection** (**MVP**) matrix during the
    rendering process. Furthermore, we will need color, depth, and velocity buffers.
    Conveniently, these buffers are already generated as part of the G-buffer pipeline,
    which we implemented in [*Chapter 4*](B18491_04.xhtml#_idTextAnchor241)*, Exploring
    Techniques for Lighting, Shading, and Shadows* in the *Implementing the G-buffer
    for deferred* *rendering* recipe:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现TAA，我们首先需要构建一个抖动矩阵。这个矩阵将在渲染过程中与**模型-视图-投影**（**MVP**）矩阵协同使用。此外，我们还需要颜色、深度和速度缓冲区。方便的是，这些缓冲区已经作为G缓冲区管道的一部分生成，我们在[*第4章*](B18491_04.xhtml#_idTextAnchor241)“探索光照、着色和阴影技术”的*实现G缓冲区以进行延迟渲染*配方中实现了：
- en: The `TAAComputePass::init` method is in charge of initializing various resources.
    It establishes two pipelines – one for resolving to an output color, and another
    for transferring the output color into a history texture and enhancing the output
    color’s sharpness.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TAAComputePass::init`方法负责初始化各种资源。它建立了两个管道 – 一个用于解析到输出颜色，另一个用于将输出颜色传输到历史纹理并增强输出颜色的锐度。'
- en: 'The majority of work happens in the `TAAComputePass::doAA` function. This function
    simply operates the resolve compute pipeline, followed by the pipeline that handles
    the copying of the history texture and the sharpening of the output color. We’ve
    highlighted key components of the `doAA` function as follows, omitting less critical
    parts to avoid verbosity:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大部分工作发生在`TAAComputePass::doAA`函数中。这个函数简单地操作解析计算管道，然后是处理复制历史纹理和增强输出颜色锐度的管道。我们如下突出显示了`doAA`函数的关键组件，省略了不那么关键的部分以避免冗长：
- en: '[PRE26]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The actual magic happens in the two compute shaders; specifically, the resolve
    shader is the most important. The resolve shader is implemented in `taaresolve.comp`.
    Let’s look at how the shaders work.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的魔法发生在两个计算着色器中；特别是，解算着色器是最重要的。解算着色器在`taaresolve.comp`中实现。让我们看看着色器是如何工作的。
- en: First, we will expand on some auxiliary functions. `catmullRomTextureFiltering`
    helps smooth out the temporal aliasing by blending the colors of pixels between
    frames, using Catmull-Rom interpolation. Catmull-Rom interpolation is a form of
    cubic interpolation that provides a smoother appearance than linear interpolation.
    The function uses the Catmull-Rom weights (`w0, w1, w2, w3`) to calculate the
    weight for the center (`w12`) and the offset from the center (`offset12`). Then,
    the function calculates three new texture positions (`texPos0`, `texPos3`, and
    `texPos12`) and adjusts these positions to match the texture resolution. The function
    then uses these weights and texture positions to calculate the resulting pixel
    color, by accessing the history buffer texture at the specific positions, multiplying
    the retrieved color by the respective weights, and summing them together.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将扩展一些辅助函数。`catmullRomTextureFiltering`通过使用Catmull-Rom插值混合帧之间的像素颜色，以平滑时间上的锯齿。Catmull-Rom插值是一种三次插值，它比线性插值提供了更平滑的外观。该函数使用Catmull-Rom权重（`w0,
    w1, w2, w3`）来计算中心（`w12`）和中心偏移（`offset12`）的权重。然后，函数计算三个新的纹理位置（`texPos0`, `texPos3`,
    和 `texPos12`）并将这些位置调整以匹配纹理分辨率。然后，函数使用这些权重和纹理位置通过访问特定位置的历史缓冲区纹理，将检索到的颜色乘以相应的权重，并将它们相加来计算结果像素颜色。
- en: The `varianceClampColor` function is used in anti-aliasing TAA to deal with
    issues of ghosting and blurring that can occur, due to the temporal reprojection
    of color data. The function works by limiting the color value of a given pixel,
    based on the color variance of its surrounding pixels. It loops over a 3x3 neighborhood
    around the current pixel. For each neighboring pixel, the function retrieves its
    color data (`neighColor`) and calculates a weight (`w`), based on the Euclidean
    distance from the current pixel. This weight is designed to give closer pixels
    more influence over the final color result.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`varianceClampColor`函数在抗锯齿TAA中用于处理由于颜色数据的时序重投影而产生的鬼影和模糊问题。该函数通过根据其周围像素的颜色方差限制给定像素的颜色值来工作。它遍历当前像素周围的3x3邻域。对于每个相邻像素，函数检索其颜色数据（`neighColor`）并基于当前像素的欧几里得距离计算一个权重（`w`）。这个权重被设计为给予更接近像素更多的最终颜色结果的影响。'
- en: The `calculateBlendFactor` function is responsible for performing calculations
    to determine the blend factor of a pixel, based on its velocity and luminance.
    Firstly, the pixel movement is calculated on two levels, the overall motion and
    the tiny subpixel motion, resulting in values called `subpixelMotion` and `dynamicBlendFactor`
    respectively. Then, to adjust the pixel’s brightness or luminance, the difference
    between the current color and the previous frame color is determined. This entire
    process enhances the realism of the pixel’s movement and color changes over time,
    significantly improving the overall image quality when there’s movement of objects
    or camera. The implementation of `catmullRomTextureFiltering` and `varianceClampColor`
    are very verbose; we suggest looking at `taaresolve.comp` for implementation details.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`calculateBlendFactor`函数负责根据像素的速度和亮度进行计算，以确定像素的混合因子。首先，在两个层面上计算像素的移动，即整体运动和微小的子像素运动，分别得到`subpixelMotion`和`dynamicBlendFactor`的值。然后，为了调整像素的亮度或亮度，确定当前颜色与前一帧颜色之间的差异。整个过程增强了像素随时间移动和颜色变化的逼真度，当物体或相机移动时，显著提高了整体图像质量。`catmullRomTextureFiltering`和`varianceClampColor`的实现非常详细；我们建议查看`taaresolve.comp`以获取实现细节。'
- en: 'Next, we present the `main` function; this helps to produce a smoother, more
    stable image by reducing flickering and ghosting artifacts that can occur, due
    to the rapid movement of the camera or objects in a scene. The following sub-steps
    will walk you through the specifics of its implementation:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们展示`main`函数；这个函数通过减少由于相机或场景中物体的快速移动而产生的闪烁和鬼影伪影，有助于生成更平滑、更稳定的图像。以下子步骤将向您介绍其实施的具体细节：
- en: 'Calculate the closest depth and corresponding velocity around the current pixel:'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算当前像素周围的最近深度和相应的速度：
- en: '[PRE27]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Reproject the current pixel position to its position in the previous frame
    using the calculated velocity:'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用计算出的速度将当前像素位置重投影到上一帧的位置：
- en: '[PRE28]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Calculate `velocityLerp` using the history buffer at the reprojected location.
    Note the use of `taaConstData.isFirstFrame`, which helps to determine whether
    we are dealing with the first frame of the sequence or not. If it is the first
    frame, `velocityLerp` is simply initialized to `0.0f`. In the context of camera
    cuts or teleports (i.e., a sudden change from one perspective to another), the
    first frame assumption is also applicable. Whenever these events occur, the scene
    changes dramatically from one frame to another. In such cases, it’s beneficial
    to treat the frame right after the cut or teleport as a first frame. This is because
    the data from the previous frame is no longer a good reference for the current
    frame, due to the drastic changes in scene content:'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用重投影位置的历史缓冲区计算`velocityLerp`。注意使用`taaConstData.isFirstFrame`，这有助于确定我们是否正在处理序列的第一帧。如果是第一帧，则`velocityLerp`简单地初始化为`0.0f`。在摄像机切换或传送（即从一个视角突然切换到另一个视角）的上下文中，第一帧假设也适用。每当这些事件发生时，场景从一个帧到另一个帧会急剧变化。在这种情况下，将切换或传送后的帧视为第一帧是有益的。这是因为由于场景内容的大幅变化，前一帧的数据不再是当前帧的好参考：
- en: '[PRE29]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Load the current frame color (`colorIn`) and calculate `colorHistory` using
    `catmullRomTextureFiltering`:'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载当前帧颜色（`colorIn`）并使用`catmullRomTextureFiltering`计算`colorHistory`：
- en: '[PRE30]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define two constants, `boxSizeWhenMoving` and `boxSizeWhenStationary`. We determine
    value of `boxSize` based on whether the camera is moving or not and is interpolated
    between the stationary and moving values, based on `velocityLerp`:'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个常量，`boxSizeWhenMoving`和`boxSizeWhenStationary`。我们根据摄像机是否移动来确定`boxSize`的值，并根据`velocityLerp`在静止和移动值之间进行插值：
- en: '[PRE31]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Historical color (`colorHistory`) is then clamped using the `varianceClampColor`
    function to ensure that the color is within a certain range, based on the variance
    of surrounding pixels:'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`varianceClampColor`函数对历史颜色（`colorHistory`）进行夹紧，以确保颜色基于周围像素的方差在某个范围内：
- en: '[PRE32]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Calculate `blendFactor`, which determines how much of the current color and
    the historical color should be used to get the final color:'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算决定当前颜色和历史颜色应使用多少以获得最终颜色的`blendFactor`：
- en: '[PRE33]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Compute the final color (`colorResolve`) as a mix of the clamped historical
    color and the current color, based on `blendFactor`; also, store `velocityLerp`
    in the `alpha` channel:'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据`blendFactor`将最终颜色（`colorResolve`）计算为夹紧的历史颜色和当前颜色的混合，并将`velocityLerp`存储在`alpha`通道中：
- en: '[PRE34]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we will show how `taahistorycopyandsharpen.comp` works; this shader is
    responsible for copying the data into history texture, as well as sharpening the
    results produced by *step 5* (`taaresolve.comp`). The main function is presented
    as follows, and the code is simple – it first copies `incolor` (which is the image
    produced by previous *step 5*) into the history texture. Then, the `sharpen` method
    is called. This method works by first loading pixel colors from the center and
    four directly adjacent locations (top, left, right, and bottom). It then uses
    an unsharp masking technique, which involves subtracting a blurred or *unsharp*
    version of the image from the original image to create a mask that represents
    the detail of the image. The function applies this mask to enhance the original
    image, making it appear sharper. The final color produced by the `sharpen` method
    is stored in `outColorImage`, which is finally copied to the swapchain image.
    For the sake of brevity, we’re not detailing the `sharpen` function here. However,
    you can review its implementation in the `taahistorycopyandsharpen.comp` file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将展示`taahistorycopyandsharpen.comp`的工作原理；这个着色器负责将数据复制到历史纹理中，以及锐化由第5步（`taaresolve.comp`）产生的结果。主要函数如下所示，代码很简单——它首先将`incolor`（即前一步骤5产生的图像）复制到历史纹理中。然后调用`sharpen`方法。该方法首先从中心及其四个直接相邻的位置（顶部、左侧、右侧和底部）加载像素颜色。然后使用非锐化掩膜技术，该技术涉及从原始图像中减去模糊或*非锐化*版本的图像，以创建表示图像细节的掩膜。该函数将此掩膜应用于增强原始图像，使其看起来更锐利。`sharpen`方法产生的最终颜色存储在`outColorImage`中，最终复制到swapchain图像中。为了简洁起见，我们在此不详细说明`sharpen`函数。然而，您可以在`taahistorycopyandsharpen.comp`文件中查看其实现：
- en: '[PRE35]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Despite its widespread use and numerous benefits, TAA isn’t without its shortcomings:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管TAA应用广泛且具有许多优点，但它并非没有缺点：
- en: When object motion uncovers new areas on a screen, these areas are either not
    present in the history buffer or are inaccurately depicted by the motion vectors.
    Additionally, camera rotation and reverse translation can lead to extensive uncovered
    areas at the screen’s edges.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当物体运动在屏幕上揭露新的区域时，这些区域要么在历史缓冲区中不存在，要么被运动矢量不准确地描绘。此外，相机旋转和反向平移可能导致屏幕边缘出现大量未被揭露的区域。
- en: Features with subpixel dimensions, such as wires, may be missed by a consecutive
    frame, leading to their absence in motion vectors in the subsequent frame. Transparent
    surfaces can generate pixels where the motion vectors from opaque objects don’t
    align with the overall movement of the objects depicted. Lastly, shadows and reflections
    don’t follow the direction of the motion vectors of the surfaces they shade.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有亚像素尺寸的特征，如电线，可能被连续帧错过，导致它们在后续帧的运动矢量中缺失。透明表面可以生成像素，其中不透明物体的运动矢量与所描绘物体的整体运动不一致。最后，阴影和反射不会遵循它们所遮蔽的表面的运动矢量方向。
- en: When TAA doesn’t work properly, it either results in ghosting (a blurring effect
    caused by integrating incorrect values) or it exposes the original aliasing, leading
    to jagged edges, flickering, and noise.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当TAA（时间抗锯齿）不正常工作时，它要么导致鬼影（由整合错误值引起的模糊效果），要么暴露原始的锯齿，导致边缘参差不齐、闪烁和噪声。
- en: See also
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料也
- en: 'For further reading and a deeper understanding of TAA, consider exploring the
    following resources. These references will provide you with more detailed information,
    practical applications, and insights into the latest advancements:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步阅读和深入了解TAA，请考虑探索以下资源。这些参考资料将为你提供更详细的信息、实际应用和最新进展的见解：
- en: '[https://research.nvidia.com/publication/2019-03_improving-temporal-antialiasing-adaptive-ray-tracing](https://research.nvidia.com/publication/2019-03_improving-temporal-antialiasing-adaptive-ray-tracing)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://research.nvidia.com/publication/2019-03_improving-temporal-antialiasing-adaptive-ray-tracing](https://research.nvidia.com/publication/2019-03_improving-temporal-antialiasing-adaptive-ray-tracing)'
- en: '[https://community.arm.com/arm-community-blogs/b/graphics-gaming-and-vr-blog/posts/temporal-anti-aliasing](https://community.arm.com/arm-community-blogs/b/graphics-gaming-and-vr-blog/posts/temporal-anti-aliasing)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://community.arm.com/arm-community-blogs/b/graphics-gaming-and-vr-blog/posts/temporal-anti-aliasing](https://community.arm.com/arm-community-blogs/b/graphics-gaming-and-vr-blog/posts/temporal-anti-aliasing)'
- en: Applying DLSS
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用DLSS
- en: DLSS is an AI-powered technology developed by NVIDIA for their RTX series of
    graphics cards. DLSS uses the power of machine learning and AI to increase the
    resolution of rendered frames by intelligently upscaling lower resolution images
    in real time. This results in a high-quality, high-resolution image that requires
    less computational power to produce. We can also use DLSS to render frames at
    a lower base resolution and then use AI to upscale the image to a higher resolution.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: DLSS是由NVIDIA为他们的RTX系列显卡开发的一种由AI驱动的技术。DLSS利用机器学习和AI的力量，通过实时智能提升低分辨率图像的分辨率，从而以更少的计算能力生成高质量的、高分辨率的图像。我们还可以使用DLSS在较低的基线分辨率下渲染帧，然后使用AI将图像提升到更高的分辨率。
- en: Note that to use DLSS, you must have an NVIDIA RTX series graphics card.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，要使用DLSS，你必须拥有NVIDIA RTX系列的显卡。
- en: In this recipe, you’ll learn how to apply DLSS, an innovative technique for
    enhancing the resolution of rendered frames in real time. You will gain an understanding
    of how DLSS leverages machine learning and AI to upscale lower-resolution images
    intelligently, thereby achieving superior image quality with less computational
    power.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何应用DLSS，这是一种用于实时增强渲染帧分辨率的创新技术。你将了解DLSS如何利用机器学习和AI智能地提升低分辨率图像，从而以更少的计算能力实现更高质量的图像。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the repository, DLSS is implemented by the `DLSS` class, located in the `source/enginecore/DLSS.hpp`
    and `cpp` files. The DLSS example can be launched by running the `chapter06_DLSS`
    executable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库中，DLSS是通过位于`source/enginecore/DLSS.hpp`和`cpp`文件中的`DLSS`类实现的。可以通过运行`chapter06_DLSS`可执行文件来启动DLSS示例。
- en: DLSS also requires color, depth and velocity textures, the same textures that
    were used by the TAA algorithm.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: DLSS还需要颜色、深度和速度纹理，这些纹理与TAA算法所使用的纹理相同。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The DLSS is integrated using the following steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: DLSS的集成步骤如下：
- en: 'First, we need to query the device and instance extensions that are required
    for DLSS; these extensions need to be enabled before Vulkan is initialized. NVIDIA’s
    DLSS SDK provides `NVSDK_NGX_VULKAN_RequiredExtensions`, which needs to be used
    to query extensions. The following code block presents a static function that
    can append extensions required by DLSS; this needs to be called before initializing
    the Vulkan device:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要查询DLSS所需的设备和实例扩展；这些扩展需要在初始化Vulkan之前启用。NVIDIA的DLSS SDK提供了`NVSDK_NGX_VULKAN_RequiredExtensions`，需要用它来查询扩展。以下代码块展示了一个可以附加DLSS所需扩展的静态函数；这需要在初始化Vulkan设备之前调用：
- en: '[PRE36]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we will look at `DLSS init` method. This method is responsible for initializing
    the DLSS feature provided by the NVSDK. It takes the current width and height
    of the viewport, an upscale factor, and a reference to a `CommandQueueManager`
    object. The function first sets the upscale factor and then determines the optimal
    settings for DLSS, based on the current viewport size and desired quality level.
    It then configures DLSS features such as motion vector resolution, frame sharpening,
    and others based on specific flags. Finally, it creates the DLSS feature and submits
    the command to the Vulkan command buffer:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨`DLSS init`方法。此方法负责初始化NVSDK提供的DLSS功能。它接受视口的当前宽度和高度、一个放大因子以及一个指向`CommandQueueManager`对象的引用。函数首先设置放大因子，然后根据当前视口大小和期望的质量级别确定DLSS的最佳设置。然后，根据特定的标志配置DLSS功能，如运动矢量分辨率、帧锐化等。最后，它创建DLSS功能并将命令提交到Vulkan命令缓冲区：
- en: '[PRE37]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The next step is to call DLSS’s `render` method, which is responsible for applying
    DLSS to the provided input textures to enhance the image quality. It takes a Vulkan
    command buffer and several texture objects as inputs – color, depth, motion vector,
    and output color texture, along with a 2D vector for the camera jitter. Firstly,
    we create resources for each of the input textures using the `NVSDK_NGX_Create_ImageView_Resource_VK`
    function; afterward, we transition the layout of the output color texture to `VK_IMAGE_LAYOUT_GENERAL`
    to prepare it for writing. Next, this function sets up the parameters for the
    DLSS evaluation, including input color and output resources, sharpness level,
    depth resource, motion vector resource, and camera jitter offsets. The last part
    is to call `NGX_VULKAN_EVALUATE_DLSS_EXT` to apply DLSS to the images, which enhances
    the image quality, based on the parameters provided:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是调用DLSS的`render`方法，该方法负责将DLSS应用于提供的输入纹理以增强图像质量。它接受一个Vulkan命令缓冲区和几个纹理对象作为输入——颜色、深度、运动矢量和输出颜色纹理，以及一个用于相机抖动的2D向量。首先，我们使用`NVSDK_NGX_Create_ImageView_Resource_VK`函数为每个输入纹理创建资源；之后，我们将输出颜色纹理的布局转换为`VK_IMAGE_LAYOUT_GENERAL`以准备写入。接下来，此函数设置DLSS评估的参数，包括输入颜色和输出资源、锐度级别、深度资源、运动矢量资源和相机抖动偏移。最后一部分是调用`NGX_VULKAN_EVALUATE_DLSS_EXT`将DLSS应用于图像，根据提供的参数增强图像质量：
- en: '[PRE38]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the next section, we present valuable links for further reading and deeper
    understanding of the topic.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将提供一些有价值的链接，以供进一步阅读和深入了解该主题。
- en: See also
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more in-depth knowledge and practical insights on DLSS, the following resource
    will prove invaluable:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更深入的知识和关于DLSS的实际见解，以下资源将非常有价值：
- en: '[https://github.com/NVIDIA/DLSS/blob/main/doc/DLSS_Programming_Guide_Release.pdf](https://github.com/NVIDIA/DLSS/blob/main/doc/DLSS_Programming_Guide_Release.pdf)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NVIDIA/DLSS的DLSS编程指南](https://github.com/NVIDIA/DLSS/blob/main/doc/DLSS_Programming_Guide_Release.pdf)'
- en: In this chapter, we started with Vulkan’s MSAA. This is a method used to combat
    the spatial aliasing of high-contrast edges, often seen as jagged or staircase
    lines in the rendered image. We discussed the process of enabling MSAA in Vulkan,
    which involves configuring the multi-sample state during pipeline creation and
    allocating a separate multi-sample image. We also covered how MSAA operates by
    averaging the color of multiple sample points, reducing the jagged appearance,
    and providing a smoother, more natural look to the edges.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了Vulkan的MSAA。这是一种用于对抗高对比度边缘空间走样（常在渲染图像中表现为锯齿或阶梯状线条）的方法。我们讨论了在Vulkan中启用MSAA的过程，这涉及到在管道创建期间配置多采样状态并分配一个单独的多采样图像。我们还介绍了MSAA是如何通过平均多个采样点的颜色来减少锯齿状外观，并为边缘提供更平滑、更自然的外观。
- en: Then, we addressed FXAA. This technique is a screen-space, post-processing method,
    meaning that it works directly on the final image. Its primary advantage is its
    speed and simplicity, offering a good trade-off between performance and quality.
    FXAA smooths edges by finding high-contrast pixels and blending them with their
    surroundings. Despite being an approximation, FXAA can often provide a significant
    improvement in perceived image quality, particularly in scenes with many high-contrast
    edges.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了FXAA技术。这是一种屏幕空间后处理方法，意味着它直接作用于最终图像。它的主要优势是速度和简单性，在性能和质量之间提供了一个良好的权衡。FXAA通过寻找高对比度像素并将它们与周围环境混合来平滑边缘。尽管是一种近似，但FXAA通常可以在感知图像质量上提供显著的提升，尤其是在具有许多高对比度边缘的场景中。
- en: The third technique we discussed was TAA. This method uses the concept of temporal
    reprojection, where it leverages information from previous frames to minimize
    aliasing artifacts in the current frame. We covered how TAA operates by accumulating
    samples over multiple frames and applying a filter to reduce the temporal aliasing
    effects, such as crawling and flickering. When implemented correctly, TAA can
    offer superior results over purely spatial techniques, particularly in scenes
    with high levels of motion and detail.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的第三种技术是TAA。这种方法利用了时间重投影的概念，即它利用前一帧的信息来最小化当前帧中的锯齿伪影。我们介绍了TAA是如何通过在多个帧上累积样本并应用过滤器来减少时间锯齿效应（如爬行和闪烁）来工作的。当正确实现时，TAA可以在具有高运动和细节水平的场景中提供优于纯粹空间技术的结果。
- en: Lastly, we explored the cutting-edge technique of DLSS. Powered by AI, DLSS
    is a proprietary technology developed by NVIDIA. It works by training a deep learning
    model to predict high-resolution images from lower-resolution inputs. The trained
    model is then used to upscale images in real time. We also talked about how DLSS
    can maintain or even improve visual fidelity while significantly boosting performance.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了DLSS这一前沿技术。DLSS是由NVIDIA开发的专有技术，它利用人工智能进行工作，通过训练一个深度学习模型来预测从低分辨率输入生成的高分辨率图像。训练好的模型随后用于实时提升图像分辨率。我们还讨论了DLSS如何在显著提升性能的同时，保持或甚至提高视觉保真度。
- en: This chapter provided a comprehensive overview of various anti-aliasing techniques,
    each with its strengths and use cases. By understanding these methods, you can
    make informed choices on which technique to implement, based on the specific needs
    of your Vulkan applications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全面概述了各种抗锯齿技术，每种技术都有其优势和适用场景。通过理解这些方法，你可以根据Vulkan应用程序的具体需求，做出明智的选择，决定采用哪种技术。
