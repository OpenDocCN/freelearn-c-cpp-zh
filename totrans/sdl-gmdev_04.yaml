- en: Chapter 4. Exploring Movement and Input Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：探索运动和输入处理
- en: 'We have already covered drawing to the screen and how to handle objects but
    we have not had anything moving around very much yet. Getting input from the user
    and then controlling our game objects is one of the most important topics in game
    development. It can decide the feel and responsiveness of your game and is something
    that a user can really pick up on. In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何在屏幕上绘制以及如何处理对象，但到目前为止还没有任何东西在屏幕上移动。从用户那里获取输入并控制我们的游戏对象是游戏开发中最重要的话题之一。它可以决定游戏的感受和响应速度，并且是用户能够真正感受到的。在本章中，我们将涵盖以下内容：
- en: Cartesian coordinate systems
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笛卡尔坐标系
- en: 2D vectors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D 向量
- en: Creating variables to control the movement of a game object
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建变量以控制游戏对象的运动
- en: Setting up a simple movement system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置简单的运动系统
- en: Setting up input handling from joysticks, keyboard, and mouse
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置来自游戏手柄、键盘和鼠标的输入处理
- en: Creating a fixed frame rate
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建固定帧率
- en: Setting up game objects for movement
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为运动设置游戏对象
- en: In the previous chapter, we gave our objects x and y values which we could then
    use to pass into our drawing code. The x and y values we used can be represented
    using a Cartesian coordinate system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们给我们的对象分配了 x 和 y 值，然后我们可以将这些值传递到我们的绘图代码中。我们使用的 x 和 y 值可以用笛卡尔坐标系来表示。
- en: '![Setting up game objects for movement](img/6821OT_04_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![为运动设置游戏对象](img/6821OT_04_01.jpg)'
- en: The above figure shows a Cartesian coordinate system (flipped on the Y axis)
    with two coordinates. Representing them as (x,y) gives us position 1 as (3,3)
    and position 2 as (7,4). These values can be used to represent a position in 2D
    space. Imagine this figure as a zoomed in image of the top-left corner of our
    game window, with each of the grid squares representing one pixel of our game
    window. With this in mind, we can see how to use these values to draw things to
    the screen in the correct position. We now need a way to update these position
    values so that we can move our objects around. For this we will look at 2D vectors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图显示了一个笛卡尔坐标系（Y 轴翻转）和两个坐标。将它们表示为 (x,y) 给我们位置 1 为 (3,3) 和位置 2 为 (7,4)。这些值可以用来表示
    2D 空间中的位置。想象这个图是我们游戏窗口左上角的放大图像，每个网格方块代表我们游戏窗口的一个像素。考虑到这一点，我们可以看到如何使用这些值在正确的位置上绘制东西。我们现在需要一种方法来更新这些位置值，以便我们可以移动我们的对象。为此，我们将查看
    2D 向量。
- en: What is a vector?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是向量？
- en: A **vector** can be described as an entity with a direction and a magnitude.
    We can use them to represent aspects of our game objects, for example, velocity
    and acceleration, that can be used to create movement. Taking velocity as an example,
    to fully represent the velocity of our objects, we need the direction in which
    they are travelling and also the amount (or magnitude) by which they are heading
    in that direction.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**向量**可以被描述为一个具有方向和大小的实体。我们可以使用它们来表示游戏对象的各个方面，例如速度和加速度，这些可以用来创建运动。以速度为例，为了完全表示我们对象的运动，我们需要它们移动的方向以及它们在该方向上移动的量（或大小）。'
- en: '![What is a vector?](img/6821OT_04_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![什么是向量？](img/6821OT_04_02.jpg)'
- en: 'Let''s define a couple of things about how we will use vectors:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一些关于我们将如何使用向量的内容：
- en: We will represent a vector as v(x,y)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将向量表示为 v(x,y)
- en: 'We can get the length of a vector using the following equation:'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用以下方程式来获取向量的长度：
- en: '![What is a vector?](img/6821OT_04_03.jpg)'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![什么是向量？](img/6821OT_04_03.jpg)'
- en: The preceding figure shows the vector v1(3,-2) which will have a length of √(32+(-22)).
    We can use the x and y components of a vector to represent our object's position
    in 2D space. We can then use some common vector operations to move our objects.
    Before we move onto these operations let's create a vector class called `Vector2D`
    in the project. We can then look at each operation we will need and add them to
    the class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了向量 v1(3,-2)，其长度将为 √(3^2+(-2)^2)。我们可以使用向量的 x 和 y 分量来表示我们的对象在 2D 空间中的位置。然后我们可以使用一些常见的向量运算来移动我们的对象。在我们继续这些运算之前，让我们在项目中创建一个名为
    `Vector2D` 的向量类。然后我们可以查看我们需要的每个运算并将它们添加到类中。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can see that the `Vector2D` class is very simple at this point. We have
    our x and y values and a way to get and set them. We already know how to get the
    length of a vector, so let''s create a function for this purpose:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`Vector2D` 类目前非常简单。我们有 x 和 y 值以及获取和设置它们的方法。我们已经知道如何获取向量的长度，所以让我们创建一个用于此目的的函数：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Some common operations
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些常见运算
- en: Now since we have our basic class in place, we can start to gradually add some
    operations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了基本类，我们可以开始逐渐添加一些操作。
- en: Addition of two vectors
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两个向量的加法
- en: The first operation we will look at is the addition of two vectors. For this
    we simply add together the individual components of each vector.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个操作是两个向量的加法。为此，我们只需将每个向量的各个分量相加。
- en: '![Addition of two vectors](img/6821OT_04_04.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![两个向量的加法](img/6821OT_04_04.jpg)'
- en: 'Let''s make use of overloaded operators to make it easy for us to add two vectors
    together:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用重载的运算符来简化我们添加两个向量的操作：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With these functions we can add two vectors together using the standard addition
    operators, for example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数，我们可以使用标准的加法运算符将两个向量相加，例如：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Multiply by a scalar number
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乘以一个标量数
- en: 'Another operation is to multiply a vector by a regular scalar number. For this
    operation we multiply each component of the vector by the scalar number:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个操作是将向量乘以一个常规的标量数。对于这个操作，我们将向量的每个分量乘以标量数：
- en: '![Multiply by a scalar number](img/6821OT_04_05.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![乘以一个标量数](img/6821OT_04_05.jpg)'
- en: 'We can again use overloaded operators to create these functions:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次使用重载的运算符来创建这些函数：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Subtraction of two vectors
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两个向量的减法
- en: Subtraction is very similar to addition.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 减法与加法非常相似。
- en: '![Subtraction of two vectors](img/6821OT_04_06.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![两个向量的减法](img/6821OT_04_06.jpg)'
- en: 'Let''s create some functions to do this for us:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些函数来为我们完成这项工作：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Divide by a scalar number
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除以一个标量数
- en: By now I am sure you have noticed a pattern emerging and can guess how dividing
    a vector by a scalar will work, but we will cover it anyway.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我相信你已经注意到一个模式的产生，并且可以猜测除以标量向量将如何工作，但无论如何我们都会介绍它。
- en: '![Divide by a scalar number](img/6821OT_04_07.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![除以一个标量数](img/6821OT_04_07.jpg)'
- en: 'And our functions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Normalizing a vector
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规范化一个向量
- en: We need another very important operation and that is the ability to normalize
    a vector. Normalizing a vector makes its length equal to 1\. Vectors with a length
    (magnitude) of 1 are known as unit vectors and are useful to represent just a
    direction, such as the facing direction of an object. To normalize a vector we
    multiply it by the inverse of its length.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要另一个非常重要的操作，那就是向量的规范化能力。规范化一个向量使其长度等于1。长度（大小）为1的向量称为单位向量，用于表示仅方向，例如对象的面向方向。为了规范化一个向量，我们将其乘以其长度的倒数。
- en: '![Normalizing a vector](img/6821OT_04_08.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![规范化一个向量](img/6821OT_04_08.jpg)'
- en: 'We can create a new member function to normalize our vectors:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个新的成员函数来规范化我们的向量：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have a few basic functions in place, let's start to use these vectors
    in our `SDLGameObject` class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一些基本函数，让我们开始在`SDLGameObject`类中使用这些向量。
- en: Adding the Vector2D class
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Vector2D类
- en: Open up `SDLGameObject.h` and we can begin implementing the vectors. First we
    need to include the new `Vector2D` class.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SDLGameObject.h`，我们可以开始实现向量。首先，我们需要包含新的`Vector2D`类。
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We also need to remove the previous `m_x` and `m_y` values and replace them
    with `Vector2D`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要删除之前的`m_x`和`m_y`值，并用`Vector2D`替换它们。
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now we can move to the `SDLGameObject.cpp` file and update the constructor.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以移动到`SDLGameObject.cpp`文件并更新构造函数。
- en: '[PRE10]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We now construct the `m_position` vector using the member initialization list
    and we must also use the `m_position` vector in our draw function.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在使用成员初始化列表构建`m_position`向量，并且必须在我们的绘制函数中使用`m_position`向量。
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: One last thing before we test is to use our vector in the `Enemy::update` function.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试之前，最后一件事是在`Enemy::update`函数中使用我们的向量。
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function will use vector addition very soon, but for now we just add `1`
    to the current position to get the same behavior we already had. We can now run
    the game and we will see that we have implemented a very basic vector system.
    Go ahead and play around with the `Vector2D` functions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将很快使用向量加法，但就目前而言，我们只是将`1`加到当前位置以获得我们之前已经有的相同行为。现在我们可以运行游戏，我们将看到我们已经实现了一个非常基本的向量系统。继续使用`Vector2D`函数进行尝试。
- en: Adding velocity
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加速度
- en: 'We previously had to separately set the `x` and `y` values of our objects,
    but now that our position is a vector, we have the ability to add a new vector
    to it to update our movement. We will call this vector the velocity vector and
    we can think of it as the amount we want our object to move in a specific direction:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前必须单独设置对象的`x`和`y`值，但现在我们的位置是一个向量，我们有能力向它添加一个新的向量以更新我们的移动。我们将这个向量称为速度向量，我们可以将其视为我们想要对象在特定方向上移动的量：
- en: The velocity vector can be represented as follows:![Adding velocity](img/6821OT_04_09.jpg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 速度向量可以表示如下：![添加速度](img/6821OT_04_09.jpg)
- en: We can add this to our `SDLGameObject` update function as this is the way we
    update all derived objects. So first let's create the velocity member variable.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将这个添加到我们的 `SDLGameObject` 更新函数中，因为这是我们更新所有派生对象的方式。所以首先让我们创建速度成员变量。
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We will construct it in the member initialization list as 0,0.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在成员初始化列表中将它设置为 0,0。
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And now we will move to the `SDLGameObject::update` function.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将转向 `SDLGameObject::update` 函数。
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can test this out in one of our derived classes. Move to `Player.cpp` and
    add the following:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在我们的派生类中测试这一点。转到 `Player.cpp` 并添加以下内容：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We set the `m_velocity` x value to 1\. This means that we will add `1` to our
    `m_position` x value each time the update function is called. Now we can run this
    to see our object move using the new velocity vector.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `m_velocity` 的 x 值设置为 1。这意味着每次调用更新函数时，我们将向 `m_position` 的 x 值添加 `1`。现在我们可以运行这个来看到我们的对象使用新的速度向量移动。
- en: Adding acceleration
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加加速度
- en: Not all of our objects will move along at a constant velocity. Some games will
    require that we gradually increase the velocity of our object using acceleration.
    A car or a spaceship are good examples. No one would expect these objects to hit
    their top speed instantaneously. We are going to need a new vector for acceleration,
    so let's add this into our `SDLGameObject.h` file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有对象都会以恒定的速度移动。一些游戏可能需要我们通过加速度逐渐增加对象的速率。汽车或宇宙飞船是很好的例子。没有人会期望这些对象瞬间达到最高速度。我们需要一个新的加速度向量，所以让我们将其添加到我们的
    `SDLGameObject.h` 文件中。
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then we can add it to our `update` function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将其添加到我们的 `update` 函数中。
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now alter our `Player::update` function to set the acceleration rather than
    the velocity.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在修改我们的 `Player::update` 函数，使其设置加速度而不是速度。
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After running our game you will see that the object gradually picks up speed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的游戏后，你会看到对象逐渐加速。
- en: Creating fixed frames per second
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建固定每秒帧数
- en: Earlier in the book we put in an `SDL_Delay` function to slow everything down
    and ensure that our objects weren't moving too fast. We will now expand upon that
    by making our game run at a fixed frame rate. Fixed frames per second (FPS) is
    not necessarily always a good option, especially when your game includes more
    advanced physics. It is worth bearing this in mind when you move on from this
    book and start developing your own games. Fixed FPS will, however, be fine for
    the small 2D games, which we will work towards in this book.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期，我们添加了一个 `SDL_Delay` 函数来减慢一切速度并确保我们的对象不会移动得太快。现在我们将在此基础上扩展，使我们的游戏以固定帧率运行。固定每秒帧数（FPS）并不一定总是好的选择，尤其是当你的游戏包含更高级的物理时。当你从本书中继续前进并开始开发自己的游戏时，这一点值得记住。然而，对于本书中我们将要努力实现的简单
    2D 游戏，固定 FPS 将是合适的。
- en: 'With that said, let''s move on to the code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们继续看代码：
- en: Open up `main.cpp` and we will create a few constant variables.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `main.cpp` 文件，我们将创建一些常量变量。
- en: '[PRE20]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we define how many frames per second we want our game to run at. A frame
    rate of 60 frames per second is a good starting point as this is essentially synced
    up to the refresh rate of most modern monitors and TVs. We can then divide this
    by the number of milliseconds in a second, giving us the amount of time we need
    to delay the game between loops to keep our constant frame rate. We need another
    two variables at the top of our main function; these will be used in our calculations.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们定义了我们的游戏希望以多少帧每秒运行。每秒 60 帧的帧率是一个好的起点，因为这基本上与大多数现代显示器和电视的刷新率同步。然后我们可以将这个除以一秒钟中的毫秒数，得到我们在循环之间延迟游戏所需的时间，以保持恒定的帧率。我们还需要在主函数的顶部添加另外两个变量；这些将用于我们的计算。
- en: '[PRE21]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can now implement our fixed frame rate in our main loop.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在主循环中实现我们的固定帧率。
- en: '[PRE22]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First we get the time at the start of our loop and store it in `frameStart`.
    For this we use `SDL_GetTicks` which returns the amount of milliseconds since
    we called `SDL_Init`. We then run our game loop and store how long it took to
    run by subtracting the time our frame started from the current time. If it is
    less than the time we want a frame to take, we call `SDL_Delay` and make our loop
    wait for the amount of time we want it to, subtracting how long the loop already
    took to complete.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在循环开始时获取时间并将其存储在`frameStart`中。为此，我们使用`SDL_GetTicks`，它返回自我们调用`SDL_Init`以来的毫秒数。然后我们运行我们的游戏循环，并通过从帧开始的时间减去当前时间来存储运行所需的时间。如果它小于我们想要的帧所需的时间，我们就调用`SDL_Delay`，使我们的循环等待我们想要的时间，并减去循环已经完成所需的时间。
- en: Input handling
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入处理
- en: We have now got our objects moving based on velocity and acceleration, so next
    we must introduce some way of controlling this movement through user input. SDL
    supports a number of different types of user interface devices including joysticks,
    gamepads, mouse, and keyboard, all of which will be covered in this chapter, along
    with how to add them into our framework implementation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经根据速度和加速度使对象移动，因此接下来我们必须引入一种方法来通过用户输入控制这种移动。SDL支持多种不同类型用户界面设备，包括游戏手柄、游戏控制器、鼠标和键盘，这些内容将在本章中介绍，以及如何将它们添加到我们的框架实现中。
- en: Creating our input handler class
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的输入处理类
- en: We will create a class that handles all device input, whether it is from controllers,
    keyboard, or mouse. Let's start with a basic class and build from there. First
    we need a header file, `InputHandler.h`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个类来处理所有设备输入，无论它来自控制器、键盘还是鼠标。让我们从一个基本的类开始，并在此基础上构建。首先，我们需要一个头文件，`InputHandler.h`。
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is our singleton `InputHandler`. So far we have an `update` function which
    will poll for events and update our `InputHandler` accordingly, and a clean function
    which will clear any devices we have initialized. As we start adding device support
    we will flesh this out a lot more.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的单例`InputHandler`。到目前为止，我们有一个`update`函数，它将轮询事件并相应地更新我们的`InputHandler`，还有一个干净的函数，它将清除我们已初始化的任何设备。随着我们开始添加设备支持，我们将进一步完善这个功能。
- en: Handling joystick/gamepad input
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理游戏手柄/游戏控制器输入
- en: There are tons of joysticks and gamepads out there, often with different amounts
    of buttons and analog sticks amongst other things. PC game developers have a lot
    to do when trying to support all of these different gamepads. SDL has good support
    for joysticks and gamepads, so we should be able to come up with a system that
    would not be difficult to extend for different gamepad support.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 目前市面上有大量的游戏手柄和游戏控制器，它们通常具有不同数量的按钮和模拟摇杆等不同功能。当PC游戏开发者试图支持所有这些不同的游戏控制器时，他们有很多事情要做。SDL对游戏手柄和游戏控制器的支持很好，因此我们应该能够设计出一个系统，该系统不会很难扩展以支持不同的游戏控制器。
- en: SDL joystick events
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SDL 游戏手柄事件
- en: There are a few different structures for handling joystick events in SDL. The
    table below lists each one and their purpose.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: SDL中有几种不同的结构用于处理游戏手柄事件。下表列出了每一个及其用途。
- en: '| SDL joystick event | Purpose |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| SDL 游戏手柄事件 | 用途 |'
- en: '| --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SDL_JoyAxisEvent` | Axis motion information |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_JoyAxisEvent` | 轴运动信息 |'
- en: '| `SDL_JoyButtonEvent` | Button press and release information |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_JoyButtonEvent` | 按钮按下和释放信息 |'
- en: '| `SDL_JoyBallEvent` | Trackball event motion information |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_JoyBallEvent` | 轨迹球事件运动信息 |'
- en: '| `SDL_JoyHatEvent` | Joystick hat position change |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_JoyHatEvent` | 游戏手柄帽子位置变化 |'
- en: The events we are most interested in are the axis motion and the button press
    events. Each of these events also has an enumerated type that we can check for
    in our event loop to ensure we are only handling the events we want to handle.
    The table below shows the type value for each of the above events.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最感兴趣的事件是轴运动和按钮按下事件。这些事件中的每一个都有一个枚举类型，我们可以在事件循环中检查以确保我们只处理我们想要处理的事件。下表显示了上述每个事件的类型值。
- en: '| SDL joystick event | Type value |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| SDL 游戏手柄事件 | 类型值 |'
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SDL_JoyAxisEvent` | `SDL_JOYAXISMOTION` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_JoyAxisEvent` | `SDL_JOYAXISMOTION` |'
- en: '| `SDL_JoyButtonEvent` | `SDL_JOYBUTTONDOWN` or `SDL_JOYBUTTONUP` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_JoyButtonEvent` | `SDL_JOYBUTTONDOWN` 或 `SDL_JOYBUTTONUP` |'
- en: '| `SDL_JoyBallEvent` | `SDL_JOYBALLMOTION` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_JoyBallEvent` | `SDL_JOYBALLMOTION` |'
- en: '| `SDL_JoyHatEvent` | `SDL_JOYHATMOTION` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_JoyHatEvent` | `SDL_JOYHATMOTION` |'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's a good idea to use the **Joystick Control Panel** property in Windows or
    **JoystickShow** on OSX to find out which button numbers you will need to use
    in SDL for a specific button. These applications are invaluable for finding out
    things about your joystick/gamepad so you can support them properly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Windows中的**Joystick Control Panel**属性或OSX上的**JoystickShow**来查找您在SDL中需要使用的特定按钮的按钮编号是个好主意。这些应用程序对于了解您的摇杆/游戏手柄信息，以便正确支持它们非常有价值。
- en: 'The code we will put in place will assume we are using a Microsoft Xbox 360
    controller (which can be used on PC or OSX), as this is an extremely popular controller
    for PC gaming. Other controllers, such as the PS3 controller, could possibly have
    different values for buttons and axes. The Xbox 360 controller consists of the
    following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将放置的代码将假设我们正在使用微软Xbox 360控制器（可以在PC或OSX上使用），因为这是PC游戏中最受欢迎的控制器之一。其他控制器，如PS3控制器，按钮和轴可能具有不同的值。Xbox
    360控制器由以下部分组成：
- en: Two analog sticks
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个模拟摇杆
- en: Analog sticks press as buttons
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟摇杆按键
- en: Start and Select buttons
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始和选择按钮
- en: 'Four face buttons: A, B, X, and Y'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个方向按钮：A、B、X和Y
- en: 'Four triggers: two digital and two analog'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个扳机：两个数字和两个模拟
- en: A digital directional pad
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字方向垫
- en: Initializing joysticks
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化摇杆
- en: To use gamepads and joysticks in SDL we first need to initialize them. We are
    going to add a new public function to the `InputHandler` class. This function
    will find out how many joysticks SDL has access to and then initialize them.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在SDL中使用游戏手柄和摇杆，我们首先需要初始化它们。我们将在`InputHandler`类中添加一个新的公共函数。这个函数将找出SDL可以访问多少个摇杆，然后初始化它们。
- en: '[PRE24]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We will also declare some private member variables that we will need.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将声明一些我们将需要的私有成员变量。
- en: '[PRE25]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `SDL_Joystick*` is a pointer to the joystick we will be initializing. We
    won't actually need these pointers when using the joysticks, but we do need to
    close them after we are done, so it is helpful for us to keep a list of them for
    later access. We will now define our `initialiseJoysticks` function and then go
    through it.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SDL_Joystick*`是指向我们将要初始化的摇杆的指针。当我们使用摇杆时，我们实际上不需要这些指针，但我们在完成后需要关闭它们，因此保留一个列表以供以后访问是有帮助的。我们现在将定义我们的`initialiseJoysticks`函数，然后通过它进行操作。'
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's go through this line-by-line. First we check whether the joystick subsystem
    has been initialized using `SDL_WasInit`. If it has not been initialized we then
    initialize it using `SDL_InitSubSystem`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们逐行分析。首先，我们使用`SDL_WasInit`检查摇杆子系统是否已初始化。如果没有初始化，我们使用`SDL_InitSubSystem`来初始化它。
- en: '[PRE27]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next is the opening of each available joystick. Before we attempt to open the
    objects, we use `SDL_NumJoysticks` to make sure there are some joysticks available.
    We can then loop through the number of joysticks, opening them in turn with `SDL_JoystickOpen`.
    They can then be pushed into our array for closing later.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是打开每个可用的摇杆。在我们尝试打开对象之前，我们使用`SDL_NumJoysticks`来确保有一些摇杆可用。然后我们可以遍历摇杆的数量，依次使用`SDL_JoystickOpen`打开它们。然后它们可以被推入我们的数组以便稍后关闭。
- en: '[PRE28]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, we tell SDL to start listening for joystick events by enabling `SDL_JoystickEventState`.
    We also set our `m_bJoysticksEnabled` member variable according to how our initialization
    went.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们告诉SDL开始监听摇杆事件，通过启用`SDL_JoystickEventState`。我们还根据初始化的结果设置我们的`m_bJoysticksEnabled`成员变量。
- en: '[PRE29]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So, we now have a way to initialize our joysticks. We have two other functions
    to define, the `update` and `clean` functions. The `clean` function will loop
    through our `SDL_Joystick*` array and call `SDL_JoystickClose` on each iteration.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们现在有了一种初始化我们的摇杆的方法。我们还需要定义另外两个函数，即`update`和`clean`函数。`clean`函数将遍历我们的`SDL_Joystick*`数组，并在每次迭代中调用`SDL_JoystickClose`。
- en: '[PRE30]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `update` function will be called in each frame in the main game loop to
    update the event state. For now though it will simply listen for a quit event
    and call the game's `quit` function (this function simply calls `SDL_Quit()`).
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update`函数将在主游戏循环的每一帧中被调用以更新事件状态。不过，目前它将简单地监听退出事件并调用游戏的`quit`函数（这个函数简单地调用`SDL_Quit()`）。'
- en: '[PRE31]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now we will use this `InputHandler` in our `Game` class functions. First we
    call `initialiseJoysticks` in the `Game::init` function.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在我们的`Game`类函数中使用这个`InputHandler`。首先，我们在`Game::init`函数中调用`initialiseJoysticks`。
- en: '[PRE32]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And we will update it in the `Game::handleEvents` function, clearing out anything
    we had before:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在`Game::handleEvents`函数中更新它，清除之前的内容：
- en: '[PRE33]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `clean` function can also be added to our `Game::clean` function.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以将`clean`函数添加到我们的`Game::clean`函数中。
- en: '[PRE34]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can now plug in a pad or joystick and run the build. If everything is working
    according to plan we should get the following output, with `x` being the number
    of joysticks you have plugged in:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以插入一个手柄或操纵杆并运行构建。如果一切按计划进行，我们应该得到以下输出，其中`x`是您插入的操纵杆数量：
- en: '[PRE35]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Ideally we want to easily use one or more controllers with no change to our
    code. We already have a way to load in and open as many controllers that are plugged
    in, but we need to know which event corresponds to which controller; we do this
    using some information stored in the event. Each joystick event will have a `which`
    variable stored within it. Using this will allow us to find out which joystick
    the event came from.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望能够轻松地使用一个或多个控制器，而无需更改我们的代码。我们已经有了一种方法来加载和打开已插入的控制器，但我们需要知道哪个事件对应哪个控制器；我们通过在事件中存储的一些信息来完成这项工作。每个操纵杆事件都将有一个存储在其内的`which`变量。使用这个变量将允许我们找出事件来自哪个操纵杆。
- en: '[PRE36]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Listening for and handling axis movement
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听和处理轴移动
- en: We are not going to handle the analog sticks in an analog way. Instead they
    will be handled as digital information, that is, they are either on or off. Our
    controller has four axes of motion, two for the left analog stick and two for
    the right.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会以模拟的方式处理模拟摇杆。相反，它们将被处理为数字信息，即它们要么开启要么关闭。我们的控制器有四个运动轴，两个用于左模拟摇杆，两个用于右模拟摇杆。
- en: 'We will make the following assumptions about our controller (you can use an
    external application to find out the specific values for your controller):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对我们的控制器做出以下假设（您可以使用外部应用程序来找出您控制器的具体值）：
- en: Left and right movement on stick one is axis 0
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一号摇杆的左右移动是轴0
- en: Up and down movement on stick one is axis 1
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一号摇杆的上下移动是轴1
- en: Left and right movement on stick two is axis 3
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二号摇杆的左右移动是轴3
- en: Up and down movement on stick two is axis 4
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二号摇杆的上下移动是轴4
- en: The Xbox 360 controller uses axes 2 and 5 for the analog triggers. To handle
    multiple controllers with multiple axes we will create a vector of pairs of `Vector2D*`,
    one for each stick.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Xbox 360控制器使用轴2和5作为模拟触发器。为了处理具有多个轴的多台控制器，我们将创建一个`Vector2D*`对的向量，每个摇杆一个。
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We use the `Vector2D` values to set whether a stick has moved up, down, left,
    or right. Now when we initialize our joysticks we need to create a pair of `Vector2D*`
    in the `m_joystickValues` array.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Vector2D`值来设置摇杆是否向上、向下、向左或向右移动。现在当我们初始化我们的操纵杆时，我们需要在`m_joystickValues`数组中创建一个`Vector2D*`对。
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We need a way to grab the values we need from this array of pairs; we will
    declare two new functions to the `InputHandler` class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来从这对数组的值中获取我们需要的值；我们将在`InputHandler`类中声明两个新函数：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `joy` parameter is the identifier (ID) of the joystick we want to use,
    and the stick is 1 for the left stick and 2 for the right stick. Let''s define
    these functions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`joy`参数是我们想要使用的操纵杆的标识符（ID），摇杆为1表示左摇杆，为2表示右摇杆。让我们定义这些函数：'
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So we grab the x or y value based on the parameters passed to each function.
    The `first` and `second` values are the first or second objects of the pair in
    the array, with `joy` being the index of the array. We can now set these values
    accordingly in the event loop.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 根据传递给每个函数的参数，我们获取x或y值。`first`和`second`值是数组中这对的第一个或第二个对象，其中`joy`是数组的索引。我们现在可以在事件循环中相应地设置这些值。
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That is a big function! It is, however, relatively straightforward. We first
    check for an `SDL_JOYAXISMOTION` event and we then find out which controller the
    event came from using the `which` value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很大的函数！然而，它相对简单。我们首先检查`SDL_JOYAXISMOTION`事件，然后使用`which`值找出事件来自哪个控制器。
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'From this we know which joystick the event came from and can set a value in
    the array accordingly; for example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里我们可以知道事件来自哪个操纵杆，并可以相应地在数组中设置一个值；例如：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'First we check the axis the event came from:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查事件来自哪个轴：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If the axis is 0 or 1, it is the left stick, and if it is 3 or 4, it is the
    right stick. We use `first` or `second` of the pair to set the left or right stick.
    You may also have noticed the `m_joystickDeadZone` variable. We use this to account
    for the sensitivity of a controller. We can set this as a constant variable in
    the `InputHandler` header file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果轴是0或1，则是左摇杆，如果是3或4，则是右摇杆。我们使用这对的`first`或`second`来设置左摇杆或右摇杆。您可能也注意到了`m_joystickDeadZone`变量。我们使用这个变量来考虑控制器的灵敏度。我们可以在`InputHandler`头文件中将此作为常量变量设置：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The value `10000` may seem like a big value to use for a stick at rest, but
    the sensitivity of a controller can be very high and so requires a value as large
    as this. Change this value accordingly for your own controllers.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`10000`这个值可能看起来对于静止的摇杆来说很大，但控制器的灵敏度可能非常高，因此需要这么大的值。根据您自己的控制器相应地更改此值。'
- en: Just to solidify what we are doing here, let's look closely at one scenario.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固我们在这里所做的工作，让我们仔细看看一个场景。
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If we get to the second if statement, we know that we are dealing with a left
    or right movement event on the left stick due to the axis being 0\. We have already
    set which controller the event was from and adjusted `whichOne` to the correct
    value. We also want `first` of the pair to be the left stick. So if the axis is
    0, we use the `first` object of the array and set its x value, as we are dealing
    with an x movement event. So why do we set the value to 1 or -1? We will answer
    this by starting to move our `Player` object.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们到达第二个if语句，我们知道我们正在处理左摇杆的左右移动事件，因为轴是0。我们已经设置了事件来自哪个控制器，并将`whichOne`调整为正确的值。我们还想让这对中的`first`是左摇杆。所以如果轴是0，我们使用数组的`first`对象并设置其x值，因为我们正在处理一个x移动事件。那么为什么我们将值设置为1或-1呢？我们将通过开始移动我们的`Player`对象来回答这个问题。
- en: 'Open up `Player.h` and we can start to use our `InputHandler` to get events.
    First we will declare a new private function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Player.h`，我们可以开始使用我们的`InputHandler`来获取事件。首先，我们将声明一个新的私有函数：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now in our `Player.cpp` file we can define this function to work with the `InputHandler`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们的`Player.cpp`文件中，我们可以定义这个函数，使其与`InputHandler`一起工作。
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Then we can call this function in the `Player::update` function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在`Player::update`函数中调用这个函数。
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Everything is in place now, but first let's go through how we are setting our
    movement.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都已经就绪，但首先让我们看看我们是如何设置我们的移动方式的。
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we first check whether `xvalue` of the left stick is more than 0 (that
    it has moved). If so, we set our `Player` x velocity to be the speed we want multiplied
    by `xvalue` of the left stick, and we know this is either 1 or -1\. As you will
    know, multiplying a positive number by a negative number results in a negative
    number, so multiplying the speed we want by -1 will mean we are setting our x
    velocity to a minus value (move left). We do the same for the other stick and
    also the y values. Build the project and start moving your `Player` object with
    a gamepad. You could also plug in another controller and update the `Enemy` class
    to use it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先检查左摇杆的`xvalue`是否大于0（它已经移动了）。如果是这样，我们将我们的`Player` x速度设置为想要的速率乘以左摇杆的`xvalue`，我们知道这是1或-1。正如你所知道的那样，一个正数乘以一个负数的结果是一个负数，所以将我们想要的速率乘以-1意味着我们将我们的x速度设置为负值（向左移动）。我们对其他摇杆和y值也做同样的处理。构建项目并使用游戏手柄开始移动你的`Player`对象。你也可以插入另一个控制器，并更新`Enemy`类以使用它。
- en: Dealing with joystick button input
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理摇杆按钮输入
- en: Our next step is to implement a way to handle button input from our controllers.
    This is actually a lot simpler than handling axes. We need to know the current
    state of each button so that we can check whenever one has been pressed or released.
    To do this, we will declare an array of Boolean values, so each controller (the
    first index into the array) will have an array of Boolean values, one for each
    button on the controller.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的步骤是实现处理控制器按钮输入的方法。实际上，这比处理轴要简单得多。我们需要知道每个按钮的当前状态，以便我们可以检查是否有一个被按下或释放。为此，我们将声明一个布尔值数组，因此每个控制器（数组的第一个索引）将有一个布尔值数组，每个控制器上的一个按钮对应一个布尔值。
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can grab the current button state with a function that looks up the correct
    button from the correct joystick.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个查找正确摇杆上正确按钮的功能来获取当前按钮状态。
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first parameter is the index into the array (the joystick ID), and the second
    is the index into the buttons. Next we are going to have to initialize this array
    for each controller and each of its buttons. We will do this in the `initialiseJoysticks`
    function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是数组的索引（摇杆ID），第二个是按钮的索引。接下来，我们必须为每个控制器及其每个按钮初始化这个数组。我们将在`initialiseJoysticks`函数中完成这项工作。
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We use `SDL_JoystickNumButtons` to get the number of buttons for each of our
    joysticks. We then push a value for each of these buttons into an array. We push
    `false` to start, as no buttons are pressed. This array is then pushed into `our
    m_buttonStates` array to be used with the `getButtonState` function. Now we must
    listen for button events and set the value in the array accordingly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`SDL_JoystickNumButtons`来获取每个摇杆的按钮数量。然后我们将每个按钮的值推入一个数组。我们开始时推入`false`，因为没有按钮被按下。然后这个数组被推入`our
    m_buttonStates`数组，以便与`getButtonState`函数一起使用。现在我们必须监听按钮事件并相应地设置数组中的值。
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When a button is pressed (`SDL_JOYBUTTONDOWN`) we get to know which controller
    it was pressed on and use this as an index into the `m_buttonStates` array. We
    then use the button number (`event.jbutton.button`) to set the correct button
    to `true`; the same applies when a button is released (`SDL_JOYBUTTONUP`). That
    is pretty much it for button handling. Let's test it out in our Player class.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被按下（`SDL_JOYBUTTONDOWN`）时，我们可以知道哪个控制器被按下，并使用这个作为`m_buttonStates`数组的索引。然后我们使用按钮号（`event.jbutton.button`）来设置正确的按钮为`true`；当按钮被释放（`SDL_JOYBUTTONUP`）时，也是同样的处理。这就是按钮处理的主要内容。让我们在我们的`Player`类中测试一下。
- en: '[PRE55]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here we are checking if button 3 has been pressed (Yellow or Y on an Xbox controller)
    and setting our velocity if it has. That is everything we will cover about joysticks
    in this book. You will realize that supporting many joysticks is very tricky and
    requires a lot of tweaking to ensure each one is handled correctly. However, there
    are ways through which you can start to have support for many joysticks; for example,
    through a configuration file or even by the use of inheritance for different joystick
    types.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查按钮3是否被按下（在Xbox控制器上为黄色或Y键），如果按下，则设置我们的速度。这就是本书中关于摇杆的所有内容。你会意识到支持多个摇杆非常复杂，需要大量调整以确保每个摇杆都能正确处理。然而，有方法可以开始支持多个摇杆；例如，通过配置文件或甚至通过使用继承来处理不同类型的摇杆。
- en: Handling mouse events
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理鼠标事件
- en: 'Unlike joysticks, we do not have to initialize the mouse. We can also safely
    assume that there will only be one mouse plugged in at a time, so we will not
    need to handle multiple mouse devices. We can start by looking at the available
    mouse events that SDL covers:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与摇杆不同，我们不需要初始化鼠标。我们还可以安全地假设一次只会插入一个鼠标，因此我们不需要处理多个鼠标设备。我们可以从查看SDL提供的可用鼠标事件开始：
- en: '| SDL Mouse Event | Purpose |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| SDL 鼠标事件 | 目的 |'
- en: '| --- | --- |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SDL_MouseButtonEvent` | A button on the mouse has been pressed or released
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_MouseButtonEvent` | 鼠标上的按钮已被按下或释放 |'
- en: '| `SDL_MouseMotionEvent` | The mouse has been moved |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_MouseMotionEvent` | 鼠标已移动 |'
- en: '| `SDL_MouseWheelEvent` | The mouse wheel has moved |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_MouseWheelEvent` | 鼠标滚轮已移动 |'
- en: 'Just like the joystick events, each mouse event has a type value; the following
    table shows each of these values:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 就像摇杆事件一样，每个鼠标事件都有一个类型值；以下表格显示了这些值：
- en: '| SDL Mouse Event | Type Value |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| SDL 鼠标事件 | 类型值 |'
- en: '| --- | --- |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SDL_MouseButtonEvent` | `SDL_MOUSEBUTTONDOWN` or `SDL_MOUSEBUTTONUP` |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_MouseButtonEvent` | `SDL_MOUSEBUTTONDOWN` 或 `SDL_MOUSEBUTTONUP` |'
- en: '| `SDL_MouseMotionEvent` | `SDL_MOUSEMOTION` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_MouseMotionEvent` | `SDL_MOUSEMOTION` |'
- en: '| `SDL_MouseWheelEvent` | `SDL_MOUSEWHEEL` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `SDL_MouseWheelEvent` | `SDL_MOUSEWHEEL` |'
- en: We will not implement any mouse wheel movement events as most games will not
    use them.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会实现任何鼠标滚轮移动事件，因为大多数游戏都不会使用它们。
- en: Using mouse button events
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用鼠标按钮事件
- en: 'Implementing mouse button events is as straightforward as joystick events,
    more so even as we have only three buttons to choose from: left, right, and middle.
    SDL numbers these as 0 for left, 1 for middle, and 2 for right. In our `InputHandler`
    header, let''s declare a similar array to the joystick buttons, but this time
    a one-dimensional array, as we won''t handle multiple mouse devices.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 实现鼠标按钮事件与摇杆事件一样简单，甚至更简单，因为我们只有三个按钮可供选择：左键、右键和中键。SDL将这些分别编号为0（左键）、1（中键）和2（右键）。在我们的`InputHandler`头文件中，让我们声明一个与摇杆按钮相似的数组，但这次是一个一维数组，因为我们不会处理多个鼠标设备。
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then in the constructor of our `InputHandler` we can push our three mouse button
    states (defaulted to `false`) into the array:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在我们的`InputHandler`构造函数中，我们可以将我们的三个鼠标按钮状态（默认为`false`）推入数组：
- en: '[PRE57]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Back in our header file, let's create an `enum` attribute to help us with the
    values of the mouse buttons. Put this above the class so that other files that
    include our `InputHandler.h` header can use it too.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的头文件中，让我们创建一个`enum`属性来帮助我们处理鼠标按钮的值。把这个属性放在类上方，这样其他包含我们的`InputHandler.h`头文件的文件也可以使用它。
- en: '[PRE58]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now let''s handle mouse events in our event loop:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的事件循环中处理鼠标事件：
- en: '[PRE59]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We also need a function to access our mouse button states. Let''s add this
    public function to the `InputHandler` header file:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个函数来访问我们的鼠标按钮状态。让我们在`InputHandler`头文件中添加这个公共函数：
- en: '[PRE60]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: That is everything we need for mouse button events. We can now test it in our
    `Player` class.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要的所有关于鼠标按钮事件的内容。现在我们可以在`Player`类中测试它。
- en: '[PRE61]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Handling mouse motion events
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理鼠标移动事件
- en: 'Mouse motion events are very important, especially in big 3D first or third
    person action titles. For our 2D games, we might want our character to follow
    the mouse as a way to control our objects, or we might want objects to move to
    where the mouse was clicked (for a strategy game perhaps). We may even just want
    to know where the mouse was clicked so that we can use it for menus. Fortunately
    for us, mouse motion events are relatively simple. We will start by creating a
    private `Vector2D*` in the header file to use as the position variable for our
    mouse:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标移动事件非常重要，尤其是在大型3D第一人称或第三人称动作游戏中。对于我们的2D游戏，我们可能想让我们的角色跟随鼠标作为控制对象的一种方式，或者我们可能想让对象移动到鼠标点击的位置（例如，在策略游戏中）。我们甚至可能只想知道鼠标点击的位置，以便我们可以用它来制作菜单。幸运的是，鼠标移动事件相对简单。我们首先在头文件中创建一个私有的`Vector2D*`，用作鼠标的位置变量：
- en: '[PRE62]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we need a public accessor for this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个公共访问器来获取这个：
- en: '[PRE63]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And we can now handle this in our event loop:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的事件循环中处理这个了：
- en: '[PRE64]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'That is all we need for mouse motion. So let''s make our `Player` function
    follow the mouse position to test this feature:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是处理鼠标移动所需的所有内容。所以，让我们让我们的`Player`函数跟随鼠标位置来测试这个功能：
- en: '[PRE65]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here we have set our velocity to a vector from the player's current position
    to the mouse position. You can get this vector by subtracting the desired location
    from the current location; we already have a vector subtract overloaded operator
    so this is easy for us. We also divide the vector by 100; this just dampens the
    speed slightly so that we can see it following rather than just sticking to the
    mouse position. Remove the `/` to have your object follow the mouse exactly.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将速度设置为从玩家当前位置到鼠标位置的向量。你可以通过从当前位置减去期望的位置来获取这个向量；我们已经有了一个向量减法重载运算符，所以这对我们来说很容易。我们还把这个向量除以100；这只是为了稍微降低速度，这样我们就可以看到它跟随鼠标而不是仅仅停留在鼠标位置。如果你想使你的对象精确跟随鼠标，请移除`/`。
- en: Implementing keyboard input
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现键盘输入
- en: Our final method of input, and the simplest of the three, is keyboard input.
    We don't have to handle any motion events, we just want the state of each button.
    We aren't going to declare an array here because SDL has a built-in function that
    will give us an array with the state of every key; 1 being pressed and 0 not pressed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的输入方法是键盘输入。我们不需要处理任何移动事件，我们只想知道每个按钮的状态。我们不会在这里声明一个数组，因为SDL有一个内置函数会给我们一个包含每个键状态的数组；1表示按下，0表示未按下。
- en: '[PRE66]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `numkeys` parameter will return the number of keys available on the keyboard
    (the length of the `keystate` array). So in our `InputHandler` header we can declare
    a pointer to the array that will be returned from `SDL_GetKeyboardState`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`numkeys`参数将返回键盘上可用的键的数量（`keystate`数组的长度）。所以，在我们的`InputHandler`头文件中，我们可以声明一个指向`SDL_GetKeyboardState`返回的数组的指针。'
- en: '[PRE67]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: When we update our event handler we can also update the state of the keys; put
    this at the top of our event loop.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新事件处理器时，我们也可以更新键的状态；把这个放在事件循环的顶部。
- en: '[PRE68]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We will now need to create a simple function that checks whether a key is down
    or not.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要创建一个简单的函数来检查一个键是否被按下。
- en: '[PRE69]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This function takes `SDL_SCANCODE` as a parameter. The full list of `SDL_SCANCODE`
    values can be found in the SDL documentation at [http://wiki.libsdl.org/moin.cgi](http://wiki.libsdl.org/moin.cgi).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受`SDL_SCANCODE`作为参数。`SDL_SCANCODE`的所有值可以在SDL文档中找到，具体请参阅[http://wiki.libsdl.org/moin.cgi](http://wiki.libsdl.org/moin.cgi)。
- en: We can test the keys in our `Player` class. We will use the arrow keys to move
    our player.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Player`类中测试这些键。我们将使用箭头键来移动我们的玩家。
- en: '[PRE70]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We now have key handling in place. Test as many keys as you can and look up
    the `SDL_Scancode` for the keys you are most likely to want to use.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了键处理。尽可能多地测试键，并查找你最可能想要使用的键的`SDL_Scancode`。
- en: Wrapping things up
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'We have now implemented all of the devices we are going to handle, but at the
    moment our event loop is in a bit of a mess. We need to break it up into more
    manageable chunks. We will do this with the use of a switch statement for event
    types and some private functions, within our `InputHandler`. First let''s declare
    our functions in the header file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了将要处理的全部设备，但此刻我们的事件循环有些混乱。我们需要将其分解成更易于管理的块。我们将通过使用事件类型的switch语句和一些私有函数，在我们的`InputHandler`中实现这一点。首先，让我们在头文件中声明我们的函数：
- en: '[PRE71]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We pass in the event from the event loop into each function (apart from keys)
    so that we can handle them accordingly. We now need to create our switch statement
    in the event loop.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将事件循环中的事件传递给每个函数（除了键以外），这样我们就可以相应地处理它们。现在我们需要在事件循环中创建我们的switch语句。
- en: '[PRE72]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As you can see, we now break up our event loop and call the associated function
    depending on the type of the event. We can now split all our previous work into
    these functions; for example, we can put all of our mouse button down handling
    code into the `onMouseButtonDown` function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在分解了事件循环，根据事件类型调用相关的函数。现在我们可以将所有之前的工作拆分到这些函数中；例如，我们可以将所有鼠标按钮按下处理代码放入`onMouseButtonDown`函数中。
- en: '[PRE73]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The rest of the code for the `InputHandler` is available within the source code
    downloads.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputHandler`的其余代码可以在源代码下载中找到。'
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered some complicated material in this chapter. We have looked at
    a small amount of vector mathematics and how we can use it to move our game objects.
    We've also covered the initialization and the use of multiple joysticks and axes
    and the use of a mouse and a keyboard. Finally, we wrapped everything up with
    a tidy way to handle our events.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些复杂的内容。我们查看了一小部分向量数学以及我们如何使用它来移动游戏对象。我们还介绍了多个摇杆和轴的初始化和使用，以及鼠标和键盘的使用。最后，我们以一种整洁的方式处理了所有事件。
