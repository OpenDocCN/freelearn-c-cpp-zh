["```cpp\n    constexpr uint32_t kNumLines = 65'536;\n    struct Line {\n      glm::vec4 v0_;\n      glm::vec4 color0_;\n      glm::vec4 v1_;\n      glm::vec4 color1_;\n    };\n    struct Header {\n      uint32_t maxNumlines_;\n      uint32_t padding0 = 0u;\n      uint32_t padding1 = 0u;\n      uint32_t padding2 = 0u;\n      VkDrawIndirectCommand cmd_;\n    };\n    struct GPULineBuffer {\n      Header header_;\n      Line lines_[kNumLines];\n    };\n    ```", "```cpp\nstd::shared_ptr<VulkanCore::Buffer> gpuLineBuffer;\ngpuLineBuffer = context.createBuffer(\n    kGPULinesBufferSize,\n    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT |\n        VK_BUFFER_USAGE_STORAGE_BUFFER_BIT |\n        VK_BUFFER_USAGE_TRANSFER_DST_BIT,\n    static_cast<VmaMemoryUsage>(\n        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT));\n```", "```cpp\n    struct Line {\n      vec3 v0;\n      vec4 c0;\n      vec3 v1;\n      vec4 c1;\n    };\n    struct VkDrawIndirectCommand {\n      uint vertexCount;\n      uint instanceCount;\n      uint firstVertex;\n      uint firstInstance;\n    };\n    layout(set = 4, binding = 0) buffer GPULinesBuffer\n    {\n      uint size;\n      uint row;\n      uint pad1;\n      uint pad2;\n      VkDrawIndirectCommand cmd;\n      Line lines[];\n    } lineBuffer;\n    void addLine(vec3 v0, vec3 v1, vec4 c0, vec4 c1) {\n      const uint idx =\n          atomicAdd(lineBuffer.cmd.instanceCount, 1);\n      if (idx >= lineBuffer.size) {\n        atomicMin(lineBuffer.cmd.instanceCount,\n                  lineBuffer.size);\n        return;\n      }\n      lineBuffer.lines[idx].v0 = v0;\n      lineBuffer.lines[idx].v1 = v1;\n      lineBuffer.lines[idx].c0 = c0;\n      lineBuffer.lines[idx].c1 = c1;\n    }\n    ```", "```cpp\n    #version 460\n    #extension GL_EXT_nonuniform_qualifier : require\n    struct Line {\n      vec3 v0;\n      vec4 c0;\n      vec3 v1;\n      vec4 c1;\n    };\n    struct VkDrawIndirectCommand {\n      uint vertexCount;\n      uint instanceCount;\n      uint firstVertex;\n      uint firstInstance;\n    };\n    layout(set = 1, binding = 0) readonly buffer\n    GPULinesBuffer {\n      Line lines[];\n    } lineBuffer;\n    layout (location = 0) out vec4 outColor;\n    void main() {\n      if (gl_VertexIndex == 0) {\n        vec3 vertex =\n            lineBuffer.lines[gl_InstanceIndex].v0;\n        gl_Position = vec4(vertex, 1.0).xyww;\n        outColor =\n            lineBuffer.lines[gl_InstanceIndex].c0;\n      } else {\n        vec3 vertex =\n            lineBuffer.lines[gl_InstanceIndex].v1;\n        gl_Position = vec4(vertex, 1.0).xyww;\n        outColor =\n            lineBuffer.lines[gl_InstanceIndex].c1;\n      }\n    }\n    ```", "```cpp\n    #version 460\n    layout(location = 0) in vec4 inColor;\n    layout(location = 0) out vec4 outColor;\n    void main() {\n      outColor = inColor;\n    }\n    ```", "```cpp\n    const VkBufferMemoryBarrier bufferBarrier = {\n        .sType =\n            VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,\n        .srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT,\n        .dstAccessMask =\n            VK_ACCESS_INDIRECT_COMMAND_READ_BIT,\n        .srcQueueFamilyIndex =\n            VK_QUEUE_FAMILY_IGNORED,\n        .dstQueueFamilyIndex =\n            VK_QUEUE_FAMILY_IGNORED,\n        .buffer = gpuLineBuffer->vkBuffer(),\n        .offset = 0,\n        .size = VK_WHOLE_SIZE,\n    };\n    vkCmdPipelineBarrier(\n        commandBuffer,\n        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,\n        VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT, 0, 0,\n        nullptr, 1, &bufferBarrier, 0, nullptr);\n    ```", "```cpp\n    vkCmdDrawIndirect(commandBuffer,\n                      gpuLineBuffer->vkBuffer(),\n                      sizeof(uint32_t) * 4, 1,\n                      sizeof(VkDrawIndirectCommand));\n    ```", "```cpp\n    const VkBufferMemoryBarrier bufferBarrierClear = {\n        .sType =\n            VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,\n        .srcAccessMask =\n            VK_ACCESS_INDIRECT_COMMAND_READ_BIT,\n        .dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT,\n        .srcQueueFamilyIndex =\n            VK_QUEUE_FAMILY_IGNORED,\n        .dstQueueFamilyIndex =\n            VK_QUEUE_FAMILY_IGNORED,\n        .buffer = gpuLineBuffer->vkBuffer(),\n        .offset = 0,\n        .size = VK_WHOLE_SIZE,\n    };\n    // Reset the number of lines in the buffer\n    vkCmdFillBuffer(commandBuffer,\n                    gpuLineBuffer->vkBuffer(),\n                    sizeof(uint32_t) * 5,\n                    sizeof(uint32_t), 0);\n    ```", "```cpp\n    layout(set = 4, binding = 0) buffer GPULinesBuffer\n    {\n      uint size;\n      uint row;\n      uint pad1;\n      uint pad2;\n      VkDrawIndirectCommand cmd;\n      Line lines[];\n    } lineBuffer;\n    ```", "```cpp\n    vec2 v[] = {vec2(-0.5f,  1.0f), vec2(0.5f,  1.f),\n                vec2(-0.5f,  0.0f), vec2(0.5f,  0.f),\n                vec2(-0.5f, -1.0f), vec2(0.5f, -1.f),\n               vec2( 0.0f, -0.8f), vec2(0.0f, -1.f) };\n    uvec2 i[] = {uvec2(0, 1), uvec2(2, 3), uvec2(4, 5), uvec2(0, 2), uvec2(1, 3), uvec2(2, 4), uvec2(3, 5), uvec2(6, 7)};\n    ```", "```cpp\n    void printSegment(int segment, vec2 pos, vec2 scale) {\n      uint idx = i[segment].x;\n      uint idy = i[segment].y;\n      vec3 v0 = vec3(v[idx] * scale + pos, 1.0);\n      vec3 v1 = vec3(v[idy] * scale + pos, 1.0);\n      addLine(v0, v1, vec4(0,0,0,1), vec4(0,0,0,1));\n    }\n    ```", "```cpp\n    void printDigit(int digit, uint linenum,\n                    uint column) {\n      const float charWidthPixel = 10;\n      const float charHeightPixels = 10;\n      const float horSpacePixels = 5;\n      const float verSpacePixels = 5;\n      const float charWidthNDC =\n          charWidthPixels / screenWidth;\n      const float charHeightNDC =\n          charHeightPixels / screenHeight;\n      const float horSpaceNDC =\n          horSpacePixels / screenWidth;\n      const float verSpaceNDC =\n          verSpacePixels / screenHeight;\n      const float colx =\n          (column + 1) *\n          (charWidthNDC + horSpaceNDC);\n      const float coly =\n          (linenum + 1) *\n          (charHeightNDC + 3 * verSpaceNDC);\n    ```", "```cpp\n      const vec2 pos(colx, coly);\n      const vec2 scale(charWidthNDC, -charHeightNDC);\n      switch (digit) {\n      case 0:\n        printSegment(0, pos, scale);\n        printSegment(3, pos, scale);\n        printSegment(4, pos, scale);\n        printSegment(5, pos, scale);\n        printSegment(6, pos, scale);\n        printSegment(2, pos, scale);\n        break;\n      case 1:\n        printSegment(4, pos, scale);\n        printSegment(6, pos, scale);\n        break;\n      case 10: // decimal separator\n        printSegment(7, pos, scale);\n        break;\n      case 11: // minus sign\n        printSegment(1, pos, scale);\n        break;\n      }\n    }\n    ```", "```cpp\n    uint printNumber(highp int value,\n                     uint linenum, uint column) {\n      if (value == 0) {\n        printDigit(0, linenum, column);\n        return column + 1;\n      }\n      int counter = 0;\n      int copy = value;\n      int tens = 1;\n      while (copy > 0) {\n        counter++;\n        copy = copy / 10;\n        tens *= 10;\n      }\n      tens /= 10;\n      for (int i = counter; i > 0; --i) {\n        int digit = int(value / tens);\n        printDigit(digit, linenum, column);\n        value = value - (digit * tens);\n        tens /= 10;\n        column++;\n      }\n      return column;\n    }\n    ```", "```cpp\n    void parse(float val, uint decimals) {\n      int d = int(log(val));\n      int base = int(pow(10, d));\n      const float tens = pow(10, decimals);\n      const uint line = atomicAdd(lineBuffer.row, 1);\n      uint column = 0;\n      // Minus sign\n      if (val < 0) {\n        printDigit(11, line, column);\n        column++;\n      }\n      // Prints only positive values\n      val = abs(val);\n      // Integer part\n      const int intPart = int(val);\n      column = printNumber(intPart, line, column);\n      // Decimal\n      if (decimals > 0) {\n        // Dot\n        printDigit(10, line, column);\n        column++;\n        const int decimal =\n            int(val * tens - intPart * tens);\n        printNumber(decimal, line, column);\n      }\n    }\n    ```", "```cpp\n    vkCmdFillBuffer(commandBuffer,\n                    gpuLineBuffer->vkBuffer(),\n                    sizeof(uint32_t),\n                    sizeof(uint32_t), 0);\n    ```", "```cpp\n    if (gl_VertexIndex == 0) {\n      parse(123456, 0);\n      parse(789, 0);\n      parse(780.12, 3);\n      parse(-23, 1);\n      parse(0.3, 2);\n    }\n    ```", "```cpp\n    FontManager fontManager;\n    const auto &glyphData = fontManager.loadFont(\n        (fontsFolder / \"times.ttf\").string());\n    std::vector<GlyphInfo> glyhInfoData;\n    std::vector<uint32_t> cellsData;\n    std::vector<glm::vec2> pointsData;\n    uint32_t pointOffset = 0;\n    uint32_t cellOffset = 0;\n    for (const auto &glyph : glyphData) {\n      glyhInfoData.push_back(\n          {glyph.bbox,\n           glm::uvec4(pointOffset, cellOffset,\n                      glyph.cellX,\n                      glyph.cellY)});\n      cellsData.insert(cellsData.end(),\n                       glyph.cellData.begin(),\n                       glyph.cellData.end());\n      pointsData.insert(pointsData.end(),\n                        glyph.points.begin(),\n                        glyph.points.end());\n      pointOffset += glyph.points.size();\n      cellOffset += glyph.cellData.size();\n    }\n    ```", "```cpp\n    std::string textToDisplay = \"GPUSDFTEXTDEMO\";\n    std::vector<CharInstance>\n        charsData(textToDisplay.length());\n    int startX =\n        context.swapchain()->extent().width / 6.0f;\n    int startY =\n        context.swapchain()->extent().height / 2.0f;\n    const float scale = 0.09f;\n    for (int i = 0; i < textToDisplay.length();\n         ++i) {\n      int glpyIndex = textToDisplay[i] - 'A';\n      charsData[i].glyphIndex = glpyIndex;\n      charsData[i].sharpness = scale;\n      charsData[i].bbox.x =\n          (startX +\n           glyphData[glpyIndex].bbox.x * scale) /\n              (context.swapchain()\n                   ->extent()\n                   .width /\n               2.0) -\n          1.0;\n      charsData[i].bbox.y =\n          (startY -\n           glyphData[glpyIndex].bbox.y * scale) /\n              (context.swapchain()\n                   ->extent()\n                   .height /\n               2.0) -\n          1.0;\n      charsData[i].bbox.z =\n          (startX +\n           glyphData[glpyIndex].bbox.z * scale) /\n              (context.swapchain()\n                   ->extent()\n                   .width /\n               2.0) -\n          1.0;\n      charsData[i].bbox.w =\n          (startY -\n           glyphData[glpyIndex].bbox.w * scale) /\n              (context.swapchain()\n                   ->extent()\n                   .height /\n               2.0) -\n          1.0;\n      startX += glyphData[glpyIndex]\n                    .horizontalAdvance *\n                scale;\n    }\n    \"GPUSDFTEXTDEMO\" onscreen. Here, textToDisplay holds the desired text, and charsData is primed to store individual character details. The starting position, calculated from the screen dimensions, suggests a slightly offset start from the left and a vertical centering of the text. A scaling factor shrinks the characters, likely aiding design or screen fit. As we progress character by character, a mapping correlates each letter to its respective data in glyphData. The bounding box coordinates for every character are meticulously scaled and normalized to ensure their optimal display on screen. To sidestep overlap, the horizontal placement (startX) gets an update for each character, relying on its width and the scaling factor. In sum, this snippet efficiently prepares the specifics for a neatly rendered, scaled, and centered display of \"GPUSDFTEXTDEMO\" on the screen.\n    ```", "```cpp\n    // 4 vertex (Quad) and x (charData) instances\n    vkCmdDraw(commandBuffer, 4, charsData.size(), 0, 0);\n    ```", "```cpp\n    #version 460\n    // Stores glyph information\n    struct GlyphInfo {\n      vec4 bbox; // Bounding box of the glyph\n      // cell_info.x: point offset\n      // cell_info.x: cell offset\n      // cell_info.x: cell count in x\n      // cell_info.x: cell count in y\n      uvec4 cell_info;\n    };\n    // Storage buffer object for glyphs\n    layout(set = 0, binding = 0) buffer GlyphBuffer {\n      GlyphInfo glyphs[];\n    } glyph_buffer;\n    layout(location = 0) in vec4 in_rect;\n    layout(location = 1) in uint in_glyph_index;\n    layout(location = 2) in float in_sharpness;\n    layout(location = 0) out vec2 out_glyph_pos;\n    layout(location = 1) out uvec4 out_cell_info;\n    layout(location = 2) out float out_sharpness;\n    layout(location = 3) out vec2 out_cell_coord;\n    void main() {\n      // Get the glyph information\n      GlyphInfo gi = glyph_buffer.glyphs[in_glyph_index];\n      // Corners of the rectangle\n      vec2 pos[4] = vec2[](\n          vec2(in_rect.x, in_rect.y), // Bottom-left\n          vec2(in_rect.z, in_rect.y), // Bottom-right\n          vec2(in_rect.x, in_rect.w), // Top-left\n          vec2(in_rect.z, in_rect.w) // Top-right\n      );\n      // Corners of the glyph\n      vec2 glyph_pos[4] = vec2[](\n          vec2(gi.bbox.x, gi.bbox.y), // Bottom-left\n          vec2(gi.bbox.z, gi.bbox.y), // Bottom-right\n          vec2(gi.bbox.x, gi.bbox.w), // Top-left\n          vec2(gi.bbox.z, gi.bbox.w) // Top-right\n      );\n      // Cell coordinates\n      vec2 cell_coord[4] = vec2[](\n          vec2(0, 0), // Bottom-left\n          vec2(gi.cell_info.z, 0), // Bottom-right\n          vec2(0, gi.cell_info.w), // Top-left\n          vec2(gi.cell_info.z,\n               gi.cell_info.w) // Top-right\n      );\n      gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\n      out_glyph_pos = glyph_pos[gl_VertexIndex];\n      out_cell_info = gi.cell_info;\n      out_sharpness = in_sharpness;\n      out_cell_coord = cell_coord[gl_VertexIndex];\n    }\n    ```", "```cpp\n        // Main function of the fragment shader\n        void main() {\n          // Calculate the cell index\n          uvec2 c = min(uvec2(in_cell_coord),\n                        in_cell_info.zw - 1);\n          uint cell_index = in_cell_info.y +\n                            in_cell_info.z * c.y + c.x;\n          // Get the cell\n          uint cell = cell_buffer.cells[cell_index];\n          // Calculate the signed distance from the\n          // glyph position to the cell\n          float v = cell_signed_dist(\n              in_cell_info.x, cell, in_glyph_pos);\n          // Calculate the alpha value\n          float alpha = clamp(v * in_sharpness + 0.5,\n                              0.0, 1.0);\n          out_color = vec4(1.0, 1.0, 1.0, alpha);\n        }\n        ```", "```cpp\n    cullingPass.init(&context, &camera,\n                     *bistro.get(), buffers[3]);\n    cullingPass.upload(commandMgr);\n    ```", "```cpp\n    auto commandBuffer = commandMgr.getCmdBufferToBegin();\n    cullingPass.cull(commandBuffer, index);\n    ```", "```cpp\n    cullingPass.addBarrierForCulledBuffers(\n        commandBuffer,\n        VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,\n        context.physicalDevice()\n            .graphicsFamilyIndex()\n            .value(),\n        context.physicalDevice()\n            .graphicsFamilyIndex()\n            .value());\n    ```", "```cpp\n    vkCmdDrawIndexedIndirectCount(\n        commandBuffer,\n        cullingPass.culledIndirectDrawBuffer()\n            ->vkBuffer(),\n        0,\n        cullingPass\n            .culledIndirectDrawCountBuffer()\n            ->vkBuffer(),\n        0, numMeshes,\n        sizeof(\n            EngineCore::\n                IndirectDrawCommandAndMeshData));\n    ```", "```cpp\nvoid CullingComputePass::cull(\n    VkCommandBuffer cmd, int frameIndex) {\n  GPUCullingPassPushConstants pushConst{\n      .drawCount =\n          uint32_t(meshesBBoxData_.size()),\n  };\n  // Compute and store the six planes of the frustum\n  for (int i = 0;\n       auto &plane :\n       camera_->calculateFrustumPlanes()) {\n    frustum_.frustumPlanes[i] = plane;\n    ++i;\n  }\n  // Upload the data to the device\n  camFrustumBuffer_->buffer()\n      ->copyDataToBuffer(&frustum_,\n                         sizeof(ViewBuffer));\n  // Bind the compute pipeline, update push constants\n  pipeline_->bind(cmd);\n  pipeline_->updatePushConstant(\n      cmd, VK_SHADER_STAGE_COMPUTE_BIT,\n      sizeof(GPUCullingPassPushConstants),\n      &pushConst);\n  // Bind descriptor sets\n  pipeline_->bindDescriptorSets(\n      cmd,\n      {\n          {.set = MESH_BBOX_SET,\n           .bindIdx = 0},\n          {.set = INPUT_INDIRECT_BUFFER_SET,\n           .bindIdx = 0},\n          {.set = OUTPUT_INDIRECT_BUFFER_SET,\n           .bindIdx = 0},\n          {.set =\n               OUTPUT_INDIRECT_COUNT_BUFFER_SET,\n           .bindIdx = 0},\n          {.set = CAMERA_FRUSTUM_SET,\n           .bindIdx = uint32_t(frameIndex)},\n      });\n  // Update descriptor sets\n  pipeline_->updateDescriptorSets();\n  // Dispatch the compute pass\n  vkCmdDispatch(\n      cmd, (pushConst.drawCount / 256) + 1, 1, 1);\n}\n```", "```cpp\nvoid CullingComputePass::\n    addBarrierForCulledBuffers(\n        VkCommandBuffer cmd,\n        VkPipelineStageFlags dstStage,\n        uint32_t computeFamilyIndex,\n        uint32_t graphicsFamilyIndex) {\n  std::array<VkBufferMemoryBarrier, 2> barriers{\n      VkBufferMemoryBarrier{\n          .sType =\n              VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,\n          .srcAccessMask =\n              VK_ACCESS_SHADER_WRITE_BIT,\n          .dstAccessMask =\n              VK_ACCESS_INDIRECT_COMMAND_READ_BIT,\n          .srcQueueFamilyIndex =\n              computeFamilyIndex,\n          .dstQueueFamilyIndex =\n              graphicsFamilyIndex,\n          .buffer = outputIndirectDrawBuffer_\n                        ->vkBuffer(),\n          .size = outputIndirectDrawBuffer_\n                      ->size(),\n      },\n      VkBufferMemoryBarrier{\n          .sType =\n              VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,\n          .srcAccessMask =\n              VK_ACCESS_SHADER_WRITE_BIT,\n          .dstAccessMask =\n              VK_ACCESS_INDIRECT_COMMAND_READ_BIT,\n          .srcQueueFamilyIndex =\n              computeFamilyIndex,\n          .dstQueueFamilyIndex =\n              graphicsFamilyIndex,\n          .buffer =\n              outputIndirectDrawCountBuffer_\n                  ->vkBuffer(),\n          .size =\n              outputIndirectDrawCountBuffer_\n                  ->size(),\n      },\n  };\n  vkCmdPipelineBarrier(\n      cmd,\n      VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,\n      dstStage, 0, 0, nullptr,\n      (uint32_t)barriers.size(),\n      barriers.data(), 0, nullptr);\n}\n```", "```cpp\nvoid cullMesh(uint id) {\n  MeshBboxData meshBBoxData = meshBboxDatas[id];\n  bool isVisible = true;\n  for (int i = 0; i < 6 && isVisible; i++) {\n    vec3 planeNormal =\n        viewData.frustumPlanes[i].xyz;\n    float distFromPlane = dot(\n        meshBBoxData.centerPos.xyz, planeNormal);\n    float absDiff = dot(abs(planeNormal),\n                        meshBBoxData.extents.xyz);\n    if (distFromPlane + absDiff +\n            viewData.frustumPlanes[i].w < 0.0) {\n      isVisible = false;\n    }\n  }\n  if (isVisible) {\n    uint index = atomicAdd(outDrawCount.count, 1);\n    outputIndirectDraws[index] = inputIndirectDraws[id];\n  }\n}\n```", "```cpp\nlayout(local_size_x = 256, local_size_y = 1,\n       local_size_z = 1) in;\nvoid main() {\n  uint currentThreadId = gl_GlobalInvocationID.x;\n  if (currentThreadId == 0) {\n    atomicExchange(outDrawCount.count, 0);\n  }\n  barrier();\n  if (currentThreadId < cullData.count) {\n    cullMesh(currentThreadId);\n  }\n}\n```"]