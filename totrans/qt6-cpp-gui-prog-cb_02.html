<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-40"><a id="_idTextAnchor040"/>2</h1>
<h1 id="_idParaDest-41"><a id="_idTextAnchor041"/>Event Handling – Signals and Slots</h1>
<p>The signals and slots mechanism in Qt 6 is one of its most important features. It’s a method that allows communication between objects, which is a crucial part of a program’s graphical user interface. A signal can be emitted from any <code>QObject</code> object or its subclasses, which will then trigger any slot functions of any objects that are connected to the signal.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Signals and slots in a nutshell</li>
<li>UI events with signals and slots</li>
<li>Asynchronous programming made easier</li>
<li>Function callbacks</li>
</ul>
<h1 id="_idParaDest-42"><a id="_idTextAnchor042"/>Technical requirements</h1>
<p>The technical requirements for this chapter include <strong class="bold">Qt 6.6.1 MinGW 64-bit</strong> and <strong class="bold">Qt Creator 12.0.2</strong>. All the code used in this chapter can be downloaded from the following GitHub repository: <a href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter02">https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter02</a>.</p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor043"/>Signals and slots in a nutshell</h1>
<p>Compared to <strong class="bold">callbacks</strong> (which Qt 6 also supports), the <strong class="bold">signals and slots</strong> mechanism is comparably more fluid and flexible for the <a id="_idIndexMarker118"/>programmer to use. It is both type-safe and not strongly coupled to the processing function, which makes it better than callback implementation.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/>How to do it…</h2>
<p>Let’s get started by following these steps:</p>
<ol>
<li>Let’s create a <code>mainwindow.ui</code>.</li>
<li>Drag and drop a <strong class="bold">PushButton</strong> widget from the <strong class="bold">Widget Box</strong> to the UI canvas:</li>
</ol>
<div><div><img alt="Figure 2.1 – Dragging and dropping a push button to the UI canvas" src="img/B20976_02_001.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Dragging and dropping a push button to the UI canvas</p>
<ol>
<li value="3">Right-click on the <strong class="bold">PushButton</strong> widget <a id="_idIndexMarker119"/>and select <strong class="bold">Go to slot</strong>. A window will appear:</li>
</ol>
<div><div><img alt="Figure 2.2 – Selecting the clicked() signal and pressing OK" src="img/B20976_02_002.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Selecting the clicked() signal and pressing OK</p>
<ol>
<li value="4">You will see a list of built-in slot functions available for the push button. Let’s select the <code>on_pushButton_clicked()</code> will now appear in both <code>mainwindow.h</code> and <code>mainwindow.cpp</code>. Qt Creator <a id="_idIndexMarker120"/>automatically added the slot function to your source code after you pressed the <code>mainwindow.h</code> now, you should be able to see an extra function under the <code>private </code><code>slots</code> keyword:<pre class="source-code">
class MainWindow : public QMainWindow {
    Q_OBJECT
public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();
private slots:
    <strong class="bold">void on_pushButton_clicked();</strong>
private:
    Ui::MainWindow *ui;
};</pre></li> <li>The same goes for <code>mainwindow.cpp</code>, where the <code>on_pushButton_clicked()</code> function has been added for you:<pre class="source-code">
void MainWindow::on_pushButton_clicked()
{
}</pre></li> <li>Now, let’s add a <code>QMessageBox</code> header to<a id="_idIndexMarker121"/> the top of your source file:<pre class="source-code">
#include &lt;QMessageBox&gt;</pre></li> <li>Then, add the following code within the <code>on_pushButton_clicked()</code> function:<pre class="source-code">
void MainWindow::on_pushButton_clicked() {
    <strong class="bold">QMessageBox::information(this, «Hello», «Button has been clicked!»);</strong>
}</pre></li> <li>Now, build and run the project. Then, click on the <strong class="bold">Push</strong> button; you should see that a message box pops out:</li>
</ol>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 2.3 – A message box pops out after pressing the push button" src="img/B20976_02_003.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – A message box pops out after pressing the push button</p>
<ol>
<li value="9">Next, we want to create our own <a id="_idIndexMarker122"/>signals and slot functions. Go to <strong class="bold">File</strong> | <strong class="bold">New File or Project</strong>, then create a new C++ class under the <strong class="bold">Files and </strong><strong class="bold">Classes</strong> category:</li>
</ol>
<div><div><img alt="Figure 2.4 – Creating a new C++ class" src="img/B20976_02_004.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Creating a new C++ class</p>
<ol>
<li value="10">Then, we need to name our class <code>MyClass</code> and make sure that the base class is <strong class="bold">QObject</strong>:</li>
</ol>
<div><div><img alt="Figure 2.5 – Defining your custom class, which inherits the QObject class" src="img/B20976_02_005.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Defining your custom class, which inherits the QObject class</p>
<ol>
<li value="11">Once you have created the<a id="_idIndexMarker123"/> class, open up <code>myclass.h</code> and add the following code, which is highlighted here for clarity:<pre class="source-code">
#include &lt;QObject&gt;
<strong class="bold">#include &lt;QMainWindow&gt;</strong>
<strong class="bold">#include &lt;QMessageBox&gt;</strong>
class MyClass : public QObject {
    Q_OBJECT
public:
    explicit MyClass(QObject *parent = nullptr);
public slots:
    <strong class="bold">void doSomething();</strong>
};</pre></li> <li>Then, open up <code>myclass.cpp</code> and implement the <code>doSomething()</code> slot function. We’ll copy the message box<a id="_idIndexMarker124"/> function from the previous example:<pre class="source-code">
#include "myclass.h"
MyClass::MyClass(QObject *parent) : QObject(parent) {}
void MyClass::doSomething() {
    <strong class="bold">QMessageBox::information(this, «Hello», «Button has been clicked!»);</strong>
}</pre></li> <li>Now, open up <code>mainwindow.h</code> and include the <code>myclass.h</code> header at the top:<pre class="source-code">
#ifndef MAINWINDOW_H
#define MAINWINDOW_H
<strong class="bold">#include "myclass.h"</strong>
namespace Ui {
class MainWindow;
}</pre></li> <li>Also, declare a <code>doNow()</code> signal in <code>myclass.h</code>:<pre class="source-code">
signals:
    <strong class="bold">void doNow();</strong>
private slots:
    void on_pushButton_clicked();</pre></li> <li>After that, open up <code>mainwindow.cpp</code> and define a <code>MyClass</code> object. Then, we’ll connect the <code>doNow()</code> signal that we created in the previous step with our <code>doSomething()</code> slot function:<pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
ui(new Ui::MainWindow){
    ui-&gt;setupUi(this);
    <strong class="bold">MyClass* myclass = new MyClass;</strong>
<strong class="bold">    connect(this, &amp;MainWindow::doNow, myclass, &amp;MyClass::doSomething);</strong>
}</pre></li> <li>Then, we have to change<a id="_idIndexMarker125"/> the code of the <code>on_pushButton_clicked()</code> function to something like this:<pre class="source-code">
void MainWindow::on_pushButton_clicked() {
    <strong class="bold">emit doNow();</strong>
}</pre></li> <li>If you build and run the program now, you will get a result that is similar to what’s shown in the previous example. However, we have placed the message box code in the <code>MyClass</code> object instead of in <code>MainWindow</code>.</li>
</ol>
<p>The preceding steps demonstrated how we can utilize the slot-and-signal feature in Qt 6 to easily link a widget action to an event function. It really is that simple.</p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/>How it works…</h2>
<p>The signals and slots mechanism has <a id="_idIndexMarker126"/>gone through some changes in the recent version of Qt, most notably its coding syntax. Qt 6 no longer supports the older syntax; therefore, if you are trying to port your older Qt 5 project to Qt 6, you must change your code to comply with the newer syntax.</p>
<p>In the good old days, we would typically connect a signal to a slot like this:</p>
<pre class="source-code">
connect(
    sender, SIGNAL(valueChanged(QString)),
    receiver, SLOT(updateValue(QString))
);</pre> <p>However, things have changed slightly since then. In the new syntax, the <code>SIGNAL</code> and <code>SLOT</code> macros are now gone, and you <a id="_idIndexMarker127"/>must specify the type of your object, as shown in the following code:</p>
<pre class="source-code">
connect(
    sender, &amp;Sender::valueChanged,
    receiver, &amp;Receiver::updateValue
);</pre> <p>The new syntax also allows you to connect a signal directly to a function instead of <code>QObject</code>:</p>
<pre class="source-code">
connect(
    sender, &amp;Sender::valueChanged, myFunction
);</pre> <p>Additionally, you can also connect<a id="_idIndexMarker128"/> your signal to a <strong class="bold">lambda expression</strong>. We will talk more about this in the <em class="italic">Asynchronous programming made </em><em class="italic">easier</em> recipe.</p>
<p class="callout-heading">Note</p>
<p class="callout">A signal of an <code>arbitrary</code> class can trigger any private slots of an unrelated class that is going to be invoked, which is not possible with callbacks.</p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/>There’s more…</h2>
<p>All Qt projects come with a project file with the <code>.pro</code> extension. This project file is used specifically by Qt’s own <strong class="bold">qmake</strong> build system, which<a id="_idIndexMarker129"/> helps simplify most of the complex build process by using a straightforward declarative style, defining standard variables to indicate the source and header files that are used in the project.</p>
<p>There’s an alternative <a id="_idIndexMarker130"/>build system called <code>CMakeLists.txt</code> with Qt Creator and it will open the project just like using Qt’s project file. However, it’s not recommended<a id="_idIndexMarker131"/> for beginners to use CMake when developing their first application with Qt, as CMake is much more manual and it takes longer time to grasp its functionality.</p>
<p class="callout-heading">Note</p>
<p class="callout">To learn more about CMake, please visit <a href="https://doc.qt.io/qt-6/cmake-get-started.html">https://doc.qt.io/qt-6/cmake-get-started.html</a>.</p>
<p>Qt categorizes its features and functionality in the form of modules and classes. Each module contains a set of related functionalities that can be added to your project separately when needed. This allows the programmer to keep their program in optimum size and performance. The Qt Core and Qt GUI modules are included in every Qt project by default. To add additional modules, you simply need to add the module keyword to your Qt project file or add the package and link its libraries in <code>CMakeLists.txt</code> if you are using CMake for your project.</p>
<p>For example, if I want to add the Qt <code>Network</code> module to my project, I will add the following keyword to my Qt project file:</p>
<pre class="console">
QT += network</pre> <p>In CMake, however, it gets slightly longer:</p>
<pre class="console">
find_package(Qt6 REQUIRED COMPONENTS Network)
target_link_libraries(mytarget PRIVATE Qt6::Network)</pre> <p>After you have added the Qt <code>Network</code> module, you can now access its C++ classes such as <code>QNetworkAccessManager</code>, <code>QNetworkInterface</code>, <code>QNetworkRequest</code>, and so on. This modular approach creates an expandable ecosystem for Qt while allowing the developers to maintain this complex and powerful framework with ease.</p>
<p class="callout-heading">Note</p>
<p class="callout">To learn more about all the different Qt modules, please visit <a href="https://doc.qt.io/qt.html">https://doc.qt.io/qt.html</a>.</p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor047"/>UI events with signals and slots</h1>
<p>In the previous recipe, we <a id="_idIndexMarker132"/>demonstrated the use of signals and slots on a <a id="_idIndexMarker133"/>push button. Now, let’s explore the signals and slots that are available in other common widget types.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor048"/>How to do it…</h2>
<p>To learn how to use signals and slots with UI events, follow these steps:</p>
<ol>
<li>Let’s create a new <strong class="bold">Qt Widgets </strong><strong class="bold">Application</strong> project.</li>
<li>Drag and drop a <strong class="bold">PushButton</strong>, <strong class="bold">Combo Box</strong>, <strong class="bold">Line Edit</strong>, <strong class="bold">Spin Box</strong>, and <strong class="bold">Slider</strong> widget from the <strong class="bold">Widget Box</strong> into your UI canvas:</li>
</ol>
<div><div><img alt="Figure 2.6 – Placing several widgets on the UI canvas" src="img/B20976_02_006.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Placing several widgets on the UI canvas</p>
<ol>
<li value="3">Then, right-click on the push button, select <strong class="bold">clicked()</strong>, and press the <strong class="bold">OK</strong> button to proceed. A slot function will be created for you by Qt Creator:</li>
</ol>
<div><div><img alt="Figure 2.7 – Selecting the clicked() signal and pressing OK" src="img/B20976_02_007.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Selecting the clicked() signal and pressing OK</p>
<ol>
<li value="4">Repeat the previous step, but<a id="_idIndexMarker134"/> this time, select the next selection until every<a id="_idIndexMarker135"/> function in <code>QAbstractButton</code> has been added to the source code:<pre class="source-code">
void on_pushButton_clicked();
void on_pushButton_clicked(bool checked);
void on_pushButton_pressed();
void on_pushButton_released();
void on_pushButton_toggled(bool checked);</pre></li> <li>Next, repeat the same steps on the combo box until all the slot functions available under the <code>QComboBox</code> class have been added to the source code:<pre class="source-code">
void on_comboBox_activated(const QString &amp;arg1);
void on_comboBox_activated(int index);
void on_comboBox_currentIndexChanged(const QString &amp;arg1);
void on_comboBox_currentIndexChanged(int index);
void on_comboBox_currentTextChanged(const QString &amp;arg1);
void on_comboBox_editTextChanged(const QString &amp;arg1);
void on_comboBox_highlighted(const QString &amp;arg1);
void on_comboBox_highlighted(int index);</pre></li> <li>The same goes for <code>lineEdit</code>, all <a id="_idIndexMarker136"/>of which are<a id="_idIndexMarker137"/> under the <code>QLineEdit</code> class:<pre class="source-code">
void on_lineEdit_cursorPositionChanged(int arg1, int arg2);
void on_lineEdit_editingFinished();
void on_lineEdit_returnPressed();
void on_lineEdit_selectionChanged();
void on_lineEdit_textChanged(const QString &amp;arg1);
void on_lineEdit_textEdited(const QString &amp;arg1);</pre></li> <li>After that, add the slot functions<a id="_idIndexMarker138"/> from the <code>QSpinBox</code> class for our <code>spin box</code> widget as well, which is<a id="_idIndexMarker139"/> relatively short:<pre class="source-code">
void on_spinBox_valueChanged(const QString &amp;arg1);
void on_spinBox_valueChanged(int arg1);</pre></li> <li>Lastly, repeat the same step for our <code>slider</code> widget, which yields similar results:<pre class="source-code">
void on_horizontalSlider_actionTriggered(int action);
void on_horizontalSlider_rangeChanged(int min, int max);
void on_horizontalSlider_sliderMoved(int position);
void on_horizontalSlider_sliderPressed();
void on_horizontalSlider_sliderReleased();
void on_horizontalSlider_valueChanged(int value);</pre></li> <li>Once you’re done with<a id="_idIndexMarker140"/> that, open up <code>mainwindow.h</code> and <a id="_idIndexMarker141"/>add the <code>QDebug</code> header, as highlighted in the following code:<pre class="source-code">
#ifndef MAINWINDOW_H
#define MAINWINDOW_H
#include &lt;QMainWindow&gt;
<strong class="bold">#include &lt;QDebug&gt;</strong>
namespace Ui {
class MainWindow;
}</pre></li> <li>Let’s implement the slot functions for our push button:<pre class="source-code">
void MainWindow::on_pushButton_clicked() {
    <strong class="bold">qDebug() &lt;&lt; «Push button clicked»;</strong>
}
void MainWindow::on_pushButton_clicked(bool checked) {
    <strong class="bold">qDebug() &lt;&lt; «Push button clicked: « &lt;&lt; checked;</strong>
}
void MainWindow::on_pushButton_pressed() {
    <strong class="bold">qDebug() &lt;&lt; «Push button pressed»;</strong>
}
void MainWindow::on_pushButton_released() {
    <strong class="bold">qDebug() &lt;&lt; «Push button released»;</strong>
}
void MainWindow::on_pushButton_toggled(bool checked) {
    <strong class="bold">qDebug() &lt;&lt; «Push button toggled: « &lt;&lt; checked;</strong>
}</pre></li> <li>If you build and run the project<a id="_idIndexMarker142"/> now, and then click on the push button, you will see that a different status gets<a id="_idIndexMarker143"/> printed out but at a slightly different time. This is due to different signals being emitted at different actions during the whole clicking process:</li>
</ol>
<pre class="console">
Push button pressed
Push button released
Push button clicked
Push button clicked: false</pre> <ol>
<li value="12">Next, we will move on to the combo box. Since the default combo box is empty, let’s add some options to it by double-clicking on it from <code>mainwindow.ui</code> and adding the options that are shown in the pop-up window:</li>
</ol>
<div><div><img alt="Figure 2.8 – Adding more options to the combo box" src="img/B20976_02_008.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Adding more options to the combo box</p>
<ol>
<li value="13">Then, let’s implement the slot <a id="_idIndexMarker144"/>functions for the combo box in <code>mainwindow.cpp</code>:<pre class="source-code">
void MainWindow::on_comboBox_activated(const QString &amp;arg1) {
    <strong class="bold">qDebug() &lt;&lt; «Combo box activated: « &lt;&lt; arg1;</strong>
}
void MainWindow::on_comboBox_activated(int index) {
    <strong class="bold">qDebug() &lt;&lt; «Combo box activated: « &lt;&lt; index;</strong>
}
void MainWindow::on_comboBox_currentIndexChanged(const QString &amp;arg1) {
    <strong class="bold">qDebug() &lt;&lt; «Combo box current index changed: « &lt;&lt; arg1;</strong>
}
void MainWindow::on_comboBox_currentIndexChanged(int index) {
    <strong class="bold">qDebug() &lt;&lt; «Combo box current index changed: « &lt;&lt; index;</strong>
}</pre></li> <li>We will continue to<a id="_idIndexMarker145"/> implement the rest of the slot functions for the combo box:<pre class="source-code">
void MainWindow::on_comboBox_currentTextChanged(const QString &amp;arg1) {
    <strong class="bold">qDebug() &lt;&lt; «Combo box current text changed: « &lt;&lt; arg1;</strong>
}
void MainWindow::on_comboBox_editTextChanged(const QString
&amp;arg1) {
    <strong class="bold">qDebug() &lt;&lt; «Combo box edit text changed: « &lt;&lt; arg1;</strong>
}
void MainWindow::on_comboBox_highlighted(const QString &amp;arg1) {
    <strong class="bold">qDebug() &lt;&lt; «Combo box highlighted: « &lt;&lt; arg1;</strong>
}
void MainWindow::on_comboBox_highlighted(int index) {
    <strong class="bold">qDebug() &lt;&lt; «Combo box highlighted: « &lt;&lt; index;</strong>
}</pre></li> <li>Build and run the project. Then, try <a id="_idIndexMarker146"/>to click on the<a id="_idIndexMarker147"/> combo box, hover over the other options, and select an option by clicking on it. You should see similar results to the following in your debug output:<pre class="source-code">
Combo box highlighted: 0
Combo box highlighted: "Option One"
Combo box highlighted: 1
Combo box highlighted: "Option Two"
Combo box highlighted: 2
Combo box highlighted: "Option Three"
Combo box current index changed: 2
Combo box current index changed: "Option Three"
Combo box current text changed: "Option Three"
Combo box activated: 2
Combo box activated: "Option Three"</pre></li> <li>Next, we will move on to<a id="_idIndexMarker148"/> line edit and implement its slot functions, as shown in the following code:<pre class="source-code">
void MainWindow::on_lineEdit_cursorPositionChanged(int arg1, int arg2) {
    <strong class="bold">qDebug() &lt;&lt; «Line edit cursor position changed: « &lt;&lt; arg1 &lt;&lt; arg2;</strong>
}
void MainWindow::on_lineEdit_editingFinished() {
    <strong class="bold">qDebug() &lt;&lt; «Line edit editing finished»;</strong>
}
void MainWindow::on_lineEdit_returnPressed() {
    <strong class="bold">qDebug() &lt;&lt; «Line edit return pressed»;</strong>
}</pre></li> <li>We will continue to <a id="_idIndexMarker149"/>implement the rest of the slot functions of line edit:<pre class="source-code">
void MainWindow::on_lineEdit_selectionChanged() {
    <strong class="bold">qDebug() &lt;&lt; «Line edit selection changed»;</strong>
}
void MainWindow::on_lineEdit_textChanged(const QString &amp;arg1) {
    <strong class="bold">qDebug() &lt;&lt; «Line edit text changed: « &lt;&lt; arg1;</strong>
}
void MainWindow::on_lineEdit_textEdited(const QString &amp;arg1) {
    <strong class="bold">qDebug() &lt;&lt; «Line edit text edited: « &lt;&lt; arg1;</strong>
}</pre></li> <li>Build and run the project. Then, click on the line edit and type <code>Hey</code>. You should see results similar to the<a id="_idIndexMarker150"/> following appearing in the debug output panel:<pre class="source-code">
Line edit cursor position changed: -1 0
Line edit text edited: "H"
Line edit text changed: "H"
Line edit cursor position changed: 0 1
Line edit text edited: "He"
Line edit text changed: "He"
Line edit cursor position changed: 1 2
Line edit text edited: "Hey"
Line edit text changed: "Hey"
Line edit cursor position changed: 2 3
Line edit editing finished</pre></li> <li>After that, we need to implement the slot functions for the spin box widget, as shown in the following<a id="_idIndexMarker151"/> code:<pre class="source-code">
void MainWindow::on_spinBox_valueChanged(const QString &amp;arg1){
    <strong class="bold">qDebug() &lt;&lt; «Spin box value changed: « &lt;&lt; arg1;</strong>
}
void MainWindow::on_spinBox_valueChanged(int arg1) {
    <strong class="bold">qDebug() &lt;&lt; «Spin box value changed: « &lt;&lt; arg1;</strong>
}</pre></li> <li>Try to build and run the program. Then, click the arrow buttons on the spin box, or directly edit the value in the box – you should get something similar to this:<pre class="source-code">
Spin box value changed: "1"
Spin box value changed: 1
Spin box value changed: "2"
Spin box value changed: 2
Spin box value changed: "3"
Spin box value changed: 3
Spin box value changed: "2"
Spin box value changed: 2
Spin box value changed: "20"
Spin box value changed: 20</pre></li> <li>Lastly, we’ll implement the<a id="_idIndexMarker152"/> slot functions for the horizontal <a id="_idIndexMarker153"/>slider widget:<pre class="source-code">
void MainWindow::on_horizontalSlider_actionTriggered(int
action) {
    <strong class="bold">qDebug() &lt;&lt; «Slider action triggered» &lt;&lt; action;</strong>
}
void MainWindow::on_horizontalSlider_rangeChanged(int min, int max) {
    <strong class="bold">qDebug() &lt;&lt; «Slider range changed: « &lt;&lt; min &lt;&lt; max;</strong>
}
void MainWindow::on_horizontalSlider_sliderMoved(int position)
{
    <strong class="bold">qDebug() &lt;&lt; «Slider moved: « &lt;&lt; position;</strong>
}</pre></li> <li>Continue to implement the slot function for the slider, as shown in the following code:<pre class="source-code">
void MainWindow::on_horizontalSlider_sliderPressed() {
    <strong class="bold">qDebug() &lt;&lt; «Slider pressed»;</strong>
}
void MainWindow::on_horizontalSlider_sliderReleased() {
    <strong class="bold">qDebug() &lt;&lt; «Slider released»;</strong>
}
void MainWindow::on_horizontalSlider_valueChanged(int value) {
    <strong class="bold">qDebug() &lt;&lt; «Slider value changed: « &lt;&lt; value;</strong>
}</pre></li> <li>Build and run the <a id="_idIndexMarker154"/>program. Then, click and drag the slider <a id="_idIndexMarker155"/>to the left and right – you should see results that are similar to the following:<pre class="source-code">
Slider pressed
Slider moved: 1
Slider action triggered 7
Slider value changed: 1
Slider moved: 2
Slider action triggered 7
Slider value changed: 2
Slider moved: 3
Slider action triggered 7
Slider value changed: 3
Slider moved: 4
Slider action triggered 7
Slider value changed: 4
Slider released</pre></li> </ol>
<p>Almost every widget has a set of slot functions associated with its usage or purpose. For example, a push button will start <a id="_idIndexMarker156"/>emitting signals that trigger the slot functions associated with it when it’s <a id="_idIndexMarker157"/>pressed or released. These expected behaviors that define the widget have slot functions that get called when the user triggers an action. As programmers, all we need to do is implement the slot functions and tell Qt what to do when these slot functions are being triggered.</p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor049"/>Asynchronous programming made easier</h1>
<p>Since the signals and slots mechanism is <em class="italic">asynchronous</em> in nature, we can make use of it for things other than user interfaces. In programming terms, an <em class="italic">asynchronous operation</em> is a process that works independently, allowing the program to continue its operation without waiting for the <a id="_idIndexMarker158"/>process to complete, which may stall the whole program. Qt 6 allows you to make use of its signals and slots mechanism to easily achieve asynchronous processes without much effort. This is even more true after Qt 6 enforced the new syntax for signals and slots, which allows a signal to trigger a normal function instead of a slot function from a <code>Qobject</code> object.</p>
<p>In the following example, we will further explore this opportunity and learn how we can improve our program’s efficiency by using asynchronous operations through the signals and slots mechanism that’s provided by Qt 6.</p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>How to do it…</h2>
<p>To learn how to achieve asynchronous operations using the signals and slots mechanism, let’s follow this example:</p>
<ol>
<li>Create a <strong class="bold">Qt Console </strong><strong class="bold">Application</strong> project:</li>
</ol>
<div><div><img alt="Figure 2.9 – Creating a new Qt Console Application project" src="img/B20976_02_009.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Creating a new Qt Console Application project</p>
<ol>
<li value="2">This type of project will only <a id="_idIndexMarker159"/>provide a <code>main.cpp</code> file for you, instead of <code>mainwindow.h</code> and <code>mainwindow.cpp</code>, like our previous example projects. Let’s open up <code>main.cpp</code> and add the following headers to it:<pre class="source-code">
#include &lt;QNetworkAccessManager&gt;
#include &lt;QNetworkReply&gt;
#include &lt;QDebug&gt;</pre></li> <li>Then, add the following code to our <code>main()</code> function. We will be using the <code>QNetworkAccessManager</code> class to initiate a <code>GET</code> request to the following web URL:<pre class="source-code">
int main(int argc, char *argv[]) {
    QCoreApplication a(argc, argv);
    QString *html = new QString;
    qDebug() &lt;&lt; "Start";
    QNetworkAccessManager manager;
    QNetworkRequest req(QUrl("http://www.dustyfeet.com"));
    QNetworkReply* reply = manager.get(req);</pre></li> <li>Then, we use C++11’s <code>QNetworkReply</code> signals<a id="_idIndexMarker160"/> to inline <a id="_idIndexMarker161"/>functions:<pre class="source-code">
QObject::connect(reply, &amp;QNetworkReply::readyRead,
 [reply, html]() {
         html-&gt;append(QString(reply-&gt;readAll()));
     });
     QObject::connect(reply, &amp;QNetworkReply::downloadProgress, [reply](qint64 bytesReceived, qint64 bytesTotal) {
         qDebug() &lt;&lt; "Progress: " &lt;&lt; bytesReceived &lt;&lt; "bytes /" &lt;&lt; bytesTotal &lt;&lt; "bytes";
     });</pre></li> <li>We can also use a lambda expression with <code>connect()</code> to call a function that is not under a <code>QObject</code> class:<pre class="source-code">
QObject::connect(reply, &amp;QNetworkReply::finished, [=]() {
        printHTML(*html);
    });
    return a.exec();
}</pre></li> <li>Lastly, we define the <code>printHTML()</code> function, as shown in the following code:<pre class="source-code">
void printHTML(QString html) {
    qDebug() &lt;&lt; "Done";
    qDebug() &lt;&lt; html;
}</pre></li> <li>If you build and run the program now, you will see that it’s functional even without declaring any<a id="_idIndexMarker162"/> slot function. <strong class="bold">Lambda expressions</strong> make declaring a slot function optional, but<a id="_idIndexMarker163"/> this is only recommended if your code is really short:</li>
</ol>
<div><div><img alt="Figure 2.10 – Printing HTML source code on the terminal window" src="img/B20976_02_010.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Printing HTML source code on the terminal window</p>
<ol>
<li value="8">If the terminal window does not appear after you build and run your Qt console application project, go to <strong class="bold">Edit</strong> | <strong class="bold">Preferences</strong> | <strong class="bold">Build &amp; Run</strong> and select <strong class="bold">Enabled</strong> for the <strong class="bold">Default for “Run in </strong><strong class="bold">terminal”</strong> option.</li>
</ol>
<div><div><img alt="Figure 2.11 – Enabling the terminal window from the Preferences settings" src="img/B20976_02_011.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Enabling the terminal window from the Preferences settings</p>
<p>The preceding example demonstrated<a id="_idIndexMarker164"/> how we can run a lambda function within the network reply slot function. This way, we can ensure that our code is shorter and easier to debug, but the lambda function is only suitable if the function is meant to be called only once.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor051"/>How it works…</h2>
<p>The preceding example is a very simple application that showcases the use of lambda expressions to connect a signal with a lambda function or a regular function without declaring any slot function and thus does not need to be inherited from a <code>QObject</code> class.</p>
<p>This is especially useful for calling asynchronous processes that are not under UI objects. Lambda expressions are functions that get defined within another function anonymously, which is quite similar to the <a id="_idIndexMarker165"/>anonymous functions in <strong class="bold">JavaScript</strong>. The format of a lambda function looks like this:</p>
<pre class="source-code">
[captured variables](arguments) {
    lambda code
}</pre> <p>You can insert variables into a lambda expression by placing them into the <code>captured variables</code> part, as we did in the example project in this recipe. We capture the <code>QNetworkReply</code> object called <code>reply</code>, and the <code>QString</code> object called <code>html</code>, and put them in our lambda expression.</p>
<p>Then, we can use these variables<a id="_idIndexMarker166"/> within our lambda code, as shown in the following code:</p>
<pre class="source-code">
[<strong class="bold">reply, html</strong>]() {
    <strong class="bold">html</strong>-&gt;append(QString(<strong class="bold">reply</strong>-&gt;readAll()));
}</pre> <p>The argument part is similar to an ordinary function, where you input values to the arguments and use them within your lambda code. In this case, the values of <code>bytesReceived</code> and <code>bytesTotal</code> are coming from the <code>downloadProgress</code> signal:</p>
<pre class="source-code">
QObject::connect(reply, &amp;QNetworkReply::downloadProgress,
[reply](qint64 <code>bytesReceived</code>, qint64 <code>bytesTotal</code>) {
    qDebug() &lt;&lt; "Progress: " &lt;&lt; <code>bytesReceived</code> &lt;&lt; "bytes /" &lt;&lt; <code>bytesTotal</code> &lt;&lt; "bytes";
});</pre> <p>You can also capture all variables that are used in your function using the <code>=</code> sign. In this case, we captured the <code>html</code> variable without specifying it in the <code>captured </code><code>variables</code> area:</p>
<pre class="source-code">
[=]() {
    printHTML(*html);
}</pre> <h1 id="_idParaDest-52"><a id="_idTextAnchor052"/>Function callbacks</h1>
<p>Even though Qt 6 supports the signals and slots<a id="_idIndexMarker167"/> mechanism, some of the features in Qt 6 still use <strong class="bold">function callbacks</strong>, such as keyboard input, window resizing, graphics painting, and others. Since these events only need to be implemented once, there is no need to use the signals and slots mechanism.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/>How to do it…</h2>
<p>Let’s get started by following this example:</p>
<ol>
<li>Create a <code>mainwindow.h</code>, and add the following headers:<pre class="source-code">
#include &lt;QDebug&gt;
#include &lt;QResizeEvent&gt;
#include &lt;QKeyEvent&gt;
#include &lt;QMouseEvent&gt;</pre></li> <li>Then, declare these functions in <code>mainwindow.h</code>:<pre class="source-code">
public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();
    <strong class="bold">void resizeEvent(QResizeEvent *event);</strong>
<strong class="bold">    void keyPressEvent(QKeyEvent *event);</strong>
<strong class="bold">    void keyReleaseEvent(QKeyEvent *event);</strong>
<strong class="bold">    void mouseMoveEvent(QMouseEvent *event);</strong>
<strong class="bold">    void mousePressEvent(QMouseEvent *event);</strong>
<code>mainwindow.cpp</code> and add the following code to the class constructor:<pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
ui(new Ui::MainWindow) {
    ui-&gt;setupUi(this);
    <strong class="bold">this-&gt;setMouseTracking(true);</strong>
<strong class="bold">    ui-&gt;centralWidget-&gt;setMouseTracking(true);</strong>
}</pre></li> <li>Then, define<a id="_idIndexMarker169"/> the <code>resizeEvent()</code> and <code>keyPressedEvent()</code> functions:<pre class="source-code">
void MainWindow::resizeEvent(QResizeEvent *event) {
    qDebug() &lt;&lt; "Old size:" &lt;&lt; event-&gt;oldSize() &lt;&lt; ", New size:" &lt;&lt; event-&gt;size();
}
void MainWindow::keyPressEvent(QKeyEvent *event) {
    if (event-&gt;key() == Qt::Key_Escape) {
        this-&gt;close();
    }
    qDebug() &lt;&lt; event-&gt;text() &lt;&lt; "has been pressed";
}</pre></li> <li>Continue to implement the rest of the functions:<pre class="source-code">
void MainWindow::keyReleaseEvent(QKeyEvent *event) {
    qDebug() &lt;&lt; event-&gt;text() &lt;&lt; "has been released";
}
void MainWindow::mouseMoveEvent(QMouseEvent *event) {
    qDebug() &lt;&lt; "Position: " &lt;&lt; event-&gt;pos();
}
void MainWindow::mousePressEvent(QMouseEvent *event) {
    qDebug() &lt;&lt; "Mouse pressed:" &lt;&lt; event-&gt;button();
}
void MainWindow::mouseReleaseEvent(QMouseEvent *event) {
    qDebug() &lt;&lt; "Mouse released:" &lt;&lt; event-&gt;button();
}</pre></li> <li>Build and run the program. Then, try and move the mouse around, rescale the main window, press some<a id="_idIndexMarker170"/> random keys on your keyboard, and finally press the <em class="italic">Esc</em> key on your keyboard to close the program.</li>
</ol>
<p>You should be seeing debug texts similar to the ones that are being printed out on the application output window:</p>
<pre class="console">
Old size: QSize(-1, -1) , New size: QSize(400, 300)
Old size: QSize(400, 300) , New size: QSize(401, 300)
Old size: QSize(401, 300) , New size: QSize(402, 300)
Position: QPoint(465,348)
Position: QPoint(438,323)
Position: QPoint(433,317)
"a" has been pressed
"a" has been released
"r" has been pressed
"r" has been released
"d" has been pressed
"d" has been released
"\u001B" has been pressed</pre> <h2 id="_idParaDest-54"><a id="_idTextAnchor054"/>How it works…</h2>
<p>Qt 6 objects, especially the main window, have a dozen built-in callback functions that exist as <strong class="bold">virtual functions</strong>. These functions can<a id="_idIndexMarker171"/> be overridden to perform your intended behavior when called. Qt 6 may invoke<a id="_idIndexMarker172"/> these <strong class="bold">callback functions</strong> when its expected condition has been met, such as a keyboard button has been pressed, the mouse cursor has been moved, the window has been resized, and so on.</p>
<p>The functions that we declared in the <code>mainwindow.h</code> file are virtual functions that are built into the <code>QWidget</code> class. We are just overriding them with our own code to define their new behavior when they<a id="_idIndexMarker173"/> are called.</p>
<p class="callout-heading">Note</p>
<p class="callout">Do take note that you must call <code>setMouseTracking(true)</code> for both <code>MainWindow</code> and <code>centralWidget</code> for the <code>mouseMoveEvent()</code> callback to work.</p>
<p>Without features such as function callbacks, signals and slots, we as programmers will have a more difficult time developing applications that are responsive and intuitive to use. Qt 6 shortens our development cycles and allows us to focus more on designing user-friendly applications.</p>
</div>
</body></html>