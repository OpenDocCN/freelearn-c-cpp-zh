- en: '*Chaper 1*: New C++20 Features'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter concentrates on some of the more compelling features that C++20
    adds to the STL. You can use some of these right away. Others may need to wait
    for implementation in your favorite compiler. But in the long run, I expect you'll
    want to know about most of these features.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of new additions to the C++20 standard, far more than we could
    cover here. These are a few that I think will have long-term impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Format text with the new `format` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use compile-time vectors and strings with `constexpr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safely compare integers of different types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the "spaceship" operator `<=>` for three-way comparisons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily find feature test macros with the `<version>` header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create safer templates with concepts and constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid re-compiling template libraries with modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create views into containers with ranges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter aims to familiarize you with these new features in C++20, so you
    may use them in your own projects and understand them when you encounter them.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap01](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap01).
  prefs: []
  type: TYPE_NORMAL
- en: Format text with the new format library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, if you wanted to format text, you could use either the legacy `printf`
    functions or the STL `iostream` library. Both have their strengths and flaws.
  prefs: []
  type: TYPE_NORMAL
- en: The `printf`-based functions are inherited from C and have proven efficient,
    flexible, and convenient for over 50 years. The formatting syntax can look a bit
    cryptic, but it's simple enough once you get used to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The main weakness in `printf` is its lack of type safety. The common `printf()`
    function (and its relatives) use C's *variadic arguments* model to pass parameters
    to a formatter. This works great when it works, but it can cause serious problems
    when a parameter type doesn't match its corresponding format specifier. Modern
    compilers do as much type-checking as they can, but the model is inherently flawed
    and the protection can only go so far.
  prefs: []
  type: TYPE_NORMAL
- en: The STL `iostream` library brings type safety at the expense of readability
    and run-time performance. The `iostream` syntax is unusual, yet familiar. It overloads
    the *bitwise left-shift operator* (`<<`) to allow a chain of objects, operands,
    and *formatting manipulators*, which produce the formatted output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The weakness of `iostream` is its complexity, in both syntax and implementation.
    Building a formatted string can be verbose and obscure. Many of the formatting
    manipulators must be reset after use, or they create cascading formatting errors
    that can be difficult to debug. The library itself is vast and complex, resulting
    in code significantly larger and slower than its `printf` equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: This dismal situation has left C++ programmers with little option but to choose
    between two flawed systems, until now.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new `format` library is in the `<format>` header. As of this writing, `format`
    is implemented only in the *MSVC* (Microsoft) compiler. By the time you read this,
    it should be available on more systems. Otherwise, you may use its reference implementation
    as a third-party library from `fmt.dev` ([j.bw.org/fmt](http://j.bw.org/fmt)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `format` library is modeled on the `str.format()` method from Python 3\.
    *Format strings* are substantially the same as those in Python and, for most purposes,
    they should be interchangeable. Let''s examine some simple examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest form, the `format()` function takes a `string_view` format
    string and a *variadic parameter pack* of arguments. It returns a `string`. Its
    function signature looks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `format()` function returns a `string` representation of virtually any
    type or value. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The *format string* uses braces `{}` as a placeholder. With no *format specifiers*,
    the braces are effectively a type-safe *placeholder* which will convert a value
    of any compatible type to a reasonable string representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can include multiple placeholders in your format string, like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can specify the order of the replacement values. This could be useful for
    internationalization:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can align values, left (`<`), right (`>`), or center (`^`), with or without
    a fill character:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can set the decimal precision of values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And much, much more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's a rich and complete formatting specification that provides the type-safety
    of `iostream` with the performance and simplicity of `printf`, for the best of
    both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `format` library does not yet include a `print()` function, which is planned
    for *C++23*. The `format()` function itself returns a `string` object. So, if
    you want to print the string, you'll need to use either `iostream` or `cstdio`.
    (Sad face.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can print the string using `iostream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you may use `cstdio`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Neither is ideal, but it's not very hard to write a simple `print()` function.
    And we can use this process to understand a bit of the `format` library's inner
    workings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple implementation of a `print()` function using the `format`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This uses the same arguments as the `format()` function. The first argument
    is a `string_view` object for the format string. This is followed by a variadic
    parameter pack for the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The `make_format_args()` function takes the parameter pack and returns an object
    that contains *type-erased values* suitable for formatting. This object is then
    passed to `vformat()`, which returns a `string` suitable for printing. We use
    `fputs()` to print the value to the console because it's far more efficient than
    `cout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use this `print()` function in place of the `cout << format()` combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When you eventually get a C++23 complier with `print()` support, you should
    be able to simply replace the above `print()` template function definition with
    `using std::print;` and all the `print()` calls should continue to work.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's nice to have the ability to format strings and primitives, but for the
    `format` library to be fully functional, it needs customization to work with your
    own classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here''s a simple `struct` with two members: a *numerator* and
    *denominator*. We would like this to print as a fraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When I compile this, it leads to a cascade of errors to the effect of, "No user-defined
    conversion operator…". Cool. So, let's fix it!
  prefs: []
  type: TYPE_NORMAL
- en: When the `format` system encounters an object for *conversion*, it looks for
    a *specialization* of a `formatter` object with the corresponding type. Standard
    specializations are included for common objects such as strings and numbers and
    such.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s quite simple to create a specialization for our `Frac` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This `formatter` specialization is a class with two short template functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `parse()` function parses the *format string* from after the colon (or,
    if there is no colon, after the opening brace) up to but not including the closing
    brace. (In other words, the part that specifies the type of the object.) It takes
    a `ParseContext` object and returns an iterator. For our purposes, we can just
    return the `begin()` iterator because we don't need any new syntax for our *type*.
    You will rarely need to put anything else here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `format()` function takes a `Frac` object and a `FormatContext` object.
    It returns an *end iterator*. The `format_to()` function makes this easy. It takes
    an iterator, a format string, and a parameter pack. In this case, the parameter
    pack is the two properties of our `Frac` class, the numerator and denominator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All we need to do here is provide a simple format string `"{0}/{1}"` and the
    numerator and denominator values. (The `0` and `1` indicate the position of the
    parameters. They're not strictly necessary but they could come in handy later.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a specialization for `Frac`, we can pass our object to `print()`
    to get a readable result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The C++20 `format` library solves a long-standing problem by providing a type-safe
    text formatting library that is both efficient and convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Use compile-time vectors and strings with constexpr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++20 allows the use of `constexpr` in several new contexts. This provides improved
    efficiency, in that these things may be evaluated at compile time, instead of
    run time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The specification includes the ability to use `string` and `vector` objects
    in `constexpr` context. It''s important to note that these objects may not themselves
    be declared `constexpr`, but they may be used in a compile-time context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use algorithms in `constexpr` context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The result of the `accumulate` algorithm is available at compile time and in
    `constexpr` context.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `constexpr` specifier declares a variable or function that may be *evaluated
    at compile time.* Before C++20, this was limited to objects initialized with a
    literal value, or a function within limited constraints. C++17 allowed a somewhat
    expanded use and C++20 expands it further.
  prefs: []
  type: TYPE_NORMAL
- en: As of C++20, the STL `string` and `vector` classes now have `constexpr`-qualified
    constructors and destructors, which allow them to be invoked at compile time.
    This also means that the memory allocated for the `string` or `vector` object
    *must be freed at compile time.*
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this `constexpr` function, which returns a `vector`, will compile
    without error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you try to use the result in a run-time context, you will get an error
    about memory that was allocated during constant evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is because the `vector` object was allocated *and freed* during compilation.
    So, the object is no longer available at run time.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, you can use some `constexpr`-qualified methods from the
    `vector` object, such as `size()`, at run time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Because the `size()` method is `constexpr`-qualified, the expression can be
    evaluated at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Safely compare integers of different types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comparing different types of integers may not always produce the expected results.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You may expect this code to print `true`, and that's understandable. -3 is usually
    less than 7\. But it will print `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that `x` is signed and `y` is unsigned. The standardized behavior
    is to convert the signed type to unsigned for the comparison. That seems counterintuitive,
    doesn't it? Indeed, you cannot reliably convert an unsigned value to a signed
    value of the same size, because a signed integer uses *two's complement* representation
    (which uses the most significant bit as a sign). Given the same sized integer,
    the maximum signed value is half that of an unsigned value. Using this example,
    if your integers are 32-bits, -3 (signed) becomes `FFFF FFFD` (hexadecimal), or
    4,294,967,293 (unsigned decimal), which is *not less than 7*.
  prefs: []
  type: TYPE_NORMAL
- en: Some compilers may issue a warning when you try to compare signed with unsigned
    integer values, but most do not.
  prefs: []
  type: TYPE_NORMAL
- en: The C++20 standard includes a set of integer-safe comparison functions in the
    `<utility>` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new integer comparison functions are found in the `<utility>` header. They
    each take two arguments, which correspond with the left- and right-hand sides
    of the operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `cmp_less()` function gives us the result we expect. -3 is less than 7 and
    the program now prints `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<utility>` header provides a full complement of integer comparison functions.
    Assuming our values for `x` and `y`, we get these comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the sample implementation of the `cmp_less()` function from the C++20
    standard, to give you a more complete picture of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `UT` and `UU` aliases are declared as `make_unsigned_t`, a useful helper
    type introduced with C++17\. This allows safe conversions of signed to unsigned
    types.
  prefs: []
  type: TYPE_NORMAL
- en: The function first tests if both arguments are either signed or unsigned. If
    so, it returns a simple comparison.
  prefs: []
  type: TYPE_NORMAL
- en: It then tests if either side is signed. If that signed value is less than zero,
    it can return `true` or `false` without performing a comparison. Otherwise, it
    converts the signed value to unsigned and returns the comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Similar logic is applied to each of the other comparison functions.
  prefs: []
  type: TYPE_NORMAL
- en: Use the "spaceship" operator <=> for three-way comparisons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *three-way comparison* operator (`<=>`), commonly called the *spaceship*
    operator because it looks like a flying saucer in profile, is new in C++20\. You
    may wonder, what's wrong with the existing six comparison operators? Nothing at
    all, and you will continue using them. The purpose of the spaceship is to provide
    a unified comparison operator for objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common two-way comparison operators return one of two states, `true` or
    `false`, according to the result of the comparison. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `a < b` expression uses the *less-than comparison* operator (`<`) to test
    if `a` is less than `b`. The comparison operator returns `true` if the condition
    is satisfied, or `false` if not. In this case it returns `true` because 7 is less
    than 42.
  prefs: []
  type: TYPE_NORMAL
- en: The three-way comparison works differently. It returns one of three states.
    The spaceship operator will return a value equal to `0` if the operands are equal,
    *negative* if the left-hand operand is less than the right-hand operand, or *positive*
    if the left-hand operand is greater than the right-hand operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The returned value is *not an integer*. It's an object from the `<compare>`
    header that compares with `0`.
  prefs: []
  type: TYPE_NORMAL
- en: If the operands have an integral type, the operator returns a `strong_ordering`
    object from the `<compare>` library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the operands have a floating-point type, the operator returns a `partial_ordering`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: These objects are designed to compare against a literal zero (`0`) with conventional
    comparison operators (for example, `(a <=> b) < 0`). This allows the results of
    the three-way comparison to be more precise than conventional comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: If all of that seems a bit complicated, that's okay. For most applications you
    will never use the spaceship operator directly. Its real power is in its application
    as a unified comparison operator for objects. Let's dig a bit deeper.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at a simple class that encapsulates an integer and provides comparison
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It's not uncommon to see a list of comparison operator overloads like this.
    In fact, it should be even more complicated with *non-member friends* that work
    with objects on either side of the operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new spaceship operator, all of this can be accomplished with one overload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we need to include the `<compare>` header for the three-way operator
    return types. Now we can declare some variables and test them with comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will automatically favor the `<=>` operator for each of the comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: Because the default `<=>` operator is already `constexpr` safe, we don't need
    to declare it as such in our member function.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `operator<=>` overload takes advantage of a new C++20 concept, *rewritten
    expressions*. During overload resolution, the compiler rewrites the expression
    according to a set of rules. For example, if we write `a < b`, the compiler will
    rewrite it to `(a <=> b < 0)` so that it works with our member operator. The compiler
    will rewrite every relevant comparison expression for the `<=>` operator, where
    we haven't included a more specific operator.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we no longer need a non-member function to handle comparisons with
    a compatible type on the left-hand side. The compiler will *synthesize* an expression
    that works with the member operator. For example, if we write `42 > a`, the compiler
    will synthesize an expression with the operators reversed `(a <=> 42 < 0)` so
    that it works with our member operator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `<=>` operator has *higher precedence* than the other comparison operators
    so it will always evaluate first. All comparison operators evaluate left-to-right.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default operator will work just fine with a wide variety of classes, including
    classes with multiple numeric members of different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if you have a more complex type? Here''s an example of a simple fraction
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this case we need to define the `operator<=>` overload because our data members
    are not stand-alone scalar values. It's still quite simple and it works just as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we also needed an `operator==` overload. This is because the expression
    rewrite rules will not rewrite `==` and `!=` with a custom `operator<=>` overload.
    You only need to define `operator==`. The compiler will rewrite the `!=` expression
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can define some objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can test them with normal comparison operators, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The power of the spaceship operator is in its ability to streamline comparison
    overloads in your classes. It improves both simplicity and efficiency when compared
    to overloading each operator independently.
  prefs: []
  type: TYPE_NORMAL
- en: Easily find feature test macros with the <version> header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ has provided some form of feature test macros for as long as new features
    have been added. Beginning with C++20, the process is standardized, and all *library
    feature* test macros have been added to the `<version>` header. This will make
    it much easier to test for a new feature in your code.
  prefs: []
  type: TYPE_NORMAL
- en: This is a useful feature and it's very simple to use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All feature test macros begin with the prefix `__cpp_`. Library features begin
    with `__cpp_lib_`. Language feature test macros are typically defined by the compiler.
    Library feature test macros are defined in the new `<version>` header. Use them
    as you would any other preprocessor macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, you can use the `__has_include` preprocessor operator (introduced
    in C++17) to test for the existence of an include file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can use `__has_include` to test for the existence of any header file. Because
    it's a preprocessor directive, it doesn't require a header of its own to work.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, you can use the feature test macros by testing for a non-zero value
    using `#ifdef` or `#if defined`. Each of the feature test macros has a non-zero
    value that corresponds to the year and month it was accepted by the standards
    committee. For example, the `__cpp_lib_three_way_comparison` macro has a value
    of `201907`. This means that it was accepted in July 2019.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The value of the macro may be useful in some obscure cases where a feature has
    changed and you're dependent upon the changes. For most purposes, you can safely
    ignore the value and just test for non-zero with `#ifdef`.
  prefs: []
  type: TYPE_NORMAL
- en: Several websites maintain a complete list of feature test macros. I tend to
    use *cppreference* ([https://j.bw.org/cppfeature](https://j.bw.org/cppfeature))
    but there are others.
  prefs: []
  type: TYPE_NORMAL
- en: Create safer templates with concepts and constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Templates are great for writing code that works with different types. For example,
    this function will work with any numeric type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: But what happens when you try to call it with a non-numeric type?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This compiles and runs without error, but the result is unpredictable. In fact,
    the call is dangerous and it could easily crash or become a vulnerability. I would
    much prefer the compiler generate an error message so I can fix the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with concepts, I can write it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `requires` keyword is new for C++20\. It applies constraints to a template.
    `Numeric` is the name of a *concept* that only accepts integer and floating-point
    types. Now, when I compile this code with a non-numeric parameter, I get a reasonable
    compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Error messages like this are far more useful than most compiler errors.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at how to use concepts and constraints in your code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A concept is simply a named constraint. The `Numeric` concept from above looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This *concept* requires a type `T`, which satisfies either the `std::integral`
    or `std::floating_point` predefined concepts. These concepts are included in the
    `<concepts>` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concepts and constraints may be used in class templates, function templates,
    or variable templates. We''ve seen a constrained function template, now here''s
    a simple constrained class template example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s a simple variable template example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can use concepts and constraints on any template. Let's consider some further
    examples. We'll be using function templates in these examples for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: A constraint may use concepts or *type traits* to evaluate the characteristics
    of a type. You may use any of the type traits found in the `<type_traits>` header,
    so long as it returns a `bool`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `requires` keyword is new in C++20\. It introduces a constraint for the
    template arguments. In this example, the constraint expression tests the template
    argument against the type trait `is_integral`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use one of the pre-defined traits found in the `<type_traits>` header,
    or you can define your own, just as you would a template variable. For use in
    constraints, the variable must return `constexpr bool`. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This defines a type trait called `is_gt_byte`. This trait uses the `sizeof`
    operator to test if the type `T` is larger than 1 byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *concept* is simply a named set of constraints. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This defines a concept named `Numeric`. It uses our `is_gt_byte` constraint,
    along with the `floating_point` and `integral` concepts from the `<concepts>`
    header. We can use it to constrain a template to only accept numeric types that
    are greater than 1 byte in size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that I've applied the constraint in the template declaration,
    rather than on a separate line in a `requires` expression. There are a few ways
    to apply a concept. Let's look at how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several different ways you can apply a concept or constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply a concept or constraint with the `requires` keyword:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can apply a concept in the template declaration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can use the `requires` keyword in a function signature:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or you can use a concept in a parameter list for an abbreviated function template:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For many purposes, choosing one of these strategies may be a matter of style.
    And there are circumstances where one may be a better option than another.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard uses the terms *conjunction*, *disjunction*, and *atomic*, to describe
    types of expressions that can be used to construct a constraint. Let's define
    these terms.
  prefs: []
  type: TYPE_NORMAL
- en: You can combine concepts and constraints using the `&&` and `||` operators.
    These combinations are called *conjunctions* and *disjunctions*, respectively.
    You can think of them as logical *AND* and *OR*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *constraint conjunction* is formed by using the `&&` operator with two constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: A conjunction is satisfied only if both sides of the `&&` operator are satisfied.
    It is evaluated left-to-right. The operands of a conjunction are short-circuited,
    that is, if the left side constraint is not satisfied the right side will not
    be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *constraint disjunction* is formed by using the `||` operator with two constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: A disjunction is satisfied if either side of the `||` operator is satisfied.
    It is evaluated left-to-right. The operands of a conjunction are short-circuited,
    that is, if the left side constraint is satisfied the right side will not be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: An *atomic constraint* is an expression that returns a `bool` type, which cannot
    be further decomposed. In other words, it is not a conjunction or a disjunction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the logical`!` (*NOT*) operator in an atomic constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the `!` operator inverts the value of the `bool` expression to
    the right of the `!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we can combine all these expression types into a larger expression.
    We see examples of each of these constraint expressions in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Let's break this down. The sub-expression, `(integral<T>` `floating_point<T>)`
    is a *disjunction*. The sub-expression, `is_gt_byte<T>` `(`…`)` is a *conjunction*.
    And each of the sub-expressions `integral<T>`, `floating_point<T>`, and `is_gt_byte<T>`,
    are *atomic*.
  prefs: []
  type: TYPE_NORMAL
- en: These distinctions are mostly for descriptive purposes. While it's good to understand
    the details, as you write your code, it's safe to think of them as simple logical
    `||`, `&&`, and `!` operators.
  prefs: []
  type: TYPE_NORMAL
- en: Concepts and constraints are a welcome addition to the C++ standard and I'm
    looking forward to using them in my future projects.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid re-compiling template libraries with modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Header files have been around since the very beginning of the C language. Originally,
    they were mainly used for *text substitution macros* and linking *external symbols*
    between translation units. With the introduction of templates, C++ leveraged header
    files to carry actual code. Because templates need to be recompiled for changes
    in specializations, we've been carrying them around in header files for many years.
    As the STL continues to grow over the years, these header files have grown as
    well. The situation has become unwieldy and is no longer scalable for the future.
  prefs: []
  type: TYPE_NORMAL
- en: Header files typically contain a lot more than templates. They often contain
    configuration macros and other symbols that are required for system purposes,
    but not useful for the application. As the number of headers grows, the number
    of opportunities for symbol collisions grows as well. This is even more problematic
    when you consider the abundance of macros, which are not subject to namespace
    restrictions nor any form of type safety.
  prefs: []
  type: TYPE_NORMAL
- en: C++20 addresses this problem with *modules*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may be used to creating header files like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This minimalist example illustrates several of the problems that modules address.
    The `BW_MATH` symbol is used as an *include guard*. Its only purpose is to prevent
    the header file from being included more than once, yet its symbol is carried
    throughout the translation unit. When you include this header in your source file,
    it may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now that `BW_MATH` symbol is available to every other header you've included,
    and every header included by the other headers, and on and on. That's a lot of
    opportunities for collision. And keep in mind, the compiler cannot check for these
    collisions. They're macros. That means they're translated by the preprocessor
    before the compiler ever has a chance to see them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we get to the actual point of the header, the template function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Because it's a template, every time you use the `add()` function the compiler
    must create a separate specialization. This means that the template function must
    be parsed and specialized each time it's invoked. That's why templates go in header
    files; the source must be available at compile time. As the STL grows and evolves,
    with its many large template classes and functions, this becomes a significant
    scalability problem.
  prefs: []
  type: TYPE_NORMAL
- en: '*Modules* solve these problems and more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a module, `bw-math.h` becomes `bw-math.ixx` (in the MSVC naming convention)
    and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the only symbols exported are the name of the module, `bw_math`,
    and the name of the function, `add()`. This keeps the namespace clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage is cleaner as well. When we use it in `module-test.cpp`, it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `import` declarations are used where we might otherwise use `#include` preprocessor
    directives. These import the symbol tables from the modules for linkage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of our example looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The module version works exactly as it did in a header file, only cleaner and
    more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The compiled module includes a separate *metadata file* (*module-name*`.ifc`
    in the MSVC naming convention), which describes the module interface. This allows
    the module to support templates. The metadata includes sufficient information
    for the compiler to create template specializations.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `import` and `export` declarations are at the core of the *Modules* implementation.
    Let''s take another look at the `bw-math.ixx` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Notice the two `export` declarations. The first exports the module itself with
    `export module bw_math`. This declares the translation unit as a module. There
    must be a module declaration at the top of every module file, and before any other
    statements. The second `export` makes the function name `add()` available to the
    *module consumer*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your module requires `#include` directives, or other global fragments, you
    will need to first declare your module with a simple module declaration like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `module;` declaration, on a line by itself at the top of the file, introduces
    a *global module fragment*. Only preprocessor directives may appear in the global
    module fragment. This must be immediately followed by a standard module declaration
    (`export module bw_math;`) and the rest of the module content. Let''s look closer
    at how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: An `export` declaration makes a symbol visible to the *module consumer*, that
    is, the code that imports the module. Symbols default to private.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can export a block, like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can export a namespace:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or, you can export individual symbols from a namespace:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An `import` declaration imports a module in the *consumer*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can even import a module and export it to the consumer to pass it along:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `export` keyword must precede the `import` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std.core` module is now available for the consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, modules are a simple, straightforward alternative to header
    files. I know a lot of us are looking forward to the broad availability of modules.
    I can see this greatly reducing our dependency on header files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the only complete implementation of modules is in a
    *preview release* of MSVC. The module filename extension (`.ixx`) may be different
    for other compilers. Also, the amalgamated `std.core` module is part of how MSVC
    implements the STL as modules in this release. Other compilers may not use this
    convention. Some details may change when fully compliant implementations are released.
  prefs: []
  type: TYPE_NORMAL
- en: In the example files, I've included a module version of my `format`-based `print()`
    function. This works on the current preview release of MSVC. It may require some
    small modifications to make it work on other systems, once they support enough
    of the modules specification.
  prefs: []
  type: TYPE_NORMAL
- en: Create views into containers with ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new `ranges` library is one of the more significant additions to C++20\.
    It provides a new paradigm for filtering and processing containers. Ranges provide
    clean and intuitive building blocks for more effective and readable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining a few terms:'
  prefs: []
  type: TYPE_NORMAL
- en: A `begin()` and `end()` iterators is a range. This includes most STL containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **View** is a range that transforms another underlying range. Views are lazy,
    meaning they only operate as the range iterates. A view returns data from the
    underlying range and does not own any data itself. Views operate in *O(1)* constant
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `|` operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `<ranges>` library uses the `std::ranges` and the `std::ranges::view` namespaces.
    Recognizing that this is cumbersome, the standard includes an alias for `std::ranges::view`
    as the simply, `std::view`. I still find that cumbersome. For this recipe I will
    use the following aliases, to save space and because I find it more elegant:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`namespace ranges = std::ranges;  // save the fingers!`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`namespace views = std::ranges::views;  `'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This applies to all the code in this recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ranges` and `views` classes are in the `<ranges>` header. Let''s look
    at how you can use them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *View* is applied to a *Range*, like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '`ranges::take_view(range, n)` is a view that returns the first *n* elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also use the *view adapter* version of `take_view()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '*View adapters* are in the `std::ranges::views` namespace. A *view adapter*
    takes the *range operand* from the left-hand side of the `|` operator, much like
    the `iostreams` usage of the `<<` operator. The `|` operands are evaluated left-to-right.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because a view adapter is *iterable*, it also qualifies as a range. This allows
    them to be applied serially, like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filter()` view uses a predicate function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `transform()` view uses a transformation function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, these views and adapters work on ranges of any type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ranges` library also includes a few *range factories*. The `iota` factory
    will generate an incrementing series of values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iota(value, bound)` function generates a sequence starting with `value`
    and ending *before* `bound`. If `bound` is omitted, the sequence is infinite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '*Ranges*, *Views*, and *View Adapters* are incredibly flexible and useful.
    Let''s take a deeper look for a better understanding.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To satisfy the basic requirements for a *Range*, an object must have at least
    two iterators, `begin()` and `end()`, where the `end()` iterator is a sentinel,
    used to determine the end point of a range. Most STL containers qualify as ranges,
    including `string`, `vector`, `array`, `map`, and others, with the notable exception
    of container-adapters, like `stack` and `queue`, which don't have `begin` and
    `end` iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *View* is an object which operates on a range and returns a modified range.
    A view operates lazily, and contains no data of its own. Instead of keeping a
    copy of the underlying data, it simply returns iterators to underlying elements
    as needed. Let''s examine this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `take_view` object takes two parameters, a *range* (in
    this case, a `vector<int>` object), and a *count*. The result is a *view* with
    the first *count* objects from the `vector`. At evaluation time, during the iteration
    of the `for` loop, the `take_view` object simply returns iterators that point
    to elements of the `vector` object, as needed. The `vector` object is not modified
    in this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the views in the `ranges` namespace have corresponding *range adapters*
    in the `views` namespace. These adapters may be used with the *bitwise or* (`|`)
    operator, as a pipe, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the `|` operator evaluates left to right. And because the result
    of the range adapter is another range, these adapter expressions may be chained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The library includes a `filter` view that is used with a *predicate*, for defining
    simple filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Also included, is a `transform` view that is used with a *transform function*
    for transforming results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: There are quite a few useful views and view adapters in the library. Please
    check your favorite reference site, or ([https://j.bw.org/ranges](https://j.bw.org/ranges))
    for a complete list.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beginning with C++20, most of the algorithms in the `<algorithm>` header include
    versions for use with `ranges`. These versions are still in the `<algorithm>`
    header, but in the `std::ranges` namespace. This distinguishes them from the legacy
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that, instead of calling an algorithm with two iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now call it with just a range, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: That's certainly more convenient, but how does it really help?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the case where you want to sort part of a vector, you could do that
    the old way, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'This would sort the elements of the vector after the first 5\. With the `ranges`
    version, you can use a view to skip the first 5 elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even combine views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, you can even use range adapters as the argument to `ranges::sort`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, if you wanted to do this with the traditional `sort` algorithm
    and vector iterators, it would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: While that's certainly shorter, and not impossible to understand, I find the
    range adapters version far more intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a complete list of algorithms that have been constrained to work
    with ranges on the *cppreference* site (https://j.bw.org/algoranges).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we've only scratched the surface of *Ranges* and *Views*. This
    feature is the culmination of over a decade of work by many different teams, and
    I expect it to fundamentally change the way we use containers in the STL.
  prefs: []
  type: TYPE_NORMAL
