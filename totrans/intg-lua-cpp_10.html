<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-213"><a id="_idTextAnchor215"/>10</h1>
<h1 id="_idParaDest-214"><a id="_idTextAnchor216"/>Managing Resources</h1>
<p>In the previous chapter, we recapped the communication mechanisms between Lua and C++. In this chapter, we will learn more about managing resources. Resources can be anything an object uses, such as memory, files, or network sockets.</p>
<p>We will cover the following topics:</p>
<ul>
<li>Customizing Lua memory allocation</li>
<li>Delegating C++ object memory allocation to Lua</li>
<li>What is RAII?</li>
</ul>
<h1 id="_idParaDest-215"><a id="_idTextAnchor217"/>Technical requirements</h1>
<p>We will use the source code for <em class="italic">Chapter 9</em> as a base to develop the examples in this chapter. Make sure you can access the source code for this book: <a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter10">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter10</a>.</p>
<h1 id="_idParaDest-216"><a id="_idTextAnchor218"/>Customizing Lua memory allocation</h1>
<p>In the<a id="_idIndexMarker438"/> Lua runtime, memory is allocated, reallocated, or deallocated in the heap in the following situations:</p>
<ul>
<li><strong class="bold">Memory is allocated</strong>: This happens when an object is created. Lua needs to allocate a piece of memory to hold it.</li>
<li><strong class="bold">Memory is reallocated</strong>: This happens when the size of an object needs to be changed – for example, adding entries to a table when the table has no more pre-allocated space.</li>
<li><strong class="bold">Memory is deallocated</strong>: This happens during garbage collection when the object is no longer needed.</li>
</ul>
<p>In most situations, you do not need to be concerned about this. But sometimes, it is helpful to get<a id="_idIndexMarker439"/> an insight into, or customize, the Lua memory allocation. Here are some examples:</p>
<ul>
<li>You need to analyze the memory footprint of your Lua objects to find optimization opportunities.</li>
<li>You need to customize where the memory is allocated. For example, to increase runtime efficiency, you may have a memory pool and you can simply have Lua use it without allocating new memory regions in the heap every time.</li>
</ul>
<p>In this section, we will see how we can customize Lua’s memory allocation by providing a memory allocation function.</p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor219"/>What is the Lua memory allocation function?</h2>
<p>Lua provides a<a id="_idIndexMarker440"/> simple way to customize memory allocation. When you create a Lua state, you can provide a memory allocation function so that whenever Lua needs to manage memory, it calls the function you provided.</p>
<p>The memory allocation function is defined as the following type:</p>
<pre class="source-code">
typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>
<p>The function returns a pointer to the newly allocated memory, or <code>NULL</code> if the call is to deallocate a piece of memory. Its arguments are explained as follows:</p>
<ul>
<li><code>ud</code> is the pointer to user-defined data for the Lua state. You can use the same memory allocation function with many Lua states. In such cases, you can use <code>ud</code> to identify each Lua state. Lua treats this transparently.</li>
<li><code>ptr</code> is the pointer to the memory to be reallocated or deallocated. If it is <code>NULL</code>, the call to the memory allocator is to allocate a new piece of memory.</li>
<li><code>osize</code> is the original size for a previously allocated memory pointed by <code>ptr</code>. If <code>ptr</code> is <code>NULL</code>, <code>osize</code> has a special meaning – the type of the Lua object that is being allocated for, which can be <code>LUA_TSTRING</code>, <code>LUA_TTABLE</code>, and so on.</li>
<li><code>nsize</code> is the size for the memory to be allocated or reallocated. If <code>nsize</code> is <code>0</code>, the memory is to be deallocated.</li>
</ul>
<p>To <a id="_idIndexMarker441"/>register your memory allocation function, you can use <code>lua_newstate</code> to create the Lua state, which is declared as follows:</p>
<pre class="source-code">
lua_State *lua_newstate (lua_Alloc f, void *ud)</pre>
<p>With this, you provide both the memory allocation function and the user data for the Lua state to be created. Note that you can provide <code>NULL</code> to <code>ud</code>, and this user data is a C++ side object, not the Lua user data.</p>
<p>Next, we’ll implement a memory allocation function.</p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor220"/>Implementing a memory allocation function</h2>
<p>We <a id="_idIndexMarker442"/>will extend <code>LuaExecutor</code> to practice implementing a memory allocation function. When we create an executor, we want to pass a flag to indicate whether we should use our own memory allocation function.</p>
<p>You can start this work based on the source code for <em class="italic">Chapter 9</em>. In <code>LuaExecutor.h</code>, change the constructor, as follows:</p>
<pre class="source-code">
class LuaExecutor
{
public:
    LuaExecutor(const LuaExecutorListener &amp;listener,
                <strong class="bold">bool overrideAllocator = false</strong>);
};</pre>
<p>We added another Boolean argument named <code>overrideAllocator</code> for the constructor. We also provided a default value as <code>false</code> because in most cases, we do not need to override the Lua memory allocator.</p>
<p>In <code>LuaExecutor.cc</code>, implement our memory allocation function in a new anonymous<a id="_idIndexMarker443"/> namespace, as follows:</p>
<pre class="source-code">
namespace
{
void *luaAlloc(
    void *ud, void *ptr, size_t osize, size_t nsize)
{
    (void)ud;
    std::cout &lt;&lt; "[luaAlloc] ptr=" &lt;&lt; std::hex &lt;&lt; ptr
              &lt;&lt; std::dec &lt;&lt; ", osize=" &lt;&lt; osize
              &lt;&lt; ", nsize=" &lt;&lt; nsize;
    void *newPtr = NULL;
    if (nsize == 0)
    {
        free(ptr);
    }
    else
    {
        newPtr = realloc(ptr, nsize);
    }
    std::cout &lt;&lt; std::dec &lt;&lt; ", newPtr=" &lt;&lt; newPtr
              &lt;&lt; std::endl;
    return newPtr;
}
}</pre>
<p><code>luaAlloc</code> relies on the standard <code>realloc</code> and <code>free</code> C functions to allocate, reallocate, and deallocate memory. This is exactly what the default Lua allocator does. But we also<a id="_idIndexMarker444"/> log the arguments and the return value to get more insight into the memory usage.</p>
<p>To use <code>luaAlloc</code>, in <code>LuaExecutor.cc</code>, modify the constructor, as follows:</p>
<pre class="source-code">
LuaExecutor::LuaExecutor(
    const LuaExecutorListener &amp;listener,
    <strong class="bold">bool overrideAllocator</strong>)
    : L(<strong class="bold">overrideAllocator ? lua_newstate(luaAlloc, NULL)</strong>
                          <strong class="bold">: luaL_newstate()</strong>),
      listener(listener)
{ ... }</pre>
<p>Here, we check if <code>overrideAllocator</code> is <code>true</code>. If it is, we use our memory allocation function by calling <code>lua_newstate</code>. If it is not, we use the default allocator by calling <code>luaL_newstate</code>.</p>
<p>Now, let’s test our allocator.</p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor221"/>Testing it out</h2>
<p>Rewrite <code>main.cpp</code>, as<a id="_idIndexMarker445"/> follows:</p>
<pre class="source-code">
#include "LuaExecutor.h"
#include "LoggingLuaExecutorListener.h"
#include "LuaModuleExporter.hpp"
#include "Destinations.h"
int main()
{
    auto listener = std::make_unique&lt;
        LoggingLuaExecutorListener&gt;();
    auto lua = std::make_unique&lt;LuaExecutor&gt;(
        *listener, <strong class="bold">true</strong>);
    auto module = LuaModuleExporter&lt;Destinations&gt;::make(
        DestinationsLuaModuleDef::def);
    lua-&gt;registerModule(module);
    lua-&gt;executeFile("script.lua");
    return 0;
}</pre>
<p>The<a id="_idIndexMarker446"/> test code creates a Lua executor, registers the <code>Destinations</code> module, and executes <code>script.lua</code>. This is similar to what we did in the previous chapters. The only thing to note is that we are setting <code>overrideAllocator</code> to <code>true</code> when creating the <code>LuaExecutor</code> instance.</p>
<p>Rewrite <code>script.lua</code>, as follows:</p>
<pre class="source-code">
print("======script begin======")
dst = Destinations.new()
dst:wish("London", "Paris", "Amsterdam")
dst:went("Paris")
print("Visited:", dst:list_visited())
print("Unvisited:", dst:list_unvisited())
print("======script end======")</pre>
<p>The script creates an object of the <code>Destinations</code> type and tests its member functions. This, again, is similar to what we did in the previous chapters.</p>
<p>We also print out markers to mark when the script starts and finishes execution. This helps us locate things of interest because the customized memory allocation function will be quite verbose.</p>
<p>Compile and execute the project. You should get an output similar to the following:</p>
<pre class="source-code">
...
[Lua] ======script begin======
[luaAlloc] ptr=0x0, osize=7, nsize=56, newPtr=0x14e7060c0
Destinations instance created: 0x14e7060e0
[luaAlloc] ptr=0x0, osize=4, nsize=47, newPtr=0x14e706100
[luaAlloc] ptr=0x0, osize=5, nsize=56, newPtr=0x14e706130
<strong class="bold">[luaAlloc] ptr=0x0, osize=0, nsize=48, newPtr=0x14e706170</strong>
[luaAlloc] ptr=0x0, osize=0, nsize=96, newPtr=0x14e7061a0
<strong class="bold">[luaAlloc] ptr=0x14e706170, osize=48, nsize=0, newPtr=0x0</strong>
...
[Lua] Visited: Paris
[Lua] Unvisited: Amsterdam London
[Lua] ======script end======
Destinations instance destroyed: 0x14e7060e0
...</pre>
<p>The two lines<a id="_idIndexMarker447"/> highlighted here are the allocation and deallocation of the object at the <code>0x14e706170</code> address. You will also see a lot of unrelated memory allocation outputs because Lua will also use the customized memory allocation function to manage the memory of its internal states.</p>
<p>Although this customized memory allocation function is not very complex, you can extend what you have learned to change how memory is managed. This is useful for runtime optimization or resource-restricted systems.</p>
<p>In the next section, we will explore a higher-level scenario – <em class="italic">how to make Lua allocate memory for </em><em class="italic">C++ objects</em>.</p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor222"/>Delegating C++ object memory allocation to Lua</h1>
<p>So far, we <a id="_idIndexMarker448"/>have been creating C++ objects in C++ and making Lua store its pointer in userdata. This was done in <code>LuaModuleExporter::luaNew</code>, as follows:</p>
<pre class="source-code">
static int luaNew(lua_State *L)
{
    ...
    T **userdata = reinterpret_cast&lt;T **&gt;(
        lua_newuserdatauv(L, sizeof(T *), 0));
    T *obj = luaModuleDef.createInstance(L, nullptr);
    *userdata = obj;
    ...
}</pre>
<p>In this case, the Lua userdata only stores a pointer. As you may recall, Lua userdata can represent a much larger piece of memory, so you might be wondering if we can store the whole C++ object in userdata, instead of just the pointer. Yes, we can. Let’s learn how to do it.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor223"/>Using C++ placement new</h2>
<p>In C++, the<a id="_idIndexMarker449"/> most common way to <a id="_idIndexMarker450"/>create an object is to call <code>new T()</code>. This does two things:</p>
<ul>
<li>It creates a piece of memory to hold an object of the <code>T</code> type.</li>
<li>It calls a constructor of the <code>T</code> type. In our example, we are calling the default constructor.</li>
</ul>
<p>Similarly, the most common way to destroy an object is to call <code>delete obj</code>. It also does two things:</p>
<ul>
<li>It calls the destructor of the <code>T</code> type. Here, <code>obj</code> is an object of the <code>T</code> type.</li>
<li>Frees the memory that holds <code>obj</code>.</li>
</ul>
<p>C++ also <a id="_idIndexMarker451"/>provides another <em class="italic">new expression</em> that only constructs an object by calling a constructor. It <a id="_idIndexMarker452"/>does not allocate memory for the object. Instead, you tell C++ where to place the object. This <em class="italic">new expression</em> is called <strong class="bold">placement new</strong>.</p>
<p>To use <em class="italic">placement new</em>, we need to provide the address to a piece of memory that has already been allocated. We can use it in the following way:</p>
<pre class="source-code">
T* obj = new <strong class="bold">(addr)</strong> T();</pre>
<p>We need to provide the address to the memory location between the <code>new</code> keyword and the constructor.</p>
<p>Now that we have found a way to decouple C++ memory allocation and object construction, let’s extend our C++ module exporter to support delegating memory management to Lua.</p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor224"/>Extending LuaModuleDef</h2>
<p>We <a id="_idIndexMarker453"/>have implemented a C++ module<a id="_idIndexMarker454"/> exporting system in this book. It has two parts:</p>
<ul>
<li><code>LuaModuleExporter</code> abstracts the module registration and implements the Lua finalizer for the module</li>
<li><code>LuaModuleDef</code> defines the module name, exported functions, and object construction and destruction</li>
</ul>
<p>First, we will add the capability to use pre-allocated memory in <code>LuaModuleDef</code>.</p>
<p>In <code>LuaModule.h</code>, add a new member variable named <code>isManagingMemory</code>, as follows:</p>
<pre class="source-code">
struct LuaModuleDef
{
    const bool isManagingMemory;
};</pre>
<p>When <code>isManagingMemory</code> is <code>true</code>, we indicate that the <code>LuaModuleDef</code> instance is managing memory allocation and deallocation. When <code>isManagingMemory</code> is <code>false</code>, we indicate that <code>LuaModuleDef</code> is not managing memory. In the latter case, <code>LuaModuleExporter</code> should make Lua manage memory, which we will implement after we have<a id="_idIndexMarker455"/> extended <code>LuaModuleDef</code>.</p>
<p>With <a id="_idIndexMarker456"/>the new flag added, modify <code>createInstance</code>, as follows:</p>
<pre class="source-code">
const std::function&lt;T *(lua_State *, <strong class="bold">void *</strong>)&gt;
createInstance = [this](lua_State *, <strong class="bold">void *addr</strong>) -&gt; T *
{
    if (isManagingMemory)
    {
        return new T();
    }
    else
    {
        return new <strong class="bold">(addr)</strong> T();
    }
};</pre>
<p>We added a new argument – <code>void *addr</code>. When the <code>LuaModuleDef</code> instance is managing memory, it allocates the memory with the normal <em class="italic">new operator</em>. When the instance is not managing memory, it uses the <em class="italic">placement new expression</em>, where <code>addr</code> is the address where the object should be constructed.</p>
<p>This implementation is the default implementation for <code>createInstance</code>. You can override it and call a non-default constructor when you create <code>LuaModuleDef</code> instances.</p>
<p>Next, we need to modify <code>destroyInstance</code> to support <code>isManagingMemory</code> as well. Change its default implementation, as follows:</p>
<pre class="source-code">
const std::function&lt;void(T *)&gt;
destroyInstance = [this](T *obj)
{
    if (isManagingMemory)
    {
        delete obj;
    }
    else
    {
        obj-&gt;~T();
    }
};</pre>
<p>When<a id="_idIndexMarker457"/> the <code>LuaModuleDef</code> instance<a id="_idIndexMarker458"/> is not managing memory, we simply call the object’s destructor, <code>obj-&gt;~T()</code>, to destroy it.</p>
<p class="callout-heading">Placement delete?</p>
<p class="callout">If you are wondering whether there is a <em class="italic">placement delete</em> to match the <em class="italic">placement new</em>, the answer is no. To destroy an object without deallocating its memory, you can simply call its destructor.</p>
<p>With <code>LuaModuleDef</code> ready to support two ways of memory management, next, we will extend <code>LuaModuleExporter</code>.</p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor225"/>Extending LuaModuleExporter</h2>
<p>Before we add <a id="_idIndexMarker459"/>support to<a id="_idIndexMarker460"/> delegate memory management for C++ objects to Lua, we will highlight the major architectural difference:</p>
<ul>
<li>When C++ allocates the object’s memory, as we have done in this book till now, the Lua userdata holds a pointer to the address of the memory allocated</li>
<li>When Lua allocates the object’s memory as userdata, the userdata holds the actual C++ object</li>
</ul>
<p>Let’s start to <a id="_idIndexMarker461"/>extend <code>LuaModuleExporter</code>. We need to modify both <code>luaNew</code> and <code>luaDelete</code> so that they <a id="_idIndexMarker462"/>work with <code>LuaModuleDef::isManagingMemory</code>.</p>
<p>In <code>LuaModuleExporter.hpp</code>, change <code>luaNew</code>, as follows:</p>
<pre class="source-code">
static int luaNew(lua_State *L)
{
    auto exporter = getExporter(L);
    auto luaModuleDef = exporter-&gt;luaModuleDef;
    if (luaModuleDef.isManagingMemory)
    {
        T **userdata = reinterpret_cast&lt;T **&gt;(
            lua_newuserdatauv(L, sizeof(T *), 0));
        T *obj = luaModuleDef.createInstance(L, nullptr);
        *userdata = obj;
    }
    else
    {
        T *userdata = reinterpret_cast&lt;<strong class="bold">T *</strong>&gt;(
            lua_newuserdatauv(L, <strong class="bold">sizeof(T)</strong>, 0));
        luaModuleDef.createInstance(L, <strong class="bold">userdata</strong>);
    }
    lua_copy(L, -1, 1);
    lua_settop(L, 1);
    ...
}</pre>
<p>The function is <a id="_idIndexMarker463"/>broken <a id="_idIndexMarker464"/>down into four blocks, separated by new lines. These blocks are as follows:</p>
<ul>
<li>The first two lines of code get the <code>LuaModuleExporter</code> instance and the <code>LuaModuleDef</code> instance. You can revisit <em class="italic">Chapter 8</em> to understand how <code>getExporter</code> works if you need to.</li>
<li>The <code>if</code> clause creates the C++ module object and the Lua userdata. When <code>luaModuleDef.isManagingMemory</code> is <code>true</code>, the code that’s executed is the same as that in <em class="italic">Chapter 8</em>. When it is <code>false</code>, the code creates a userdata with a size of <code>sizeof(T)</code> to hold the actual <code>T</code> instance. Note that, in this case, the type of the userdata is <code>T*</code>, and its address is passed to <code>luaModuleDef.createInstance</code> to use with the <em class="italic">placement new</em>.</li>
<li>It copies the userdata to the bottom of the stack via <code>lua_copy(L, -1, 1)</code> and clears everything but the bottom of the stack via <code>lua_settop</code>(<code>L, 1</code>). The object construction is delegated to <code>LuaModuleDef</code> to clear the stack of temporary items in case <code>LuaModuleDef</code> has pushed any. These two lines of code are an improved version compared to the code in <em class="italic">Chapter 8</em> to cover more cases and the different ways of object creation.</li>
<li>The omitted code in the rest of the function is unchanged.</li>
</ul>
<p>Finally, to complete the feature, modify <code>LuaModuleExporter::luaDelete</code>, as follows:</p>
<pre class="source-code">
static int luaDelete(lua_State *L)
{
    auto luaModuleDef = getExporter(L)-&gt;luaModuleDef;
    <strong class="bold">T *obj = luaModuleDef.isManagingMemory</strong>
        <strong class="bold">? *reinterpret_cast&lt;T **&gt;(lua_touserdata(L, 1))</strong>
        <strong class="bold">: reinterpret_cast&lt;T *&gt;(lua_touserdata(L, 1));</strong>
    luaModuleDef.destroyInstance(obj);
    return 0;
}</pre>
<p>We <a id="_idIndexMarker465"/>need to<a id="_idIndexMarker466"/> change how to get the C++ module instance in the finalizer. The difference comes from whether the userdata is holding the actual object or a pointer to the object.</p>
<p>Next, let’s test whether the mechanism to have Lua allocate the C++ object memory works.</p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor226"/>Testing with the Destinations.cc module</h2>
<p>We only <a id="_idIndexMarker467"/>need to <a id="_idIndexMarker468"/>tweak the code in <code>Destinations.cc</code> a little bit to support both memory allocation scenarios. Change <code>getObj</code>, as follows:</p>
<pre class="source-code">
inline Destinations *getObj(lua_State *L)
{
    luaL_checkudata(L, 1, DestinationsLuaModuleDef::def
        .metatableName().c_str());
    if (DestinationsLuaModuleDef::def.isManagingMemory)
    {
        return *reinterpret_cast&lt;Destinations **&gt;(
            lua_touserdata(L, 1));
    }
    else
    {
        return reinterpret_cast&lt;Destinations *&gt;(
            lua_touserdata(L, 1));
    }
}</pre>
<p>The change we’ve made here is similar to what we did to <code>LuaModuleExporter::luaDelete</code> so that it supports the different content the Lua userdata holds.</p>
<p>To<a id="_idIndexMarker469"/> choose to have <a id="_idIndexMarker470"/>Lua allocate the memory, change <code>DestinationsLuaModuleDef::def</code>, as follows:</p>
<pre class="source-code">
LuaModuleDef DestinationsLuaModuleDef::def =
LuaModuleDef&lt;Destinations&gt;{
    "Destinations",
    {{"wish", luaWish},
     {"went", luaWent},
     {"list_visited", luaListVisited},
     {"list_unvisited", luaListUnvisited},
     {NULL, NULL}},
    <strong class="bold">false,</strong>
};</pre>
<p>Here, we set <code>LuaModuleDef::isManagingMemory</code> to <code>false</code>.</p>
<p>Compile and execute the project. You should see the following output:</p>
<pre class="source-code">
Chapter10 % ./executable
[Lua] ======script begin======
Destinations instance created: 0x135e0af10
[Lua] Visited: Paris
[Lua] Unvisited: Amsterdam London
[Lua] ======script end======
Destinations instance destroyed: 0x135e0af10</pre>
<p>If <a id="_idIndexMarker471"/>you<a id="_idIndexMarker472"/> set <code>LuaModuleDef::isManagingMemory</code> to <code>true</code>, it should also work.</p>
<p class="callout-heading">Who should manage the memory for C++ objects?</p>
<p class="callout">You can have either C++ or Lua manage the memory allocation for C++ objects. Managing memory in C++ can provide better control in complex projects. Managing memory in Lua can get rid of the double-pointer indirection. There are also psychological considerations. For some people coming from the C++ world, having Lua allocate C++ objects, especially when Lua is only one of the libraries used in the project, may seem to violate resource ownership. For some people coming from the Lua or C world, making Lua do more may be easier to accept. However, in a real-world project, these details will be hidden. As seen in this section, if you have an abstraction, it is easy to change from one way to another.</p>
<p>Next, I would like to introduce you to the RAII resource management idiom.</p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor227"/>What is RAII?</h1>
<p>This <a id="_idIndexMarker473"/>chapter is all about resource management. A resource can be a piece of memory, an opened file, or a network socket. Although in this chapter we have only used memory management as examples, the principles for all resources are the same.</p>
<p>Of course, all acquired resources need to be released. In C++, the destructor is a good place to release resources. When working with Lua, the Lua finalizer is a good trigger to release resources.</p>
<p><strong class="bold">Resource Acquisition is Initialization</strong>, or <strong class="bold">RAII</strong>, is a useful resource management idiom. This means object creation and acquiring the resources the object needs should be an atomic operation – everything should succeed, or the partially acquired resources should be released before raising an error.</p>
<p>By using this technique, the resources are also linked with the object’s life cycle. This ensures that all resources are guaranteed to be available during the life cycle of the object. This will prevent complex failure scenarios. For example, say a job has been half done and resources were spent but it could not be finished due to a certain new resource not being available.</p>
<p>When <a id="_idIndexMarker474"/>designing a C++ class, you can make sure all resources are acquired in the constructor and released in the destructor. When integrating with Lua, make sure you provide a finalizer and destroy the object from the finalizer.</p>
<p>The finalizer will be called during one of Lua’s garbage collection cycles. You should not assume when Lua does this as it is not portable across different platforms and Lua versions. If you are memory-constrained, you can trigger a garbage collection cycle manually by calling <code>lua_gc</code> from C++ or <code>collectgarbage</code> from Lua.</p>
<p class="callout-heading">Garbage collection is only for memory</p>
<p class="callout">Remember that garbage collection is only for memory. If you have a simple class that does not use other resources, it may be tempting to not provide a Lua finalizer. But if later the class is changed to rely on a non-memory resource, chances are that adding a finalizer is not part of the change. Then, you find out later that the resource is leaked from a weird bug report.</p>
<p>RAII is also useful in multithreaded programming to acquire a shared resource. We will see an example of this in the next chapter.</p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor228"/>Summary</h1>
<p>In this chapter, we learned more about resource management. We learned how to provide a customized memory allocation function to Lua. We also learned how to hold the actual C++ object in a Lua userdata. Finally, we familiarized ourselves with the RAII resource management technique.</p>
<p>In the next chapter, we will explore multithreading when integrating Lua into C++.</p>
</div>
</div></body></html>