<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer066">
<h1 class="chapter-number" id="_idParaDest-213"><a id="_idTextAnchor215"/>10</h1>
<h1 id="_idParaDest-214"><a id="_idTextAnchor216"/>Managing Resources</h1>
<p>In the previous chapter, we recapped the communication mechanisms between Lua and C++. In this chapter, we will learn more about managing resources. Resources can be anything an object uses, such as memory, files, or <span class="No-Break">network sockets.</span></p>
<p>We will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Customizing Lua <span class="No-Break">memory allocation</span></li>
<li>Delegating C++ object memory allocation <span class="No-Break">to Lua</span></li>
<li>What <span class="No-Break">is RAII?</span></li>
</ul>
<h1 id="_idParaDest-215"><a id="_idTextAnchor217"/>Technical requirements</h1>
<p>We will use the source code for <span class="No-Break"><em class="italic">Chapter 9</em></span> as a base to develop the examples in this chapter. Make sure you can access the source code for this <span class="No-Break">book: </span><a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter10"><span class="No-Break">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter10</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-216"><a id="_idTextAnchor218"/>Customizing Lua memory allocation</h1>
<p>In the<a id="_idIndexMarker438"/> Lua runtime, memory is allocated, reallocated, or deallocated in the heap in the <span class="No-Break">following situations:</span></p>
<ul>
<li><strong class="bold">Memory is allocated</strong>: This happens when an object is created. Lua needs to allocate a piece of memory to <span class="No-Break">hold it.</span></li>
<li><strong class="bold">Memory is reallocated</strong>: This happens when the size of an object needs to be changed – for example, adding entries to a table when the table has no more <span class="No-Break">pre-allocated space.</span></li>
<li><strong class="bold">Memory is deallocated</strong>: This happens during garbage collection when the object is no <span class="No-Break">longer needed.</span></li>
</ul>
<p>In most situations, you do not need to be concerned about this. But sometimes, it is helpful to get<a id="_idIndexMarker439"/> an insight into, or customize, the Lua memory allocation. Here are <span class="No-Break">some examples:</span></p>
<ul>
<li>You need to analyze the memory footprint of your Lua objects to find <span class="No-Break">optimization opportunities.</span></li>
<li>You need to customize where the memory is allocated. For example, to increase runtime efficiency, you may have a memory pool and you can simply have Lua use it without allocating new memory regions in the heap <span class="No-Break">every time.</span></li>
</ul>
<p>In this section, we will see how we can customize Lua’s memory allocation by providing a memory <span class="No-Break">allocation function.</span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor219"/>What is the Lua memory allocation function?</h2>
<p>Lua provides a<a id="_idIndexMarker440"/> simple way to customize memory allocation. When you create a Lua state, you can provide a memory allocation function so that whenever Lua needs to manage memory, it calls the function <span class="No-Break">you provided.</span></p>
<p>The memory allocation function is defined as the <span class="No-Break">following type:</span></p>
<pre class="source-code">
typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>
<p>The function returns a pointer to the newly allocated memory, or <strong class="source-inline">NULL</strong> if the call is to deallocate a piece of memory. Its arguments are explained <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="source-inline">ud</strong> is the pointer to user-defined data for the Lua state. You can use the same memory allocation function with many Lua states. In such cases, you can use <strong class="source-inline">ud</strong> to identify each Lua state. Lua treats <span class="No-Break">this transparently.</span></li>
<li><strong class="source-inline">ptr</strong> is the pointer to the memory to be reallocated or deallocated. If it is <strong class="source-inline">NULL</strong>, the call to the memory allocator is to allocate a new piece <span class="No-Break">of memory.</span></li>
<li><strong class="source-inline">osize</strong> is the original size for a previously allocated memory pointed by <strong class="source-inline">ptr</strong>. If <strong class="source-inline">ptr</strong> is <strong class="source-inline">NULL</strong>, <strong class="source-inline">osize</strong> has a special meaning – the type of the Lua object that is being allocated for, which can be <strong class="source-inline">LUA_TSTRING</strong>, <strong class="source-inline">LUA_TTABLE</strong>, and <span class="No-Break">so on.</span></li>
<li><strong class="source-inline">nsize</strong> is the size for the memory to be allocated or reallocated. If <strong class="source-inline">nsize</strong> is <strong class="source-inline">0</strong>, the memory is to <span class="No-Break">be deallocated.</span></li>
</ul>
<p>To <a id="_idIndexMarker441"/>register your memory allocation function, you can use <strong class="source-inline">lua_newstate</strong> to create the Lua state, which is declared <span class="No-Break">as follows:</span></p>
<pre class="source-code">
lua_State *lua_newstate (lua_Alloc f, void *ud)</pre>
<p>With this, you provide both the memory allocation function and the user data for the Lua state to be created. Note that you can provide <strong class="source-inline">NULL</strong> to <strong class="source-inline">ud</strong>, and this user data is a C++ side object, not the Lua <span class="No-Break">user data.</span></p>
<p>Next, we’ll implement a memory <span class="No-Break">allocation function.</span></p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor220"/>Implementing a memory allocation function</h2>
<p>We <a id="_idIndexMarker442"/>will extend <strong class="source-inline">LuaExecutor</strong> to practice implementing a memory allocation function. When we create an executor, we want to pass a flag to indicate whether we should use our own memory <span class="No-Break">allocation function.</span></p>
<p>You can start this work based on the source code for <span class="No-Break"><em class="italic">Chapter 9</em></span>. In <strong class="source-inline">LuaExecutor.h</strong>, change the constructor, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
class LuaExecutor
{
public:
    LuaExecutor(const LuaExecutorListener &amp;listener,
                <strong class="bold">bool overrideAllocator = false</strong>);
};</pre>
<p>We added another Boolean argument named <strong class="source-inline">overrideAllocator</strong> for the constructor. We also provided a default value as <strong class="source-inline">false</strong> because in most cases, we do not need to override the Lua <span class="No-Break">memory allocator.</span></p>
<p>In <strong class="source-inline">LuaExecutor.cc</strong>, implement our memory allocation function in a new anonymous<a id="_idIndexMarker443"/> namespace, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
namespace
{
void *luaAlloc(
    void *ud, void *ptr, size_t osize, size_t nsize)
{
    (void)ud;
    std::cout &lt;&lt; "[luaAlloc] ptr=" &lt;&lt; std::hex &lt;&lt; ptr
              &lt;&lt; std::dec &lt;&lt; ", osize=" &lt;&lt; osize
              &lt;&lt; ", nsize=" &lt;&lt; nsize;
    void *newPtr = NULL;
    if (nsize == 0)
    {
        free(ptr);
    }
    else
    {
        newPtr = realloc(ptr, nsize);
    }
    std::cout &lt;&lt; std::dec &lt;&lt; ", newPtr=" &lt;&lt; newPtr
              &lt;&lt; std::endl;
    return newPtr;
}
}</pre>
<p><strong class="source-inline">luaAlloc</strong> relies on the standard <strong class="source-inline">realloc</strong> and <strong class="source-inline">free</strong> C functions to allocate, reallocate, and deallocate memory. This is exactly what the default Lua allocator does. But we also<a id="_idIndexMarker444"/> log the arguments and the return value to get more insight into the <span class="No-Break">memory usage.</span></p>
<p>To use <strong class="source-inline">luaAlloc</strong>, in <strong class="source-inline">LuaExecutor.cc</strong>, modify the constructor, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
LuaExecutor::LuaExecutor(
    const LuaExecutorListener &amp;listener,
    <strong class="bold">bool overrideAllocator</strong>)
    : L(<strong class="bold">overrideAllocator ? lua_newstate(luaAlloc, NULL)</strong>
                          <strong class="bold">: luaL_newstate()</strong>),
      listener(listener)
{ ... }</pre>
<p>Here, we check if <strong class="source-inline">overrideAllocator</strong> is <strong class="source-inline">true</strong>. If it is, we use our memory allocation function by calling <strong class="source-inline">lua_newstate</strong>. If it is not, we use the default allocator by <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">luaL_newstate</strong></span><span class="No-Break">.</span></p>
<p>Now, let’s test <span class="No-Break">our allocator.</span></p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor221"/>Testing it out</h2>
<p>Rewrite <strong class="source-inline">main.cpp</strong>, <span class="No-Break">as</span><span class="No-Break"><a id="_idIndexMarker445"/></span><span class="No-Break"> follows:</span></p>
<pre class="source-code">
#include "LuaExecutor.h"
#include "LoggingLuaExecutorListener.h"
#include "LuaModuleExporter.hpp"
#include "Destinations.h"
int main()
{
    auto listener = std::make_unique&lt;
        LoggingLuaExecutorListener&gt;();
    auto lua = std::make_unique&lt;LuaExecutor&gt;(
        *listener, <strong class="bold">true</strong>);
    auto module = LuaModuleExporter&lt;Destinations&gt;::make(
        DestinationsLuaModuleDef::def);
    lua-&gt;registerModule(module);
    lua-&gt;executeFile("script.lua");
    return 0;
}</pre>
<p>The<a id="_idIndexMarker446"/> test code creates a Lua executor, registers the <strong class="source-inline">Destinations</strong> module, and executes <strong class="source-inline">script.lua</strong>. This is similar to what we did in the previous chapters. The only thing to note is that we are setting <strong class="source-inline">overrideAllocator</strong> to <strong class="source-inline">true</strong> when creating the <span class="No-Break"><strong class="source-inline">LuaExecutor</strong></span><span class="No-Break"> instance.</span></p>
<p>Rewrite <strong class="source-inline">script.lua</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
print("======script begin======")
dst = Destinations.new()
dst:wish("London", "Paris", "Amsterdam")
dst:went("Paris")
print("Visited:", dst:list_visited())
print("Unvisited:", dst:list_unvisited())
print("======script end======")</pre>
<p>The script creates an object of the <strong class="source-inline">Destinations</strong> type and tests its member functions. This, again, is similar to what we did in the <span class="No-Break">previous chapters.</span></p>
<p>We also print out markers to mark when the script starts and finishes execution. This helps us locate things of interest because the customized memory allocation function will be <span class="No-Break">quite verbose.</span></p>
<p>Compile and execute the project. You should get an output similar to <span class="No-Break">the following:</span></p>
<pre class="source-code">
...
[Lua] ======script begin======
[luaAlloc] ptr=0x0, osize=7, nsize=56, newPtr=0x14e7060c0
Destinations instance created: 0x14e7060e0
[luaAlloc] ptr=0x0, osize=4, nsize=47, newPtr=0x14e706100
[luaAlloc] ptr=0x0, osize=5, nsize=56, newPtr=0x14e706130
<strong class="bold">[luaAlloc] ptr=0x0, osize=0, nsize=48, newPtr=0x14e706170</strong>
[luaAlloc] ptr=0x0, osize=0, nsize=96, newPtr=0x14e7061a0
<strong class="bold">[luaAlloc] ptr=0x14e706170, osize=48, nsize=0, newPtr=0x0</strong>
...
[Lua] Visited: Paris
[Lua] Unvisited: Amsterdam London
[Lua] ======script end======
Destinations instance destroyed: 0x14e7060e0
...</pre>
<p>The two lines<a id="_idIndexMarker447"/> highlighted here are the allocation and deallocation of the object at the <strong class="source-inline">0x14e706170</strong> address. You will also see a lot of unrelated memory allocation outputs because Lua will also use the customized memory allocation function to manage the memory of its <span class="No-Break">internal states.</span></p>
<p>Although this customized memory allocation function is not very complex, you can extend what you have learned to change how memory is managed. This is useful for runtime optimization or <span class="No-Break">resource-restricted systems.</span></p>
<p>In the next section, we will explore a higher-level scenario – <em class="italic">how to make Lua allocate memory for </em><span class="No-Break"><em class="italic">C++ objects</em></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor222"/>Delegating C++ object memory allocation to Lua</h1>
<p>So far, we <a id="_idIndexMarker448"/>have been creating C++ objects in C++ and making Lua store its pointer in userdata. This was done in <strong class="source-inline">LuaModuleExporter::luaNew</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
static int luaNew(lua_State *L)
{
    ...
    T **userdata = reinterpret_cast&lt;T **&gt;(
        lua_newuserdatauv(L, sizeof(T *), 0));
    T *obj = luaModuleDef.createInstance(L, nullptr);
    *userdata = obj;
    ...
}</pre>
<p>In this case, the Lua userdata only stores a pointer. As you may recall, Lua userdata can represent a much larger piece of memory, so you might be wondering if we can store the whole C++ object in userdata, instead of just the pointer. Yes, we can. Let’s learn how to <span class="No-Break">do it.</span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor223"/>Using C++ placement new</h2>
<p>In C++, the<a id="_idIndexMarker449"/> most common way to <a id="_idIndexMarker450"/>create an object is to call <strong class="source-inline">new T()</strong>. This does <span class="No-Break">two things:</span></p>
<ul>
<li>It creates a piece of memory to hold an object of the <span class="No-Break"><strong class="source-inline">T</strong></span><span class="No-Break"> type.</span></li>
<li>It calls a constructor of the <strong class="source-inline">T</strong> type. In our example, we are calling the <span class="No-Break">default constructor.</span></li>
</ul>
<p>Similarly, the most common way to destroy an object is to call <strong class="source-inline">delete obj</strong>. It also does <span class="No-Break">two things:</span></p>
<ul>
<li>It calls the destructor of the <strong class="source-inline">T</strong> type. Here, <strong class="source-inline">obj</strong> is an object of the <span class="No-Break"><strong class="source-inline">T</strong></span><span class="No-Break"> type.</span></li>
<li>Frees the memory that <span class="No-Break">holds </span><span class="No-Break"><strong class="source-inline">obj</strong></span><span class="No-Break">.</span></li>
</ul>
<p>C++ also <a id="_idIndexMarker451"/>provides another <em class="italic">new expression</em> that only constructs an object by calling a constructor. It <a id="_idIndexMarker452"/>does not allocate memory for the object. Instead, you tell C++ where to place the object. This <em class="italic">new expression</em> is called <span class="No-Break"><strong class="bold">placement new</strong></span><span class="No-Break">.</span></p>
<p>To use <em class="italic">placement new</em>, we need to provide the address to a piece of memory that has already been allocated. We can use it in the <span class="No-Break">following way:</span></p>
<pre class="source-code">
T* obj = new <strong class="bold">(addr)</strong> T();</pre>
<p>We need to provide the address to the memory location between the <strong class="source-inline">new</strong> keyword and <span class="No-Break">the constructor.</span></p>
<p>Now that we have found a way to decouple C++ memory allocation and object construction, let’s extend our C++ module exporter to support delegating memory management <span class="No-Break">to Lua.</span></p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor224"/>Extending LuaModuleDef</h2>
<p>We <a id="_idIndexMarker453"/>have implemented a C++ module<a id="_idIndexMarker454"/> exporting system in this book. It has <span class="No-Break">two parts:</span></p>
<ul>
<li><strong class="source-inline">LuaModuleExporter</strong> abstracts the module registration and implements the Lua finalizer for <span class="No-Break">the module</span></li>
<li><strong class="source-inline">LuaModuleDef</strong> defines the module name, exported functions, and object construction <span class="No-Break">and destruction</span></li>
</ul>
<p>First, we will add the capability to use pre-allocated memory <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">LuaModuleDef</strong></span><span class="No-Break">.</span></p>
<p>In <strong class="source-inline">LuaModule.h</strong>, add a new member variable named <strong class="source-inline">isManagingMemory</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
struct LuaModuleDef
{
    const bool isManagingMemory;
};</pre>
<p>When <strong class="source-inline">isManagingMemory</strong> is <strong class="source-inline">true</strong>, we indicate that the <strong class="source-inline">LuaModuleDef</strong> instance is managing memory allocation and deallocation. When <strong class="source-inline">isManagingMemory</strong> is <strong class="source-inline">false</strong>, we indicate that <strong class="source-inline">LuaModuleDef</strong> is not managing memory. In the latter case, <strong class="source-inline">LuaModuleExporter</strong> should make Lua manage memory, which we will implement after we have<a id="_idIndexMarker455"/> <span class="No-Break">extended </span><span class="No-Break"><strong class="source-inline">LuaModuleDef</strong></span><span class="No-Break">.</span></p>
<p>With <a id="_idIndexMarker456"/>the new flag added, modify <strong class="source-inline">createInstance</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
const std::function&lt;T *(lua_State *, <strong class="bold">void *</strong>)&gt;
createInstance = [this](lua_State *, <strong class="bold">void *addr</strong>) -&gt; T *
{
    if (isManagingMemory)
    {
        return new T();
    }
    else
    {
        return new <strong class="bold">(addr)</strong> T();
    }
};</pre>
<p>We added a new argument – <strong class="source-inline">void *addr</strong>. When the <strong class="source-inline">LuaModuleDef</strong> instance is managing memory, it allocates the memory with the normal <em class="italic">new operator</em>. When the instance is not managing memory, it uses the <em class="italic">placement new expression</em>, where <strong class="source-inline">addr</strong> is the address where the object should <span class="No-Break">be constructed.</span></p>
<p>This implementation is the default implementation for <strong class="source-inline">createInstance</strong>. You can override it and call a non-default constructor when you create <span class="No-Break"><strong class="source-inline">LuaModuleDef</strong></span><span class="No-Break"> instances.</span></p>
<p>Next, we need to modify <strong class="source-inline">destroyInstance</strong> to support <strong class="source-inline">isManagingMemory</strong> as well. Change its default implementation, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
const std::function&lt;void(T *)&gt;
destroyInstance = [this](T *obj)
{
    if (isManagingMemory)
    {
        delete obj;
    }
    else
    {
        obj-&gt;~T();
    }
};</pre>
<p>When<a id="_idIndexMarker457"/> the <strong class="source-inline">LuaModuleDef</strong> instance<a id="_idIndexMarker458"/> is not managing memory, we simply call the object’s destructor, <strong class="source-inline">obj-&gt;~T()</strong>, to <span class="No-Break">destroy it.</span></p>
<p class="callout-heading">Placement delete?</p>
<p class="callout">If you are wondering whether there is a <em class="italic">placement delete</em> to match the <em class="italic">placement new</em>, the answer is no. To destroy an object without deallocating its memory, you can simply call <span class="No-Break">its destructor.</span></p>
<p>With <strong class="source-inline">LuaModuleDef</strong> ready to support two ways of memory management, next, we will <span class="No-Break">extend </span><span class="No-Break"><strong class="source-inline">LuaModuleExporter</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor225"/>Extending LuaModuleExporter</h2>
<p>Before we add <a id="_idIndexMarker459"/>support to<a id="_idIndexMarker460"/> delegate memory management for C++ objects to Lua, we will highlight the major <span class="No-Break">architectural difference:</span></p>
<ul>
<li>When C++ allocates the object’s memory, as we have done in this book till now, the Lua userdata holds a pointer to the address of the <span class="No-Break">memory allocated</span></li>
<li>When Lua allocates the object’s memory as userdata, the userdata holds the actual <span class="No-Break">C++ object</span></li>
</ul>
<p>Let’s start to <a id="_idIndexMarker461"/>extend <strong class="source-inline">LuaModuleExporter</strong>. We need to modify both <strong class="source-inline">luaNew</strong> and <strong class="source-inline">luaDelete</strong> so that they <a id="_idIndexMarker462"/>work <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">LuaModuleDef::isManagingMemory</strong></span><span class="No-Break">.</span></p>
<p>In <strong class="source-inline">LuaModuleExporter.hpp</strong>, change <strong class="source-inline">luaNew</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
static int luaNew(lua_State *L)
{
    auto exporter = getExporter(L);
    auto luaModuleDef = exporter-&gt;luaModuleDef;
    if (luaModuleDef.isManagingMemory)
    {
        T **userdata = reinterpret_cast&lt;T **&gt;(
            lua_newuserdatauv(L, sizeof(T *), 0));
        T *obj = luaModuleDef.createInstance(L, nullptr);
        *userdata = obj;
    }
    else
    {
        T *userdata = reinterpret_cast&lt;<strong class="bold">T *</strong>&gt;(
            lua_newuserdatauv(L, <strong class="bold">sizeof(T)</strong>, 0));
        luaModuleDef.createInstance(L, <strong class="bold">userdata</strong>);
    }
    lua_copy(L, -1, 1);
    lua_settop(L, 1);
    ...
}</pre>
<p>The function is <a id="_idIndexMarker463"/>broken <a id="_idIndexMarker464"/>down into four blocks, separated by new lines. These blocks are <span class="No-Break">as follows:</span></p>
<ul>
<li>The first two lines of code get the <strong class="source-inline">LuaModuleExporter</strong> instance and the <strong class="source-inline">LuaModuleDef</strong> instance. You can revisit <span class="No-Break"><em class="italic">Chapter 8</em></span> to understand how <strong class="source-inline">getExporter</strong> works if you <span class="No-Break">need to.</span></li>
<li>The <strong class="source-inline">if</strong> clause creates the C++ module object and the Lua userdata. When <strong class="source-inline">luaModuleDef.isManagingMemory</strong> is <strong class="source-inline">true</strong>, the code that’s executed is the same as that in <span class="No-Break"><em class="italic">Chapter 8</em></span>. When it is <strong class="source-inline">false</strong>, the code creates a userdata with a size of <strong class="source-inline">sizeof(T)</strong> to hold the actual <strong class="source-inline">T</strong> instance. Note that, in this case, the type of the userdata is <strong class="source-inline">T*</strong>, and its address is passed to <strong class="source-inline">luaModuleDef.createInstance</strong> to use with the <span class="No-Break"><em class="italic">placement new</em></span><span class="No-Break">.</span></li>
<li>It copies the userdata to the bottom of the stack via <strong class="source-inline">lua_copy(L, -1, 1)</strong> and clears everything but the bottom of the stack via <strong class="source-inline">lua_settop</strong>(<strong class="source-inline">L, 1</strong>). The object construction is delegated to <strong class="source-inline">LuaModuleDef</strong> to clear the stack of temporary items in case <strong class="source-inline">LuaModuleDef</strong> has pushed any. These two lines of code are an improved version compared to the code in <span class="No-Break"><em class="italic">Chapter 8</em></span> to cover more cases and the different ways of <span class="No-Break">object creation.</span></li>
<li>The omitted code in the rest of the function <span class="No-Break">is unchanged.</span></li>
</ul>
<p>Finally, to complete the feature, modify <strong class="source-inline">LuaModuleExporter::luaDelete</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
static int luaDelete(lua_State *L)
{
    auto luaModuleDef = getExporter(L)-&gt;luaModuleDef;
    <strong class="bold">T *obj = luaModuleDef.isManagingMemory</strong>
        <strong class="bold">? *reinterpret_cast&lt;T **&gt;(lua_touserdata(L, 1))</strong>
        <strong class="bold">: reinterpret_cast&lt;T *&gt;(lua_touserdata(L, 1));</strong>
    luaModuleDef.destroyInstance(obj);
    return 0;
}</pre>
<p>We <a id="_idIndexMarker465"/>need to<a id="_idIndexMarker466"/> change how to get the C++ module instance in the finalizer. The difference comes from whether the userdata is holding the actual object or a pointer to <span class="No-Break">the object.</span></p>
<p>Next, let’s test whether the mechanism to have Lua allocate the C++ object <span class="No-Break">memory works.</span></p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor226"/>Testing with the Destinations.cc module</h2>
<p>We only <a id="_idIndexMarker467"/>need to <a id="_idIndexMarker468"/>tweak the code in <strong class="source-inline">Destinations.cc</strong> a little bit to support both memory allocation scenarios. Change <strong class="source-inline">getObj</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
inline Destinations *getObj(lua_State *L)
{
    luaL_checkudata(L, 1, DestinationsLuaModuleDef::def
        .metatableName().c_str());
    if (DestinationsLuaModuleDef::def.isManagingMemory)
    {
        return *reinterpret_cast&lt;Destinations **&gt;(
            lua_touserdata(L, 1));
    }
    else
    {
        return reinterpret_cast&lt;Destinations *&gt;(
            lua_touserdata(L, 1));
    }
}</pre>
<p>The change we’ve made here is similar to what we did to <strong class="source-inline">LuaModuleExporter::luaDelete</strong> so that it supports the different content the Lua <span class="No-Break">userdata holds.</span></p>
<p>To<a id="_idIndexMarker469"/> choose to have <a id="_idIndexMarker470"/>Lua allocate the memory, change <strong class="source-inline">DestinationsLuaModuleDef::def</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
LuaModuleDef DestinationsLuaModuleDef::def =
LuaModuleDef&lt;Destinations&gt;{
    "Destinations",
    {{"wish", luaWish},
     {"went", luaWent},
     {"list_visited", luaListVisited},
     {"list_unvisited", luaListUnvisited},
     {NULL, NULL}},
    <strong class="bold">false,</strong>
};</pre>
<p>Here, we set <strong class="source-inline">LuaModuleDef::isManagingMemory</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
<p>Compile and execute the project. You should see the <span class="No-Break">following output:</span></p>
<pre class="source-code">
Chapter10 % ./executable
[Lua] ======script begin======
Destinations instance created: 0x135e0af10
[Lua] Visited: Paris
[Lua] Unvisited: Amsterdam London
[Lua] ======script end======
Destinations instance destroyed: 0x135e0af10</pre>
<p>If <a id="_idIndexMarker471"/>you<a id="_idIndexMarker472"/> set <strong class="source-inline">LuaModuleDef::isManagingMemory</strong> to <strong class="source-inline">true</strong>, it should <span class="No-Break">also work.</span></p>
<p class="callout-heading">Who should manage the memory for C++ objects?</p>
<p class="callout">You can have either C++ or Lua manage the memory allocation for C++ objects. Managing memory in C++ can provide better control in complex projects. Managing memory in Lua can get rid of the double-pointer indirection. There are also psychological considerations. For some people coming from the C++ world, having Lua allocate C++ objects, especially when Lua is only one of the libraries used in the project, may seem to violate resource ownership. For some people coming from the Lua or C world, making Lua do more may be easier to accept. However, in a real-world project, these details will be hidden. As seen in this section, if you have an abstraction, it is easy to change from one way <span class="No-Break">to another.</span></p>
<p>Next, I would like to introduce you to the RAII resource <span class="No-Break">management idiom.</span></p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor227"/>What is RAII?</h1>
<p>This <a id="_idIndexMarker473"/>chapter is all about resource management. A resource can be a piece of memory, an opened file, or a network socket. Although in this chapter we have only used memory management as examples, the principles for all resources are <span class="No-Break">the same.</span></p>
<p>Of course, all acquired resources need to be released. In C++, the destructor is a good place to release resources. When working with Lua, the Lua finalizer is a good trigger to <span class="No-Break">release resources.</span></p>
<p><strong class="bold">Resource Acquisition is Initialization</strong>, or <strong class="bold">RAII</strong>, is a useful resource management idiom. This means object creation and acquiring the resources the object needs should be an atomic operation – everything should succeed, or the partially acquired resources should be released before raising <span class="No-Break">an error.</span></p>
<p>By using this technique, the resources are also linked with the object’s life cycle. This ensures that all resources are guaranteed to be available during the life cycle of the object. This will prevent complex failure scenarios. For example, say a job has been half done and resources were spent but it could not be finished due to a certain new resource not <span class="No-Break">being available.</span></p>
<p>When <a id="_idIndexMarker474"/>designing a C++ class, you can make sure all resources are acquired in the constructor and released in the destructor. When integrating with Lua, make sure you provide a finalizer and destroy the object from <span class="No-Break">the finalizer.</span></p>
<p>The finalizer will be called during one of Lua’s garbage collection cycles. You should not assume when Lua does this as it is not portable across different platforms and Lua versions. If you are memory-constrained, you can trigger a garbage collection cycle manually by calling <strong class="source-inline">lua_gc</strong> from C++ or <strong class="source-inline">collectgarbage</strong> <span class="No-Break">from Lua.</span></p>
<p class="callout-heading">Garbage collection is only for memory</p>
<p class="callout">Remember that garbage collection is only for memory. If you have a simple class that does not use other resources, it may be tempting to not provide a Lua finalizer. But if later the class is changed to rely on a non-memory resource, chances are that adding a finalizer is not part of the change. Then, you find out later that the resource is leaked from a weird <span class="No-Break">bug report.</span></p>
<p>RAII is also useful in multithreaded programming to acquire a shared resource. We will see an example of this in the <span class="No-Break">next chapter.</span></p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor228"/>Summary</h1>
<p>In this chapter, we learned more about resource management. We learned how to provide a customized memory allocation function to Lua. We also learned how to hold the actual C++ object in a Lua userdata. Finally, we familiarized ourselves with the RAII resource <span class="No-Break">management technique.</span></p>
<p>In the next chapter, we will explore multithreading when integrating Lua <span class="No-Break">into C++.</span></p>
</div>
</div></body></html>