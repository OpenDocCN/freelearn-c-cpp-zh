- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Generic Containers with Explicit Memory Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have come quite a long way since the beginning of our journey into the wonders
    of memory management mechanisms and techniques in C++. From [*Chapter 4*](B21071_04.xhtml#_idTextAnchor062)
    to [*Chapter 7*](B21071_07.xhtml#_idTextAnchor116), we built an interesting toolbox,
    one on which we can build and from which we can adapt to solve new problems we
    might face in the future. This toolbox now contains, among other things, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Techniques through which an object implicitly manages its resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types that behave like pointers but encode responsibility over the pointee in
    the type system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various ways in which we can take over the behavior of memory allocation mechanisms
    of a program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One (important!) aspect of memory management we have not covered yet is how
    containers manage memory. This is actually quite an interesting topic, one that
    we will address through three different angles, in three different chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first angle is how to handle memory management *explicitly* yet efficiently
    in a container. This is what the current chapter is about. In some application
    domains, it is customary to implement (or maintain) one’s own containers instead
    of using those provided by the standard library. There can be various reasons
    for this: for example, maybe your company has highly specialized needs. Maybe
    your company has been unsatisfied with standard library containers’ performance
    in the past, perhaps because the implementations were less efficient than they
    hoped back then, and developed its own alternative containers in response. After
    years of writing code based on your own containers, moving back to standard library
    containers might seem too costly.'
  prefs: []
  type: TYPE_NORMAL
- en: The second angle, which is somewhat shorter, is how to handle memory *implicitly*
    yet efficiently in a container, and will be covered in [*Chapter 13*](B21071_13.xhtml#_idTextAnchor187)
    of this book, where we will revisit and simplify the implementations seen in the
    current chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The third angle, which is more complex and subtle, is how to handle memory through
    an allocator in a container, and will form [*Chapter 14*](B21071_14.xhtml#_idTextAnchor199)
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the current chapter, we will write a (naïve) `std::vector<T>` lookalike named
    `Vector<T>`. We will use that as an opportunity to discuss exception safety (an
    important issue, especially when writing generic code). Then, we will notice that
    we have been very inefficient up to that point, in the sense that `std::vector<T>`
    will be significantly more efficient than our `Vector<T>` alternative, at least
    for some types. Based on this realization, we will revisit our design with better
    memory management, seeing important improvements in many aspects, and discuss
    some important low-level standard facilities for memory management that can (and
    will) make our lives easier.
  prefs: []
  type: TYPE_NORMAL
- en: We will also write a homemade `std::forward_list<T>` lookalike named `ForwardList<T>`,
    as there are issues and considerations specific to node-based containers that
    a vector-like type does not really allow us to discuss. This chapter will write
    a “vanilla” version of a forward list, and we will revisit it briefly in [*Chapter
    13*](B21071_13.xhtml#_idTextAnchor187), then in more detail in [*Chapter 14*](B21071_14.xhtml#_idTextAnchor199).
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that after reading this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a correct and exception-safe container with naïve memory management techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the problems associated with `const` or reference data members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use standard-provided low-level memory management algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More generally, you will know why `std::vector<T>` is so fast, and why that
    type is so difficult to beat at the resource management game. You will also get
    an idea of the challenges faced by node-based containers such as `std::forward_list<T>`,
    although later chapters will delve more deeply into this. That does not mean you
    should not write your own containers (for specific use cases, we can often do
    better than a general solution), but it does mean that you will know better why
    (and when) to do so, and how much effort you will need to invest.
  prefs: []
  type: TYPE_NORMAL
- en: Exhaustiveness or representativeness
  prefs: []
  type: TYPE_NORMAL
- en: This book does not in general aim for exhaustive representations or implementations
    (there are size limits to a physical object such as a book!), and this chapter
    will be no exception to that rule… far from it! Implementing the full set of member
    functions provided for two container types inspired by the standard library would
    require this book to grow immensely – and your standard library implementation
    covers many more corner cases (and offers many more cool optimizations) than a
    book such as this one could hope to present. For that reason, we will try to expose
    a core set of member functions from which you can build instead of trying to write
    every single one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code files for this chapter in the book’s GitHub repository
    here: [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter12](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter12).'
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own vector<T> alternative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose you get up one day and say: “Hey, I’m going to beat `std::vector` at
    its own game” and confidently start coding. Some words to the wise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This seemingly simple task is astonishingly difficult to accomplish: for one
    thing, `std::vector` is a work of art, and then there’s the fact that your favorite
    standard library writers are spectacularly skilled individuals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might still think you can do it, so it’s fine to try, but make sure you
    test your ideas with both a type of element that is trivially constructible (for
    example, `int` or `double`) and one that is not (for example, `std::string`) and
    compare the results. For many, the former will lead to stellar performance, but
    the latter might bring …sadness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason for this difference is that a container such as `std::vector` is
    extremely efficient at… managing memory (I know, reading this in this book must
    come as quite a shock!). It is much better, in fact, than a homegrown alternative
    would be, unless you invest significant time and effort and (most probably) have
    a specific use case in mind, one for which the homegrown version would be optimized
    more specifically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your standard library vendor does invest such time and effort and does so for
    your very benefit, so it is possible that learning how to use `std::vector` optimally
    will end up being an avenue that brings better results than trying to write your
    personal equivalent container. Of course, in the end, which container to use is
    up to you, and you can often write code for custom situations that outperforms
    general solutions the way standard containers do.
  prefs: []
  type: TYPE_NORMAL
- en: A general note on how we will write our containers
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be writing (and using) containers in this chapter and the ones that
    follow, so a brief explanation is needed if we want to have a common understanding
    of how we will proceed. For one thing, we will use type aliases in our containers
    that match those used in standard containers, as this helps toward a more fluid
    integration in other standard library tools, such as the standard algorithms.
    Then, we will strive to use the same public names for our member functions as
    those used in the standard library (for example, we will write `empty()` for the
    predicate used to test whether a container is empty or not, matching existing
    practice in the standard library, even though some might argue `is_empty()` would
    be preferable). Finally, we will adopt a gradual refinement approach: our first
    versions will be simpler but less efficient than later ones, so be patient, dear
    reader: we are following our own path to enlightenment!'
  prefs: []
  type: TYPE_NORMAL
- en: Representational choices for a container of contiguous elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Informally, a `std::vector` represents a dynamically allocated array that can
    grow as needed. As with any array, a `std::vector<T>` is a sequence of elements
    of type `T` arranged contiguously in memory. We will name our homemade version
    `Vector<T>` to make it visibly distinct from `std::vector<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: To get a reasonably performant implementation, the first key idea is to *distinguish
    size from capacity*. If we do not do so, deciding to make size and capacity the
    same thing, our `Vector<T>` implementation will always conceptually be full and
    will need to grow, which means allocating more memory, copying the elements from
    the old storage to the new storage, getting rid of the old storage, and so on
    with every insertion of even a single element. To say such an implementation would
    be painful seems like a severe understatement.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main approaches to the internal representation of a vector-like
    type. One is to keep track of three pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: One to the beginning of the allocated storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One to the end of the elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One to the end of the allocated storage (note that we are referring to half-open
    ranges here, with the beginning included and the end excluded)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A simplified illustration would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another is to keep a pointer to the beginning of the allocated storage as well
    as two integers (for the container’s size and capacity, respectively). A simplified
    illustration in this case would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These are equivalent representations in the sense that they both allow us to
    write a correct container, but they bring different trade-offs. For example, keeping
    three pointers makes computing the `end()` iterator fast but makes `size()` and
    `capacity()` require computing a pointer subtraction, whereas keeping a pointer
    and two integers makes both `size()` and `capacity()` fast but requires computing
    the addition of a pointer and an integer to get the `end()` iterator.
  prefs: []
  type: TYPE_NORMAL
- en: As far as size goes, the three-pointer representation makes `sizeof(Vector<T>)`
    equal to `3*sizeof(void*)`, thus probably 24 bytes on a 64-bit platform with an
    alignment of 8\. The pointer and two integers might be of the same size or might
    be slightly different depending on the integer types used. For example, choosing
    32-bit integers for the size and capacity on a 64-bit machine would lead to a
    16-byte representation and an alignment of 8\. These details may make a difference
    on a resource-constrained system, but as you have probably deduced already, the
    main memory consumption cost of something such as `Vector<T>` comes from the memory
    allocated for the `T` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Different implementations will make different representational choices due to
    size considerations, estimates of which member functions will be called more often
    on average, and so on. We will need to make a choice too; in this book, we will
    choose the “one pointer and two integers” approach, but keep in mind it’s one
    of a few reasonable options (you can even play with the idea and implement what
    follows through other representational choices and see where this leads you!).
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of Vector<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will walk through our initial (naïve) `Vector<T>` implementation step by
    step, building a gradual understanding of how this all works, and what makes us
    claim that this implementation is indeed naïve. Our initial step has mostly been
    covered already and consists of defining our abstractions through standard library-conforming
    type aliases and choosing our internal representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that this implementation makes the choice of using non-`static`
    data member initializers for the three data members of a `Vector<T>`, initializing
    them to their default values (integers are 0, the pointer is null), which is suitable
    in our implementation as it represents an empty container, which seems like a
    reasonable state for a default `Vector<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some simple yet fundamental member functions follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to the implementation of `empty()` and `full()`. Some people
    will prefer accessing data members (here: using `nelems` and `cap` instead of
    `size()` and `capacity()`) internally when implementing member functions, but
    consider reusing your more fundamental member functions to implement the more
    “synthetic” ones. This will make your code less sensitive to changes in the implementation,
    and C++ compilers are very good at function inlining, particularly when these
    functions are non-`virtual`.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the most useful set of members we could probably design is the
    iterator types and data members of our class, as this will help us use standard
    algorithms to cleanly and efficiently implement the rest of our member functions.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++ containers usually expose iterators as part of their interface, and ours
    will be no exception. We will define type aliases for the `const` and non-`const`
    iterator types, as this makes it simpler to implement alternatives such as bounds-checked
    iterators if we feel the need to do so, and implement both `const` and non-`const`
    versions of the `begin()` and `end()` member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You might complain about the syntactic repetition that comes with writing a
    `const` and non-`const` version for `begin()` and `end()`, as these are syntactically
    similar yet semantically distinct. If you have a C++23 compiler at hand, you can
    simplify this somewhat through the handy “deduced `this`” feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a slightly more complicated way of expressing these functions, but it
    lets us coalesce both versions of `begin()` and `end()` into one by leveraging
    the type deduction system through forwarding references.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and other special member functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now get to our constructors. The first two we will look at are the default
    constructor and a parametric constructor that takes as arguments a number of elements
    and an initial value, such that `Vector<char>(3,''a'')` yields a container with
    three elements of value `''a''`. Note that the `default`-ed default constructor
    (yes, I know) in this case is implicitly `constexpr` as all the non-`static` member
    initializers can be resolved in a `constexpr` context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to the exception-handling code in this constructor, as it will
    come back again and again. We are writing a generic container, so we are using
    some type `T` we have no prior knowledge of. When calling `std::fill()`, which
    assigns the value of the `init` argument to each of the `T` objects in the sequence,
    we are assigning a `T` value to a `T` object, but we do not know whether that
    assignment operator can throw.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our responsibility is to `elems`, a dynamically allocated array of `T`, so
    if one of the assignment operators throws, we need to make sure that array is
    destroyed and deallocated before the `Vector<T>` constructor fails; otherwise,
    we will leak the memory and (even worse) the objects we had constructed in that
    array will not be finalized. The `catch(...)` block means “catch anything,” without
    really knowing what you caught in this case, and the `throw;` expression means
    “re-throw whatever you had caught.” Indeed, we do not want to handle the exception
    in such a case (we do not have sufficient knowledge of the execution context to
    do so: is this a console application? A graphical application? An embedded system?
    Something else?); we just want to make sure our failure to construct the `Vector<T>`
    object did not leak resources and let user code know exactly why it is that our
    constructor failed to meet its postconditions (failed to construct a valid object).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The copy constructor will follow a similar pattern, except that instead of
    filling the sequence with copies of a single value, it copies values from a source
    sequence (`other`) to a destination sequence (`*this` or `elems` depending on
    how you see it). The move constructor is, of course, quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the copy constructor is a costly beast for this type: an allocation
    for `other.size()` objects (with as many calls to the default constructor of type
    `T` accompanying this for non-trivially-constructible objects), then `other.size()`
    assignments, and exception handling thrown in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The move constructor is simpler: it’s a constant-time, `noexcept` function.
    You don’t technically need move operations in most classes (C++ got along fine
    for years without move operations, after all), but when you can take advantage
    of them, you probably should do so. The speed improvements can be stupendous,
    and execution speed becomes more predictable.'
  prefs: []
  type: TYPE_NORMAL
- en: On values and salient properties
  prefs: []
  type: TYPE_NORMAL
- en: 'If you read the copy constructor’s code attentively, you might have noticed
    that `*this` did not copy `other.capacity()`, instead deciding to make `cap` a
    copy of `other.size()`. That’s actually the correct thing to do in such a case:
    the `size()` of a container is what is called a `capacity()` is more of an artifact
    of that object’s life, showing traces of how it has grown over time. What we want
    is that, after copying an object, the original and the copy compare equal with
    respect to `operator==` and, of course, `capacity()` does not intervene in that
    function: two arrays are generally considered equal if they have the same number
    of elements and each of these elements has the same value when compared to its
    counterpart in the other container. Copying the capacity would work in practice,
    but it would be wasteful for most use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I added (for convenience) a constructor that accepts an `initializer_list<T>`,
    argument to allow for initializing a `Vector<T>` object with a sequence of values
    of type `T`. The destructor should be self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementing the copy assignment operator from a source object (here: `other`)
    to a destination object (`*this`) can be complicated if done in an… undisciplined
    manner, as it involves cleanup code (for the before-assignment contents of `*this`),
    duplication of the state of the source object, and ensuring we handle both self-assignment
    and potential exceptions thrown when duplicating the source object’s state appropriately.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, there’s a neat trick suggested by Scott Meyers (and re-proposed by
    countless others!) who noticed that copy assignment can be expressed as a combination
    of a copy constructor (the locus of object duplication), the destructor (where
    cleanup happens) and a `swap()` member function: you simply copy the argument
    into an anonymous object (to make its lifetime minimal), then swap the states
    of that unnamed temporary with those of `*this`, leading to `*this` becoming a
    copy of `other`. This programming idiom almost always works, which explains its
    success!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Move assignment can be expressed along the same lines as copy assignment, but
    replacing the copy constructor with a move constructor in the implementation of
    the assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Basic services of a vector-like class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have now implemented the special member functions that handle the internal
    representation of a `Vector<T>` object, but there is more to writing a convenient
    dynamic array type. For example, member functions that let you access the `first()`
    element, or the last (`back()`) element, or that let you access the element at
    a specific index in the array (using square brackets) are all to be expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be expected, calling `front()` or `back()` on an empty `Vector<T>` is
    undefined behavior (you could make these functions throw if you prefer, but then
    everyone would pay the price for those few programs that are badly behaved maybe
    only in so-called `this`” feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Some will want to add an `at()` member function in both `const` and non-`const`
    form that behaves like `operator[]` but throws an exception if an attempt to access
    the underlying array is out of bounds. Feel free to do so if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparing two `Vector<T>` objects for equivalence or lack thereof is a relatively
    easy matter if we use algorithms since we implemented iterators for our type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you might say, we reach the point that interests us the most in a
    book discussing memory management: how to add elements to our container, and how
    the underlying memory is managed. Without going through every mechanism client
    code could use to add elements to a `Vector<T>` object, we will at least examine
    the `push_back()` and `emplace_back()` member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this version, there will be two `push_back()` member functions: one that
    takes `const T&` as argument and one that instead takes a `T&&`. The one that
    takes a `const T&` argument will copy that argument at the end of the container,
    and the one that takes a `T&&` will move it at that location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `emplace_back()` member function will take a variadic pack of arguments,
    then perfectly forward them to the constructor of a `T` object that will be placed
    at the end of the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reference to the newly constructed object is returned by `emplace_back()`
    for convenience, in case user code would like to use it right away. This is not
    done by `push_back()`, which is called with a fully constructed object to which
    user code already has access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all three functions, we first check whether the container is full, in which
    case we call `grow()`, a private member function. The `grow()` function needs
    to allocate more memory than what the container currently holds, something that
    can, of course, fail. Note that if `grow()` throws, the addition of a new object
    never occurred and the container remains intact. Note that `grow()` takes into
    account the possibility of a `capacity()` of value `0`, in which case an arbitrary
    default capacity is chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `grow()` has succeeded, we add the new element after the last object in
    the container’s storage. Note that the value is added through assignment, which
    implies an object to the left side of the assignment operation, meaning that `grow()`
    not only added storage but initialized it with (most probably) default objects
    of type `T`. Thus, we can infer that with this implementation of `Vector<T>`,
    type `T` needs to expose a default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the insertion code in `push_back()` and `emplace_back()` does, in
    both cases, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be tempted to combine the incrementation of the number of elements
    and the actual insertion expression into one, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Do *not* do that, however. “Why are you stopping me?” you might ask. Well,
    this would lead to exception-unsafe code! The reason for this is that the suffix
    version of `operator++()` has a high (very high!) priority, *much* higher than
    assignment does. This means that in the combined expression, `nelems++` happens
    very early on (which might go unnoticed as that expression yields the old value
    of `nelems`), and assignment follows later, but assignment can throw: we are assigning
    from an object of some type `T` to another object of that same type, and we do
    not know whether `T::operator=(const T&)` will throw. Of course, if it does throw,
    the assignment will not have occurred, and no object will have been added at the
    end of the containers; but the number of elements will have been incremented,
    leading to an incoherent `Vector<T>` object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a general trick here: do not modify your object until you know you
    can do so safely. Try to do the potentially throwing operations first, then do
    the operations that can mutate your object. You will sleep better, and the risks
    of object corruption will be alleviated somewhat.'
  prefs: []
  type: TYPE_NORMAL
- en: Our `grow()` member function did its work by calling `resize()` and doubling
    the container’s capacity (unless that capacity was 0, in which case it picked
    a default capacity). How does `resize()` work? With our implementation, it’s a
    matter of allocating enough memory to cover the needs of the new capacity, copying
    or moving the objects from the old memory block to the new one, then replacing
    the old memory block with the new one and updating the capacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we know whether we should move or copy the objects? Well, since moving
    could destroy the original objects, we only do so if `T::operator=(T&&)` is explicitly
    `noexcept`. The `std::is_nothrow_move_assignable<T>` trait is our tool of choice
    to determine whether that is indeed the case (if it is not, then we copy the objects,
    which is the safe option as it leaves the original objects intact):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There we go. It’s not exactly trivial code, I agree, but it’s not insurmountable
    either. Remember that this is only our first draft, and that it will be much slower
    than `std::vector<T>` for a wide array of types.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last aspect of this container we should address is how to `insert()` elements
    into it and how to `erase()` elements from it. In industrial-strength containers
    such as those found in the standard library, there is a wide array of functions
    to perform these two tasks, so we will limit ourselves to one of each: inserting
    a sequence of values at a given location in the container and erasing an element
    at a given location from the container.'
  prefs: []
  type: TYPE_NORMAL
- en: Our `insert()` member function will be a template that takes a pair of source
    iterators named `first` and `last`, as well as a `const_iterator` named `pos`
    representing a location within the `Vector<T>` object. Making it a `template`
    means that we will be able to use pairs of iterators from any container as a source
    of values to insert, a useful property indeed.
  prefs: []
  type: TYPE_NORMAL
- en: Within the function, we will use a non-`const` equivalent of `pos` named `pos_`,
    but only because we are writing a simplified and incomplete container where many
    member functions that would work on `const_iterator` objects are missing.
  prefs: []
  type: TYPE_NORMAL
- en: To perform the insertion, we will compute `remaining`, the space we will have
    available in the container (expressed as a number of objects), and `n`, which
    will be the number of objects to insert. If the available space remaining is insufficient,
    we will allocate more through our `resize()` member function. Of course, calling
    `resize()` will probably lead to `pos_` becoming invalid (it pointed into the
    old block of memory, which will be replaced by another block once `resize()` has
    completed its task), so we take care of computing the relative `index` in the
    container before resizing, and recomputing the equivalent of `pos_` in the new
    memory block after resizing.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting twist in the insertion process is that we will want to copy
    (or move, but we will keep things simple here) the objects from `pos_` to `end()`
    at the location *ending* at `end()+n` before performing the insertion of `n` objects
    at the `pos_` location, but that copy has to be made *backward* (from the last
    to the first) if we are to avoid overwriting some of the objects we are trying
    to copy along the way. The `std::copy_backward()` algorithm is expressed this
    way: the third argument expressed where the destination of the copy stops, not
    where it begins.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only then do we copy the sequence determined by `first` and `last` at position
    `pos_`, update the number of elements in the `Vector<T>` object, and return what
    the standard requires (an iterator to the first element inserted, or `pos` in
    the case where `first==last`, meaning that they determine an empty sequence):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our `erase()` member function will take a `const_iterator` argument named `pos`
    representing the location of the element to erase from the `Vector<T>` object.
    We again resort to the trick of using a non-`const` iterator named `pos_` within
    the function. Erasing `end()` is a no-op (as it should); otherwise, we perform
    a linear copy from `next(pos_)` to `end()` into the location starting at `pos_`,
    effectively replacing each element from that point on with its immediate successor.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we replace the last element with some default value, something that
    might not seem necessary but actually is since the `T` object at the end could
    have been holding some resource that needed to be freed. For example, in a program
    where we use a `Vector<Res>` object and where `Res` is an RAII type that releases
    a resource on destruction, not replacing the object “lying around just past the
    end” might lead to the associated resource being closed only when the `Vector`
    object is destroyed, which might occur later, maybe much later, than client code
    would expect it to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then update the number of elements in the `Vector<T>` object. Once again,
    this implementation means we are requiring that `T` exposes a default constructor,
    something that is not fundamentally necessary (and a requirement that we will
    alleviate later in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I’m sure you’re wondering how we could do better, but we will get back to this
    very soon. We will look at how to implement a simple node-based container (a homemade
    `std::forward_list<T>`-like type) in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own forward_list<T> alternative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing a node-based container such as `std::list`, `std::unordered_map`, `std::
    map`, and so on is an interesting exercise, but in this chapter, the fact that
    it is interesting will not necessarily “shine” right away. The points of interest
    for such classes will be more evident in [*Chapter 13*](B21071_13.xhtml#_idTextAnchor187)
    and [*Chapter 14*](B21071_14.xhtml#_idTextAnchor199), but we will still write
    a basic, simplified version here to make the side-by-side evolution of our container
    types clearer in the pages and chapters to come.'
  prefs: []
  type: TYPE_NORMAL
- en: A forward list is an exercise in leanness. We want the type to be small and
    do what it does well. Some forward lists occupy the size of a single pointer in
    memory (a pointer to the first node in the sequence); in our implementation, we
    will pay the price for an additional integer (the number of elements) in order
    to get a constant-time complexity guarantee for the `size()` member function.
  prefs: []
  type: TYPE_NORMAL
- en: Representational choices for a node-based container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our implementation, `ForwardList<T>` will hold nodes, and each node will
    hold a pair made of a value (of type `T`) and a pointer to the next node in the
    sequence. The last node will have a null pointer as the `next` node.
  prefs: []
  type: TYPE_NORMAL
- en: The representation of a `ForwardList<T>` object will thus be a `Node*` and an
    unsigned integral (for the number of elements in the list). Our implementation
    will be very simple and will show a small set of member functions. Feel free to
    enrich it as you want, as long as you limit yourself to functions that can be
    written efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of ForwardList<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we did for `Vector<T>`, we will walk through our initial (naïve) `ForwardList<T>`
    implementation in steps. Our initial step consists of defining our abstractions
    through standard library-conforming type aliases and choosing our internal representation,
    as is usually the case with containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, a`ForwardList<T>::Node` object will hold a value and
    a pointer to the next node in the sequence. Initially, the next node will always
    be a null pointer; it is the list’s responsibility to organize nodes, the nodes
    themselves being responsible for the ownership of the values stored therein:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The default state of a `ForwardList<T>` object will be equivalent to that of
    an empty list (a null pointer for `head` and no elements). That’s a reasonable
    default for most containers as an empty container is usually what users expect
    in practice when asking for a default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `size()` and `empty()` member functions are both trivial to write. I expressed
    `empty()` in terms of a null head rather than as a zero `size()` since in some
    (reasonable) forward list implementations, the size would be computed, not stored,
    which would make `size()` a linear complexity operation instead of a constant-time
    one. In practice, exposing a constant-time `size()` member function is a good
    idea as it matches most users’ expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Iterators on a linked list cannot be raw pointers, as the elements it stores
    are not contiguous in memory. We need a class whose instances can iterate over
    elements of the list, and that can take into account the `const`-ness of the elements
    (or lack thereof).
  prefs: []
  type: TYPE_NORMAL
- en: Our (private) `ForwardList<T>::Iterator` class will be a template on some type,
    `U`, where (in practice) `U` will be `T` for `ForwardList<T>::iterator` and `const
    T` for `ForwardList<T>::const_iterator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard iterators in C++ are expected to provide five aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value_type`: The type of the pointed-to value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reference`: The type that represents a reference to a pointed-to value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pointer`: The type that represents a pointer to a pointed-to value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`difference_type`: The type that represents the distance between two iterators
    of this type (a signed integral).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iterator_category`: There are six categories as of C++20, and they guide the
    code generation by describing what an iterator can do. In our case, since we will
    provide `++` but not `--`, we will describe our iterators as being part of `forward_iterator_category`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An iterator is an object that describes how we can traverse a sequence of values,
    and `ForwardList<T>::Iterator` is no exception. The key operations exposed by
    an iterator are probably `operator++()` (advance one position in the sequence),
    `operator!=()` (compare two iterators to know whether we have attained the end
    of a sequence), as well as `operator*()` and `operator->()` (accessing the pointed-to
    element or its services). Note that we make `ForwardList<T>` our friend as that
    class will be responsible for the organization of nodes, which is easier done
    when you have full access privileges to private data members such as `cur`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding proposed implementation uses a template based on the type, `U`,
    of the elements that an `Iterator<U>` can traverse. We used `U` instead of `T`
    as `T` is the type of the values in a `ForwardList<T>` object. In `ForwardList<T>`,
    we then make aliases for types `Iterator<T>` and `Iterator<const T>` through `iterator`
    and `const_iterator`, respectively. We could also have written two distinct types
    had we preferred that approach, but a template seemed less verbose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `begin()` and `end()` set of member functions are essentially trivial;
    `begin()` yields an iterator to the head of the list, and the conceptual just-after-the-end
    node returned by `end()` is a null pointer, which is what the default constructor
    of our `Iterator<U>` gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will sometimes need to `clear()` a `ForwardList<T>` object, which will lead
    us to destroy that container’s content. In this implementation, for simplicity,
    I made the destructor call the `clear()` member function, but we could have spared
    a tiny bit of processing time (the reinitialization of `nelems`, not needed in
    the destructor) by writing the destructor separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing that might seem tempting would be to write a `Node` destructor that
    applies `delete` to its `next` data member; if we did so, `clear()` would simply
    be `delete head;` (which would call `delete head->next` and continue from that
    point on, recursively) followed by `nelems=0;`. However, I would not do that if
    I were you: on principle, the `ForwardList<T>` object should organize the nodes
    in a `ForwardList<T>`, and this responsibility should not be given to the numerous
    `Node` objects themselves. Then, there is a small technical problem: calling `delete
    head;` would call `delete head->next;`, which would then technically call `delete`
    on `head-> next-> next;` and so on. This leads to a very concrete risk of stack
    overflow if the list is long enough, something that a loop would avoid altogether.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a simple lesson here: life is easier when each class has a single
    responsibility. This is something that’s been known for a while as the “single
    responsibility principle”. That principle is the ‘S’ in the well-known SOLID principles
    of object-oriented programming. Let the container deal with the organization of
    nodes in a node-based container and let the nodes store values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as constructors go, we will implement a small set for this class:'
  prefs: []
  type: TYPE_NORMAL
- en: A default constructor that models an empty list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor that accepts a `std::initializer_list<T>` as argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A copy constructor that duplicates each node from the source list in order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A move constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A sequence constructor that accepts two objects of some type, `It`, that satisfies
    the `std::input_iterator` concept (essentially: that lets you make at least a
    single pass through the sequence and consume the elements, which is all we need
    to do the job)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It happens that this last constructor can be seen as a generalization of some
    of the others, and that only the default constructor and the move constructor
    really benefit from being written separately (we could technically compute the
    size of the sequence more efficiently if we did not delegate the work to a general
    constructor, so if this makes a difference in your code base, feel free to do
    so):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Unsurprisingly, assignment can be expressed through the safe assignment idiom
    that we applied in the case of type `Vector<T>` earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the remaining operations can reasonably be said to be trivial, for
    example, `front()`, `operator==()`, and `push_front()`. As you could reasonably
    assume for a forward list, we will implement neither a `back()` nor a `push_back()`
    member function as there would not be an efficient way to do so with our representational
    choices (the only reasonable algorithm would require looping through the whole
    construct in order to find the last node, leading to a linear complexity algorithm):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example of value insertion into a container, consider the following `insert_after()`
    member function, which inserts a node with a value of `value` after the node pointed
    to by `pos`. With this function, we could easily build more complex ones, such
    as one that inserts a sequence of values after some position in the list (try
    it!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Offering the possibility of adding elements to a container is a useful feature
    indeed, and so is offering the option of removing an element from a container.
    As an example, see the following `erase_after()` member function implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: That should do the job for this class. For the rest of this chapter, there will
    be little room for improvement for `ForwardList<T>`, but we will return to this
    class in [*Chapter 13*](B21071_13.xhtml#_idTextAnchor187), and more so in [*Chapter
    14*](B21071_14.xhtml#_idTextAnchor199).
  prefs: []
  type: TYPE_NORMAL
- en: For `Vector<T>`, however, we can do significantly better than we have so far…
    at the cost of some added complexity. But we are ready for this, are we not?
  prefs: []
  type: TYPE_NORMAL
- en: Better memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, this humble writer claims our nice but simple `Vector<T>` type is no match
    for `std::vector<T>`. That may seem like a bold claim: after all, we seemed to
    do what was needed and, no less, we used algorithms instead of raw loops; we caught
    exceptions as we wanted to be exception-safe but limited ourselves to cleaning
    up the resources… What are we doing wrong?'
  prefs: []
  type: TYPE_NORMAL
- en: If you run comparative benchmarks between a `Vector<int>` object and a `std::vector<int>`
    object, in fact, you will probably not notice much of a difference in the respective
    numbers of both tests. For example, try adding a million `int` objects (through
    `push_back()`) to each of these containers and you will think our container holds
    its own quite well. Cool! Now, change that to a comparative test between `Vector<std::string>`
    and `std::vector<std::string>` and you might be saddened a bit, seeing that we’re
    “left behind in the dust,” as they say.
  prefs: []
  type: TYPE_NORMAL
- en: A word about the small object optimization
  prefs: []
  type: TYPE_NORMAL
- en: This will show more if you add strings that are not too short (try at least
    25 characters, say) as with “short” strings (for some indeterminate value of “short”)
    most standard libraries will perform what is called the **Small String Optimization**
    (**SSO**), a special case of the **Small Object Optimization** (**SOO**). Through
    this optimization, when the data to store in an object is small enough, the implementation
    will use the storage for the so-called “control block” (the data members, really)
    of the object as raw storage, avoiding dynamic memory allocation altogether. Because
    of this, “small” strings do not allocate and are very, very fast in practice.
  prefs: []
  type: TYPE_NORMAL
- en: But why?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a clue in the type of element in both tests: `int` is a trivially
    constructible type, and `std::string` is not. This clue is an indication that
    `std::vector` might be calling fewer constructors than we are, essentially being
    more efficient than `Vector<T>` in the way it handles memory and the objects therein.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s the problem? Well, let’s look at one of the constructors of `Vector<T>`
    to get an appreciation of the problem with our implementation. Any constructor
    but the default constructor (defaulted in our implementation) and the move constructor
    would do, so let’s take the one that accepts a number of elements and an initial
    value as arguments. Pay special attention to the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The construction of the `elems` data member allocates a block of memory big
    enough to hold `n` objects of type `T` and calls the default constructor for each
    of these `n` elements. Obviously, if `T` is trivially constructible, then these
    default constructors are not a big source of worries, but you could question the
    virtue of so doing if `T` is not trivially constructible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, you might want to argue that the objects need to be constructed, but
    then look ahead and you will notice that `std::fill()` replaces each of these
    default `T` objects with a copy of `init`, showing that the initial default construction
    of the objects was essentially a waste of time (we never used these objects!).
    This is the sort of thing that `std::vector<T>` does so much better than we do:
    it avoids wasteful operations, restricting itself to what is necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: We will now try to see how we could get closer in performance to what `std::vector<T>`
    achieves in practice.
  prefs: []
  type: TYPE_NORMAL
- en: A more efficient Vector<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key to a more efficient `Vector<T>` is distinguishing allocation from construction,
    something we have discussed many times in this book, and, well, lying to the type
    system in adequate ways and in a controlled environment. Yes, those “evil” early
    chapters of this book will come in handy now.
  prefs: []
  type: TYPE_NORMAL
- en: We will not rewrite the entirety of `Vector<T>` in these pages, but we will
    look at selected member functions to highlight what needs to be done (a full implementation
    is available in the GitHub repository mentioned at the beginning of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'We could try to do this effort manually, using the language facilities we already
    know about, such as `std::malloc()`, to allocate a raw memory block and placement
    `new` to construct the objects in that block. Taking the same constructor that
    takes a number of elements and an initial value as arguments, we would then get
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that’s… unpleasant. Pay attention to the sections marked with are **A**
    to **D** in this function:'
  prefs: []
  type: TYPE_NORMAL
- en: In `n` objects of type `T` but limit ourselves to raw memory allocation (the
    constructor of no `T` object is being called at this point), yet we keep a `T*`
    to that block of memory for our own purposes. Our implementation needs to be aware,
    internally, that the type of the `elems` pointer is incorrect at this stage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `begin()` knowing that `iterator` is the same thing as `T*` in our implementation.
    If our implementation used a class instead of a raw pointer to model an iterator,
    we would have to do some work here to get the underlying pointer to the raw storage
    in order to implement the rest of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `T` objects in place within the block of memory we allocated. Since there
    are no objects there to replace, we construct these objects with the placement
    `new`, and use the fact that we lied to the type system (in the sense that we
    used a `T*` even though we allocated raw memory) to do the pointer arithmetic
    required to move from one object to another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `T` objects. Since we are the only ones who know that there are `T` objects
    therein, just as we are the only ones who know exactly where the first object
    that we failed to construct is, we need to destroy the objects manually, then
    free the (now raw) memory block and re-throw the exception. As a bonus, this implementation
    is not even standards-compliant; we should destroy the objects in reverse order
    of construction, something this example does not do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the way, this example shows a clear example of the reasons why you cannot
    throw from a destructor: if an exception is thrown during **D**, we cannot reasonably
    hope to recover (at least not without incurring prohibitive costs).'
  prefs: []
  type: TYPE_NORMAL
- en: You, dear reader, are probably thinking right now that this is unreasonably
    complicated and way too error-prone for non-specialists to hope to be able to
    write a whole container that way. Indeed, this sort of complexity would creep
    into a significant number of member functions, making quality control much more
    difficult than you would hope.
  prefs: []
  type: TYPE_NORMAL
- en: But wait, there is hope! As you might imagine, your library vendors face the
    same challenges we do (and more!), so the standard library provides low-level
    facilities that make handling raw memory in homemade containers a reasonably achievable
    task as long as you know, well, what you have read in this book so far.
  prefs: []
  type: TYPE_NORMAL
- en: Using low-level standard facilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `<memory>` standard library header is a treasure trove of useful facilities
    for those who dabble in memory management. We have already discussed the standard
    smart pointers defined in that header (see [*Chapter 5*](B21071_05.xhtml#_idTextAnchor079)
    for a reminder), but if you look a bit deeper, you will see some algorithms made
    to operate on raw memory.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping as an example the `Vector<T>` constructor that takes a number of elements
    and an initial value as argument, we went from something rather simple that allocates
    an array of `T` objects and replaces them through a call to `std::fill()` to something
    significantly more complicated. The original version was both simple and inefficient
    (we constructed unneeded objects just to replace them); the replacement was much
    more efficient (doing minimal work) but required much more skill to write and
    maintain.
  prefs: []
  type: TYPE_NORMAL
- en: We will now examine the impact of these facilities on the implementation of
    our allocating member functions. The first such functions we will pay attention
    to are the constructors, as they make a nice starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Impact on constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In practice, when you want to write a homemade container that manages memory
    explicitly, it’s better to use the low-level facilities found in `<memory>`. Take
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is much nicer than the version we entirely wrote ourselves, is it not?
    The two highlights of this version are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We allocate a properly sized block of raw memory instead of an array of `T`
    objects, thus avoiding all of the unneeded default constructors the initial version
    had.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We replaced the call to `std::fill()` (found in `<algorithm>`), which uses `T::operator=(const
    T&)` and thus supposes an existing object to the left side of the assignment with
    a call to `std::uninitialized_fill()`, which instead supposes that it is iterating
    through raw memory and initializes the objects through the placement `new`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The beauty of this algorithm (and others of this family) is that it is exception-safe.
    If one of the constructors invoked by `std::uninitialized_fill()` ends up throwing,
    then the objects it had managed to create before the exception occurred will be
    destroyed (in reverse order of construction, as they should) before the exception
    leaves the function.
  prefs: []
  type: TYPE_NORMAL
- en: It’s what we had written (clumsily) by hand, really. Apart from the fact that
    we now allocate and free raw memory, the rest of the code is very similar to the
    original, simple version. This probably makes you feel much better… and it should.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar approach can be taken with other constructors. Take, for example,
    the copy constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, with the proper algorithms, the fast implementations that work
    on raw memory are very similar to the naïve and slower versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key point here is to understand the boundaries of the API. A function such
    as `std::uninitialized_copy()` takes three arguments: the beginning and end of
    a source sequence (this sequence is presumed to contain objects) and the beginning
    of the destination sequence (this sequence is presumed to be appropriately aligned
    and made of raw memory, not objects). If the function concludes its execution
    because it met its postconditions and constructed the objects in the destination
    sequence, then that destination sequence contains objects. On the other hand,
    if the function fails to meet its postconditions, then there are no objects in
    the destination sequence as whatever the function has constructed, it will also
    have destructed.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar maneuvers can be done with other constructors, keeping in mind that
    the default constructor and the move constructor are implemented very differently
    and as such deserve a different treatment.
  prefs: []
  type: TYPE_NORMAL
- en: Impact on the destructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The destructor in this implementation of `Vector<T>` is interesting: when the
    object reaches the end of its lifetime, we cannot simply call `delete[]` on the
    `elems` data member as it has not been allocated by `new[]` in the first place
    and it is made of a sequence of `T` objects, potentially followed by a sequence
    of raw bytes. We would not want to call `T::~T()` on an arbitrary sequence of
    bytes since this could cause quite a lot of damage in our program and incur **UB**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only entity that knows how many objects there are in the container is the
    `Vector<T>` object itself, which means that it will need to `destroy()` the remaining
    objects, and only then `free()` the (now devoid of objects) memory block that
    remains. Applying the `std::destroy()` algorithm on a sequence of `T` objects
    calls `T::~T()` on each of them, turning a sequence of objects into raw memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: These low-level memory management algorithms really help in clarifying the intent
    of the code we write, as you can see.
  prefs: []
  type: TYPE_NORMAL
- en: Impact on per-element insertion functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A similar situation happens in member functions `push_back()` and `emplace_back()`
    where we used to replace through an assignment some existing object at the end
    of our array; we now need to construct an object at the end of the array since
    there is no object there anymore (we do not construct objects needlessly; that’s
    the point of our efforts!).
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use placement `new` to do this, obviously, but the standard library
    offers a moral equivalent named `std::construct_at()`. This makes our intent even
    clearer from the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Impact on growth functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `grow()` function we had implemented initially called `resize()` on our
    `Vector<T>`, but `resize()` is meant to initialize the storage with objects. To
    make the allocated storage grow in size without initializing it with objects,
    we need a different member function, namely `reserve()`.
  prefs: []
  type: TYPE_NORMAL
- en: On the differences between resize() and reserve()
  prefs: []
  type: TYPE_NORMAL
- en: Expressed simply, `resize()` potentially adds objects to the container, and
    as such it can modify both `size()` and `capacity()`. On the other hand, `reserve()`
    adds no object to the container, limiting itself to potentially increasing the
    storage space being used by the container; in other words, `reserve()` can change
    `capacity()` but will not change `size()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the example set by `std::vector<T>`, our `Vector<T>` class will offer
    both `resize()` and `reserve()`. A version of `resize()` adapted to the new reality
    of our part-objects, part-raw-memory container follows, accompanied by an implementation
    of `reserve()` that suits `Vector<T>`. We will discuss `reserve()` and `resize()`
    separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reserve()` member function first ensures that the requested new capacity
    is higher than the existing one (otherwise there’s nothing to do). If that is
    so, it allocates a new memory block and either moves or copies the existing elements
    of the `Vector<T>` object into that new memory (a copy will be made if moving
    `T` objects can throw: it pays to make move operations `noexcept`, dear readers!)
    using algorithms that construct objects into raw memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `T` objects left in `elems` are then destroyed (even if they have been
    moved-from: they still need to be finalized), and we ensure that `cap` is updated
    and `elems` points to the new block of storage. Of course, `size()` does not change
    as no new object has been added to the container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The procedure is similar for `resize()` (as follows), except that the locations
    in the memory block starting at the `size()` index are initialized with a default
    `T` instead of being left in their raw memory state. Consequently, `size()` is
    updated, leading to different semantics from those obtained following a call to
    `reserve()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This more sophisticated structure we are implementing will obviously have an
    impact on the way we `insert()` or `erase()` elements.
  prefs: []
  type: TYPE_NORMAL
- en: Impact on element insertion and erasure functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As expected, member functions such as `insert()` and `erase()` have to be updated
    to take into account the changes we have made to the internal organization of
    `Vector<T>` objects. That does not have to be painful (and, indeed, required changes,
    if any, can be tiny) as long as the semantics of every function are clear from
    the onset, but it does require care.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, using `insert(pos,first,last)` as an example, we are moving from
    the simple model described in *Figure 12**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Example of the naïve Vector<T> insertion model](img/B21071_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Example of the naïve Vector<T> insertion model
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, inserting a `[first,last)` sequence at position `pos` means copying (in
    reverse order) the elements in `[pos,end())` at position `pos + n`, then overwriting
    the elements of `[pos,pos+n)` with `[first,last)` to the more complex model described
    in *Figure 12**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Example of the current Vector<T> insertion model](img/B21071_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Example of the current Vector<T> insertion model
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that we need to insert `[first,last)` at position `pos`, which means
    that the elements in `[pos,pos+n)` have to be copied (or moved) to the right.
    This will require constructing some objects in raw memory (the gray area in the
    preceding figure) and replacing some other objects through copy (or move) assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four steps to consider here:'
  prefs: []
  type: TYPE_NORMAL
- en: How many elements should be copied or moved from the `[begin(),end())` sequence
    to the raw memory block at the end of the container, and where in that block should
    the resulting objects be constructed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are elements from the `[first,last)` sequence to insert in raw memory
    (there could be none), how many should there be? If there are any such objects,
    they will be inserted at `end()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are elements to copy or move from the `[pos,end())` sequence to copy
    or move as a replacement to existing objects in the container (there could be
    none), how many should there be? The end of the destination range will be `end()`
    in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, whatever remains to be inserted from the `[first,last)` sequence will
    be copied in the container starting at `pos`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A possible implementation would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you do not move the elements in `[first,last)`, however: that would
    be user-hostile as it would potentially destroy the data in the source range!'
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the `erase()` member function that we had written in a more naïve manner
    initially, the key adjustment we will need to make is in the way we handle the
    removed element: you might remember that in our naïve version, we assigned a default
    `T` to the erased element at the end of the container, and complained that this
    added the suspicious requirement of a default constructor in type `T`. In this
    version, we will quite simply destroy this object, ending its lifetime and turning
    its underlying storage back into raw memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, this gives you, dear reader, a better idea of what it takes to write
    a more serious implementation of a homemade `std::vector`-like type and a better
    appreciation for the craftsmanship of the individuals behind your favorite standard
    library provider. Know that they do all this and more for your programs to be
    the wonderfully efficient things they are!
  prefs: []
  type: TYPE_NORMAL
- en: Const or reference members and std::launder()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we conclude this chapter, we need to say a few words on those oddities
    that are containers that hold objects of `const` types, as well as on containers
    whose elements are of a type with `const` or reference members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this seemingly innocuous program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: With the implementation we have, this will refuse to compile as our implementation
    calls a number of low-level functions (`std::free()`, `std::destroy_at()`, `std::construct_at()`,
    and so on) that take a pointer to a non-`const` type as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: If we are to support such a program, it means we will have to “cast away” `const`-ness
    in some places in our implementation. For example, replacing the following line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '#include <type_traits>'
  prefs: []
  type: TYPE_NORMAL
- en: template <class T>
  prefs: []
  type: TYPE_NORMAL
- en: struct X {
  prefs: []
  type: TYPE_NORMAL
- en: static_assert(std::is_trivially_destructible_v<T>);
  prefs: []
  type: TYPE_NORMAL
- en: T &r;
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: 'X(T &r) : r{ r } {'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: T& value() { return r; }
  prefs: []
  type: TYPE_NORMAL
- en: const T & value() const { return r; }
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: // ...
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iostream>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <new>'
  prefs: []
  type: TYPE_NORMAL
- en: int main() {
  prefs: []
  type: TYPE_NORMAL
- en: int n = 3;
  prefs: []
  type: TYPE_NORMAL
- en: X<int> h{ n };
  prefs: []
  type: TYPE_NORMAL
- en: h.value()++;
  prefs: []
  type: TYPE_NORMAL
- en: std::cout << n << '\n'; // 4
  prefs: []
  type: TYPE_NORMAL
- en: std::cout << h.value() << '\n'; // 4
  prefs: []
  type: TYPE_NORMAL
- en: int m = -3;
  prefs: []
  type: TYPE_NORMAL
- en: // h = X<int>{ m }; // nope
  prefs: []
  type: TYPE_NORMAL
- en: X<int> *p = new (static_cast<void*>(&h)) X<int>{ m };
  prefs: []
  type: TYPE_NORMAL
- en: std::cout << p->value() << '\n'; // -3
  prefs: []
  type: TYPE_NORMAL
- en: // UB (-3? 4? something else?)
  prefs: []
  type: TYPE_NORMAL
- en: std::cout << h.value() << '\n';
  prefs: []
  type: TYPE_NORMAL
- en: std::cout << std::launder(&h)->value() << '\n'; // -3
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
