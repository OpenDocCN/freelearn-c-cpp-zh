<html><head></head><body>
        

                            
                    <h1 class="header-title">Communication Between Classes and Interfaces: Part II</h1>
                
            
            
                
<p>The following recipes will be covered in this chapter:</p>
<ul>
<li>Exposing UInterface methods to Blueprint from a native base class</li>
<li>Implementing UInterface functions in Blueprint</li>
<li>Creating C++ UInterface function implementations that can be overridden in Blueprint</li>
<li>Calling Blueprint-defined interface functions from C++</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>This chapter will show you ways in which you can use your C++ UInterfaces through Blueprints. This can be very helpful in letting designers access code that you've written without requiring them to dive into the C++ code of the project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017 as the IDE. Instructions on how to install both pieces of software and the requirements for them can be found in <a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml">Chapter 1</a>, <em>UE4 Development Tools</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exposing UInterface methods to Blueprint from a native base class</h1>
                
            
            
                
<p>Being able to define <kbd>UInterface</kbd> methods in C++ is great, but they should be accessible from Blueprint too. Otherwise, designers or others who are using Blueprint won't be able to interact with your <kbd>UInterface</kbd>. This recipe shows you how to make a function from an interface callable within the Blueprint system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a <kbd>UInterface</kbd> called <kbd>PostBeginPlay</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/7539c4d4-019e-4c79-87e9-1b34d814759e.png"/></p>
<ol start="2">
<li>Open <kbd>PostBeginPlay.h</kbd> in Visual Studio and update the <kbd>UINTERFACE</kbd> of <kbd>UPostBeginPlay</kbd> and add the following <kbd>virtual</kbd> method in <kbd>IPostBeginPlay</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "UObject/Interface.h"<br/>#include "PostBeginPlay.generated.h"<br/><br/><strong>UINTERFACE(meta = (CannotImplementInterfaceInBlueprint))</strong><br/>class UPostBeginPlay : public UInterface<br/>{<br/>    GENERATED_BODY()<br/>};<br/><br/>/**<br/> * <br/> */<br/>class CHAPTER_08_API IPostBeginPlay<br/>{<br/>    GENERATED_BODY()<br/><br/>    // Add interface functions to this class. This is the<br/>    // class that will be inherited to implement<br/>    // this interface.<br/>public:<br/><strong>    UFUNCTION(BlueprintCallable, Category = Test)</strong><br/><strong>    virtual void OnPostBeginPlay();</strong><br/>};</pre>
<ol start="3">
<li>Provide an implementation of the function:</li>
</ol>
<pre style="padding-left: 60px">#include "PostBeginPlay.h"<br/><br/>// Add default functionality here for any IPostBeginPlay <br/>// functions that are not pure virtual.<br/><strong>void IPostBeginPlay::OnPostBeginPlay()</strong><br/><strong>{</strong><br/><strong>    GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, "PostBeginPlay called");</strong><br/><strong>}</strong></pre>
<ol start="4">
<li>Create a new <kbd>Actor</kbd> class called <kbd>APostBeginPlayTest</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/c6f5e0ca-46ef-4aa6-8dfc-742573723f0a.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="5">
<li>Modify the class declaration so that it also inherits <kbd>IPostBeginPlay</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "PostBeginPlay.h"</strong><br/>#include "PostBeginPlayTest.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_08_API APostBeginPlayTest : public AActor<strong>, public IPostBeginPlay</strong></pre>
<ol start="6">
<li>Compile your project. Inside the editor, drag an instance of <kbd>APostBeginPlayTest</kbd> into your level:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/b3bef66c-220a-4c6a-aafe-cb29f2950e87.png"/></p>
<ol start="7">
<li>With the instance selected in the World Outliner, click on Blueprints | Open Level Blueprint:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ad526052-f410-46fe-b6e9-99a44dc869d4.jpg" style="width:28.58em;height:26.00em;"/></p>
<ol start="8">
<li>Inside the Level Blueprint, right-click and Create a Reference to PostBeginPlayTest1:</li>
</ol>
<div><img src="img/5f52943e-720b-45de-b7ce-a9aa47bb3a46.png" style="width:37.75em;height:14.33em;"/></div>
<p>Note that you can also use the drag-and-drop method we discussed in the <em>Inheriting UInterfaces from one another</em> recipe from the previous chapter.</p>
<ol start="9">
<li>Drag away from the blue pin on the right-hand side of your actor reference, then search the context menu for <kbd>onpost</kbd> to see your new interface function. Click on it to insert a call to your native <kbd>UInterface</kbd> implementation from Blueprint:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0a4d5096-348e-4d01-9996-1c1b4738061a.png"/></p>
<ol start="10">
<li>Finally, connect the execution pin (white arrow) from the <kbd>BeginPlay</kbd> node to the execution pin for <kbd>OnPostBeginPlay</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/cd60e61c-cce6-4569-9985-af0696055fac.png"/></p>
<ol start="11">
<li>When you play your level, you should see the message PostBeginPlay called visible on screen for a short amount of time, verifying that Blueprint has successfully accessed and called through to your native code implementation of the <kbd>UInterface</kbd>.</li>
</ol>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>UINTERFACE</kbd>/<kbd>IInterface</kbd> pair function like they do in other recipes, with the <kbd>UInterface</kbd> containing reflection information and other data and the <kbd>IInterface</kbd> functioning as the actual interface class that can be inherited from.</p>
<p>The most significant element that allows the function inside <kbd>IInterface</kbd> to be exposed to Blueprint is the <kbd>UFUNCTION</kbd> specifier. <kbd>BlueprintCallable</kbd> marks this function as one that can be called from the Blueprint system.</p>
<p>Any functions exposed to Blueprint in any way require a <kbd>Category</kbd> value. This <kbd>Category</kbd> value specifies the heading under which the function will be listed in the context menu.</p>
<p>The function must also be marked <kbd>virtual</kbd> – this is so that a class that implements the interface via native code can override the implementations of the functions inside it. Without the <kbd>virtual</kbd> specifier, the Unreal Header Tool will give you an error, indicating that you have to either add <kbd>virtual</kbd> or <kbd>BlueprintImplementableEvent</kbd> as a <kbd>UFUNCTION</kbd> specifier.</p>
<p>The reason for this is that without either of those, the interface function wouldn't be overridable in C++ (due to the absence of <kbd>virtual</kbd>) or Blueprint (because <kbd>BlueprintImplementableEvent</kbd> was missing). An interface that can't be overridden, but only inherited, has limited utility, so Epic have chosen not to support it within UInterfaces.</p>
<p>We then provide a default implementation of the <kbd>OnPostBeginPlay</kbd> function, which uses the <kbd>GEngine</kbd> pointer to display a debug message, confirming that the function was invoked.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Refer to <a href="bded5c5b-3038-4d12-b03d-39218257492b.xhtml">Chapter 8</a>, <em>Communication Between Classes and Interfaces: Part II</em><em>,</em> for a number of recipes that show you how you can integrate your C++ classes with Blueprint</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing UInterface functions in Blueprint</h1>
                
            
            
                
<p>One of the key advantages of UInterface in Unreal is the ability for users to implement <kbd>UInterface</kbd> functions in the editor. This means that the interface can be implemented strictly in Blueprint without needing any C++ code, which is helpful to designers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new <kbd>UInterface</kbd> called <kbd>AttackAvoider</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/91241cc3-1b98-40c3-8d23-054321e24a96.png"/></p>
<ol start="2">
<li>Add the following function declaration to the header:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "UObject/Interface.h"<br/>#include "AttackAvoider.generated.h"<br/><br/>// This class does not need to be modified.<br/>UINTERFACE(MinimalAPI)<br/>class UAttackAvoider : public UInterface<br/>{<br/>  GENERATED_BODY()<br/>};<br/><br/>class CHAPTER_08_API IAttackAvoider<br/>{<br/>  GENERATED_BODY()<br/><br/>  // Add interface functions to this class. This is the class<br/>  // that will be inherited to implement this interface.<br/>public:<br/>    <strong>UFUNCTION(BlueprintImplementableEvent, BlueprintCallable, <br/> Category = AttackAvoider)</strong><br/><strong> void AttackIncoming(AActor* AttackActor);</strong><br/>};</pre>
<ol start="3">
<li>Compile your project. From the Content Browser, open the Content folder and then create a new Blueprint Class within the Editor by selecting Add New | Blueprint Class:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/9cf44734-02d1-4ebb-87e0-f1aa7cbc45f5.jpg" style="width:19.17em;height:33.67em;"/></p>
<ol start="4">
<li>Base the class on Actor:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/be3e694c-bcd6-4215-b045-1c160d2f7596.png"/></p>
<ol start="5">
<li>Name the blueprint <kbd>AvoiderBlueprint</kbd> and then double-click on it to open the Blueprint Editor. From there, open Class Settings:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/7b83d5a4-c153-433a-826b-a72e0d29a0b2.png"/></p>
<ol start="6">
<li>Under the Details tab, click on the drop-down menu that says Add for Implemented Interfaces, and select AttackAvoider:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/5019f64b-074e-4432-b9f3-f48a1b693772.jpg" style="width:37.83em;height:23.25em;"/></p>
<ol start="7">
<li>Compile your Blueprint:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/8b5c7a09-df49-4876-af79-e9c5ff4b4c9f.jpg" style="width:11.75em;height:11.75em;"/></p>
<ol start="8">
<li>Open the Event Graph by clicking on the Event Graph tab and then right-click within the graph and type <kbd>event attack</kbd>. Within the Context Sensitive menu, you should see Event Attack Incoming. Select it to place an event node in your graph:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/b80d7c45-4c16-4648-b626-9e234aff316f.jpg" style="width:31.00em;height:11.17em;"/></p>
<ol start="9">
<li>Drag this out from the execution pin on the new node and release. Type <kbd>print string</kbd> into the Context Sensitive menu to add a Print String node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6e86e174-4833-4ccc-aab1-d344fdb4f6c8.png"/></p>
<p>Selecting the Print String node</p>
<p style="padding-left: 60px">You have now implemented a <kbd>UInterface</kbd> function within Blueprint.</p>
<ol start="10">
<li>To see the event in action, drag the pin to the right of the Event BeginPlay event and call an Attack Incoming event:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/2a10d7b5-eb26-4f02-970a-af9a5d675ec0.png"/></p>
<ol start="11">
<li>Drag and drop an instance of your Blueprint class into the level and play the game:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/8621e029-18b4-4ca3-a875-bccd083bc7d9.png" style="width:34.58em;height:23.00em;"/></p>
<p>If all went well, you should see the default message from Print String, or whatever you posted to happen when the event should happen!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>UINTERFACE</kbd>/<kbd>IInterface</kbd> are created in exactly the same way that we saw in the other recipes in this chapter. When we add a function to the interface, however, we use a new <kbd>UFUNCTION</kbd> specifier, <kbd>BlueprintImplementableEvent</kbd>.</p>
<p><kbd>BlueprintImplementableEvent</kbd> tells the Unreal Header Tool to generate code that creates an empty stub function that can be implemented by Blueprint. We do not need to provide a default C++ implementation for the function.</p>
<p>We implement the interface inside Blueprint, which exposes the function for us in a way that allows us to define its implementation in Blueprint. The autogenerated code that's created by the header tool forwards the calls to the <kbd>UInterface</kbd> function to our Blueprint implementation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>The <em>Overriding C++ UInterface functions through Blueprints</em> recipe shows you how to define a default implementation for your <kbd>UInterface</kbd> function in C++, then optionally override it in Blueprint if necessary.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Overriding C++ UInterface functions through Blueprints </h1>
                
            
            
                
<p>Just like the previous recipe, UInterfaces are useful, but that utility is severely limited without their functionality being usable by designers.</p>
<p>The previous recipe, <em>Exposing UInterface methods to Blueprints from a native base class</em>, showed you how to call C++ <kbd>UInterface</kbd> functions from Blueprint; this recipe will show you how to replace the implementation of a <kbd>UInterface</kbd> function with your own custom Blueprint-only function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new interface called <kbd>Wearable</kbd> ( Creating both <kbd>IWearable</kbd> &amp;  <kbd>UWearable</kbd>):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/5c357868-84cf-4094-9a7a-f75ac5064c56.png"/></p>
<ol start="2">
<li>Add the following functions to the header of the <kbd>IWearable</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">class CHAPTER_08_API IWearable<br/>{<br/>    GENERATED_BODY()<br/><br/>    // Add interface functions to this class. This is the<br/>    // class that will be inherited to implement<br/>    // this interface.<br/>public:<br/><strong>    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, </strong><br/><strong>              Category = Wearable)</strong><br/><strong>    int32 GetStrengthRequirement();</strong><br/><br/><strong>    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, </strong><br/><strong>              Category = Wearable)</strong><br/><strong>    bool CanEquip(APawn* Wearer);</strong><br/><br/><strong>    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, </strong><br/><strong>              Category = Wearable)</strong><br/><strong>    void OnEquip(APawn* Wearer);</strong><br/>};</pre>
<p style="padding-left: 60px">UE 4.20 and above does not allow us to create a default implementation for a function if it is defined in an interface class, so we will have to use UE's default empty implementation, which gives us the default value as a return for each function. This is because, in C# and other languages that have interfaces, they are not supposed to have a default implementation.</p>
<ol start="3">
<li>Create a new <kbd>Actor</kbd> class called <kbd>Boots</kbd> inside the editor:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/db097867-0667-461f-ac7a-17516d5381dc.png"/></p>
<ol start="4">
<li>Add <kbd>#include "Wearable.h"</kbd> to the header file for <kbd>Boots</kbd> and modify the class declaration, as follows:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "Wearable.h"</strong><br/>#include "Boots.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_08_API ABoots : public AActor<strong>, public IWearable</strong></pre>
<ol start="5">
<li>Add the following implementation of the pure <kbd>virtual</kbd> functions that were created by our Interface:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_08_API ABoots : public AActor, public IWearable<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public: <br/>    // Sets default values for this actor's properties<br/>    ABoots();<br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/><strong>    // Implementing the functions needed for IWearable</strong><br/><strong>    virtual void OnEquip_Implementation(APawn* Wearer) override</strong><br/><strong>    {</strong><br/><strong>        GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, <br/>                                         "Item being worn");</strong><br/><strong>    }<br/></strong><br/><strong>    virtual bool CanEquip_Implementation(APawn* Wearer) override</strong><br/><strong>    {</strong><br/><strong>        return true;</strong><br/><strong>    }<br/></strong><br/><strong>    virtual int32 GetStrengthRequirement_Implementation() override</strong><br/><strong>    {</strong><br/><strong>        return 0;</strong><br/><strong>    }</strong><br/><br/>};</pre>
<p style="padding-left: 60px">If you do not know how to do the following two steps, check out the previous recipe, <em>Implementing UInterface functions in Blueprint</em>.</p>
<ol start="6">
<li>Compile your script so that we will have access to the new functions we have created.</li>
<li>Create a new Blueprint class called <kbd>Gloves</kbd> based on <kbd>Actor</kbd> by going to the Content Browser, opening the <kbd>Content</kbd> folder, and then right clicking and then selecting Blueprint Class.</li>
</ol>
<ol start="8">
<li>In the Class Settings menu, under the Details tab, scroll down to the Implemented Interfaces property and click on the Add button and select <kbd>Wearable</kbd> as the interface that the <kbd>Gloves</kbd> actor will implement:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6e0652ae-bd66-450b-9bc7-859d6ff1eae0.png"/></p>
<p>Adding the Wearable interface</p>
<ol start="9">
<li>Afterwards, hit the Compile button in order to apply the change.</li>
</ol>
<ol start="10">
<li>Open the Event Graph and right-click it to create a new event. From the search bar, type in <kbd>on equip</kbd>, and you should see our event under the Add Event section:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/c02f936d-d293-45b9-97f2-60b24aa5a932.png"/></p>
<ol start="11">
<li>This allows us to override the <kbd>OnEquip</kbd> function from the default implementation to do whatever we want. For instance, add a Print String node with the In String being set to <kbd>Gloves being worn</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/aa9216fb-a775-41b3-854f-0bfdfdc6f958.png"/></p>
<ol start="12">
<li>Click on the Compile button and then you can close the Blueprint. Drag a copy of both <kbd>Gloves</kbd> and <kbd>Boots</kbd> into your level for testing purposes.</li>
</ol>
<ol start="13">
<li>Once added, add the following blueprint code to your level:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/7e5b7e41-6f9a-4a02-9065-c8fa4ed3e74f.png"/></p>
<ol start="14">
<li>Verify that <kbd>Boots</kbd> performs the default behavior, but that <kbd>Gloves</kbd> performs the blueprint-defined behavior:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/95bdce70-174c-418e-98fe-88231ed6b461.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>This recipe uses two <kbd>UFUNCTION</kbd> specifiers together: <kbd>BlueprintNativeEvent</kbd> and <kbd>BlueprintCallable</kbd>. <kbd>BlueprintCallable</kbd> has been shown in previous recipes, and is a way of marking your <kbd>UFUNCTION</kbd> as visible and invokable in the Blueprint Editor.</p>
<p><kbd>BlueprintNativeEvent</kbd> signifies a <kbd>UFUNCTION</kbd> that has a default C++ (native code) implementation, but is also overridable in Blueprint. It's a combination of a virtual function, along with <kbd>BlueprintImplementableEvent</kbd>.</p>
<p>For this mechanism to work, the Unreal Header Tool generates the body of your functions so that the Blueprint version of the function is called if it exists; otherwise, it dispatches the method call through to the native implementation.</p>
<p>The <kbd>Boots</kbd> class implements <kbd>IWearable</kbd>, overriding the default functionality. In contrast, <kbd>Gloves</kbd> also implements <kbd>IWearable</kbd>, but has an overridden implementation for <kbd>OnEquip</kbd> defined in Blueprint. This can be verified when we use Level Blueprints to call <kbd>OnEquip</kbd> for the two actors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Calling Blueprint-defined interface functions from C++</h1>
                
            
            
                
<p>While the previous recipes have focused on C++ being usable in Blueprint, such as being able to call functions from C++ in Blueprint, and override C++ functions with Blueprint, this recipe shows you the reverse: calling a Blueprint-defined interface function from C++.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new <kbd>UInterface</kbd> called <kbd>Talker</kbd>  (Creating the <kbd>UTalker</kbd>/<kbd>ITalker</kbd> classes):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/246f7357-2422-4d79-a871-d740fc5f04bf.png"/></p>
<ol start="2">
<li>Add the following <kbd>UFUNCTION</kbd> implementation:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "UObject/Interface.h"<br/>#include "Talker.generated.h"<br/><br/>// This class does not need to be modified.<br/>UINTERFACE(MinimalAPI)<br/>class UTalker : public UInterface<br/>{<br/>    GENERATED_BODY()<br/>};<br/><br/>/**<br/> * <br/> */<br/>class CHAPTER_08_API ITalker<br/>{<br/>    GENERATED_BODY()<br/><br/>    // Add interface functions to this class. This is the<br/>    // class that will be inherited to implement<br/>    // this interface.<br/>public:<br/><strong>    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = Talk)</strong><br/><strong>    void StartTalking();</strong><br/><br/>};</pre>
<ol start="3">
<li>Create a new C++ class based on <kbd>StaticMeshActor</kbd>. Remember to check Show All Classes and find the class that way:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d78ffdd9-291d-4c5e-900b-4afe7bb3b150.png"/>.</p>
<ol start="4">
<li>After clicking Next, name this new class <kbd>TalkingMesh</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/89e67a4a-0978-4258-ba9c-0ef649ac5c8f.png"/></p>
<ol start="5">
<li>Add <kbd>#include</kbd> and modify the class declaration to include the talker interface:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "Engine/StaticMeshActor.h"<br/><strong>#include "Talker.h"</strong><br/>#include "TalkingMesh.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_08_API ATalkingMesh : public AStaticMeshActor<strong>, public ITalker</strong></pre>
<ol start="6">
<li>Also, add the following functions to the class declaration:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_08_API ATalkingMesh : public AStaticMeshActor, public ITalker<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>public:</strong><br/><strong>    ATalkingMesh();</strong><br/><strong>    void StartTalking_Implementation();</strong><br/>};</pre>
<ol start="7">
<li>Within the implementation, add the following to <kbd>TalkingMesh.cpp</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#include "TalkingMesh.h"<br/><strong>#include "ConstructorHelpers.h"</strong><br/><br/><strong>ATalkingMesh::ATalkingMesh() : Super()</strong><br/><strong>{</strong><br/><strong>    auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;(TEXT("StaticMesh'/Engine/BasicShapes/Cube.Cube'"));</strong><br/><br/><strong>    UStaticMeshComponent * SM = GetStaticMeshComponent();</strong><br/><br/><strong>    if(SM != nullptr)</strong><br/><strong>    {</strong><br/><strong>        if (MeshAsset.Object != nullptr)</strong><br/><strong>        {</strong><br/><strong>            SM-&gt;SetStaticMesh(MeshAsset.Object);</strong><br/><strong>            SM-&gt;SetGenerateOverlapEvents(true);</strong><br/><strong>        }</strong><br/><br/><strong>        SM-&gt;SetMobility(EComponentMobility::Movable);</strong><br/><br/><strong>    }</strong><br/><strong>    </strong><br/><strong>    SetActorEnableCollision(true);</strong><br/><strong>}</strong><br/><br/><strong>void ATalkingMesh::StartTalking_Implementation()</strong><br/><strong>{</strong><br/><strong>    GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, </strong><br/><strong>                              TEXT("Hello there. What is your name?"));</strong><br/><strong>}</strong></pre>
<ol start="8">
<li>Create a new class based on <kbd>DefaultPawn</kbd> to function as our player character:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/7c9e20bd-ff72-4add-b845-251e8019f6d6.png"/></p>
<ol start="9">
<li>Once you select Next, give the class a Name of <kbd>TalkingPawn</kbd> and select Create Class:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/459b2a04-31ce-4d3b-8655-29fc0370b550.png"/></p>
<p class="mce-root"/>
<ol start="10">
<li>Add the following to our class header:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/DefaultPawn.h"<br/><strong>#include "Components/BoxComponent.h" // UBoxComponent</strong><br/>#include "TalkingPawn.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_08_API ATalkingPawn : public ADefaultPawn<br/>{<br/>  GENERATED_BODY()<br/>  <br/><strong>public:</strong><br/><strong>    // Sets default values for this character's properties</strong><br/><strong>    ATalkingPawn();</strong><br/><br/><strong>    UPROPERTY()</strong><br/><strong>    UBoxComponent* TalkCollider;</strong><br/><br/><strong>    UFUNCTION()</strong><br/><strong>    void OnTalkOverlap(UPrimitiveComponent* OverlappedComponent, </strong><br/><strong>                       AActor* OtherActor, </strong><br/><strong>                       UPrimitiveComponent* OtherComp, </strong><br/><strong>                       int32 OtherBodyIndex, bool bFromSweep, </strong><br/><strong>                       const FHitResult &amp; SweepResult);</strong><br/><br/><br/>};</pre>
<ol start="11">
<li>From the <kbd>TalkingPawn.cpp</kbd> file, make sure to include the following so that we have access to the <kbd>ITalker</kbd> and <kbd>UTalker</kbd> classes:</li>
</ol>
<pre style="padding-left: 60px">#include "TalkingPawn.h"<br/><strong>#include "Talker.h"</strong></pre>
<ol start="12">
<li>Afterwards implement the constructor:</li>
</ol>
<pre style="padding-left: 60px">ATalkingPawn::ATalkingPawn() : Super()<br/>{<br/>    // Set this character to call Tick() every frame. You can<br/>    // turn this off to improve performance if you<br/>    // don't need it.<br/>    PrimaryActorTick.bCanEverTick = true;<br/><br/>    TalkCollider = CreateDefaultSubobject&lt;UBoxComponent&gt;("TalkCollider");<br/><br/>    TalkCollider-&gt;SetBoxExtent(FVector(200, 200, 100));<br/><br/>    TalkCollider-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;ATalkingPawn::OnTalkOverlap);<br/><br/>    TalkCollider-&gt;AttachTo(RootComponent);<br/>}</pre>
<ol start="13">
<li>Implement <kbd>OnTalkOverlap</kbd>:</li>
</ol>
<pre style="padding-left: 60px">// Called to bind functionality to input<br/>void ATalkingPawn::OnTalkOverlap(UPrimitiveComponent* OverlappedComponent, <br/>                                 AActor* OtherActor, <br/>                                 UPrimitiveComponent* OtherComp, <br/>                                 int32 OtherBodyIndex, bool bFromSweep, <br/>                                 const FHitResult &amp; SweepResult)<br/>{<br/>    auto Class = OtherActor-&gt;GetClass();<br/>    if (Class-&gt;ImplementsInterface(UTalker::StaticClass()))<br/>    {<br/>        ITalker::Execute_StartTalking(OtherActor);<br/>    }<br/>}</pre>
<ol start="14">
<li>Compile your scripts. Create a new <kbd>GameMode</kbd> and set <kbd>TalkingPawn</kbd> as the default pawn class for the player. The quickest way to do this is to go to Settings | World Settings and then, under GameMode Override, click on the + button. From there, expand the Selected GameMode option and under Default Pawn Class, select <kbd>TalkingPawn</kbd>. Refer to the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6aca0461-7c62-4d54-bf82-4b8e96c8b0c9.png"/></p>
<ol start="15">
<li> Drag an instance of your <kbd>ATalkingMesh</kbd> class into the level. If you play the game now, you should be able to walk close to the mesh and see it display a message:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/4b6e90fc-40da-46b1-b6b9-98cbbf90fba9.png"/></p>
<ol start="16">
<li>Create a new Blueprint class based on <kbd>ATalkingMesh</kbd> by right-clicking on it from the Content Browser and selecting the appropriate option from the context menu:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/fa84dd2a-1452-4c4c-a716-b9a32a62d245.png"/> </p>
<ol start="17">
<li>Name it <kbd>MyTalkingMesh</kbd> and select Create Blueprint Class:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d4c82f32-2f65-4bb6-9c3f-29d9235c2bb6.png"/></p>
<ol start="18">
<li>Inside the Blueprint Editor, create an implementation for <kbd>StartTalking</kbd>. We can do this by going to the Event Graph and right-clicking within the graph. Then, in the search bar, we can type in <kbd>start talking</kbd>. Under Add Event, select the Event Start Talking option.</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/10bf1f2e-cf6a-4c8f-8247-a3b2472aed4d.png"/></p>
<ol start="19">
<li>If you would like to call the parent version of the event, you can right-click on the event node and select the Add call to parent function option:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/45898ae1-509a-492e-b45b-9f3771054836.png"/></p>
<ol start="20">
<li>Afterward, you can connect the events together. To do something different from the original, create a Print String node and display a new In String message, such as <kbd>I'm the overridden implementation in Blueprint</kbd>. The final version of the example will look as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/e67f1e3d-201a-4a7a-ae37-b61e8c2558ca.png"/></p>
<ol start="21">
<li>Compile your Blueprint. Afterwards, drag a copy of your new Blueprint into the level beside your <kbd>ATalkingMesh</kbd> instance.</li>
<li>Walk up to the two actors and verify that your custom <kbd>Pawn</kbd> is correctly invoking either the default C++ implementation or the Blueprint implementation, as appropriate:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ccd4ed7e-9285-4a9f-907d-8a2c011b9402.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As always, we create a new interface, and then add some function definitions to the <kbd>IInterface</kbd> class. We use the <kbd>BlueprintNativeEvent</kbd> specifier to indicate that we want to declare a default implementation in C++ that can then be overridden in Blueprint. We create a new class (inheriting from <kbd>StaticMeshActor</kbd> for convenience) and implement the interface on it.</p>
<p>In the implementation of the new class constructor, we load a static mesh and set our collision as usual. We then add an implementation for our interface function, which simply prints a message to the screen.</p>
<p>If you were using this in a full-blown project, you could play animations, play audio, alter the user interface, and whatever else was necessary to start a conversation with your <kbd>Talker</kbd>.</p>
<p>At this point, though, we don't have anything to actually call <kbd>StartTalking</kbd> on our <kbd>Talker</kbd>. The simplest way to implement this is to create a new <kbd>Pawn</kbd> subclass (again, inheriting from <kbd>DefaultPawn</kbd> for convenience) that can start talking to any <kbd>Talker</kbd> actors that it collides with.</p>
<p>For this to work, we create a new <kbd>BoxComponent</kbd> to establish the radius at which we will trigger a conversation. As always, it is a <kbd>UPROPERTY</kbd>, so it won't get garbage collected. We also create the definition for a function that will get triggered when the new <kbd>BoxComponent</kbd> overlaps another <kbd>Actor</kbd> in the scene.</p>
<p>The constructor for our <kbd>TalkingPawn</kbd> initializes the new <kbd>BoxComponent</kbd>, and sets its extents appropriately. The constructor also binds the <kbd>OnTalkOverlap</kbd> function as an event handler to handle collisions with our <kbd>BoxComponent</kbd>. It also attaches the box component to our <kbd>RootComponent</kbd> so that it moves with the rest of the player character as the player moves around the level.</p>
<p>Inside <kbd>OnTalkOverlap</kbd>, we need to check if the other actor, which is overlapping our box, implements the <kbd>Talker</kbd> interface. The most reliable way to do this is with the <kbd>ImplementsInterface</kbd> function in <kbd>UClass</kbd>. This function uses the class information that's generated by the Unreal Header Tool during compilation, and correctly handles both C++ and Blueprint-implemented interfaces.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If the function returns <kbd>true</kbd>, we can use a special autogenerated function contained in our <kbd>IInterface</kbd> to invoke the interface method of our choice on our instance. This is a static method of the form <kbd>&lt;IInterface&gt;::Execute_&lt;FunctionName&gt;</kbd>. In our instance, our <kbd>IInterface</kbd> is <kbd>ITalker</kbd>, and the function is <kbd>StartTalking</kbd>, so the function we want to invoke is <kbd>ITalker::Execute_StartTalking()</kbd>.</p>
<p>The reason we need this function is that, when an interface is implemented in Blueprint, the relationship isn't actually established at compile time. C++ is, therefore, not aware of the fact that the interface is implemented, and so we can't cast the Blueprint class to <kbd>IInterface</kbd> to call functions directly.</p>
<p>The <kbd>Execute_</kbd> functions take a pointer to the object that implements the interface and call a number of internal methods to invoke the desired function's Blueprint implementation.</p>
<p>When you play the level and walk around, the custom <kbd>Pawn</kbd> is constantly receiving notifications when its <kbd>BoxComponent</kbd> overlaps other objects. If they implement the <kbd>UTalker</kbd>/<kbd>ITalker</kbd> interface, the pawn then tries to invoke <kbd>StartTalking</kbd> on the <kbd>Actor</kbd> instance in question, which then prints the appropriate message on screen.</p>


            

            
        
    </body></html>