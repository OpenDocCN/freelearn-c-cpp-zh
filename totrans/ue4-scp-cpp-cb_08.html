<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Communication Between Classes and Interfaces: Part II</h1>
                </header>
            
            <article>
                
<p>The following recipes will be covered in this chapter:</p>
<ul>
<li>Exposing UInterface methods to Blueprint from a native base class</li>
<li>Implementing UInterface functions in Blueprint</li>
<li>Creating C++ UInterface function implementations that can be overridden in Blueprint</li>
<li>Calling Blueprint-defined interface functions from C++</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>This chapter will show you ways in which you can use your C++ UInterfaces through Blueprints. This can be very helpful in letting designers access code that you've written without requiring them to dive into the C++ code of the project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p><span>This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017 as the IDE. Instructions on how to install both pieces of software and the requirements for them can be found in <a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml">Chapter 1</a>, <em>UE4 Development Tools</em>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exposing UInterface methods to Blueprint from a native base class</h1>
                </header>
            
            <article>
                
<p>Being able to define<span> </span><kbd>UInterface</kbd><span> </span>methods in C++ is great, but they should be accessible from Blueprint too. Otherwise, designers or others who are using Blueprint won't be able to interact with your<span> </span><kbd>UInterface</kbd>. This recipe shows you how to make a function from an interface callable within the Blueprint system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a<span> </span><kbd>UInterface</kbd><span> </span>called<span> </span><kbd>PostBeginPlay</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7539c4d4-019e-4c79-87e9-1b34d814759e.png"/></p>
<ol start="2">
<li>Open <kbd>PostBeginPlay.h</kbd> in Visual Studio and update the<span> </span><kbd>UINTERFACE</kbd><span> </span>of<span> </span><kbd>UPostBeginPlay</kbd><span> </span>and add the following<span> </span><kbd>virtual</kbd><span> </span>method in<span> </span><kbd>IPostBeginPlay</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "UObject/Interface.h"<br/>#include "PostBeginPlay.generated.h"<br/><br/><strong>UINTERFACE(meta = (CannotImplementInterfaceInBlueprint))</strong><br/>class UPostBeginPlay : public UInterface<br/>{<br/>    GENERATED_BODY()<br/>};<br/><br/>/**<br/> * <br/> */<br/>class CHAPTER_08_API IPostBeginPlay<br/>{<br/>    GENERATED_BODY()<br/><br/>    // Add interface functions to this class. This is the<br/>    // class that will be inherited to implement<br/>    // this interface.<br/>public:<br/><strong>    UFUNCTION(BlueprintCallable, Category = Test)</strong><br/><strong>    virtual void OnPostBeginPlay();</strong><br/>};</pre>
<ol start="3">
<li>Provide an implementation of the function:</li>
</ol>
<pre style="padding-left: 60px">#include "PostBeginPlay.h"<br/><br/>// Add default functionality here for any IPostBeginPlay <br/>// functions that are not pure virtual.<br/><strong>void IPostBeginPlay::OnPostBeginPlay()</strong><br/><strong>{</strong><br/><strong>    GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, "PostBeginPlay called");</strong><br/><strong>}</strong></pre>
<ol start="4">
<li>Create a new<span> </span><kbd>Actor</kbd><span> </span>class called<span> </span><kbd>APostBeginPlayTest</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c6f5e0ca-46ef-4aa6-8dfc-742573723f0a.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="5">
<li>Modify the class declaration so that it also inherits<span> </span><kbd>IPostBeginPlay</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "PostBeginPlay.h"</strong><br/>#include "PostBeginPlayTest.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_08_API APostBeginPlayTest : public AActor<strong>, public IPostBeginPlay</strong></pre>
<ol start="6">
<li>Compile your project. Inside the editor, drag an instance of<span> </span><kbd>APostBeginPlayTest</kbd><span> </span>into your level:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b3bef66c-220a-4c6a-aafe-cb29f2950e87.png"/></p>
<ol start="7">
<li>With the instance selected in the<span> </span><span class="packt_screen">World Outliner</span>, click on<span> </span><span class="packt_screen">Blueprints | </span><span class="packt_screen">Open Level Blueprint</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ad526052-f410-46fe-b6e9-99a44dc869d4.jpg" style="width:28.58em;height:26.00em;"/></p>
<ol start="8">
<li>Inside the Level Blueprint, right-click and<span> </span><span class="packt_screen">Create a Reference to PostBeginPlayTest1</span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/5f52943e-720b-45de-b7ce-a9aa47bb3a46.png" style="width:37.75em;height:14.33em;"/></div>
<div class="packt_tip">Note that you can also use the drag-and-drop method we discussed in the<span> </span><em>Inheriting UInterfaces from one another</em> recipe from the previous chapter.</div>
<ol start="9">
<li>Drag away from the blue pin on the right-hand side of your actor reference, then search the context menu for<span> </span><kbd>onpost</kbd><span> </span>to see your new interface function. Click on it to insert a call to your native<span> </span><kbd>UInterface</kbd><span> </span>implementation from Blueprint:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0a4d5096-348e-4d01-9996-1c1b4738061a.png"/></p>
<ol start="10">
<li>Finally, connect the execution pin (white arrow) from the<span> </span><kbd>BeginPlay</kbd><span> </span>node to the execution pin for<span> </span><kbd>OnPostBeginPlay</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cd60e61c-cce6-4569-9985-af0696055fac.png"/></p>
<ol start="11">
<li>When you play your level, you should see the message<span> </span><span class="packt_screen">PostBeginPlay called</span><span> </span>visible on screen for a short amount of time, verifying that Blueprint has successfully accessed and called through to your native code implementation of the<span> </span><kbd>UInterface</kbd>.</li>
</ol>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>UINTERFACE</kbd>/<kbd>IInterface</kbd><span> </span>pair function like they do in other recipes, with the<span> </span><kbd>UInterface</kbd><span> </span>containing reflection information and other data and the<span> </span><kbd>IInterface</kbd><span> </span>functioning as the actual interface class that can be inherited from.</p>
<p>The most significant element that allows the function inside<span> </span><kbd>IInterface</kbd><span> </span>to be exposed to Blueprint is the<span> </span><kbd>UFUNCTION</kbd><span> </span>specifier.<span> </span><kbd>BlueprintCallable</kbd><span> </span>marks this function as one that can be called from the Blueprint system.</p>
<p>Any functions exposed to Blueprint in any way require a<span> </span><kbd>Category</kbd><span> </span>value. This<span> </span><kbd>Category</kbd><span> </span>value specifies the heading under which the function will be listed in the context menu.</p>
<p>The function must also be marked<span> </span><kbd>virtual</kbd> <span>– </span>this is so that a class that implements the interface via native code can override the implementations of the functions inside it. Without the<span> </span><kbd>virtual</kbd><span> </span>specifier, the Unreal Header Tool will give you an error, indicating that you have to either add<span> </span><kbd>virtual</kbd> or<span> </span><kbd>BlueprintImplementableEvent</kbd><span> </span>as a<span> </span><kbd>UFUNCTION</kbd><span> </span>specifier.</p>
<p>The reason for this is that without either of those, the interface function wouldn't be overridable in C++ (due to the absence of<span> </span><kbd>virtual</kbd>) or Blueprint (because<span> </span><kbd>BlueprintImplementableEvent</kbd><span> </span>was missing). An interface that can't be overridden, but only inherited, has limited utility, so Epic have chosen not to support it within UInterfaces.</p>
<p>We then provide a default implementation of the<span> </span><kbd>OnPostBeginPlay</kbd><span> </span>function, which uses the<span> </span><kbd>GEngine</kbd><span> </span>pointer to display a debug message, confirming that the function was invoked.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><span class="ChapterrefPACKT">Refer to<span> </span><a href="bded5c5b-3038-4d12-b03d-39218257492b.xhtml">Chapter 8</a></span>, <span><em>Communication Between Classes and Interfaces: Part II</em></span><em>,</em><span> </span>for a number of recipes that show you how you can integrate your C++ classes with Blueprint</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing UInterface functions in Blueprint</h1>
                </header>
            
            <article>
                
<p>One of the key advantages of UInterface in Unreal is the ability for users to implement<span> </span><kbd>UInterface</kbd><span> </span>functions in the editor. This means that the interface can be implemented strictly in Blueprint without needing any C++ code, which is helpful to designers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new<span> </span><kbd>UInterface</kbd><span> </span>called<span> </span><kbd>AttackAvoider</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/91241cc3-1b98-40c3-8d23-054321e24a96.png"/></p>
<ol start="2">
<li>Add the following function declaration to the header:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "UObject/Interface.h"<br/>#include "AttackAvoider.generated.h"<br/><br/>// This class does not need to be modified.<br/>UINTERFACE(MinimalAPI)<br/>class UAttackAvoider : public UInterface<br/>{<br/>  GENERATED_BODY()<br/>};<br/><br/>class CHAPTER_08_API IAttackAvoider<br/>{<br/>  GENERATED_BODY()<br/><br/>  // Add interface functions to this class. This is the class<br/>  // that will be inherited to implement this interface.<br/>public:<br/>    <strong>UFUNCTION(BlueprintImplementableEvent, BlueprintCallable, <br/> Category = AttackAvoider)</strong><br/><strong> void AttackIncoming(AActor* AttackActor);</strong><br/>};</pre>
<ol start="3">
<li>Compile your project. From the<span> </span><span class="packt_screen">Content Browser</span>, open the<span> </span><span class="packt_screen">Content</span><span> </span>folder and then create a new<span> </span><span class="packt_screen">Blueprint Class</span><span> </span>within the Editor by selecting<span> </span><span class="packt_screen">Add New | Blueprint Class</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9cf44734-02d1-4ebb-87e0-f1aa7cbc45f5.jpg" style="width:19.17em;height:33.67em;"/></p>
<ol start="4">
<li>Base the class on<span> </span><span class="packt_screen">Actor</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/be3e694c-bcd6-4215-b045-1c160d2f7596.png"/></p>
<ol start="5">
<li>Name the blueprint<span> </span><kbd>AvoiderBlueprint</kbd><span> </span>and then double-click on it to open the Blueprint Editor. From there, open<span> </span><span class="packt_screen">Class Settings</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7b83d5a4-c153-433a-826b-a72e0d29a0b2.png"/></p>
<ol start="6">
<li>Under the Details tab, click on the drop-down menu that says<span> </span><span class="packt_screen">Add</span><span> </span>for<span> </span><span class="packt_screen">Implemented Interfaces</span>, and select<span> </span><span class="packt_screen">AttackAvoider</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5019f64b-074e-4432-b9f3-f48a1b693772.jpg" style="width:37.83em;height:23.25em;"/></p>
<ol start="7">
<li><span class="packt_screen">Compile</span><span> </span>your Blueprint:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8b5c7a09-df49-4876-af79-e9c5ff4b4c9f.jpg" style="width:11.75em;height:11.75em;"/></p>
<ol start="8">
<li>Open the <span class="packt_screen">Event Graph</span> by clicking on the <span class="packt_screen">Event Graph</span> tab and then right-click within the graph and type<span> </span><kbd>event attack</kbd>. Within the<span> </span><span class="packt_screen">Context Sensitive</span><span> </span>menu, you should see<span> </span><span class="packt_screen">Event Attack Incoming</span>. Select it to place an event node in your graph:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b80d7c45-4c16-4648-b626-9e234aff316f.jpg" style="width:31.00em;height:11.17em;"/></p>
<ol start="9">
<li>Drag this out from the execution pin on the new node and release. Type<span> </span><kbd>print string</kbd><span> </span>into the<span> </span><span class="packt_screen">Context Sensitive</span><span> </span>menu to add a<span> </span><span class="packt_screen">Print String</span><span> </span>node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6e86e174-4833-4ccc-aab1-d344fdb4f6c8.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Selecting the <span class="packt_screen">Print String</span> node</div>
<p style="padding-left: 60px">You have now implemented a<span> </span><kbd>UInterface</kbd><span> </span>function within Blueprint.</p>
<ol start="10">
<li>To see the event in action, drag the pin to the right of the<span> </span><span class="packt_screen">Event BeginPlay</span><span> </span>event and call an<span> </span><span class="packt_screen">Attack Incoming</span><span> </span>event:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2a10d7b5-eb26-4f02-970a-af9a5d675ec0.png"/></p>
<ol start="11">
<li>Drag and drop an instance of your Blueprint class into the level and play the game:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8621e029-18b4-4ca3-a875-bccd083bc7d9.png" style="width:34.58em;height:23.00em;"/></p>
<p>If all went well, you should see the default message from<span> </span><span class="packt_screen">Print String</span>, or whatever you posted to happen when the event should happen!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>UINTERFACE</kbd>/<kbd>IInterface</kbd><span> </span>are created in exactly the same way that we saw in the other recipes in this chapter. When we add a function to the interface, however, we use a new<span> </span><kbd>UFUNCTION</kbd><span> </span>specifier,<span> </span><kbd>BlueprintImplementableEvent</kbd>.</p>
<p><kbd>BlueprintImplementableEvent</kbd><span> </span>tells the Unreal Header Tool to generate code that creates an empty stub function that can be implemented by Blueprint. We do not need to provide a default C++ implementation for the function.</p>
<p>We implement the interface inside Blueprint, which exposes the function for us in a way that allows us to define its implementation in Blueprint.<span> </span><span>The autogenerated code that's created by the header tool forwards the calls to the</span><span> </span><kbd>UInterface</kbd><span> </span><span>function to our Blueprint implementation.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p><span>The</span><span> </span><em>Overriding C++ UInterface functions through Blueprints</em> <span>recipe shows you how to define a default implementation for your</span><span> </span><kbd>UInterface</kbd><span> </span><span>function in C++, then optionally override it in Blueprint if necessary.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overriding C++ UInterface functions through Blueprints </h1>
                </header>
            
            <article>
                
<p>Just like the previous recipe, UInterfaces are useful, but that utility is severely limited without their functionality being usable by designers.</p>
<p>The previous recipe, <em>Exposing UInterface methods to Blueprints from a native base class</em>, showed you how to call C++<span> </span><kbd>UInterface</kbd><span> </span>functions from Blueprint; this recipe will show you how to replace the implementation of a<span> </span><kbd>UInterface</kbd><span> </span>function with your own custom Blueprint-only function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new interface called<span> </span><kbd>Wearable</kbd><span> ( Creating both </span><kbd>IWearable</kbd> &amp; <span> </span><kbd>UWearable</kbd>):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5c357868-84cf-4094-9a7a-f75ac5064c56.png"/></p>
<ol start="2">
<li>Add the following functions to the header of the<span> </span><kbd>IWearable</kbd><span> </span>class:</li>
</ol>
<pre style="padding-left: 60px">class CHAPTER_08_API IWearable<br/>{<br/>    GENERATED_BODY()<br/><br/>    // Add interface functions to this class. This is the<br/>    // class that will be inherited to implement<br/>    // this interface.<br/>public:<br/><strong>    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, </strong><br/><strong>              Category = Wearable)</strong><br/><strong>    int32 GetStrengthRequirement();</strong><br/><br/><strong>    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, </strong><br/><strong>              Category = Wearable)</strong><br/><strong>    bool CanEquip(APawn* Wearer);</strong><br/><br/><strong>    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, </strong><br/><strong>              Category = Wearable)</strong><br/><strong>    void OnEquip(APawn* Wearer);</strong><br/>};</pre>
<p style="padding-left: 60px"><span>UE 4.20 and above does not allow us to create a default implementation for a function if it is defined in an interface class, so we will have to use UE's default empty implementation, which gives us the default value as a return for each function. This is because, in C# and other languages that have</span><span> interfaces, they are not supposed to have a default implementation.</span></p>
<ol start="3">
<li>Create a new<span> </span><kbd>Actor</kbd><span> </span>class called<span> </span><kbd>Boots</kbd><span> </span>inside the editor:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/db097867-0667-461f-ac7a-17516d5381dc.png"/></p>
<ol start="4">
<li>Add<span> </span><kbd>#include "Wearable.h"</kbd><span> </span>to the header file for<span> </span><kbd>Boots</kbd> and modify the class declaration, as follows:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/><strong>#include "Wearable.h"</strong><br/>#include "Boots.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_08_API ABoots : public AActor<strong>, public IWearable</strong></pre>
<ol start="5">
<li>Add the following implementation of the pure<span> </span><kbd>virtual</kbd><span> </span>functions that were created by our Interface:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_08_API ABoots : public AActor, public IWearable<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public: <br/>    // Sets default values for this actor's properties<br/>    ABoots();<br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/><strong>    // Implementing the functions needed for IWearable</strong><br/><strong>    virtual void OnEquip_Implementation(APawn* Wearer) override</strong><br/><strong>    {</strong><br/><strong>        GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, <br/>                                         "Item being worn");</strong><br/><strong>    }<br/></strong><br/><strong>    virtual bool CanEquip_Implementation(APawn* Wearer) override</strong><br/><strong>    {</strong><br/><strong>        return true;</strong><br/><strong>    }<br/></strong><br/><strong>    virtual int32 GetStrengthRequirement_Implementation() override</strong><br/><strong>    {</strong><br/><strong>        return 0;</strong><br/><strong>    }</strong><br/><br/>};</pre>
<p style="padding-left: 60px"><span>If you do not know how to do the following two steps, check out the previous recipe, </span><span><em>Implementing UInterface functions in Blueprint</em>.</span></p>
<ol start="6">
<li>Compile your script so that we will have access to the new functions we have created.</li>
<li>Create a new Blueprint class called<span> </span><kbd>Gloves</kbd><span> </span>based on<span> </span><kbd>Actor</kbd> by going to the <span class="packt_screen">Content Browser</span>, opening the <kbd>Content</kbd> folder, and then right clicking and then selecting <span class="packt_screen">Blueprint Class</span>.</li>
</ol>
<ol start="8">
<li>In the<span> </span><span class="packt_screen">Class Settings</span><span> </span>menu, under the<span> </span><span class="packt_screen">Details</span><span> </span>tab, scroll down to the <span class="packt_screen">Implemented Interfaces</span> property and click on the<span> </span><span class="packt_screen">Add</span><span> </span>button<span> </span>and select<span> </span><kbd>Wearable</kbd><span> </span>as the interface that the<span> </span><kbd>Gloves</kbd><span> </span>actor will implement:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6e0652ae-bd66-450b-9bc7-859d6ff1eae0.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Adding the Wearable interface</div>
<ol start="9">
<li>Afterwards, hit the <span class="packt_screen">Compile</span> button in order to apply the change.</li>
</ol>
<ol start="10">
<li>Open the<span> </span><span class="packt_screen">Event Graph</span><span> </span>and right-click it to create a new event. From the search bar, type in<span> </span><kbd>on equip</kbd><span>, </span>and you should see our event under the<span> </span><span class="packt_screen">Add Event</span><span> </span>section:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c02f936d-d293-45b9-97f2-60b24aa5a932.png"/></p>
<ol start="11">
<li>This allows us to override the<span> </span><kbd>OnEquip</kbd><span> </span>function from the default implementation to do whatever we want. For instance, add a<span> </span><span class="packt_screen">Print String</span><span> </span>node with the<span> </span><span class="packt_screen">In String</span><span> </span>being set to <kbd>Gloves being worn</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/aa9216fb-a775-41b3-854f-0bfdfdc6f958.png"/></p>
<ol start="12">
<li>Click on the <span class="packt_screen">Compile</span> button and then you can close the Blueprint. Drag a copy of both<span> </span><kbd>Gloves</kbd><span> </span>and<span> </span><kbd>Boots</kbd><span> </span>into your level for testing purposes.</li>
</ol>
<ol start="13">
<li>Once added, add the following blueprint code to your level:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7e5b7e41-6f9a-4a02-9065-c8fa4ed3e74f.png"/></p>
<ol start="14">
<li>Verify that<span> </span><kbd>Boots</kbd><span> </span>performs the default behavior, but<span> that </span><kbd>Gloves</kbd><span> </span>performs the blueprint-defined behavior:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/95bdce70-174c-418e-98fe-88231ed6b461.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe uses two<span> </span><kbd>UFUNCTION</kbd><span> </span>specifiers together:<span> </span><kbd>BlueprintNativeEvent</kbd><span> </span>and<span> </span><kbd>BlueprintCallable</kbd>.<span> </span><kbd>BlueprintCallable</kbd><span> </span>has been shown in previous recipes, and is a way of marking your<span> </span><kbd>UFUNCTION</kbd><span> </span>as visible and invokable in the Blueprint Editor.</p>
<p><kbd>BlueprintNativeEvent</kbd><span> </span>signifies a<span> </span><kbd>UFUNCTION</kbd><span> </span>that has a default C++ (native code) implementation, but is also overridable in Blueprint. It's a combination of a virtual function, along with<span> </span><kbd>BlueprintImplementableEvent</kbd>.</p>
<p>For this mechanism to work, the Unreal Header Tool generates the body of your functions so that the Blueprint version of the function is called if it exists; otherwise, it dispatches the method call through to the native implementation.</p>
<p>The<span> </span><kbd>Boots</kbd><span> </span>class implements<span> </span><kbd>IWearable</kbd>, overriding the default functionality. In contrast,<span> </span><kbd>Gloves</kbd><span> </span>also implements<span> </span><kbd>IWearable</kbd>, but has an overridden implementation for<span> </span><kbd>OnEquip</kbd><span> </span>defined in Blueprint. This can be verified when we use<span> </span><span class="packt_screen">Level Blueprints</span><span> </span>to call<span> </span><kbd>OnEquip</kbd><span> </span>for the two actors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calling Blueprint-defined interface functions from C++</h1>
                </header>
            
            <article>
                
<p>While the previous recipes have focused on C++ being usable in Blueprint, such as being able to call functions from C++ in Blueprint, and override C++ functions with Blueprint, this recipe shows you the reverse: calling a Blueprint-defined interface function from C++.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new<span> </span><kbd>UInterface</kbd><span> </span>called<span> </span><kbd>Talker</kbd><span>  (C</span>reating the <kbd>UTalker</kbd>/<kbd>ITalker</kbd> classes):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/246f7357-2422-4d79-a871-d740fc5f04bf.png"/></p>
<ol start="2">
<li>Add the following<span> </span><kbd>UFUNCTION</kbd><span> </span>implementation:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "UObject/Interface.h"<br/>#include "Talker.generated.h"<br/><br/>// This class does not need to be modified.<br/>UINTERFACE(MinimalAPI)<br/>class UTalker : public UInterface<br/>{<br/>    GENERATED_BODY()<br/>};<br/><br/>/**<br/> * <br/> */<br/>class CHAPTER_08_API ITalker<br/>{<br/>    GENERATED_BODY()<br/><br/>    // Add interface functions to this class. This is the<br/>    // class that will be inherited to implement<br/>    // this interface.<br/>public:<br/><strong>    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = Talk)</strong><br/><strong>    void StartTalking();</strong><br/><br/>};</pre>
<ol start="3">
<li>Create a new C++ class based on<span> </span><kbd>StaticMeshActor</kbd>. Remember to check<span> </span><span class="packt_screen">Show All Classes</span><span> </span>and find the class that way:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d78ffdd9-291d-4c5e-900b-4afe7bb3b150.png"/>.</p>
<ol start="4">
<li>After clicking<span> </span><span class="packt_screen">Next</span>, name this new class<span> </span><kbd>TalkingMesh</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/89e67a4a-0978-4258-ba9c-0ef649ac5c8f.png"/></p>
<ol start="5">
<li>Add<span> </span><kbd>#include</kbd><span> </span>and modify the class declaration to include the talker interface:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "Engine/StaticMeshActor.h"<br/><strong>#include "Talker.h"</strong><br/>#include "TalkingMesh.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_08_API ATalkingMesh : public AStaticMeshActor<strong>, public ITalker</strong></pre>
<ol start="6">
<li>Also, add the following functions to the class declaration:</li>
</ol>
<pre style="padding-left: 60px">UCLASS()<br/>class CHAPTER_08_API ATalkingMesh : public AStaticMeshActor, public ITalker<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>public:</strong><br/><strong>    ATalkingMesh();</strong><br/><strong>    void StartTalking_Implementation();</strong><br/>};</pre>
<ol start="7">
<li>Within the implementation, add the following to <kbd>TalkingMesh.cpp</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#include "TalkingMesh.h"<br/><strong>#include "ConstructorHelpers.h"</strong><br/><br/><strong>ATalkingMesh::ATalkingMesh() : Super()</strong><br/><strong>{</strong><br/><strong>    auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;(TEXT("StaticMesh'/Engine/BasicShapes/Cube.Cube'"));</strong><br/><br/><strong>    UStaticMeshComponent * SM = GetStaticMeshComponent();</strong><br/><br/><strong>    if(SM != nullptr)</strong><br/><strong>    {</strong><br/><strong>        if (MeshAsset.Object != nullptr)</strong><br/><strong>        {</strong><br/><strong>            SM-&gt;SetStaticMesh(MeshAsset.Object);</strong><br/><strong>            SM-&gt;SetGenerateOverlapEvents(true);</strong><br/><strong>        }</strong><br/><br/><strong>        SM-&gt;SetMobility(EComponentMobility::Movable);</strong><br/><br/><strong>    }</strong><br/><strong>    </strong><br/><strong>    SetActorEnableCollision(true);</strong><br/><strong>}</strong><br/><br/><strong>void ATalkingMesh::StartTalking_Implementation()</strong><br/><strong>{</strong><br/><strong>    GEngine-&gt;AddOnScreenDebugMessage(-1, 1, FColor::Red, </strong><br/><strong>                              TEXT("Hello there. What is your name?"));</strong><br/><strong>}</strong></pre>
<ol start="8">
<li>Create a new class based on<span> </span><kbd>DefaultPawn</kbd><span> </span>to function as our player character:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7c9e20bd-ff72-4add-b845-251e8019f6d6.png"/></p>
<ol start="9">
<li>Once you select<span> </span><span class="packt_screen">Next</span>, give the class a<span> </span><span class="packt_screen">Name</span><span> </span>of<span> </span><kbd>TalkingPawn</kbd><span> </span>and select<span> </span><span class="packt_screen">Create Class</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/459b2a04-31ce-4d3b-8655-29fc0370b550.png"/></p>
<p class="mce-root"/>
<ol start="10">
<li>Add the following to our class header:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/DefaultPawn.h"<br/><strong>#include "Components/BoxComponent.h" // UBoxComponent</strong><br/>#include "TalkingPawn.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_08_API ATalkingPawn : public ADefaultPawn<br/>{<br/>  GENERATED_BODY()<br/>  <br/><strong>public:</strong><br/><strong>    // Sets default values for this character's properties</strong><br/><strong>    ATalkingPawn();</strong><br/><br/><strong>    UPROPERTY()</strong><br/><strong>    UBoxComponent* TalkCollider;</strong><br/><br/><strong>    UFUNCTION()</strong><br/><strong>    void OnTalkOverlap(UPrimitiveComponent* OverlappedComponent, </strong><br/><strong>                       AActor* OtherActor, </strong><br/><strong>                       UPrimitiveComponent* OtherComp, </strong><br/><strong>                       int32 OtherBodyIndex, bool bFromSweep, </strong><br/><strong>                       const FHitResult &amp; SweepResult);</strong><br/><br/><br/>};</pre>
<ol start="11">
<li>From the<span> </span><kbd>TalkingPawn.cpp</kbd><span> </span>file, make sure to include the following so that we<span> </span>have<span> </span>access to the<span> </span><kbd>ITalker</kbd><span> </span>and<span> </span><kbd>UTalker</kbd><span> </span>classes:</li>
</ol>
<pre style="padding-left: 60px">#include "TalkingPawn.h"<br/><strong>#include "Talker.h"</strong></pre>
<ol start="12">
<li>Afterwards implement the constructor:</li>
</ol>
<pre style="padding-left: 60px">ATalkingPawn::ATalkingPawn() : Super()<br/>{<br/>    // Set this character to call Tick() every frame. You can<br/>    // turn this off to improve performance if you<br/>    // don't need it.<br/>    PrimaryActorTick.bCanEverTick = true;<br/><br/>    TalkCollider = CreateDefaultSubobject&lt;UBoxComponent&gt;("TalkCollider");<br/><br/>    TalkCollider-&gt;SetBoxExtent(FVector(200, 200, 100));<br/><br/>    TalkCollider-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;ATalkingPawn::OnTalkOverlap);<br/><br/>    TalkCollider-&gt;AttachTo(RootComponent);<br/>}</pre>
<ol start="13">
<li>Implement<span> </span><kbd>OnTalkOverlap</kbd>:</li>
</ol>
<pre style="padding-left: 60px">// Called to bind functionality to input<br/>void ATalkingPawn::OnTalkOverlap(UPrimitiveComponent* OverlappedComponent, <br/>                                 AActor* OtherActor, <br/>                                 UPrimitiveComponent* OtherComp, <br/>                                 int32 OtherBodyIndex, bool bFromSweep, <br/>                                 const FHitResult &amp; SweepResult)<br/>{<br/>    auto Class = OtherActor-&gt;GetClass();<br/>    if (Class-&gt;ImplementsInterface(UTalker::StaticClass()))<br/>    {<br/>        ITalker::Execute_StartTalking(OtherActor);<br/>    }<br/>}</pre>
<ol start="14">
<li>Compile your scripts. Create a new<span> </span><kbd>GameMode</kbd> and set<span> </span><kbd>TalkingPawn</kbd><span> </span>as the default pawn class for the player. The quickest way to do this is to go to<span> </span><span class="packt_screen">Settings | World Settings</span><span> </span>and then, under<span> </span><span class="packt_screen">GameMode Override</span><span>, </span>click on the<span> </span>+<span> </span>button. From there, expand the <span class="packt_screen">Selected GameMode</span> option and under<span> </span><span class="packt_screen">Default Pawn Class</span><span>, </span>select<span> </span><kbd>TalkingPawn</kbd>. Refer to the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6aca0461-7c62-4d54-bf82-4b8e96c8b0c9.png"/></p>
<ol start="15">
<li> Drag an instance of your<span> </span><kbd>ATalkingMesh</kbd><span> </span>class into the level. If you play the game now, you should be able to walk close to the mesh and see it display a message:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4b6e90fc-40da-46b1-b6b9-98cbbf90fba9.png"/></p>
<ol start="16">
<li>Create a new Blueprint class based on<span> </span><kbd>ATalkingMesh</kbd><span> </span>by right-clicking on it from the<span> </span><span class="packt_screen">Content Browser</span> and selecting the appropriate option from the context menu:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fa84dd2a-1452-4c4c-a716-b9a32a62d245.png"/> </p>
<ol start="17">
<li>Name it<span> </span><kbd>MyTalkingMesh</kbd> and select<span> </span><span class="packt_screen">Create Blueprint Class</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d4c82f32-2f65-4bb6-9c3f-29d9235c2bb6.png"/></p>
<ol start="18">
<li>Inside the Blueprint Editor, create an implementation for<span> </span><kbd>StartTalking</kbd>. We can do this by going to the<span> </span><span class="packt_screen">Event Graph</span><span> </span>and right-clicking within the graph. Then, in the search bar, we can type in<span> </span><kbd>start talking</kbd>. Under<span> </span><span class="packt_screen">Add Event</span><span>, </span>select the<span> </span><span class="packt_screen">Event Start Talking</span><span> </span>option.</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/10bf1f2e-cf6a-4c8f-8247-a3b2472aed4d.png"/></p>
<ol start="19">
<li>If you would like to call the parent version of the event, you can right-click on the event node and select the<span> </span><span class="packt_screen">Add call to parent function</span><span> </span>option:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/45898ae1-509a-492e-b45b-9f3771054836.png"/></p>
<ol start="20">
<li>Afterward, you can connect the events together. To do something different from the original, create a<span> </span><span class="packt_screen">Print String</span><span> </span>node and display a new<span> </span><span class="packt_screen">In String</span><span> </span>message, such as<span> </span><kbd>I'm the overridden implementation in Blueprint</kbd>. The final version of the example will look as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e67f1e3d-201a-4a7a-ae37-b61e8c2558ca.png"/></p>
<ol start="21">
<li><span>Compile your Blueprint. Afterwards, drag a copy of your new Blueprint into the level beside your</span><span> </span><kbd>ATalkingMesh</kbd><span> </span><span>instance.</span></li>
<li>Walk up to the two actors and verify that your custom <kbd>Pawn</kbd> is correctly invoking either the default C++ implementation or the Blueprint implementation, as appropriate:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ccd4ed7e-9285-4a9f-907d-8a2c011b9402.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As always, we create a new interface, and then add some function definitions to the<span> </span><kbd>IInterface</kbd><span> </span>class. We use the<span> </span><kbd>BlueprintNativeEvent</kbd><span> </span>specifier to indicate that we want to declare a default implementation in C++ that can then be overridden in Blueprint. We create a new class (inheriting from<span> </span><kbd>StaticMeshActor</kbd><span> </span>for convenience) and implement the interface on it.</p>
<p>In the implementation of the new class constructor, we load a static mesh and set our collision as usual. We then add an implementation for our interface function, which simply prints a message to the screen.</p>
<p>If you were using this in a full-blown project, you could play animations, play audio, alter the user interface, and whatever else was necessary to start a conversation with your<span> </span><kbd>Talker</kbd>.</p>
<p>At this point, though, we don't have anything to actually call<span> </span><kbd>StartTalking</kbd><span> </span>on our<span> </span><kbd>Talker</kbd>. The simplest way to implement this is to create a new<span> </span><kbd>Pawn</kbd><span> </span>subclass (again, inheriting from<span> </span><kbd>DefaultPawn</kbd><span> </span>for convenience) that can start talking to any<span> </span><kbd>Talker</kbd><span> </span>actors that it collides with.</p>
<p>For this to work, we create a new<span> </span><kbd>BoxComponent</kbd><span> </span>to establish the radius at which we will trigger a conversation. As always, it is a<span> </span><kbd>UPROPERTY</kbd>, so it won't get garbage collected. We also create the definition for a function that will get triggered when the new<span> </span><kbd>BoxComponent</kbd><span> </span>overlaps another<span> </span><kbd>Actor</kbd><span> </span>in the scene.</p>
<p>The constructor for our<span> </span><kbd>TalkingPawn</kbd><span> </span>initializes the new<span> </span><kbd>BoxComponent</kbd>, and sets its extents appropriately. The constructor also binds the<span> </span><kbd>OnTalkOverlap</kbd><span> </span>function as an event handler to handle collisions with our<span> </span><kbd>BoxComponent</kbd>. It also attaches the box component to our<span> </span><kbd>RootComponent</kbd><span> </span>so that it moves with the rest of the player character as the player moves around the level.</p>
<p>Inside<span> </span><kbd>OnTalkOverlap</kbd>, we need to check if the other actor, which is overlapping our box, implements the<span> </span><kbd>Talker</kbd><span> </span>interface. The most reliable way to do this is with the<span> </span><kbd>ImplementsInterface</kbd><span> </span>function in<span> </span><kbd>UClass</kbd>. This function uses the class information that's generated by the Unreal Header Tool during compilation, and correctly handles both C++ and Blueprint-implemented interfaces.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If the function returns<span> </span><kbd>true</kbd>, we can use a special autogenerated function contained in our<span> </span><kbd>IInterface</kbd><span> </span>to invoke the interface method of our choice on our instance. This is a static method of the form<span> </span><kbd>&lt;IInterface&gt;::Execute_&lt;FunctionName&gt;</kbd>. In our instance, our<span> </span><kbd>IInterface</kbd><span> </span>is<span> </span><kbd>ITalker</kbd>, and the function is<span> </span><kbd>StartTalking</kbd>, so the function we want to invoke is<span> </span><kbd>ITalker::Execute_StartTalking()</kbd>.</p>
<p>The reason we need this function is that, when an interface is implemented in Blueprint, the relationship isn't actually established at compile time. C++ is, therefore, not aware of the fact that the interface is implemented, and so we can't cast the Blueprint class to<span> </span><kbd>IInterface</kbd><span> </span>to call functions directly.</p>
<p>The<span> </span><kbd>Execute_</kbd><span> </span>functions take a pointer to the object that implements the interface and call a number of internal methods to invoke the desired function's Blueprint implementation.</p>
<p>When you play the level and walk around, the custom<span> </span><kbd>Pawn</kbd><span> </span>is constantly receiving notifications when its<span> </span><kbd>BoxComponent</kbd><span> </span>overlaps other objects. If they implement the<span> </span><kbd>UTalker</kbd>/<kbd>ITalker</kbd><span> </span>interface, the pawn then tries to invoke<span> </span><kbd>StartTalking</kbd><span> </span>on the<span> </span><kbd>Actor</kbd><span> </span>instance in question, which then prints the appropriate message on screen.</p>


            </article>

            
        </section>
    </body></html>