<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Manipulating Functions in Functional Programming</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we talked about modern C++ in depth, especially about the new feature in C++11--the Lambda expression. As we discussed earlier, the Lambda expression is useful in simplifying function notation. Thus, in this chapter, we will apply the power of the Lambda expression again, which will be used in functional code, especially when we talk about currying--the technique to split and reduce the current function.</p>
<p>In this chapter, we will discuss the following topics:</p>
<ul>
<li>Applying the first-class function and higher-order function so that our functions can not only be invoked as a function, but also be assigned to any variable, pass a function, and return a function</li>
<li>Pure function, to avoid side effect in our function since it no longer contacts an outside state</li>
<li>Currying, as mentioned at the beginning of this chapter, to reduce the multiple arguments function so we can evaluate a sequence of functions, with a single argument in each function</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying the first-class function in all functions</h1>
                </header>
            
            <article>
                
<p>The first-class function is just a normal class. We can treat the first-class function like any other data type. However, in the language that supports the first-class function, we can do the following tasks without invoking the compiler recursively:</p>
<ul>
<li>Passing a function as another function's parameter</li>
<li>Assigning functions to variables</li>
<li>Storing functions in collections</li>
<li>Creating new functions from the existing functions at runtime</li>
</ul>
<p>Fortunately, C++ can be used to solve the preceding tasks. We will discuss it in depth in the following topics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing a function as another function's parameter</h1>
                </header>
            
            <article>
                
<p>Let's start to pass a function as the function parameter. We will choose one of four functions and invoke the function from its main function. The code will look like this:</p>
<pre class="mce-root">
    /* first_class_1.cpp */<br/>    #include &lt;functional&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Defining a type of function named FuncType<br/>    // representing a function<br/>    // that pass two int arguments<br/>    // and return an int value<br/>    typedef function&lt;int(int, int)&gt; FuncType;<br/><br/>    int addition(int x, int y)<br/>    {<br/>      return x + y;<br/>    }<br/><br/>    int subtraction(int x, int y)<br/>    {<br/>      return x - y;<br/>    }<br/><br/>    int multiplication(int x, int y)<br/>    {<br/>      return x * y;<br/>    }<br/><br/>    int division(int x, int y)<br/>    {<br/>      return x / y;<br/>    }<br/><br/>    void PassingFunc(FuncType fn, int x, int y)<br/>    {<br/>      cout &lt;&lt; "Result = " &lt;&lt; fn(x, y) &lt;&lt; endl;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[first_class_1.cpp]" &lt;&lt; endl;<br/>      int i, a, b;<br/>      FuncType func;<br/><br/>      // Displaying menu for user<br/>      cout &lt;&lt; "Select mode:" &lt;&lt; endl;<br/>      cout &lt;&lt; "1. Addition" &lt;&lt; endl;<br/>      cout &lt;&lt; "2. Subtraction" &lt;&lt; endl;<br/>      cout &lt;&lt; "3. Multiplication" &lt;&lt; endl;<br/>      cout &lt;&lt; "4. Division" &lt;&lt; endl;<br/>      cout &lt;&lt; "Choice: ";<br/>      cin &gt;&gt; i;<br/><br/>      // Preventing user to select<br/>      // unavailable modes<br/>      if(i &lt; 1 || i &gt; 4)<br/>      {<br/>         cout &lt;&lt; "Please select available mode!";<br/>         return 1;<br/>      }<br/>    <br/>      // Getting input from user for variable a<br/>      cout &lt;&lt; "a -&gt; ";<br/>      cin &gt;&gt; a;<br/><br/>      // Input validation for variable a<br/>      while (cin.fail())<br/>      {<br/>        // Clearing input buffer to restore cin to a usable state<br/>        cin.clear();<br/>        <br/>        // Ignoring last input<br/>        cin.ignore(INT_MAX, '\n');<br/><br/>        cout &lt;&lt; "You can only enter numbers.\n";<br/>        cout &lt;&lt; "Enter a number for variable a -&gt; ";<br/>        cin &gt;&gt; a;<br/>      }<br/><br/>      // Getting input from user for variable b<br/>      cout &lt;&lt; "b -&gt; ";<br/>      cin &gt;&gt; b;<br/><br/>      // Input validation for variable b<br/>      while (cin.fail())<br/>      {<br/>        // Clearing input buffer to restore cin to a usable state<br/>        cin.clear();<br/><br/>        // Ignoring last input<br/>        cin.ignore(INT_MAX, '\n');<br/><br/>        cout &lt;&lt; "You can only enter numbers.\n";<br/>        cout &lt;&lt; "Enter a number for variable b -&gt; ";<br/>        cin &gt;&gt; b;<br/>      }<br/>      switch(i)<br/>      {<br/>        case 1: PassingFunc(addition, a, b); break;<br/>        case 2: PassingFunc(subtraction, a, b); break;<br/>        case 3: PassingFunc(multiplication, a, b); break;<br/>        case 4: PassingFunc(division, a, b); break;<br/>      }<br/><br/>      return 0;<br/>    }
</pre>
<p><span>From the preceding code, we can see that we have four functions, and we want the user to choose one, and then run it. In the switch statement, we will invoke one of the four functions based on the choice of the user. We will pass the selected function to</span> <kbd>PassingFunc()</kbd>, as we can see in the following code snippet:</p>
<pre>
    case 1: <strong>PassingFunc(addition, a, b)</strong>; break;<br/>    case 2: <strong>PassingFunc(subtraction, a, b)</strong>; break;<br/>    case 3: <strong>PassingFunc(multiplication, a, b)</strong>; break;<br/>    case 4: <strong>PassingFunc(division, a, b)</strong>; break;
</pre>
<p>We also have the input validation to prevent the user from selecting unavailable modes as well as inputting a non-integer value for variable <kbd>a</kbd> and <kbd>b</kbd>. The output we will see on the screen should look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/e7a276f3-b116-4d3e-80fd-12b4fe9e197f.png"/></div>
<p class="mce-root">The preceding screenshot shows that we select the <kbd>Multiplication</kbd> mode from the available modes. Then, we try to input the <kbd>r</kbd> and <kbd>e</kbd> variables for variable <kbd>a</kbd>. Fortunately, the program rejects it since we have had the input validation. Then, we give <kbd>4</kbd> to variable <kbd>a</kbd> and <kbd>2</kbd> to variable <kbd>b</kbd>. As we expect, the program gives us <kbd>8</kbd> as a result.</p>
<div class="packt_infobox">As we can see in the <kbd>first_class_1.cpp</kbd> program, we use the <kbd>std::function</kbd> class and the <kbd>typedef</kbd> keyword to simplify the code. The <kbd>std::function</kbd> class is used to <span>store, copy, and invoke any callable</span> <span>functions, Lambda expressions, or</span> <span>other function objects, as well as pointers to member functions and pointers to data members. However, the <kbd>typedef</kbd> keyword is used as an alias name for another type or function.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Assigning a function to a variable</h1>
                </header>
            
            <article>
                
<p>We can also assign a function to the variable so we can call the function by calling the variable. We will refactor <kbd>first_class_1.cpp</kbd>, and it will be as follows:</p>
<pre>
    /* first_class_2.cpp */<br/>    #include &lt;functional&gt;<br/>    #include &lt;iostream&gt;<br/>    <br/>    using namespace std;<br/><br/>    // Defining a type of function named FuncType<br/>    // representing a function<br/>    // that pass two int arguments<br/>    // and return an int value<br/>    typedef function&lt;int(int, int)&gt; FuncType;<br/><br/>    int addition(int x, int y)<br/>    {<br/>      return x + y;<br/>    }<br/><br/>    int subtraction(int x, int y)<br/>    {<br/>      return x - y;<br/>    }<br/><br/>    int multiplication(int x, int y)<br/>    {<br/>      return x * y;<br/>    }<br/><br/>    int division(int x, int y)<br/>    {<br/>      return x / y;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[first_class_2.cpp]" &lt;&lt; endl;<br/><br/>      int i, a, b;<br/>      FuncType func;<br/><br/>      // Displaying menu for user<br/>      cout &lt;&lt; "Select mode:" &lt;&lt; endl;<br/>      cout &lt;&lt; "1. Addition" &lt;&lt; endl;<br/>      cout &lt;&lt; "2. Subtraction" &lt;&lt; endl;<br/>      cout &lt;&lt; "3. Multiplication" &lt;&lt; endl;<br/>      cout &lt;&lt; "4. Division" &lt;&lt; endl;<br/>      cout &lt;&lt; "Choice: ";<br/>      cin &gt;&gt; i;<br/><br/>      // Preventing user to select<br/>      // unavailable modes<br/>      if(i &lt; 1 || i &gt; 4)<br/>      {<br/>        cout &lt;&lt; "Please select available mode!";<br/>        return 1;<br/>      }<br/><br/>      // Getting input from user for variable a<br/>      cout &lt;&lt; "a -&gt; ";<br/>      cin &gt;&gt; a;<br/><br/>      // Input validation for variable a<br/>      while (cin.fail())<br/>      {<br/>        // Clearing input buffer to restore cin to a usable state<br/>        cin.clear();<br/><br/>        // Ignoring last input<br/>        cin.ignore(INT_MAX, '\n');<br/><br/>        cout &lt;&lt; "You can only enter numbers.\n";<br/>        cout &lt;&lt; "Enter a number for variable a -&gt; ";<br/>        cin &gt;&gt; a;<br/>      }<br/><br/>      // Getting input from user for variable b<br/>      cout &lt;&lt; "b -&gt; ";<br/>      cin &gt;&gt; b;<br/><br/>      // Input validation for variable b<br/>      while (cin.fail())<br/>      {<br/>        // Clearing input buffer to restore cin to a usable state<br/>        cin.clear();<br/><br/>        // Ignoring last input<br/>        cin.ignore(INT_MAX, '\n');<br/><br/>        cout &lt;&lt; "You can only enter numbers.\n";<br/>        cout &lt;&lt; "Enter a number for variable b -&gt; ";<br/>        cin &gt;&gt; b;<br/>      }<br/><br/>      switch(i)<br/>      {<br/>        case 1: func = addition; break;<br/>        case 2: func = subtraction; break;<br/>        case 3: func = multiplication; break;<br/>        case 4: func = division; break;<br/>      }<br/>   <br/>      cout &lt;&lt; "Result = " &lt;&lt; func(a, b) &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>We will now assign the four functions based on the user's choice and store the selected function in the <kbd>func</kbd> variable inside the switch statement as follows:</p>
<pre>
    case 1: <strong>func = addition</strong>; break;<br/>    case 2: <strong>func = subtraction</strong>; break;<br/>    case 3: <strong>func = multiplication</strong>; break;<br/>    case 4: <strong>func = division</strong>; break;
</pre>
<p>After the <kbd>func</kbd> variable is assigned with the user's choice, the code will just call the variable like it calls the function, as shown in the following line of code:</p>
<pre>
    cout &lt;&lt; "Result = " &lt;&lt; <strong>func(a, b)</strong> &lt;&lt; endl;
</pre>
<p>And we will then obtain the same output on the console if we run the code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Storing a function in the container</h1>
                </header>
            
            <article>
                
<p>Now, let's save the function to the container. Here, we will use <strong>vector</strong> as the container. The code is written as follows:</p>
<pre class="mce-root">
    /* first_class_3.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;functional&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Defining a type of function named FuncType<br/>    // representing a function<br/>    // that pass two int arguments<br/>    // and return an int value<br/>    typedef function&lt;int(int, int)&gt; FuncType;<br/><br/>    int addition(int x, int y)<br/>    {<br/>      return x + y;<br/>    }<br/><br/>    int subtraction(int x, int y)<br/>    {<br/>      return x - y;<br/>    }<br/><br/>    int multiplication(int x, int y)<br/>    {<br/>      return x * y;<br/>    }<br/><br/>    int division(int x, int y)<br/>    {<br/>      return x / y;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[first_class_3.cpp]" &lt;&lt; endl;<br/><br/>      // Declaring a vector containing FuncType element<br/>      vector&lt;FuncType&gt; functions;<br/><br/>      // Assigning several FuncType elements to the vector<br/>      functions.push_back(addition);<br/>      functions.push_back(subtraction);<br/>      functions.push_back(multiplication);<br/>      functions.push_back(division);<br/><br/>      int i, a, b;<br/>      function&lt;int(int, int)&gt; func;<br/><br/>      // Displaying menu for user<br/>      cout &lt;&lt; "Select mode:" &lt;&lt; endl;<br/>      cout &lt;&lt; "1. Addition" &lt;&lt; endl;<br/>      cout &lt;&lt; "2. Subtraction" &lt;&lt; endl;<br/>      cout &lt;&lt; "3. Multiplication" &lt;&lt; endl;<br/>      cout &lt;&lt; "4. Division" &lt;&lt; endl;<br/>      cout &lt;&lt; "Choice: ";<br/>      cin &gt;&gt; i;<br/><br/>      // Preventing user to select<br/>      // unavailable modes<br/>      if(i &lt; 1 || i &gt; 4)<br/>      {<br/>        cout &lt;&lt; "Please select available mode!";<br/>        return 1;<br/>      }<br/><br/>      // Getting input from user for variable a<br/>      cout &lt;&lt; "a -&gt; ";<br/>      cin &gt;&gt; a;<br/><br/>      // Input validation for variable a<br/>      while (cin.fail())<br/>      {<br/>        // Clearing input buffer to restore cin to a usable state<br/>        cin.clear();<br/><br/>        // Ignoring last input<br/>        cin.ignore(INT_MAX, '\n');<br/><br/>        cout &lt;&lt; "You can only enter numbers.\n";<br/>        cout &lt;&lt; "Enter a number for variable a -&gt; ";<br/>        cin &gt;&gt; a;<br/>      }<br/><br/>      // Getting input from user for variable b<br/>      cout &lt;&lt; "b -&gt; ";<br/>      cin &gt;&gt; b;<br/><br/>      // Input validation for variable b<br/>      while (cin.fail())<br/>      {<br/>        // Clearing input buffer to restore cin to a usable state<br/>        cin.clear();<br/><br/>        // Ignoring last input<br/>        cin.ignore(INT_MAX, '\n');<br/><br/>        cout &lt;&lt; "You can only enter numbers.\n";<br/>        cout &lt;&lt; "Enter a number for variable b -&gt; ";<br/>        cin &gt;&gt; b;<br/>      }<br/><br/>      // Invoking the function inside the vector<br/>      cout &lt;&lt; "Result = " &lt;&lt; functions.at(i - 1)(a, b) &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>From the preceding code, we can see that we create a new vector named functions, then store four different functions to it. Just like we did with our two previous code examples, we ask the user to select the mode as well. However, now the code becomes simpler, since we don't need to add the switch statement; we can select the function directly by selecting the vector index, as we can see in the following code snippet:</p>
<pre>
    cout &lt;&lt; "Result = " &lt;&lt; <strong>functions.at(i - 1)(a, b)</strong> &lt;&lt; endl;
</pre>
<p>However, since the vector is a <strong>zero-based</strong> index, we have to adjust the index with the menu choice. The result will be same with our two previous code samples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new function from the existing functions at runtime</h1>
                </header>
            
            <article>
                
<p>Now let's make a new function at runtime from the preexisting functions. Let's suppose we have two collections of functions, the first is hyperbolic functions and the second is the inverse of the first one. Beside these built-in functions, we also add one user-defined function to calculate the squared number in the first collection and the inverse of the <span>squared number in the second</span> collection. Then, we will implement the function composition and build a new function from two existing functions.</p>
<div class="packt_infobox"><strong>Function composition</strong> is a process to combine two or more simple functions to create a more complex one. The result of each function is passed as the argument to the next function. The final result is obtained from the last function result. In a mathematical approach, we usually use the following notation to function composition: <kbd>compose(f, g) (x) = f(g(x))</kbd>. Let's suppose we have the following code:
<p><kbd><span>double</span> <span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>;</span> <span>// ...</span> <span>y</span> <span>=</span> <span>g</span><span>(</span><span>x</span><span>);</span> <span>z</span> <span>=</span> <span>f</span><span>(</span><span>y</span><span>);</span></kbd></p>
<p>So, to simplify the notation, we can use the function composition and have the following notation for <em>z</em>:</p>
<p><kbd>z = f(g(x));</kbd></p>
</div>
<p>If we run the hyperbolic functions, then pass the result to the inverse one, we will see that we indeed get the original value that we passed to the <span>hyperbolic function. Now, let's take a look at the following code:</span></p>
<pre>
    /* first_class_4.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;cmath&gt;<br/>    #include &lt;algorithm&gt;<br/>    #include &lt;functional&gt;<br/>    #include &lt;iostream&gt;<br/> <br/>    using std::vector;<br/>    using std::function;<br/>    using std::transform;<br/>    using std::back_inserter;<br/>    using std::cout;<br/>    using std::endl;<br/><br/>    // Defining a type of function named HyperbolicFunc<br/>    // representing a function<br/>    // that pass a double argument<br/>    // and return an double value<br/>    typedef function&lt;double(double)&gt; HyperbolicFunc;<br/><br/>    // Initializing a vector containing four functions<br/>    vector&lt;HyperbolicFunc&gt; funcs = {<br/>      sinh,<br/>      cosh,<br/>      tanh,<br/>      [](double x) {<br/>        return x*x; }<br/>    };<br/><br/>    // Initializing a vector containing four functions<br/>    vector&lt;HyperbolicFunc&gt; inverseFuncs = {<br/>      asinh,<br/>      acosh,<br/>      atanh,<br/>      [](double x) {<br/>        return exp(log(x)/2); }<br/>    };<br/><br/>    // Declaring a template to be able to be reused<br/>    template &lt;typename A, typename B, typename C&gt;<br/>    function&lt;C(A)&gt; compose(<br/>      function&lt;C(B)&gt; f,<br/>      function&lt;B(A)&gt; g) {<br/>        return [f,g](A x) {<br/>            return f(g(x));<br/>      };<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[first_class_4.cpp]" &lt;&lt; endl;<br/><br/>      // Declaring a template to be able to be reused<br/>      vector&lt;HyperbolicFunc&gt; composedFuncs;<br/><br/>      // Initializing a vector containing several double elements<br/>      vector&lt;double&gt; nums;<br/>      for (int i = 1; i &lt;= 5; ++i)<br/>        nums.push_back(i * 0.2);<br/> <br/>      // Transforming the element inside the vector<br/>      transform(<br/>        begin(inverseFuncs),<br/>        end(inverseFuncs),<br/>        begin(funcs),<br/>        back_inserter(composedFuncs),<br/>        compose&lt;double, double, double&gt;);<br/><br/>      for (auto num: nums)<br/>      {<br/>        for (auto func: composedFuncs)<br/>            cout &lt;&lt; "f(g(" &lt;&lt; num &lt;&lt; ")) = " &lt;&lt; func(num) &lt;&lt; endl;<br/><br/>        cout &lt;&lt; "---------------" &lt;&lt; endl;<br/>      }<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we have two function collections--<kbd>funcs</kbd> and <kbd>inverseFuncs</kbd>. Moreover, as we discussed previously, the <kbd>inverseFuncs</kbd> <span>function is the inverse of the <kbd>funcs</kbd> function. The <kbd>funcs</kbd> function contains three built-in hyperbolic functions, along with one user-defined function to calculate the squared number, whereas <kbd>inverseFuncs</kbd> contains three built-in inverse hyperbolic functions along with one user-defined function to compute the inverse of the squared number.</span></p>
<div class="packt_infobox">As we can see in the preceding <kbd>first_class_4.cpp</kbd> code, we will use <span>individual classes/functions when calling the <kbd>using</kbd> keyword. Compared to the other code samples in this chapter, the use of the <kbd>using</kbd> keyword in individual classes/functions is inconsistent, since we use <kbd>using namespace std</kbd>. It's because there's a clashing function name in the <kbd>std</kbd> namespace, so we have to call them individually.</span></div>
<p>By using these two collections of functions, we will construct one new function from them. To achieve this purpose, we will use the <kbd>transform()</kbd> function to combine the two functions from the two different collections. The code snippet is as follows:</p>
<pre>
<strong>    transform(</strong><br/><strong>      begin(inverseFuncs), </strong><br/><strong>      inverseFuncs.end(inverseFuncs), </strong><br/><strong>      begin(funcs), </strong><br/><strong>      back_inserter(composedFuncs), </strong><br/><strong>      compose&lt;double, double, double&gt;);</strong>
</pre>
<p>Now, we have a new function collection stored in the <kbd>composedFuncs</kbd> vector. We can iterate the collection and pass the value we have provided in the <kbd>nums</kbd> variable to this new function. We should obtain the following output on the console if we run the code:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/020e5ce8-760c-4446-82c2-7aeca8fddc1a.png"/></div>
<p>As we can see from the preceding output, whatever we pass to the transforming function, we will get the same output as the input. Here, we can prove that C++ programming can be used to compose a function from two or more existing functions.</p>
<div class="packt_infobox">On the preceding <kbd>first_class_4.cpp</kbd> code, we use <kbd>template&lt;&gt;</kbd> in the code. If you need a more detailed explanation about <kbd>template&lt;&gt;</kbd>, refer to <a href="2093af96-36ce-46a4-b90f-ee9876987290.xhtml" target="_blank">Chapter 7</a>, <em>Running Parallel Execution Using Concurrency</em><span class="fontstyle0">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting acquainted with three functional techniques in the higher-order function</h1>
                </header>
            
            <article>
                
<p>We discussed that in the first-class function, the C++ language treats the functions as the value, which means we can pass them to the other functions, assign to variables, and so on. However, we have another term in functional programming, that is, a higher-order function, which are functions that work on other functions. It means the <span>higher-order function can pass</span> functions as the argument and can also return a function.</p>
<p>The higher-order function concept can be applied to the function in general, like in a mathematical function, instead of the first-class function concept that can only be applied in the functional programming language. Now, let's examine the three most useful higher-order functions in functional programming--<strong>map</strong>, <strong>filter</strong>, and <strong>fold</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Executing each element list using map</h1>
                </header>
            
            <article>
                
<p>We won't talk about map as a container in the C++ language, but a feature in the higher-order function instead. This feature is used to apply a given function to each element of the list <span>and return a list of results in the same order</span>. We can use the <kbd>transform()</kbd> function to achieve this purpose. As you know, we already discussed this function previously. However, we can take a look at the following piece of code to view the use of the <kbd>transform()</kbd> function:</p>
<pre class="mce-root">
    /* transform_1.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;algorithm&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[transform_1.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a vector containing integer element<br/>      vector&lt;int&gt; v1;<br/>      for (int i = 0; i &lt; 5; ++i)<br/>        v1.push_back(i);<br/><br/>      // Creating another v2 vector<br/>      vector&lt;int&gt; v2;<br/>      // Resizing the size of v2 exactly same with v1<br/>      v2.resize(v1.size());<br/><br/>      // Transforming the element inside the vector<br/>      transform (<br/>        begin(v1),<br/>        end(v1),<br/>        begin(v2),<br/>        [](int i){<br/>            return i * i;});<br/><br/>      // Displaying the elements of v1<br/>      std::cout &lt;&lt; "v1 contains:";<br/>      for (auto v : v1)<br/>        std::cout &lt;&lt; " " &lt;&lt; v;<br/>      std::cout &lt;&lt; endl;<br/><br/>      // Displaying the elements of v2<br/>      std::cout &lt;&lt; "v2 contains:";<br/>      for (auto v : v2)<br/>        std::cout &lt;&lt; " " &lt;&lt; v;<br/>      std::cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As shown in our preceding definition of map in the higher-order function, it will apply the given function to each element of the list. In the preceding code, we try to map the <kbd>v1</kbd> vector to the <kbd>v2</kbd> vector with the given function in the Lambda expression as follows:</p>
<pre>
<strong>    transform (<br/>      begin(v1), <br/>      end(v1), <br/>      begin(v2), <br/>      [](int i){<br/>        return i * i;});</strong>
</pre>
<p>If we run the code, we should get the following output on the console screen:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/30abb408-577c-4cfd-82c7-8b1030998fc0.png"/></div>
<p>As we can see in the output display, we transform <kbd>v1</kbd> into <kbd>v2</kbd> using the given function notating in the Lambda expression, which is doubling the input value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extracting data using filter</h1>
                </header>
            
            <article>
                
<p>Filter, in a higher-order function, is a function to produce a new data structure from the existing one that exactly matches each element in the new data structure to a given predicate returning a Boolean value. In C++ language, we can apply the <kbd>copy_if()</kbd> function, which is added in C++11, to gain the filtering processes. Let's take a look at the following piece of code to analyze the filtering process using the <kbd>copy_if()</kbd> <span>function:</span></p>
<pre class="mce-root">
    /* filter_1.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;algorithm&gt;<br/>    #include &lt;iterator&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/> <br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[filter_1.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a vector containing integer elements<br/>      vector&lt;int&gt; numbers;<br/>      for (int i = 0; i &lt; 20; ++i)<br/>        numbers.push_back(i);<br/><br/>       // Displaying the elements of numbers<br/>       cout &lt;&lt; "The original numbers: " &lt;&lt; endl;<br/>       copy(<br/>        begin(numbers),<br/>        end(numbers),<br/>        ostream_iterator&lt;int&gt;(cout, " "));<br/>       cout &lt;&lt; endl;<br/><br/>       // Declaring a vector containing int elements<br/>       vector&lt;int&gt; primes;<br/><br/>      // Filtering the vector<br/>      copy_if(<br/>        begin(numbers),<br/>        end(numbers),<br/>        back_inserter(primes),<br/>        [](int n) {<br/>            if(n &lt; 2) {<br/>                return (n != 0) ? true : false;}<br/>            else {<br/>                for (int j = 2; j &lt; n; ++j) {<br/>                    if (n % j == 0){<br/>                        return false;}<br/>            }<br/><br/>            return true;<br/>         }});<br/><br/>        // Displaying the elements of primes<br/>        // using copy() function<br/>        cout &lt;&lt; "The primes numbers: " &lt;&lt; endl;<br/>        copy(<br/>         begin(primes),<br/>         end(primes),<br/>         ostream_iterator&lt;int&gt;(cout, " "));<br/>         cout &lt;&lt; endl;<br/><br/>         return 0;<br/>    }
</pre>
<p>As we see in the preceding code, we filter the <kbd>numbers</kbd> vector into the <kbd>0</kbd> primes vector using the <kbd>copy_if()</kbd> function. We will pass the Lambda expression to decide whether or not the selected element is a prime number, as we used for the <kbd>lambda_multiline_func.cpp</kbd> code in <a href="58c8c3cc-432a-4664-be4d-a78917b16f15.xhtml" target="_blank">Chapter 1</a>, <em>Diving into Modern C++</em>. We will also use the <kbd>copy()</kbd> function to copy all elements in the selected vector to be printed. The result, when we run the preceding code, should be like this:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/84a91b01-5fb5-4111-afaa-c2ca77c868ca.png"/></div>
<p>Beside the <kbd>copy_if()</kbd> function, we can also use the <kbd>remove_copy_if()</kbd> function to filter the data structure. Instead of selecting the match predicate element from the existing data structure, <span>using the</span> <kbd>remove_copy_if()</kbd> <span>function will omit the match predicate element, choose the unmatch one, and store it in the new data structure. Let's refactor our</span> <kbd>filter_1.cpp</kbd> code and create a new vector that is not a prime number. The code will be as follows:</p>
<pre class="mce-root">
    /* filter_2.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;algorithm&gt;<br/>    #include &lt;iterator&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    int main()<br/>   {<br/>      cout &lt;&lt; "[filter_2.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a vector containing integer elements<br/>      vector&lt;int&gt; numbers;<br/>      for (int i = 0; i &lt; 20; ++i)<br/>        numbers.push_back(i);<br/><br/>      // Displaying the elements of numbers<br/>      cout &lt;&lt; "The original numbers: " &lt;&lt; endl;<br/>      copy(<br/>        begin(numbers),<br/>        end(numbers),<br/>        ostream_iterator&lt;int&gt;(cout, " "));<br/>      cout &lt;&lt; endl;<br/><br/>      // Declaring a vector containing int elements<br/>      vector&lt;int&gt; <strong>nonPrimes</strong>;<br/><br/>      // Filtering the vector<br/>      <strong>remove_copy_if</strong>(<br/>        numbers.begin(),<br/>        numbers.end(),<br/>        back_inserter(<strong>nonPrimes</strong>),<br/>        [](int n) {<br/>            if(n &lt; 2){<br/>                return (n != 0) ? true : false;}<br/>            else {<br/>                for (int j = 2; j &lt; n; ++j){<br/>                    if (n % j == 0) {<br/>                        return false;}<br/>            }<br/><br/>            return true;<br/>        }});<br/><br/>      // Displaying the elements of nonPrimes<br/>      // using copy() function<br/>      cout &lt;&lt; "The <strong>non-primes</strong> numbers: " &lt;&lt; endl;<br/>      copy(<br/>        begin(<strong>nonPrimes</strong>),<br/>        end(<strong>nonPrimes</strong>),<br/>        ostream_iterator&lt;int&gt;(cout, " "));<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see from the preceding highlighted code, we refactor the previous code and use the <kbd>remove_copy_if()</kbd> function to choose non-prime numbers. As we expect, the console window will display the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/c0b50b7a-1cfb-48ed-b552-c4bfb806a152.png"/></div>
<p>We now have the non-prime number instead of the prime number, like we have in the <kbd>filter_1.cpp</kbd> code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Combining all elements of a list using fold</h1>
                </header>
            
            <article>
                
<p>In functional programming, a fold is a technique to reduce a data structure into a single value. There are two types of fold--left fold (<kbd>foldl</kbd>) and right fold (<kbd>foldr</kbd>). Let's suppose we have a list that contains 0, 1, 2, 3, and 4. Let's use the fold technique to add all the contents of the list, first using <kbd>foldl</kbd> and then <kbd>foldr</kbd>. However, there is a significant difference between the two--<kbd>foldl</kbd> is the left associative, which means we combine the leftmost element then move towards the rightmost element. For instance, by the list we have, we will get the following parentheses:</p>
<pre>
    ((((0 + 1) + 2) + 3) + 4)
</pre>
<p>While <kbd>foldr</kbd> is the right <span>associative, which means we will combine the rightmost element then move towards the leftmost element. The parentheses will be like the following line of code:</span></p>
<pre>
    (0 + (1 + (2 + (3 + 4))))
</pre>
<p>Now, let's take a look at the following code:</p>
<pre class="mce-root">
    /* fold_1.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;numeric&gt;<br/>    #include &lt;functional&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[fold_1.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a vector containing integer elements<br/>      vector&lt;int&gt; numbers = {0, 1, 2, 3, 4};<br/><br/>      // Calculating the sum of the value<br/>      // in the vector<br/>      auto foldl = accumulate(<br/>        begin(numbers),<br/>        end(numbers),<br/>        0,<br/>        std::plus&lt;int&gt;());<br/><br/>      // Calculating the sum of the value<br/>      // in the vector<br/>      auto foldr = accumulate(<br/>        rbegin(numbers),<br/>        rend(numbers),<br/>        0,<br/>        std::plus&lt;int&gt;());<br/><br/>      // Displaying the calculating result<br/>      cout &lt;&lt; "foldl result = " &lt;&lt; foldl &lt;&lt; endl;<br/>      cout &lt;&lt; "foldr result = " &lt;&lt; foldr &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>In C++ programming, we can apply the <kbd>fold</kbd> technique using the <kbd>accumulate()</kbd> function. As we can see in the preceding code, we use the forward iterator in <kbd>foldl</kbd> while we use the backward iterator in <kbd>foldr</kbd>. The output on the console should be like following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/9cb482af-59c6-4f00-b396-d4fbabd686c9.png"/></div>
<p>As we can see in the preceding output screenshot, we've got the same result for both, the <kbd>foldl</kbd> and <kbd>foldr</kbd> techniques. For those curious about the order of the sum, we can refactor the preceding code into the following one:</p>
<pre class="mce-root">
    /* fold_2.cpp */<br/>    #include &lt;vector&gt;<br/>    #include &lt;numeric&gt;<br/>    #include &lt;functional&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Function for logging the flow<br/>    int addition(const int&amp; x, const int&amp; y)<br/>    {<br/>      cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; endl;<br/>      return x + y;<br/>    }<br/><br/>    int main()<br/>    {<br/>      cout &lt;&lt; "[fold_2.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a vector containing integer elements<br/>      vector&lt;int&gt; numbers = {0, 1, 2, 3, 4};<br/><br/>      // Calculating the sum of the value<br/>      // in the vector<br/>      // from left to right<br/>      cout &lt;&lt; "foldl" &lt;&lt; endl;<br/>      auto foldl = accumulate(<br/>          begin(numbers),<br/>          end(numbers),<br/>          0,<br/>          addition);<br/> <br/>      // Calculating the sum of the value<br/>      // in the vector<br/>      // from right to left<br/>      cout &lt;&lt; endl &lt;&lt; "foldr" &lt;&lt; endl;<br/>      auto foldr = accumulate(<br/>          rbegin(numbers),<br/>          rend(numbers),<br/>          0,<br/>          addition);<br/><br/>      cout &lt;&lt; endl;<br/><br/>      // Displaying the calculating result<br/>      cout &lt;&lt; "foldl result = " &lt;&lt; foldl &lt;&lt; endl;<br/>      cout &lt;&lt; "foldr result = " &lt;&lt; foldr &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>In the preceding code, we pass a new <kbd>addition()</kbd> function and pass it to the <kbd>accumulate()</kbd> function. From the <kbd>addition()</kbd> function, we will track the operation of each element. Now, let's run the preceding code whose the output will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="248" src="assets/5b662182-a4b8-4a3f-a969-29983904dcbb.png" width="503"/></div>
<p>From the preceding output screenshot, we can see that, even though both <kbd>foldl</kbd> and <kbd>foldr</kbd> give the exact same result, they make a different operation order. Since we set the initial value to <kbd>0</kbd>, the addition operation starts by adding <kbd>0</kbd> to the first element in the <kbd>foldl</kbd> technique and to the last element in the <kbd>foldr</kbd> technique.</p>
<div class="packt_tip">We will set the initial value to <kbd>0</kbd> because <kbd>0</kbd> is the additive identity that won't impact the addition result. However, in multiplication, we have to consider changing the initial value to <kbd>1</kbd> since <kbd>1</kbd> is the identity element for multiplication.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Avoiding the side effect with pure function</h1>
                </header>
            
            <article>
                
<p>A <strong>pure function</strong> is a function that will always return the same result every time it is given the same input. The result doesn't depend on any information or state and won't produce a <strong>side effect</strong>, or <span>a change of the system state outside of the function. Let's take a look at the following piece of code:</span></p>
<pre class="mce-root">
    /* pure_function_1.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    float circleArea(float r)<br/>    {<br/>      return 3.14 * r * r;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[pure_function_1.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a float variable<br/>      float f = 2.5f;<br/><br/>      // Invoking the circleArea() function<br/>      // passing the f variable five times<br/>      for(int i = 1; i &lt;= 5; ++i)<br/>      {<br/>        cout &lt;&lt; "Invocation " &lt;&lt; i &lt;&lt; " -&gt; ";<br/>        cout &lt;&lt; "Result of circleArea(" &lt;&lt; f &lt;&lt; ") = ";<br/>        cout &lt;&lt; circleArea(f) &lt;&lt; endl;<br/>      }<br/><br/>      return 0;<br/>    }
</pre>
<p>From the preceding code, we can see that we have a function named <kbd>circleArea()</kbd> to calculate the area of a circle based on the given radius. We then invoke the function five times and pass the same radius value. The output on the console should be like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/363316b8-632e-4346-a2f6-50003c5a8c14.png"/></div>
<p>As we can see, in five invocations passing the same input, the function returns the same output as well. So that we can say that <kbd>circleArea()</kbd> <span>is a pure function. Now, let's see how the impure function looks like in the following piece of code:</span></p>
<pre class="mce-root">
    /* impure_function_1.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Initializing a global variable<br/>    int currentState = 0;<br/><br/>    int increment(int i)<br/>    {<br/>      currentState += i;<br/>      return currentState;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[impure_function_1.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a local variable<br/>      int fix = 5;<br/><br/>      // Involving the global variable<br/>      // in the calculation<br/>      for(int i = 1; i &lt;= 5; ++i)<br/>      {<br/>        cout &lt;&lt; "Invocation " &lt;&lt; i &lt;&lt; " -&gt; ";<br/>        cout &lt;&lt; "Result of increment(" &lt;&lt; fix &lt;&lt; ") = ";<br/>        cout &lt;&lt; increment(fix) &lt;&lt; endl;<br/>      }<br/><br/>       return 0;<br/>    }
</pre>
<p>In the preceding code, we see that a function named <kbd>increment()</kbd> increases the value of the <kbd>currentState</kbd> variable. As we can see, the <kbd>increment()</kbd> <span>function depends on the value of the <kbd>currentState</kbd> variable, so it's not a pure function. Let's prove it by running the preceding code. The console window should display the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/d0f1d544-925c-447a-9780-1ae4db9ca6f1.png"/></div>
<p>We see that the <kbd>increment()</kbd> function gives a different result even though we pass the same input. It's the side effect of the impure function when it depends on the outside state or changes the value of the outside state.</p>
<p>We have been able to distinguish the pure function over the impure function. However, consider the following code:</p>
<pre class="mce-root">
    /* im_pure_function_1.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Initializing a global variable<br/>    float phi = 3.14f;<br/><br/>    float circleArea(float r)<br/>    {<br/>      return phi * r * r;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[im_pure_function_1.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a float variable<br/>      float f = 2.5f;<br/><br/>      // Involving the global variable<br/>      // in the calculation<br/>      for(int i = 1; i &lt;= 5; ++i)<br/>      {<br/>        cout &lt;&lt; "Invocation " &lt;&lt; i &lt;&lt; " -&gt; ";<br/>        cout &lt;&lt; "Result of circleArea(" &lt;&lt; f &lt;&lt; ") = ";<br/>        cout &lt;&lt; circleArea(f) &lt;&lt; endl;<br/>      }<br/><br/>      return 0;<br/>    }
</pre>
<p>The preceding code comes from <kbd>pure_function_1.cpp</kbd>, but we add a global state, <kbd>phi</kbd>. If we run the preceding code, we will definitely obtain the same result as <kbd>pure_function_1.cpp</kbd>. Although the function returns the same result in the five invocations, <kbd>circleArea()</kbd> in <kbd>im_pure_function_1.cpp</kbd> is not a pure function since it depends on the <kbd>phi</kbd> variable.</p>
<div class="packt_infobox">The side effect is not only the change of global state that is done by the function. Printing to the screen is also the side effect. However, since we need to show the result of every code we create, we cannot avoid the existence of printing to screen in our codes. In the next chapter, we will also discuss the immutable state, which is the way we can turn an impure function into a pure function.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reducing a multiple arguments function with currying</h1>
                </header>
            
            <article>
                
<p>Currying is a technique to split a function that takes multiple arguments into evaluating a sequence of functions, each with a single argument. In other words, we create other functions based on a current function by reducing the current function. Let's suppose we have a function named <kbd>areaOfRectangle()</kbd>, which takes two parameters, <kbd>length</kbd> and <kbd>width</kbd>. The code will be like this:</p>
<pre>
    /* curry_1.cpp */<br/><br/>    #include &lt;functional&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Variadic template for currying<br/>    template&lt;typename Func, typename... Args&gt;<br/>    auto curry(Func func, Args... args)<br/>    {<br/>      return [=](auto... lastParam)<br/>      {<br/>        return func(args..., lastParam...);<br/>      };<br/>    }<br/><br/>    int areaOfRectangle(int length, int width)<br/>    {<br/>      return length * width;<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[curry_1.cpp]" &lt;&lt; endl;<br/><br/>      // Currying the areaOfRectangle() function<br/>      auto length5 = curry(areaOfRectangle, 5);<br/><br/>      // Invoking the curried function<br/>      cout &lt;&lt; "Curried with spesific length = 5" &lt;&lt; endl;<br/>      for(int i = 0; i &lt;= 5; ++i)<br/>      {<br/>        cout &lt;&lt; "length5(" &lt;&lt; i &lt;&lt; ") = ";<br/>        cout &lt;&lt; length5(i) &lt;&lt; endl;<br/>      }<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we have a variadic template and function named <kbd>curry</kbd>. We will use this template to construct a currying function. In a normal function invocation, we can invoke the <kbd>areaOfRectangle()</kbd> function as follows:</p>
<pre>
    int i = areaOfRectangle(5, 2);
</pre>
<p>As we can see in the preceding code snippet, we pass <kbd>5</kbd> and <kbd>2</kbd> as the argument to the <span><kbd>areaOfRectangle()</kbd> function. However, using the curried function, we can reduce the <kbd>areaOfRectangle()</kbd> function so we just have a single argument. All we have to do is invoke the curry function template as follows:</span></p>
<pre>
<strong>    auto length5 = curry(areaOfRectangle, 5);</strong>
</pre>
<p>Now, we have the <kbd>areaOfRectangle()</kbd> <span>function having the value for the <kbd>length</kbd> argument named <kbd>length5</kbd>. It's easier for us to call the function and add just the <kbd>width</kbd> argument as the following code snippet:</span></p>
<pre>
<strong>    length5(i)</strong> // where i is the width parameter we want to pass
</pre>
<p>Let's take a look at the output we will see on the console when we run the preceding code:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/1097f10c-3b57-448c-8d71-fc69bf9f4918.png"/></div>
<p>The variadic template and function has helped us reduce the <kbd>areaOfRectangle()</kbd> <span>function to become the <kbd>length5()</kbd> function. However, it can also help us reduce the function that has more than two arguments. Let's suppose we have a function named <kbd>volumeOfRectanglular()</kbd> that passes three arguments. We will reduce the function as well, as shown in the following code:</span></p>
<pre class="mce-root">
    /* curry_2.cpp */<br/><br/>    #include &lt;functional&gt;<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // Variadic template for currying<br/>    template&lt;typename Func, typename... Args&gt;<br/>    auto curry(Func func, Args... args)<br/>    {<br/>      return [=](auto... lastParam)<br/>      {<br/>        return func(args..., lastParam...);<br/>      };<br/>    }<br/><br/>    int volumeOfRectanglular(<br/>      int length,<br/>      int width,<br/>      int height)<br/>     {<br/>        return length * width * height;<br/>     }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[curry_2.cpp]" &lt;&lt; endl;<br/><br/>      // Currying the volumeOfRectanglular() function<br/>      auto length5width4 = curry(volumeOfRectanglular, 5, 4);<br/><br/>      // Invoking the curried function<br/>      cout &lt;&lt; "Curried with spesific data:" &lt;&lt; endl;<br/>      cout &lt;&lt; "length = 5, width 4" &lt;&lt; endl;<br/>      for(int i = 0; i &lt;= 5; ++i)<br/>      {<br/>        cout &lt;&lt; "length5width4(" &lt;&lt; i &lt;&lt; ") = ";<br/>        cout &lt;&lt; length5width4(i) &lt;&lt; endl;<br/>      }<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we have successfully passed the <kbd>length</kbd> and <kbd>width</kbd> arguments to the <kbd>volumeOfRectanglular()</kbd> function only, then reduced it as <kbd>length5width4()</kbd>. We can invoke the <kbd>length5width4()</kbd> <span>function and just pass the rest argument, <kbd>height</kbd>, to it. The following is the output we will see on the console screen if we run the preceding code:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/dbbc74e9-74e1-4a84-af5e-59a4b8494f0c.png"/></div>
<p>By using the currying technique, we can partially evaluate a multiple arguments function by reducing the function so it will only pass a single parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We have discussed that there are some techniques to manipulate a function. We will gain many advantages from it. Since we can implement the first-class function in the C++ language, we can pass a function as another function's parameter. We can treat a function as a data object so we can assign it to a variable and store it in the container. Also, we can compose a new function from the existing one. Moreover, by using map, filter, and fold, we can implement the higher-order function in every function we create.</p>
<p>Another technique we have to implement in gaining a better functional code is a pure function to avoid a side effect. We can refactor all the functions we have so it won't talk to outside variables or states and won't change and retrieve the value from the outside state. Also, to reduce the multiple arguments function so we can evaluate its sequence, we can implement the currying technique to our function.</p>
<p>In the next chapter, we will discuss another technique to avoid side effects. We will make all states in our code immutable so there's no state that will mutate each time the function is invoked.</p>


            </article>

            
        </section>
    </body></html>