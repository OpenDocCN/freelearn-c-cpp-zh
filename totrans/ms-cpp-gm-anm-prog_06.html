<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer058" class="Basic-Text-Frame">
    <h1 class="chapterNumber">4</h1>
    <h1 id="_idParaDest-111" class="chapterTitle">Enhancing Application Handling</h1>
    <p class="normal">Welcome to <a href=""><em class="italic">Chapter 4</em></a>! In the previous chapter, we added capabilities for a better selection of a single instance among a possibly large number of models and instances. We started with a simple “move to” function and added a highlight to the current instance as the next step. Then, we implemented a visual selection by using the mouse. Finally, we created a null object to allow selecting no instance at all.</p>
    <p class="normal">In this chapter, we will focus on the edit mode. First, we will add the capability to switch off all controls and menus by creating a separate view mode. The split between edit and view modes will help us in later chapters to stop all automatic actions when we configure instance settings. Next, we will implement a simplified version of the undo functionality, allowing us to reset the settings of a model instance after applying changes. As the last step, we will implement undo and redo of setting changes on the instance level.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Switching between edit and view modes</li>
      <li class="bulletList">Reverting changes before applying</li>
      <li class="bulletList">Implementing undo and redo functionality</li>
    </ul>
    <h1 id="_idParaDest-112" class="heading-1">Technical requirements</h1>
    <p class="normal">The example source code for this chapter is in the <code class="inlineCode">chapter04</code> folder, in the <code class="inlineCode">01_opengl_edit_view_mode</code> subfolder for OpenGL and <code class="inlineCode">02_vulkan_edit_view_mode</code> for Vulkan.</p>
    <p class="normal">After making instance selection easy in <a href="Chapter_3.xhtml"><em class="italic">Chapter 3</em></a>, changing the settings of an instance will be the next topic to tackle. Right now, we have a Control menu on the screen, capturing the mouse input if the pointer is placed over the ImGui window. Any change we make will remain permanent in the current application session. Reverting any accidental rotation or scaling to the exact same value as before could be very difficult since we would have to memorize the previous values to undo the change.</p>
    <p class="normal">We will now change the application to toggle to a mode without any controls or selection and add a rather simple but useful undo and redo functionality to roll changes to instances back or forward.</p>
    <h1 id="_idParaDest-113" class="heading-1">Switching between edit and view modes</h1>
    <p class="normal">If we start the current version <a id="_idIndexMarker151"/>of the application, we will see that a large part of the screen is blocked by the user interface whenever we want to make changes to<a id="_idIndexMarker152"/> instances.</p>
    <p class="normal"><em class="italic">Figure 4.1</em> shows what the user interface window looks like when all headers are expanded:</p>
    <figure class="mediaobject"><img src="../Images/Figure_4.1_B22428.png" alt="" width="1647" height="1116"/></figure>
    <p class="packt_figref">Figure 4.1: User interface blocking parts of the screen</p>
    <p class="normal">As more and more options will be added later in the book, the user interface may fill up even more of the available window space. In addition, a selected instance will blink if the highlight is active and the coordinate arrows are placed below it.</p>
    <p class="normal">To change the overall appearance, we must check which features should be disabled in a separate view mode.</p>
    <h2 id="_idParaDest-114" class="heading-2">Deciding what should be switched in view mode</h2>
    <p class="normal">Our main goal for this section is to remove the ImGui <strong class="screenText">Control</strong> window to have the full application available for interacting <a id="_idIndexMarker153"/>with the model instances. We could just switch off the rendering of the user interface, but if we do not show the user interface window, there is no need to do any calculations like the timer and FPS updates. So, for the first decision, we will skip the user interface in the <strong class="screenText">View mode</strong>.</p>
    <p class="normal">We must also add a shortcut to avoid forwarding mouse button events to ImGui when the user interface is not active. ImGui saves the positions of all control elements, and we would still get unwanted side effects, like being unable to move the camera if we switch the user interface while the mouse pointer is above the ImGui window.</p>
    <p class="normal">Even without a user interface, all parts related to the instance selection are still active. This means we do not need the instance selection in view mode, since there is no way to adjust instance parameters without a user interface. Our second decision here is to switch off everything connected to the instance selection. We will disable mouse picking, including the selection shaders, the coordinate arrows, and the highlight calculation.</p>
    <p class="normal">We will also adjust the window title, reflecting the current view/edit state of the application. Changing the window <a id="_idIndexMarker154"/>properties from the renderer requires a bit of callback “magic” but helps to immediately see what mode the application is in.</p>
    <p class="normal">The implementation of most of the switch of view and edit mode is simple. We just need a variable to save the current state, and some of the branches to enable or disable above specified operations for the two modes.</p>
    <h2 id="_idParaDest-115" class="heading-2">Adding the state variable plus code</h2>
    <p class="normal">As the first implementation<a id="_idIndexMarker155"/> step, we create a new <code class="inlineCode">enum</code> class named <code class="inlineCode">appMode</code> in the <code class="inlineCode">OGLRenderData.h</code> file in the <code class="inlineCode">opengl</code> folder:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">enum class</span> <span class="hljs-title">appMode</span> {
  edit = <span class="hljs-number">0</span>,
  view
};
</code></pre>
    <p class="normal">For the Vulkan renderer, the <code class="inlineCode">appMode</code> <code class="inlineCode">enum</code> class will reside in the <code class="inlineCode">VkRenderData.h</code> file in the <code class="inlineCode">vulkan</code> folder.</p>
    <p class="normal">In addition, a variable named <code class="inlineCode">rdApplicationMode</code> must be added to the <code class="inlineCode">OGLRenderData</code> struct for the OpenGL renderer, and the respective <code class="inlineCode">VkRenderData</code> struct for the Vulkan renderer:</p>
    <pre class="programlisting code"><code class="hljs-code">  appMode rdApplicationMode = appMode::edit;
</code></pre>
    <p class="normal">We initialize <code class="inlineCode">rdApplicationMode</code> with the value for the edit mode, avoiding visible changes to the application functionality at startup.</p>
    <p class="normal">To enable or disable a feature in the renderer, depending on the mode, we can simply check the value of the <code class="inlineCode">rdApplicationMode</code> variable:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span> (mRenderData.rdApplicationMode == appMode::edit) {
    ...
  }
</code></pre>
    <p class="normal">For example, to switch between the animated shader with and without selection support, the following lines are used:</p>
    <pre class="programlisting code"><code class="hljs-code">      <span class="hljs-keyword">if</span> (mMousePick &amp;&amp;
          mRenderData.rdApplicationMode == appMode::edit) {
        mAssimpSkinningSelectionShader.<span class="hljs-built_in">use</span>();
      } <span class="hljs-keyword">else</span> {
        mAssimpSkinningShader.<span class="hljs-built_in">use</span>();
      }
</code></pre>
    <p class="normal">To disable rendering of<a id="_idIndexMarker156"/> the user interface in view mode, we surround the <code class="inlineCode">render()</code> call to the user interface in the renderer with a check for the application mode:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span> (mRenderData.rdApplicationMode == appMode::edit) {
    mUIDrawTimer.<span class="hljs-built_in">start</span>();
    mUserInterface.<span class="hljs-built_in">render</span>();
    mRenderData.rdUIDrawTime = mUIDrawTimer.<span class="hljs-built_in">stop</span>();
  }
</code></pre>
    <p class="normal">We disable the timer calls in view mode too – without a user interface on screen, filling the timer values would be a waste of computing power.</p>
    <p class="normal">Switching from edit to view mode and back will be done by pressing a hotkey. We cannot use an ImGui button here if we disable the user interface completely since we would need the button to toggle back to edit mode.</p>
    <h2 id="_idParaDest-116" class="heading-2">Toggling between the two modes and changing the title</h2>
    <p class="normal">For the mode switch, a simple <a id="_idIndexMarker157"/>check for the <code class="inlineCode">F10</code> key is done<a id="_idIndexMarker158"/> in the <code class="inlineCode">handleKeyEvents()</code> method of the renderer:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(mRenderData.rdWindow, GLFW_KEY_F10) ==
      GLFW_PRESS) {
    mRenderData.rdApplicationMode =
      mRenderData.rdApplicationMode == appMode::edit ?
      appMode::view : appMode::edit;
    <span class="hljs-built_in">setModeInWindowTitle</span>();
  }
</code></pre>
    <p class="normal">Any other unused key can be achieved by placing the respective GLFW key name as the second parameter into the <code class="inlineCode">glfwGetKey()</code> call.</p>
    <p class="normal">The call to <code class="inlineCode">setModeInWindowTitle()</code> needs further explanation, as we are using callback functions to change the title string of our application window. The function call itself is short and simple:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">OGLRenderer::setModeInWindowTitle</span><span class="hljs-params">()</span><span class="hljs-function"> </span>{
  <span class="hljs-keyword">if</span> (mRenderData.rdApplicationMode == appMode::edit) {
    <span class="hljs-built_in">setWindowTitle</span>(mOrigWindowTitle + <span class="hljs-string">" (Edit Mode)"</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">setWindowTitle</span>(mOrigWindowTitle + <span class="hljs-string">" (View Mode)"</span>);
  }
}
</code></pre>
    <p class="normal">We save the original window title in the <code class="inlineCode">init()</code> method of the renderer, and append the default mode (<strong class="screenText">Edit mode</strong>) to the window title:</p>
    <pre class="programlisting code"><code class="hljs-code">  mOrigWindowTitle = <span class="hljs-built_in">getWindowTitle</span>();
  <span class="hljs-built_in">setModeInWindowTitle</span>();
</code></pre>
    <p class="normal">Since the Window class initializes the renderer class, we have to move the window title change request backward, from the renderer<a id="_idIndexMarker159"/> to the application window.</p>
    <p class="normal">First, two <code class="inlineCode">std::function</code> aliases are <a id="_idIndexMarker160"/>created in the renderer header file, <code class="inlineCode">OGLRenderer.h</code> for OpenGL and <code class="inlineCode">VkRenderer.h</code> for Vulkan:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">using</span> GetWindowTitleCallback =
  std::function&lt;std::<span class="hljs-built_in">string</span>(<span class="hljs-type">void</span>)&gt;;
<span class="hljs-keyword">using</span> SetWindowTitleCallback =
  std::function&lt;<span class="hljs-built_in">void</span>(std::string)&gt;
</code></pre>
    <p class="normal">We also add two <code class="inlineCode">public</code> methods to the declaration of our renderer:</p>
    <pre class="programlisting code"><code class="hljs-code">    SetWindowTitleCallback setWindowTitle;
    GetWindowTitleCallback getWindowTitle;
</code></pre>
    <p class="normal">Using the aliases makes it easier to handle the calls to <code class="inlineCode">std::function</code>.</p>
    <p class="normal">Next, we create two methods matching the callback signatures in the <code class="inlineCode">Window</code> class header file, <code class="inlineCode">window.h</code>, in the <code class="inlineCode">window</code> folder:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-function">std::string </span><span class="hljs-title">getWindowTitle</span><span class="hljs-params">()</span>;
    <span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">setWindowTitle</span><span class="hljs-params">(std::string newTitle)</span>;
</code></pre>
    <p class="normal">In addition, a <code class="inlineCode">private</code> member variable named <code class="inlineCode">mWindowTitle</code> is added, storing the current title of the window:</p>
    <pre class="programlisting code"><code class="hljs-code">    std::string mWindowTitle;
</code></pre>
    <p class="normal">Storing the window title in a variable may be handy for debugging log prints.</p>
    <p class="normal">Then, right after initializing the renderer in the <code class="inlineCode">init()</code> method of the <code class="inlineCode">Window</code> class, two lambda functions are used to forward the <code class="inlineCode">Window</code> class function calls to the renderer:</p>
    <pre class="programlisting code"><code class="hljs-code">  mRenderer-&gt;getWindowTitle = [<span class="hljs-keyword">this</span>]()
    { <span class="hljs-keyword">return</span> <span class="hljs-built_in">getWindowTitle</span>(); };
  mRenderer-&gt;setWindowTitle = [<span class="hljs-keyword">this</span>](std::string
    windowTitle) { <span class="hljs-built_in">setWindowTitle</span>(windowTitle); };
</code></pre>
    <p class="normal">When we press <code class="inlineCode">F10</code> now, the renderer appends a mode string to the original window title and forwards the created string via callback to the Window class. This way, the current application mode is presented in the title text of <a id="_idIndexMarker161"/>the application window.</p>
    <p class="normal">In <em class="italic">Figure 4.2</em>, the user interface and the selection have been disabled. Check the window title to see the current mode:</p>
    <figure class="mediaobject"><img src="../Images/Figure_4.2_B22428.png" alt="" width="1631" height="1143"/></figure>
    <p class="packt_figref">Figure 4.2: No user interface in view mode</p>
    <p class="normal">Without the user<a id="_idIndexMarker162"/> interface window in view mode, the entire application window can be used to fly around in the virtual world. By pressing <em class="italic">F10</em>, we can go back to the edit mode to adjust the parameters of the model instances.</p>
    <h2 id="_idParaDest-117" class="heading-2">An outlook for future changes</h2>
    <p class="normal">For every new feature we add later in <a id="_idIndexMarker163"/>the book, we must decide how to handle the feature in edit and view mode. Some of the new features are only feasible in edit mode, like adding and configuring different cameras in <a href="Chapter_6.xhtml"><em class="italic">Chapter 6</em></a>. Using the cameras, on the other hand, is best done in view mode since we only need to switch between different cameras when roaming through the virtual world we created. We will have to think about the usage of a new feature every time.</p>
    <p class="normal">After adding a separate view mode, let’s go back to the basic application handling. Whenever we select an instance and change one of the settings, we are stuck with the new value, without a proper way to reset the instance state to a “last known good” setting. In the next section, we will add a basic mechanism to revert at least the last change to a model instance.</p>
    <h1 id="_idParaDest-118" class="heading-1">Reverting changes before applying</h1>
    <p class="normal">The main purpose of the<a id="_idIndexMarker164"/> current model viewer application is to view model instances. But, next to pure model viewing, adjusting instance properties and settings will become a larger part of the application throughout the book. And changing settings can go wrong in many ways. A solution to preview a change sounds like a good feature to add.</p>
    <h2 id="_idParaDest-119" class="heading-2">The basic idea</h2>
    <p class="normal">A simple rollback method would allow us to accept a change to the instance setting, or to revert the same settings to the previous values. We could experiment with the values, try to move the instance to the<a id="_idIndexMarker165"/> correct destination, or adjust other parameters to fit our needs. When we are happy with the result, we push the <strong class="screenText">Apply</strong> button, and the instance settings are made permanent. The same workflow can be used for the next instance, and so on, until we have placed all instances in the way we imagined.</p>
    <h2 id="_idParaDest-120" class="heading-2">Adding code and User Interface elements</h2>
    <p class="normal">First, we add two new <code class="inlineCode">private</code> members<a id="_idIndexMarker166"/> to the <code class="inlineCode">UserInterface.h</code> header file of the <code class="inlineCode">UserInterface</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">    std::shared_ptr&lt;AssimpInstance&gt; mCurrentInstance;
    InstanceSettings mSavedInstanceSettings{};
</code></pre>
    <p class="normal">In the <code class="inlineCode">mCurrentInstance</code> smart pointer, we store the currently selected instance, and in the <code class="inlineCode">mSavedInstanceSettings</code> variable, we will save the original settings of the currently selected instance.</p>
    <p class="normal">Since we are retrieving the current instance several times in the user interface, we can simply remove the <code class="inlineCode">currentInstance</code> declaration in all other places within the <code class="inlineCode">CollapsingHeader</code> block.</p>
    <p class="normal">Reading the settings of the currently selected instance stays the same:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> (numberOfInstances &gt; <span class="hljs-number">0</span>) {
      settings = modInstData.miAssimpInstances.<span class="hljs-built_in">at</span>(
        modInstData.miSelectedInstance)
        -&gt;<span class="hljs-built_in">getInstanceSettings</span>();
</code></pre>
    <p class="normal">But, in addition, we also check if the currently selected instance is different compared to the new <code class="inlineCode">mCurrentInstance</code> pointer:</p>
    <pre class="programlisting code"><code class="hljs-code">      <span class="hljs-keyword">if</span> (mCurrentInstance !=
          modInstData.miAssimpInstances.<span class="hljs-built_in">at</span>(
          modInstData.miSelectedInstance)) {
        mSavedInstanceSettings = settings;
        mCurrentInstance =
          modInstData.miAssimpInstances.<span class="hljs-built_in">at</span>(
          modInstData.miSelectedInstance);
      }
    }
</code></pre>
    <p class="normal">Whenever the current instance changes, we store the new selected instance in the <code class="inlineCode">mCurrentInstance</code> pointer, and we also save the instance settings we just retrieved in the <code class="inlineCode">mSavedInstanceSettings</code> variable.</p>
    <p class="normal">The <code class="inlineCode">mSavedInstanceSetting</code> variable enables us now to revert the settings of the instance, undoing any changes. To toggle the setting revert, we add a new button named <code class="inlineCode">Reset Values to Previous</code> below the existing <code class="inlineCode">Reset Values to Zero</code> button:</p>
    <pre class="programlisting code"><code class="hljs-code">    ImGui::<span class="hljs-built_in">SameLine</span>();
    <span class="hljs-keyword">if</span> (ImGui::<span class="hljs-built_in">Button</span>(<span class="hljs-string">"Reset Values to Previous"</span>)) {
        settings = mSavedInstanceSettings;
    }
</code></pre>
    <p class="normal">To undo any changes, we copy the saved instance settings back to the current settings variable. At the end of the <code class="inlineCode">CollapsingHeader</code> <strong class="screenText">Instances</strong>, the values in settings are saved to the currently selected instance. Et voilà, we<a id="_idIndexMarker167"/> have reverted the settings to the state when we selected the instance.</p>
    <p class="normal">Applying the changes just does the copy operation the other way around:</p>
    <pre class="programlisting code"><code class="hljs-code">    ImGui::<span class="hljs-built_in">SameLine</span>();
    <span class="hljs-keyword">if</span> (ImGui::<span class="hljs-built_in">Button</span>(<span class="hljs-string">"Apply Changes"</span>)) {
      mSavedInstanceSettings = settings;
    }
</code></pre>
    <p class="normal">Here, the saved settings are overwritten by the current settings of the instance, making the current settings the new default for an undo operation.</p>
    <p class="normal"><em class="italic">Figure 4.3</em> shows the location of the two new buttons:</p>
    <figure class="mediaobject"><img src="../Images/Figure_4.3_B22428.png" alt="" width="1642" height="1334"/></figure>
    <p class="packt_figref">Figure 4.3: Button to revert instance settings, respectively doing a permanent apply</p>
    <p class="normal">By using the <strong class="screenText">Apply Changes</strong> button, the current changes to the model instance are made permanent. And with the <strong class="screenText">Reset Values to Previous</strong> button, we can revert any changes to the instance to the state when we<a id="_idIndexMarker168"/> pressed <strong class="screenText">Apply Changes</strong> before.</p>
    <h2 id="_idParaDest-121" class="heading-2">Drawbacks of the current solution</h2>
    <p class="normal">Using two buttons to apply or revert every instance setting change is time-consuming and cumbersome. A version that applies the changes automatically and more often would generate a much better workflow while <a id="_idIndexMarker169"/>editing instance properties. The general idea from this section will be kept; we just add some more automatic behavior.</p>
    <p class="normal">Let’s create a real-world undo and redo solution.</p>
    <h1 id="_idParaDest-122" class="heading-1">Implementing undo and redo functionality</h1>
    <p class="normal">Nearly every application has some way to undo one operation or more, and many applications also allow a redo <a id="_idIndexMarker170"/>of reverted steps. Accidents <a id="_idIndexMarker171"/>can happen in both ways; undoing an<a id="_idIndexMarker172"/> unwanted undo can save a lot of time and stress for the user.</p>
    <h2 id="_idParaDest-123" class="heading-2">What do we need to create undo and redo?</h2>
    <p class="normal">To be able to undo a simple operation that changes object properties, we need to save the previous values. Undoing that change could then be done by applying the “old” values to the same object, and restoring the state of that object before the change.</p>
    <p class="normal">For more complex undo operations, storing the operation type is also required. If we delete something, the undo step must recreate the object with the same properties, and vice versa – undoing the creation of a new object will delete that object.</p>
    <p class="normal">Other options could be also taken into account. Do we want to store the absolute previous values or just the difference to the new values? By storing relative values, redoing the changes that followed the reverted operation<a id="_idIndexMarker173"/> could use the adjusted values as a basis, while absolute values would overwrite<a id="_idIndexMarker174"/> intermitted adjustments. And do we store the complete settings for that object, or only the changed parameter(s)? The implication is similar to the absolute and relative values before.</p>
    <p class="normal">From a technical side, our implementation will use two stacks: one for the possible undo operations and another for the possible redo operations. Every configuration change will push the new and the old settings to the undo stack, allowing the reversal of the changes by applying the old settings.</p>
    <p class="normal">After the undo operation has been done, the very same setting combination will be taken from the undo stack and pushed to the redo stack. If we now do a redo of the same operation, the new settings will be applied, and the settings will be moved back to the undo stack.</p>
    <p class="normal">This simple workflow will allow us a virtually endless undo and redo size, limited mostly by the amount of memory in the computer. And, since the settings are small, it would take a very long time to fill up the computer memory with the two stacks.</p>
    <p class="normal">As the first step on the road to undo and redo, we will create a storage container class that encapsulates all the information we need to revert the settings in one or the other direction.</p>
    <h2 id="_idParaDest-124" class="heading-2">Creating a setting storage class</h2>
    <p class="normal">The new class is called <code class="inlineCode">AssimpSettingsContainer</code>, and the header and implementation file are in the model folder. In the<a id="_idIndexMarker175"/> header file, a struct is declared to store all the settings we need for both undo and redo:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span> <span class="hljs-title">AssimpInstanceSettings</span> {
  std::weak_ptr&lt;AssimpInstance&gt; aisInstance;
  InstanceSettings aisInstanceSettings{};
  InstanceSettings aisSavedInstanceSettings{};
};
</code></pre>
    <p class="normal">The <code class="inlineCode">AssimpInstanceSettings</code> struct saves the previous and current settings of an instance, along with a weak pointer to the instance. Using <code class="inlineCode">std::weak_ptr</code> instead of <code class="inlineCode">std::shared_ptr</code> here has two important reasons:</p>
    <ul>
      <li class="bulletList">A weak pointer breaks the dependency between the <code class="inlineCode">miAssimpInstances</code> vector containing the instance <code class="inlineCode">std::shared_ptr</code> and the settings stored for undo/redo because a weak pointer is not added to the reference counter of the smart pointer for the instance. If we use another shared pointer when storing the undo/redo information instead, the memory for a deleted instance may not be freed, since there could be another active reference to the instance stored somewhere in the undo or redo stack.</li>
      <li class="bulletList">When requesting the weak pointer to return the shared pointer by using the <code class="inlineCode">lock()</code> call, we can easily find deleted instances and remove the saved settings. The <code class="inlineCode">lock()</code> call returns a <code class="inlineCode">nullptr</code> if the shared pointer is no longer available, and we simply use a <code class="inlineCode">pop()</code> call on the respective stack to remove the dead settings.</li>
    </ul>
    <p class="normal">If we want to save the settings instances of an instance, we call the <code class="inlineCode">apply()</code> method of the <code class="inlineCode">AssimpSettingsContainer</code> class. The <code class="inlineCode">apply()</code> method creates a new <code class="inlineCode">AssimpInstanceSettings</code> object and pushes the settings to the undo stack.</p>
    <p class="normal">We also clear the redo stack while saving a new setting via <code class="inlineCode">apply()</code>. It may be useless to use the redo operation after we reverted a couple of changes and applied recent changes since the redo operations could create conflicts with the latest changes, or even overwrite the latest change. Removing all settings from the redo stack is a quick and safe way to avoid side effects after the latest changes are applied.</p>
    <p class="normal">The implementation of the <code class="inlineCode">undo()</code> and <code class="inlineCode">redo()</code> methods is short and simple:</p>
    <ol>
      <li class="numberedList" value="1">Check for any deleted instances by requesting the shared pointer from the weak pointer, and remove the settings struct if the instance pointer is invalid. The check will be done in a <code class="inlineCode">while()</code> loop to find all deleted instances.</li>
      <li class="numberedList">If the stack is empty (i.e., because all instances that had settings saved for undo or redo are gone), we <a id="_idIndexMarker176"/>return from the operation immediately.</li>
      <li class="numberedList">Get the top entry from the stack and apply the saved settings to the instance in case of an undo operation, or the new settings for a redo operation.</li>
      <li class="numberedList">Push the top entry of a stack to the opposite stack and remove the top entry.</li>
    </ol>
    <p class="normal">Now, all relevant instance changes can be saved to the undo stack. If we choose to undo a change to an instance, we can also immediately redo the very same change. In the background, the structs containing old and new settings and the instance pointer are just moved between the two stacks on undo and redo operations.</p>
    <p class="normal">Adding the new operations to the renderer requires a bit of extra work.</p>
    <h2 id="_idParaDest-125" class="heading-2">Hooking up the storage class to the renderer</h2>
    <p class="normal">The renderer will be extended by<a id="_idIndexMarker177"/> two new methods for the undo/redo related code, called <code class="inlineCode">undoLastOperation()</code> and <code class="inlineCode">redoLastOperation()</code>.</p>
    <p class="normal">At the start of each of the methods, we call the respective operation on the settings container:</p>
    <pre class="programlisting code"><code class="hljs-code">  mModelInstData.miSettingsContainer-&gt;<span class="hljs-built_in">undo</span>();
  <span class="hljs-built_in">assignInstanceIndices</span>();
</code></pre>
    <p class="normal">In addition, a call to <code class="inlineCode">assignInstanceIndices()</code> will be issued. Enumerating all instances after undo and redo operations is crucial. The settings taken from the stack could contain an invalid instance index in the <code class="inlineCode">isInstanceIndexPosition</code> variable after other instances have been deleted, resulting in access outside the <code class="inlineCode">miAssimpInstance</code> vector.</p>
    <p class="normal">A side effect of the enumeration is a position change in the <code class="inlineCode">miAssimpInstances</code> vector. So, we cannot just take the new <code class="inlineCode">isInstanceIndexPosition</code> to select the instance that was changed by the undo or redo operation. Instead, we retrieve the instance pointer of the changed instance from <code class="inlineCode">AssimpInstanceSettings</code> and use <code class="inlineCode">std::find_if</code> to search the <code class="inlineCode">miAssimpInstance</code> vector for a <a id="_idIndexMarker178"/>matching pointer. If we don’t find the correct instance, the null instance will be selected, resulting in no instance to be selected.</p>
    <h2 id="_idParaDest-126" class="heading-2">Defining hotkeys for undo and redo</h2>
    <p class="normal">To use undo and <a id="_idIndexMarker179"/>redo functions by using known key combinations on the <a id="_idIndexMarker180"/>keyboard, we add the new keys to the <code class="inlineCode">handleKeyEvents()</code> method in<a id="_idIndexMarker181"/> the renderer:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span> (mRenderData.rdApplicationMode == appMode::edit) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(mRenderData.rdWindow,
        GLFW_KEY_Z) == GLFW_PRESS &amp;&amp;
        (<span class="hljs-built_in">glfwGetKey</span>(mRenderData.rdWindow,
        GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS ||
        <span class="hljs-built_in">glfwGetKey</span>(mRenderData.rdWindow,
        GLFW_KEY_RIGHT_CONTROL) == GLFW_PRESS)) {
      <span class="hljs-built_in">undoLastOperation</span>();
    }
    ...
  }
</code></pre>
    <p class="normal">Here, only the undo part is shown, utilizing the key combination <code class="inlineCode">CTRL + Z</code>, like many other applications. The redo function is called when <code class="inlineCode">CTRL + Y</code> is pressed, which is also a well-known key combination to redo changes.</p>
    <p class="normal">Undo and redo functionality will only be activated in edit mode. We cannot adjust instance settings in view mode, so we also do not need to revert or redo changes.</p>
    <p class="normal">We are now able to call the undo and redo functions by key combinations. However, for easier access, reaching both operations via a menu bar would be great.</p>
    <h2 id="_idParaDest-127" class="heading-2">Adding an ImGui menu to allow direct access</h2>
    <p class="normal">Luckily, a menu bar <a id="_idIndexMarker182"/>can be added with a few ImGui calls:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span> (ImGui::<span class="hljs-built_in">BeginMainMenuBar</span>()) {
    <span class="hljs-keyword">if</span> (ImGui::<span class="hljs-built_in">BeginMenu</span>(<span class="hljs-string">"Edit"</span>)) {
      <span class="hljs-keyword">if</span> (ImGui::<span class="hljs-built_in">MenuItem</span>(<span class="hljs-string">"Undo"</span>, <span class="hljs-string">"CTRL+Z"</span>)) {
        modInstData.<span class="hljs-built_in">miUndoCallbackFunction</span>();
      }
      <span class="hljs-keyword">if</span> (ImGui::<span class="hljs-built_in">MenuItem</span>(<span class="hljs-string">"Redo"</span>, <span class="hljs-string">"CTRL+Y"</span>)) {
        modInstData.<span class="hljs-built_in">miRedoCallbackFunction</span>();
      }
      ImGui::<span class="hljs-built_in">EndMenu</span>();
    }
    ImGui::<span class="hljs-built_in">EndMainMenuBar</span>();
  }
</code></pre>
    <p class="normal">Like other ImGui widgets, the main menu bar itself, and all menus in the menu bar, start with an <code class="inlineCode">ImGui::Begin*()</code> line and end with an <code class="inlineCode">ImGui::End*()</code> line. As with other ImGui widgets, the ImGui menu commands return a Boolean value of <code class="inlineCode">true</code> if they are activated (i.e., by clicking the left mouse button on the menu item).</p>
    <p class="normal">Also, we are using – once again – callback functions in the <code class="inlineCode">ModelAndInstanceData</code> struct to move the workload to do the undo and redo operations from the user interface to the renderer.</p>
    <p class="normal">In <em class="italic">Figure 4.4</em>, the new <a id="_idIndexMarker183"/>ImGui menu bar of the application is shown:</p>
    <figure class="mediaobject"><img src="../Images/Figure_4.4_B22428.png" alt="A screenshot of a computer  AI-generated content may be incorrect." width="690" height="396"/></figure>
    <p class="packt_figref">Figure 4.4: Main menu bar, containing the edit menu with undo and redo entries</p>
    <p class="normal">The menu was created by the small code snippet in this section, and new menu entries and menu items can be added easily. Two new menu entries can be implemented when you solve the tasks in the <em class="italic">Practical sessions</em> section.</p>
    <h2 id="_idParaDest-128" class="heading-2">Limits and enhancements of our undo/redo implementation</h2>
    <p class="normal">One of the biggest shortcomings of the current undo/redo implementation is the limitation to react to configuration changes<a id="_idIndexMarker184"/> of single instances. We do not <a id="_idIndexMarker185"/>capture other features, like loading or deleting models, or the creation of multiple instances of a model at once.</p>
    <p class="normal">Adding undo/redo support for multiple instances would need an extension of the <code class="inlineCode">AssimpSettingsContainer</code> class to store all affected instances in a single group. In case of an undo or redo operation, we don’t want to step through every single instance, but all instances should reappear or disappear at the same time.</p>
    <p class="normal">Including model changes to the undo/redo stacks requires another rework of the settings container class. Now, we would have to check what kind of object we are working on and add the model change plus the affected instance changes. Deleting a model also removes all instances of that model; an undo <a id="_idIndexMarker186"/>operation would need to restore the model and all instances with their respective settings.</p>
    <p class="normal">Extending the currently implemented undo/redo functionality to support multiple instances and model changes can be found as a task in the <em class="italic">Practical sessions</em> section at the end of this chapter. But be <a id="_idIndexMarker187"/>warned, building a mature undo/redo system is not trivial and will require a significant amount of time.</p>
    <p class="normal">As you can see, keeping up a consistently working undo/redo feature adds a lot of overhead to an application, but the time spent on good undo and redo handling is well-invested. The future user of any application will thank the programmers for being able to recover from unwanted changes, like an accidental change, or even the deletion of elements.</p>
    <h1 id="_idParaDest-129" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we added a second application mode to disable all features that are not needed for a visit to the virtual world. The user interface, selection, and all parts belonging to such topics can be disabled by a hotkey now. Next, we tested a basic rollback operation for instance setting changes and enabling a simple undo. Finally, we enhanced the rollback to an undo/redo functionality for any setting changes on the instance level.</p>
    <p class="normal">In the next chapter, we will implement the ability to save the current configuration of all models and instances to a file, plus restore all models and instances from a saved file. With a working save and load functionality, we can stop changing the virtual world at any time and continue in the exact same state at a later point in time.</p>
    <h1 id="_idParaDest-130" class="heading-1">Practical sessions</h1>
    <p class="normal">There are some additions you could make to the code:</p>
    <ul>
      <li class="bulletList">Move the <strong class="screenText">Import Model</strong> button to the menu bar.</li>
    </ul>
    <p class="normal">The <strong class="screenText">Import Model</strong> button may feel a bit misplaced since the start, but now we have the chance to change the functionality. Move the functionality of the button to a submenu of the menu bar, making it easier to understand how to import a model to the application.</p>
    <ul>
      <li class="bulletList">Add a confirmation dialog when the application is closed.</li>
    </ul>
    <p class="normal">If we use key combinations like <code class="inlineCode">ALT + F4</code> now or press the icon to close the window, the application ends immediately. Add a simple popup dialog with a yes/no question, allowing the user to stop another possibly accidental operation. Since we have a menu bar now, you can also create a File-&gt;Exit entry, calling the same logic to request confirmation before closing the application. Oh, and don’t forget to switch back to edit mode when the application exit is requested. A hidden exit dialog is hardly usable.</p>
    <ul>
      <li class="bulletList">Enhanced difficulty: Add a full-featured undo/redo.</li>
    </ul>
    <p class="normal">Right now, we only store simple setting changes. Extend the <code class="inlineCode">AssimpSettingContainer</code> class to also store the addition and deletion events of instances. You may need an <code class="inlineCode">enum</code> to store the action because, during the undo and redo operations, you need to execute the opposite action. You may have to adjust the two stacks to also store vectors of instance settings. Doing a mass-adding of instances should be reverted in both directions by a single undo or redo call, not by acting on every single instance of the group.</p>
    <h1 id="_idParaDest-131" class="heading-1">Additional resources</h1>
    <ul>
      <li class="bulletList">The Command pattern, used for undo/redo operations: <a href="https://gameprogrammingpatterns.com/command.html"><span class="url">https://gameprogrammingpatterns.com/command.html</span></a></li>
      <li class="bulletList"><em class="italic">Game Programming in C++</em> by <em class="italic">Sanjay Madhav</em>, published by <em class="italic">Pearson Addison-Wesley</em>, ISBN 978-0134597201</li>
    </ul>
  </div>
</div></div></body></html>