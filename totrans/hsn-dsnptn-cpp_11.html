<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-198"><a id="_idTextAnchor509"/>11</h1>
<h1 id="_idParaDest-199"><a id="_idTextAnchor510"/><a id="_idTextAnchor511"/><a id="_idTextAnchor512"/>ScopeGuard</h1>
<p>This chapter covers a pattern that can be seen as a generalization of the RAII idiom we studied earlier. In its earliest form, it is an old and established C++ pattern, however, it is also one that has particularly benefited from the language additions in C++11, C++14, and C++17. We will witness the evolution of this pattern as the language becomes more powerful. The ScopeGuard pattern exists at the intersection of declarative programming (say what you want to happen, not how you want it done) and error-safe programs (especially exception safety). We will have to learn a bit about both before we fully understand ScopeGuard.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>How can we write error-safe and exception-safe code? How does RAII make error handling easier?</li>
<li>What is composability as applied to error handling?</li>
<li>Why is RAII not powerful enough for error handling, and how is it generalized? How can we implement declarative error handling in C++?</li>
</ul>
<h1 id="_idParaDest-200"><a id="_idTextAnchor513"/>Technical requirements</h1>
<p>Here is the example code: <a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter11">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter11</a>.</p>
<p>You will also need the Google Benchmark library installed and configured: <a href="https://github.com/google/benchmark">https://github.com/google/benchmark</a> (see <a href="B19262_04.xhtml#_idTextAnchor152"><em class="italic">Chapter 4</em></a>, <em class="italic">Swap – From Simple to Subtle</em>, for installation instructions).</p>
<p><a id="_idTextAnchor514"/>This chapter is rather heavy on advanced C++ features, so keep a C++ reference nearby (<a href="https://en.cppreference.com">https://en.cppreference.com</a> unless you want to dig through the standard itself).</p>
<p>Finally, a very thorough and complete implementation of ScopeGuard can be found in the Folly library: <a href="https://github.com/facebook/folly/blob/master/folly/ScopeGuard.h">https://github.com/facebook/folly/blob/master/folly/ScopeGuard.h</a>; it includes C++ library programming details beyond those covered in this book.</p>
<h1 id="_idParaDest-201"><a id="_idTextAnchor516"/>Error handling and resource acquisition is initialization</h1>
<p>We begin by reviewing the concepts of error handling, and, in particular, writing exception-safe <a id="_idIndexMarker604"/>code in C++. The <strong class="bold">Resource Acquisition Is Initialization</strong> (<strong class="bold">RAII</strong>) idiom is <a id="_idIndexMarker605"/>one of the primary methods of error handling in C++. We have already dedicated an entire chapter to it, and you will need it here to make sense of what we are about to do. Let’s first recognize th<a id="_idTextAnchor517"/>e problem we are facing<a id="_idTextAnchor518"/>.</p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor519"/>Error safety and exception safety</h2>
<p>For the rest of this chapter, we will consider the following problem—suppose we are implementing <a id="_idIndexMarker606"/>a database of records. The records are stored <a id="_idIndexMarker607"/>on disk, but there is also an in-memory index for fast access to the records. The database API offers a method to insert records into the database:</p>
<pre class="source-code">
class Record { ... };
class Database {
  public:
  void insert(const Record&amp; r);
  ...
};</pre>
<p>If the insertion succeeds, both the index and the disk storage are updated and consistent with each other. If something goes wrong, an exception is thrown.</p>
<p>While it appears to the clients of the database that the insertion is a single transaction, the implementation has to deal with the fact that it is done in multiple steps—we need to insert the record into the index and write it to disk. To facilitate this, the database contains two classes, each responsible for its type of storage:</p>
<pre class="source-code">
class Database {
  class Storage { ... };    // Disk storage Storage S;
  class Index { ... };    // Memory index Index I;
  public:
  void insert(const Record&amp; r);
  ...
};</pre>
<p>The <a id="_idIndexMarker608"/>implementation of the <code>insert()</code> function must insert the record into both the storage <a id="_idIndexMarker609"/>and the index, there is no way around it:</p>
<pre class="source-code">
//Example 01
void Database::insert(const Record&amp; r) {
  S.insert(r);
  I.insert(r);
}</pre>
<p>Unfortunately, either of these operations can fail. Let’s see first what happens if the storage insertion fails. Let’s assume that all failures in the program are signaled by throwing exceptions. If the storage insertion fails, the storage remains unchanged, the index insertion is not attempted at all, and the exception is propagated out of the <code>Database::insert()</code> function. That is exactly what we want—the insertion failed, the database is unchanged, and an exception is thrown.</p>
<p>So, what happens if the storage insertion succeeds but the index fails? Things are not looking so good this time—the disk is altered successfully, then the index insertion fails, and the exception propagates to the caller of <code>Database::insert()</code> to signal the insertion failure, but the truth is the insertion did not completely fail. It did not completely succeed either.</p>
<p>The database is left in an inconsistent state; there is a record on disk that is not accessible from the index. This is a failure to handle an error condition, exception-unsafe code, and it just won’t do.</p>
<p>The impulsive attempt to change the order of the sub-operations does not help:</p>
<pre class="source-code">
void Database::insert(const Record&amp; r) {
  I.insert(r);
  S.insert(r);
}</pre>
<p>Sure, everything is now fine if the index fails. But we have the same problem if the storage <a id="_idIndexMarker610"/>insertion throws an exception—we now have an entry in the index <a id="_idIndexMarker611"/>that is pointing to nowhere since the record was never written to disk.</p>
<p>Obviously, we cannot just ignore the exceptions thrown by <code>Index</code> or <code>Storage</code>; we have to somehow deal with them to maintain the consistency of the database. We know how to handle exceptions; that’s what the <code>try-catch</code> block is for:</p>
<pre class="source-code">
// Example 02
void Database::insert(const Record&amp; r) {
  S.insert(r);
  try {
    I.insert(r);
  } catch (...) {
    S.undo();
    throw;    // Rethrow
  }
}</pre>
<p>Again, if the storage fails, we don’t need to do anything special. If the index fails, we have to undo the last operation on the storage (let’s assume that it has the API to do that). Now the database is again consistent as if the insertion never happened. Even though we caught the exception thrown by the index, we still need to signal to the caller that the insertion fails, so we re-throw the exception. So far, so good.</p>
<p>The situation <a id="_idIndexMarker612"/>is not much different if we choose to use <a id="_idIndexMarker613"/>error codes instead of exceptions; let’s consider the variant where all <code>insert()</code> functions return <code>true</code> if they succeed and <code>false</code> if they fail:</p>
<pre class="source-code">
bool Database::insert(const Record&amp; r) {
  if (!S.insert(r)) return false;
  if (!I.insert(r)) {
    S.undo();
    return false;
  }
  return true;
}</pre>
<p>We have to check the return value of every function, undo the first action if the second one fails, and return <code>true</code> only if both actions succeed.</p>
<p>So far, so good; we were able to fix the simplest two-stage problem, so the code is error-safe. Now, it is time to up the complexity. Suppose that our storage needs some cleanup to be performed at the end of the transaction, for example, the inserted record is not in its final state until we call the <code>Storage::finalize()</code> method (maybe this is done so <code>Storage::undo()</code> can work, and after the insertion is finalized it can no longer be undone). Note the difference between <code>undo()</code> and <code>finalize()</code>; the former must be called only if we want to roll back the transaction, while the latter must be called if the storage insertion succeeded, regardless of what happe<a id="_idTextAnchor520"/>ns after.</p>
<p>Our requirements are met with this flow of control:</p>
<pre class="source-code">
// Example 02a:
void Database::insert(const Record&amp; r) {
  S.insert(r);
  try {
    I.insert(r);
  } catch (...) {
    S.undo();
    S.finalize();
    throw;
  }
  S.finalize();
}</pre>
<p>Or we have <a id="_idIndexMarker614"/>something similar in the case of returning error codes (for the rest of this chapter, we will use exceptions in all our examples, but conversion <a id="_idIndexMarker615"/>to error codes is not hard).</p>
<p>This is already getting ugly, particularly the part about getting the cleanup code (in our case, <code>S.finalize()</code>) to run in every execution path. It’s only going to get worse if we have a more complex sequence of actions that must all be undone unless the entire operation succeeds. Here is the control flow for three actions, each with its own rollback and cleanup:</p>
<pre class="source-code">
if (action1() == SUCCESS) {
  if (action2() == SUCCESS) {
    if (action3() == FAIL) {
      rollback2();
      rollback1();
    }
    cleanup2();
  } else {
    rollback1();
  }
  cleanup1();
}</pre>
<p>The obvious problem is the explicit tests for success, either as conditionals or as try-catch blocks. The more <a id="_idIndexMarker616"/>serious problem is that this way of <a id="_idIndexMarker617"/>error handling is not composable. The solution for N+1 actions is not the code for N actions with some bits added to it; no, we have to go deep inside the code and add the right pieces there. But we have already seen the C++ idiom for solving this <a id="_idTextAnchor521"/><a id="_idTextAnchor522"/><a id="_idTextAnchor523"/>very problem.</p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor524"/>Resource Acquisition Is Initialization</h2>
<p>The RAII idiom <a id="_idIndexMarker618"/>binds resources to objects. The object is constructed when the resource is acquired, and the resource is deleted when the object is destroyed. In our case, we are interested only in the second half, the destruction. The advantage of the RAII idiom is that the destructors of all local objects must be called when the control reaches the end of the scope, regardless of how it happens (<code>return</code>, <code>throw</code>, <code>break</code>, and so on). Since we struggled with the cleanup, let’s hand that off to an RAII object:</p>
<pre class="source-code">
// Example 02b:
class StorageFinalizer {
  public:
  StorageFinalizer(Storage&amp; S) : S_(S) {}
  ~StorageFinalizer() { S_.finalize(); }
  private:
  Storage&amp; S_;
};
void Database::insert(const Record&amp; r) {
  S.insert(r);
  StorageFinalizer SF(S);
  try {
    I.insert(r);
  } catch (...) {
    S.undo();
    throw;
  }
}</pre>
<p>The <code>StorageFinalizer</code> object binds to the <code>Storage</code> object when it is constructed and calls <code>finalize()</code> when it is destroyed. Since there is no way to exit the scope in which the <code>StorageFinalizer</code> object is defined without calling its destructor, we do not need to worry about the control flow, at least for the cleanup; it is going to happen. Note that the <code>StorageFinalizer</code> is properly constructed after the storage insertion succeeds; if the first insertion fails, there is nothing to finalize.</p>
<p>This code works, but it looks somehow half-done; we have two actions that are performed <a id="_idIndexMarker619"/>at the end of the function, and the first one (cleanup, or <code>finalize()</code>) is automated while the second one (rollback, or <code>undo()</code>) is not. Also, the technique is still not composable; here is the flow of control for three actions:</p>
<pre class="source-code">
class Cleanup1() {
  ~Cleanup1() { cleanup1(); }
  ...
};
class Cleanup2() {
  ~Cleanup2() { cleanup2(); }
  ...
};
action1();
Cleanup1 c1;
try {
  action2();
  Cleanup2 c2;
  try {
    action3();
  } catch (...) {
    rollback2();
    throw;
  }
} catch (...) {
  rollback1();
}</pre>
<p>Again, to add another action, we have to add a try-catch block deep in the code. On the other hand, the cleanup <a id="_idIndexMarker620"/>part by itself is perfectly composable. Consider what the previous code looks like if we don’t need to do a rollback:</p>
<pre class="source-code">
action1();
Cleanup1 c1;
action2();
Cleanup2 c2;</pre>
<p>If we need one more action, we simply add two lines at the end of the function, and the cleanup happens in the right order. If we could do the same for the rollback, we would be all set.</p>
<p>We cannot simply move the call to <code>undo()</code> into a destructor of another object; the destructors are always called, but the rollback happens only in the case of an error. But we can make the destructor call the rollback conditionally:</p>
<pre class="source-code">
// Example 03:
class StorageGuard {
  public:
  StorageGuard(Storage&amp; S) : S_(S) {}
  ~StorageGuard() {
    if (!commit_) S_.undo();
  }
  void commit() noexcept { commit_ = true; }
  private:
  Storage&amp; S_;
  bool commit_ = false;
};
void Database::insert(const Record&amp; r) {
  S.insert(r);
  Storage<a id="_idTextAnchor525"/>Finalizer SF(S);
  StorageGuard SG(S);
  I.insert(r);
  SG.commit();
}</pre>
<p>Examine the <a id="_idIndexMarker621"/>code now; if the storage insertion fails, the exception is thrown and the database is unchanged. If it succeeds, two RAII objects are constructed. The first one will unconditionally call <code>S.finalize()</code> at the end of the scope. The second one will call <code>S.undo()</code> unless we commit the change first by calling the <code>commit()</code> method on the <code>StorageGuard</code> object. That will happen unless the index insertion fails, in which case an exception is thrown, the rest of the code in the scope is bypassed, and the control jumps straight to the end of the scope (the closing <code>}</code>) where the destructors of all local objects are called. Since we never called <code>commit()</code> in this scenario, the <code>StorageGuard</code> is still active and will undo the insertion. Note also that there are no explicit <code>try-catch</code> blocks at all: the actions that used to be in the <code>catch</code> clause are now done by the destructors. The exception should be, of course, caught eventually (in all examples that accompany this chapter, the exception is caught in <code>main()</code>).</p>
<p>The destructors of the local objects are called in reverse construction order. This is important; if we have to undo the insertion, this can be done only until the action is finalized, so the rollback has to happen before the cleanup. Therefore, we construct the RAII objects in the correct order—first, the cleanup (to be done last), then the rollback guard (to be done first, if necessary).</p>
<p>The code now <a id="_idIndexMarker622"/>looks very nice, with no try-catch blocks at all. In some ways, it does not look <a id="_idIndexMarker623"/>like regular C++. This programming style is called <strong class="bold">declarative programming</strong>; it is a programming paradigm in which the program logic is expressed without explicitly stating the flow of control (the opposite, and the <a id="_idIndexMarker624"/>more common in C++, is <strong class="bold">imperative programming</strong>, where the program describes which steps to do and in what order, but not necessarily why). There are declarative programming languages (the prime example is SQL), but C++ is not one of them. Nonetheless, C++ is very good at implementing constructs that allow the creation of higher-order languages on top of C++, and so we have implemented a declarative error-handling language. Our program now says that after the record was inserted into storage, two actions are pending—the cleanup and the rollback.</p>
<p>The rollback is disarmed if the entire function succeeds. The code looks linear, without the explicit flow of control, in other words, declarative.</p>
<p>Nice as it is, it is also far from perfect. The obvious problem is that we have to write a guard or a finalizer class for every action in our program. The less obvious one is that writing these classes correctly is not easy, and we have not done a particularly good job so far. Take a moment to figure out what is missing before looking at the fixed version here:</p>
<pre class="source-code">
class StorageGuard {
  public:
  StorageGuard(Storage&amp; S) : S_(S), commit_(false) {}
  ~StorageGuard() { if (!c<a id="_idTextAnchor526"/>ommit_) S_.undo(); }
  void commit() noexcept { commit_ = true; }
  private:
  Storage&amp; S_;
  bool commit_;
  // Important: really bad things happen if
  // this guard is copied!
  StorageGuard(const StorageGuard&amp;) = delete;
  StorageGuard&amp; operator=(const StorageGuard&amp;) = delete;
};
void Database::insert(const Record&amp; r) {
  S.insert(r);
  StorageFinalizer SF(S);
  StorageGuard SG(S);
  I.insert(r);
  SG.commit();
}</pre>
<p>What we need <a id="_idIndexMarker625"/>is a general framework that lets us schedule an arbitrary action to be executed at the end of the scope, unconditionally or conditionally. The <a id="_idTextAnchor527"/>next section presents the pattern that provides such a f<a id="_idTextAnchor528"/>ramework, ScopeGuard.</p>
<h1 id="_idParaDest-204"><a id="_idTextAnchor529"/>The ScopeGuard pattern</h1>
<p>In this section, we learn how to write the on-exit action RAII classes such as the ones we implemented <a id="_idIndexMarker626"/>in the previous section, but without all the boilerplate <a id="_idTextAnchor530"/>code. This can be done in C++03 but is much improved in C++1<a id="_idTextAnchor531"/>4, and again in C++17.</p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor532"/>ScopeGuard basics</h2>
<p>Let’s start with <a id="_idIndexMarker627"/>the more difficult problem—how to implement a generic rollback class, a generic version of <code>StorageGuard</code> from the last section. The only difference between that and the cleanup class is that the cleanup is always active, but the rollback is canceled after the action is committed. If we have the conditional rollback version, we can always take out the condition check, and we get the cleanup version, so let’s not worry about that for now.</p>
<p>In our example, the rollback is a call to the <code>S.undo()</code> method. To simplify the example, let’s start <a id="_idIndexMarker628"/>with a rollback that calls a regular function, not a member function:</p>
<pre class="source-code">
void undo(Storage&amp; S) { S.undo(); }</pre>
<p>Once the implementation is finished, the program should look something like this:</p>
<pre class="source-code">
{
  S.insert(r);
  ScopeGuard SG(undo, S);    // Approximate desired syntax
  ...
  SG.commit();            // Disarm the scope guard
}</pre>
<p>This code tells us (in a declarative manner!) that if the insert action succeeded, we schedule the <a id="_idIndexMarker629"/>rollback to be done upon exiting the scope. The rollback will call the <code>undo()</code> function with the argument <code>S</code>, which in turn will undo the insertion. If we made it to the end of the function, we disarm the guard and disable the rollback call, which commits the insertion and makes it permanent.</p>
<p>A much more general and reusable solution was proposed by Andrei Alexandrescu in the <em class="italic">Dr. Dobbs</em> article in 2000 (<a href="http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758?">http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758?</a>). Let’s look at the implementation and analyze it:</p>
<pre class="source-code">
// Example 04
class ScopeGuardImplBase {
  public:
  ScopeGuardImplBase() = default;
  void commit() const noexcept { commit_ = true; }
  protected:
  ScopeGuardImplBase(const ScopeGuardImplBase&amp; other) :
    commit_(other.commit_) { other.commit(); }
  ~ScopeGuardImplBase() {}
  mutable bool commit_ = false;
};
template &lt;typename Func, typename Arg&gt;
class ScopeGuardImpl : public ScopeGuardImplBase {
  public:
  ScopeGuardImpl(const Func&amp; func, Arg&amp; arg) :
    func_(func), arg_(arg) {}
  ~ScopeGuardImpl() { if (!commit_) func_(arg_); }
  private:
  const Func&amp; func_;
  Arg&amp; arg_;
};
template &lt;typename Func, typename Arg&gt;
ScopeGuardImpl&lt;Func, Arg&gt;
MakeGuard(const Func&amp; func, Arg&amp; arg) {
  return ScopeGuardImpl&lt;Func, Arg&gt;(func, arg);
}</pre>
<p>From the top, we have <a id="_idIndexMarker630"/>the base class for all the scope guards, <code>ScopeGuardImplBase</code>. The base class holds the commit flag and the code to manipulate it; the constructor initially creates the guard in the armed state, so the deferred action will happen in the destructor. The call to <code>commit()</code> will prevent that from happening and make the destructor do nothing. Finally, there is a copy constructor that creates a new guard in the same state as the original but then disarms the original guard. This is so the rollback does not happen twice, from the destructors of both objects. The object is copyable but not assignable. We use C++03 features for everything here, including the disabled assignment operator. This implementation is fundamentally C++03; the few C++11 twists are just icing on the cake (that is about to change in the next section).</p>
<p>There are several details of the implementation of <code>ScopeGuardImplBase</code> that may seem odd and need elaboration. First of all, the destructor is not virtual; this is not a typo or a bug, this is intentional, as we will see later. Second, the <code>commit_</code> flag is declared <code>mutable</code>. This is, of course, so that it can be changed by the <code>commit()</code> method, which we declared <code>const</code>. So, why is <code>commit()</code> declared <code>const</code>? One reason is so we can call it on the source object from the copy constructor, to transfer the responsibility for the rollback from the other object to this one. In this sense, the copy constructor really does a move and will be officially declared as such later. The second reason for <code>const</code> will become obvious later (it is related to the non-virtual destructor, of all things).</p>
<p>Let’s now turn <a id="_idIndexMarker631"/>to the derived class, <code>ScopeGuardImpl</code>. This is a class template with two type parameters—the first is the type of the function or any other callable object we are going to call for the rollback, and the second is the type of the argument. Our rollback function is restricted, for now, to having only one argument. That function is called in the destructor of the <code>ScopeGuard</code> object unless the guard was disarmed by calling <code>commit()</code>.</p>
<p>Finally, we have a factory function template, <code>MakeGuard</code>. This is a very common idiom in C++; if you need to create an instantiation of a class template from the constructor arguments, use a template function that can deduce the type of the parameters and that of the return value from the arguments (in C++17 class templates can do that too, as we will see later).</p>
<p>How is this all used to create a guard object that will call <code>undo(S)</code> for us? Like this:</p>
<pre class="source-code">
void Database::insert(const Record&amp; r) {
  S.insert(r);
  const ScopeGuardImplBase&amp; SG = MakeGuard(undo, S);
  I.insert(r);
  SG.commit();
}</pre>
<p>The <code>MakeGaurd</code> function deduces the types of the <code>undo()</code> function and the argument <code>S</code> and returns a <code>ScopeGuard</code> object of the corresponding type. The return is by value, so there is a copy involved (the compiler may choose to elide the copy as an optimization, but is not required to). The returned object is a temporary variable, it has no name and binds it to the base class reference <code>SG</code> (casting from the derived class to the base class is implicit for both pointers and references). The lifetime of the temporary variable is until the closing semicolon of the statement that created it, as everyone knows. But then, what does the <code>SG</code> reference point to after the end of the statement? It has to be bound to something, as references cannot be unbound, they are not like <code>NULL</code> pointers. The truth is, “everyone” knows wrong, or rather only mostly right—usually, the temporaries indeed live until the end of the statement. However, binding a temporary to a <code>const</code> reference extends its lifetime to coincide with the lifetime of the reference itself. In other words, the unnamed temporary <code>ScopeGuard</code> object created by <code>MakeGuard</code> will not be destroyed until the <code>SG</code> reference goes out of scope. Const-ness is important here, but do not worry, you can’t forget it; the language does not permit binding non-<code>const</code> references to temporary variables, so the compiler will let you know. So this <a id="_idIndexMarker632"/>explains the <code>commit()</code> method; it has to be <code>const</code> since we are going to call it on the <code>const</code> reference (and, therefore, the <code>commit_</code> flag has to be <code>mutable</code>).</p>
<p>But what about the destructor? At the end of the scope, the destructor of the <code>ScopeGuardImplBase</code> class will be called, since that is the type of reference that goes out of scope. The base class destructor itself does nothing, it’s the derived class that has the destructor we want. A polymorphic class with a virtual destructor would have served us right, but we did not take that route. Instead, we availed ourselves of yet another special rule in the C++ standard concerning the <code>const</code> references and temporary variables—not only is the lifetime of the temporary variable extended but also the destructor of the derived class, that is the actual class that was constructed, is going to be called at the end of the scope.</p>
<p>Note that this rule applies only to destructors; you still cannot call derived class methods on the base class <code>SG</code> reference. Also, the lifetime extension works only when the temporary variable is directly bound to a <code>const</code> reference. It does not work if, for example, we initialize another <code>const</code> reference from the first one. This is why we had to return the <code>ScopeGuard</code> object from the <code>MakeGuard</code> function by value; if we tried to return it by reference, the temporary would be bound to that reference, which is going to go away at the end of the statement. The second reference, <code>SG</code>, initialized from the first one, would not have extended the lifetime of the object.</p>
<p>The function implementation we just saw comes very close to the original goal, it is just a bit more verbose (and it mentions <code>ScopeGuardImplBase</code> instead of the promised <code>ScopeGuard</code>). Fear not, for the last step is merely syntactic sugar:</p>
<pre class="source-code">
using ScopeGuard = const ScopeGuardImplBase&amp;;</pre>
<p>Now, we can write this:</p>
<pre class="source-code">
// Example 04a
void Database::insert(const Record&amp; r) {
  S.insert(r);
  ScopeGuard SG = MakeGuard(undo, S);
  I.insert(r);
  SG.commit();
}</pre>
<p>This is as far <a id="_idIndexMarker633"/>as we are going to get with the language tools we’ve used so far. Ideally, the desired syntax would be as follows (and we are not very far off):</p>
<pre class="source-code">
ScopeGuard SG(undo, S);</pre>
<p>We can tidy up our <code>ScopeGuard</code> a bit by making use of the C++11 features. First of all, we can properly disable the assignment operator. Second, we can stop pretending that our copy constructor is anything other than a move constructor:</p>
<pre class="source-code">
// Example 05
class ScopeGuardImplBase {
  public:
  ScopeGuardImplBase() = default;
  void commit() const noexcept { commit_ = true; }
  protected:
  ScopeGuardImplBase(ScopeGuardImplBase&amp;&amp; other) :
    commit_(other.commit_) { other.commit(); }
  ~ScopeGuardImplBase() {}
  mutable bool commit_ = false;
  private:
  ScopeGuardImplBase&amp; operator=(const ScopeGuardImplBase&amp;)
    = delete;
};
using ScopeGuard = const ScopeGuardImplBase&amp;;
template &lt;typename Func, typename Arg&gt;
class ScopeGuardImpl : public ScopeGuardImplBase {
  public:
  ScopeGuardImpl(const Func&amp; func, Arg&amp; arg) :
    func_(func), arg_(arg) {}
  ~ScopeGuardImpl() { <a id="_idTextAnchor533"/>if (!commit_) func_(arg_); }
  ScopeGuardImpl(ScopeGuardImpl&amp;&amp; other) :
    ScopeGuardImplBase(std::move(other)),
    func_(other.func_),
    arg_(other.arg_) {}
  private:
  const Func&amp; func_;
  Arg&amp; arg_;
};
template &lt;typename Func, typename Arg&gt;
ScopeGuardImpl&lt;Func, Arg&gt;
MakeGuard(const Func&amp; func, Arg&amp; arg) {
  return ScopeGuardImpl&lt;Func, Arg&gt;(func, arg);
}</pre>
<p>Moving to C++14, we can <a id="_idIndexMarker634"/>make one more simplification and deduce the return type of the <code>MakeGuard</code> function:</p>
<pre class="source-code">
// Example 05a
template &lt;typename Func, typename Arg&gt;
auto MakeGuard(const Func&amp; func, Arg&amp; arg) {
  return ScopeGuardImpl&lt;Func, Arg&gt;(func, arg);
}</pre>
<p>There is still one concession we had to make—we did not really need the <code>undo(S)</code> function what we really wanted was to call <code>S.undo()</code>. This is done just as easily with a member function variant of <code>ScopeGuard</code>. In fact, the only reason we have not done so from the beginning is to make the example easier to follow; the member function pointer syntax is not the most straightforward aspect of C++:</p>
<pre class="source-code">
// Example 06
template &lt;typename MemFunc, typename Obj&gt;
class ScopeGuardImpl : public ScopeGuardImplBase {
  public:
  ScopeGuardImpl(const MemFunc&amp; memfunc, Obj&amp; obj) :
    memfunc_(memfunc), obj_(obj) {}
  ~ScopeGuardImpl() { if (!commit_) (obj_.*memfunc_)(); }
  ScopeGuardImpl(ScopeGuardImpl&amp;&amp; other) :
    ScopeGuardImplBase(std::move(other)),
    memfunc_(other.memfunc_),
    obj_(other.obj_) {}
  private:
  const MemFunc&amp; memfunc_; Obj&amp; obj_;
};
template &lt;typename MemFunc, typename Obj&gt;
auto MakeGuard(const MemFunc&amp; memfunc, Obj&amp; obj) {// C++14
  return ScopeGuardImpl&lt;<a id="_idTextAnchor534"/>MemFunc, Obj&gt;(memfunc, obj);
}</pre>
<p>Of course, if both versions of the ScopeGuard template are used in the same program, we have to rename <a id="_idIndexMarker635"/>one of them. Also, our function guard is limited to calling functions with only one argument, while our member function guard can call only member functions with no arguments. In C++03, this problem is solved in a tedious but reliable way—we have to create versions of the implementation, <code>ScopeGuardImpl0</code>, <code>ScopeGuardImp1</code>, <code>ScopeGuardImpl2</code>, and so on, for functions with zero, one, two, and so on arguments. We then create <code>ScopeObjGuardImpl0</code>, <code>ScopeObjGuardImpl1</code>, and so on, for member functions with zero, one, two, and so on arguments. If we do not create enough, the compiler will let us know. The base class remains the same for all these variants of the derived class, and so is the <code>ScopeGuard</code> <code>typedef</code>.</p>
<p>In C++11, we have <a id="_idIndexMarker636"/>variadic templates that are designed to address this exact problem, but we’re not going to see such an implementation here. There i<a id="_idTextAnchor535"/>s no reason for it; we can do so much better tha<a id="_idTextAnchor536"/>n that, as you are about to see.</p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor537"/>Generic ScopeGuard</h2>
<p>We are now firmly in C++11 territory, nothing that you are about to see has a C++03 equivalent of any practical worth.</p>
<p>Our <code>ScopeGuard</code> has, so far, allowed us to all arbitrary functions as rollback for any action. Just like the hand-crafted guard objects, the scope guards are composable and guarantee <a id="_idIndexMarker637"/>exception safety. But our implementation, so far, is somewhat limited in what exactly we can call to implement the rollback; it has to be a function or a member function. While this seems to cover a lot, we may want to call, for example, two functions to do a single rollback. We could, of course, write a wrapper function for that, but that sets us back on the path toward single-purpose hand-crafted rollback objects.</p>
<p>There is, in truth, another problem with our implementation. We decided to capture the function argument by reference:</p>
<pre class="source-code">
ScopeGuardImpl(const Func&amp; func, Arg&amp; arg);</pre>
<p>This mostly works, unless the argument is a constant or a temporary variable; then, our code will not compile.</p>
<p>C++11 gives us another way to create arbitrary callable objects: lambda expressions. Lambdas are actually classes, but they behave like functions in that they can be called with parentheses. They can take arguments, but they can also capture any arguments from the containing scope, and that often obviates the need to pass arguments to the function call itself. We can also write arbitrary code and package it in a lambda expression. This sounds ideal for the scope guard; we could just write something that says, <em class="italic">at the end of the scope run </em><em class="italic">this code</em>.</p>
<p>Let’s see what a lambda expression ScopeGuard looks like:</p>
<pre class="source-code">
// Example 07
class ScopeGuardBase {
  public:
  ScopeGuardBase() = default;
  void commit() noexcept { commit_ = true; }
  protected:
  ScopeGuardBase(ScopeGuardBase&amp;&amp; other) noexcept :
    commit_(other.commit_) { other.commit(); }
  ~ScopeGuardBase() = default;
  bool commit_ = false;
  private:
  ScopeGuardBase&amp; operator=(const ScopeGuardBase&amp;)
    = delete;
};
template &lt;typename Func&gt;
class ScopeGuard : public ScopeGuardBase {
  public:
  ScopeGuard(Func&amp;&amp; func) : func_(std::move(func)) {}
  ScopeGuard(const Func&amp; func) : func_(func) {}
  ~ScopeGuard() { if (!commit_) func_(); }
  ScopeGuard(ScopeGuard&amp;&amp; other) = default;
  private:
  Func func_;
};
template &lt;typename Func&gt;
ScopeGuard&lt;Func&gt; MakeGuard(Func&amp;&amp; func) {
  return ScopeGuard&lt;Func&gt;(std::forward&lt;Func&gt;(func));
}</pre>
<p>The base class <a id="_idIndexMarker638"/>is essentially the same as before, except we are not going to use the <code>const</code> reference trick anymore, and so the <code>Impl</code> suffix is gone; what you see is not an implementation aid but the base of the guard class itself; it contains the reusable code dealing with the <code>commit_</code> flag. Since we do not use the <code>const</code> reference, we can stop pretending that the <code>commit()</code> method is const, and drop the <code>mutable</code> declaration from <code>commit_</code>.</p>
<p>The derived class, on the other hand, is much different. First of all, there is only one class for all types of rollback, and the argument type parameter is gone; instead, we have a functional object that is going to be a lambda, and it’ll contain all the arguments that it needs. The destructor is the same as before (except for the missing argument to the callable <code>func_</code>), and so is the move constructor. But the primary constructor of the object is quite different; the callable object is stored by value, and initialized from either a <code>const</code> reference or an r-value reference, with a suitable overload selected automatically by the compiler.</p>
<p>The <code>MakeGuard</code> function is largely unchanged, and we do not need two of them; we can use perfect forwarding (<code>std::forward</code>) to forward the argument of any type to one of the constructors of <code>ScopeGuard</code>.</p>
<p>Here is how this ScopeGuard is used:</p>
<pre class="source-code">
void Database::insert(const Record&amp; r) {
  S.insert(r);
  auto SG = MakeGuard([&amp;] { S.undo(); });
  I.insert(r);
  SG.commit();
}</pre>
<p>The punctuation-rich construct that is used as an argument to <code>MakeGuard</code> is the lambda expression. It creates a callable object, and calling this object will run the code in the body of the lambda, in our case <code>S.undo()</code>. There is no <code>S</code> variable declared in the lambda object itself, so it has to be captured from the containing scope. All captures are done by reference (<code>[&amp;]</code>). Finally, the object is called with no arguments; the parentheses can be omitted, although <code>MakeGuard([&amp;]() { S.undo(); });</code> is also valid. The function does not return anything, that is, the return type is <code>void</code>; it does not have to be explicitly declared. Note that, so far, we have used C++11 lambdas and have not taken advantage of the more powerful C++14 lambdas. This will usually be the case with ScopeGuard, although in practice, you would probably use C++14 just for auto-deduced return types, if nothing else.</p>
<p>We have, until now, intentionally set aside the matter of the regular cleanup and focused on error <a id="_idIndexMarker639"/>handling and the rollback. Now that we have a decent working ScopeGuard, we can tie up loose ends quite easily:</p>
<pre class="source-code">
// Example 07a
void Database::insert(const Record&amp; r) {
  S.insert(r);
  auto SF = MakeGuard([&amp;] { S.finalize(); });
  auto SG = MakeGuard([&amp;] { S.undo(); <a id="_idTextAnchor538"/>});
  I.insert(r);
  SG.commit();
}</pre>
<p>As you can see, nothing special needs to be added to our framework to support the cleanup. We simply create another ScopeGuard that we never disarm.</p>
<p>We should also point out that, in C++17, we no longer need the <code>MakeGuard</code> function since the compiler can deduce the template arguments from the constructor:</p>
<pre class="source-code">
// Example 07b
void Database::insert(const Record&amp; r) {
  S.insert(r);
  ScopeGuard SF = [&amp;] { S.finalize(); };    // C++17
  ScopeGuard SG = [&amp;] { S.undo(); };
  I.insert(r);
  SG.commit();
}</pre>
<p>As long as we are on the subject of making ScopeGuard use prettier, we should consider some helpful macros. We can easily write a macro for the cleanup guard, the one that is always executed. We would like the resulting syntax to look something like this (if this isn’t declarative enough, I don’t know what is):</p>
<pre class="source-code">
ON_SCOPE_EXIT { S.finalize(); };</pre>
<p>We can, in fact, get that very syntax. First of all, we need to generate a name for the guard, what used <a id="_idIndexMarker640"/>to be called <code>SF</code>, and we need it to be something unique. From the cutting edge of modern C++, we are now reaching decades back, to classic C and its preprocessor tricks, to generate a unique name for an anonymous variable:</p>
<pre class="source-code">
#define CONCAT2(x, y) x##y
#define CONCAT(x, y) CONCAT2(x, y)
#ifdef __COUNTER__
#define ANON_VAR(x) CONCAT(x, __COUNTER__)
#else
#define ANON_VAR(x) CONCAT(x, __LINE__)
#endif</pre>
<p>The <code>__CONCAT__</code> macros are how you concatenate two tokens in the preprocessor (and yes, you need two of them, that’s the way the preprocessor works). The first token will be a user-specified prefix, and the second one is something unique. Many compilers support a preprocessor variable, <code>__COUNTER__</code>, that is incremented every time it’s used, so it’s never the same. However, it is not in the standard. If <code>__COUNTER__</code> is not available, we have to use the line number <code>__LINE__</code> as a unique identifier. Of course, it is only unique if we don’t put two guards on the same line, so don’t.</p>
<p>Now that we have a way to generate an anonymous variable name, we can implement the <code>ON_SCOPE_EXIT</code> macro. It would be trivial to implement one where the code is passed as a macro argument, but it would not give us the syntax we want; the argument has to be in parentheses, so at best we could get <code>ON_SCOPE_EXIT(S.finalize();)</code>. Also, commas in the code confuse the preprocessor, since it interprets them as a separator between the macro arguments. If you look carefully at the syntax we requested, <code>ON_SCOPE_EXIT { S.finalize(); };</code>, you will realize that this macro has no arguments at all, and the body of the lambda expression is just typed after the no-argument macro. The macro <a id="_idIndexMarker641"/>expansion, therefore, ends on something that can be followed by an opening curly brace. Here is how this is done:</p>
<pre class="source-code">
// Example 08
struct ScopeGuardOnExit {};
template &lt;typename Func&gt;
ScopeGuard&lt;Func&gt; operator+(ScopeGuardOnExit, Func&amp;&amp; func) {
  return ScopeGuard&lt;Func&gt;(std::forward&lt;Func&gt;(func));
}
#define ON_SCOPE_EXIT auto ANON_VAR(SCOPE_EXIT_STATE) = \
  ScopeGuardOnExit() + [&amp;]()</pre>
<p>The macro expansion declares an anonymous variable that starts with <code>SCOPE_EXIT_STATE</code>, followed by a unique number, and it ends on the incomplete lambda expression, <code>[&amp;]()</code>, that is completed by the code in the curly braces. In order to not have a closing parenthesis of the former <code>MakeGuard</code> function, which the macro cannot generate (the macro is expanded before the lambda body, so it cannot generate any code after that), we have to replace the <code>MakeGuard</code> function (or the <code>ScopeGuard</code> constructor in C++17) with an operator. The choice of the operator does not matter; we use <code>+</code>, but we could use any binary operator. The first argument to the operator is a temporary object of a unique type, it limits the overload resolution only to the <code>operator+()</code> defined previously (the object itself is not used at all, we only need its type). The <code>operator+()</code> itself is exactly what <code>MakeGuard</code> used to be, it deduces the type of the lambda expression and creates the corresponding <code>ScopeGuard</code> object. The only downside of this technique is that the closing semicolon at the end of the <code>ON_SCOPE_EXIT</code> statement is required, and should you forget it, the compiler will remind you in the most obscure and opaque way possible.</p>
<p>Our program code can now be further tidied up:</p>
<pre class="source-code">
// Example 08
void Database::insert(const Record&amp; r) {
  S.insert(r);
  ON_SCOPE_EXIT { S.finalize(); };
  auto SG = ScopeGuard([&amp;] { S.undo(<a id="_idTextAnchor539"/>); });
  I.insert(r);
  SG.commit();
}</pre>
<p>It is tempting to apply the same technique to the second guard. Unfortunately, this is not so simple; we have to know the name of this variable so we can call <code>commit()</code> on it. We can define <a id="_idIndexMarker642"/>a similar macro that does not use an anonymous variable but instead takes the user-specified name:</p>
<pre class="source-code">
// Example 08a
#define ON_SCOPE_EXIT_ROLLBACK(NAME) \
  auto NAME = ScopeGuardOnExit() + [&amp;]()</pre>
<p>We can use it to complete the conversion of our code:</p>
<pre class="source-code">
// Example 08a
void Database::insert(const Record&amp; r) {
  S.insert(r);
  ON_SCOPE_EXIT { S.finalize(); };
  ON_SCOPE_EXIT_ROLLBACK(SG){ S.undo(); };
  I.insert(r);
  SG.commit();
}</pre>
<p>At this point, we should revisit the issue of composability. For three actions, each with its own rollback and cleanup, we now have the following:</p>
<pre class="source-code">
action1();
ON_SCOPE_EXIT { cleanup1; };
ON_SCOPE_EXIT_ROLLBACK(g2){ rollback1(); };
action2();
ON_SCOPE_EXIT { cleanup2; };
ON_SCOPE_EXIT_ROLLBACK(g4){ rollback2(); };
action3();
g2.commit();
g4.commit();</pre>
<p>One can see how this pattern is trivially extended to any number of actions. An observant reader might wonder whether they have noticed a bug in the code, though—should not the <a id="_idIndexMarker643"/>rollback guards be dismissed in reverse construction order? This is not a bug, although neither is the reverse order of all <code>commit()</code> calls. The reason is that <code>commit()</code> cannot throw an exception, it was declared <code>noexcept</code>, and indeed its implementation is such that no exception can be thrown. This is vitally important for the ScopeGuard pattern to work; if <code>commit()</code> could throw, then there would be no way to guarantee that all rollback guards are properly disarmed. At the end of the scope, some actions would be rolled back, and others would not, leaving the system in an inconsistent state.</p>
<p>While ScopeGuard was primarily designed to make exception-safe code easier to write, the interaction of the ScopeGuard pattern with exceptions is far from trivia<a id="_idTextAnchor540"/><a id="_idTextAnchor541"/><a id="_idTextAnchor542"/>l, and we should spend more time on it.</p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor543"/>ScopeGuard and exceptions</h1>
<p>The ScopeGuard pattern is designed to correctly run various cleanup and rollback operations <a id="_idIndexMarker644"/>automatically upon exiting a scope, no matter what caused the exit—normal completion by reaching the end of the scope, an early return, or an exception. This makes writing error-safe code in general, and exception-safe code in particular, much easier; as long as we queued up the right guards after every action, the correct cleanup and error handling will automatically happen. That is, of course, assuming that  ScopeGuard itself is functioning correctly in the presence of excep<a id="_idTextAnchor544"/>tions. We are going to learn how to make sure it does and how to use it <a id="_idTextAnchor545"/>to make the rest of the code error-safe.</p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor546"/>What must not throw an exception</h2>
<p>We have already seen that the <code>commit()</code> function that is used to commit an action and disarm <a id="_idIndexMarker645"/>the rollback guard must never throw an exception. Fortunately, that is easy to guarantee since all this function does is set a flag. But what happens if the rollback function also fails, and throws an exception?</p>
<pre class="source-code">
// Example 09
void Database::insert(const Record&amp; r) {
  S.insert(r);
  auto SF = MakeGuard([&amp;] { S.finalize(); });
  auto SG = MakeGuard([&amp;] { S.undo(); });
             // What if undo() can throw?
  I.insert(r);    // Let's say this fails
  SG.commit();    // Commit never happens
}            // Control jumps here and undo() throws</pre>
<p>The short answer is <em class="italic">nothing good</em>. In general, we have a conundrum—we cannot allow the action, in our case the storage insertion, to remain, but we also cannot undo it, since that also fails. Specifically, in C++, two exceptions cannot propagate at the same time. For that reason, the destructors are not allowed to throw exceptions; a destructor may be called when an exception is thrown, and if that destructor also throws, we now have two exceptions propagating at the same time. If this happens, the program immediately terminates. This is not so much a shortcoming of the language as a reflection on the unsolvable nature of the problem in general; we cannot let things stay the way they are, but we also failed in an attempt to change something. There aren’t any good options left.</p>
<p>In general, there are three ways a C++ program can handle this situation. The best option is not to fall into this trap—if the rollback cannot throw, none of this will happen. A well-written exception-safe program thus goes to great lengths to provide non-throwing rollback and cleanup. For example, the main action can produce the new data and have it ready, then making the data available to the callers is as simple as swapping a pointer, definitely a non-throwing operation. The rollback involves only swapping the pointer back and maybe deleting something (as we already said, destructors should not throw exceptions; if they do, the program behavior is undefined).</p>
<p>The second option <a id="_idIndexMarker646"/>is to suppress the exception in the rollback. We tried to undo the operation, it didn’t work, there is nothing else we can do about it, so let’s push on. The danger here is that the program may be in an undefined state, and every operation from this point forward may be incorrect. This is, however, the worst-case scenario. In practice, the consequences may be less severe. For example, for our database, we may know that if the rollback fails, there is a chunk of disk space that is claimed by the record but is unreachable from the index. The caller will be correctly informed that the insertion failed, but we have wasted some disk space. This may be preferable to terminating the program outright. If this is what we want, we have to catch any exceptions that might be thrown by the ScopeGuard action:</p>
<pre class="source-code">
// Example 09a
template &lt;typename Func&gt;
class ScopeGuard : public ScopeGuardBase {
  public:
  ...
  ~ScopeGuard() {
    if (!commit_) try { func_(); } catch (...) {}
  }
  ...
};</pre>
<p>The <code>catch</code> clause is empty; we catch everything but do nothing. This implementation is sometimes <a id="_idIndexMarker647"/>called a <em class="italic">shielded ScopeGuard</em>.</p>
<p>The final option is to allow the program to fail. That will happen with no effort on our part if we just let two exceptions happen, but we could also print a message or otherwise signal to the user what is about to happen and why. If we want to insert our own dying action before the program terminates, we have to write code that is very similar to previously:</p>
<pre class="source-code">
template &lt;typename Func&gt;
class ScopeGuard : public ScopeGuardBase {
  public:
  ...
  ~ScopeGuard() {
    if (!commit_) try { func_(); } catch (...) {
      s<a id="_idTextAnchor547"/>td::cout &lt;&lt; "Rollback failed" &lt;&lt; std::endl;
      throw;    // Rethrow
    }
  }
  ...
};</pre>
<p>The key difference is the <code>throw;</code> statement without any arguments. This re-throws the exception <a id="_idIndexMarker648"/>we caught and allows it to continue propagating.</p>
<p>The difference between the last two code fragments highlights a subtle detail that we have glossed over earlier, but one that will become important later. It is imprecise to say that in C++ the destructors should not throw exceptions. The correct statement is that an exception should not propagate out of the destructor. The destructor can throw anything it wants as long as it also catches it:</p>
<pre class="source-code">
class LivingDangerously {
  public:
  ~LivingDangerously() {
    try {
      if (cleanup() != SUCCESS) throw 0;
       more_cleanup();
    } catch (...) {
      std::cout &lt;&lt; "Cleanup failed, proceeding anyway" &lt;&lt;
      std::endl;
      // No rethrow - this is critical!
    }
  }
};</pre>
<p>Up until now, we have dealt with exceptions mostly as a nuisance; the program has to remain in a well-defined state if something somewhere throws something, but other than that, we have no use for these exceptions; we just pass them on. On the other hand, our code <a id="_idIndexMarker649"/>could work with any type of error handling, be it exceptions or error codes. If we knew for sure that errors are always signaled by exceptions and that any return from a function other than an exception thrown is a success, we could take advantage of that to automate the detection of success or failur<a id="_idTextAnchor548"/>e and therefore al<a id="_idTextAnchor549"/>low a commit or rollback to happen as needed.</p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor550"/>Exception-driven ScopeGuard</h2>
<p>We are now going to assume that if a function returns without throwing an exception, the operation has succeeded. If the function throws, it obviously failed. The objective now is to <a id="_idIndexMarker650"/>get rid of the explicit call to <code>commit()</code> and instead detect whether the destructor of ScopeGuard is executed because an exception was thrown, or because the function returned normally.</p>
<p>There are two parts to this implementation. The first part is specifying when we want the action to be taken. The cleanup guard must be executed regardless of how we exit the scope. The rollback guard is executed only in case of failure. For completeness, we can also have a guard that is executed only if the function has succeeded. The second part is determining what actually happened.</p>
<p>We will start with the second part. Our ScopeGuard now needs two additional parameters that will tell us whether it should be executed on success and whether it should be executed on failure (both can be enabled at the same time). Only the destructor of <code>ScopeGuard</code> needs to be modified:</p>
<pre class="source-code">
template &lt;typename Func, bool on_success, bool on_failure&gt;
class ScopeGuard {
  public:
  ...
  ~ScopeGuard() {
    if ((on_success &amp;&amp; is_success()) ||
        (on_failure &amp;&amp; is_failure())) func_();
  }
  ...
};</pre>
<p>We still <a id="_idIndexMarker651"/>need to figure out how to implement the  pseudo-functions <code>is_success()</code> and <code>is_failure()</code>. Remember that failure means that an exception was thrown. In C++, we have a function for that: <code>std::uncaught_exception()</code>. It returns true if an exception is currently propagating, and false otherwise. Armed with this knowledge, we can implement our guard:</p>
<pre class="source-code">
// Example 10
template &lt;typename Func, bool on_success, bool on_failure&gt;
class ScopeGuard {
  public:
  ...
  ~ScopeGuard() {
    if ((on_success &amp;&amp; !std::uncaught_exception()) ||
        (on_failure &amp;&amp; std::uncaught_exception())) func_();
  }
  ...
};</pre>
<p>Now, back to the first part: <code>ScopeGuard</code> will execute the delayed action if the conditions are right, so how do we tell it what conditions are right? Using the macro approach we developed earlier, we can define three versions of the guard—<code>ON_SCOPE_EXIT</code> is always executed, <code>ON_SCOPE_SUCCESS</code> is executed only if no exceptions were thrown, and <code>ON_SCOPE_FAILURE</code> is executed if an exception was thrown. The latter replaces our <code>ON_SCOPE_EXIT_ROLLBACK</code> macro, only now it too can use an <a id="_idIndexMarker652"/>anonymous variable name, since there are no explicit calls to <code>commit()</code>. The three macros are defined in a very similar way, we just need three different unique types instead of one <code>ScopeGuardOnExit</code>, so we can decide which <code>operator+()</code> to call:</p>
<pre class="source-code">
// Example 10
struct ScopeGuardOnExit {};
template &lt;typename Func&gt;
auto operator+(ScopeGuardOnExit, Func&amp;&amp; func) {
  return
    ScopeGuard&lt;Func, true, true&gt;(std::forward&lt;Func&gt;(func));
}
#define ON_SCOPE_EXIT auto ANON_VAR(SCOPE_EXIT_STATE) = \
  ScopeGuardOnExit() + [&amp;]()
struct ScopeGuardOnSuccess {};
template &lt;typename Func&gt;
auto operator+(ScopeGuardOnSuccess, Func&amp;&amp; func) {
  return
   ScopeGuard&lt;Func, true, false&gt;(std::forward&lt;Func&gt;(func));
}
#define ON_SCOPE_SUCCESS auto ANON_VAR(SCOPE_EXIT_STATE) =\
  ScopeGuardOnSuccess() + [&amp;]()
struct ScopeGuardOnFailure {};
template &lt;typename Func&gt;
auto operator+(ScopeGuardOnFailure, Func&amp;&amp; func) {
  return
   ScopeGuard&lt;Func, false, true&gt;(std::forward&lt;Func&gt;(func));
}
#define ON_SCOPE_FAILURE auto ANON_VAR(SCOPE_EXIT_STATE) =\
  ScopeGuardOnFailure() + [&amp;]()</pre>
<p>Each overload of <code>operator+()</code> constructs a <code>ScopeGuard</code> object with different Boolean <a id="_idIndexMarker653"/>arguments that control when it does and does not execute. Each macro directs the lambda expression to the desired overload by specifying the type of the first argument to the <code>operator+()</code> using one of the unique tree types we defined just for this purpose: <code>ScopeGuardOnEx<a id="_idTextAnchor551"/>it</code>, <code>ScopeGuardOnSuccess</code>, and <code>ScopeGuardOnFailure</code>.</p>
<p>This implementation can pass simple and even fairly elaborate tests and appears to work. Unfortunately, it has a fatal flaw—it does not correctly detect success or failure. To be sure, it works fine if our <code>Database::insert()</code> function was called from the normal control flow, where it may or may not succeed. The problem is we may call <code>Database::insert()</code> from a destructor of some other object, and that object may be used in a scope where an exception is thrown:</p>
<pre class="source-code">
class ComplexOperation {
  Database db_;
  public:
  ...
  ~ComplexOperation() {
    try {
      db_.insert(some_record);
    } catch (...) {}    // Shield any exceptions from insert()
  }
};
{
  ComplexOperation OP;
  throw 1;
}    // OP.~ComplexOperation() runs here</pre>
<p>Now, <code>db_.insert()</code> runs in the presence of an uncaught exception, and so <code>std::uncaught_exception()</code> will return <code>true</code>. The problem is this is not the exception we were looking for. This exception does not indicate that <code>insert()</code> failed, but it will be treated as such and the database insertion will be undone.</p>
<p>What we <a id="_idIndexMarker654"/>really need is to know how many exceptions are currently propagating. This may seem a strange statement since C++ does not allow multiple exceptions to propagate at the same time. However, we have already seen that this is an oversimplification; the second exception can propagate just fine as long as it does not escape the destructor. In the same manner, three or more exceptions can propagate if we have nested destructor calls, we just have to catch them all in time. To solve this problem correctly, we need to know how many exceptions were propagating when the <code>Database::insert()</code> function was called. Then, we can compare it with the number of exceptions propagating at the end of the function, however we got there. If these numbers are the same, <code>insert()</code> did not throw any exceptions, and any preexisting ones are not our concern. If a new exception was added, <code>insert()</code> has fail<a id="_idTextAnchor552"/>ed, and the exit handling must change accordingly.</p>
<p>C++17 lets us implement this detection; in addition to the previous <code>std::uncaught_exception()</code>, which is deprecated (and removed in C++20), we now have a new function, <code>std::uncaught_exceptions()</code>, which returns the number of currently propagating exceptions. We can now implement this <code>UncaughtExceptionDetector</code> to detect new exceptions:</p>
<pre class="source-code">
// Example 10a
class UncaughtExceptionDetector {
  public:
  UncaughtExceptionDetector() :
    count_(std::uncaught_exceptions()) {}
  operator bool() const noexcept {
    return std::uncaught_exceptions() &gt; count_;
  }
  private:
  const int count_;
};</pre>
<p>With <a id="_idIndexMarker655"/>this detector, we can finally implement the automatic <code>ScopeGuard</code>:</p>
<pre class="source-code">
// Example 10a
template &lt;typename Func, bool on_success, bool on_failure&gt;
class ScopeGuard {
  public:
  ...
  ~ScopeGuard() {
  if ((on_success &amp;&amp; !detector_) ||
      (on_failure &amp;&amp; detector_)) func_();
  }
  ...
  private:
  UncaughtExceptionDetector detector_;
  ...
};</pre>
<p>The need to use C++17 may present a (hopefully short-term) obstacle to using this technique in programs constrained to older versions of the language. While there is no other standard-compliant, portable way to solve this problem, most modern compilers have ways <a id="_idIndexMarker656"/>to get to the uncaught exception counter. This is how it is done in GCC or Clang (the names starting with <code>__</code> are GCC internal types and functions):</p>
<pre class="source-code">
// Example 10b
namespace  cxxabiv1 {
  struct cxa_eh_globals;
  extern "C" cxa_eh_globals* cxa_get_globals() noexcept;
}
class UncaughtExceptionDetector {
  public:
  UncaughtExceptionDetector() :
    count_(uncaught<a id="_idTextAnchor553"/>_exceptions()) {}
  operator bool() const noexcept {
    return uncaught_exceptions() &gt; count_;
  }
  private:
  const int count_;
  int uncaught_exceptions() const noexcept {
    return *(reinterpret_cast&lt;int*&gt;(
      static_cast&lt;char*&gt;( static_cast&lt;void*&gt;(
        cxxabiv1::cxa_get_globals())) + sizeof(void*)));
  }
};</pre>
<p>Whether we use the exception-driven ScopeGuard or the explicitly named ScopeGuard (perhaps to handle error codes as well as exceptions), we have accomplished our goals—we now can specify deferred actions that must be taken at the end of a function or any other scope.</p>
<p>At the <a id="_idIndexMarker657"/>end of this chapter, we will show another implementation of ScopeGuard that can be found in several <a id="_idTextAnchor554"/>sources on the web. This implementation deserves some considerati<a id="_idTextAnchor555"/>on, but you should be aware of the downsides as well.</p>
<h1 id="_idParaDest-210"><a id="_idTextAnchor556"/>Type-erased ScopeGuard</h1>
<p>If you search online for a ScopeGuard example, you may chance upon an implementation <a id="_idIndexMarker658"/>that uses <code>std::function</code> instead of a class template. The implementation itself is quite simple:</p>
<pre class="source-code">
// Example 11
class ScopeGuard {
  public:
  template &lt;typename Func&gt; ScopeGuard(Func&amp;&amp; func) :
    func_(std::forward&lt;Func&gt;(func)) {}
  ~ScopeGuard() { if (!commit_) func_(); }
  void commit() const noexcept { commit_ = true; }
  ScopeGuard(ScopeGuard&amp;&amp; other) :
    commit_(other.commit_), func_(std::move(other.func_)) {
    other.commit();
  }
  private:
  mutable bool commit_ = false;
  std::function&lt;void()&gt; func_;
  ScopeGuard&amp; operator=(const ScopeGuard&amp;) = delete;
};</pre>
<p>Note that this ScopeGuard is a class, not a class template. It has template constructors that can accept the same lambda expression or another callable object as the other guard. But the variable used to store that expression has the same type no matter what the type of the callable is. That type is <code>std::function&lt;void()&gt;</code>, a wrapper for any function that takes no arguments and returns nothing. How can a value of any type be stored in an <a id="_idIndexMarker659"/>object of some fixed type? That is the magic of type erasure, and we have a whole chapter dedicated to it (<a href="B19262_06.xhtml#_idTextAnchor266"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding Type Erasure</em>). This non-template ScopeGuard makes the code that uses it simpler (at least in the pre-C++17 version) because there are no types to deduce:</p>
<pre class="source-code">
void Database::insert(const Record&amp; r) {
  S.insert(r);
  ScopeGuard SF([&amp;] { S.finalize(); });
  ScopeGuard SG([&amp;] { S.undo(); });
  I.insert(r);
  SG.commit();
}</pre>
<p>There is, however, a serious downside to this approach—a type-erased object has to do a non-trivial amount of computation to achieve its magic. As a minimum, it involves an indirect or a virtual function call, and often some memory is allocated and deallocated as well.</p>
<p>Using the lessons of <a href="B19262_06.xhtml#_idTextAnchor266"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding Type Erasure</em>, we can come up with a slightly more efficient type erasure implementation; in particular, we can insist that the on-exit callable fits into the guard’s buffer:</p>
<pre class="source-code">
// Example 11
template &lt;size_t S = 16&gt;
class ScopeGuard : public CommitFlag {
  alignas(8) char space_[S];
  using guard_t = void(*)(void*);
  guard_t guard_ = nullptr;
  template&lt;typename Callable&gt;
  static void invoke(void* callable) {
    (*static_cast&lt;Callable*&gt;(callable))();
  }
  mutable bool commit_ = false;
  public:
  template &lt;typename Callable,
            typename D = std::decay_t&lt;Callable&gt;&gt;
    ScopeGuard(Callable&amp;&amp; callable) :
    guard_(invoke&lt;Callable&gt;) {
    static_assert(sizeof(Callable) &lt;= sizeof(space_));
    ::new(static_cast&lt;void*&gt;(space_))
      D(std::forward&lt;Callable&gt;(callable));
  }
  ScopeGuard(ScopeGuard&amp;&amp; other) = default;
  ~ScopeGuard() { if (!commit_) guard_(space_); }
};</pre>
<p>We can compare <a id="_idIndexMarker660"/>the runtime cost of the type-erased ScopeGuard versus the template <code>ScopeGuard</code> using the Google Benchmark library. The results will depend on what operation we are guarding, of course: for long computations and expensive on-exit actions, a slight difference in <code>ScopeGuard</code>’s run time makes no difference. The difference is going to be more pronounced if the computations in the scope and upon exiting the scope are fast:</p>
<pre class="source-code">
void BM_nodelete(benchmark::State&amp; state) {
  for (auto _ : state) {
    int* p = nullptr;
    ScopeGuardTypeErased::ScopeGuard SG([&amp;] { delete p; });
    p = rand() &lt; 0 ? new int(42) : nullptr;
  }
  state.SetItemsProcessed(state.iterations());
}</pre>
<p>Note that the <a id="_idIndexMarker661"/>memory is never allocated (<code>rand()</code> returns non-negative random numbers) and the pointer <code>p</code> is always <code>null</code>, so we are benchmarking the call to <code>rand()</code> plus the overhead of <code>ScopeGuard</code>. For comparison, we can call <code>delete</code> explicitly, without the guard. The result shows that the template version of the guard has no measurable overhead, while both type-erased implementations have some:</p>
<pre class="console">
Benchmark                              Time
-------------------------------------------
BM_nodelete_explicit                4.48 ns
BM_nodelete_type_erased             6.29 ns
BM_nodelete_type_erased_fast        5.48 ns
BM_nodelete_template                4.50 ns</pre>
<p>Our own type-erased version adds about 1 nanosecond to each iteration, and the one based on <code>std::function</code> takes almost twice as long. Benchmarks of this sort are strongly affected by compiler optimizations and can produce very different results in response to even slight changes in the code. For example, let us change the code to always construct the new object:</p>
<pre class="source-code">
void BM_nodelete(benchmark::State&amp; state) {
  for (auto _ : state) {
    int* p = nullptr;
    ScopeGuardTypeErased::ScopeGuard SG([&amp;] { delete p; });
    p = rand() &gt;= 0 ? new int(42) : nullptr;
  }
  state.SetItemsProcessed(state.iterations());
}</pre>
<p>Now we call the operator new on each iteration of the loop, so the corresponding deletion must happen as well. This time, the compiler was able to optimize the template <code>ScopeGuard</code> much better than the type-erased one:</p>
<pre class="console">
Benchmark                              Time
-------------------------------------------
BM_delete_explicit                  4.54 ns
BM_delete_type_erased               13.4 ns
BM_delete_type_erased_fast          12.7 ns
BM_delete_template                  4.56 ns</pre>
<p>Over<a id="_idTextAnchor557"/>all, there isn’t much of a reason to use type erasure here. The runtime cost may be negligible or significant, but there is usually nothing to gain in exchange. The only advantage of <a id="_idIndexMarker662"/>the type-erased version is that the guard itself is always of the same type. But the type of the guard is almost always irrelevant: we create the variable as <code>auto</code> or using constructor template argument deduction, and the only explicit operation we may need to do on the guard is to disarm it. Thus, we never need to write any code that depends on the guard’s type. Overall, the template-based ScopeGuard, with or without macros, remains the pattern of choice for automatically releasing res<a id="_idTextAnchor558"/>ources and performing other actions at the end of a scope.</p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor559"/>Summary</h1>
<p>In this chapter, we have studied, in detail, one of the best C++ patterns for writing exception-safe and error-safe code. The ScopeGuard pattern allows us to schedule an arbitrary action, a fragment of C++ code, to be executed upon completion of a scope. The scope may be a function, the body of a loop, or just a scope inserted into the program to manage the lifetime of local variables. The actions that are executed to the end may be conditional on the successful completion of the scope, however, that is defined. The ScopeGuard pattern works equally well when success or failure are indicated by return codes or exceptions, although in the latter case we can automatically detect the failure (with return codes, the programmer has to explicitly specify which return values mean success and which do not). We have observed the evolution of the ScopeGuard pattern as more recent language features are used. In its optimal form, ScopeGuard provides a simple declarative way to specify post-conditions and deferred actions, such as cleanup or rollback, in a manner that is trivially composable for any number of actions that need to be committed or undone.</p>
<p>The next chapter describes another very C++-specific pattern, the Friends Factory, which is a kind of Factory, only instead of objects during the execution of a <a id="_idTextAnchor560"/>program, it manufactures functions during its compilation.</p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor561"/>Questions</h1>
<ol>
<li>What is an error-safe or exception-safe, program?</li>
<li>How can we make a routine that performs several related actions be error-safe?</li>
<li>How does RAII assist in writing error-safe programs?</li>
<li>How does the ScopeGuard pattern generalize the RAII idiom?</li>
<li>How can the program automatically detect when a function exits successfully and when it fails?</li>
<li>What are the advantages and drawbacks of a type-erased ScopeGuard</li>
</ol>
</div>
</body></html>