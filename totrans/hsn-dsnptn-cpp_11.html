<html><head></head><body>
<div id="_idContainer027">
<h1 class="chapter-number" id="_idParaDest-198"><a id="_idTextAnchor509"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-199"><a id="_idTextAnchor510"/><a id="_idTextAnchor511"/><a id="_idTextAnchor512"/><span class="koboSpan" id="kobo.2.1">ScopeGuard</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This chapter covers a pattern that can be seen as a generalization of the RAII idiom we studied earlier. </span><span class="koboSpan" id="kobo.3.2">In its earliest form, it is an old and established C++ pattern, however, it is also one that has particularly benefited from the language additions in C++11, C++14, and C++17. </span><span class="koboSpan" id="kobo.3.3">We will witness the evolution of this pattern as the language becomes more powerful. </span><span class="koboSpan" id="kobo.3.4">The ScopeGuard pattern exists at the intersection of declarative programming (say what you want to happen, not how you want it done) and error-safe programs (especially exception safety). </span><span class="koboSpan" id="kobo.3.5">We will have to learn a bit about both before we fully </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">understand ScopeGuard.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">How can we write error-safe and exception-safe code? </span><span class="koboSpan" id="kobo.7.2">How does RAII make error </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">handling easier?</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">What is composability as applied to </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">error handling?</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Why is RAII not powerful enough for error handling, and how is it generalized? </span><span class="koboSpan" id="kobo.11.2">How can we implement declarative error handling </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">in C++?</span></span></li>
</ul>
<h1 id="_idParaDest-200"><a id="_idTextAnchor513"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.14.1">Here is the example </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">code: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter11"><span class="No-Break"><span class="koboSpan" id="kobo.16.1">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter11</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.17.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">You will also need the Google Benchmark library installed and configured: </span><a href="https://github.com/google/benchmark"><span class="koboSpan" id="kobo.19.1">https://github.com/google/benchmark</span></a><span class="koboSpan" id="kobo.20.1"> (see </span><a href="B19262_04.xhtml#_idTextAnchor152"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.21.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.22.1">, </span><em class="italic"><span class="koboSpan" id="kobo.23.1">Swap – From Simple to Subtle</span></em><span class="koboSpan" id="kobo.24.1">, for </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">installation instructions).</span></span></p>
<p><a id="_idTextAnchor514"/><span class="koboSpan" id="kobo.26.1">This chapter is rather heavy on advanced C++ features, so keep a C++ reference nearby (</span><a href="https://en.cppreference.com"><span class="koboSpan" id="kobo.27.1">https://en.cppreference.com</span></a><span class="koboSpan" id="kobo.28.1"> unless you want to dig through the </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">standard itself).</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">Finally, a very thorough and complete implementation of ScopeGuard can be found in the Folly library: </span><a href="https://github.com/facebook/folly/blob/master/folly/ScopeGuard.h"><span class="koboSpan" id="kobo.31.1">https://github.com/facebook/folly/blob/master/folly/ScopeGuard.h</span><span id="_idTextAnchor515"/></a><span class="koboSpan" id="kobo.32.1">; it includes C++ library programming details beyond those covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">this book.</span></span></p>
<h1 id="_idParaDest-201"><a id="_idTextAnchor516"/><span class="koboSpan" id="kobo.34.1">Error handling and resource acquisition is initialization</span></h1>
<p><span class="koboSpan" id="kobo.35.1">We begin by reviewing the concepts of error handling, and, in particular, writing exception-safe </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.36.1">code in C++. </span><span class="koboSpan" id="kobo.36.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">Resource Acquisition Is Initialization</span></strong><span class="koboSpan" id="kobo.38.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.39.1">RAII</span></strong><span class="koboSpan" id="kobo.40.1">) idiom is </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.41.1">one of the primary methods of error handling in C++. </span><span class="koboSpan" id="kobo.41.2">We have already dedicated an entire chapter to it, and you will need it here to make sense of what we are about to do. </span><span class="koboSpan" id="kobo.41.3">Let’s first recognize th</span><a id="_idTextAnchor517"/><span class="koboSpan" id="kobo.42.1">e problem we </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">are facing</span><a id="_idTextAnchor518"/><span class="koboSpan" id="kobo.44.1">.</span></span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor519"/><span class="koboSpan" id="kobo.45.1">Error safety and exception safety</span></h2>
<p><span class="koboSpan" id="kobo.46.1">For the rest of this chapter, we will consider the following problem—suppose we are implementing </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.47.1">a database of records. </span><span class="koboSpan" id="kobo.47.2">The records are stored </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.48.1">on disk, but there is also an in-memory index for fast access to the records. </span><span class="koboSpan" id="kobo.48.2">The database API offers a method to insert records into </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">the database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.50.1">
class Record { ... </span><span class="koboSpan" id="kobo.50.2">};
class Database {
  public:
  void insert(const Record&amp; r);
  ...
</span><span class="koboSpan" id="kobo.50.3">};</span></pre>
<p><span class="koboSpan" id="kobo.51.1">If the insertion succeeds, both the index and the disk storage are updated and consistent with each other. </span><span class="koboSpan" id="kobo.51.2">If something goes wrong, an exception </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">is thrown.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">While it appears to the clients of the database that the insertion is a single transaction, the implementation has to deal with the fact that it is done in multiple steps—we need to insert the record into the index and write it to disk. </span><span class="koboSpan" id="kobo.53.2">To facilitate this, the database contains two classes, each responsible for its type </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">of storage:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.55.1">
class Database {
  class Storage { ... </span><span class="koboSpan" id="kobo.55.2">};    // Disk storage Storage S;
  class Index { ... </span><span class="koboSpan" id="kobo.55.3">};    // Memory index Index I;
  public:
  void insert(const Record&amp; r);
  ...
</span><span class="koboSpan" id="kobo.55.4">};</span></pre>
<p><span class="koboSpan" id="kobo.56.1">The </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.57.1">implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">insert()</span></strong><span class="koboSpan" id="kobo.59.1"> function must insert the record into both the storage </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.60.1">and the index, there is no way </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">around it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.62.1">
//Example 01
void Database::insert(const Record&amp; r) {
  S.insert(r);
  I.insert(r);
}</span></pre>
<p><span class="koboSpan" id="kobo.63.1">Unfortunately, either of these operations can fail. </span><span class="koboSpan" id="kobo.63.2">Let’s see first what happens if the storage insertion fails. </span><span class="koboSpan" id="kobo.63.3">Let’s assume that all failures in the program are signaled by throwing exceptions. </span><span class="koboSpan" id="kobo.63.4">If the storage insertion fails, the storage remains unchanged, the index insertion is not attempted at all, and the exception is propagated out of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">Database::insert()</span></strong><span class="koboSpan" id="kobo.65.1"> function. </span><span class="koboSpan" id="kobo.65.2">That is exactly what we want—the insertion failed, the database is unchanged, and an exception </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">is thrown.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">So, what happens if the storage insertion succeeds but the index fails? </span><span class="koboSpan" id="kobo.67.2">Things are not looking so good this time—the disk is altered successfully, then the index insertion fails, and the exception propagates to the caller of </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">Database::insert()</span></strong><span class="koboSpan" id="kobo.69.1"> to signal the insertion failure, but the truth is the insertion did not completely fail. </span><span class="koboSpan" id="kobo.69.2">It did not completely </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">succeed either.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">The database is left in an inconsistent state; there is a record on disk that is not accessible from the index. </span><span class="koboSpan" id="kobo.71.2">This is a failure to handle an error condition, exception-unsafe code, and it just </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">won’t do.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">The impulsive attempt to change the order of the sub-operations does </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">not help:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.75.1">
void Database::insert(const Record&amp; r) {
  I.insert(r);
  S.insert(r);
}</span></pre>
<p><span class="koboSpan" id="kobo.76.1">Sure, everything is now fine if the index fails. </span><span class="koboSpan" id="kobo.76.2">But we have the same problem if the storage </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.77.1">insertion throws an exception—we now have an entry in the index </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.78.1">that is pointing to nowhere since the record was never written </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">to disk.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">Obviously, we cannot just ignore the exceptions thrown by </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">Index</span></strong><span class="koboSpan" id="kobo.82.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">Storage</span></strong><span class="koboSpan" id="kobo.84.1">; we have to somehow deal with them to maintain the consistency of the database. </span><span class="koboSpan" id="kobo.84.2">We know how to handle exceptions; that’s what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">try-catch</span></strong><span class="koboSpan" id="kobo.86.1"> block </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">is for:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.88.1">
// Example 02
void Database::insert(const Record&amp; r) {
  S.insert(r);
  try {
    I.insert(r);
  } catch (...) {
    S.undo();
    throw;    // Rethrow
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.89.1">Again, if the storage fails, we don’t need to do anything special. </span><span class="koboSpan" id="kobo.89.2">If the index fails, we have to undo the last operation on the storage (let’s assume that it has the API to do that). </span><span class="koboSpan" id="kobo.89.3">Now the database is again consistent as if the insertion never happened. </span><span class="koboSpan" id="kobo.89.4">Even though we caught the exception thrown by the index, we still need to signal to the caller that the insertion fails, so we re-throw the exception. </span><span class="koboSpan" id="kobo.89.5">So far, </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">so good.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">The situation </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.92.1">is not much different if we choose to use </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.93.1">error codes instead of exceptions; let’s consider the variant where all </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">insert()</span></strong><span class="koboSpan" id="kobo.95.1"> functions return </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">true</span></strong><span class="koboSpan" id="kobo.97.1"> if they succeed and </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">false</span></strong><span class="koboSpan" id="kobo.99.1"> if </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">they fail:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.101.1">
bool Database::insert(const Record&amp; r) {
  if (!S.insert(r)) return false;
  if (!I.insert(r)) {
    S.undo();
    return false;
  }
  return true;
}</span></pre>
<p><span class="koboSpan" id="kobo.102.1">We have to check the return value of every function, undo the first action if the second one fails, and return </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">true</span></strong><span class="koboSpan" id="kobo.104.1"> only if both </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">actions succeed.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">So far, so good; we were able to fix the simplest two-stage problem, so the code is error-safe. </span><span class="koboSpan" id="kobo.106.2">Now, it is time to up the complexity. </span><span class="koboSpan" id="kobo.106.3">Suppose that our storage needs some cleanup to be performed at the end of the transaction, for example, the inserted record is not in its final state until we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">Storage::finalize()</span></strong><span class="koboSpan" id="kobo.108.1"> method (maybe this is done so </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">Storage::undo()</span></strong><span class="koboSpan" id="kobo.110.1"> can work, and after the insertion is finalized it can no longer be undone). </span><span class="koboSpan" id="kobo.110.2">Note the difference between </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">undo()</span></strong><span class="koboSpan" id="kobo.112.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">finalize()</span></strong><span class="koboSpan" id="kobo.114.1">; the former must be called only if we want to roll back the transaction, while the latter must be called if the storage insertion succeeded, regardless of what </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">happe</span><a id="_idTextAnchor520"/><span class="koboSpan" id="kobo.116.1">ns after.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">Our requirements are met with this flow </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">of control:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.119.1">
// Example 02a:
void Database::insert(const Record&amp; r) {
  S.insert(r);
  try {
    I.insert(r);
  } catch (...) {
    S.undo();
    S.finalize();
    throw;
  }
  S.finalize();
}</span></pre>
<p><span class="koboSpan" id="kobo.120.1">Or we have </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.121.1">something similar in the case of returning error codes (for the rest of this chapter, we will use exceptions in all our examples, but conversion </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.122.1">to error codes is </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">not hard).</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">This is already getting ugly, particularly the part about getting the cleanup code (in our case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">S.finalize()</span></strong><span class="koboSpan" id="kobo.126.1">) to run in every execution path. </span><span class="koboSpan" id="kobo.126.2">It’s only going to get worse if we have a more complex sequence of actions that must all be undone unless the entire operation succeeds. </span><span class="koboSpan" id="kobo.126.3">Here is the control flow for three actions, each with its own rollback </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">and cleanup:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.128.1">
if (action1() == SUCCESS) {
  if (action2() == SUCCESS) {
    if (action3() == FAIL) {
      rollback2();
      rollback1();
    }
    cleanup2();
  } else {
    rollback1();
  }
  cleanup1();
}</span></pre>
<p><span class="koboSpan" id="kobo.129.1">The obvious problem is the explicit tests for success, either as conditionals or as try-catch blocks. </span><span class="koboSpan" id="kobo.129.2">The more </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.130.1">serious problem is that this way of </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.131.1">error handling is not composable. </span><span class="koboSpan" id="kobo.131.2">The solution for N+1 actions is not the code for N actions with some bits added to it; no, we have to go deep inside the code and add the right pieces there. </span><span class="koboSpan" id="kobo.131.3">But we have already seen the C++ idiom for solving this </span><a id="_idTextAnchor521"/><a id="_idTextAnchor522"/><a id="_idTextAnchor523"/><span class="No-Break"><span class="koboSpan" id="kobo.132.1">very problem.</span></span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor524"/><span class="koboSpan" id="kobo.133.1">Resource Acquisition Is Initialization</span></h2>
<p><span class="koboSpan" id="kobo.134.1">The RAII idiom </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.135.1">binds resources to objects. </span><span class="koboSpan" id="kobo.135.2">The object is constructed when the resource is acquired, and the resource is deleted when the object is destroyed. </span><span class="koboSpan" id="kobo.135.3">In our case, we are interested only in the second half, the destruction. </span><span class="koboSpan" id="kobo.135.4">The advantage of the RAII idiom is that the destructors of all local objects must be called when the control reaches the end of the scope, regardless of how it happens (</span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">return</span></strong><span class="koboSpan" id="kobo.137.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">throw</span></strong><span class="koboSpan" id="kobo.139.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">break</span></strong><span class="koboSpan" id="kobo.141.1">, and so on). </span><span class="koboSpan" id="kobo.141.2">Since we struggled with the cleanup, let’s hand that off to an </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">RAII object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.143.1">
// Example 02b:
class StorageFinalizer {
  public:
  StorageFinalizer(Storage&amp; S) : S_(S) {}
  ~StorageFinalizer() { S_.finalize(); }
  private:
  Storage&amp; S_;
};
void Database::insert(const Record&amp; r) {
  S.insert(r);
  StorageFinalizer SF(S);
  try {
    I.insert(r);
  } catch (...) {
    S.undo();
    throw;
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.144.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">StorageFinalizer</span></strong><span class="koboSpan" id="kobo.146.1"> object binds to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">Storage</span></strong><span class="koboSpan" id="kobo.148.1"> object when it is constructed and calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">finalize()</span></strong><span class="koboSpan" id="kobo.150.1"> when it is destroyed. </span><span class="koboSpan" id="kobo.150.2">Since there is no way to exit the scope in which the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">StorageFinalizer</span></strong><span class="koboSpan" id="kobo.152.1"> object is defined without calling its destructor, we do not need to worry about the control flow, at least for the cleanup; it is going to happen. </span><span class="koboSpan" id="kobo.152.2">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">StorageFinalizer</span></strong><span class="koboSpan" id="kobo.154.1"> is properly constructed after the storage insertion succeeds; if the first insertion fails, there is nothing </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">to finalize.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">This code works, but it looks somehow half-done; we have two actions that are performed </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.157.1">at the end of the function, and the first one (cleanup, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">finalize()</span></strong><span class="koboSpan" id="kobo.159.1">) is automated while the second one (rollback, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">undo()</span></strong><span class="koboSpan" id="kobo.161.1">) is not. </span><span class="koboSpan" id="kobo.161.2">Also, the technique is still not composable; here is the flow of control for </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">three actions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.163.1">
class Cleanup1() {
  ~Cleanup1() { cleanup1(); }
  ...
</span><span class="koboSpan" id="kobo.163.2">};
class Cleanup2() {
  ~Cleanup2() { cleanup2(); }
  ...
</span><span class="koboSpan" id="kobo.163.3">};
action1();
Cleanup1 c1;
try {
  action2();
  Cleanup2 c2;
  try {
    action3();
  } catch (...) {
    rollback2();
    throw;
  }
} catch (...) {
  rollback1();
}</span></pre>
<p><span class="koboSpan" id="kobo.164.1">Again, to add another action, we have to add a try-catch block deep in the code. </span><span class="koboSpan" id="kobo.164.2">On the other hand, the cleanup </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.165.1">part by itself is perfectly composable. </span><span class="koboSpan" id="kobo.165.2">Consider what the previous code looks like if we don’t need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">a rollback:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.167.1">
action1();
Cleanup1 c1;
action2();
Cleanup2 c2;</span></pre>
<p><span class="koboSpan" id="kobo.168.1">If we need one more action, we simply add two lines at the end of the function, and the cleanup happens in the right order. </span><span class="koboSpan" id="kobo.168.2">If we could do the same for the rollback, we would be </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">all set.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">We cannot simply move the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">undo()</span></strong><span class="koboSpan" id="kobo.172.1"> into a destructor of another object; the destructors are always called, but the rollback happens only in the case of an error. </span><span class="koboSpan" id="kobo.172.2">But we can make the destructor call the </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">rollback conditionally:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
// Example 03:
class StorageGuard {
  public:
  StorageGuard(Storage&amp; S) : S_(S) {}
  ~StorageGuard() {
    if (!commit_) S_.undo();
  }
  void commit() noexcept { commit_ = true; }
  private:
  Storage&amp; S_;
  bool commit_ = false;
};
void Database::insert(const Record&amp; r) {
  S.insert(r);
  Storage</span><a id="_idTextAnchor525"/><span class="koboSpan" id="kobo.175.1">Finalizer SF(S);
  StorageGuard SG(S);
  I.insert(r);
  SG.commit();
}</span></pre>
<p><span class="koboSpan" id="kobo.176.1">Examine the </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.177.1">code now; if the storage insertion fails, the exception is thrown and the database is unchanged. </span><span class="koboSpan" id="kobo.177.2">If it succeeds, two RAII objects are constructed. </span><span class="koboSpan" id="kobo.177.3">The first one will unconditionally call </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">S.finalize()</span></strong><span class="koboSpan" id="kobo.179.1"> at the end of the scope. </span><span class="koboSpan" id="kobo.179.2">The second one will call </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">S.undo()</span></strong><span class="koboSpan" id="kobo.181.1"> unless we commit the change first by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">commit()</span></strong><span class="koboSpan" id="kobo.183.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">StorageGuard</span></strong><span class="koboSpan" id="kobo.185.1"> object. </span><span class="koboSpan" id="kobo.185.2">That will happen unless the index insertion fails, in which case an exception is thrown, the rest of the code in the scope is bypassed, and the control jumps straight to the end of the scope (the closing </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">}</span></strong><span class="koboSpan" id="kobo.187.1">) where the destructors of all local objects are called. </span><span class="koboSpan" id="kobo.187.2">Since we never called </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">commit()</span></strong><span class="koboSpan" id="kobo.189.1"> in this scenario, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">StorageGuard</span></strong><span class="koboSpan" id="kobo.191.1"> is still active and will undo the insertion. </span><span class="koboSpan" id="kobo.191.2">Note also that there are no explicit </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">try-catch</span></strong><span class="koboSpan" id="kobo.193.1"> blocks at all: the actions that used to be in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">catch</span></strong><span class="koboSpan" id="kobo.195.1"> clause are now done by the destructors. </span><span class="koboSpan" id="kobo.195.2">The exception should be, of course, caught eventually (in all examples that accompany this chapter, the exception is caught </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">main()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">The destructors of the local objects are called in reverse construction order. </span><span class="koboSpan" id="kobo.199.2">This is important; if we have to undo the insertion, this can be done only until the action is finalized, so the rollback has to happen before the cleanup. </span><span class="koboSpan" id="kobo.199.3">Therefore, we construct the RAII objects in the correct order—first, the cleanup (to be done last), then the rollback guard (to be done first, </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">if necessary).</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">The code now </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.202.1">looks very nice, with no try-catch blocks at all. </span><span class="koboSpan" id="kobo.202.2">In some ways, it does not look </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.203.1">like regular C++. </span><span class="koboSpan" id="kobo.203.2">This programming style is called </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">declarative programming</span></strong><span class="koboSpan" id="kobo.205.1">; it is a programming paradigm in which the program logic is expressed without explicitly stating the flow of control (the opposite, and the </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.206.1">more common in C++, is </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">imperative programming</span></strong><span class="koboSpan" id="kobo.208.1">, where the program describes which steps to do and in what order, but not necessarily why). </span><span class="koboSpan" id="kobo.208.2">There are declarative programming languages (the prime example is SQL), but C++ is not one of them. </span><span class="koboSpan" id="kobo.208.3">Nonetheless, C++ is very good at implementing constructs that allow the creation of higher-order languages on top of C++, and so we have implemented a declarative error-handling language. </span><span class="koboSpan" id="kobo.208.4">Our program now says that after the record was inserted into storage, two actions are pending—the cleanup and </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">the rollback.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">The rollback is disarmed if the entire function succeeds. </span><span class="koboSpan" id="kobo.210.2">The code looks linear, without the explicit flow of control, in other </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">words, declarative.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">Nice as it is, it is also far from perfect. </span><span class="koboSpan" id="kobo.212.2">The obvious problem is that we have to write a guard or a finalizer class for every action in our program. </span><span class="koboSpan" id="kobo.212.3">The less obvious one is that writing these classes correctly is not easy, and we have not done a particularly good job so far. </span><span class="koboSpan" id="kobo.212.4">Take a moment to figure out what is missing before looking at the fixed </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">version here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.214.1">
class StorageGuard {
  public:
  StorageGuard(Storage&amp; S) : S_(S), commit_(false) {}
  ~StorageGuard() { if (!c</span><a id="_idTextAnchor526"/><span class="koboSpan" id="kobo.215.1">ommit_) S_.undo(); }
  void commit() noexcept { commit_ = true; }
  private:
  Storage&amp; S_;
  bool commit_;
  // Important: really bad things happen if
  // this guard is copied!
</span><span class="koboSpan" id="kobo.215.2">  StorageGuard(const StorageGuard&amp;) = delete;
  StorageGuard&amp; operator=(const StorageGuard&amp;) = delete;
};
void Database::insert(const Record&amp; r) {
  S.insert(r);
  StorageFinalizer SF(S);
  StorageGuard SG(S);
  I.insert(r);
  SG.commit();
}</span></pre>
<p><span class="koboSpan" id="kobo.216.1">What we need </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.217.1">is a general framework that lets us schedule an arbitrary action to be executed at the end of the scope, unconditionally or conditionally. </span><span class="koboSpan" id="kobo.217.2">The </span><a id="_idTextAnchor527"/><span class="koboSpan" id="kobo.218.1">next section presents the pattern that provides such a </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">f</span><a id="_idTextAnchor528"/><span class="koboSpan" id="kobo.220.1">ramework, ScopeGuard.</span></span></p>
<h1 id="_idParaDest-204"><a id="_idTextAnchor529"/><span class="koboSpan" id="kobo.221.1">The ScopeGuard pattern</span></h1>
<p><span class="koboSpan" id="kobo.222.1">In this section, we learn how to write the on-exit action RAII classes such as the ones we implemented </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.223.1">in the previous section, but without all the boilerplate </span><a id="_idTextAnchor530"/><span class="koboSpan" id="kobo.224.1">code. </span><span class="koboSpan" id="kobo.224.2">This can be done in C++03 but is much improved in C++1</span><a id="_idTextAnchor531"/><span class="koboSpan" id="kobo.225.1">4, and again </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">in C++17.</span></span></p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor532"/><span class="koboSpan" id="kobo.227.1">ScopeGuard basics</span></h2>
<p><span class="koboSpan" id="kobo.228.1">Let’s start with </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.229.1">the more difficult problem—how to implement a generic rollback class, a generic version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">StorageGuard</span></strong><span class="koboSpan" id="kobo.231.1"> from the last section. </span><span class="koboSpan" id="kobo.231.2">The only difference between that and the cleanup class is that the cleanup is always active, but the rollback is canceled after the action is committed. </span><span class="koboSpan" id="kobo.231.3">If we have the conditional rollback version, we can always take out the condition check, and we get the cleanup version, so let’s not worry about that </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">for now.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">In our example, the rollback is a call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">S.undo()</span></strong><span class="koboSpan" id="kobo.235.1"> method. </span><span class="koboSpan" id="kobo.235.2">To simplify the example, let’s start </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.236.1">with a rollback that calls a regular function, not a </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">member function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
void undo(Storage&amp; S) { S.undo(); }</span></pre>
<p><span class="koboSpan" id="kobo.239.1">Once the implementation is finished, the program should look something </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
{
  S.insert(r);
  ScopeGuard SG(undo, S);    // Approximate desired syntax
  ...
</span><span class="koboSpan" id="kobo.241.2">  SG.commit();            // Disarm the scope guard
}</span></pre>
<p><span class="koboSpan" id="kobo.242.1">This code tells us (in a declarative manner!) that if the insert action succeeded, we schedule the </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.243.1">rollback to be done upon exiting the scope. </span><span class="koboSpan" id="kobo.243.2">The rollback will call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">undo()</span></strong><span class="koboSpan" id="kobo.245.1"> function with the argument </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">S</span></strong><span class="koboSpan" id="kobo.247.1">, which in turn will undo the insertion. </span><span class="koboSpan" id="kobo.247.2">If we made it to the end of the function, we disarm the guard and disable the rollback call, which commits the insertion and makes </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">it permanent.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">A much more general and reusable solution was proposed by Andrei Alexandrescu in the </span><em class="italic"><span class="koboSpan" id="kobo.250.1">Dr. </span><span class="koboSpan" id="kobo.250.2">Dobbs</span></em><span class="koboSpan" id="kobo.251.1"> article in 2000 (</span><a href="http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758?"><span class="koboSpan" id="kobo.252.1">http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758?</span></a><span class="koboSpan" id="kobo.253.1">). </span><span class="koboSpan" id="kobo.253.2">Let’s look at the implementation and </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">analyze it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.255.1">
// Example 04
class ScopeGuardImplBase {
  public:
  ScopeGuardImplBase() = default;
  void commit() const noexcept { commit_ = true; }
  protected:
  ScopeGuardImplBase(const ScopeGuardImplBase&amp; other) :
    commit_(other.commit_) { other.commit(); }
  ~ScopeGuardImplBase() {}
  mutable bool commit_ = false;
};
template &lt;typename Func, typename Arg&gt;
class ScopeGuardImpl : public ScopeGuardImplBase {
  public:
  ScopeGuardImpl(const Func&amp; func, Arg&amp; arg) :
    func_(func), arg_(arg) {}
  ~ScopeGuardImpl() { if (!commit_) func_(arg_); }
  private:
  const Func&amp; func_;
  Arg&amp; arg_;
};
template &lt;typename Func, typename Arg&gt;
ScopeGuardImpl&lt;Func, Arg&gt;
MakeGuard(const Func&amp; func, Arg&amp; arg) {
  return ScopeGuardImpl&lt;Func, Arg&gt;(func, arg);
}</span></pre>
<p><span class="koboSpan" id="kobo.256.1">From the top, we have </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.257.1">the base class for all the scope guards, </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">ScopeGuardImplBase</span></strong><span class="koboSpan" id="kobo.259.1">. </span><span class="koboSpan" id="kobo.259.2">The base class holds the commit flag and the code to manipulate it; the constructor initially creates the guard in the armed state, so the deferred action will happen in the destructor. </span><span class="koboSpan" id="kobo.259.3">The call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">commit()</span></strong><span class="koboSpan" id="kobo.261.1"> will prevent that from happening and make the destructor do nothing. </span><span class="koboSpan" id="kobo.261.2">Finally, there is a copy constructor that creates a new guard in the same state as the original but then disarms the original guard. </span><span class="koboSpan" id="kobo.261.3">This is so the rollback does not happen twice, from the destructors of both objects. </span><span class="koboSpan" id="kobo.261.4">The object is copyable but not assignable. </span><span class="koboSpan" id="kobo.261.5">We use C++03 features for everything here, including the disabled assignment operator. </span><span class="koboSpan" id="kobo.261.6">This implementation is fundamentally C++03; the few C++11 twists are just icing on the cake (that is about to change in the </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">next section).</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">There are several details of the implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">ScopeGuardImplBase</span></strong><span class="koboSpan" id="kobo.265.1"> that may seem odd and need elaboration. </span><span class="koboSpan" id="kobo.265.2">First of all, the destructor is not virtual; this is not a typo or a bug, this is intentional, as we will see later. </span><span class="koboSpan" id="kobo.265.3">Second, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">commit_</span></strong><span class="koboSpan" id="kobo.267.1"> flag is declared </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">mutable</span></strong><span class="koboSpan" id="kobo.269.1">. </span><span class="koboSpan" id="kobo.269.2">This is, of course, so that it can be changed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">commit()</span></strong><span class="koboSpan" id="kobo.271.1"> method, which we declared </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">const</span></strong><span class="koboSpan" id="kobo.273.1">. </span><span class="koboSpan" id="kobo.273.2">So, why is </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">commit()</span></strong><span class="koboSpan" id="kobo.275.1"> declared </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">const</span></strong><span class="koboSpan" id="kobo.277.1">? </span><span class="koboSpan" id="kobo.277.2">One reason is so we can call it on the source object from the copy constructor, to transfer the responsibility for the rollback from the other object to this one. </span><span class="koboSpan" id="kobo.277.3">In this sense, the copy constructor really does a move and will be officially declared as such later. </span><span class="koboSpan" id="kobo.277.4">The second reason for </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">const</span></strong><span class="koboSpan" id="kobo.279.1"> will become obvious later (it is related to the non-virtual destructor, of </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">all things).</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">Let’s now turn </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.282.1">to the derived class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">ScopeGuardImpl</span></strong><span class="koboSpan" id="kobo.284.1">. </span><span class="koboSpan" id="kobo.284.2">This is a class template with two type parameters—the first is the type of the function or any other callable object we are going to call for the rollback, and the second is the type of the argument. </span><span class="koboSpan" id="kobo.284.3">Our rollback function is restricted, for now, to having only one argument. </span><span class="koboSpan" id="kobo.284.4">That function is called in the destructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.286.1"> object unless the guard was disarmed by </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">commit()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">Finally, we have a factory function template, </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">MakeGuard</span></strong><span class="koboSpan" id="kobo.292.1">. </span><span class="koboSpan" id="kobo.292.2">This is a very common idiom in C++; if you need to create an instantiation of a class template from the constructor arguments, use a template function that can deduce the type of the parameters and that of the return value from the arguments (in C++17 class templates can do that too, as we will </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">see later).</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">How is this all used to create a guard object that will call </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">undo(S)</span></strong><span class="koboSpan" id="kobo.296.1"> for us? </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">Like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.298.1">
void Database::insert(const Record&amp; r) {
  S.insert(r);
  const ScopeGuardImplBase&amp; SG = MakeGuard(undo, S);
  I.insert(r);
  SG.commit();
}</span></pre>
<p><span class="koboSpan" id="kobo.299.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">MakeGaurd</span></strong><span class="koboSpan" id="kobo.301.1"> function deduces the types of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">undo()</span></strong><span class="koboSpan" id="kobo.303.1"> function and the argument </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">S</span></strong><span class="koboSpan" id="kobo.305.1"> and returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.307.1"> object of the corresponding type. </span><span class="koboSpan" id="kobo.307.2">The return is by value, so there is a copy involved (the compiler may choose to elide the copy as an optimization, but is not required to). </span><span class="koboSpan" id="kobo.307.3">The returned object is a temporary variable, it has no name and binds it to the base class reference </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">SG</span></strong><span class="koboSpan" id="kobo.309.1"> (casting from the derived class to the base class is implicit for both pointers and references). </span><span class="koboSpan" id="kobo.309.2">The lifetime of the temporary variable is until the closing semicolon of the statement that created it, as everyone knows. </span><span class="koboSpan" id="kobo.309.3">But then, what does the </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">SG</span></strong><span class="koboSpan" id="kobo.311.1"> reference point to after the end of the statement? </span><span class="koboSpan" id="kobo.311.2">It has to be bound to something, as references cannot be unbound, they are not like </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">NULL</span></strong><span class="koboSpan" id="kobo.313.1"> pointers. </span><span class="koboSpan" id="kobo.313.2">The truth is, “everyone” knows wrong, or rather only mostly right—usually, the temporaries indeed live until the end of the statement. </span><span class="koboSpan" id="kobo.313.3">However, binding a temporary to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">const</span></strong><span class="koboSpan" id="kobo.315.1"> reference extends its lifetime to coincide with the lifetime of the reference itself. </span><span class="koboSpan" id="kobo.315.2">In other words, the unnamed temporary </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.317.1"> object created by </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">MakeGuard</span></strong><span class="koboSpan" id="kobo.319.1"> will not be destroyed until the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">SG</span></strong><span class="koboSpan" id="kobo.321.1"> reference goes out of scope. </span><span class="koboSpan" id="kobo.321.2">Const-ness is important here, but do not worry, you can’t forget it; the language does not permit binding non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">const</span></strong><span class="koboSpan" id="kobo.323.1"> references to temporary variables, so the compiler will let you know. </span><span class="koboSpan" id="kobo.323.2">So this </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.324.1">explains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">commit()</span></strong><span class="koboSpan" id="kobo.326.1"> method; it has to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">const</span></strong><span class="koboSpan" id="kobo.328.1"> since we are going to call it on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">const</span></strong><span class="koboSpan" id="kobo.330.1"> reference (and, therefore, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">commit_</span></strong><span class="koboSpan" id="kobo.332.1"> flag has to </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">mutable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">But what about the destructor? </span><span class="koboSpan" id="kobo.336.2">At the end of the scope, the destructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">ScopeGuardImplBase</span></strong><span class="koboSpan" id="kobo.338.1"> class will be called, since that is the type of reference that goes out of scope. </span><span class="koboSpan" id="kobo.338.2">The base class destructor itself does nothing, it’s the derived class that has the destructor we want. </span><span class="koboSpan" id="kobo.338.3">A polymorphic class with a virtual destructor would have served us right, but we did not take that route. </span><span class="koboSpan" id="kobo.338.4">Instead, we availed ourselves of yet another special rule in the C++ standard concerning the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">const</span></strong><span class="koboSpan" id="kobo.340.1"> references and temporary variables—not only is the lifetime of the temporary variable extended but also the destructor of the derived class, that is the actual class that was constructed, is going to be called at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">the scope.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">Note that this rule applies only to destructors; you still cannot call derived class methods on the base class </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">SG</span></strong><span class="koboSpan" id="kobo.344.1"> reference. </span><span class="koboSpan" id="kobo.344.2">Also, the lifetime extension works only when the temporary variable is directly bound to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">const</span></strong><span class="koboSpan" id="kobo.346.1"> reference. </span><span class="koboSpan" id="kobo.346.2">It does not work if, for example, we initialize another </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">const</span></strong><span class="koboSpan" id="kobo.348.1"> reference from the first one. </span><span class="koboSpan" id="kobo.348.2">This is why we had to return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.350.1"> object from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">MakeGuard</span></strong><span class="koboSpan" id="kobo.352.1"> function by value; if we tried to return it by reference, the temporary would be bound to that reference, which is going to go away at the end of the statement. </span><span class="koboSpan" id="kobo.352.2">The second reference, </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">SG</span></strong><span class="koboSpan" id="kobo.354.1">, initialized from the first one, would not have extended the lifetime of </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">the object.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">The function implementation we just saw comes very close to the original goal, it is just a bit more verbose (and it mentions </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">ScopeGuardImplBase</span></strong><span class="koboSpan" id="kobo.358.1"> instead of the promised </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.360.1">). </span><span class="koboSpan" id="kobo.360.2">Fear not, for the last step is merely </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">syntactic sugar:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.362.1">
using ScopeGuard = const ScopeGuardImplBase&amp;;</span></pre>
<p><span class="koboSpan" id="kobo.363.1">Now, we can </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">write this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.365.1">
// Example 04a
void Database::insert(const Record&amp; r) {
  S.insert(r);
  ScopeGuard SG = MakeGuard(undo, S);
  I.insert(r);
  SG.commit();
}</span></pre>
<p><span class="koboSpan" id="kobo.366.1">This is as far </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.367.1">as we are going to get with the language tools we’ve used so far. </span><span class="koboSpan" id="kobo.367.2">Ideally, the desired syntax would be as follows (and we are not very </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">far off):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.369.1">
ScopeGuard SG(undo, S);</span></pre>
<p><span class="koboSpan" id="kobo.370.1">We can tidy up our </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.372.1"> a bit by making use of the C++11 features. </span><span class="koboSpan" id="kobo.372.2">First of all, we can properly disable the assignment operator. </span><span class="koboSpan" id="kobo.372.3">Second, we can stop pretending that our copy constructor is anything other than a </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">move constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
// Example 05
class ScopeGuardImplBase {
  public:
  ScopeGuardImplBase() = default;
  void commit() const noexcept { commit_ = true; }
  protected:
  ScopeGuardImplBase(ScopeGuardImplBase&amp;&amp; other) :
    commit_(other.commit_) { other.commit(); }
  ~ScopeGuardImplBase() {}
  mutable bool commit_ = false;
  private:
  ScopeGuardImplBase&amp; operator=(const ScopeGuardImplBase&amp;)
    = delete;
};
using ScopeGuard = const ScopeGuardImplBase&amp;;
template &lt;typename Func, typename Arg&gt;
class ScopeGuardImpl : public ScopeGuardImplBase {
  public:
  ScopeGuardImpl(const Func&amp; func, Arg&amp; arg) :
    func_(func), arg_(arg) {}
  ~ScopeGuardImpl() { </span><a id="_idTextAnchor533"/><span class="koboSpan" id="kobo.375.1">if (!commit_) func_(arg_); }
  ScopeGuardImpl(ScopeGuardImpl&amp;&amp; other) :
    ScopeGuardImplBase(std::move(other)),
    func_(other.func_),
    arg_(other.arg_) {}
  private:
  const Func&amp; func_;
  Arg&amp; arg_;
};
template &lt;typename Func, typename Arg&gt;
ScopeGuardImpl&lt;Func, Arg&gt;
MakeGuard(const Func&amp; func, Arg&amp; arg) {
  return ScopeGuardImpl&lt;Func, Arg&gt;(func, arg);
}</span></pre>
<p><span class="koboSpan" id="kobo.376.1">Moving to C++14, we can </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.377.1">make one more simplification and deduce the return type of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">MakeGuard</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.379.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.380.1">
// Example 05a
template &lt;typename Func, typename Arg&gt;
auto MakeGuard(const Func&amp; func, Arg&amp; arg) {
  return ScopeGuardImpl&lt;Func, Arg&gt;(func, arg);
}</span></pre>
<p><span class="koboSpan" id="kobo.381.1">There is still one concession we had to make—we did not really need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">undo(S)</span></strong><span class="koboSpan" id="kobo.383.1"> function what we really wanted was to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">S.undo()</span></strong><span class="koboSpan" id="kobo.385.1">. </span><span class="koboSpan" id="kobo.385.2">This is done just as easily with a member function variant of </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.387.1">. </span><span class="koboSpan" id="kobo.387.2">In fact, the only reason we have not done so from the beginning is to make the example easier to follow; the member function pointer syntax is not the most straightforward aspect </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">of C++:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.389.1">
// Example 06
template &lt;typename MemFunc, typename Obj&gt;
class ScopeGuardImpl : public ScopeGuardImplBase {
  public:
  ScopeGuardImpl(const MemFunc&amp; memfunc, Obj&amp; obj) :
    memfunc_(memfunc), obj_(obj) {}
  ~ScopeGuardImpl() { if (!commit_) (obj_.*memfunc_)(); }
  ScopeGuardImpl(ScopeGuardImpl&amp;&amp; other) :
    ScopeGuardImplBase(std::move(other)),
    memfunc_(other.memfunc_),
    obj_(other.obj_) {}
  private:
  const MemFunc&amp; memfunc_; Obj&amp; obj_;
};
template &lt;typename MemFunc, typename Obj&gt;
auto MakeGuard(const MemFunc&amp; memfunc, Obj&amp; obj) {// C++14
  return ScopeGuardImpl&lt;</span><a id="_idTextAnchor534"/><span class="koboSpan" id="kobo.390.1">MemFunc, Obj&gt;(memfunc, obj);
}</span></pre>
<p><span class="koboSpan" id="kobo.391.1">Of course, if both versions of the ScopeGuard template are used in the same program, we have to rename </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.392.1">one of them. </span><span class="koboSpan" id="kobo.392.2">Also, our function guard is limited to calling functions with only one argument, while our member function guard can call only member functions with no arguments. </span><span class="koboSpan" id="kobo.392.3">In C++03, this problem is solved in a tedious but reliable way—we have to create versions of the implementation, </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">ScopeGuardImpl0</span></strong><span class="koboSpan" id="kobo.394.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">ScopeGuardImp1</span></strong><span class="koboSpan" id="kobo.396.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">ScopeGuardImpl2</span></strong><span class="koboSpan" id="kobo.398.1">, and so on, for functions with zero, one, two, and so on arguments. </span><span class="koboSpan" id="kobo.398.2">We then create </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">ScopeObjGuardImpl0</span></strong><span class="koboSpan" id="kobo.400.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">ScopeObjGuardImpl1</span></strong><span class="koboSpan" id="kobo.402.1">, and so on, for member functions with zero, one, two, and so on arguments. </span><span class="koboSpan" id="kobo.402.2">If we do not create enough, the compiler will let us know. </span><span class="koboSpan" id="kobo.402.3">The base class remains the same for all these variants of the derived class, and so is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">ScopeGuard</span></strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">typedef</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">In C++11, we have </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.407.1">variadic templates that are designed to address this exact problem, but we’re not going to see such an implementation here. </span><span class="koboSpan" id="kobo.407.2">There i</span><a id="_idTextAnchor535"/><span class="koboSpan" id="kobo.408.1">s no reason for it; we can do so much better tha</span><a id="_idTextAnchor536"/><span class="koboSpan" id="kobo.409.1">n that, as you are about </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">to see.</span></span></p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor537"/><span class="koboSpan" id="kobo.411.1">Generic ScopeGuard</span></h2>
<p><span class="koboSpan" id="kobo.412.1">We are now firmly in C++11 territory, nothing that you are about to see has a C++03 equivalent of any </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">practical worth.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.416.1"> has, so far, allowed us to all arbitrary functions as rollback for any action. </span><span class="koboSpan" id="kobo.416.2">Just like the hand-crafted guard objects, the scope guards are composable and guarantee </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.417.1">exception safety. </span><span class="koboSpan" id="kobo.417.2">But our implementation, so far, is somewhat limited in what exactly we can call to implement the rollback; it has to be a function or a member function. </span><span class="koboSpan" id="kobo.417.3">While this seems to cover a lot, we may want to call, for example, two functions to do a single rollback. </span><span class="koboSpan" id="kobo.417.4">We could, of course, write a wrapper function for that, but that sets us back on the path toward single-purpose hand-crafted </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">rollback objects.</span></span></p>
<p><span class="koboSpan" id="kobo.419.1">There is, in truth, another problem with our implementation. </span><span class="koboSpan" id="kobo.419.2">We decided to capture the function argument </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">by reference:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.421.1">
ScopeGuardImpl(const Func&amp; func, Arg&amp; arg);</span></pre>
<p><span class="koboSpan" id="kobo.422.1">This mostly works, unless the argument is a constant or a temporary variable; then, our code will </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">not compile.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">C++11 gives us another way to create arbitrary callable objects: lambda expressions. </span><span class="koboSpan" id="kobo.424.2">Lambdas are actually classes, but they behave like functions in that they can be called with parentheses. </span><span class="koboSpan" id="kobo.424.3">They can take arguments, but they can also capture any arguments from the containing scope, and that often obviates the need to pass arguments to the function call itself. </span><span class="koboSpan" id="kobo.424.4">We can also write arbitrary code and package it in a lambda expression. </span><span class="koboSpan" id="kobo.424.5">This sounds ideal for the scope guard; we could just write something that says, </span><em class="italic"><span class="koboSpan" id="kobo.425.1">at the end of the scope run </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.426.1">this code</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">Let’s see what a lambda expression ScopeGuard </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">looks like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.430.1">
// Example 07
class ScopeGuardBase {
  public:
  ScopeGuardBase() = default;
  void commit() noexcept { commit_ = true; }
  protected:
  ScopeGuardBase(ScopeGuardBase&amp;&amp; other) noexcept :
    commit_(other.commit_) { other.commit(); }
  ~ScopeGuardBase() = default;
  bool commit_ = false;
  private:
  ScopeGuardBase&amp; operator=(const ScopeGuardBase&amp;)
    = delete;
};
template &lt;typename Func&gt;
class ScopeGuard : public ScopeGuardBase {
  public:
  ScopeGuard(Func&amp;&amp; func) : func_(std::move(func)) {}
  ScopeGuard(const Func&amp; func) : func_(func) {}
  ~ScopeGuard() { if (!commit_) func_(); }
  ScopeGuard(ScopeGuard&amp;&amp; other) = default;
  private:
  Func func_;
};
template &lt;typename Func&gt;
ScopeGuard&lt;Func&gt; MakeGuard(Func&amp;&amp; func) {
  return ScopeGuard&lt;Func&gt;(std::forward&lt;Func&gt;(func));
}</span></pre>
<p><span class="koboSpan" id="kobo.431.1">The base class </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.432.1">is essentially the same as before, except we are not going to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">const</span></strong><span class="koboSpan" id="kobo.434.1"> reference trick anymore, and so the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">Impl</span></strong><span class="koboSpan" id="kobo.436.1"> suffix is gone; what you see is not an implementation aid but the base of the guard class itself; it contains the reusable code dealing with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">commit_</span></strong><span class="koboSpan" id="kobo.438.1"> flag. </span><span class="koboSpan" id="kobo.438.2">Since we do not use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">const</span></strong><span class="koboSpan" id="kobo.440.1"> reference, we can stop pretending that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">commit()</span></strong><span class="koboSpan" id="kobo.442.1"> method is const, and drop the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">mutable</span></strong><span class="koboSpan" id="kobo.444.1"> declaration </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">commit_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">The derived class, on the other hand, is much different. </span><span class="koboSpan" id="kobo.448.2">First of all, there is only one class for all types of rollback, and the argument type parameter is gone; instead, we have a functional object that is going to be a lambda, and it’ll contain all the arguments that it needs. </span><span class="koboSpan" id="kobo.448.3">The destructor is the same as before (except for the missing argument to the callable </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">func_</span></strong><span class="koboSpan" id="kobo.450.1">), and so is the move constructor. </span><span class="koboSpan" id="kobo.450.2">But the primary constructor of the object is quite different; the callable object is stored by value, and initialized from either a </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">const</span></strong><span class="koboSpan" id="kobo.452.1"> reference or an r-value reference, with a suitable overload selected automatically by </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">the compiler.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">MakeGuard</span></strong><span class="koboSpan" id="kobo.456.1"> function is largely unchanged, and we do not need two of them; we can use perfect forwarding (</span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">std::forward</span></strong><span class="koboSpan" id="kobo.458.1">) to forward the argument of any type to one of the constructors </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">ScopeGuard</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">Here is how this ScopeGuard </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">is used:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.464.1">
void Database::insert(const Record&amp; r) {
  S.insert(r);
  auto SG = MakeGuard([&amp;] { S.undo(); });
  I.insert(r);
  SG.commit();
}</span></pre>
<p><span class="koboSpan" id="kobo.465.1">The punctuation-rich construct that is used as an argument to </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">MakeGuard</span></strong><span class="koboSpan" id="kobo.467.1"> is the lambda expression. </span><span class="koboSpan" id="kobo.467.2">It creates a callable object, and calling this object will run the code in the body of the lambda, in our case </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">S.undo()</span></strong><span class="koboSpan" id="kobo.469.1">. </span><span class="koboSpan" id="kobo.469.2">There is no </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">S</span></strong><span class="koboSpan" id="kobo.471.1"> variable declared in the lambda object itself, so it has to be captured from the containing scope. </span><span class="koboSpan" id="kobo.471.2">All captures are done by reference (</span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">[&amp;]</span></strong><span class="koboSpan" id="kobo.473.1">). </span><span class="koboSpan" id="kobo.473.2">Finally, the object is called with no arguments; the parentheses can be omitted, although </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">MakeGuard([&amp;]() { S.undo(); });</span></strong><span class="koboSpan" id="kobo.475.1"> is also valid. </span><span class="koboSpan" id="kobo.475.2">The function does not return anything, that is, the return type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">void</span></strong><span class="koboSpan" id="kobo.477.1">; it does not have to be explicitly declared. </span><span class="koboSpan" id="kobo.477.2">Note that, so far, we have used C++11 lambdas and have not taken advantage of the more powerful C++14 lambdas. </span><span class="koboSpan" id="kobo.477.3">This will usually be the case with ScopeGuard, although in practice, you would probably use C++14 just for auto-deduced return types, if </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">nothing else.</span></span></p>
<p><span class="koboSpan" id="kobo.479.1">We have, until now, intentionally set aside the matter of the regular cleanup and focused on error </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.480.1">handling and the rollback. </span><span class="koboSpan" id="kobo.480.2">Now that we have a decent working ScopeGuard, we can tie up loose ends </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">quite easily:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.482.1">
// Example 07a
void Database::insert(const Record&amp; r) {
  S.insert(r);
  auto SF = MakeGuard([&amp;] { S.finalize(); });
  auto SG = MakeGuard([&amp;] { S.undo(); </span><a id="_idTextAnchor538"/><span class="koboSpan" id="kobo.483.1">});
  I.insert(r);
  SG.commit();
}</span></pre>
<p><span class="koboSpan" id="kobo.484.1">As you can see, nothing special needs to be added to our framework to support the cleanup. </span><span class="koboSpan" id="kobo.484.2">We simply create another ScopeGuard that we </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">never disarm.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">We should also point out that, in C++17, we no longer need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">MakeGuard</span></strong><span class="koboSpan" id="kobo.488.1"> function since the compiler can deduce the template arguments from </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">the constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.490.1">
// Example 07b
void Database::insert(const Record&amp; r) {
  S.insert(r);
  ScopeGuard SF = [&amp;] { S.finalize(); };    // C++17
  ScopeGuard SG = [&amp;] { S.undo(); };
  I.insert(r);
  SG.commit();
}</span></pre>
<p><span class="koboSpan" id="kobo.491.1">As long as we are on the subject of making ScopeGuard use prettier, we should consider some helpful macros. </span><span class="koboSpan" id="kobo.491.2">We can easily write a macro for the cleanup guard, the one that is always executed. </span><span class="koboSpan" id="kobo.491.3">We would like the resulting syntax to look something like this (if this isn’t declarative enough, I don’t know </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">what is):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.493.1">
ON_SCOPE_EXIT { S.finalize(); };</span></pre>
<p><span class="koboSpan" id="kobo.494.1">We can, in fact, get that very syntax. </span><span class="koboSpan" id="kobo.494.2">First of all, we need to generate a name for the guard, what used </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.495.1">to be called </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">SF</span></strong><span class="koboSpan" id="kobo.497.1">, and we need it to be something unique. </span><span class="koboSpan" id="kobo.497.2">From the cutting edge of modern C++, we are now reaching decades back, to classic C and its preprocessor tricks, to generate a unique name for an </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">anonymous variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.499.1">
#define CONCAT2(x, y) x##y
#define CONCAT(x, y) CONCAT2(x, y)
#ifdef __COUNTER__
#define ANON_VAR(x) CONCAT(x, __COUNTER__)
#else
#define ANON_VAR(x) CONCAT(x, __LINE__)
#endif</span></pre>
<p><span class="koboSpan" id="kobo.500.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">__CONCAT__</span></strong><span class="koboSpan" id="kobo.502.1"> macros are how you concatenate two tokens in the preprocessor (and yes, you need two of them, that’s the way the preprocessor works). </span><span class="koboSpan" id="kobo.502.2">The first token will be a user-specified prefix, and the second one is something unique. </span><span class="koboSpan" id="kobo.502.3">Many compilers support a preprocessor variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">__COUNTER__</span></strong><span class="koboSpan" id="kobo.504.1">, that is incremented every time it’s used, so it’s never the same. </span><span class="koboSpan" id="kobo.504.2">However, it is not in the standard. </span><span class="koboSpan" id="kobo.504.3">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">__COUNTER__</span></strong><span class="koboSpan" id="kobo.506.1"> is not available, we have to use the line number </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">__LINE__</span></strong><span class="koboSpan" id="kobo.508.1"> as a unique identifier. </span><span class="koboSpan" id="kobo.508.2">Of course, it is only unique if we don’t put two guards on the same line, </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">so don’t.</span></span></p>
<p><span class="koboSpan" id="kobo.510.1">Now that we have a way to generate an anonymous variable name, we can implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">ON_SCOPE_EXIT</span></strong><span class="koboSpan" id="kobo.512.1"> macro. </span><span class="koboSpan" id="kobo.512.2">It would be trivial to implement one where the code is passed as a macro argument, but it would not give us the syntax we want; the argument has to be in parentheses, so at best we could get </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">ON_SCOPE_EXIT(S.finalize();)</span></strong><span class="koboSpan" id="kobo.514.1">. </span><span class="koboSpan" id="kobo.514.2">Also, commas in the code confuse the preprocessor, since it interprets them as a separator between the macro arguments. </span><span class="koboSpan" id="kobo.514.3">If you look carefully at the syntax we requested, </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">ON_SCOPE_EXIT { S.finalize(); };</span></strong><span class="koboSpan" id="kobo.516.1">, you will realize that this macro has no arguments at all, and the body of the lambda expression is just typed after the no-argument macro. </span><span class="koboSpan" id="kobo.516.2">The macro </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.517.1">expansion, therefore, ends on something that can be followed by an opening curly brace. </span><span class="koboSpan" id="kobo.517.2">Here is how this </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">is done:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.519.1">
// Example 08
struct ScopeGuardOnExit {};
template &lt;typename Func&gt;
ScopeGuard&lt;Func&gt; operator+(ScopeGuardOnExit, Func&amp;&amp; func) {
  return ScopeGuard&lt;Func&gt;(std::forward&lt;Func&gt;(func));
}
#define ON_SCOPE_EXIT auto ANON_VAR(SCOPE_EXIT_STATE) = \
  ScopeGuardOnExit() + [&amp;]()</span></pre>
<p><span class="koboSpan" id="kobo.520.1">The macro expansion declares an anonymous variable that starts with </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">SCOPE_EXIT_STATE</span></strong><span class="koboSpan" id="kobo.522.1">, followed by a unique number, and it ends on the incomplete lambda expression, </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">[&amp;]()</span></strong><span class="koboSpan" id="kobo.524.1">, that is completed by the code in the curly braces. </span><span class="koboSpan" id="kobo.524.2">In order to not have a closing parenthesis of the former </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">MakeGuard</span></strong><span class="koboSpan" id="kobo.526.1"> function, which the macro cannot generate (the macro is expanded before the lambda body, so it cannot generate any code after that), we have to replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">MakeGuard</span></strong><span class="koboSpan" id="kobo.528.1"> function (or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.530.1"> constructor in C++17) with an operator. </span><span class="koboSpan" id="kobo.530.2">The choice of the operator does not matter; we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">+</span></strong><span class="koboSpan" id="kobo.532.1">, but we could use any binary operator. </span><span class="koboSpan" id="kobo.532.2">The first argument to the operator is a temporary object of a unique type, it limits the overload resolution only to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">operator+()</span></strong><span class="koboSpan" id="kobo.534.1"> defined previously (the object itself is not used at all, we only need its type). </span><span class="koboSpan" id="kobo.534.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">operator+()</span></strong><span class="koboSpan" id="kobo.536.1"> itself is exactly what </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">MakeGuard</span></strong><span class="koboSpan" id="kobo.538.1"> used to be, it deduces the type of the lambda expression and creates the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.540.1"> object. </span><span class="koboSpan" id="kobo.540.2">The only downside of this technique is that the closing semicolon at the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">ON_SCOPE_EXIT</span></strong><span class="koboSpan" id="kobo.542.1"> statement is required, and should you forget it, the compiler will remind you in the most obscure and opaque </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">way possible.</span></span></p>
<p><span class="koboSpan" id="kobo.544.1">Our program code can now be further </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">tidied up:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.546.1">
// Example 08
void Database::insert(const Record&amp; r) {
  S.insert(r);
  ON_SCOPE_EXIT { S.finalize(); };
  auto SG = ScopeGuard([&amp;] { S.undo(</span><a id="_idTextAnchor539"/><span class="koboSpan" id="kobo.547.1">); });
  I.insert(r);
  SG.commit();
}</span></pre>
<p><span class="koboSpan" id="kobo.548.1">It is tempting to apply the same technique to the second guard. </span><span class="koboSpan" id="kobo.548.2">Unfortunately, this is not so simple; we have to know the name of this variable so we can call </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">commit()</span></strong><span class="koboSpan" id="kobo.550.1"> on it. </span><span class="koboSpan" id="kobo.550.2">We can define </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.551.1">a similar macro that does not use an anonymous variable but instead takes the </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">user-specified name:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.553.1">
// Example 08a
#define ON_SCOPE_EXIT_ROLLBACK(NAME) \
  auto NAME = ScopeGuardOnExit() + [&amp;]()</span></pre>
<p><span class="koboSpan" id="kobo.554.1">We can use it to complete the conversion of </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">our code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.556.1">
// Example 08a
void Database::insert(const Record&amp; r) {
  S.insert(r);
  ON_SCOPE_EXIT { S.finalize(); };
  ON_SCOPE_EXIT_ROLLBACK(SG){ S.undo(); };
  I.insert(r);
  SG.commit();
}</span></pre>
<p><span class="koboSpan" id="kobo.557.1">At this point, we should revisit the issue of composability. </span><span class="koboSpan" id="kobo.557.2">For three actions, each with its own rollback and cleanup, we now have </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.559.1">
action1();
ON_SCOPE_EXIT { cleanup1; };
ON_SCOPE_EXIT_ROLLBACK(g2){ rollback1(); };
action2();
ON_SCOPE_EXIT { cleanup2; };
ON_SCOPE_EXIT_ROLLBACK(g4){ rollback2(); };
action3();
g2.commit();
g4.commit();</span></pre>
<p><span class="koboSpan" id="kobo.560.1">One can see how this pattern is trivially extended to any number of actions. </span><span class="koboSpan" id="kobo.560.2">An observant reader might wonder whether they have noticed a bug in the code, though—should not the </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.561.1">rollback guards be dismissed in reverse construction order? </span><span class="koboSpan" id="kobo.561.2">This is not a bug, although neither is the reverse order of all </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">commit()</span></strong><span class="koboSpan" id="kobo.563.1"> calls. </span><span class="koboSpan" id="kobo.563.2">The reason is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">commit()</span></strong><span class="koboSpan" id="kobo.565.1"> cannot throw an exception, it was declared </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">noexcept</span></strong><span class="koboSpan" id="kobo.567.1">, and indeed its implementation is such that no exception can be thrown. </span><span class="koboSpan" id="kobo.567.2">This is vitally important for the ScopeGuard pattern to work; if </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">commit()</span></strong><span class="koboSpan" id="kobo.569.1"> could throw, then there would be no way to guarantee that all rollback guards are properly disarmed. </span><span class="koboSpan" id="kobo.569.2">At the end of the scope, some actions would be rolled back, and others would not, leaving the system in an </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">inconsistent state.</span></span></p>
<p><span class="koboSpan" id="kobo.571.1">While ScopeGuard was primarily designed to make exception-safe code easier to write, the interaction of the ScopeGuard pattern with exceptions is far from trivia</span><a id="_idTextAnchor540"/><a id="_idTextAnchor541"/><a id="_idTextAnchor542"/><span class="koboSpan" id="kobo.572.1">l, and we should spend more time </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">on it.</span></span></p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor543"/><span class="koboSpan" id="kobo.574.1">ScopeGuard and exceptions</span></h1>
<p><span class="koboSpan" id="kobo.575.1">The ScopeGuard pattern is designed to correctly run various cleanup and rollback operations </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.576.1">automatically upon exiting a scope, no matter what caused the exit—normal completion by reaching the end of the scope, an early return, or an exception. </span><span class="koboSpan" id="kobo.576.2">This makes writing error-safe code in general, and exception-safe code in particular, much easier; as long as we queued up the right guards after every action, the correct cleanup and error handling will automatically happen. </span><span class="koboSpan" id="kobo.576.3">That is, of course, assuming that  ScopeGuard itself is functioning correctly in the presence of excep</span><a id="_idTextAnchor544"/><span class="koboSpan" id="kobo.577.1">tions. </span><span class="koboSpan" id="kobo.577.2">We are going to learn how to make sure it does and how to use it </span><a id="_idTextAnchor545"/><span class="koboSpan" id="kobo.578.1">to make the rest of the </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">code error-safe.</span></span></p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor546"/><span class="koboSpan" id="kobo.580.1">What must not throw an exception</span></h2>
<p><span class="koboSpan" id="kobo.581.1">We have already seen that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">commit()</span></strong><span class="koboSpan" id="kobo.583.1"> function that is used to commit an action and disarm </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.584.1">the rollback guard must never throw an exception. </span><span class="koboSpan" id="kobo.584.2">Fortunately, that is easy to guarantee since all this function does is set a flag. </span><span class="koboSpan" id="kobo.584.3">But what happens if the rollback function also fails, and throws </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">an exception?</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.586.1">
// Example 09
void Database::insert(const Record&amp; r) {
  S.insert(r);
  auto SF = MakeGuard([&amp;] { S.finalize(); });
  auto SG = MakeGuard([&amp;] { S.undo(); });
             // What if undo() can throw?
</span><span class="koboSpan" id="kobo.586.2">  I.insert(r);    // Let's say this fails
  SG.commit();    // Commit never happens
}            // Control jumps here and undo() throws</span></pre>
<p><span class="koboSpan" id="kobo.587.1">The short answer is </span><em class="italic"><span class="koboSpan" id="kobo.588.1">nothing good</span></em><span class="koboSpan" id="kobo.589.1">. </span><span class="koboSpan" id="kobo.589.2">In general, we have a conundrum—we cannot allow the action, in our case the storage insertion, to remain, but we also cannot undo it, since that also fails. </span><span class="koboSpan" id="kobo.589.3">Specifically, in C++, two exceptions cannot propagate at the same time. </span><span class="koboSpan" id="kobo.589.4">For that reason, the destructors are not allowed to throw exceptions; a destructor may be called when an exception is thrown, and if that destructor also throws, we now have two exceptions propagating at the same time. </span><span class="koboSpan" id="kobo.589.5">If this happens, the program immediately terminates. </span><span class="koboSpan" id="kobo.589.6">This is not so much a shortcoming of the language as a reflection on the unsolvable nature of the problem in general; we cannot let things stay the way they are, but we also failed in an attempt to change something. </span><span class="koboSpan" id="kobo.589.7">There aren’t any good </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">options left.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">In general, there are three ways a C++ program can handle this situation. </span><span class="koboSpan" id="kobo.591.2">The best option is not to fall into this trap—if the rollback cannot throw, none of this will happen. </span><span class="koboSpan" id="kobo.591.3">A well-written exception-safe program thus goes to great lengths to provide non-throwing rollback and cleanup. </span><span class="koboSpan" id="kobo.591.4">For example, the main action can produce the new data and have it ready, then making the data available to the callers is as simple as swapping a pointer, definitely a non-throwing operation. </span><span class="koboSpan" id="kobo.591.5">The rollback involves only swapping the pointer back and maybe deleting something (as we already said, destructors should not throw exceptions; if they do, the program behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">is undefined).</span></span></p>
<p><span class="koboSpan" id="kobo.593.1">The second option </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.594.1">is to suppress the exception in the rollback. </span><span class="koboSpan" id="kobo.594.2">We tried to undo the operation, it didn’t work, there is nothing else we can do about it, so let’s push on. </span><span class="koboSpan" id="kobo.594.3">The danger here is that the program may be in an undefined state, and every operation from this point forward may be incorrect. </span><span class="koboSpan" id="kobo.594.4">This is, however, the worst-case scenario. </span><span class="koboSpan" id="kobo.594.5">In practice, the consequences may be less severe. </span><span class="koboSpan" id="kobo.594.6">For example, for our database, we may know that if the rollback fails, there is a chunk of disk space that is claimed by the record but is unreachable from the index. </span><span class="koboSpan" id="kobo.594.7">The caller will be correctly informed that the insertion failed, but we have wasted some disk space. </span><span class="koboSpan" id="kobo.594.8">This may be preferable to terminating the program outright. </span><span class="koboSpan" id="kobo.594.9">If this is what we want, we have to catch any exceptions that might be thrown by the </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">ScopeGuard action:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.596.1">
// Example 09a
template &lt;typename Func&gt;
class ScopeGuard : public ScopeGuardBase {
  public:
  ...
</span><span class="koboSpan" id="kobo.596.2">  ~ScopeGuard() {
    if (!commit_) try { func_(); } catch (...) {}
  }
  ...
</span><span class="koboSpan" id="kobo.596.3">};</span></pre>
<p><span class="koboSpan" id="kobo.597.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">catch</span></strong><span class="koboSpan" id="kobo.599.1"> clause is empty; we catch everything but do nothing. </span><span class="koboSpan" id="kobo.599.2">This implementation is sometimes </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.600.1">called a </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.601.1">shielded ScopeGuard</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.603.1">The final option is to allow the program to fail. </span><span class="koboSpan" id="kobo.603.2">That will happen with no effort on our part if we just let two exceptions happen, but we could also print a message or otherwise signal to the user what is about to happen and why. </span><span class="koboSpan" id="kobo.603.3">If we want to insert our own dying action before the program terminates, we have to write code that is very similar </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">to previously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.605.1">
template &lt;typename Func&gt;
class ScopeGuard : public ScopeGuardBase {
  public:
  ...
</span><span class="koboSpan" id="kobo.605.2">  ~ScopeGuard() {
    if (!commit_) try { func_(); } catch (...) {
      s</span><a id="_idTextAnchor547"/><span class="koboSpan" id="kobo.606.1">td::cout &lt;&lt; "Rollback failed" &lt;&lt; std::endl;
      throw;    // Rethrow
    }
  }
  ...
</span><span class="koboSpan" id="kobo.606.2">};</span></pre>
<p><span class="koboSpan" id="kobo.607.1">The key difference is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">throw;</span></strong><span class="koboSpan" id="kobo.609.1"> statement without any arguments. </span><span class="koboSpan" id="kobo.609.2">This re-throws the exception </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.610.1">we caught and allows it to </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">continue propagating.</span></span></p>
<p><span class="koboSpan" id="kobo.612.1">The difference between the last two code fragments highlights a subtle detail that we have glossed over earlier, but one that will become important later. </span><span class="koboSpan" id="kobo.612.2">It is imprecise to say that in C++ the destructors should not throw exceptions. </span><span class="koboSpan" id="kobo.612.3">The correct statement is that an exception should not propagate out of the destructor. </span><span class="koboSpan" id="kobo.612.4">The destructor can throw anything it wants as long as it also </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">catches it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.614.1">
class LivingDangerously {
  public:
  ~LivingDangerously() {
    try {
      if (cleanup() != SUCCESS) throw 0;
       more_cleanup();
    } catch (...) {
      std::cout &lt;&lt; "Cleanup failed, proceeding anyway" &lt;&lt;
      std::endl;
      // No rethrow - this is critical!
</span><span class="koboSpan" id="kobo.614.2">    }
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.615.1">Up until now, we have dealt with exceptions mostly as a nuisance; the program has to remain in a well-defined state if something somewhere throws something, but other than that, we have no use for these exceptions; we just pass them on. </span><span class="koboSpan" id="kobo.615.2">On the other hand, our code </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.616.1">could work with any type of error handling, be it exceptions or error codes. </span><span class="koboSpan" id="kobo.616.2">If we knew for sure that errors are always signaled by exceptions and that any return from a function other than an exception thrown is a success, we could take advantage of that to automate the detection of success or failur</span><a id="_idTextAnchor548"/><span class="koboSpan" id="kobo.617.1">e and therefore al</span><a id="_idTextAnchor549"/><span class="koboSpan" id="kobo.618.1">low a commit or rollback to happen </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">as needed.</span></span></p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor550"/><span class="koboSpan" id="kobo.620.1">Exception-driven ScopeGuard</span></h2>
<p><span class="koboSpan" id="kobo.621.1">We are now going to assume that if a function returns without throwing an exception, the operation has succeeded. </span><span class="koboSpan" id="kobo.621.2">If the function throws, it obviously failed. </span><span class="koboSpan" id="kobo.621.3">The objective now is to </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.622.1">get rid of the explicit call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">commit()</span></strong><span class="koboSpan" id="kobo.624.1"> and instead detect whether the destructor of ScopeGuard is executed because an exception was thrown, or because the function </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">returned normally.</span></span></p>
<p><span class="koboSpan" id="kobo.626.1">There are two parts to this implementation. </span><span class="koboSpan" id="kobo.626.2">The first part is specifying when we want the action to be taken. </span><span class="koboSpan" id="kobo.626.3">The cleanup guard must be executed regardless of how we exit the scope. </span><span class="koboSpan" id="kobo.626.4">The rollback guard is executed only in case of failure. </span><span class="koboSpan" id="kobo.626.5">For completeness, we can also have a guard that is executed only if the function has succeeded. </span><span class="koboSpan" id="kobo.626.6">The second part is determining what </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">actually happened.</span></span></p>
<p><span class="koboSpan" id="kobo.628.1">We will start with the second part. </span><span class="koboSpan" id="kobo.628.2">Our ScopeGuard now needs two additional parameters that will tell us whether it should be executed on success and whether it should be executed on failure (both can be enabled at the same time). </span><span class="koboSpan" id="kobo.628.3">Only the destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.630.1"> needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">be modified:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
template &lt;typename Func, bool on_success, bool on_failure&gt;
class ScopeGuard {
  public:
  ...
</span><span class="koboSpan" id="kobo.632.2">  ~ScopeGuard() {
    if ((on_success &amp;&amp; is_success()) ||
        (on_failure &amp;&amp; is_failure())) func_();
  }
  ...
</span><span class="koboSpan" id="kobo.632.3">};</span></pre>
<p><span class="koboSpan" id="kobo.633.1">We still </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.634.1">need to figure out how to implement the  pseudo-functions </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">is_success()</span></strong><span class="koboSpan" id="kobo.636.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">is_failure()</span></strong><span class="koboSpan" id="kobo.638.1">. </span><span class="koboSpan" id="kobo.638.2">Remember that failure means that an exception was thrown. </span><span class="koboSpan" id="kobo.638.3">In C++, we have a function for that: </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">std::uncaught_exception()</span></strong><span class="koboSpan" id="kobo.640.1">. </span><span class="koboSpan" id="kobo.640.2">It returns true if an exception is currently propagating, and false otherwise. </span><span class="koboSpan" id="kobo.640.3">Armed with this knowledge, we can implement </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">our guard:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.642.1">
// Example 10
template &lt;typename Func, bool on_success, bool on_failure&gt;
class ScopeGuard {
  public:
  ...
</span><span class="koboSpan" id="kobo.642.2">  ~ScopeGuard() {
    if ((on_success &amp;&amp; !std::uncaught_exception()) ||
        (on_failure &amp;&amp; std::uncaught_exception())) func_();
  }
  ...
</span><span class="koboSpan" id="kobo.642.3">};</span></pre>
<p><span class="koboSpan" id="kobo.643.1">Now, back to the first part: </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.645.1"> will execute the delayed action if the conditions are right, so how do we tell it what conditions are right? </span><span class="koboSpan" id="kobo.645.2">Using the macro approach we developed earlier, we can define three versions of the guard—</span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">ON_SCOPE_EXIT</span></strong><span class="koboSpan" id="kobo.647.1"> is always executed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">ON_SCOPE_SUCCESS</span></strong><span class="koboSpan" id="kobo.649.1"> is executed only if no exceptions were thrown, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">ON_SCOPE_FAILURE</span></strong><span class="koboSpan" id="kobo.651.1"> is executed if an exception was thrown. </span><span class="koboSpan" id="kobo.651.2">The latter replaces our </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">ON_SCOPE_EXIT_ROLLBACK</span></strong><span class="koboSpan" id="kobo.653.1"> macro, only now it too can use an </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.654.1">anonymous variable name, since there are no explicit calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">commit()</span></strong><span class="koboSpan" id="kobo.656.1">. </span><span class="koboSpan" id="kobo.656.2">The three macros are defined in a very similar way, we just need three different unique types instead of one </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">ScopeGuardOnExit</span></strong><span class="koboSpan" id="kobo.658.1">, so we can decide which </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">operator+()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.660.1">to call:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.661.1">
// Example 10
struct ScopeGuardOnExit {};
template &lt;typename Func&gt;
auto operator+(ScopeGuardOnExit, Func&amp;&amp; func) {
  return
    ScopeGuard&lt;Func, true, true&gt;(std::forward&lt;Func&gt;(func));
}
#define ON_SCOPE_EXIT auto ANON_VAR(SCOPE_EXIT_STATE) = \
  ScopeGuardOnExit() + [&amp;]()
struct ScopeGuardOnSuccess {};
template &lt;typename Func&gt;
auto operator+(ScopeGuardOnSuccess, Func&amp;&amp; func) {
  return
   ScopeGuard&lt;Func, true, false&gt;(std::forward&lt;Func&gt;(func));
}
#define ON_SCOPE_SUCCESS auto ANON_VAR(SCOPE_EXIT_STATE) =\
  ScopeGuardOnSuccess() + [&amp;]()
struct ScopeGuardOnFailure {};
template &lt;typename Func&gt;
auto operator+(ScopeGuardOnFailure, Func&amp;&amp; func) {
  return
   ScopeGuard&lt;Func, false, true&gt;(std::forward&lt;Func&gt;(func));
}
#define ON_SCOPE_FAILURE auto ANON_VAR(SCOPE_EXIT_STATE) =\
  ScopeGuardOnFailure() + [&amp;]()</span></pre>
<p><span class="koboSpan" id="kobo.662.1">Each overload of </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">operator+()</span></strong><span class="koboSpan" id="kobo.664.1"> constructs a </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.666.1"> object with different Boolean </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.667.1">arguments that control when it does and does not execute. </span><span class="koboSpan" id="kobo.667.2">Each macro directs the lambda expression to the desired overload by specifying the type of the first argument to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">operator+()</span></strong><span class="koboSpan" id="kobo.669.1"> using one of the unique tree types we defined just for this purpose: </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">ScopeGuardOnEx</span><a id="_idTextAnchor551"/><span class="koboSpan" id="kobo.671.1">it</span></strong><span class="koboSpan" id="kobo.672.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">ScopeGuardOnSuccess</span></strong><span class="koboSpan" id="kobo.674.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">ScopeGuardOnFailure</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.678.1">This implementation can pass simple and even fairly elaborate tests and appears to work. </span><span class="koboSpan" id="kobo.678.2">Unfortunately, it has a fatal flaw—it does not correctly detect success or failure. </span><span class="koboSpan" id="kobo.678.3">To be sure, it works fine if our </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">Database::insert()</span></strong><span class="koboSpan" id="kobo.680.1"> function was called from the normal control flow, where it may or may not succeed. </span><span class="koboSpan" id="kobo.680.2">The problem is we may call </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">Database::insert()</span></strong><span class="koboSpan" id="kobo.682.1"> from a destructor of some other object, and that object may be used in a scope where an exception </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">is thrown:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.684.1">
class ComplexOperation {
  Database db_;
  public:
  ...
</span><span class="koboSpan" id="kobo.684.2">  ~ComplexOperation() {
    try {
      db_.insert(some_record);
    } catch (...) {}    // Shield any exceptions from insert()
  }
};
{
  ComplexOperation OP;
  throw 1;
}    // OP.~ComplexOperation() runs here</span></pre>
<p><span class="koboSpan" id="kobo.685.1">Now, </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">db_.insert()</span></strong><span class="koboSpan" id="kobo.687.1"> runs in the presence of an uncaught exception, and so </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">std::uncaught_exception()</span></strong><span class="koboSpan" id="kobo.689.1"> will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">true</span></strong><span class="koboSpan" id="kobo.691.1">. </span><span class="koboSpan" id="kobo.691.2">The problem is this is not the exception we were looking for. </span><span class="koboSpan" id="kobo.691.3">This exception does not indicate that </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">insert()</span></strong><span class="koboSpan" id="kobo.693.1"> failed, but it will be treated as such and the database insertion will </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">be undone.</span></span></p>
<p><span class="koboSpan" id="kobo.695.1">What we </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.696.1">really need is to know how many exceptions are currently propagating. </span><span class="koboSpan" id="kobo.696.2">This may seem a strange statement since C++ does not allow multiple exceptions to propagate at the same time. </span><span class="koboSpan" id="kobo.696.3">However, we have already seen that this is an oversimplification; the second exception can propagate just fine as long as it does not escape the destructor. </span><span class="koboSpan" id="kobo.696.4">In the same manner, three or more exceptions can propagate if we have nested destructor calls, we just have to catch them all in time. </span><span class="koboSpan" id="kobo.696.5">To solve this problem correctly, we need to know how many exceptions were propagating when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">Database::insert()</span></strong><span class="koboSpan" id="kobo.698.1"> function was called. </span><span class="koboSpan" id="kobo.698.2">Then, we can compare it with the number of exceptions propagating at the end of the function, however we got there. </span><span class="koboSpan" id="kobo.698.3">If these numbers are the same, </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">insert()</span></strong><span class="koboSpan" id="kobo.700.1"> did not throw any exceptions, and any preexisting ones are not our concern. </span><span class="koboSpan" id="kobo.700.2">If a new exception was added, </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">insert()</span></strong><span class="koboSpan" id="kobo.702.1"> has fail</span><a id="_idTextAnchor552"/><span class="koboSpan" id="kobo.703.1">ed, and the exit handling must </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">change accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.705.1">C++17 lets us implement this detection; in addition to the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">std::uncaught_exception()</span></strong><span class="koboSpan" id="kobo.707.1">, which is deprecated (and removed in C++20), we now have a new function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">std::uncaught_exceptions()</span></strong><span class="koboSpan" id="kobo.709.1">, which returns the number of currently propagating exceptions. </span><span class="koboSpan" id="kobo.709.2">We can now implement this </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">UncaughtExceptionDetector</span></strong><span class="koboSpan" id="kobo.711.1"> to detect </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">new exceptions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.713.1">
// Example 10a
class UncaughtExceptionDetector {
  public:
  UncaughtExceptionDetector() :
    count_(std::uncaught_exceptions()) {}
  operator bool() const noexcept {
    return std::uncaught_exceptions() &gt; count_;
  }
  private:
  const int count_;
};</span></pre>
<p><span class="koboSpan" id="kobo.714.1">With </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.715.1">this detector, we can finally implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">automatic </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">ScopeGuard</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.719.1">
// Example 10a
template &lt;typename Func, bool on_success, bool on_failure&gt;
class ScopeGuard {
  public:
  ...
</span><span class="koboSpan" id="kobo.719.2">  ~ScopeGuard() {
  if ((on_success &amp;&amp; !detector_) ||
      (on_failure &amp;&amp; detector_)) func_();
  }
  ...
</span><span class="koboSpan" id="kobo.719.3">  private:
  UncaughtExceptionDetector detector_;
  ...
</span><span class="koboSpan" id="kobo.719.4">};</span></pre>
<p><span class="koboSpan" id="kobo.720.1">The need to use C++17 may present a (hopefully short-term) obstacle to using this technique in programs constrained to older versions of the language. </span><span class="koboSpan" id="kobo.720.2">While there is no other standard-compliant, portable way to solve this problem, most modern compilers have ways </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.721.1">to get to the uncaught exception counter. </span><span class="koboSpan" id="kobo.721.2">This is how it is done in GCC or Clang (the names starting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">__</span></strong><span class="koboSpan" id="kobo.723.1"> are GCC internal types </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">and functions):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.725.1">
// Example 10b
namespace  cxxabiv1 {
  struct cxa_eh_globals;
  extern "C" cxa_eh_globals* cxa_get_globals() noexcept;
}
class UncaughtExceptionDetector {
  public:
  UncaughtExceptionDetector() :
    count_(uncaught</span><a id="_idTextAnchor553"/><span class="koboSpan" id="kobo.726.1">_exceptions()) {}
  operator bool() const noexcept {
    return uncaught_exceptions() &gt; count_;
  }
  private:
  const int count_;
  int uncaught_exceptions() const noexcept {
    return *(reinterpret_cast&lt;int*&gt;(
      static_cast&lt;char*&gt;( static_cast&lt;void*&gt;(
        cxxabiv1::cxa_get_globals())) + sizeof(void*)));
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.727.1">Whether we use the exception-driven ScopeGuard or the explicitly named ScopeGuard (perhaps to handle error codes as well as exceptions), we have accomplished our goals—we now can specify deferred actions that must be taken at the end of a function or any </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">other scope.</span></span></p>
<p><span class="koboSpan" id="kobo.729.1">At the </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.730.1">end of this chapter, we will show another implementation of ScopeGuard that can be found in several </span><a id="_idTextAnchor554"/><span class="koboSpan" id="kobo.731.1">sources on the web. </span><span class="koboSpan" id="kobo.731.2">This implementation deserves some considerati</span><a id="_idTextAnchor555"/><span class="koboSpan" id="kobo.732.1">on, but you should be aware of the downsides </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">as well.</span></span></p>
<h1 id="_idParaDest-210"><a id="_idTextAnchor556"/><span class="koboSpan" id="kobo.734.1">Type-erased ScopeGuard</span></h1>
<p><span class="koboSpan" id="kobo.735.1">If you search online for a ScopeGuard example, you may chance upon an implementation </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.736.1">that uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">std::function</span></strong><span class="koboSpan" id="kobo.738.1"> instead of a class template. </span><span class="koboSpan" id="kobo.738.2">The implementation itself is </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">quite simple:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.740.1">
// Example 11
class ScopeGuard {
  public:
  template &lt;typename Func&gt; ScopeGuard(Func&amp;&amp; func) :
    func_(std::forward&lt;Func&gt;(func)) {}
  ~ScopeGuard() { if (!commit_) func_(); }
  void commit() const noexcept { commit_ = true; }
  ScopeGuard(ScopeGuard&amp;&amp; other) :
    commit_(other.commit_), func_(std::move(other.func_)) {
    other.commit();
  }
  private:
  mutable bool commit_ = false;
  std::function&lt;void()&gt; func_;
  ScopeGuard&amp; operator=(const ScopeGuard&amp;) = delete;
};</span></pre>
<p><span class="koboSpan" id="kobo.741.1">Note that this ScopeGuard is a class, not a class template. </span><span class="koboSpan" id="kobo.741.2">It has template constructors that can accept the same lambda expression or another callable object as the other guard. </span><span class="koboSpan" id="kobo.741.3">But the variable used to store that expression has the same type no matter what the type of the callable is. </span><span class="koboSpan" id="kobo.741.4">That type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">std::function&lt;void()&gt;</span></strong><span class="koboSpan" id="kobo.743.1">, a wrapper for any function that takes no arguments and returns nothing. </span><span class="koboSpan" id="kobo.743.2">How can a value of any type be stored in an </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.744.1">object of some fixed type? </span><span class="koboSpan" id="kobo.744.2">That is the magic of type erasure, and we have a whole chapter dedicated to it (</span><a href="B19262_06.xhtml#_idTextAnchor266"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.745.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.746.1">, </span><em class="italic"><span class="koboSpan" id="kobo.747.1">Understanding Type Erasure</span></em><span class="koboSpan" id="kobo.748.1">). </span><span class="koboSpan" id="kobo.748.2">This non-template ScopeGuard makes the code that uses it simpler (at least in the pre-C++17 version) because there are no types </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">to deduce:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.750.1">
void Database::insert(const Record&amp; r) {
  S.insert(r);
  ScopeGuard SF([&amp;] { S.finalize(); });
  ScopeGuard SG([&amp;] { S.undo(); });
  I.insert(r);
  SG.commit();
}</span></pre>
<p><span class="koboSpan" id="kobo.751.1">There is, however, a serious downside to this approach—a type-erased object has to do a non-trivial amount of computation to achieve its magic. </span><span class="koboSpan" id="kobo.751.2">As a minimum, it involves an indirect or a virtual function call, and often some memory is allocated and deallocated </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.753.1">Using the lessons of </span><a href="B19262_06.xhtml#_idTextAnchor266"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.754.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.755.1">, </span><em class="italic"><span class="koboSpan" id="kobo.756.1">Understanding Type Erasure</span></em><span class="koboSpan" id="kobo.757.1">, we can come up with a slightly more efficient type erasure implementation; in particular, we can insist that the on-exit callable fits into the </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">guard’s buffer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.759.1">
// Example 11
template &lt;size_t S = 16&gt;
class ScopeGuard : public CommitFlag {
  alignas(8) char space_[S];
  using guard_t = void(*)(void*);
  guard_t guard_ = nullptr;
  template&lt;typename Callable&gt;
  static void invoke(void* callable) {
    (*static_cast&lt;Callable*&gt;(callable))();
  }
  mutable bool commit_ = false;
  public:
  template &lt;typename Callable,
            typename D = std::decay_t&lt;Callable&gt;&gt;
    ScopeGuard(Callable&amp;&amp; callable) :
    guard_(invoke&lt;Callable&gt;) {
    static_assert(sizeof(Callable) &lt;= sizeof(space_));
    ::new(static_cast&lt;void*&gt;(space_))
      D(std::forward&lt;Callable&gt;(callable));
  }
  ScopeGuard(ScopeGuard&amp;&amp; other) = default;
  ~ScopeGuard() { if (!commit_) guard_(space_); }
};</span></pre>
<p><span class="koboSpan" id="kobo.760.1">We can compare </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.761.1">the runtime cost of the type-erased ScopeGuard versus the template </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.763.1"> using the Google Benchmark library. </span><span class="koboSpan" id="kobo.763.2">The results will depend on what operation we are guarding, of course: for long computations and expensive on-exit actions, a slight difference in </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.765.1">’s run time makes no difference. </span><span class="koboSpan" id="kobo.765.2">The difference is going to be more pronounced if the computations in the scope and upon exiting the scope </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">are fast:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.767.1">
void BM_nodelete(benchmark::State&amp; state) {
  for (auto _ : state) {
    int* p = nullptr;
    ScopeGuardTypeErased::ScopeGuard SG([&amp;] { delete p; });
    p = rand() &lt; 0 ? </span><span class="koboSpan" id="kobo.767.2">new int(42) : nullptr;
  }
  state.SetItemsProcessed(state.iterations());
}</span></pre>
<p><span class="koboSpan" id="kobo.768.1">Note that the </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.769.1">memory is never allocated (</span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">rand()</span></strong><span class="koboSpan" id="kobo.771.1"> returns non-negative random numbers) and the pointer </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">p</span></strong><span class="koboSpan" id="kobo.773.1"> is always </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">null</span></strong><span class="koboSpan" id="kobo.775.1">, so we are benchmarking the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">rand()</span></strong><span class="koboSpan" id="kobo.777.1"> plus the overhead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.779.1">. </span><span class="koboSpan" id="kobo.779.2">For comparison, we can call </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">delete</span></strong><span class="koboSpan" id="kobo.781.1"> explicitly, without the guard. </span><span class="koboSpan" id="kobo.781.2">The result shows that the template version of the guard has no measurable overhead, while both type-erased implementations </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">have some:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.783.1">
Benchmark                              Time
-------------------------------------------
BM_nodelete_explicit                4.48 ns
BM_nodelete_type_erased             6.29 ns
BM_nodelete_type_erased_fast        5.48 ns
BM_nodelete_template                4.50 ns</span></pre>
<p><span class="koboSpan" id="kobo.784.1">Our own type-erased version adds about 1 nanosecond to each iteration, and the one based on </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">std::function</span></strong><span class="koboSpan" id="kobo.786.1"> takes almost twice as long. </span><span class="koboSpan" id="kobo.786.2">Benchmarks of this sort are strongly affected by compiler optimizations and can produce very different results in response to even slight changes in the code. </span><span class="koboSpan" id="kobo.786.3">For example, let us change the code to always construct the </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">new object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.788.1">
void BM_nodelete(benchmark::State&amp; state) {
  for (auto _ : state) {
    int* p = nullptr;
    ScopeGuardTypeErased::ScopeGuard SG([&amp;] { delete p; });
    p = rand() &gt;= 0 ? </span><span class="koboSpan" id="kobo.788.2">new int(42) : nullptr;
  }
  state.SetItemsProcessed(state.iterations());
}</span></pre>
<p><span class="koboSpan" id="kobo.789.1">Now we call the operator new on each iteration of the loop, so the corresponding deletion must happen as well. </span><span class="koboSpan" id="kobo.789.2">This time, the compiler was able to optimize the template </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">ScopeGuard</span></strong><span class="koboSpan" id="kobo.791.1"> much better than the </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">type-erased one:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.793.1">
Benchmark                              Time
-------------------------------------------
BM_delete_explicit                  4.54 ns
BM_delete_type_erased               13.4 ns
BM_delete_type_erased_fast          12.7 ns
BM_delete_template                  4.56 ns</span></pre>
<p><span class="koboSpan" id="kobo.794.1">Over</span><a id="_idTextAnchor557"/><span class="koboSpan" id="kobo.795.1">all, there isn’t much of a reason to use type erasure here. </span><span class="koboSpan" id="kobo.795.2">The runtime cost may be negligible or significant, but there is usually nothing to gain in exchange. </span><span class="koboSpan" id="kobo.795.3">The only advantage of </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.796.1">the type-erased version is that the guard itself is always of the same type. </span><span class="koboSpan" id="kobo.796.2">But the type of the guard is almost always irrelevant: we create the variable as </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">auto</span></strong><span class="koboSpan" id="kobo.798.1"> or using constructor template argument deduction, and the only explicit operation we may need to do on the guard is to disarm it. </span><span class="koboSpan" id="kobo.798.2">Thus, we never need to write any code that depends on the guard’s type. </span><span class="koboSpan" id="kobo.798.3">Overall, the template-based ScopeGuard, with or without macros, remains the pattern of choice for automatically releasing res</span><a id="_idTextAnchor558"/><span class="koboSpan" id="kobo.799.1">ources and performing other actions at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">a scope.</span></span></p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor559"/><span class="koboSpan" id="kobo.801.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.802.1">In this chapter, we have studied, in detail, one of the best C++ patterns for writing exception-safe and error-safe code. </span><span class="koboSpan" id="kobo.802.2">The ScopeGuard pattern allows us to schedule an arbitrary action, a fragment of C++ code, to be executed upon completion of a scope. </span><span class="koboSpan" id="kobo.802.3">The scope may be a function, the body of a loop, or just a scope inserted into the program to manage the lifetime of local variables. </span><span class="koboSpan" id="kobo.802.4">The actions that are executed to the end may be conditional on the successful completion of the scope, however, that is defined. </span><span class="koboSpan" id="kobo.802.5">The ScopeGuard pattern works equally well when success or failure are indicated by return codes or exceptions, although in the latter case we can automatically detect the failure (with return codes, the programmer has to explicitly specify which return values mean success and which do not). </span><span class="koboSpan" id="kobo.802.6">We have observed the evolution of the ScopeGuard pattern as more recent language features are used. </span><span class="koboSpan" id="kobo.802.7">In its optimal form, ScopeGuard provides a simple declarative way to specify post-conditions and deferred actions, such as cleanup or rollback, in a manner that is trivially composable for any number of actions that need to be committed </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">or undone.</span></span></p>
<p><span class="koboSpan" id="kobo.804.1">The next chapter describes another very C++-specific pattern, the Friends Factory, which is a kind of Factory, only instead of objects during the execution of a </span><a id="_idTextAnchor560"/><span class="koboSpan" id="kobo.805.1">program, it manufactures functions during </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">its compilation.</span></span></p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor561"/><span class="koboSpan" id="kobo.807.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.808.1">What is an error-safe or </span><span class="No-Break"><span class="koboSpan" id="kobo.809.1">exception-safe, program?</span></span></li>
<li><span class="koboSpan" id="kobo.810.1">How can we make a routine that performs several related actions </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">be error-safe?</span></span></li>
<li><span class="koboSpan" id="kobo.812.1">How does RAII assist in writing </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">error-safe programs?</span></span></li>
<li><span class="koboSpan" id="kobo.814.1">How does the ScopeGuard pattern generalize the </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">RAII idiom?</span></span></li>
<li><span class="koboSpan" id="kobo.816.1">How can the program automatically detect when a function exits successfully and when </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">it fails?</span></span></li>
<li><span class="koboSpan" id="kobo.818.1">What are the advantages and drawbacks of a </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">type-erased ScopeGuard</span></span></li>
</ol>
</div>
</body></html>