<html><head></head><body>
  <div id="_idContainer039">
   <h1 class="chapter-number" id="_idParaDest-126">
    <a id="_idTextAnchor125">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     6
    </span>
   </h1>
   <h1 id="_idParaDest-127">
    <a id="_idTextAnchor126">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Promises and Futures
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In previous chapters, we learned the foundations of managing and synchronizing thread execution using C++.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     We also mentioned in
    </span>
    <a href="B22219_03.xhtml#_idTextAnchor051">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.4.1">
        Chapter 3
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.5.1">
     that to return values from a thread, we could use promises and futures.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     Now it’s time to learn how to do that and much more using these features
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      in C++.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.7.1">
      Futures
     </span>
    </strong>
    <span class="koboSpan" id="kobo.8.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.9.1">
      promises
     </span>
    </strong>
    <span class="koboSpan" id="kobo.10.1">
     are essential blocks for achieving asynchronous programming.
    </span>
    <span class="koboSpan" id="kobo.10.2">
     They define a way to manage the result of a task that will be completed in the future, usually in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.11.1">
      separate thread.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.12.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.13.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.14.1">
      What are promises
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.15.1">
       and futures?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.16.1">
      What are shared futures and how are they different from
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.17.1">
       regular futures?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.18.1">
      What are packaged tasks and when do we
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.19.1">
       use them?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.20.1">
      How do we check future statuses
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.21.1">
       and errors?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.22.1">
      What are the benefits and drawbacks of using promises
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.23.1">
       and futures?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.24.1">
      Examples of real-life scenarios
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.25.1">
       and solutions
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     So, let’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.27.1">
      get started!
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-128">
    <a id="_idTextAnchor127">
    </a>
    <span class="koboSpan" id="kobo.28.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.29.1">
     Promises and futures have been available since C++11, but some examples implemented in this chapter use features from C++20, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.30.1">
      std::jthread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.31.1">
     , so the code shown in this chapter can be compiled by compilers
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.32.1">
      supporting C++20.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.33.1">
     Please check the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.34.1">
      Technical requirements
     </span>
    </em>
    <span class="koboSpan" id="kobo.35.1">
     section in
    </span>
    <a href="B22219_03.xhtml#_idTextAnchor051">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.36.1">
        Chapter 3
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.37.1">
     for guidance on how to install GCC 13 and Clang
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.38.1">
      8 compilers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.39.1">
     You can find all the complete code in the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.40.1">
      GitHub repository:
     </span>
    </span>
   </p>
   <p>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.41.1">
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.42.1">
     The examples for this chapter are located under the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.43.1">
      Chapter_06
     </span>
    </strong>
    <span class="koboSpan" id="kobo.44.1">
     folder.
    </span>
    <span class="koboSpan" id="kobo.44.2">
     All source code files can be compiled using CMake
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.45.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.46.1">
cmake . </span><span class="koboSpan" id="kobo.46.2">&amp;&amp; cmake build .</span></pre>
   <p>
    <span class="koboSpan" id="kobo.47.1">
     Executable binaries will be generated under the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.48.1">
       bin
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.49.1">
      directory.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-129">
    <a id="_idTextAnchor128">
    </a>
    <span class="koboSpan" id="kobo.50.1">
     Exploring promises and futures
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.51.1">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.52.1">
      future
     </span>
    </strong>
    <span class="koboSpan" id="kobo.53.1">
     is an object that represents some
    </span>
    <a id="_idIndexMarker403">
    </a>
    <span class="koboSpan" id="kobo.54.1">
     undetermined result that will be completed sometime in the future.
    </span>
    <span class="koboSpan" id="kobo.54.2">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.55.1">
      promise
     </span>
    </strong>
    <span class="koboSpan" id="kobo.56.1">
     is the
    </span>
    <a id="_idIndexMarker404">
    </a>
    <span class="koboSpan" id="kobo.57.1">
     provider of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.58.1">
      that result.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.59.1">
     Promises and futures have been part of the C++ standard since version C++11 and are available by including the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.60.1">
      &lt;future&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.61.1">
     header file, promises via the class
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.62.1">
      std::promise
     </span>
    </strong>
    <span class="koboSpan" id="kobo.63.1">
     and futures via the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.64.1">
      class
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.65.1">
       std::future
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.66.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.67.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.68.1">
      std::promise
     </span>
    </strong>
    <span class="koboSpan" id="kobo.69.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.70.1">
      std::future
     </span>
    </strong>
    <span class="koboSpan" id="kobo.71.1">
     pair implements a one-shot producer-consumer channel with the promise as the producer and the future as the consumer.
    </span>
    <span class="koboSpan" id="kobo.71.2">
     The consumer (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.72.1">
      std::future
     </span>
    </strong>
    <span class="koboSpan" id="kobo.73.1">
     ) can block until the result of the producer (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.74.1">
      std::promise
     </span>
    </strong>
    <span class="koboSpan" id="kobo.75.1">
     )
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.76.1">
      is available.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer036">
     <span class="koboSpan" id="kobo.77.1">
      <img alt="Figure 6.1 – Promise-future communication channel" src="image/B22219_06_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.78.1">
     Figure 6.1 – Promise-future communication channel
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.79.1">
     Many modern programming languages provide similar asynchronous approaches, such as Python (with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.80.1">
      asyncio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.81.1">
     library), Scala (in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.82.1">
      scala.concurrent
     </span>
    </strong>
    <span class="koboSpan" id="kobo.83.1">
     library), JavaScript (in its core library), Rust (in its
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.84.1">
      Standard Library
     </span>
    </strong>
    <span class="koboSpan" id="kobo.85.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.86.1">
      std
     </span>
    </strong>
    <span class="koboSpan" id="kobo.87.1">
     ) or crates such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.88.1">
      promising_future
     </span>
    </strong>
    <span class="koboSpan" id="kobo.89.1">
     ), Swift (in the
    </span>
    <a id="_idIndexMarker405">
    </a>
    <span class="koboSpan" id="kobo.90.1">
     Combine framework), and Kotlin,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.91.1">
      among others.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.92.1">
     The basic principle behind achieving asynchronous execution using promises and futures is that a function we want to run to generate a result is executed in the background, using a new thread or the current one, and a future object is used by the initial thread to retrieve the result computed by the function.
    </span>
    <span class="koboSpan" id="kobo.92.2">
     This result value will be stored when the function finishes, so meanwhile, the future will be used as a placeholder.
    </span>
    <span class="koboSpan" id="kobo.92.3">
     The asynchronous function will use a promise object to store the result in the future with no need for explicit synchronization mechanisms between the initial thread and the background one.
    </span>
    <span class="koboSpan" id="kobo.92.4">
     When the value is
    </span>
    <a id="_idIndexMarker406">
    </a>
    <span class="koboSpan" id="kobo.93.1">
     needed by the initial thread, it will be retrieved from the future object.
    </span>
    <span class="koboSpan" id="kobo.93.2">
     If the value is still not ready, the initial thread execution will be blocked until the future
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.94.1">
      becomes ready.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.95.1">
     With this idea, making a function run asynchronously becomes easy.
    </span>
    <span class="koboSpan" id="kobo.95.2">
     We only need to be aware that the function can run on a separate thread, so we need to avoid data races, but result communication and synchronization between threads is managed by the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.96.1">
      promise-future pair.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.97.1">
     Using promises and futures improves responsiveness by offloading computations and provides a structured approach to handling asynchronous operations compared to threads and callbacks, as we will explore in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.98.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.99.1">
     Let’s now learn about these
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.100.1">
      two objects.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-130">
    <a id="_idTextAnchor129">
    </a>
    <span class="koboSpan" id="kobo.101.1">
     Promises
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.102.1">
     Promises are defined
    </span>
    <a id="_idIndexMarker407">
    </a>
    <span class="koboSpan" id="kobo.103.1">
     in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.104.1">
      &lt;future&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.105.1">
     header
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.106.1">
      as
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.107.1">
       std::promise
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.108.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.109.1">
     With a promise, we get an agreement that the result will be available at some time in the future.
    </span>
    <span class="koboSpan" id="kobo.109.2">
     This way, we can let the background task do its work and compute the result.
    </span>
    <span class="koboSpan" id="kobo.109.3">
     Meanwhile the main thread will also proceed with its task and, when the result is needed, request it.
    </span>
    <span class="koboSpan" id="kobo.109.4">
     At that time, the result might already
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.110.1">
      be ready.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.111.1">
     Also, promises can communicate if an exception was raised instead of returning a valid value and, they will make sure that its lifetime persists until the thread finishes and writes the result
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.112.1">
      to it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.113.1">
     Therefore, a promise is a facility to store a result (a value or an exception) that is later acquired asynchronously via a future.
    </span>
    <span class="koboSpan" id="kobo.113.2">
     A promise object is only intended to be used once and cannot be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.114.1">
      modified afterward.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.115.1">
     Apart from a result, each promise also holds a shared state.
    </span>
    <span class="koboSpan" id="kobo.115.2">
     The shared state is a memory area that stores the completion status, synchronization mechanisms, and a pointer to the result.
    </span>
    <span class="koboSpan" id="kobo.115.3">
     It ensures proper communication and synchronization between a promise and a future by enabling the promise to store either a result or an exception, signal when it’s complete, and allowing the future to access the result, blocking if the promise is not yet ready.
    </span>
    <span class="koboSpan" id="kobo.115.4">
     The promise can update its shared state using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.116.1">
      following operations:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.117.1">
       Make ready
      </span>
     </strong>
     <span class="koboSpan" id="kobo.118.1">
      : The promise stores the result in the shared state and makes the state of the promise to become ready unblocking any thread waiting on a future associated with the promise.
     </span>
     <span class="koboSpan" id="kobo.118.2">
      Remember
     </span>
     <a id="_idIndexMarker408">
     </a>
     <span class="koboSpan" id="kobo.119.1">
      that the result can be a value (or even void) or
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.120.1">
       an exception.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.121.1">
       Release
      </span>
     </strong>
     <span class="koboSpan" id="kobo.122.1">
      : The promise releases its reference to the shared state, which will be destroyed if this is the last
     </span>
     <a id="_idIndexMarker409">
     </a>
     <span class="koboSpan" id="kobo.123.1">
      reference.
     </span>
     <span class="koboSpan" id="kobo.123.2">
      This memory release mechanism is like the one used by shared pointers and their control blocks.
     </span>
     <span class="koboSpan" id="kobo.123.3">
      This operation does not block unless the shared state was created by
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.124.1">
       std::async
      </span>
     </strong>
     <span class="koboSpan" id="kobo.125.1">
      and is not yet in the ready status (we will learn about this in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.126.1">
       next chapter).
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.127.1">
       Abandon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.128.1">
      : The promise stores
     </span>
     <a id="_idIndexMarker410">
     </a>
     <span class="koboSpan" id="kobo.129.1">
      an exception of type
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.130.1">
       std::future_error
      </span>
     </strong>
     <span class="koboSpan" id="kobo.131.1">
      with error code
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.132.1">
       std::future_errc::broken_promise
      </span>
     </strong>
     <span class="koboSpan" id="kobo.133.1">
      , making the shared state ready and then
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.134.1">
       releasing it.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.135.1">
     A
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.136.1">
      std::promise
     </span>
    </strong>
    <span class="koboSpan" id="kobo.137.1">
     object can be constructed using its default constructor or using a custom allocator.
    </span>
    <span class="koboSpan" id="kobo.137.2">
     In both cases, a new promise will be created with an empty shared state.
    </span>
    <span class="koboSpan" id="kobo.137.3">
     Promises can also be constructed using the move constructor; thus, the new promise will have the shared state owned by the other promise.
    </span>
    <span class="koboSpan" id="kobo.137.4">
     The initial promise will remain with no
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.138.1">
      shared state.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.139.1">
     Moving a promise is
    </span>
    <a id="_idIndexMarker411">
    </a>
    <span class="koboSpan" id="kobo.140.1">
     useful in scenarios related to resource management, optimization by avoiding extra copies, and keeping correct ownership semantics; for example, it’s useful when a promise needs to be completed in another thread, stored in a container, returned to the caller of an API call, or sent to a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.141.1">
      callback handler.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.142.1">
     Promises cannot be copied (their copy-constructor or copy-assignment operator is deleted), avoiding two promise objects sharing the same shared state and in risk of data races when results are stored in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.143.1">
      shared state.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.144.1">
     As promises can be moved, they can also be
    </span>
    <a id="_idIndexMarker412">
    </a>
    <span class="koboSpan" id="kobo.145.1">
     swapped.
    </span>
    <span class="koboSpan" id="kobo.145.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.146.1">
      std::swap
     </span>
    </strong>
    <span class="koboSpan" id="kobo.147.1">
     function from the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.148.1">
      Standard Template Library
     </span>
    </strong>
    <span class="koboSpan" id="kobo.149.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.150.1">
      STL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     ) has a template specialization
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.152.1">
      for promises.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.153.1">
     When a promise object is deleted, the associated future will still have access to the shared state.
    </span>
    <span class="koboSpan" id="kobo.153.2">
     If deletion happens after the promise sets the value, the shared state will be in release mode, thus the future can access the result and use it.
    </span>
    <span class="koboSpan" id="kobo.153.3">
     However, if the promise was deleted before setting the result value, the shared state will be moved to abandoned, and the future will obtain
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.154.1">
      std::future_errc::broken_promise
     </span>
    </strong>
    <span class="koboSpan" id="kobo.155.1">
     when trying to get
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.156.1">
      the result.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.157.1">
     A value can be set by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.158.1">
      std::promise
     </span>
    </strong>
    <span class="koboSpan" id="kobo.159.1">
     function
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.160.1">
      set_value()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.161.1">
     and an exception by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.162.1">
      set_exception()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.163.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.163.2">
     The result is stored atomically in the promise’s shared
    </span>
    <a id="_idIndexMarker413">
    </a>
    <span class="koboSpan" id="kobo.164.1">
     state, making its state ready.
    </span>
    <span class="koboSpan" id="kobo.164.2">
     Let’s see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.165.1">
      an example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.166.1">
auto threadFunc = [](std::promise&lt;int&gt; prom) {
    try {
        int result = func();
        prom.set_value(result);
    } catch (...) {
        prom.set_exception(std::current_exception());
    }
};
std::promise&lt;int&gt; prom;
std::jthread t(threadFunc, std::move(prom));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.167.1">
     In the previous example, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.168.1">
      prom
     </span>
    </strong>
    <span class="koboSpan" id="kobo.169.1">
     promise is created and moved into the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.170.1">
      threadFunc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.171.1">
     lambda function as a parameter.
    </span>
    <span class="koboSpan" id="kobo.171.2">
     As the promise is non-copyable, we need to use pass-by-value together with moving the promise into the parameter to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.172.1">
      avoid copies.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.173.1">
     Inside the lambda function, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.174.1">
      func()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.175.1">
     function is called, and its result is stored in the promise using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.176.1">
      set_value()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.177.1">
     .
    </span>
    <span class="koboSpan" id="kobo.177.2">
     If
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.178.1">
      func()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.179.1">
     throws an exception, it’s captured and stored into the promise using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.180.1">
      set_exception()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.181.1">
     .
    </span>
    <span class="koboSpan" id="kobo.181.2">
     As we will learn later, this result (value or exception) can be extracted in the calling thread by using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.182.1">
      a future.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.183.1">
     In C++14, we can also use generalized lambda capture to pass the promise into the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.184.1">
      lambda capture:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.185.1">
using namespace std::literals;
std::promise&lt;std::string&gt; prom;
auto t = std::jthread([prm = std::move(prom)] mutable {
    std::this_thread::sleep_for(100ms);
    prm.set_value("Value successfully set");
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.186.1">
     Therefore,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.187.1">
      prm = std::move(prom)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.188.1">
     is moving the external promise,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.189.1">
      prom
     </span>
    </strong>
    <span class="koboSpan" id="kobo.190.1">
     , into the lambda’s internal promise,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.191.1">
      prm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.192.1">
     .
    </span>
    <span class="koboSpan" id="kobo.192.2">
     By default, parameters are captured as constants, so we need to specify
    </span>
    <a id="_idIndexMarker414">
    </a>
    <span class="koboSpan" id="kobo.193.1">
     the lambda as mutable to allow
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.194.1">
      prm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.195.1">
     to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.196.1">
      be modified.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.197.1">
      set_value()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.198.1">
     can throw a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.199.1">
      std::future_error
     </span>
    </strong>
    <span class="koboSpan" id="kobo.200.1">
     exception if the promise has no shared state (error code set to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.201.1">
      no_state
     </span>
    </strong>
    <span class="koboSpan" id="kobo.202.1">
     ) or the shared state has already a stored result (error code set
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.203.1">
      to
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.204.1">
       promise_already_satisfied
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.205.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.206.1">
      set_value()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.207.1">
     can also be used without specifying a value.
    </span>
    <span class="koboSpan" id="kobo.207.2">
     In that case, it simply makes the state ready.
    </span>
    <span class="koboSpan" id="kobo.207.3">
     That can be used as a barrier, as we will see later in this chapter after
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.208.1">
      introducing futures.
     </span>
    </span>
   </p>
   <p>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.209.1">
       Figure 6
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.210.1">
      .2
     </span>
    </em>
    <span class="koboSpan" id="kobo.211.1">
     shows a diagram representing the different shared
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.212.1">
      state transitions.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer037">
     <span class="koboSpan" id="kobo.213.1">
      <img alt="Figure 6.2 – Promise shared state transitions diagram" src="image/B22219_06_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.214.1">
     Figure 6.2 – Promise shared state transitions diagram
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.215.1">
     There are two other functions to set the value of a promise,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.216.1">
      set_value_at_thread_exit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.217.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.218.1">
      set_exception_at_thread_exit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.219.1">
     .
    </span>
    <span class="koboSpan" id="kobo.219.2">
     As before, the result is stored immediately, but using these new functions, the state is not made ready yet.
    </span>
    <span class="koboSpan" id="kobo.219.3">
     The state becomes ready when the thread exits after all thread-local variables have been destroyed.
    </span>
    <span class="koboSpan" id="kobo.219.4">
     This is useful when we want threads to manage resources that need to be cleaned up before exiting, even if an exception happens, or if we want to provide accurate log activity or monitor when
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.220.1">
      threads exit.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.221.1">
     In terms of exceptions thrown or synchronization mechanisms to avoid data races, both functions behave as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.222.1">
      set_value()
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.223.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.224.1">
       set_exception()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.225.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.226.1">
     Now that we
    </span>
    <a id="_idIndexMarker415">
    </a>
    <span class="koboSpan" id="kobo.227.1">
     know how to store a result in a promise, let’s learn about the other member of the duo,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.228.1">
      the future.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-131">
    <a id="_idTextAnchor130">
    </a>
    <span class="koboSpan" id="kobo.229.1">
     Futures
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.230.1">
     Futures are defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.231.1">
      &lt;future&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.232.1">
     header file
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.233.1">
      as
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.234.1">
       std::future
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.235.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.236.1">
     As we saw earlier, a future is the
    </span>
    <a id="_idIndexMarker416">
    </a>
    <span class="koboSpan" id="kobo.237.1">
     consumer side of the communication channel.
    </span>
    <span class="koboSpan" id="kobo.237.2">
     It provides access to the result stored by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.238.1">
      the promise.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.239.1">
     A
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.240.1">
      std::future
     </span>
    </strong>
    <span class="koboSpan" id="kobo.241.1">
     object must be created from a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.242.1">
      std::promise
     </span>
    </strong>
    <span class="koboSpan" id="kobo.243.1">
     object by calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.244.1">
      get_future()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.245.1">
     , or through a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.246.1">
      std::packaged_task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.247.1">
     object (more details later in this chapter) or a call to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.248.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.249.1">
     function (in
    </span>
    <a href="B22219_07.xhtml#_idTextAnchor143">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.250.1">
        Chapter 7
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.251.1">
      ):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.252.1">
std::promise&lt;int&gt; prom;
std::future&lt;int&gt; fut = prom.get_future();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.253.1">
     Like promises, futures can be moved but not copied for the same reasons.
    </span>
    <span class="koboSpan" id="kobo.253.2">
     To reference the same shared state from multiple futures, we need to use shared futures (explained in the next section,
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.254.1">
       Shared futures
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.255.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.256.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.257.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.258.1">
     method can be used to retrieve the result.
    </span>
    <span class="koboSpan" id="kobo.258.2">
     If the shared state is still not ready, this call will block by internally calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.259.1">
      wait()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.260.1">
     .
    </span>
    <span class="koboSpan" id="kobo.260.2">
     When the shared state becomes ready, the result value is returned.
    </span>
    <span class="koboSpan" id="kobo.260.3">
     If an exception was stored in the shared state, that exception will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.261.1">
      be rethrown:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.262.1">
try {
    int result = fut.get();
    std::cout &lt;&lt; "Result from thread: " &lt;&lt; result &lt;&lt; '\n';
} catch (const std::exception&amp; e) {
    std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; '\n';
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.263.1">
     In the preceding example, the result is retrieved from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.264.1">
      fut
     </span>
    </strong>
    <span class="koboSpan" id="kobo.265.1">
     future by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.266.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.267.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.267.2">
     If the result is a value, it will be printed with a line starting with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.268.1">
      Result from thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.269.1">
     .
    </span>
    <span class="koboSpan" id="kobo.269.2">
     On the other hand, if an exception were thrown and stored into the promise, it would be
    </span>
    <a id="_idIndexMarker417">
    </a>
    <span class="koboSpan" id="kobo.270.1">
     rethrown and captured in the caller thread, and a line starting with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.271.1">
      Exception
     </span>
    </strong>
    <span class="koboSpan" id="kobo.272.1">
     would be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.273.1">
      printed out.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.274.1">
     After calling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.275.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.276.1">
     method,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.277.1">
      valid()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.278.1">
     will return
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.279.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.280.1">
     .
    </span>
    <span class="koboSpan" id="kobo.280.2">
     If for some reason
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.281.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.282.1">
     is called when
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.283.1">
      valid()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.284.1">
     is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.285.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.286.1">
     , the behavior is undefined, but the C++ standard recommends that a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.287.1">
      std::future_error
     </span>
    </strong>
    <span class="koboSpan" id="kobo.288.1">
     exception is thrown with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.289.1">
      std::future_errc::no_state
     </span>
    </strong>
    <span class="koboSpan" id="kobo.290.1">
     error code.
    </span>
    <span class="koboSpan" id="kobo.290.2">
     Futures in which the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.291.1">
      valid()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.292.1">
     function returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.293.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.294.1">
     can still
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.295.1">
      be moved.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.296.1">
     When a future is destroyed, it releases its shared state reference.
    </span>
    <span class="koboSpan" id="kobo.296.2">
     If that were the last reference, the shared state would be destroyed.
    </span>
    <span class="koboSpan" id="kobo.296.3">
     These actions will not block unless in a specific case when using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.297.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.298.1">
     , which we will learn about in
    </span>
    <a href="B22219_07.xhtml#_idTextAnchor143">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.299.1">
        Chapter 7
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.300.1">
      .
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.301.1">
     Future errors and error codes
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.302.1">
     As we have seen in the preceding
    </span>
    <a id="_idIndexMarker418">
    </a>
    <span class="koboSpan" id="kobo.303.1">
     examples, some functions that deal with asynchronous execution
    </span>
    <a id="_idIndexMarker419">
    </a>
    <span class="koboSpan" id="kobo.304.1">
     and shared states can throw
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.305.1">
       std::future_error
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.306.1">
      exceptions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.307.1">
     This exception class is inherited from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.308.1">
      std::logic_error
     </span>
    </strong>
    <span class="koboSpan" id="kobo.309.1">
     , which in turn is inherited from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.310.1">
      std::exception
     </span>
    </strong>
    <span class="koboSpan" id="kobo.311.1">
     , defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.312.1">
      &lt;stdexcept&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.313.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.314.1">
      &lt;exception&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.315.1">
     header
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.316.1">
      files, respectively.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.317.1">
     As with any other exception defined in the STL, the error code can be checked by using its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.318.1">
      code()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.319.1">
     function or an explanatory string by using its
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.320.1">
       what()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.321.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.322.1">
     Error codes reported by futures are defined by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.323.1">
      std::future_errorc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.324.1">
     , a scoped enumeration (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.325.1">
      enum
     </span>
    </strong>
    <span class="koboSpan" id="kobo.326.1">
     class).
    </span>
    <span class="koboSpan" id="kobo.326.2">
     The C++ standard defines the following error codes, but the implementation may define
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.327.1">
      additional ones:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.328.1">
       broken_promise
      </span>
     </strong>
     <span class="koboSpan" id="kobo.329.1">
      : Reported when a promise is deleted before setting the result, so the shared state is released before
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.330.1">
       being valid.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.331.1">
       future_already_retrieved
      </span>
     </strong>
     <span class="koboSpan" id="kobo.332.1">
      : Occurring when
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.333.1">
       std::promise::get_future()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.334.1">
      is called more
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.335.1">
       than once.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.336.1">
       promise_already_satisfied
      </span>
     </strong>
     <span class="koboSpan" id="kobo.337.1">
      : Reported by
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.338.1">
       std::promise:: set_value()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.339.1">
      if the shared state already has a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.340.1">
       stored result.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.341.1">
       no_state
      </span>
     </strong>
     <span class="koboSpan" id="kobo.342.1">
      : Reported when
     </span>
     <a id="_idIndexMarker420">
     </a>
     <span class="koboSpan" id="kobo.343.1">
      some methods are used but there is no shared state as the promise
     </span>
     <a id="_idIndexMarker421">
     </a>
     <span class="koboSpan" id="kobo.344.1">
      was created by using the default constructor or moved from.
     </span>
     <span class="koboSpan" id="kobo.344.2">
      As we will see later in this chapter, this happens when calling some packaged tasks (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.345.1">
       std::packaged_task
      </span>
     </strong>
     <span class="koboSpan" id="kobo.346.1">
      ) methods, such as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.347.1">
       get_future()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.348.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.349.1">
       make_ready_at_thread_exit()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.350.1">
      , or
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.351.1">
       reset()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.352.1">
      , when their shared state has not been created, or when using
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.353.1">
       std::future::get()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.354.1">
      with a not-yet-ready future (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.355.1">
       std::future::valid()
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.356.1">
       returns
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.357.1">
        false
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.358.1">
       ).
      </span>
     </span>
    </li>
   </ul>
   <h3>
    <span class="koboSpan" id="kobo.359.1">
     Waiting for results
    </span>
   </h3>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.360.1">
      std::future
     </span>
    </strong>
    <span class="koboSpan" id="kobo.361.1">
     also
    </span>
    <a id="_idIndexMarker422">
    </a>
    <span class="koboSpan" id="kobo.362.1">
     provides functions to block the thread and wait for a result to be available.
    </span>
    <span class="koboSpan" id="kobo.362.2">
     These functions are
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.363.1">
      wait()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.364.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.365.1">
      wait_for()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.366.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.367.1">
      wait_until()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.368.1">
     .
    </span>
    <span class="koboSpan" id="kobo.368.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.369.1">
      wait()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.370.1">
     function will block indefinitely until the result is ready,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.371.1">
      wait_for()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.372.1">
     for a period, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.373.1">
      wait_until()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.374.1">
     until a specific time has been reached.
    </span>
    <span class="koboSpan" id="kobo.374.2">
     All will return as soon as the result is available within those
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.375.1">
      waiting periods.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.376.1">
     These functions must be called only when
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.377.1">
      valid()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.378.1">
     is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.379.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.380.1">
     .
    </span>
    <span class="koboSpan" id="kobo.380.2">
     Otherwise, the behavior is undefined but encouraged by the C++ standard to throw a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.381.1">
      std::future_error
     </span>
    </strong>
    <span class="koboSpan" id="kobo.382.1">
     exception with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.383.1">
      std::future_errc::no_state
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.384.1">
      error code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.385.1">
     As commented previously, using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.386.1">
      std::promise::set_value()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.387.1">
     without specifying a value sets the shared state as ready.
    </span>
    <span class="koboSpan" id="kobo.387.2">
     This together with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.388.1">
      std::future::wait()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.389.1">
     can be used to implement a barrier and stop a thread from progressing until it is signaled.
    </span>
    <span class="koboSpan" id="kobo.389.2">
     The following example shows this mechanism
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.390.1">
      in action.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.391.1">
     Let’s start by adding the required
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.392.1">
      header files:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.393.1">
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;sstream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
using namespace std::chrono_literals;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.394.1">
     Inside the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.395.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.396.1">
     function, the
    </span>
    <a id="_idIndexMarker423">
    </a>
    <span class="koboSpan" id="kobo.397.1">
     program will start by creating two promises,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.398.1">
      numbers_promise
     </span>
    </strong>
    <span class="koboSpan" id="kobo.399.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.400.1">
      letters_promise
     </span>
    </strong>
    <span class="koboSpan" id="kobo.401.1">
     , and their corresponding futures,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.402.1">
      numbers_ready
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.403.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.404.1">
       letters_ready
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.405.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.406.1">
std::promise&lt;void&gt; numbers_promise, letters_promise;
auto numbers_ready = numbers_promise.get_future();
auto letter_ready = letters_promise.get_future();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.407.1">
     Then, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.408.1">
      input_data_thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.409.1">
     emulates two I/O thread operations running in sequence, one copying numbers into a vector and another inserting letters into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.410.1">
      a set:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.411.1">
std::istringstream iss_numbers{"10 5 2 6 4 1 3 9 7 8"};
std::istringstream iss_letters{"A b 53 C,d 83D 4B ca"};
std::vector&lt;int&gt; numbers;
std::set&lt;char&gt; letters;
std::jthread input_data_thread([&amp;] {
    // Step 1: Emulating I/O operations.
</span><span class="koboSpan" id="kobo.411.2">    std::copy(std::istream_iterator&lt;int&gt;{iss_numbers},
              std::istream_iterator&lt;int&gt;{},
              std::back_inserter(numbers));
    // Notify completion of Step 1.
</span><span class="koboSpan" id="kobo.411.3">    numbers_promise.set_value();
    // Step 2: Emulating further I/O operations.
</span><span class="koboSpan" id="kobo.411.4">    std::copy_if(std::istreambuf_iterator&lt;char&gt;
                               {iss_letters},
                   std::istreambuf_iterator&lt;char&gt;{},
                   std::inserter(letters,
                               letters.end()),
                               ::isalpha);
    // Notify completion of Step 2.
</span><span class="koboSpan" id="kobo.411.5">    letters_promise.set_value();
});
// Wait for numbers vector to be filled.
</span><span class="koboSpan" id="kobo.411.6">numbers_ready.wait();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.412.1">
     While this is happening, the main
    </span>
    <a id="_idIndexMarker424">
    </a>
    <span class="koboSpan" id="kobo.413.1">
     thread stops its execution by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.414.1">
      numbers_ready.wait()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.415.1">
     , waiting for the counterpart promise,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.416.1">
      numbers_promise
     </span>
    </strong>
    <span class="koboSpan" id="kobo.417.1">
     , to be ready.
    </span>
    <span class="koboSpan" id="kobo.417.2">
     Once all numbers are read,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.418.1">
      input_data_thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.419.1">
     will call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.420.1">
      numbers_promise.set_value()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.421.1">
     , waking up the main thread and continuing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.422.1">
      its execution.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.423.1">
     Numbers will then be sorted and printed if letters have not already been read by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.424.1">
      wait_for()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.425.1">
     function from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.426.1">
      letters_ready
     </span>
    </strong>
    <span class="koboSpan" id="kobo.427.1">
     future and checking whether it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.428.1">
      timed out:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.429.1">
std::sort(numbers.begin(), numbers.end());
if (letter_ready.wait_for(1s) == std::future_status::timeout) {
    for (int num : numbers) std::cout &lt;&lt; num &lt;&lt; ' ';
    numbers.clear();
}
// Wait for letters vector to be filled.
</span><span class="koboSpan" id="kobo.429.2">letter_ready.wait();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.430.1">
     This section of the code shows
    </span>
    <a id="_idIndexMarker425">
    </a>
    <span class="koboSpan" id="kobo.431.1">
     how the main thread can do some work.
    </span>
    <span class="koboSpan" id="kobo.431.2">
     Meanwhile,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.432.1">
      input_data_thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.433.1">
     continues processing incoming data.
    </span>
    <span class="koboSpan" id="kobo.433.2">
     Then, the main thread will wait again by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.434.1">
      calling
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.435.1">
       letters_ready.wait()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.436.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.437.1">
     Finally, when all letters are added to the set, the main thread will wake up by being signaled again by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.438.1">
      letters_promise.set_value()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.439.1">
     , and numbers (if not yet printed) and letters will be printed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.440.1">
      in order:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.441.1">
for (int num : numbers) std::cout &lt;&lt; num &lt;&lt; ' ';
std::cout &lt;&lt; std::endl;
for (char let : letters) std::cout &lt;&lt; let &lt;&lt; ' ';
std::cout &lt;&lt; std::endl;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.442.1">
     As we have seen in the previous example, a future status object is returned by the wait functions.
    </span>
    <span class="koboSpan" id="kobo.442.2">
     Next, let’s learn what these
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.443.1">
      objects are.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.444.1">
     Future status
    </span>
   </h3>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.445.1">
      wait_for()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.446.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.447.1">
      wait_until()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.448.1">
     return a
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.449.1">
       std::future_status
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.450.1">
      object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.451.1">
     A future can be in any of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.452.1">
      following
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker426">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.453.1">
      statuses:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.454.1">
       Ready
      </span>
     </strong>
     <span class="koboSpan" id="kobo.455.1">
      : The shared state is
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.456.1">
       ready
      </span>
     </strong>
     <span class="koboSpan" id="kobo.457.1">
      , indicating
     </span>
     <a id="_idIndexMarker427">
     </a>
     <span class="koboSpan" id="kobo.458.1">
      that the result can
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.459.1">
       be retrieved.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.460.1">
       Deferred
      </span>
     </strong>
     <span class="koboSpan" id="kobo.461.1">
      : The shared state contains a
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.462.1">
       deferred
      </span>
     </strong>
     <span class="koboSpan" id="kobo.463.1">
      function, meaning that the result will only be computed
     </span>
     <a id="_idIndexMarker428">
     </a>
     <span class="koboSpan" id="kobo.464.1">
      when explicitly requested.
     </span>
     <span class="koboSpan" id="kobo.464.2">
      We will learn more about deferred functions in the next chapter when
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.465.1">
       introducing
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.466.1">
        std::async
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.467.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.468.1">
       Timeout
      </span>
     </strong>
     <span class="koboSpan" id="kobo.469.1">
      : The specified
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.470.1">
       timeout period
      </span>
     </strong>
     <span class="koboSpan" id="kobo.471.1">
      passed
     </span>
     <a id="_idIndexMarker429">
     </a>
     <span class="koboSpan" id="kobo.472.1">
      before the shared state could
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.473.1">
       become ready.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.474.1">
     Next, we will learn how to share a promise result among multiple futures by using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.475.1">
      shared futures.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-132">
    <a id="_idTextAnchor131">
    </a>
    <span class="koboSpan" id="kobo.476.1">
     Shared futures
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.477.1">
     As we saw earlier,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.478.1">
      std::future
     </span>
    </strong>
    <span class="koboSpan" id="kobo.479.1">
     is only
    </span>
    <a id="_idIndexMarker430">
    </a>
    <span class="koboSpan" id="kobo.480.1">
     moveable, thus only one future object can refer to a particular asynchronous result.
    </span>
    <span class="koboSpan" id="kobo.480.2">
     On the other hand,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.481.1">
      std::shared_future
     </span>
    </strong>
    <span class="koboSpan" id="kobo.482.1">
     is copyable, so several shared future objects can refer to the same
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.483.1">
      shared state.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.484.1">
     Therefore,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.485.1">
      std::shared_future
     </span>
    </strong>
    <span class="koboSpan" id="kobo.486.1">
     allows thread-safe access from different threads to the same shared state.
    </span>
    <span class="koboSpan" id="kobo.486.2">
     Shared futures can be useful for sharing the result of a computationally intensive task among multiple consumers or interested parties, reducing redundant computation.
    </span>
    <span class="koboSpan" id="kobo.486.3">
     Also, they can be used to notify events or as a synchronization mechanism where multiple threads must wait for the completion of a single task.
    </span>
    <span class="koboSpan" id="kobo.486.4">
     Later in this chapter, we will learn how to chain asynchronous operations by using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.487.1">
      shared futures.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.488.1">
     The interface of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.489.1">
      std:;shared_object
     </span>
    </strong>
    <span class="koboSpan" id="kobo.490.1">
     is the same as the one for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.491.1">
      std::future
     </span>
    </strong>
    <span class="koboSpan" id="kobo.492.1">
     , so everything explained about waiting and getter functions
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.493.1">
      applies here.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.494.1">
     A shared object can be created by using the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.495.1">
       std::future::share()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.496.1">
      function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.497.1">
std::shared_future&lt;int&gt; shared_fut = fut.share();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.498.1">
     That invalidates the original future (its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.499.1">
      valid()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.500.1">
     function will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.501.1">
      return
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.502.1">
       false
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.503.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.504.1">
     The following example shows how to send the same result to many threads at the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.505.1">
      same time:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.506.1">
#define sync_cout std::osyncstream(std::cout)
int main() {
    std::promise&lt;int&gt; prom;
    std::future&lt;int&gt; fut = prom.get_future();
    std::shared_future&lt;int&gt; shared_fut = fut.share();
    std::vector&lt;std::jthread&gt; threads;
    for (int i = 1; i &lt;= 5; ++i) {
        threads.emplace_back([shared_fut, i]() {
            sync_cout &lt;&lt; "Thread " &lt;&lt; i &lt;&lt; ": Result = "
                      &lt;&lt; shared_fut.get() &lt;&lt; std::endl;
        });
    }
    prom.set_value(5);
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.507.1">
     We start by creating a promise,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.508.1">
      prom
     </span>
    </strong>
    <span class="koboSpan" id="kobo.509.1">
     , getting the future,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.510.1">
      fut
     </span>
    </strong>
    <span class="koboSpan" id="kobo.511.1">
     , from it, and finally, getting a shared future,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.512.1">
      shared_fut
     </span>
    </strong>
    <span class="koboSpan" id="kobo.513.1">
     , by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.514.1">
      calling
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.515.1">
       share()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.516.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.517.1">
     Then, five threads are
    </span>
    <a id="_idIndexMarker431">
    </a>
    <span class="koboSpan" id="kobo.518.1">
     created and added to a vector, each one having a shared future instance and an index.
    </span>
    <span class="koboSpan" id="kobo.518.2">
     All these threads will be waiting for the promise,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.519.1">
      prom
     </span>
    </strong>
    <span class="koboSpan" id="kobo.520.1">
     , to be ready by calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.521.1">
      shared_future.get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.522.1">
     .
    </span>
    <span class="koboSpan" id="kobo.522.2">
     When a value is set in the promise shared state, the value will be accessible by all the threads.
    </span>
    <span class="koboSpan" id="kobo.522.3">
     The output of running the previous program is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.523.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.524.1">
Thread 5: Result = 5
Thread 3: Result = 5
Thread 4: Result = 5
Thread 2: Result = 5
Thread 1: Result = 5</span></pre>
   <p>
    <span class="koboSpan" id="kobo.525.1">
     Therefore, shared futures can also be used to signal multiple threads at the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.526.1">
      same time.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-133">
    <a id="_idTextAnchor132">
    </a>
    <span class="koboSpan" id="kobo.527.1">
     Packaged tasks
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.528.1">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.529.1">
      packaged task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.530.1">
     , or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.531.1">
      std::packaged_task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.532.1">
     , also defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.533.1">
      &lt;future&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.534.1">
     header file, is a class template that wraps
    </span>
    <a id="_idIndexMarker432">
    </a>
    <span class="koboSpan" id="kobo.535.1">
     a callable object to be invoked asynchronously.
    </span>
    <span class="koboSpan" id="kobo.535.2">
     Its result is stored in a shared state, which is accessible through a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.536.1">
      std::future
     </span>
    </strong>
    <span class="koboSpan" id="kobo.537.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.537.2">
     To create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.538.1">
      std::packaged_task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.539.1">
     object, we need to define as the template parameter the function signature that represents the task that will be called and pass the desired function as its constructor argument.
    </span>
    <span class="koboSpan" id="kobo.539.2">
     Here are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.540.1">
      some examples:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.541.1">
// Using a thread.
</span><span class="koboSpan" id="kobo.541.2">std::packaged_task&lt;int(int, int)&gt; task1(
                      std::pow&lt;int, int&gt;);
std::jthread t(std::move(task1), 2, 10);
// Using a lambda function.
</span><span class="koboSpan" id="kobo.541.3">std::packaged_task&lt;int(int, int)&gt; task2([](int a, int b)
{
    return std::pow(a, b);
});
task2(2, 10);
// Binding to a function.
</span><span class="koboSpan" id="kobo.541.4">std::packaged_task&lt;int()&gt; task3(std::bind(std::pow&lt;int, int&gt;, 2, 10));
task3();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.542.1">
     In the preceding example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.543.1">
      task1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.544.1">
     is created by using a function and executed by using a thread.
    </span>
    <span class="koboSpan" id="kobo.544.2">
     On the other hand,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.545.1">
      task2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.546.1">
     is created by using a lambda function and executed by invoking its method
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.547.1">
      operator()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.548.1">
     .
    </span>
    <span class="koboSpan" id="kobo.548.2">
     Finally,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.549.1">
      task3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.550.1">
     is created by using a forwarding call wrapper by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.551.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.552.1">
       std::bind
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.553.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.554.1">
     To retrieve the future associated with a task, just call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.555.1">
      get_future()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.556.1">
     from its
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.557.1">
       packaged_task
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.558.1">
      object:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.559.1">
std::future&lt;int&gt; result = task1.get_future();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.560.1">
     As with promises and futures, packaged tasks can be constructed with no shared state by using the default constructor, the move constructor, or allocators.
    </span>
    <span class="koboSpan" id="kobo.560.2">
     Packaged tasks are thus move-only and non-copyable.
    </span>
    <span class="koboSpan" id="kobo.560.3">
     Also, assignment operators and the swap function have similar behaviors
    </span>
    <a id="_idIndexMarker433">
    </a>
    <span class="koboSpan" id="kobo.561.1">
     as promises
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.562.1">
      and futures.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.563.1">
     The destructor of packaged tasks behaves like the promise destructors; if the shared state is released before being valid, a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.564.1">
      std::future_error
     </span>
    </strong>
    <span class="koboSpan" id="kobo.565.1">
     exception will be thrown with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.566.1">
      std::future_errc::broken_promise
     </span>
    </strong>
    <span class="koboSpan" id="kobo.567.1">
     error code.
    </span>
    <span class="koboSpan" id="kobo.567.2">
     As with futures, packaged tasks define a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.568.1">
      valid()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.569.1">
     that function returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.570.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.571.1">
     if a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.572.1">
      std::packaged_task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.573.1">
     object has a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.574.1">
      shared state.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.575.1">
     As with promises,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.576.1">
      get_future()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.577.1">
     can only be called once.
    </span>
    <span class="koboSpan" id="kobo.577.2">
     If this function is called more than once, a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.578.1">
      std::future_error
     </span>
    </strong>
    <span class="koboSpan" id="kobo.579.1">
     exception with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.580.1">
      future_already_retrieved
     </span>
    </strong>
    <span class="koboSpan" id="kobo.581.1">
     code will be thrown.
    </span>
    <span class="koboSpan" id="kobo.581.2">
     If the packaged tasks were created from the default constructor, thus with no shared state, the error code will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.582.1">
      be
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.583.1">
       no_state
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.584.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.585.1">
     As seen in the previous example, the stored callable object can be invoked by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.586.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.587.1">
       operator()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.588.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.589.1">
task1(2, 10);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.590.1">
     Sometimes, it’s interesting to make the result ready only when the thread that runs the packaged task exits and all its
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.591.1">
      thread-local
     </span>
    </strong>
    <span class="koboSpan" id="kobo.592.1">
     objects are
    </span>
    <a id="_idIndexMarker434">
    </a>
    <span class="koboSpan" id="kobo.593.1">
     destroyed.
    </span>
    <span class="koboSpan" id="kobo.593.2">
     This is achieved by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.594.1">
      make_ready_at_thread_exit()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.595.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.595.2">
     Even if the result is not ready until the thread exits, it is computed right away as usual.
    </span>
    <span class="koboSpan" id="kobo.595.3">
     Therefore, its computation is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.596.1">
      not deferred.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.597.1">
     As an example, let’s define the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.598.1">
      following function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.599.1">
void task_func(std::future&lt;void&gt;&amp; output) {
    std::packaged_task&lt;void(bool&amp;)&gt; task{[](bool&amp; done){
        done = true;
    }};
    auto result = task.get_future();
    bool done = false;
    task.make_ready_at_thread_exit(done);
    std::cout &lt;&lt; "task_func: done = "
              &lt;&lt; std::boolalpha &lt;&lt; done &lt;&lt; std::endl;
    auto status = result.wait_for(0s);
    if (status == std::future_status::timeout)
        std::cout &lt;&lt; "task_func: result not ready\n";
    output = std::move(result);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.600.1">
     This function creates a packaged task called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.601.1">
      task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.602.1">
     that sets its Boolean argument to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.603.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.604.1">
     .
    </span>
    <span class="koboSpan" id="kobo.604.2">
     A future called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.605.1">
      result
     </span>
    </strong>
    <span class="koboSpan" id="kobo.606.1">
     is also created from this task.
    </span>
    <span class="koboSpan" id="kobo.606.2">
     When the task is executed by calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.607.1">
      make_ready_at_thread_exit()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.608.1">
     , its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.609.1">
      done
     </span>
    </strong>
    <span class="koboSpan" id="kobo.610.1">
     argument is set to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.611.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.612.1">
     but the future result is still not marked as ready.
    </span>
    <span class="koboSpan" id="kobo.612.2">
     When the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.613.1">
      task_func
     </span>
    </strong>
    <span class="koboSpan" id="kobo.614.1">
     function exits, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.615.1">
      result
     </span>
    </strong>
    <span class="koboSpan" id="kobo.616.1">
     future is
    </span>
    <a id="_idIndexMarker435">
    </a>
    <span class="koboSpan" id="kobo.617.1">
     moved to the passed-by reference.
    </span>
    <span class="koboSpan" id="kobo.617.2">
     At this point, the thread exits, and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.618.1">
      result
     </span>
    </strong>
    <span class="koboSpan" id="kobo.619.1">
     future will be set
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.620.1">
      as ready.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.621.1">
     Therefore, say we call this task from the main thread by using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.622.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.623.1">
std::future&lt;void&gt; result;
std::thread t{task_func, std::ref(result)};
t.join();
auto status = result.wait_for(0s);
if (status == std::future_status::ready)
    std::cout &lt;&lt; «main: result ready\n»;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.624.1">
     The program will show the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.625.1">
      following output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.626.1">
task_func: done = true
task_func: result not ready
main: result ready</span></pre>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.627.1">
      make_ready_at_thread_exit()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.628.1">
     will throw
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.629.1">
      std::future_error
     </span>
    </strong>
    <span class="koboSpan" id="kobo.630.1">
     exceptions if there is no shared state (the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.631.1">
      no_state
     </span>
    </strong>
    <span class="koboSpan" id="kobo.632.1">
     error code) or the task has already been invoked (the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.633.1">
      promise_already_satisfied
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.634.1">
      error code).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.635.1">
     A packaged task state can also be reset by calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.636.1">
      reset()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.637.1">
     .
    </span>
    <span class="koboSpan" id="kobo.637.2">
     This function will abandon the current state and construct a new shared state.
    </span>
    <span class="koboSpan" id="kobo.637.3">
     Obviously, if there is no state when calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.638.1">
      reset()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.639.1">
     , an exception with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.640.1">
      no_state
     </span>
    </strong>
    <span class="koboSpan" id="kobo.641.1">
     error code will be thrown.
    </span>
    <span class="koboSpan" id="kobo.641.2">
     After resetting, a new future must be acquired by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.642.1">
      calling
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.643.1">
       get_future()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.644.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.645.1">
     The following example
    </span>
    <a id="_idIndexMarker436">
    </a>
    <span class="koboSpan" id="kobo.646.1">
     prints the first 10 power-of-two numbers.
    </span>
    <span class="koboSpan" id="kobo.646.2">
     Each number is computed by calling the same
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.647.1">
      packaged_task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.648.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.648.2">
     In each loop iteration,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.649.1">
      packaged_task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.650.1">
     is reset, and a new future object
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.651.1">
      is retrieved:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.652.1">
std::packaged_task&lt;int(int, int)&gt; task([](int a, int b){
    return std::pow(a, b);
});
for (int i=1; i&lt;=10; ++i) {
    std::future&lt;int&gt; result = task.get_future();
    task(2, i);
    std::cout &lt;&lt; "2^" &lt;&lt; i &lt;&lt; " = "
              &lt;&lt; result.get() &lt;&lt; std::endl;
    task.reset();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.653.1">
     This is the output when executing the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.654.1">
      preceding code:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.655.1">
2^1 = 2
2^2 = 4
2^3 = 8
2^4 = 16
2^5 = 32
2^6 = 64
2^7 = 128
2^8 = 256
2^9 = 512
2^10 = 1024</span></pre>
   <p>
    <span class="koboSpan" id="kobo.656.1">
     As we will learn in the next chapter,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.657.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.658.1">
     provides a simpler way to achieve the same result.
    </span>
    <span class="koboSpan" id="kobo.658.2">
     The only advantage of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.659.1">
      std::packaged_task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.660.1">
     is the ability to specify in exactly which thread the task
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.661.1">
      will run.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.662.1">
     Now that we know
    </span>
    <a id="_idIndexMarker437">
    </a>
    <span class="koboSpan" id="kobo.663.1">
     how to use promises, futures, and packaged tasks, it’s time to understand not only the upsides of this approach but also what downsides
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.664.1">
      can arise.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-134">
    <a id="_idTextAnchor133">
    </a>
    <span class="koboSpan" id="kobo.665.1">
     The benefits and drawbacks of promises and futures
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.666.1">
     There are advantages as well as some disadvantages of using promises and futures.
    </span>
    <span class="koboSpan" id="kobo.666.2">
     Here are the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.667.1">
      main points.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-135">
    <a id="_idTextAnchor134">
    </a>
    <span class="koboSpan" id="kobo.668.1">
     Benefits
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.669.1">
     As high-level abstractions for
    </span>
    <a id="_idIndexMarker438">
    </a>
    <span class="koboSpan" id="kobo.670.1">
     managing asynchronous operations, writing and
    </span>
    <a id="_idIndexMarker439">
    </a>
    <span class="koboSpan" id="kobo.671.1">
     reasoning about concurrent code by using promises and futures is simplified and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.672.1">
      less error-prone.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.673.1">
     Futures and promises enable concurrent execution of tasks, allowing the program to use multiple CPU cores efficiently.
    </span>
    <span class="koboSpan" id="kobo.673.2">
     This can lead to improved performance and reduced execution time for computationally
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.674.1">
      intensive tasks.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.675.1">
     Also, they facilitate asynchronous programming by decoupling the initiation of an operation from its completion.
    </span>
    <span class="koboSpan" id="kobo.675.2">
     As we will see later, this is particularly useful for I/O-bound tasks, such as network requests or file operations, where the program can continue executing other tasks while waiting for the asynchronous operation to complete.
    </span>
    <span class="koboSpan" id="kobo.675.3">
     As a result, they can return a value but also an exception, allowing exception propagation from the asynchronous tasks to the caller code section that waits for their completion, which allows for a cleaner way for error handling
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.676.1">
      and recovery.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.677.1">
     As we have also
    </span>
    <a id="_idIndexMarker440">
    </a>
    <span class="koboSpan" id="kobo.678.1">
     mentioned, they also provide a mechanism for synchronizing the completion
    </span>
    <a id="_idIndexMarker441">
    </a>
    <span class="koboSpan" id="kobo.679.1">
     of tasks and retrieving their results.
    </span>
    <span class="koboSpan" id="kobo.679.2">
     This helps in coordinating parallel tasks and managing dependencies
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.680.1">
      between them.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-136">
    <a id="_idTextAnchor135">
    </a>
    <span class="koboSpan" id="kobo.681.1">
     Drawbacks
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.682.1">
     Unfortunately, not everything is positive news; there are also some areas that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.683.1">
      are impacted.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.684.1">
     For example, asynchronous
    </span>
    <a id="_idIndexMarker442">
    </a>
    <span class="koboSpan" id="kobo.685.1">
     programming with futures and promises can introduce complexity when dealing with dependencies between tasks or managing the life cycle of asynchronous operations.
    </span>
    <span class="koboSpan" id="kobo.685.2">
     Also, potential deadlocks can happen if there are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.686.1">
      circular dependencies.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.687.1">
     Likewise, using futures and promises may introduce some performance overhead due to the synchronization mechanisms happening under the hood, involved in coordinating asynchronous tasks and managing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.688.1">
      shared states.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.689.1">
     As with other concurrent or asynchronous solutions, debugging code that uses futures and promises can be more challenging compared to synchronous code, as the flow of execution may be non-linear and involve
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.690.1">
      multiple threads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.691.1">
     Now it’s time to tackle real-life scenarios by implementing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.692.1">
      some examples.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-137">
    <a id="_idTextAnchor136">
    </a>
    <span class="koboSpan" id="kobo.693.1">
     Examples of real-life scenarios and solutions
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.694.1">
     Now that we’ve learned
    </span>
    <a id="_idIndexMarker443">
    </a>
    <span class="koboSpan" id="kobo.695.1">
     about some new building blocks of creating asynchronous programs, let’s build solutions for some real-life scenarios.
    </span>
    <span class="koboSpan" id="kobo.695.2">
     In this section, we will learn how to do
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.696.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.697.1">
      Cancel
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.698.1">
       asynchronous operation
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.699.1">
      Return
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.700.1">
       combined results
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.701.1">
      Chain asynchronous operations and create
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.702.1">
       a pipeline
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.703.1">
      Create a
     </span>
     <a id="_idIndexMarker444">
     </a>
     <span class="koboSpan" id="kobo.704.1">
      thread-safe
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.705.1">
       single-producer-single-consumer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.706.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.707.1">
       SPSC
      </span>
     </strong>
     <span class="koboSpan" id="kobo.708.1">
      )
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.709.1">
       task queue
      </span>
     </span>
    </li>
   </ul>
   <h2 id="_idParaDest-138">
    <a id="_idTextAnchor137">
    </a>
    <span class="koboSpan" id="kobo.710.1">
     Canceling asynchronous operations
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.711.1">
     As we saw earlier, futures offer the ability to check for completion or timeout before waiting for the result.
    </span>
    <span class="koboSpan" id="kobo.711.2">
     That
    </span>
    <a id="_idIndexMarker445">
    </a>
    <span class="koboSpan" id="kobo.712.1">
     can be done by checking the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.713.1">
      std::future_status
     </span>
    </strong>
    <span class="koboSpan" id="kobo.714.1">
     object returned by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.715.1">
      std::future
     </span>
    </strong>
    <span class="koboSpan" id="kobo.716.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.717.1">
      wait_for()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.718.1">
     , or
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.719.1">
       wait_until()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.720.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.721.1">
     By combining futures with mechanisms such as cancellation flags (by means of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.722.1">
      std::atomic_bool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.723.1">
     ) or timeouts, we can gracefully terminate long-running tasks if necessary.
    </span>
    <span class="koboSpan" id="kobo.723.2">
     Timeout cancellation can be implemented by simply using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.724.1">
      wait_for()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.725.1">
     and
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.726.1">
       wait_until()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.727.1">
      functions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.728.1">
     Canceling a task by using a cancellation flag or token can be implemented by passing a reference to a cancellation flag defined as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.729.1">
      std::atomic_bool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.730.1">
     , where the caller thread sets its value to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.731.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.732.1">
     to request the task cancellation, and the worker thread periodically checks this flag and whether it’s set.
    </span>
    <span class="koboSpan" id="kobo.732.2">
     If it is set, it exits gracefully and performs any cleanup work to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.733.1">
      be done.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.734.1">
     Let’s first define a long-running
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.735.1">
      task function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.736.1">
const int CHECK_PERIOD_MS = 100;
bool long_running_task(int ms,
            const std::atomic_bool&amp; cancellation_token) {
    while (ms &gt; 0 &amp;&amp; !cancellation_token) {
        ms -= CHECK_PERIOD_MS;
        std::this_thrsead::sleep_for(100ms);
    }
    return cancellation_token;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.737.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.738.1">
      long_running_task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.739.1">
     function accepts as arguments a period in milliseconds (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.740.1">
      ms
     </span>
    </strong>
    <span class="koboSpan" id="kobo.741.1">
     ) to run the task and a reference to an atomic Boolean value (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.742.1">
      cancellation_token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.743.1">
     ) representing the cancellation token.
    </span>
    <span class="koboSpan" id="kobo.743.2">
     The function will periodically check whether the cancellation token is set to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.744.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.745.1">
     .
    </span>
    <span class="koboSpan" id="kobo.745.2">
     When the running period passes or the cancellation token is set to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.746.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.747.1">
     , the thread
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.748.1">
      will exit.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.749.1">
     In the main thread, we can
    </span>
    <a id="_idIndexMarker446">
    </a>
    <span class="koboSpan" id="kobo.750.1">
     use two
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.751.1">
      packaged task objects
     </span>
    </strong>
    <span class="koboSpan" id="kobo.752.1">
     to execute this function, that is,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.753.1">
      task1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.754.1">
     lasting for 500 ms and running in thread
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.755.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.756.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.757.1">
      task2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.758.1">
     running for one second in thread
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.759.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.760.1">
     .
    </span>
    <span class="koboSpan" id="kobo.760.2">
     Both share the same
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.761.1">
      cancellation token:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.762.1">
std::atomic_bool cancellation_token{false};
std::cout &lt;&lt; "Starting long running tasks...\n";
std::packaged_task&lt;bool(int, const std::atomic_bool&amp;)&gt;
                task1(long_running_task);
std::future&lt;bool&gt; result1 = task1.get_future();
std::jthread t1(std::move(task1), 500,
                std::ref(cancellation_token));
std::packaged_task&lt;bool(int, const std::atomic_bool&amp;)&gt;
                task2(long_running_task);
std::future&lt;bool&gt; result2 = task2.get_future();
std::jthread t2(std::move(task2), 1000,
                std::ref(cancellation_token));
std::cout &lt;&lt; "Cancelling tasks after 600 ms...\n";
this_thread::sleep_for(600ms);
cancellation_token = true;
std::cout &lt;&lt; "Task1, waiting for 500 ms. </span><span class="koboSpan" id="kobo.762.2">Cancelled = "
          &lt;&lt; std::boolalpha &lt;&lt; result1.get() &lt;&lt; "\n";
std::cout &lt;&lt; "Task2, waiting for 1 second. </span><span class="koboSpan" id="kobo.762.3">Cancelled = "
          &lt;&lt; std::boolalpha &lt;&lt; result2.get() &lt;&lt; "\n";</span></pre>
   <p>
    <span class="koboSpan" id="kobo.763.1">
     After both tasks have started, the main thread sleeps for 600 ms.
    </span>
    <span class="koboSpan" id="kobo.763.2">
     When it wakes up, it sets the cancellation
    </span>
    <a id="_idIndexMarker447">
    </a>
    <span class="koboSpan" id="kobo.764.1">
     token to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.765.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.766.1">
     .
    </span>
    <span class="koboSpan" id="kobo.766.2">
     At that time,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.767.1">
      task1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.768.1">
     was already finished, but
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.769.1">
      task2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.770.1">
     was still running.
    </span>
    <span class="koboSpan" id="kobo.770.2">
     Thus,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.771.1">
      task2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.772.1">
     is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.773.1">
      being cancelled.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.774.1">
     This explanation aligns with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.775.1">
      obtained output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.776.1">
Starting long running tasks...
</span><span class="koboSpan" id="kobo.776.2">Cancelling tasks after 600 ms...
</span><span class="koboSpan" id="kobo.776.3">Task1, waiting for 500 ms. </span><span class="koboSpan" id="kobo.776.4">Cancelled = false
Task2, waiting for 1 second. </span><span class="koboSpan" id="kobo.776.5">Cancelled = true</span></pre>
   <p>
    <span class="koboSpan" id="kobo.777.1">
     Next, let’s see how to combine several asynchronous computation results into a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.778.1">
      single future.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-139">
    <a id="_idTextAnchor138">
    </a>
    <span class="koboSpan" id="kobo.779.1">
     Returning combined results
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.780.1">
     Another common approach in asynchronous programming is to decompose complex tasks into smaller independent subtasks using multiple promises and futures.
    </span>
    <span class="koboSpan" id="kobo.780.2">
     Each subtask can be launched in a
    </span>
    <a id="_idIndexMarker448">
    </a>
    <span class="koboSpan" id="kobo.781.1">
     separate thread and its result stored in a corresponding promise.
    </span>
    <span class="koboSpan" id="kobo.781.2">
     The main thread can then use the futures to wait for all subtasks to finish and combine their results to obtain
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.782.1">
      the outcome.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.783.1">
     This approach is useful to achieve parallel processing of multiple independent tasks, allowing the efficient utilization of multiple cores for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.784.1">
      faster computations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.785.1">
     Let’s see an example of a task that emulates a value computation and an I/O operation.
    </span>
    <span class="koboSpan" id="kobo.785.2">
     We want that task to return a tuple with both results, the computed value as an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.786.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.787.1">
     value, and the information read from the file as a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.788.1">
      string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.789.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.789.2">
     So, we define the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.790.1">
      combineFunc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.791.1">
     function that accepts as an argument a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.792.1">
      combineProm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.793.1">
     promise holding a tuple with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.794.1">
      result types.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.795.1">
     This function will create two
    </span>
    <a id="_idIndexMarker449">
    </a>
    <span class="koboSpan" id="kobo.796.1">
     threads,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.797.1">
      computeThread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.798.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.799.1">
      fetchData
     </span>
    </strong>
    <span class="koboSpan" id="kobo.800.1">
     , with their respective promises,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.801.1">
      computeProm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.802.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.803.1">
      fetchProm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.804.1">
     , and futures,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.805.1">
      computeFut
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.806.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.807.1">
       fetchFut
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.808.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.809.1">
void combineFunc(std::promise&lt;std::tuple&lt;int,
                 std::string&gt;&gt; combineProm) {
    try {
        // Thread to simulate computing a value.
</span><span class="koboSpan" id="kobo.809.2">        std::cout &lt;&lt; "Starting computeThread...\n";
        auto computeVal = [](std::promise&lt;int&gt; prom)
                            mutable {
            std::this_thread::sleep_for(1s);
            prom.set_value(42);
        };
        std::promise&lt;int&gt; computeProm;
        auto computeFut = computeProm.get_future();
        std::jthread computeThread(computeVal,
                              std::move(computeProm));
        // Thread to simulate downloading a file.
</span><span class="koboSpan" id="kobo.809.3">        std::cout &lt;&lt; "Starting dataThread...\n";
        auto fetchData = [](
                 std::promise&lt;std::string&gt; prom) mutable {
            std::this_thread::sleep_for(2s);
            prom.set_value("data.txt");
        };
        std::promise&lt;std::string&gt; fetchProm;
        auto fetchFut = fetchProm.get_future();
        std::jthread dataThread(fetchData,
                                std::move(fetchProm));
        combineProm.set_value({
                    computeFut.get(),
                    fetchFut.get()
        });
    } catch (...) {
        combineProm.set_exception(
                    std::current_exception());
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.810.1">
     As we can see, both threads will execute asynchronously and independently, generating a result and storing it in
    </span>
    <a id="_idIndexMarker450">
    </a>
    <span class="koboSpan" id="kobo.811.1">
     their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.812.1">
      respective promises.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.813.1">
     The combined promise is set by calling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.814.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.815.1">
     function on each future and combining their result into a tuple that is used to set the value of the combined promise by calling its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.816.1">
      set_value()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.817.1">
     function,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.818.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.819.1">
combineProm.set_value({computeFut.get(), fetchFut.get()});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.820.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.821.1">
      combineFunc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.822.1">
     task can be called as usual by using a thread and setting up the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.823.1">
      combineProm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.824.1">
     promise and its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.825.1">
      combineFut
     </span>
    </strong>
    <span class="koboSpan" id="kobo.826.1">
     future.
    </span>
    <span class="koboSpan" id="kobo.826.2">
     Calling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.827.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.828.1">
     function on this future will return
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.829.1">
      a tuple:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.830.1">
std::promise&lt;std::tuple&lt;int, std::string&gt;&gt; combineProm;
auto combineFuture = combineProm.get_future();
std::jthread combineThread(combineFunc,
                           std::move(combineProm));
auto [data, file] = combineFuture.get();
std::cout &lt;&lt; "Value [ " &lt;&lt; data
          &lt;&lt; " ]  File [ « &lt;&lt; file &lt;&lt; « ]\n»;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.831.1">
     Running this example
    </span>
    <a id="_idIndexMarker451">
    </a>
    <span class="koboSpan" id="kobo.832.1">
     will show the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.833.1">
      following result:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.834.1">
Creating combined promise...
</span><span class="koboSpan" id="kobo.834.2">Starting computeThread...
</span><span class="koboSpan" id="kobo.834.3">Starting dataThread...
</span><span class="koboSpan" id="kobo.834.4">Value [ 42 ]  File [ data.txt ]</span></pre>
   <p>
    <span class="koboSpan" id="kobo.835.1">
     Now, let’s continue by learning how to create a pipeline using promises
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.836.1">
      and futures.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-140">
    <a id="_idTextAnchor139">
    </a>
    <span class="koboSpan" id="kobo.837.1">
     Chaining asynchronous operations
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.838.1">
     Promises and futures can be chained together to perform multiple asynchronous operations sequentially.
    </span>
    <span class="koboSpan" id="kobo.838.2">
     We can create a pipeline where one future’s result becomes the input for the next
    </span>
    <a id="_idIndexMarker452">
    </a>
    <span class="koboSpan" id="kobo.839.1">
     operation’s promise.
    </span>
    <span class="koboSpan" id="kobo.839.2">
     This allows for composing complex asynchronous workflows where the output of one task feeds into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.840.1">
      the next.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.841.1">
     Also, we can allow branching in the pipeline and keep some tasks switched off until needed.
    </span>
    <span class="koboSpan" id="kobo.841.2">
     This can be done by using futures with deferred execution, which is useful in scenarios where the computation cost is high, but the result may not always be needed.
    </span>
    <span class="koboSpan" id="kobo.841.3">
     Thus, we can use futures to initiate the computation asynchronously and retrieve the result only when required.
    </span>
    <span class="koboSpan" id="kobo.841.4">
     As futures with deferred status can only be created by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.842.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.843.1">
     , we will leave that for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.844.1">
      next chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.845.1">
     In this section, we will focus on creating the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.846.1">
      task graph:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer038">
     <span class="koboSpan" id="kobo.847.1">
      <img alt="Figure 6.3 – A pipeline example" src="image/B22219_06_03.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.848.1">
     Figure 6.3 – A pipeline example
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.849.1">
     We start by defining a template class called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.850.1">
      Task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.851.1">
     that accepts a callable as a template argument, defining the
    </span>
    <a id="_idIndexMarker453">
    </a>
    <span class="koboSpan" id="kobo.852.1">
     function to execute.
    </span>
    <span class="koboSpan" id="kobo.852.2">
     This class will also allow us to create tasks that share a future with dependent ones.
    </span>
    <span class="koboSpan" id="kobo.852.3">
     These will use the shared futures to wait for the predecessor tasks to signal them about their completion by calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.853.1">
      set_value()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.854.1">
     in the associated promise before running their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.855.1">
      own task:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.856.1">
#define sync_cout std::osyncstream(std::cout)
template &lt;typename Func&gt;
class Task {
   public:
    Task(int id, Func&amp; func)
        : id_(id), func_(func), has_dependency_(false) {
        sync_cout &lt;&lt; "Task " &lt;&lt; id
                 &lt;&lt; " constructed without dependencies.\n";
        fut_ = prom_.get_future().share();
    }
    template &lt;typename... </span><span class="koboSpan" id="kobo.856.2">Futures&gt;
    Task(int id, Func&amp; func, Futures&amp;&amp;... </span><span class="koboSpan" id="kobo.856.3">futures)
        : id_(id), func_(func), has_dependency_(true) {
        sync_cout &lt;&lt; "Task " &lt;&lt; id
                  &lt;&lt; « constructed with dependencies.\n";
        fut_ = prom_.get_future().share();
        add_dependencies(
                  std::forward&lt;Futures&gt;(futures)...);
    }
    std::shared_future&lt;void&gt; get_dependency() {
        return fut_;
    }
    void operator()() {
        sync_cout &lt;&lt; "Running task " &lt;&lt; id_ &lt;&lt; '\n';
        wait_completion();
        func_();
        sync_cout &lt;&lt; "Signaling completion of task "
                  &lt;&lt; id_ &lt;&lt; ‹\n';
        prom_.set_value();
    }
   private:
    template &lt;typename... </span><span class="koboSpan" id="kobo.856.4">Futures&gt;
    void add_dependencies(Futures&amp;&amp;... </span><span class="koboSpan" id="kobo.856.5">futures) {
        (deps_.push_back(futures), ...);
    }
    void wait_completion() {
        sync_cout &lt;&lt; "Waiting completion for task "
                  &lt;&lt; id_ &lt;&lt; ‹\n';
        if (!deps_.empty()) {
            for (auto&amp; fut : deps_) {
                if (fut.valid()) {
                    sync_cout &lt;&lt; "Fut valid so getting "
                              &lt;&lt; "value in task "
                              &lt;&lt; id_ &lt;&lt; ‹\n';
                    fut.get();
                }
            }
        }
    }
   private:
    int id_;
    Func&amp; func_;
    std::promise&lt;void&gt; prom_;
    std::shared_future&lt;void&gt; fut_;
    std::vector&lt;std::shared_future&lt;void&gt;&gt; deps_;
    bool has_dependency_;
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.857.1">
     Let’s describe step by step how this
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.858.1">
      Task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.859.1">
     class
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.860.1">
      is implemented.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.861.1">
     There are two constructors: one to initialize an object of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.862.1">
      Task
     </span>
    </strong>
    <span class="koboSpan" id="kobo.863.1">
     that has no dependencies with other tasks and another templated constructor to initialize a task with a variable number of dependent tasks.
    </span>
    <span class="koboSpan" id="kobo.863.2">
     Both initialize an identifier (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.864.1">
      id_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.865.1">
     ), the function to call to perform the task (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.866.1">
      func_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.867.1">
     ), a Boolean variable indicating whether the task has dependencies or
    </span>
    <a id="_idIndexMarker454">
    </a>
    <span class="koboSpan" id="kobo.868.1">
     not (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.869.1">
      has_dependency_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.870.1">
     ), and a shared future,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.871.1">
      fut_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.872.1">
     , to share with tasks that will depend on this one.
    </span>
    <span class="koboSpan" id="kobo.872.2">
     This
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.873.1">
      fut_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.874.1">
     future is retrieved from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.875.1">
      prom_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.876.1">
     promise used to signal the task completion.
    </span>
    <span class="koboSpan" id="kobo.876.2">
     The templated constructor also calls the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.877.1">
      add_dependencies
     </span>
    </strong>
    <span class="koboSpan" id="kobo.878.1">
     function forwarding the futures passed as arguments, which will be stored in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.879.1">
       deps_
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.880.1">
      vector.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.881.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.882.1">
      get_dependency()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.883.1">
     function just returns the shared future used by dependent tasks to wait for the completion of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.884.1">
      current task.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.885.1">
     Finally,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.886.1">
      operator()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.887.1">
     waits for the completion of previous tasks by calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.888.1">
      wait_completion()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.889.1">
     , which checks whether each shared future stored in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.890.1">
      deps_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.891.1">
     vector is valid and waiting until the result is ready by calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.892.1">
      get()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.893.1">
     .
    </span>
    <span class="koboSpan" id="kobo.893.2">
     Once all shared futures are ready, meaning that all previous tasks are complete, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.894.1">
      func_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.895.1">
     function is invoked, running the task, and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.896.1">
      prom_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.897.1">
     promise is then set to ready by calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.898.1">
      set_value()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.899.1">
     , triggering the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.900.1">
      dependent tasks.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.901.1">
     In the main thread, we define the pipeline as follows, creating a graph like the one shown in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.902.1">
       Figure 6
      </span>
     </em>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.903.1">
       .3
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.904.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.905.1">
auto sleep1s = []() { std::this_thread::sleep_for(1s); };
auto sleep2s = []() { std::this_thread::sleep_for(2s); };
Task task1(1, sleep1s);
Task task2(2, sleep2s, task1.get_dependency());
Task task3(3, sleep1s, task2.get_dependency());
Task task4(4, sleep2s, task2.get_dependency());
Task task5(5, sleep2s, task3.get_dependency(),
                       task4.get_dependency());</span></pre>
   <p>
    <span class="koboSpan" id="kobo.906.1">
     Then, we need to start the pipeline by triggering all tasks and calling their
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.907.1">
      operator()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.908.1">
     .
    </span>
    <span class="koboSpan" id="kobo.908.2">
     As
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.909.1">
      task1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.910.1">
     has no dependencies, it will start running straight away.
    </span>
    <span class="koboSpan" id="kobo.910.2">
     All other tasks will be waiting for their
    </span>
    <a id="_idIndexMarker455">
    </a>
    <span class="koboSpan" id="kobo.911.1">
     predecessor tasks to complete
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.912.1">
      their work:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.913.1">
sync_cout &lt;&lt; "Starting the pipeline..." </span><span class="koboSpan" id="kobo.913.2">&lt;&lt; std::endl;
task1();
task2();
task3();
task4();
task5();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.914.1">
     Finally, we need to wait for the pipeline to finish the execution of all tasks.
    </span>
    <span class="koboSpan" id="kobo.914.2">
     We can achieve that by simply waiting for the shared future returned by the last task,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.915.1">
      task5
     </span>
    </strong>
    <span class="koboSpan" id="kobo.916.1">
     , to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.917.1">
      be ready:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.918.1">
sync_cout &lt;&lt; "Waiting for the pipeline to finish...\n";
auto finish_pipeline_fut = task5.get_dependency();
finish_pipeline_fut.get();
sync_cout &lt;&lt; "All done!" </span><span class="koboSpan" id="kobo.918.2">&lt;&lt; std::endl;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.919.1">
     Here is the output of running
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.920.1">
      this example:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.921.1">
Task 1 constructed without dependencies.
</span><span class="koboSpan" id="kobo.921.2">Getting future from task 1
Task 2 constructed with dependencies.
</span><span class="koboSpan" id="kobo.921.3">Getting future from task 2
Task 3 constructed with dependencies.
</span><span class="koboSpan" id="kobo.921.4">Getting future from task 2
Task 4 constructed with dependencies.
</span><span class="koboSpan" id="kobo.921.5">Getting future from task 4
Getting future from task 3
Task 5 constructed with dependencies.
</span><span class="koboSpan" id="kobo.921.6">Starting the pipeline...
</span><span class="koboSpan" id="kobo.921.7">Running task 1
Waiting completion for task 1
Signaling completion of task 1
Running task 2
Waiting completion for task 2
Fut valid so getting value in task 2
Signaling completion of task 2
Running task 3
Waiting completion for task 3
Fut valid so getting value in task 3
Signaling completion of task 3
Running task 4
Waiting completion for task 4
Fut valid so getting value in task 4
Signaling completion of task 4
Running task 5
Waiting completion for task 5
Fut valid so getting value in task 5
Fut valid so getting value in task 5
Signaling completion of task 5
Waiting for the pipeline to finish...
</span><span class="koboSpan" id="kobo.921.8">Getting future from task 5
All done!</span></pre>
   <p>
    <span class="koboSpan" id="kobo.922.1">
     There are some issues that can occur with this approach that we must be aware of.
    </span>
    <span class="koboSpan" id="kobo.922.2">
     First, the dependency graph must be a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.923.1">
      directed acyclic graph
     </span>
    </strong>
    <span class="koboSpan" id="kobo.924.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.925.1">
      DAG
     </span>
    </strong>
    <span class="koboSpan" id="kobo.926.1">
     ), therefore without cycles or loops between dependent
    </span>
    <a id="_idIndexMarker456">
    </a>
    <span class="koboSpan" id="kobo.927.1">
     tasks.
    </span>
    <span class="koboSpan" id="kobo.927.2">
     Otherwise, a deadlock will occur, as a task might be waiting for a task happening in the future and not yet started.
    </span>
    <span class="koboSpan" id="kobo.927.3">
     Also, we need enough threads to run all the tasks concurrently or launch the tasks orderly; otherwise, it can also lead to a
    </span>
    <a id="_idIndexMarker457">
    </a>
    <span class="koboSpan" id="kobo.928.1">
     deadlock with threads waiting on the completion of tasks that have still
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.929.1">
      not launched.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.930.1">
     One common use case of this approach
    </span>
    <a id="_idIndexMarker458">
    </a>
    <span class="koboSpan" id="kobo.931.1">
     can be found in
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.932.1">
      MapReduce
     </span>
    </strong>
    <span class="koboSpan" id="kobo.933.1">
     algorithms where large datasets are processed in parallel across multiple nodes, and futures and threads can be used to execute map and reduce tasks concurrently, allowing efficient distributed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.934.1">
      data processing.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-141">
    <a id="_idTextAnchor140">
    </a>
    <span class="koboSpan" id="kobo.935.1">
     Thread-safe SPSC task queue
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.936.1">
     In this last example, we will show
    </span>
    <a id="_idIndexMarker459">
    </a>
    <span class="koboSpan" id="kobo.937.1">
     how to use promises and futures to create an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.938.1">
      SPSC queue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.939.1">
     The producer thread creates a promise for each item it wants to add to the queue.
    </span>
    <span class="koboSpan" id="kobo.939.2">
     The consumer thread waits for a future obtained from an empty queue slot.
    </span>
    <span class="koboSpan" id="kobo.939.3">
     Once the producer finishes adding an item, it sets the value on the corresponding promise, notifying the waiting consumer.
    </span>
    <span class="koboSpan" id="kobo.939.4">
     This allows for efficient data exchange between threads while maintaining
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.940.1">
      thread safety.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.941.1">
     Let’s first define the thread-safe
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.942.1">
      queue class:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.943.1">
template &lt;typename T&gt;
class ThreadSafeQueue {
   public:
    void push(T value) {
        std::lock_guard&lt;std::mutex&gt; lock(mutex_);
        queue_.push(std::move(value));
        cond_var_.notify_one();
    }
    T pop() {
        std::unique_lock&lt;std::mutex&gt; lock(mutex_);
        cond_var_.wait(lock, [&amp;]{
            return !queue_.empty();
        });
        T value = std::move(queue_.front());
        queue_.pop();
        return value;
    }
   private:
    std::queue&lt;T&gt; queue_;
    std::mutex mutex_;
    std::condition_variable cond_var_;
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.944.1">
     In this example, we simply use a mutex to have mutual exclusion over all the queue data structures when pushing
    </span>
    <a id="_idIndexMarker460">
    </a>
    <span class="koboSpan" id="kobo.945.1">
     or popping elements.
    </span>
    <span class="koboSpan" id="kobo.945.2">
     We want to keep this example simple and focus on the promise and future interactions.
    </span>
    <span class="koboSpan" id="kobo.945.3">
     A better approach could be to use a vector or circular array and control the access to individual elements within the queue
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.946.1">
      with mutexes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.947.1">
     The queue also uses a condition variable,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.948.1">
      cond_var_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.949.1">
     , to wait if the queue is empty when trying to pop an element and to notify one waiting thread when an element is pushed.
    </span>
    <span class="koboSpan" id="kobo.949.2">
     Elements are moved in and out of the queue by moving them.
    </span>
    <span class="koboSpan" id="kobo.949.3">
     This is needed as the queue will store futures, and as we learned earlier, futures are movable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.950.1">
      but non-copiable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.951.1">
     The thread-safe queue will be used to define a task queue that will store futures,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.952.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.953.1">
using TaskQueue = ThreadSafeQueue&lt;std::future&lt;int&gt;&gt;;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.954.1">
     Then, we define a function,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.955.1">
      producer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.956.1">
     , that accepts a reference to the queue, and a value,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.957.1">
      val
     </span>
    </strong>
    <span class="koboSpan" id="kobo.958.1">
     , that will be produced.
    </span>
    <span class="koboSpan" id="kobo.958.2">
     This function just creates a promise, retrieves a future from the promise, and pushes that future into the queue.
    </span>
    <span class="koboSpan" id="kobo.958.3">
     Then, we simulate a task running and
    </span>
    <a id="_idIndexMarker461">
    </a>
    <span class="koboSpan" id="kobo.959.1">
     producing the value,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.960.1">
      val
     </span>
    </strong>
    <span class="koboSpan" id="kobo.961.1">
     , by making the thread wait for a random number of milliseconds.
    </span>
    <span class="koboSpan" id="kobo.961.2">
     Finally, the value is stored in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.962.1">
      the promise:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.963.1">
void producer(TaskQueue&amp; queue, int val) {
    std::promise&lt;int&gt; prom;
    auto fut = prom.get_future();
    queue.push(std::move(fut));
    std::this_thread::sleep_for(
            std::chrono::milliseconds(rand() % MAX_WAIT));
    prom.set_value(val);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.964.1">
     At the other end of the communication channel, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.965.1">
      consumer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.966.1">
     function accepts a reference to the same queue.
    </span>
    <span class="koboSpan" id="kobo.966.2">
     Again, we simulate a task running on the consumer side by waiting for a random number of milliseconds.
    </span>
    <span class="koboSpan" id="kobo.966.3">
     Then, a future is popped out of the queue and its result is retrieved, being the value,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.967.1">
      val
     </span>
    </strong>
    <span class="koboSpan" id="kobo.968.1">
     , or an exception if something
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.969.1">
      went wrong:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.970.1">
void consumer(TaskQueue&amp; queue) {
    std::this_thread::sleep_for(
            std::chrono::milliseconds(rand() % MAX_WAIT));
    std::future&lt;int&gt; fut = queue.pop();
    try {
        int result = fut.get();
        std::cout &lt;&lt; "Result: " &lt;&lt; result &lt;&lt; "\n";
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; '\n';
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.971.1">
     For this example, we will use
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.972.1">
      these constants:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.973.1">
const unsigned VALUE_RANGE = 1000;
const unsigned RESULTS_TO_PRODUCE = 10; // Numbers of items to produce.
</span><span class="koboSpan" id="kobo.973.2">const unsigned MAX_WAIT = 500; // Maximum waiting time (ms) when producing items.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.974.1">
     In the main thread, two
    </span>
    <a id="_idIndexMarker462">
    </a>
    <span class="koboSpan" id="kobo.975.1">
     threads are started; the first runs the producer function
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.976.1">
      producerFunc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.977.1">
     , which pushes some futures into the queue, while the second thread runs the consumer function
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.978.1">
      consumerFunc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.979.1">
     , which consumes elements from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.980.1">
      the queue:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.981.1">
TaskQueue queue;
auto producerFunc = [](TaskQueue&amp; queue) {
    auto n = RESULTS_TO_PRODUCE;
    while (n-- &gt; 0) {
        int val = rand() % VALUE_RANGE;
        std::cout &lt;&lt; "Producer: Sending value " &lt;&lt; val
                  &lt;&lt; std::endl;
        producer(queue, val);
    }
};
auto consumerFunc = [](TaskQueue&amp; queue) {
    auto n = RESULTS_TO_PRODUCE;
    while (n-- &gt; 0) {
        std::cout &lt;&lt; "Consumer: Receiving value"
                  &lt;&lt; std::endl;
        consumer(queue);
    }
};
std::jthread producerThread(producerFunc, std::ref(queue));
std::jthread consumerThread(consumerFunc, std::ref(queue));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.982.1">
     Here is sample output
    </span>
    <a id="_idIndexMarker463">
    </a>
    <span class="koboSpan" id="kobo.983.1">
     of executing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.984.1">
      this code:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.985.1">
Producer: Sending value 383
Consumer: Receiving value
Producer: Sending value 915
Result: 383
Consumer: Receiving value
Producer: Sending value 386
Result: 915
Consumer: Receiving value
Producer: Sending value 421
Result: 386
Consumer: Receiving value
Producer: Sending value 690
Result: 421
Consumer: Receiving value
Producer: Sending value 926
Producer: Sending value 426
Result: 690
Consumer: Receiving value
Producer: Sending value 211
Result: 926
Consumer: Receiving value
Result: 426
Consumer: Receiving value
Producer: Sending value 782
Producer: Sending value 862
Result: 211
Consumer: Receiving value
Result: 782
Consumer: Receiving value
Result: 862</span></pre>
   <p>
    <span class="koboSpan" id="kobo.986.1">
     With a producer-consumer
    </span>
    <a id="_idIndexMarker464">
    </a>
    <span class="koboSpan" id="kobo.987.1">
     queue like this one, the consumer and producer are decoupled, and their threads communicate asynchronously, allowing both the producer and consumer to do extra work while the other side generates or processes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.988.1">
      the values.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-142">
    <a id="_idTextAnchor141">
    </a>
    <span class="koboSpan" id="kobo.989.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.990.1">
     In this chapter, we learned about promises and futures, how to use them to execute asynchronous code in separate threads, and also how to run callables using packaged tasks.
    </span>
    <span class="koboSpan" id="kobo.990.2">
     These objects and mechanisms constitute and implement the key concepts of asynchronous programming used by many programming languages,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.991.1">
      including C++.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.992.1">
     We also now understand why promises, futures, and packaged tasks cannot be copied, and thus how to share futures by using shared
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.993.1">
      future objects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.994.1">
     Finally, we have shown how to use futures, promises, and packaged tasks to tackle
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.995.1">
      real-life problems.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.996.1">
     If you want to explore promises and futures deeper, it is worth mentioning some third-party open source libraries, especially
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.997.1">
      Boost.Thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.998.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.999.1">
      Facebook Folly
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1000.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1000.2">
     These libraries include additional functionality, including callbacks, executors,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1001.1">
      and combinators.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1002.1">
     In the next chapter, we will learn a simpler way to asynchronously invoke callables by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1003.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1004.1">
       std::async
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1005.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-143">
    <a id="_idTextAnchor142">
    </a>
    <span class="koboSpan" id="kobo.1006.1">
     Further reading
    </span>
   </h1>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.1007.1">
      Boost futures and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1008.1">
       promises:
      </span>
     </span>
     <a href="https://theboostcpplibraries.com/boost.thread-futures-and-promises">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1009.1">
        https://theboostcpplibraries.com/boost.thread-futures-and-promises
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1010.1">
      Facebook Folly open source
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1011.1">
       library:
      </span>
     </span>
     <a href="https://github.com/facebook/folly">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1012.1">
        https://github.com/facebook/folly
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1013.1">
      Futures for C++11 at
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1014.1">
       Facebook:
      </span>
     </span>
     <a href="https://engineering.fb.com/2015/06/19/developer-tools/futures-for-c-11-at-facebook">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1015.1">
        https://engineering.fb.com/2015/06/19/developer-tools/futures-for-c-11-at-facebook
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1016.1">
       ‘Futures and Promises’ – How Instagram leverages it for better resource
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1017.1">
        utilization
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1018.1">
       :
      </span>
     </span>
     <a href="https://scaleyourapp.com/futures-and-promises-and-how-instagram-leverages-it/">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1019.1">
        https://scaleyourapp.com/futures-and-promises-and-how-instagram-leverages-it/
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1020.1">
      SeaStar: Open source C++ framework for high-performance server
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1021.1">
       applications:
      </span>
     </span>
     <a href="https://seastar.io">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1022.1">
        https://seastar.io
       </span>
      </span>
     </a>
    </li>
   </ul>
  </div>
 </body></html>