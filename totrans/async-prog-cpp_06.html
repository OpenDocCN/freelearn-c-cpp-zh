<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-126">
    <a id="_idTextAnchor125">
    </a>
    
     6
    
   </h1>
   <h1 id="_idParaDest-127">
    <a id="_idTextAnchor126">
    </a>
    
     Promises and Futures
    
   </h1>
   <p>
    
     In previous chapters, we learned the foundations of managing and synchronizing thread execution using C++.
    
    
     We also mentioned in
    
    <a href="B22219_03.xhtml#_idTextAnchor051">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     that to return values from a thread, we could use promises and futures.
    
    
     Now it’s time to learn how to do that and much more using these features
    
    
     
      in C++.
     
    
   </p>
   <p>
    <strong class="bold">
     
      Futures
     
    </strong>
    
     and
    
    <strong class="bold">
     
      promises
     
    </strong>
    
     are essential blocks for achieving asynchronous programming.
    
    
     They define a way to manage the result of a task that will be completed in the future, usually in a
    
    
     
      separate thread.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      What are promises
     
     
      
       and futures?
      
     
    </li>
    <li>
     
      What are shared futures and how are they different from
     
     
      
       regular futures?
      
     
    </li>
    <li>
     
      What are packaged tasks and when do we
     
     
      
       use them?
      
     
    </li>
    <li>
     
      How do we check future statuses
     
     
      
       and errors?
      
     
    </li>
    <li>
     
      What are the benefits and drawbacks of using promises
     
     
      
       and futures?
      
     
    </li>
    <li>
     
      Examples of real-life scenarios
     
     
      
       and solutions
      
     
    </li>
   </ul>
   <p>
    
     So, let’s
    
    
     
      get started!
     
    
   </p>
   <h1 id="_idParaDest-128">
    <a id="_idTextAnchor127">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     Promises and futures have been available since C++11, but some examples implemented in this chapter use features from C++20, such as
    
    <strong class="source-inline">
     
      std::jthread
     
    </strong>
    
     , so the code shown in this chapter can be compiled by compilers
    
    
     
      supporting C++20.
     
    
   </p>
   <p>
    
     Please check the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section in
    
    <a href="B22219_03.xhtml#_idTextAnchor051">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     for guidance on how to install GCC 13 and Clang
    
    
     
      8 compilers.
     
    
   </p>
   <p>
    
     You can find all the complete code in the following
    
    
     
      GitHub repository:
     
    
   </p>
   <p>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     
      
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      
     
    </a>
   </p>
   <p>
    
     The examples for this chapter are located under the
    
    <strong class="source-inline">
     
      Chapter_06
     
    </strong>
    
     folder.
    
    
     All source code files can be compiled using CMake
    
    
     
      as follows:
     
    
   </p>
   <pre class="console">
cmake . &amp;&amp; cmake build .</pre>
   <p>
    
     Executable binaries will be generated under the
    
    
     <strong class="source-inline">
      
       bin
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <h1 id="_idParaDest-129">
    <a id="_idTextAnchor128">
    </a>
    
     Exploring promises and futures
    
   </h1>
   <p>
    
     A
    
    <strong class="bold">
     
      future
     
    </strong>
    
     is an object that represents some
    
    <a id="_idIndexMarker403">
    </a>
    
     undetermined result that will be completed sometime in the future.
    
    
     A
    
    <strong class="bold">
     
      promise
     
    </strong>
    
     is the
    
    <a id="_idIndexMarker404">
    </a>
    
     provider of
    
    
     
      that result.
     
    
   </p>
   <p>
    
     Promises and futures have been part of the C++ standard since version C++11 and are available by including the
    
    <strong class="source-inline">
     
      &lt;future&gt;
     
    </strong>
    
     header file, promises via the class
    
    <strong class="source-inline">
     
      std::promise
     
    </strong>
    
     and futures via the
    
    
     
      class
     
    
    
     <strong class="source-inline">
      
       std::future
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      std::promise
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      std::future
     
    </strong>
    
     pair implements a one-shot producer-consumer channel with the promise as the producer and the future as the consumer.
    
    
     The consumer (
    
    <strong class="source-inline">
     
      std::future
     
    </strong>
    
     ) can block until the result of the producer (
    
    <strong class="source-inline">
     
      std::promise
     
    </strong>
    
     )
    
    
     
      is available.
     
    
   </p>
   <div><div><img alt="Figure 6.1 – Promise-future communication channel" src="img/B22219_06_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.1 – Promise-future communication channel
    
   </p>
   <p>
    
     Many modern programming languages provide similar asynchronous approaches, such as Python (with the
    
    <strong class="source-inline">
     
      asyncio
     
    </strong>
    
     library), Scala (in the
    
    <strong class="source-inline">
     
      scala.concurrent
     
    </strong>
    
     library), JavaScript (in its core library), Rust (in its
    
    <strong class="bold">
     
      Standard Library
     
    </strong>
    
     (
    
    <strong class="bold">
     
      std
     
    </strong>
    
     ) or crates such as
    
    <strong class="source-inline">
     
      promising_future
     
    </strong>
    
     ), Swift (in the
    
    <a id="_idIndexMarker405">
    </a>
    
     Combine framework), and Kotlin,
    
    
     
      among others.
     
    
   </p>
   <p>
    
     The basic principle behind achieving asynchronous execution using promises and futures is that a function we want to run to generate a result is executed in the background, using a new thread or the current one, and a future object is used by the initial thread to retrieve the result computed by the function.
    
    
     This result value will be stored when the function finishes, so meanwhile, the future will be used as a placeholder.
    
    
     The asynchronous function will use a promise object to store the result in the future with no need for explicit synchronization mechanisms between the initial thread and the background one.
    
    
     When the value is
    
    <a id="_idIndexMarker406">
    </a>
    
     needed by the initial thread, it will be retrieved from the future object.
    
    
     If the value is still not ready, the initial thread execution will be blocked until the future
    
    
     
      becomes ready.
     
    
   </p>
   <p>
    
     With this idea, making a function run asynchronously becomes easy.
    
    
     We only need to be aware that the function can run on a separate thread, so we need to avoid data races, but result communication and synchronization between threads is managed by the
    
    
     
      promise-future pair.
     
    
   </p>
   <p>
    
     Using promises and futures improves responsiveness by offloading computations and provides a structured approach to handling asynchronous operations compared to threads and callbacks, as we will explore in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     Let’s now learn about these
    
    
     
      two objects.
     
    
   </p>
   <h2 id="_idParaDest-130">
    <a id="_idTextAnchor129">
    </a>
    
     Promises
    
   </h2>
   <p>
    
     Promises are defined
    
    <a id="_idIndexMarker407">
    </a>
    
     in the
    
    <strong class="source-inline">
     
      &lt;future&gt;
     
    </strong>
    
     header
    
    
     
      as
     
    
    
     <strong class="source-inline">
      
       std::promise
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     With a promise, we get an agreement that the result will be available at some time in the future.
    
    
     This way, we can let the background task do its work and compute the result.
    
    
     Meanwhile the main thread will also proceed with its task and, when the result is needed, request it.
    
    
     At that time, the result might already
    
    
     
      be ready.
     
    
   </p>
   <p>
    
     Also, promises can communicate if an exception was raised instead of returning a valid value and, they will make sure that its lifetime persists until the thread finishes and writes the result
    
    
     
      to it.
     
    
   </p>
   <p>
    
     Therefore, a promise is a facility to store a result (a value or an exception) that is later acquired asynchronously via a future.
    
    
     A promise object is only intended to be used once and cannot be
    
    
     
      modified afterward.
     
    
   </p>
   <p>
    
     Apart from a result, each promise also holds a shared state.
    
    
     The shared state is a memory area that stores the completion status, synchronization mechanisms, and a pointer to the result.
    
    
     It ensures proper communication and synchronization between a promise and a future by enabling the promise to store either a result or an exception, signal when it’s complete, and allowing the future to access the result, blocking if the promise is not yet ready.
    
    
     The promise can update its shared state using the
    
    
     
      following operations:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Make ready
      
     </strong>
     
      : The promise stores the result in the shared state and makes the state of the promise to become ready unblocking any thread waiting on a future associated with the promise.
     
     
      Remember
     
     <a id="_idIndexMarker408">
     </a>
     
      that the result can be a value (or even void) or
     
     
      
       an exception.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Release
      
     </strong>
     
      : The promise releases its reference to the shared state, which will be destroyed if this is the last
     
     <a id="_idIndexMarker409">
     </a>
     
      reference.
     
     
      This memory release mechanism is like the one used by shared pointers and their control blocks.
     
     
      This operation does not block unless the shared state was created by
     
     <strong class="source-inline">
      
       std::async
      
     </strong>
     
      and is not yet in the ready status (we will learn about this in the
     
     
      
       next chapter).
      
     
    </li>
    <li>
     <strong class="bold">
      
       Abandon
      
     </strong>
     
      : The promise stores
     
     <a id="_idIndexMarker410">
     </a>
     
      an exception of type
     
     <strong class="source-inline">
      
       std::future_error
      
     </strong>
     
      with error code
     
     <strong class="source-inline">
      
       std::future_errc::broken_promise
      
     </strong>
     
      , making the shared state ready and then
     
     
      
       releasing it.
      
     
    </li>
   </ul>
   <p>
    
     A
    
    <strong class="source-inline">
     
      std::promise
     
    </strong>
    
     object can be constructed using its default constructor or using a custom allocator.
    
    
     In both cases, a new promise will be created with an empty shared state.
    
    
     Promises can also be constructed using the move constructor; thus, the new promise will have the shared state owned by the other promise.
    
    
     The initial promise will remain with no
    
    
     
      shared state.
     
    
   </p>
   <p>
    
     Moving a promise is
    
    <a id="_idIndexMarker411">
    </a>
    
     useful in scenarios related to resource management, optimization by avoiding extra copies, and keeping correct ownership semantics; for example, it’s useful when a promise needs to be completed in another thread, stored in a container, returned to the caller of an API call, or sent to a
    
    
     
      callback handler.
     
    
   </p>
   <p>
    
     Promises cannot be copied (their copy-constructor or copy-assignment operator is deleted), avoiding two promise objects sharing the same shared state and in risk of data races when results are stored in the
    
    
     
      shared state.
     
    
   </p>
   <p>
    
     As promises can be moved, they can also be
    
    <a id="_idIndexMarker412">
    </a>
    
     swapped.
    
    
     The
    
    <strong class="source-inline">
     
      std::swap
     
    </strong>
    
     function from the
    
    <strong class="bold">
     
      Standard Template Library
     
    </strong>
    
     (
    
    <strong class="bold">
     
      STL
     
    </strong>
    
     ) has a template specialization
    
    
     
      for promises.
     
    
   </p>
   <p>
    
     When a promise object is deleted, the associated future will still have access to the shared state.
    
    
     If deletion happens after the promise sets the value, the shared state will be in release mode, thus the future can access the result and use it.
    
    
     However, if the promise was deleted before setting the result value, the shared state will be moved to abandoned, and the future will obtain
    
    <strong class="source-inline">
     
      std::future_errc::broken_promise
     
    </strong>
    
     when trying to get
    
    
     
      the result.
     
    
   </p>
   <p>
    
     A value can be set by using the
    
    <strong class="source-inline">
     
      std::promise
     
    </strong>
    
     function
    
    <strong class="source-inline">
     
      set_value()
     
    </strong>
    
     and an exception by using the
    
    <strong class="source-inline">
     
      set_exception()
     
    </strong>
    
     function.
    
    
     The result is stored atomically in the promise’s shared
    
    <a id="_idIndexMarker413">
    </a>
    
     state, making its state ready.
    
    
     Let’s see
    
    
     
      an example:
     
    
   </p>
   <pre class="source-code">
auto threadFunc = [](std::promise&lt;int&gt; prom) {
    try {
        int result = func();
        prom.set_value(result);
    } catch (...) {
        prom.set_exception(std::current_exception());
    }
};
std::promise&lt;int&gt; prom;
std::jthread t(threadFunc, std::move(prom));</pre>
   <p>
    
     In the previous example, the
    
    <strong class="source-inline">
     
      prom
     
    </strong>
    
     promise is created and moved into the
    
    <strong class="source-inline">
     
      threadFunc
     
    </strong>
    
     lambda function as a parameter.
    
    
     As the promise is non-copyable, we need to use pass-by-value together with moving the promise into the parameter to
    
    
     
      avoid copies.
     
    
   </p>
   <p>
    
     Inside the lambda function, the
    
    <strong class="source-inline">
     
      func()
     
    </strong>
    
     function is called, and its result is stored in the promise using
    
    <strong class="source-inline">
     
      set_value()
     
    </strong>
    
     .
    
    
     If
    
    <strong class="source-inline">
     
      func()
     
    </strong>
    
     throws an exception, it’s captured and stored into the promise using
    
    <strong class="source-inline">
     
      set_exception()
     
    </strong>
    
     .
    
    
     As we will learn later, this result (value or exception) can be extracted in the calling thread by using
    
    
     
      a future.
     
    
   </p>
   <p>
    
     In C++14, we can also use generalized lambda capture to pass the promise into the
    
    
     
      lambda capture:
     
    
   </p>
   <pre class="source-code">
using namespace std::literals;
std::promise&lt;std::string&gt; prom;
auto t = std::jthread([prm = std::move(prom)] mutable {
    std::this_thread::sleep_for(100ms);
    prm.set_value("Value successfully set");
});</pre>
   <p>
    
     Therefore,
    
    <strong class="source-inline">
     
      prm = std::move(prom)
     
    </strong>
    
     is moving the external promise,
    
    <strong class="source-inline">
     
      prom
     
    </strong>
    
     , into the lambda’s internal promise,
    
    <strong class="source-inline">
     
      prm
     
    </strong>
    
     .
    
    
     By default, parameters are captured as constants, so we need to specify
    
    <a id="_idIndexMarker414">
    </a>
    
     the lambda as mutable to allow
    
    <strong class="source-inline">
     
      prm
     
    </strong>
    
     to
    
    
     
      be modified.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      set_value()
     
    </strong>
    
     can throw a
    
    <strong class="source-inline">
     
      std::future_error
     
    </strong>
    
     exception if the promise has no shared state (error code set to
    
    <strong class="source-inline">
     
      no_state
     
    </strong>
    
     ) or the shared state has already a stored result (error code set
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       promise_already_satisfied
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      set_value()
     
    </strong>
    
     can also be used without specifying a value.
    
    
     In that case, it simply makes the state ready.
    
    
     That can be used as a barrier, as we will see later in this chapter after
    
    
     
      introducing futures.
     
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    <em class="italic">
     
      .2
     
    </em>
    
     shows a diagram representing the different shared
    
    
     
      state transitions.
     
    
   </p>
   <div><div><img alt="Figure 6.2 – Promise shared state transitions diagram" src="img/B22219_06_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.2 – Promise shared state transitions diagram
    
   </p>
   <p>
    
     There are two other functions to set the value of a promise,
    
    <strong class="source-inline">
     
      set_value_at_thread_exit
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      set_exception_at_thread_exit
     
    </strong>
    
     .
    
    
     As before, the result is stored immediately, but using these new functions, the state is not made ready yet.
    
    
     The state becomes ready when the thread exits after all thread-local variables have been destroyed.
    
    
     This is useful when we want threads to manage resources that need to be cleaned up before exiting, even if an exception happens, or if we want to provide accurate log activity or monitor when
    
    
     
      threads exit.
     
    
   </p>
   <p>
    
     In terms of exceptions thrown or synchronization mechanisms to avoid data races, both functions behave as
    
    <strong class="source-inline">
     
      set_value()
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       set_exception()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Now that we
    
    <a id="_idIndexMarker415">
    </a>
    
     know how to store a result in a promise, let’s learn about the other member of the duo,
    
    
     
      the future.
     
    
   </p>
   <h2 id="_idParaDest-131">
    <a id="_idTextAnchor130">
    </a>
    
     Futures
    
   </h2>
   <p>
    
     Futures are defined in the
    
    <strong class="source-inline">
     
      &lt;future&gt;
     
    </strong>
    
     header file
    
    
     
      as
     
    
    
     <strong class="source-inline">
      
       std::future
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     As we saw earlier, a future is the
    
    <a id="_idIndexMarker416">
    </a>
    
     consumer side of the communication channel.
    
    
     It provides access to the result stored by
    
    
     
      the promise.
     
    
   </p>
   <p>
    
     A
    
    <strong class="source-inline">
     
      std::future
     
    </strong>
    
     object must be created from a
    
    <strong class="source-inline">
     
      std::promise
     
    </strong>
    
     object by calling
    
    <strong class="source-inline">
     
      get_future()
     
    </strong>
    
     , or through a
    
    <strong class="source-inline">
     
      std::packaged_task
     
    </strong>
    
     object (more details later in this chapter) or a call to the
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     function (in
    
    <a href="B22219_07.xhtml#_idTextAnchor143">
     
      <em class="italic">
       
        Chapter 7
       
      </em>
     
    </a>
    
     
      ):
     
    
   </p>
   <pre class="source-code">
std::promise&lt;int&gt; prom;
std::future&lt;int&gt; fut = prom.get_future();</pre>
   <p>
    
     Like promises, futures can be moved but not copied for the same reasons.
    
    
     To reference the same shared state from multiple futures, we need to use shared futures (explained in the next section,
    
    
     <em class="italic">
      
       Shared futures
      
     </em>
    
    
     
      ).
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     method can be used to retrieve the result.
    
    
     If the shared state is still not ready, this call will block by internally calling
    
    <strong class="source-inline">
     
      wait()
     
    </strong>
    
     .
    
    
     When the shared state becomes ready, the result value is returned.
    
    
     If an exception was stored in the shared state, that exception will
    
    
     
      be rethrown:
     
    
   </p>
   <pre class="source-code">
try {
    int result = fut.get();
    std::cout &lt;&lt; "Result from thread: " &lt;&lt; result &lt;&lt; '\n';
} catch (const std::exception&amp; e) {
    std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; '\n';
}</pre>
   <p>
    
     In the preceding example, the result is retrieved from the
    
    <strong class="source-inline">
     
      fut
     
    </strong>
    
     future by using the
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     function.
    
    
     If the result is a value, it will be printed with a line starting with
    
    <strong class="source-inline">
     
      Result from thread
     
    </strong>
    
     .
    
    
     On the other hand, if an exception were thrown and stored into the promise, it would be
    
    <a id="_idIndexMarker417">
    </a>
    
     rethrown and captured in the caller thread, and a line starting with
    
    <strong class="source-inline">
     
      Exception
     
    </strong>
    
     would be
    
    
     
      printed out.
     
    
   </p>
   <p>
    
     After calling the
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     method,
    
    <strong class="source-inline">
     
      valid()
     
    </strong>
    
     will return
    
    <strong class="source-inline">
     
      false
     
    </strong>
    
     .
    
    
     If for some reason
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     is called when
    
    <strong class="source-inline">
     
      valid()
     
    </strong>
    
     is
    
    <strong class="source-inline">
     
      false
     
    </strong>
    
     , the behavior is undefined, but the C++ standard recommends that a
    
    <strong class="source-inline">
     
      std::future_error
     
    </strong>
    
     exception is thrown with the
    
    <strong class="source-inline">
     
      std::future_errc::no_state
     
    </strong>
    
     error code.
    
    
     Futures in which the
    
    <strong class="source-inline">
     
      valid()
     
    </strong>
    
     function returns
    
    <strong class="source-inline">
     
      false
     
    </strong>
    
     can still
    
    
     
      be moved.
     
    
   </p>
   <p>
    
     When a future is destroyed, it releases its shared state reference.
    
    
     If that were the last reference, the shared state would be destroyed.
    
    
     These actions will not block unless in a specific case when using
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     , which we will learn about in
    
    <a href="B22219_07.xhtml#_idTextAnchor143">
     
      <em class="italic">
       
        Chapter 7
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <h3>
    
     Future errors and error codes
    
   </h3>
   <p>
    
     As we have seen in the preceding
    
    <a id="_idIndexMarker418">
    </a>
    
     examples, some functions that deal with asynchronous execution
    
    <a id="_idIndexMarker419">
    </a>
    
     and shared states can throw
    
    
     <strong class="source-inline">
      
       std::future_error
      
     </strong>
    
    
     
      exceptions.
     
    
   </p>
   <p>
    
     This exception class is inherited from
    
    <strong class="source-inline">
     
      std::logic_error
     
    </strong>
    
     , which in turn is inherited from
    
    <strong class="source-inline">
     
      std::exception
     
    </strong>
    
     , defined in the
    
    <strong class="source-inline">
     
      &lt;stdexcept&gt;
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      &lt;exception&gt;
     
    </strong>
    
     header
    
    
     
      files, respectively.
     
    
   </p>
   <p>
    
     As with any other exception defined in the STL, the error code can be checked by using its
    
    <strong class="source-inline">
     
      code()
     
    </strong>
    
     function or an explanatory string by using its
    
    
     <strong class="source-inline">
      
       what()
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     Error codes reported by futures are defined by
    
    <strong class="source-inline">
     
      std::future_errorc
     
    </strong>
    
     , a scoped enumeration (
    
    <strong class="source-inline">
     
      enum
     
    </strong>
    
     class).
    
    
     The C++ standard defines the following error codes, but the implementation may define
    
    
     
      additional ones:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       broken_promise
      
     </strong>
     
      : Reported when a promise is deleted before setting the result, so the shared state is released before
     
     
      
       being valid.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       future_already_retrieved
      
     </strong>
     
      : Occurring when
     
     <strong class="source-inline">
      
       std::promise::get_future()
      
     </strong>
     
      is called more
     
     
      
       than once.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       promise_already_satisfied
      
     </strong>
     
      : Reported by
     
     <strong class="source-inline">
      
       std::promise:: set_value()
      
     </strong>
     
      if the shared state already has a
     
     
      
       stored result.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       no_state
      
     </strong>
     
      : Reported when
     
     <a id="_idIndexMarker420">
     </a>
     
      some methods are used but there is no shared state as the promise
     
     <a id="_idIndexMarker421">
     </a>
     
      was created by using the default constructor or moved from.
     
     
      As we will see later in this chapter, this happens when calling some packaged tasks (
     
     <strong class="source-inline">
      
       std::packaged_task
      
     </strong>
     
      ) methods, such as
     
     <strong class="source-inline">
      
       get_future()
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       make_ready_at_thread_exit()
      
     </strong>
     
      , or
     
     <strong class="source-inline">
      
       reset()
      
     </strong>
     
      , when their shared state has not been created, or when using
     
     <strong class="source-inline">
      
       std::future::get()
      
     </strong>
     
      with a not-yet-ready future (
     
     <strong class="source-inline">
      
       std::future::valid()
      
     </strong>
     
      
       returns
      
     
     
      <strong class="source-inline">
       
        false
       
      </strong>
     
     
      
       ).
      
     
    </li>
   </ul>
   <h3>
    
     Waiting for results
    
   </h3>
   <p>
    <strong class="source-inline">
     
      std::future
     
    </strong>
    
     also
    
    <a id="_idIndexMarker422">
    </a>
    
     provides functions to block the thread and wait for a result to be available.
    
    
     These functions are
    
    <strong class="source-inline">
     
      wait()
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      wait_for()
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      wait_until()
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      wait()
     
    </strong>
    
     function will block indefinitely until the result is ready,
    
    <strong class="source-inline">
     
      wait_for()
     
    </strong>
    
     for a period, and
    
    <strong class="source-inline">
     
      wait_until()
     
    </strong>
    
     until a specific time has been reached.
    
    
     All will return as soon as the result is available within those
    
    
     
      waiting periods.
     
    
   </p>
   <p>
    
     These functions must be called only when
    
    <strong class="source-inline">
     
      valid()
     
    </strong>
    
     is
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     .
    
    
     Otherwise, the behavior is undefined but encouraged by the C++ standard to throw a
    
    <strong class="source-inline">
     
      std::future_error
     
    </strong>
    
     exception with the
    
    <strong class="source-inline">
     
      std::future_errc::no_state
     
    </strong>
    
     
      error code.
     
    
   </p>
   <p>
    
     As commented previously, using
    
    <strong class="source-inline">
     
      std::promise::set_value()
     
    </strong>
    
     without specifying a value sets the shared state as ready.
    
    
     This together with
    
    <strong class="source-inline">
     
      std::future::wait()
     
    </strong>
    
     can be used to implement a barrier and stop a thread from progressing until it is signaled.
    
    
     The following example shows this mechanism
    
    
     
      in action.
     
    
   </p>
   <p>
    
     Let’s start by adding the required
    
    
     
      header files:
     
    
   </p>
   <pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;sstream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
using namespace std::chrono_literals;</pre>
   <p>
    
     Inside the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function, the
    
    <a id="_idIndexMarker423">
    </a>
    
     program will start by creating two promises,
    
    <strong class="source-inline">
     
      numbers_promise
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      letters_promise
     
    </strong>
    
     , and their corresponding futures,
    
    <strong class="source-inline">
     
      numbers_ready
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       letters_ready
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
std::promise&lt;void&gt; numbers_promise, letters_promise;
auto numbers_ready = numbers_promise.get_future();
auto letter_ready = letters_promise.get_future();</pre>
   <p>
    
     Then, the
    
    <strong class="source-inline">
     
      input_data_thread
     
    </strong>
    
     emulates two I/O thread operations running in sequence, one copying numbers into a vector and another inserting letters into
    
    
     
      a set:
     
    
   </p>
   <pre class="source-code">
std::istringstream iss_numbers{"10 5 2 6 4 1 3 9 7 8"};
std::istringstream iss_letters{"A b 53 C,d 83D 4B ca"};
std::vector&lt;int&gt; numbers;
std::set&lt;char&gt; letters;
std::jthread input_data_thread([&amp;] {
    // Step 1: Emulating I/O operations.
    std::copy(std::istream_iterator&lt;int&gt;{iss_numbers},
              std::istream_iterator&lt;int&gt;{},
              std::back_inserter(numbers));
    // Notify completion of Step 1.
    numbers_promise.set_value();
    // Step 2: Emulating further I/O operations.
    std::copy_if(std::istreambuf_iterator&lt;char&gt;
                               {iss_letters},
                   std::istreambuf_iterator&lt;char&gt;{},
                   std::inserter(letters,
                               letters.end()),
                               ::isalpha);
    // Notify completion of Step 2.
    letters_promise.set_value();
});
// Wait for numbers vector to be filled.
numbers_ready.wait();</pre>
   <p>
    
     While this is happening, the main
    
    <a id="_idIndexMarker424">
    </a>
    
     thread stops its execution by using
    
    <strong class="source-inline">
     
      numbers_ready.wait()
     
    </strong>
    
     , waiting for the counterpart promise,
    
    <strong class="source-inline">
     
      numbers_promise
     
    </strong>
    
     , to be ready.
    
    
     Once all numbers are read,
    
    <strong class="source-inline">
     
      input_data_thread
     
    </strong>
    
     will call
    
    <strong class="source-inline">
     
      numbers_promise.set_value()
     
    </strong>
    
     , waking up the main thread and continuing
    
    
     
      its execution.
     
    
   </p>
   <p>
    
     Numbers will then be sorted and printed if letters have not already been read by using the
    
    <strong class="source-inline">
     
      wait_for()
     
    </strong>
    
     function from the
    
    <strong class="source-inline">
     
      letters_ready
     
    </strong>
    
     future and checking whether it
    
    
     
      timed out:
     
    
   </p>
   <pre class="source-code">
std::sort(numbers.begin(), numbers.end());
if (letter_ready.wait_for(1s) == std::future_status::timeout) {
    for (int num : numbers) std::cout &lt;&lt; num &lt;&lt; ' ';
    numbers.clear();
}
// Wait for letters vector to be filled.
letter_ready.wait();</pre>
   <p>
    
     This section of the code shows
    
    <a id="_idIndexMarker425">
    </a>
    
     how the main thread can do some work.
    
    
     Meanwhile,
    
    <strong class="source-inline">
     
      input_data_thread
     
    </strong>
    
     continues processing incoming data.
    
    
     Then, the main thread will wait again by
    
    
     
      calling
     
    
    
     <strong class="source-inline">
      
       letters_ready.wait()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Finally, when all letters are added to the set, the main thread will wake up by being signaled again by using
    
    <strong class="source-inline">
     
      letters_promise.set_value()
     
    </strong>
    
     , and numbers (if not yet printed) and letters will be printed
    
    
     
      in order:
     
    
   </p>
   <pre class="source-code">
for (int num : numbers) std::cout &lt;&lt; num &lt;&lt; ' ';
std::cout &lt;&lt; std::endl;
for (char let : letters) std::cout &lt;&lt; let &lt;&lt; ' ';
std::cout &lt;&lt; std::endl;</pre>
   <p>
    
     As we have seen in the previous example, a future status object is returned by the wait functions.
    
    
     Next, let’s learn what these
    
    
     
      objects are.
     
    
   </p>
   <h3>
    
     Future status
    
   </h3>
   <p>
    <strong class="source-inline">
     
      wait_for()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      wait_until()
     
    </strong>
    
     return a
    
    
     <strong class="source-inline">
      
       std::future_status
      
     </strong>
    
    
     
      object.
     
    
   </p>
   <p>
    
     A future can be in any of the
    
    
     
      following
     
    
    
     <a id="_idIndexMarker426">
     </a>
    
    
     
      statuses:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Ready
      
     </strong>
     
      : The shared state is
     
     <strong class="bold">
      
       ready
      
     </strong>
     
      , indicating
     
     <a id="_idIndexMarker427">
     </a>
     
      that the result can
     
     
      
       be retrieved.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Deferred
      
     </strong>
     
      : The shared state contains a
     
     <strong class="bold">
      
       deferred
      
     </strong>
     
      function, meaning that the result will only be computed
     
     <a id="_idIndexMarker428">
     </a>
     
      when explicitly requested.
     
     
      We will learn more about deferred functions in the next chapter when
     
     
      
       introducing
      
     
     
      <strong class="source-inline">
       
        std::async
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       Timeout
      
     </strong>
     
      : The specified
     
     <strong class="bold">
      
       timeout period
      
     </strong>
     
      passed
     
     <a id="_idIndexMarker429">
     </a>
     
      before the shared state could
     
     
      
       become ready.
      
     
    </li>
   </ul>
   <p>
    
     Next, we will learn how to share a promise result among multiple futures by using
    
    
     
      shared futures.
     
    
   </p>
   <h2 id="_idParaDest-132">
    <a id="_idTextAnchor131">
    </a>
    
     Shared futures
    
   </h2>
   <p>
    
     As we saw earlier,
    
    <strong class="source-inline">
     
      std::future
     
    </strong>
    
     is only
    
    <a id="_idIndexMarker430">
    </a>
    
     moveable, thus only one future object can refer to a particular asynchronous result.
    
    
     On the other hand,
    
    <strong class="source-inline">
     
      std::shared_future
     
    </strong>
    
     is copyable, so several shared future objects can refer to the same
    
    
     
      shared state.
     
    
   </p>
   <p>
    
     Therefore,
    
    <strong class="source-inline">
     
      std::shared_future
     
    </strong>
    
     allows thread-safe access from different threads to the same shared state.
    
    
     Shared futures can be useful for sharing the result of a computationally intensive task among multiple consumers or interested parties, reducing redundant computation.
    
    
     Also, they can be used to notify events or as a synchronization mechanism where multiple threads must wait for the completion of a single task.
    
    
     Later in this chapter, we will learn how to chain asynchronous operations by using
    
    
     
      shared futures.
     
    
   </p>
   <p>
    
     The interface of
    
    <strong class="source-inline">
     
      std:;shared_object
     
    </strong>
    
     is the same as the one for
    
    <strong class="source-inline">
     
      std::future
     
    </strong>
    
     , so everything explained about waiting and getter functions
    
    
     
      applies here.
     
    
   </p>
   <p>
    
     A shared object can be created by using the
    
    
     <strong class="source-inline">
      
       std::future::share()
      
     </strong>
    
    
     
      function:
     
    
   </p>
   <pre class="source-code">
std::shared_future&lt;int&gt; shared_fut = fut.share();</pre>
   <p>
    
     That invalidates the original future (its
    
    <strong class="source-inline">
     
      valid()
     
    </strong>
    
     function will
    
    
     
      return
     
    
    
     <strong class="source-inline">
      
       false
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    
     The following example shows how to send the same result to many threads at the
    
    
     
      same time:
     
    
   </p>
   <pre class="source-code">
#define sync_cout std::osyncstream(std::cout)
int main() {
    std::promise&lt;int&gt; prom;
    std::future&lt;int&gt; fut = prom.get_future();
    std::shared_future&lt;int&gt; shared_fut = fut.share();
    std::vector&lt;std::jthread&gt; threads;
    for (int i = 1; i &lt;= 5; ++i) {
        threads.emplace_back([shared_fut, i]() {
            sync_cout &lt;&lt; "Thread " &lt;&lt; i &lt;&lt; ": Result = "
                      &lt;&lt; shared_fut.get() &lt;&lt; std::endl;
        });
    }
    prom.set_value(5);
    return 0;
}</pre>
   <p>
    
     We start by creating a promise,
    
    <strong class="source-inline">
     
      prom
     
    </strong>
    
     , getting the future,
    
    <strong class="source-inline">
     
      fut
     
    </strong>
    
     , from it, and finally, getting a shared future,
    
    <strong class="source-inline">
     
      shared_fut
     
    </strong>
    
     , by
    
    
     
      calling
     
    
    
     <strong class="source-inline">
      
       share()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Then, five threads are
    
    <a id="_idIndexMarker431">
    </a>
    
     created and added to a vector, each one having a shared future instance and an index.
    
    
     All these threads will be waiting for the promise,
    
    <strong class="source-inline">
     
      prom
     
    </strong>
    
     , to be ready by calling
    
    <strong class="source-inline">
     
      shared_future.get()
     
    </strong>
    
     .
    
    
     When a value is set in the promise shared state, the value will be accessible by all the threads.
    
    
     The output of running the previous program is
    
    
     
      the following:
     
    
   </p>
   <pre class="console">
Thread 5: Result = 5
Thread 3: Result = 5
Thread 4: Result = 5
Thread 2: Result = 5
Thread 1: Result = 5</pre>
   <p>
    
     Therefore, shared futures can also be used to signal multiple threads at the
    
    
     
      same time.
     
    
   </p>
   <h2 id="_idParaDest-133">
    <a id="_idTextAnchor132">
    </a>
    
     Packaged tasks
    
   </h2>
   <p>
    
     A
    
    <strong class="bold">
     
      packaged task
     
    </strong>
    
     , or
    
    <strong class="source-inline">
     
      std::packaged_task
     
    </strong>
    
     , also defined in the
    
    <strong class="source-inline">
     
      &lt;future&gt;
     
    </strong>
    
     header file, is a class template that wraps
    
    <a id="_idIndexMarker432">
    </a>
    
     a callable object to be invoked asynchronously.
    
    
     Its result is stored in a shared state, which is accessible through a
    
    <strong class="source-inline">
     
      std::future
     
    </strong>
    
     object.
    
    
     To create a
    
    <strong class="source-inline">
     
      std::packaged_task
     
    </strong>
    
     object, we need to define as the template parameter the function signature that represents the task that will be called and pass the desired function as its constructor argument.
    
    
     Here are
    
    
     
      some examples:
     
    
   </p>
   <pre class="source-code">
// Using a thread.
std::packaged_task&lt;int(int, int)&gt; task1(
                      std::pow&lt;int, int&gt;);
std::jthread t(std::move(task1), 2, 10);
// Using a lambda function.
std::packaged_task&lt;int(int, int)&gt; task2([](int a, int b)
{
    return std::pow(a, b);
});
task2(2, 10);
// Binding to a function.
std::packaged_task&lt;int()&gt; task3(std::bind(std::pow&lt;int, int&gt;, 2, 10));
task3();</pre>
   <p>
    
     In the preceding example,
    
    <strong class="source-inline">
     
      task1
     
    </strong>
    
     is created by using a function and executed by using a thread.
    
    
     On the other hand,
    
    <strong class="source-inline">
     
      task2
     
    </strong>
    
     is created by using a lambda function and executed by invoking its method
    
    <strong class="source-inline">
     
      operator()
     
    </strong>
    
     .
    
    
     Finally,
    
    <strong class="source-inline">
     
      task3
     
    </strong>
    
     is created by using a forwarding call wrapper by
    
    
     
      using
     
    
    
     <strong class="source-inline">
      
       std::bind
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     To retrieve the future associated with a task, just call
    
    <strong class="source-inline">
     
      get_future()
     
    </strong>
    
     from its
    
    
     <strong class="source-inline">
      
       packaged_task
      
     </strong>
    
    
     
      object:
     
    
   </p>
   <pre class="source-code">
std::future&lt;int&gt; result = task1.get_future();</pre>
   <p>
    
     As with promises and futures, packaged tasks can be constructed with no shared state by using the default constructor, the move constructor, or allocators.
    
    
     Packaged tasks are thus move-only and non-copyable.
    
    
     Also, assignment operators and the swap function have similar behaviors
    
    <a id="_idIndexMarker433">
    </a>
    
     as promises
    
    
     
      and futures.
     
    
   </p>
   <p>
    
     The destructor of packaged tasks behaves like the promise destructors; if the shared state is released before being valid, a
    
    <strong class="source-inline">
     
      std::future_error
     
    </strong>
    
     exception will be thrown with the
    
    <strong class="source-inline">
     
      std::future_errc::broken_promise
     
    </strong>
    
     error code.
    
    
     As with futures, packaged tasks define a
    
    <strong class="source-inline">
     
      valid()
     
    </strong>
    
     that function returns
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     if a
    
    <strong class="source-inline">
     
      std::packaged_task
     
    </strong>
    
     object has a
    
    
     
      shared state.
     
    
   </p>
   <p>
    
     As with promises,
    
    <strong class="source-inline">
     
      get_future()
     
    </strong>
    
     can only be called once.
    
    
     If this function is called more than once, a
    
    <strong class="source-inline">
     
      std::future_error
     
    </strong>
    
     exception with the
    
    <strong class="source-inline">
     
      future_already_retrieved
     
    </strong>
    
     code will be thrown.
    
    
     If the packaged tasks were created from the default constructor, thus with no shared state, the error code will
    
    
     
      be
     
    
    
     <strong class="source-inline">
      
       no_state
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     As seen in the previous example, the stored callable object can be invoked by
    
    
     
      using
     
    
    
     <strong class="source-inline">
      
       operator()
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
task1(2, 10);</pre>
   <p>
    
     Sometimes, it’s interesting to make the result ready only when the thread that runs the packaged task exits and all its
    
    <strong class="bold">
     
      thread-local
     
    </strong>
    
     objects are
    
    <a id="_idIndexMarker434">
    </a>
    
     destroyed.
    
    
     This is achieved by using the
    
    <strong class="source-inline">
     
      make_ready_at_thread_exit()
     
    </strong>
    
     function.
    
    
     Even if the result is not ready until the thread exits, it is computed right away as usual.
    
    
     Therefore, its computation is
    
    
     
      not deferred.
     
    
   </p>
   <p>
    
     As an example, let’s define the
    
    
     
      following function:
     
    
   </p>
   <pre class="source-code">
void task_func(std::future&lt;void&gt;&amp; output) {
    std::packaged_task&lt;void(bool&amp;)&gt; task{[](bool&amp; done){
        done = true;
    }};
    auto result = task.get_future();
    bool done = false;
    task.make_ready_at_thread_exit(done);
    std::cout &lt;&lt; "task_func: done = "
              &lt;&lt; std::boolalpha &lt;&lt; done &lt;&lt; std::endl;
    auto status = result.wait_for(0s);
    if (status == std::future_status::timeout)
        std::cout &lt;&lt; "task_func: result not ready\n";
    output = std::move(result);
}</pre>
   <p>
    
     This function creates a packaged task called
    
    <strong class="source-inline">
     
      task
     
    </strong>
    
     that sets its Boolean argument to
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     .
    
    
     A future called
    
    <strong class="source-inline">
     
      result
     
    </strong>
    
     is also created from this task.
    
    
     When the task is executed by calling
    
    <strong class="source-inline">
     
      make_ready_at_thread_exit()
     
    </strong>
    
     , its
    
    <strong class="source-inline">
     
      done
     
    </strong>
    
     argument is set to
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     but the future result is still not marked as ready.
    
    
     When the
    
    <strong class="source-inline">
     
      task_func
     
    </strong>
    
     function exits, the
    
    <strong class="source-inline">
     
      result
     
    </strong>
    
     future is
    
    <a id="_idIndexMarker435">
    </a>
    
     moved to the passed-by reference.
    
    
     At this point, the thread exits, and the
    
    <strong class="source-inline">
     
      result
     
    </strong>
    
     future will be set
    
    
     
      as ready.
     
    
   </p>
   <p>
    
     Therefore, say we call this task from the main thread by using the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
std::future&lt;void&gt; result;
std::thread t{task_func, std::ref(result)};
t.join();
auto status = result.wait_for(0s);
if (status == std::future_status::ready)
    std::cout &lt;&lt; «main: result ready\n»;</pre>
   <p>
    
     The program will show the
    
    
     
      following output:
     
    
   </p>
   <pre class="console">
task_func: done = true
task_func: result not ready
main: result ready</pre>
   <p>
    <strong class="source-inline">
     
      make_ready_at_thread_exit()
     
    </strong>
    
     will throw
    
    <strong class="source-inline">
     
      std::future_error
     
    </strong>
    
     exceptions if there is no shared state (the
    
    <strong class="source-inline">
     
      no_state
     
    </strong>
    
     error code) or the task has already been invoked (the
    
    <strong class="source-inline">
     
      promise_already_satisfied
     
    </strong>
    
     
      error code).
     
    
   </p>
   <p>
    
     A packaged task state can also be reset by calling
    
    <strong class="source-inline">
     
      reset()
     
    </strong>
    
     .
    
    
     This function will abandon the current state and construct a new shared state.
    
    
     Obviously, if there is no state when calling
    
    <strong class="source-inline">
     
      reset()
     
    </strong>
    
     , an exception with the
    
    <strong class="source-inline">
     
      no_state
     
    </strong>
    
     error code will be thrown.
    
    
     After resetting, a new future must be acquired by
    
    
     
      calling
     
    
    
     <strong class="source-inline">
      
       get_future()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The following example
    
    <a id="_idIndexMarker436">
    </a>
    
     prints the first 10 power-of-two numbers.
    
    
     Each number is computed by calling the same
    
    <strong class="source-inline">
     
      packaged_task
     
    </strong>
    
     object.
    
    
     In each loop iteration,
    
    <strong class="source-inline">
     
      packaged_task
     
    </strong>
    
     is reset, and a new future object
    
    
     
      is retrieved:
     
    
   </p>
   <pre class="source-code">
std::packaged_task&lt;int(int, int)&gt; task([](int a, int b){
    return std::pow(a, b);
});
for (int i=1; i&lt;=10; ++i) {
    std::future&lt;int&gt; result = task.get_future();
    task(2, i);
    std::cout &lt;&lt; "2^" &lt;&lt; i &lt;&lt; " = "
              &lt;&lt; result.get() &lt;&lt; std::endl;
    task.reset();
}</pre>
   <p>
    
     This is the output when executing the
    
    
     
      preceding code:
     
    
   </p>
   <pre class="console">
2^1 = 2
2^2 = 4
2^3 = 8
2^4 = 16
2^5 = 32
2^6 = 64
2^7 = 128
2^8 = 256
2^9 = 512
2^10 = 1024</pre>
   <p>
    
     As we will learn in the next chapter,
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     provides a simpler way to achieve the same result.
    
    
     The only advantage of
    
    <strong class="source-inline">
     
      std::packaged_task
     
    </strong>
    
     is the ability to specify in exactly which thread the task
    
    
     
      will run.
     
    
   </p>
   <p>
    
     Now that we know
    
    <a id="_idIndexMarker437">
    </a>
    
     how to use promises, futures, and packaged tasks, it’s time to understand not only the upsides of this approach but also what downsides
    
    
     
      can arise.
     
    
   </p>
   <h1 id="_idParaDest-134">
    <a id="_idTextAnchor133">
    </a>
    
     The benefits and drawbacks of promises and futures
    
   </h1>
   <p>
    
     There are advantages as well as some disadvantages of using promises and futures.
    
    
     Here are the
    
    
     
      main points.
     
    
   </p>
   <h2 id="_idParaDest-135">
    <a id="_idTextAnchor134">
    </a>
    
     Benefits
    
   </h2>
   <p>
    
     As high-level abstractions for
    
    <a id="_idIndexMarker438">
    </a>
    
     managing asynchronous operations, writing and
    
    <a id="_idIndexMarker439">
    </a>
    
     reasoning about concurrent code by using promises and futures is simplified and
    
    
     
      less error-prone.
     
    
   </p>
   <p>
    
     Futures and promises enable concurrent execution of tasks, allowing the program to use multiple CPU cores efficiently.
    
    
     This can lead to improved performance and reduced execution time for computationally
    
    
     
      intensive tasks.
     
    
   </p>
   <p>
    
     Also, they facilitate asynchronous programming by decoupling the initiation of an operation from its completion.
    
    
     As we will see later, this is particularly useful for I/O-bound tasks, such as network requests or file operations, where the program can continue executing other tasks while waiting for the asynchronous operation to complete.
    
    
     As a result, they can return a value but also an exception, allowing exception propagation from the asynchronous tasks to the caller code section that waits for their completion, which allows for a cleaner way for error handling
    
    
     
      and recovery.
     
    
   </p>
   <p>
    
     As we have also
    
    <a id="_idIndexMarker440">
    </a>
    
     mentioned, they also provide a mechanism for synchronizing the completion
    
    <a id="_idIndexMarker441">
    </a>
    
     of tasks and retrieving their results.
    
    
     This helps in coordinating parallel tasks and managing dependencies
    
    
     
      between them.
     
    
   </p>
   <h2 id="_idParaDest-136">
    <a id="_idTextAnchor135">
    </a>
    
     Drawbacks
    
   </h2>
   <p>
    
     Unfortunately, not everything is positive news; there are also some areas that
    
    
     
      are impacted.
     
    
   </p>
   <p>
    
     For example, asynchronous
    
    <a id="_idIndexMarker442">
    </a>
    
     programming with futures and promises can introduce complexity when dealing with dependencies between tasks or managing the life cycle of asynchronous operations.
    
    
     Also, potential deadlocks can happen if there are
    
    
     
      circular dependencies.
     
    
   </p>
   <p>
    
     Likewise, using futures and promises may introduce some performance overhead due to the synchronization mechanisms happening under the hood, involved in coordinating asynchronous tasks and managing
    
    
     
      shared states.
     
    
   </p>
   <p>
    
     As with other concurrent or asynchronous solutions, debugging code that uses futures and promises can be more challenging compared to synchronous code, as the flow of execution may be non-linear and involve
    
    
     
      multiple threads.
     
    
   </p>
   <p>
    
     Now it’s time to tackle real-life scenarios by implementing
    
    
     
      some examples.
     
    
   </p>
   <h1 id="_idParaDest-137">
    <a id="_idTextAnchor136">
    </a>
    
     Examples of real-life scenarios and solutions
    
   </h1>
   <p>
    
     Now that we’ve learned
    
    <a id="_idIndexMarker443">
    </a>
    
     about some new building blocks of creating asynchronous programs, let’s build solutions for some real-life scenarios.
    
    
     In this section, we will learn how to do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Cancel
     
     
      
       asynchronous operation
      
     
    </li>
    <li>
     
      Return
     
     
      
       combined results
      
     
    </li>
    <li>
     
      Chain asynchronous operations and create
     
     
      
       a pipeline
      
     
    </li>
    <li>
     
      Create a
     
     <a id="_idIndexMarker444">
     </a>
     
      thread-safe
     
     <strong class="bold">
      
       single-producer-single-consumer
      
     </strong>
     
      (
     
     <strong class="bold">
      
       SPSC
      
     </strong>
     
      )
     
     
      
       task queue
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-138">
    <a id="_idTextAnchor137">
    </a>
    
     Canceling asynchronous operations
    
   </h2>
   <p>
    
     As we saw earlier, futures offer the ability to check for completion or timeout before waiting for the result.
    
    
     That
    
    <a id="_idIndexMarker445">
    </a>
    
     can be done by checking the
    
    <strong class="source-inline">
     
      std::future_status
     
    </strong>
    
     object returned by the
    
    <strong class="source-inline">
     
      std::future
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      wait_for()
     
    </strong>
    
     , or
    
    
     <strong class="source-inline">
      
       wait_until()
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     By combining futures with mechanisms such as cancellation flags (by means of
    
    <strong class="source-inline">
     
      std::atomic_bool
     
    </strong>
    
     ) or timeouts, we can gracefully terminate long-running tasks if necessary.
    
    
     Timeout cancellation can be implemented by simply using the
    
    <strong class="source-inline">
     
      wait_for()
     
    </strong>
    
     and
    
    
     <strong class="source-inline">
      
       wait_until()
      
     </strong>
    
    
     
      functions.
     
    
   </p>
   <p>
    
     Canceling a task by using a cancellation flag or token can be implemented by passing a reference to a cancellation flag defined as
    
    <strong class="source-inline">
     
      std::atomic_bool
     
    </strong>
    
     , where the caller thread sets its value to
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     to request the task cancellation, and the worker thread periodically checks this flag and whether it’s set.
    
    
     If it is set, it exits gracefully and performs any cleanup work to
    
    
     
      be done.
     
    
   </p>
   <p>
    
     Let’s first define a long-running
    
    
     
      task function:
     
    
   </p>
   <pre class="source-code">
const int CHECK_PERIOD_MS = 100;
bool long_running_task(int ms,
            const std::atomic_bool&amp; cancellation_token) {
    while (ms &gt; 0 &amp;&amp; !cancellation_token) {
        ms -= CHECK_PERIOD_MS;
        std::this_thrsead::sleep_for(100ms);
    }
    return cancellation_token;
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      long_running_task
     
    </strong>
    
     function accepts as arguments a period in milliseconds (
    
    <strong class="source-inline">
     
      ms
     
    </strong>
    
     ) to run the task and a reference to an atomic Boolean value (
    
    <strong class="source-inline">
     
      cancellation_token
     
    </strong>
    
     ) representing the cancellation token.
    
    
     The function will periodically check whether the cancellation token is set to
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     .
    
    
     When the running period passes or the cancellation token is set to
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     , the thread
    
    
     
      will exit.
     
    
   </p>
   <p>
    
     In the main thread, we can
    
    <a id="_idIndexMarker446">
    </a>
    
     use two
    
    <strong class="source-inline">
     
      packaged task objects
     
    </strong>
    
     to execute this function, that is,
    
    <strong class="source-inline">
     
      task1
     
    </strong>
    
     lasting for 500 ms and running in thread
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      task2
     
    </strong>
    
     running for one second in thread
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     .
    
    
     Both share the same
    
    
     
      cancellation token:
     
    
   </p>
   <pre class="source-code">
std::atomic_bool cancellation_token{false};
std::cout &lt;&lt; "Starting long running tasks...\n";
std::packaged_task&lt;bool(int, const std::atomic_bool&amp;)&gt;
                task1(long_running_task);
std::future&lt;bool&gt; result1 = task1.get_future();
std::jthread t1(std::move(task1), 500,
                std::ref(cancellation_token));
std::packaged_task&lt;bool(int, const std::atomic_bool&amp;)&gt;
                task2(long_running_task);
std::future&lt;bool&gt; result2 = task2.get_future();
std::jthread t2(std::move(task2), 1000,
                std::ref(cancellation_token));
std::cout &lt;&lt; "Cancelling tasks after 600 ms...\n";
this_thread::sleep_for(600ms);
cancellation_token = true;
std::cout &lt;&lt; "Task1, waiting for 500 ms. Cancelled = "
          &lt;&lt; std::boolalpha &lt;&lt; result1.get() &lt;&lt; "\n";
std::cout &lt;&lt; "Task2, waiting for 1 second. Cancelled = "
          &lt;&lt; std::boolalpha &lt;&lt; result2.get() &lt;&lt; "\n";</pre>
   <p>
    
     After both tasks have started, the main thread sleeps for 600 ms.
    
    
     When it wakes up, it sets the cancellation
    
    <a id="_idIndexMarker447">
    </a>
    
     token to
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     .
    
    
     At that time,
    
    <strong class="source-inline">
     
      task1
     
    </strong>
    
     was already finished, but
    
    <strong class="source-inline">
     
      task2
     
    </strong>
    
     was still running.
    
    
     Thus,
    
    <strong class="source-inline">
     
      task2
     
    </strong>
    
     is
    
    
     
      being cancelled.
     
    
   </p>
   <p>
    
     This explanation aligns with the
    
    
     
      obtained output:
     
    
   </p>
   <pre class="console">
Starting long running tasks...
Cancelling tasks after 600 ms...
Task1, waiting for 500 ms. Cancelled = false
Task2, waiting for 1 second. Cancelled = true</pre>
   <p>
    
     Next, let’s see how to combine several asynchronous computation results into a
    
    
     
      single future.
     
    
   </p>
   <h2 id="_idParaDest-139">
    <a id="_idTextAnchor138">
    </a>
    
     Returning combined results
    
   </h2>
   <p>
    
     Another common approach in asynchronous programming is to decompose complex tasks into smaller independent subtasks using multiple promises and futures.
    
    
     Each subtask can be launched in a
    
    <a id="_idIndexMarker448">
    </a>
    
     separate thread and its result stored in a corresponding promise.
    
    
     The main thread can then use the futures to wait for all subtasks to finish and combine their results to obtain
    
    
     
      the outcome.
     
    
   </p>
   <p>
    
     This approach is useful to achieve parallel processing of multiple independent tasks, allowing the efficient utilization of multiple cores for
    
    
     
      faster computations.
     
    
   </p>
   <p>
    
     Let’s see an example of a task that emulates a value computation and an I/O operation.
    
    
     We want that task to return a tuple with both results, the computed value as an
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     value, and the information read from the file as a
    
    <strong class="source-inline">
     
      string
     
    </strong>
    
     object.
    
    
     So, we define the
    
    <strong class="source-inline">
     
      combineFunc
     
    </strong>
    
     function that accepts as an argument a
    
    <strong class="source-inline">
     
      combineProm
     
    </strong>
    
     promise holding a tuple with the
    
    
     
      result types.
     
    
   </p>
   <p>
    
     This function will create two
    
    <a id="_idIndexMarker449">
    </a>
    
     threads,
    
    <strong class="source-inline">
     
      computeThread
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      fetchData
     
    </strong>
    
     , with their respective promises,
    
    <strong class="source-inline">
     
      computeProm
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      fetchProm
     
    </strong>
    
     , and futures,
    
    <strong class="source-inline">
     
      computeFut
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       fetchFut
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
void combineFunc(std::promise&lt;std::tuple&lt;int,
                 std::string&gt;&gt; combineProm) {
    try {
        // Thread to simulate computing a value.
        std::cout &lt;&lt; "Starting computeThread...\n";
        auto computeVal = [](std::promise&lt;int&gt; prom)
                            mutable {
            std::this_thread::sleep_for(1s);
            prom.set_value(42);
        };
        std::promise&lt;int&gt; computeProm;
        auto computeFut = computeProm.get_future();
        std::jthread computeThread(computeVal,
                              std::move(computeProm));
        // Thread to simulate downloading a file.
        std::cout &lt;&lt; "Starting dataThread...\n";
        auto fetchData = [](
                 std::promise&lt;std::string&gt; prom) mutable {
            std::this_thread::sleep_for(2s);
            prom.set_value("data.txt");
        };
        std::promise&lt;std::string&gt; fetchProm;
        auto fetchFut = fetchProm.get_future();
        std::jthread dataThread(fetchData,
                                std::move(fetchProm));
        combineProm.set_value({
                    computeFut.get(),
                    fetchFut.get()
        });
    } catch (...) {
        combineProm.set_exception(
                    std::current_exception());
    }
}</pre>
   <p>
    
     As we can see, both threads will execute asynchronously and independently, generating a result and storing it in
    
    <a id="_idIndexMarker450">
    </a>
    
     their
    
    
     
      respective promises.
     
    
   </p>
   <p>
    
     The combined promise is set by calling the
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     function on each future and combining their result into a tuple that is used to set the value of the combined promise by calling its
    
    <strong class="source-inline">
     
      set_value()
     
    </strong>
    
     function,
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
combineProm.set_value({computeFut.get(), fetchFut.get()});</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      combineFunc
     
    </strong>
    
     task can be called as usual by using a thread and setting up the
    
    <strong class="source-inline">
     
      combineProm
     
    </strong>
    
     promise and its
    
    <strong class="source-inline">
     
      combineFut
     
    </strong>
    
     future.
    
    
     Calling the
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     function on this future will return
    
    
     
      a tuple:
     
    
   </p>
   <pre class="source-code">
std::promise&lt;std::tuple&lt;int, std::string&gt;&gt; combineProm;
auto combineFuture = combineProm.get_future();
std::jthread combineThread(combineFunc,
                           std::move(combineProm));
auto [data, file] = combineFuture.get();
std::cout &lt;&lt; "Value [ " &lt;&lt; data
          &lt;&lt; " ]  File [ « &lt;&lt; file &lt;&lt; « ]\n»;</pre>
   <p>
    
     Running this example
    
    <a id="_idIndexMarker451">
    </a>
    
     will show the
    
    
     
      following result:
     
    
   </p>
   <pre class="console">
Creating combined promise...
Starting computeThread...
Starting dataThread...
Value [ 42 ]  File [ data.txt ]</pre>
   <p>
    
     Now, let’s continue by learning how to create a pipeline using promises
    
    
     
      and futures.
     
    
   </p>
   <h2 id="_idParaDest-140">
    <a id="_idTextAnchor139">
    </a>
    
     Chaining asynchronous operations
    
   </h2>
   <p>
    
     Promises and futures can be chained together to perform multiple asynchronous operations sequentially.
    
    
     We can create a pipeline where one future’s result becomes the input for the next
    
    <a id="_idIndexMarker452">
    </a>
    
     operation’s promise.
    
    
     This allows for composing complex asynchronous workflows where the output of one task feeds into
    
    
     
      the next.
     
    
   </p>
   <p>
    
     Also, we can allow branching in the pipeline and keep some tasks switched off until needed.
    
    
     This can be done by using futures with deferred execution, which is useful in scenarios where the computation cost is high, but the result may not always be needed.
    
    
     Thus, we can use futures to initiate the computation asynchronously and retrieve the result only when required.
    
    
     As futures with deferred status can only be created by using
    
    <strong class="source-inline">
     
      std::async
     
    </strong>
    
     , we will leave that for the
    
    
     
      next chapter.
     
    
   </p>
   <p>
    
     In this section, we will focus on creating the following
    
    
     
      task graph:
     
    
   </p>
   <div><div><img alt="Figure 6.3 – A pipeline example" src="img/B22219_06_03.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.3 – A pipeline example
    
   </p>
   <p>
    
     We start by defining a template class called
    
    <strong class="source-inline">
     
      Task
     
    </strong>
    
     that accepts a callable as a template argument, defining the
    
    <a id="_idIndexMarker453">
    </a>
    
     function to execute.
    
    
     This class will also allow us to create tasks that share a future with dependent ones.
    
    
     These will use the shared futures to wait for the predecessor tasks to signal them about their completion by calling
    
    <strong class="source-inline">
     
      set_value()
     
    </strong>
    
     in the associated promise before running their
    
    
     
      own task:
     
    
   </p>
   <pre class="source-code">
#define sync_cout std::osyncstream(std::cout)
template &lt;typename Func&gt;
class Task {
   public:
    Task(int id, Func&amp; func)
        : id_(id), func_(func), has_dependency_(false) {
        sync_cout &lt;&lt; "Task " &lt;&lt; id
                 &lt;&lt; " constructed without dependencies.\n";
        fut_ = prom_.get_future().share();
    }
    template &lt;typename... Futures&gt;
    Task(int id, Func&amp; func, Futures&amp;&amp;... futures)
        : id_(id), func_(func), has_dependency_(true) {
        sync_cout &lt;&lt; "Task " &lt;&lt; id
                  &lt;&lt; « constructed with dependencies.\n";
        fut_ = prom_.get_future().share();
        add_dependencies(
                  std::forward&lt;Futures&gt;(futures)...);
    }
    std::shared_future&lt;void&gt; get_dependency() {
        return fut_;
    }
    void operator()() {
        sync_cout &lt;&lt; "Running task " &lt;&lt; id_ &lt;&lt; '\n';
        wait_completion();
        func_();
        sync_cout &lt;&lt; "Signaling completion of task "
                  &lt;&lt; id_ &lt;&lt; ‹\n';
        prom_.set_value();
    }
   private:
    template &lt;typename... Futures&gt;
    void add_dependencies(Futures&amp;&amp;... futures) {
        (deps_.push_back(futures), ...);
    }
    void wait_completion() {
        sync_cout &lt;&lt; "Waiting completion for task "
                  &lt;&lt; id_ &lt;&lt; ‹\n';
        if (!deps_.empty()) {
            for (auto&amp; fut : deps_) {
                if (fut.valid()) {
                    sync_cout &lt;&lt; "Fut valid so getting "
                              &lt;&lt; "value in task "
                              &lt;&lt; id_ &lt;&lt; ‹\n';
                    fut.get();
                }
            }
        }
    }
   private:
    int id_;
    Func&amp; func_;
    std::promise&lt;void&gt; prom_;
    std::shared_future&lt;void&gt; fut_;
    std::vector&lt;std::shared_future&lt;void&gt;&gt; deps_;
    bool has_dependency_;
};</pre>
   <p>
    
     Let’s describe step by step how this
    
    <strong class="source-inline">
     
      Task
     
    </strong>
    
     class
    
    
     
      is implemented.
     
    
   </p>
   <p>
    
     There are two constructors: one to initialize an object of type
    
    <strong class="source-inline">
     
      Task
     
    </strong>
    
     that has no dependencies with other tasks and another templated constructor to initialize a task with a variable number of dependent tasks.
    
    
     Both initialize an identifier (
    
    <strong class="source-inline">
     
      id_
     
    </strong>
    
     ), the function to call to perform the task (
    
    <strong class="source-inline">
     
      func_
     
    </strong>
    
     ), a Boolean variable indicating whether the task has dependencies or
    
    <a id="_idIndexMarker454">
    </a>
    
     not (
    
    <strong class="source-inline">
     
      has_dependency_
     
    </strong>
    
     ), and a shared future,
    
    <strong class="source-inline">
     
      fut_
     
    </strong>
    
     , to share with tasks that will depend on this one.
    
    
     This
    
    <strong class="source-inline">
     
      fut_
     
    </strong>
    
     future is retrieved from the
    
    <strong class="source-inline">
     
      prom_
     
    </strong>
    
     promise used to signal the task completion.
    
    
     The templated constructor also calls the
    
    <strong class="source-inline">
     
      add_dependencies
     
    </strong>
    
     function forwarding the futures passed as arguments, which will be stored in the
    
    
     <strong class="source-inline">
      
       deps_
      
     </strong>
    
    
     
      vector.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      get_dependency()
     
    </strong>
    
     function just returns the shared future used by dependent tasks to wait for the completion of the
    
    
     
      current task.
     
    
   </p>
   <p>
    
     Finally,
    
    <strong class="source-inline">
     
      operator()
     
    </strong>
    
     waits for the completion of previous tasks by calling
    
    <strong class="source-inline">
     
      wait_completion()
     
    </strong>
    
     , which checks whether each shared future stored in the
    
    <strong class="source-inline">
     
      deps_
     
    </strong>
    
     vector is valid and waiting until the result is ready by calling
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     .
    
    
     Once all shared futures are ready, meaning that all previous tasks are complete, the
    
    <strong class="source-inline">
     
      func_
     
    </strong>
    
     function is invoked, running the task, and the
    
    <strong class="source-inline">
     
      prom_
     
    </strong>
    
     promise is then set to ready by calling
    
    <strong class="source-inline">
     
      set_value()
     
    </strong>
    
     , triggering the
    
    
     
      dependent tasks.
     
    
   </p>
   <p>
    
     In the main thread, we define the pipeline as follows, creating a graph like the one shown in
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    
     <em class="italic">
      
       .3
      
     </em>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
auto sleep1s = []() { std::this_thread::sleep_for(1s); };
auto sleep2s = []() { std::this_thread::sleep_for(2s); };
Task task1(1, sleep1s);
Task task2(2, sleep2s, task1.get_dependency());
Task task3(3, sleep1s, task2.get_dependency());
Task task4(4, sleep2s, task2.get_dependency());
Task task5(5, sleep2s, task3.get_dependency(),
                       task4.get_dependency());</pre>
   <p>
    
     Then, we need to start the pipeline by triggering all tasks and calling their
    
    <strong class="source-inline">
     
      operator()
     
    </strong>
    
     .
    
    
     As
    
    <strong class="source-inline">
     
      task1
     
    </strong>
    
     has no dependencies, it will start running straight away.
    
    
     All other tasks will be waiting for their
    
    <a id="_idIndexMarker455">
    </a>
    
     predecessor tasks to complete
    
    
     
      their work:
     
    
   </p>
   <pre class="source-code">
sync_cout &lt;&lt; "Starting the pipeline..." &lt;&lt; std::endl;
task1();
task2();
task3();
task4();
task5();</pre>
   <p>
    
     Finally, we need to wait for the pipeline to finish the execution of all tasks.
    
    
     We can achieve that by simply waiting for the shared future returned by the last task,
    
    <strong class="source-inline">
     
      task5
     
    </strong>
    
     , to
    
    
     
      be ready:
     
    
   </p>
   <pre class="source-code">
sync_cout &lt;&lt; "Waiting for the pipeline to finish...\n";
auto finish_pipeline_fut = task5.get_dependency();
finish_pipeline_fut.get();
sync_cout &lt;&lt; "All done!" &lt;&lt; std::endl;</pre>
   <p>
    
     Here is the output of running
    
    
     
      this example:
     
    
   </p>
   <pre class="console">
Task 1 constructed without dependencies.
Getting future from task 1
Task 2 constructed with dependencies.
Getting future from task 2
Task 3 constructed with dependencies.
Getting future from task 2
Task 4 constructed with dependencies.
Getting future from task 4
Getting future from task 3
Task 5 constructed with dependencies.
Starting the pipeline...
Running task 1
Waiting completion for task 1
Signaling completion of task 1
Running task 2
Waiting completion for task 2
Fut valid so getting value in task 2
Signaling completion of task 2
Running task 3
Waiting completion for task 3
Fut valid so getting value in task 3
Signaling completion of task 3
Running task 4
Waiting completion for task 4
Fut valid so getting value in task 4
Signaling completion of task 4
Running task 5
Waiting completion for task 5
Fut valid so getting value in task 5
Fut valid so getting value in task 5
Signaling completion of task 5
Waiting for the pipeline to finish...
Getting future from task 5
All done!</pre>
   <p>
    
     There are some issues that can occur with this approach that we must be aware of.
    
    
     First, the dependency graph must be a
    
    <strong class="bold">
     
      directed acyclic graph
     
    </strong>
    
     (
    
    <strong class="bold">
     
      DAG
     
    </strong>
    
     ), therefore without cycles or loops between dependent
    
    <a id="_idIndexMarker456">
    </a>
    
     tasks.
    
    
     Otherwise, a deadlock will occur, as a task might be waiting for a task happening in the future and not yet started.
    
    
     Also, we need enough threads to run all the tasks concurrently or launch the tasks orderly; otherwise, it can also lead to a
    
    <a id="_idIndexMarker457">
    </a>
    
     deadlock with threads waiting on the completion of tasks that have still
    
    
     
      not launched.
     
    
   </p>
   <p>
    
     One common use case of this approach
    
    <a id="_idIndexMarker458">
    </a>
    
     can be found in
    
    <strong class="bold">
     
      MapReduce
     
    </strong>
    
     algorithms where large datasets are processed in parallel across multiple nodes, and futures and threads can be used to execute map and reduce tasks concurrently, allowing efficient distributed
    
    
     
      data processing.
     
    
   </p>
   <h2 id="_idParaDest-141">
    <a id="_idTextAnchor140">
    </a>
    
     Thread-safe SPSC task queue
    
   </h2>
   <p>
    
     In this last example, we will show
    
    <a id="_idIndexMarker459">
    </a>
    
     how to use promises and futures to create an
    
    
     
      SPSC queue.
     
    
   </p>
   <p>
    
     The producer thread creates a promise for each item it wants to add to the queue.
    
    
     The consumer thread waits for a future obtained from an empty queue slot.
    
    
     Once the producer finishes adding an item, it sets the value on the corresponding promise, notifying the waiting consumer.
    
    
     This allows for efficient data exchange between threads while maintaining
    
    
     
      thread safety.
     
    
   </p>
   <p>
    
     Let’s first define the thread-safe
    
    
     
      queue class:
     
    
   </p>
   <pre class="source-code">
template &lt;typename T&gt;
class ThreadSafeQueue {
   public:
    void push(T value) {
        std::lock_guard&lt;std::mutex&gt; lock(mutex_);
        queue_.push(std::move(value));
        cond_var_.notify_one();
    }
    T pop() {
        std::unique_lock&lt;std::mutex&gt; lock(mutex_);
        cond_var_.wait(lock, [&amp;]{
            return !queue_.empty();
        });
        T value = std::move(queue_.front());
        queue_.pop();
        return value;
    }
   private:
    std::queue&lt;T&gt; queue_;
    std::mutex mutex_;
    std::condition_variable cond_var_;
};</pre>
   <p>
    
     In this example, we simply use a mutex to have mutual exclusion over all the queue data structures when pushing
    
    <a id="_idIndexMarker460">
    </a>
    
     or popping elements.
    
    
     We want to keep this example simple and focus on the promise and future interactions.
    
    
     A better approach could be to use a vector or circular array and control the access to individual elements within the queue
    
    
     
      with mutexes.
     
    
   </p>
   <p>
    
     The queue also uses a condition variable,
    
    <strong class="source-inline">
     
      cond_var_
     
    </strong>
    
     , to wait if the queue is empty when trying to pop an element and to notify one waiting thread when an element is pushed.
    
    
     Elements are moved in and out of the queue by moving them.
    
    
     This is needed as the queue will store futures, and as we learned earlier, futures are movable
    
    
     
      but non-copiable.
     
    
   </p>
   <p>
    
     The thread-safe queue will be used to define a task queue that will store futures,
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
using TaskQueue = ThreadSafeQueue&lt;std::future&lt;int&gt;&gt;;</pre>
   <p>
    
     Then, we define a function,
    
    <strong class="source-inline">
     
      producer
     
    </strong>
    
     , that accepts a reference to the queue, and a value,
    
    <strong class="source-inline">
     
      val
     
    </strong>
    
     , that will be produced.
    
    
     This function just creates a promise, retrieves a future from the promise, and pushes that future into the queue.
    
    
     Then, we simulate a task running and
    
    <a id="_idIndexMarker461">
    </a>
    
     producing the value,
    
    <strong class="source-inline">
     
      val
     
    </strong>
    
     , by making the thread wait for a random number of milliseconds.
    
    
     Finally, the value is stored in
    
    
     
      the promise:
     
    
   </p>
   <pre class="source-code">
void producer(TaskQueue&amp; queue, int val) {
    std::promise&lt;int&gt; prom;
    auto fut = prom.get_future();
    queue.push(std::move(fut));
    std::this_thread::sleep_for(
            std::chrono::milliseconds(rand() % MAX_WAIT));
    prom.set_value(val);
}</pre>
   <p>
    
     At the other end of the communication channel, the
    
    <strong class="source-inline">
     
      consumer
     
    </strong>
    
     function accepts a reference to the same queue.
    
    
     Again, we simulate a task running on the consumer side by waiting for a random number of milliseconds.
    
    
     Then, a future is popped out of the queue and its result is retrieved, being the value,
    
    <strong class="source-inline">
     
      val
     
    </strong>
    
     , or an exception if something
    
    
     
      went wrong:
     
    
   </p>
   <pre class="source-code">
void consumer(TaskQueue&amp; queue) {
    std::this_thread::sleep_for(
            std::chrono::milliseconds(rand() % MAX_WAIT));
    std::future&lt;int&gt; fut = queue.pop();
    try {
        int result = fut.get();
        std::cout &lt;&lt; "Result: " &lt;&lt; result &lt;&lt; "\n";
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; '\n';
    }
}</pre>
   <p>
    
     For this example, we will use
    
    
     
      these constants:
     
    
   </p>
   <pre class="source-code">
const unsigned VALUE_RANGE = 1000;
const unsigned RESULTS_TO_PRODUCE = 10; // Numbers of items to produce.
const unsigned MAX_WAIT = 500; // Maximum waiting time (ms) when producing items.</pre>
   <p>
    
     In the main thread, two
    
    <a id="_idIndexMarker462">
    </a>
    
     threads are started; the first runs the producer function
    
    <strong class="source-inline">
     
      producerFunc
     
    </strong>
    
     , which pushes some futures into the queue, while the second thread runs the consumer function
    
    <strong class="source-inline">
     
      consumerFunc
     
    </strong>
    
     , which consumes elements from
    
    
     
      the queue:
     
    
   </p>
   <pre class="source-code">
TaskQueue queue;
auto producerFunc = [](TaskQueue&amp; queue) {
    auto n = RESULTS_TO_PRODUCE;
    while (n-- &gt; 0) {
        int val = rand() % VALUE_RANGE;
        std::cout &lt;&lt; "Producer: Sending value " &lt;&lt; val
                  &lt;&lt; std::endl;
        producer(queue, val);
    }
};
auto consumerFunc = [](TaskQueue&amp; queue) {
    auto n = RESULTS_TO_PRODUCE;
    while (n-- &gt; 0) {
        std::cout &lt;&lt; "Consumer: Receiving value"
                  &lt;&lt; std::endl;
        consumer(queue);
    }
};
std::jthread producerThread(producerFunc, std::ref(queue));
std::jthread consumerThread(consumerFunc, std::ref(queue));</pre>
   <p>
    
     Here is sample output
    
    <a id="_idIndexMarker463">
    </a>
    
     of executing
    
    
     
      this code:
     
    
   </p>
   <pre class="console">
Producer: Sending value 383
Consumer: Receiving value
Producer: Sending value 915
Result: 383
Consumer: Receiving value
Producer: Sending value 386
Result: 915
Consumer: Receiving value
Producer: Sending value 421
Result: 386
Consumer: Receiving value
Producer: Sending value 690
Result: 421
Consumer: Receiving value
Producer: Sending value 926
Producer: Sending value 426
Result: 690
Consumer: Receiving value
Producer: Sending value 211
Result: 926
Consumer: Receiving value
Result: 426
Consumer: Receiving value
Producer: Sending value 782
Producer: Sending value 862
Result: 211
Consumer: Receiving value
Result: 782
Consumer: Receiving value
Result: 862</pre>
   <p>
    
     With a producer-consumer
    
    <a id="_idIndexMarker464">
    </a>
    
     queue like this one, the consumer and producer are decoupled, and their threads communicate asynchronously, allowing both the producer and consumer to do extra work while the other side generates or processes
    
    
     
      the values.
     
    
   </p>
   <h1 id="_idParaDest-142">
    <a id="_idTextAnchor141">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we learned about promises and futures, how to use them to execute asynchronous code in separate threads, and also how to run callables using packaged tasks.
    
    
     These objects and mechanisms constitute and implement the key concepts of asynchronous programming used by many programming languages,
    
    
     
      including C++.
     
    
   </p>
   <p>
    
     We also now understand why promises, futures, and packaged tasks cannot be copied, and thus how to share futures by using shared
    
    
     
      future objects.
     
    
   </p>
   <p>
    
     Finally, we have shown how to use futures, promises, and packaged tasks to tackle
    
    
     
      real-life problems.
     
    
   </p>
   <p>
    
     If you want to explore promises and futures deeper, it is worth mentioning some third-party open source libraries, especially
    
    <strong class="bold">
     
      Boost.Thread
     
    </strong>
    
     and
    
    <strong class="bold">
     
      Facebook Folly
     
    </strong>
    
     .
    
    
     These libraries include additional functionality, including callbacks, executors,
    
    
     
      and combinators.
     
    
   </p>
   <p>
    
     In the next chapter, we will learn a simpler way to asynchronously invoke callables by
    
    
     
      using
     
    
    
     <strong class="source-inline">
      
       std::async
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-143">
    <a id="_idTextAnchor142">
    </a>
    
     Further reading
    
   </h1>
   <ul>
    <li>
     
      Boost futures and
     
     
      
       promises:
      
     
     <a href="https://theboostcpplibraries.com/boost.thread-futures-and-promises">
      
       
        https://theboostcpplibraries.com/boost.thread-futures-and-promises
       
      
     </a>
    </li>
    <li>
     
      Facebook Folly open source
     
     
      
       library:
      
     
     <a href="https://github.com/facebook/folly">
      
       
        https://github.com/facebook/folly
       
      
     </a>
    </li>
    <li>
     
      Futures for C++11 at
     
     
      
       Facebook:
      
     
     <a href="https://engineering.fb.com/2015/06/19/developer-tools/futures-for-c-11-at-facebook">
      
       
        https://engineering.fb.com/2015/06/19/developer-tools/futures-for-c-11-at-facebook
       
      
     </a>
    </li>
    <li>
     <em class="italic">
      
       ‘Futures and Promises’ – How Instagram leverages it for better resource
      
     </em>
     
      <em class="italic">
       
        utilization
       
      </em>
     
     
      
       :
      
     
     <a href="https://scaleyourapp.com/futures-and-promises-and-how-instagram-leverages-it/">
      
       
        https://scaleyourapp.com/futures-and-promises-and-how-instagram-leverages-it/
       
      
     </a>
    </li>
    <li>
     
      SeaStar: Open source C++ framework for high-performance server
     
     
      
       applications:
      
     
     <a href="https://seastar.io">
      
       
        https://seastar.io
       
      
     </a>
    </li>
   </ul>
  </div>
 </body></html>