["```cpp\nwhile(Serial1.available()>0)//While there are characters to come from the GPS\n  {\n    gps.encode(Serial1.read());//This feeds the serial NMEA data into the library one char at a time\n  }\n  if(gps.location.isUpdated())//This will pretty much be fired all the time anyway but will at least reduce it to only after a package of NMEA data comes in\n  {\n    //Get the latest info from the gps object which it derived from the data sent by the GPS unit\n    Serial.println(\"Satellite Count:\");\n    Serial.println(gps.satellites.value());\n    Serial.println(\"Latitude:\");\n    Serial.println(gps.location.lat(), 6);\n    Serial.println(\"Longitude:\");\n    Serial.println(gps.location.lng(), 6);\n    Serial.println(\"Speed MPH:\");\n    Serial.println(gps.speed.mph());\n    Serial.println(\"Altitude Feet:\");\n    Serial.println(gps.altitude.feet());\n    Serial.println(\"\");\n  }\n```", "```cpp\nTinyGPSPlus gps;\nunsigned long previousMillis = 0;\nconst long interval = 30000; //milliseconds\n```", "```cpp\n  unsigned long currentMillis = millis();\n  if (currentMillis - previousMillis >= interval) {\n    //speed=currentMillis;\n    FetchGPS();\n    previousMillis = currentMillis;\n  }\n```", "```cpp\nif (gps.location.isUpdated())\n  {\n    altitudeFeet = gps.altitude.feet();\n    satelliteCount = gps.satellites.value();\n    speed = gps.speed.mph();\n    location = Location(gps.location.lat(), gps.location.lng());\n    Location cordinates = location.getValue();\n .\n .\n .\n}\n```"]