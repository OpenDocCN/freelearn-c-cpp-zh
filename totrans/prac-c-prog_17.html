<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Embedded Software and IoT</h1>
                </header>
            
            <article>
                
<p>When it comes to doing specific tasks more efficiently and precisely, embedded systems are preferred. They work as independent components, and they can be collectively combined into larger pieces of equipment. The internet is a vast and endless source of information; consequently, the <strong>Internet of Things</strong> (<strong>IoT</strong>) plays a major role in making embedded devices smarter so that they can be managed and controlled remotely.</p>
<p>In this chapter, we'll deep dive into the following recipes related to embedded software and IoT:</p>
<ul>
<li>Toggling the port of a microcontroller in Embedded C (blinking LED)</li>
<li>Incrementing the value of a port in Embedded C</li>
<li>Toggling the voltage in an output pin using Arduino (blinking LED)</li>
<li>Taking input from the serial port using Arduino</li>
<li>Sensing the temperature using Arduino with the LM35 sensor</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>For embedded programming in C, we will use Keil MDK, which provides a software development environment for a wide range of ARM Cortex-M-based microcontroller devices. MDK provides the very easy-to-use µVision IDE, an Arm C/C++ compiler, and other libraries. You can download Keil MDK from the following URL:<span> </span><a href="https://www.keil.com/download/">https://www.keil.com/download/</a>. Let's take a look at the following steps:</p>
<ol start="1">
<li>Download the following three executable files. You may not find the files with exactly the same names, but they will be somewhat similar:
<ul>
<li><kbd>mdk526.exe</kbd>: This provides a development environment for ARM devices.</li>
<li><kbd>c251v560.exe</kbd>: This provides development tools for all 80251 devices.</li>
<li><kbd>c51v959.exe</kbd>: This provides development tools for all 8051 devices.</li>
</ul>
</li>
<li>Double-click on these executable files one by one and follow the setup dialog boxes to install these three Keil products.</li>
</ol>
<p>Following the successful installation of these products, you will find an icon called Keil uVision5 on the desktop. The icon represents the<span> </span><strong>Integrated Development Environment</strong><span> </span>(<strong>IDE</strong>) that enables us to write, edit, debug, and compile programs. The compiler converts the source code into a HEX file, which, in return, can be fused onto the target chip.</p>
<p>In order to work with Arduino, you have to buy the Arduino board and download the Arduino IDE from <a href="https://www.arduino.cc/en/main/software">https://www.arduino.cc/en/main/software</a>.</p>
<p>At the time of writing this chapter, the latest version of the Arduino IDE that is available is 1.8.8. The downloaded executable file will be<span> </span><kbd>arduino-1.8.8-windows.exe</kbd>. Connect the Arduino board to your PC and simply double-click on the executable file to install the Arduino IDE. When it has successfully installed, you will find the Arduino IDE icon on the desktop.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to embedded systems</h1>
                </header>
            
            <article>
                
<p>An embedded system is a combination of computer hardware and software designed to do specific functions within larger equipment. The heavy equipment used in industries, automobiles, medical procedures, household appliances, and mobile devices use embedded systems. Most embedded systems use a RISC family microcontroller, such as PIC 16F84, Atmel 8051, or Motorola 68HC11. Several input and output devices can be connected to the embedded system's microcontrollers, such as an LCD display, keypad, printer, and sensor. These devices can control several other devices such as fans, motors, bulbs, washing machines, ovens, AC controllers, cars, printers, and so much more.</p>
<p>To program a microcontroller to do a specific task, the microcontroller is interfaced with a PC by connecting it to a slot. An assembly program, or Embedded C, can be used to write and burn the program onto the microcontroller. The programs can be stored in the microcontroller's <span><strong>EPROM </strong>(short for <strong>Erasable Programmable Read-Only Memory</strong></span><span>).</span><span> It's an </span>internal, read-only memory that can be programmed and erased when exposed to an ultraviolet light source. We will be developing applications for embedded systems using Embedded C with software such as Keil.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to IoT</h1>
                </header>
            
            <article>
                
<p>IoT is an architecture that comprises hardware and software systems or devices that are connected to the internet using various means such as WiFi, Ethernet, and more. The web API and other protocols, when combined, provide an environment that allows smart embedded devices to be connected to the internet. Consequently, it enables us to access data from remote areas and control or trigger certain actions on various devices via the internet. In other words, IoT is a system of interrelated embedded computing devices that have the ability to transfer data over a network and take necessary actions. Arduino is considered to be the best starting point for embedded IoT. For Arduino to be able to work as an IoT device, Android with an Ethernet shield is required.</p>
<p>Let's quickly learn a little more about Arduino.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to Arduino</h1>
                </header>
            
            <article>
                
<p>Arduino is an architecture that includes the Atmel microcontroller family along with standard hardware. The pin diagram of Arduino is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a4b83b8f-6db5-46a6-bfe8-717fa7b3738b.png" style="width:55.17em;height:27.92em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Arduino includes 14 digital pins that can operate with 5V:</p>
<ul>
<li>Pins <strong>0</strong> (<strong>RXD</strong>) and <strong>1</strong> (<strong>TXD</strong>) are the serial pins used to transfer TTL serial data.</li>
<li>Pins <strong>2</strong> and <strong>3</strong> are the external interrupt pins used to activate an interrupt.</li>
<li>Pins <strong>3</strong>, <strong>5</strong>, <strong>6</strong>, <strong>9</strong>, <strong>10</strong>, and <strong>11</strong> are used to provide the PWM output.</li>
<li>Pins <strong>10</strong>, <strong>11</strong>, <strong>12</strong>, and <strong>13</strong> are <strong>SPI</strong> pins (short for the <strong>Serial Peripheral Interface</strong>). Named <strong>SS</strong>, <strong>MOSI</strong>, <strong>MISO</strong>, and <strong>SCK</strong>, these pins are used for SPI communication.</li>
<li>Pin <strong>13</strong> is an LED pin. A HIGH digital value, when supplied to this pin, will make the LED glow.</li>
<li>Analog pins <strong>4</strong> and <strong>5</strong>—called <strong>SDA</strong> and <strong>SCL</strong>, respectively<span>—</span>are used in the communication of <strong>TWI</strong> (short for the <strong>Two-Wire Interface</strong>).</li>
<li>The <strong>AREF</strong> (short for <strong>Analog Reference</strong>) pin is used to connect to some reference voltage from an external power supply.</li>
<li>The <strong>RESET</strong> (<strong>RST</strong>) pin is used to reset the microcontroller.</li>
</ul>
<p>As far as software is concerned, Arduino comes with an IDE that we can use to write and edit applications and can even upload them to do specific tasks. This IDE includes support for the C and C++ programming languages for programming microcontrollers. It contains several libraries that make the job of a software developer quite easy. Besides this, the IDE provides communication windows in order to enter data into the board as well as to get output.</p>
<p>The Arduino board provides ports to connect LCDs, relays, and much more to its output pin and provides input pins to input information from sensors, relays, and much more. The Arduino board can be powered either by a USB or by connecting a 9V battery. </p>
<p><span>While working with Arduino programming, we will be using the following functions:</span></p>
<ul>
<li class="mce-root"><kbd>Serial.begin()</kbd> is used to set the data rate while establishing communication between the Arduino board and the PC. In order to communicate with the computer through serial data transmission, we need to first set the data rate in bits per second (baud). We can use any of the baud rates, such as 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, or 115200.</li>
<li class="mce-root"><kbd>Serial.println()</kbd><span> is used to display a message to the serial port in a human-readable format. It displays the message in ASCII text followed by a newline character on the serial monitor. You will need to press</span> <em>Ctrl</em> <span>+</span> <em>Shift</em> <span>+</span> <em>M</em> <span><span>to open the serial monitor.</span></span></li>
<li class="mce-root"><kbd>Serial.available()</kbd><span> checks whether the data, in terms of bytes from the serial port, is available for reading. Essentially, the data to be read from the serial port is stored in the serial receive buffer and this method checks whether the data has arrived in this buffer. This method returns the number of bytes available to read:</span></li>
<li class="mce-root"><kbd>Serial.read()</kbd><span> reads incoming serial data and returns the first byte of incoming serial data available. The method returns</span> <kbd>-1</kbd> <span>if no data is available to read.</span></li>
<li class="mce-root"><kbd>analogRead()</kbd><span> reads the value from the specified analog pin. The Arduino board contains a multichannel, 10-bit analog-to-digital converter. As a result of this, it will map input voltages between 0 and the operating voltage (5V or 3.3V) into integer values between 0 and 1023.</span></li>
</ul>
<p>For example, if you're using a 5V Arduino and a sensor is connected to its analog pin, then the following formula is used to convert the 10-bit analog reading into a temperature:</p>
<pre>Voltage at pin in milli volts = Reading from ADC * 5000/1024</pre>
<p>This formula converts the number 0-1023 from the ADC into 0-5000 mV.</p>
<p>If you're using a 3.3V Arduino, then the following formula is used to convert the analog reading into a temperature:</p>
<pre>Voltage at pin in milli volts = Reading from ADC * 3300/1024</pre>
<p>This formula converts the number 0-1023 from the ADC into 0-3300 mV.</p>
<p>To convert the number of millivolts retrieved from the preceding formula into a temperature, the following formula is used:</p>
<pre>Centigrade temperature = Analog voltage in mV / 10</pre>
<p>That wraps up our introduction to embedded systems and IoT. We'll now review the required technical software and hardware we need to complete the recipes in this chapter. After that, we will begin with the first recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Toggling the port of a microcontroller in Embedded C (blinking LED)</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will learn how to send HIGH and LOW signals to a specific port <span>that is connected to an LED, and make the LED blink</span>. The idea behind this exercise is to learn how to control a device that is connected to a specific port of the microcontroller. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>To toggle the port of a microcontroller in Embedded C, perform the following steps:</p>
<ol>
<li>We will carry out this recipe using Keil; double-click on the Keil uVision5 icon to activate the IDE.</li>
<li>Create a new project by clicking on the <span class="packt_screen">Project</span> | <span class="packt_screen">New uVision Project</span> option.</li>
<li>When prompted, specify <span>the project name </span>and the folder where you want to create the new project.</li>
<li>Give the new project the name <kbd>LedBlinkProject</kbd> and then click on the <span class="packt_screen">Save</span> button.</li>
<li>The device selection window will open and you will be prompted to select a device.</li>
<li>From the <span class="packt_screen">Device</span> combo box, select the <span class="packt_screen">Legacy Device Database [no RTE]</span> option. You will get the list of devices in the lower-left pane (<span>refer to</span> the following screenshot).</li>
<li>Click on the <span class="packt_screen">Microchip</span> node to expand it and display the list of devices in it.</li>
<li><span>Because we want to program the Atmel microcontroller, f</span>rom the <span class="packt_screen">Microchip</span> node, select the <span class="packt_screen">AT89C51</span> device. The description of the selected device will appear in the description pane on the right. Click on <span class="packt_screen">OK</span> to move further:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e086bd76-9554-4d4c-8d26-c961142a3a99.png" style="width:45.42em;height:33.92em;"/></p>
<ol start="3">
<li>You will be asked whether you want to copy the <kbd>STARTUP.A51</kbd> file to the project folder (refer to the following screenshot). The startup file will be required for running the project, so click on the <span class="packt_screen">Yes</span> button to add the file and move further:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d23d91fa-3ead-45eb-a4ba-ea5fe55903bc.png" style="width:32.67em;height:11.83em;"/></p>
<ol start="4">
<li>The IDE will appear as follows. You can see three windows: <span class="packt_screen">Project</span> <span class="packt_screen">Workspace</span>, <span class="packt_screen">Editing Window</span>, and <span class="packt_screen">Output Window</span> in the IDE. Additionally, you can see the <span class="packt_screen">Target1</span> node created under the <span class="packt_screen">Project</span> space:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4c8417f2-dce2-469e-b0d2-e5fc9330f0c7.png" style="width:58.25em;height:40.33em;"/></p>
<ol start="5">
<li>Add a C file. Right-click on <span class="packt_screen">Source Group</span><span class="packt_screen">1</span> under the <span class="packt_screen">Target1</span> node and click on the <span class="packt_screen">Add New item to Group 'Source Group 1'</span> option. From the list box, select the <span class="packt_screen">C File (.c)</span> option. Specify the filename as <kbd>blinkingLed</kbd> (or any other name), and then click on the <span class="packt_screen">Add</span> button (refer to the following screenshot):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/aa3a6f00-ca50-475d-a1d3-fa8bf5bbfd87.png" style="width:46.00em;height:33.67em;"/></p>
<ol start="6">
<li>The <kbd>blinkingLed.c</kbd> file is added to <span class="packt_screen">Source Group 1</span>. Enter the following code in the editor window:</li>
</ol>
<pre style="padding-left: 60px">#include&lt;reg52.h&gt;   <br/><br/>sbit LED = P1^0;          <br/>void Delay(int);<br/>void main (void)<br/>{<br/>    while(1)               <br/>    {<br/>        LED = 0;           <br/>        Delay(500);<br/>        LED = 1;           <br/>        Delay(500);<br/>    }<br/>}<br/><br/>void Delay(int n)<br/>{<br/>    int i,j;<br/>    for(i=0;i&lt;n;i++)<br/>    {<br/>        for(j=0;j&lt;100;j++);<br/>    }<br/>}</pre>
<ol start="7">
<li>After entering the code, click on the save icon from the toolbar to save the <kbd>blinkingLed.c</kbd> file.</li>
</ol>
<p>Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We will define a variable called <kbd>LED</kbd> of the <span><kbd>sbit</kbd> </span><span>type</span>. The <kbd>sbit</kbd> type defines a bit within a <strong>special function register</strong> (<strong>SFR</strong>). We will set the <kbd>LED</kbd> variable to represent the 0<sup>th</sup>-bit position of port <kbd>P1</kbd>. Then, we will define a prototype of the <kbd>Delay</kbd> function, which takes an integer parameter but returns nothing. Within the <kbd>main</kbd> function, we will execute a <kbd>while</kbd> loop in an infinite loop. Within the <kbd>while</kbd> loop, we will set the <kbd>LED</kbd> variable to <kbd>0</kbd>, that is, a LOW signal will be sent to the 0th bit of port <kbd>P1</kbd>.</p>
<p>Thereafter, we will introduce a delay through two nested loops. After the delay, we will set the value of the <kbd>LED</kbd> variable to <kbd>1</kbd>, that is, a HIGH signal will be sent to the 0th bit of port <kbd>P1</kbd>. If the LED is connected to the 0th bit of port <kbd>1</kbd>, the LED will glow and, after some delay, it will go off. Again, after some delay, the LED will glow again; therefore, we get a blinking LED.</p>
<p>Press <em>F7</em> or click on the <span class="packt_screen">Build</span> button to start compiling the code. If there is no error, you can move on to the next step. You can either generate a HEX file to infuse into the desired hardware, or you can use the simulation technique to see whether the program is giving the desired output. In order to generate a HEX file, right-click on the <span class="packt_screen">Target1</span> node and select <span class="packt_screen"><span class="packt_screen">Options</span> for Target 'Target  1'</span>. We will get a dialog box showing different options. Click on the <span class="packt_screen">Output</span> tab, and check the <span class="packt_screen">Create HEX File</span> box (refer to the following screenshot). Additionally, click on the <span class="packt_screen">Device</span> tab to confirm that the device selected is <span class="packt_screen">AT89C51</span>. Then, click on the <span class="packt_screen">OK</span> button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/14d919f9-c13b-4635-8567-8fba4fd9f389.png" style="width:47.50em;height:24.17em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 5.5</div>
<p>Keil's built-in <span class="packt_screen">Debug</span> option can be used for code simulation. To do this, click on <span class="packt_screen">Debug</span> | <span class="packt_screen">Start/Stop Debug Session</span>; alternatively, you can press <em>Ctrl</em> + <em>F5</em> as the shortcut key, or click on the <span class="packt_screen">Start/Stop Debug Session</span> icon (it appears in the form of d) in the toolbar. The <span>free version of the </span>Keil tool has a condition that the running code size should not be more than 2 KB. You will get the following dialog box indicating that the running code has an upper limit of 2 KB:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ae978b3a-b3e7-41f8-9e74-e53126b34d46.png" style="width:20.50em;height:11.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 5.6</div>
<p class="mce-root"/>
<p>Click on the <span class="packt_screen">OK</span> button to move further. Now the <span class="packt_screen">Project</span> workspace window shows most of the SFRs as well as the GPRs, <span class="packt_screen">r0</span> to <span class="packt_screen">r7</span>, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/28b08d76-c374-4106-ba99-ca014b9987f8.png" style="width:44.08em;height:35.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 5.7</div>
<p>Click on the <span class="packt_screen">Run</span> icon from the toolbar or press <em>F5</em>. To see the output on ports go to <span class="packt_screen">Peripherals </span>| <span class="packt_screen">Select I/O ports</span> | <span class="packt_screen">Port 1</span>. You will get the blinking LED on <kbd>Port1</kbd>, as shown in the following screenshot. You can see that there is a LOW signal in <kbd>bit0</kbd> of the <kbd>Port1</kbd> and a <span><span>HIGH </span></span>signal on the same bit:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d38d1f7a-c909-4c46-9f87-d0bc68d091ab.png" style="width:33.58em;height:11.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 5.8</div>
<p>Voilà! We've successfully created a blinking LED using a microcontroller port. Now, let's move on to the next recipe!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Incrementing the value of a port in Embedded C</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will learn how to display values from 0 to 255 on a specific port of a microcontroller and make the value increment like a counter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p><span>To increment the value of a port in Embedded C, perform the following steps:</span></p>
<ol>
<li>Launch the Keil uVision5 IDE.</li>
<li>Create a new project by clicking on the <span class="packt_screen">New Project</span> | <span class="packt_screen">New uVision Project</span> option.</li>
<li>Specify the <span>project name and </span>folder location when prompted. Let's give the new project the name <kbd>CounterApp</kbd>; click on <span class="packt_screen">Save</span>.</li>
<li>The device selection window will open and you will be prompted to select a device. From the <span class="packt_screen">Device</span> combo box, select <span class="packt_screen">Legacy Device Database [no RTE]</span>.</li>
<li>You will get the list of devices in the lower-left pane. Click on the <span class="packt_screen">Microchip</span> node to expand it and display the list of devices in it.</li>
<li>From the <span class="packt_screen">Microchip</span> node, select the <span class="packt_screen">AT89C51</span> device. The description of the selected device will appear in the description pane on the right. Click on <span class="packt_screen">OK</span> to move further.</li>
</ol>
<ol start="6">
<li>You will be asked whether you want to copy the <kbd>STARTUP.A51</kbd> file to the project folder. Click on <span class="packt_screen">Yes</span> to add the file and move further.</li>
<li>The IDE will open showing three windows: The <span class="packt_screen">Project</span> <span class="packt_screen">Workspace</span> on the left, the <span class="packt_screen">Editing Window</span> on the right, and the <span class="packt_screen">Output Window</span> at the bottom. You will see <span class="packt_screen">Target1</span> created under the <span class="packt_screen">Project</span> space.</li>
<li>Add a C file by right-clicking on <span class="packt_screen">Source Group1</span> under the <span class="packt_screen">Target1</span> node and then click on <span class="packt_screen">Add New item to Group 'Source Group 1'</span>.</li>
<li>From the list box, select the <span class="packt_screen">C File (.c)</span> option. Specify the filename as <kbd>showcounter</kbd> and then click on <span class="packt_screen">Add</span>.</li>
<li>The <kbd>showcounter.c</kbd> file will be added to <span class="packt_screen">Source Group 1</span>. Enter the following code in the editor window:</li>
</ol>
<pre style="padding-left: 60px">#include&lt;stdio.h&gt;<br/>#include&lt;reg52.h&gt;<br/>void delay(void);        <br/>void main()<br/>{<br/>    unsigned char i; <br/>    i=0x00;                   <br/>    while(++i)<br/>    {<br/>         P3=i;                                  <br/>         delay();            <br/>    }             <br/>}<br/><br/>void delay(void)<br/>{<br/>    int j;<br/>    int i;<br/>    for(i=0;i&lt;1000;i++)<br/>    {<br/>        for(j=0;j&lt;10000;j++)<br/>        {<br/>        }<br/>    }<br/>}</pre>
<ol start="8">
<li>After entering the code, click on the <span class="packt_screen">SAVE</span> icon in the toolbar to save the <kbd>showcounter.c</kbd> file.</li>
</ol>
<p>Now, let's go behind the scenes to understand the steps better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We will define a variable, <kbd>i</kbd>, of the unsigned char <span>type</span>; a variable of the unsigned char type can store 256 bits, whereas that of a signed char can store only 128 bits. The <kbd>i</kbd><span> variable</span> is assigned the HEX value of <kbd>0</kbd>. We will set a <kbd>while</kbd> loop to execute infinitely. With every iteration of the <kbd>while</kbd> loop, the value of the <kbd>i</kbd> <span>variable </span>will increment by <kbd>1</kbd>. Within the <kbd>while</kbd> loop, we will assign the value of the <kbd>i</kbd> <span>variable,</span> that is, <kbd>0</kbd>, to port <kbd>P3</kbd>.</p>
<p>We will introduce a delay by using two nested <kbd>for</kbd> loops. Thereafter, we will execute a <kbd>while</kbd> loop again, incrementing the value of the <kbd>i</kbd> <span>variable,</span> making it <kbd>1</kbd>. Again, we will assign the value of the <kbd>i</kbd> <span>variable </span>to port <kbd>P3</kbd> for display. And, we will reintroduce some delay, followed by executing the <kbd>while</kbd> loop again. This process continues infinitely; consequently, port <kbd>P3</kbd> will display the counter from <kbd>0</kbd> until <kbd>255</kbd> repeatedly.</p>
<p>Press <em>F7</em> or click on the <span class="packt_screen">Build</span> button to compile the code. If there is no error, you can move ahead to the next step; otherwise, first, debug the code. In order to see the output of the code through simulation, we will use Keil's built-in <span class="packt_screen">Debug</span> option for simulation of the code. To do this, click on <span class="packt_screen">Debug</span> | <span class="packt_screen">Start/Stop Debug Session</span>. Alternatively, you can press <em>Ctrl</em> + <em>F5</em> as the shortcut key, or click on the <span class="packt_screen">Start/Stop Debug Session</span> icon (it appears in the form of a D) in the toolbar.</p>
<p>On the free version of Keil, there is a condition that the running code size should not be more than 2 KB, so you will get a dialog box indicating that the running code has an upper limit of 2 KB. Click on <span class="packt_screen">OK</span> to move further. The project workspace window shows most of the SFRs as well as the GPRs, from <span class="packt_screen">r0</span> to <span class="packt_screen">r7</span>. Click on the  <span class="packt_screen">Run</span> icon from the toolbar or press the <em>F5</em> key. You can see the output of the ports under <span class="packt_screen">Peripherals |</span> <span class="packt_screen">Select I/O ports|</span> <span class="packt_screen">Port 3</span>. You will see the bits of the ports showing the counter from <kbd>0</kbd> to <kbd>255</kbd>.</p>
<p>In the following screenshot, <strong>(a)</strong> shows the bits set to a value of <kbd>5</kbd>. The binary value of 5 is 101, so, accordingly, the first and third bits are set to a HIGH signal and the remaining bits are set to a LOW signal. Similarly, <strong>(b)</strong> shows the bits displaying the counter value of 10. The bits of the port will be set showing the values from 0 to 255:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ec502c1f-6fea-4ee3-b7b0-a7be409632d6.png" style="width:26.17em;height:9.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 5.9</div>
<p>Voilà! We've successfully created a counter using Embedded C. Now, let's move on to the next recipe!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Toggle voltage in output pin using Arduino (blinking LED)</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will learn how to make an LED that is connected to the output pins of the Arduino board <span>blink</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>To <span>make an LED that is connected to the output pins of the Arduino board </span><span>blink, perform the following steps:</span></p>
<ol>
<li>Open the Arduino IDE. Arduino opens up with a file showing the default content, as follows:</li>
</ol>
<pre style="padding-left: 60px">void setup() {<br/>// put your setup code here, to run once:<br/>}<br/><br/>void loop() {<br/>// put your main code here, to run repeatedly:<br/><br/>}</pre>
<p class="mce-root"/>
<ol start="2">
<li>Connect the Arduino board to the PC.</li>
<li>From the <span class="packt_screen">Tools</span> menu, select <span class="packt_screen">Port</span> and confirm whether it shows COM3 (Arduino/Genuino Uno) or whatever Arduino board you have attached to your PC. Additionally, confirm whether the <span class="packt_screen">Board</span> option from the <span class="packt_screen">Tools</span> menu indicates the Arduino board that is attached to your PC. In my case, the <span class="packt_screen">Board</span> option will show <span class="packt_screen">Arduino/Genuino Uno</span>.</li>
<li>Remember, the LEDs have polarity; hence, they will only glow when they are connected properly. The long leg is positive and should connect to a digital pin on the Arduino board. I am using the 13<sup>th</sup> pin of the Arduino board for the output, so connect the long leg of the LED to the 13<sup>th</sup> pin of the Arduino board (refer to <em>Figure 5.10</em>). Then, connect the short leg of the LED, which is negative, to the GND on the Arduino board.</li>
<li>Type the following program in the editor window:</li>
</ol>
<pre style="padding-left: 60px">int Led = 13;<br/><br/>void setup() {<br/>pinMode(Led, OUTPUT);<br/>}<br/><br/>void loop() {<br/>digitalWrite(Led, HIGH);<br/>                 delay(1000);<br/>                digitalWrite(Led, LOW);<br/>                delay(1000);<br/>}</pre>
<p style="padding-left: 60px">6. Save the application by clicking on <span class="packt_screen">File</span> | <span class="packt_screen">Save As</span>. Specify the application name when prompted. Select the desired folder location and specify the application name. Let's name the application <kbd>ArduinoLedBlink</kbd>. A folder will be created with the specified application name (<kbd>ArduinoLedBlink</kbd>), and, within the <kbd>ArduinoLedBlink</kbd> folder, the application will be created with the filename <kbd>ArduinoLedBlink.ino</kbd>.</p>
<p style="padding-left: 60px">7. Upload the application to Arduino by clicking on the <span class="packt_screen">Upload</span> icon in the toolbar.</p>
<p>Now, let's go behind the scenes to understand the steps better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We will start by defining a <kbd>Led</kbd> <span>variable </span>and setting it to represent pin 13 of the Arduino. By invoking the <kbd>pinMode</kbd> function, the <kbd>Led</kbd> <span>variable </span>will be <span class="fontstyle0">indicated</span> as the output pin, that is, it will be connected to an output device for display or to do some task.</p>
<p>Within the <kbd>loop</kbd> function, we will invoke the <kbd>digitalWrite</kbd> method to send a HIGH signal to <span>variable </span><kbd>Led</kbd>. By doing so, the LED that is connected to output pin 13 will be switched on. Thereafter, we will introduce a time delay of 1,000 milliseconds.</p>
<p>Once more, we will invoke the <kbd>digitalWrite</kbd> method and send a <span><span>LOW </span></span>signal, this time to variable <kbd>Led</kbd>. As a result, the LED connected to output pin 13 will be switched off. Again, we will introduce a delay of 1,000 milliseconds. The commands in the <kbd>loop</kbd> function will execute infinitely making the connected LED to keep blinking.</p>
<p>On uploading the program to Arduino, the LED connected to the 13<sup>th</sup> pin of the Arduino will start blinking, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/65963531-c8ab-44ae-a5e6-b034cc5f825f.png" style="width:58.75em;height:28.58em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 5.10</div>
<p>Voilà! We've successfully toggled the voltage in an output pin on the Arduino board to make a blinking LED.</p>
<p>Now, let's move on to the next recipe!</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Taking input from the serial port using Arduino</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will be attaching an LED to the Arduino board and will prompt the user to press either <kbd>0</kbd> or <kbd>1</kbd>. The user can input a value using the serial port. If the value entered by the user is <kbd>0</kbd>, it will switch off the LED and if the value entered by the user is <kbd>1</kbd>, it will make the LED glow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>To take input from the serial port using Arduino, perform the following steps:</p>
<ol>
<li>Invoke the Arduino IDE. Arduino opens up with a file showing its default content, as follows:</li>
</ol>
<pre style="padding-left: 60px">void setup() {<br/>// put your setup code here, to run once:<br/><br/>}<br/><br/>void loop() {<br/>// put your main code here, to run repeatedly:<br/><br/>}</pre>
<ol start="2">
<li>Connect the Arduino board to your PC.</li>
<li>From the <span class="packt_screen">Tools</span> menu, select <span class="packt_screen">Port</span> and confirm whether it shows COM3 (Arduino/Genuino Uno) or whatever Arduino board you have attached to your PC. Additionally, confirm whether the <span class="packt_screen">Board</span> option from the <span class="packt_screen">Tools</span> menu indicates the Arduino board that is attached to your PC. In my case, the <span class="packt_screen">Board</span> option will show <span class="packt_screen">Arduino/Genuino Uno</span>.</li>
<li>We will be attaching the LED to the output pin 13 of Arduino. Because the LEDs have polarity and need to be connected properly, we will connect the long leg of the LED (also known as the positive pin) to the 13<sup>th</sup> digital pin on the Arduino board. Additionally, we will connect the short leg of the LED (also known as the negative pin) to the GND on the Arduino board.</li>
</ol>
<ol start="5">
<li>Type the following program in the editor window:</li>
</ol>
<pre style="padding-left: 60px">int Led = 13;<br/>void setup() {<br/>                pinMode(Led,OUTPUT);<br/>                Serial.begin(9600);<br/>                Serial.println("Enter 0 to switch Off LED and 1 to <br/>                  switch it On");<br/>}<br/><br/>void loop() {<br/>if(Serial.available())<br/>                {<br/>                                int input=Serial.read();<br/>                                input=input-48;<br/>                                if(input==0)<br/>                                {<br/>                                                Serial.println("LED <br/>                                                  is OFF");<br/>                                                digitalWrite(Led,LOW);<br/>                                 }<br/>                                else if(input==1)<br/>                                 {<br/>                                                Serial.println("LED <br/>                                                  is ON");<br/>                                                digitalWrite(Led,HIGH);<br/>                                }<br/>                                else<br/>                                {<br/>                                                <br/>Serial.println("Enter 0 to switch Off<br/> LED and 1 to switch it On");<br/>                                 }<br/>                }<br/>}</pre>
<ol start="6">
<li>Save the application by clicking on the <span class="packt_screen">File</span> | <span class="packt_screen">Save As</span> option. Specify the application name when prompted. Let's name the application <kbd>ArduinoTakinginput</kbd>. A folder will be created with the specified application name, and, within the <kbd>ArduinoLedBlink</kbd> folder, the application will be created with the filename <kbd>ArduinoTakinginput.ino</kbd>.</li>
<li>Upload the application to Arduino by clicking on the <span class="packt_screen">Upload</span> icon from the toolbar (refer to the following screenshot):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c1e6c409-2c23-46a8-bcce-de4cd5110ffc.png" style="width:34.08em;height:11.58em;"/></p>
<p>Now, let's go behind the scenes to understand the steps better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We will define a <kbd>Led</kbd> <span>variable </span>and set it to represent pin 13 of Arduino. By invoking the <kbd>pinMode</kbd> function, the <kbd>Led</kbd> <span>variable </span>is declared as the output pin and, hence, we will use it for connecting to an output device in order to perform a desired action. In this application, the output device will be an LED.</p>
<p>Because we want our PC to communicate with Arduino using serial communication, we need to set the data rate in terms of bits per second. So, we will call the <kbd>Serial.begin</kbd> function to set the serial data transmission speed at 9,600 bits per second (however, it can be any baud rate). Thereafter, we will display a message on the serial port in a human-readable format, informing the user that <kbd>0</kbd> can be pressed to switch off the connected LED and <kbd>1</kbd> can be pressed to switch on the LED.</p>
<p>Within the <kbd>loop</kbd> function of Arduino, we will invoke the <kbd>Serial.available</kbd> function to check whether any data is available in the serial port to read from. That is, the serial receive buffer will be checked to see whether some data or bytes are available there to be read. The data can be available in the serial receive buffer only when the user presses any key. It also means that no output will appear until the user presses any key. The moment the user presses any key, that byte will go into the serial receive buffer and the <kbd>Serial.available</kbd> function will return the Boolean value <kbd>true</kbd>. As a result of this, the <kbd>if</kbd> block will execute.</p>
<p>Within the <kbd>if</kbd> block, we will invoke the <kbd>Serial.read</kbd> function to read the serial data from the serial port. The data or byte that is read from the serial port will be assigned to the variable input. The byte read is always in ASCII format. The user is supposed to press either <kbd>0</kbd> or <kbd>1</kbd>; their corresponding ASCII values are 48 and 49, respectively. So, if the user presses <kbd>0</kbd>, its ASCII value, 48, will be assigned to the variable input. And if the user presses <kbd>1</kbd>, its ASCII value, 49, will be assigned to the variable input.</p>
<p>To get the actual value of the number entered by the user, the value of 48 is subtracted from the variable input. If the user presses <kbd>0</kbd>, a specified <kbd>if</kbd> block will execute. Within that <kbd>if</kbd> block, we will invoke the <kbd>Serial.println</kbd> function to display the message <em><span class="packt_screen">LED is OFF</span></em> to inform the user. And we will invoke the <kbd>digitalWrite</kbd> method to send a LOW signal to output pin 13 where the LED is connected. Consequently, the LED, if it is glowing, will be switched off.</p>
<p>If the user presses <kbd>1</kbd>, then another <kbd>if</kbd> block will execute; in this case, we will invoke the <kbd>Serial.println</kbd> function to display the message <em><span class="packt_screen">LED is On</span>.</em> And we will invoke the <kbd>digitalWrite</kbd> function to send a HIGH signal to output pin 13 to make the LED glow. If the user has not pressed either <kbd>0</kbd> or <kbd>1</kbd>, we will display a message asking them to press either <kbd>0</kbd> or <kbd>1</kbd> only.</p>
<p>After uploading the program to Arduino, we can press <em>Ctrl</em> + <em>Shift</em> + <em>M</em> to open the serial monitor. In the serial monitor, we will get the following message: <em><span class="packt_screen">Enter 0 to switch off LED and 1 to switch it On</span></em> (refer to the first dialog box in <em>Figure 5.11</em>). After pressing <kbd>0</kbd> in the serial monitor, we will get the message <span class="packt_screen">LED is OFF</span> and, again, you will be prompted to enter either <kbd>0</kbd> or <kbd>1</kbd> (refer to the second dialog box in <em>Figure 5.11</em>). Besides the message in the serial monitor, the LED that is connected to the 13<sup>th</sup> pin of the Arduino board will also get switched off (if it was glowing). On pressing <kbd>1</kbd>, the message <span class="packt_screen">LED is ON</span> will be displayed in the serial monitor. Additionally, a message will appear prompting us to enter either <kbd>0</kbd> or <kbd>1</kbd> (refer to the third dialog box in <em>Figure 5.11</em>). Also, the LED connected to the Arduino board will glow:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/90223173-1fb1-469f-9ace-27a614a2fc47.png" style="width:41.58em;height:41.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 5.11</div>
<p><span>Voilà! We've successfully made an LED switch on and off on the basis of the input made to the serial port using Arduino.</span></p>
<p>Now, let's move on to the next recipe!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sensing the temperature using Arduino with the LM35 sensor</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will learn how to sense temperature using the LM35 sensor connected to the Arduino board and will display the temperature in Celsius and Fahrenheit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready...</h1>
                </header>
            
            <article>
                
<p>For this recipe, we will require the following three components: a b<span>readboard, </span><span>Arduino Uno R3, and an </span><span>LM35 sensor.</span></p>
<p>The LM35 is a temperature sensor that produces an output voltage that is linearly proportional to centigrade temperature. It does not require any external calibration or trimming to provide an accurate temperature. It has three terminals, <strong>Vs</strong>, <strong>Vout</strong>, and <strong>Ground</strong>, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/47c2e713-5144-4a84-aa65-2707c8c3ef23.png" style="width:16.50em;height:15.58em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 5.12</div>
<p>We will connect the LM35 sensor to the Arduino board as follows:</p>
<ol>
<li>Connect the +Vs terminal to +5v on your Arduino board.</li>
<li>Connect the Vout terminal to Analog0 or A0 on the Arduino board.</li>
<li>Connect the GND terminal with the GND terminal on Arduino.</li>
</ol>
<p>The following diagram makes this clearer:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a3e15b71-9f5d-4412-9432-3a23edc8b178.png" style="width:54.33em;height:36.33em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 5.13</div>
<p>Now that the LM35 sensor is connected to the Arduino board, let's perform the steps listed next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To <span>sense temperature using the LM35 sensor connected to the Arduino board, perform the following steps:</span></p>
<ol>
<li>Invoke the Arduino IDE. Arduino will open up with a file showing its default content, as follows:</li>
</ol>
<pre style="padding-left: 60px">void setup() {<br/>// put your setup code here, to run once:<br/>}<br/><br/>void loop() {<br/>// put your main code here, to run repeatedly:<br/><br/>}</pre>
<ol start="2">
<li>Connect the Arduino board to the PC.</li>
<li>From the <span class="packt_screen">Tools</span> menu, select <span class="packt_screen">Port</span> and confirm whether it shows COM3 (Arduino/Genuino Uno) or whatever Arduino board you have attached to your PC. Additionally, confirm whether the <span class="packt_screen">Board</span> option from the <span class="packt_screen">Tools</span> menu indicates the Arduino board that is attached to your PC. In my case, the <span class="packt_screen">Board</span> option will show <span class="packt_screen">Arduino/Genuino Uno</span>.</li>
<li>Type the following program into the editor window:</li>
</ol>
<pre style="padding-left: 60px">float voltage;<br/>int tempPin = 0;<br/><br/>void setup() {<br/>   Serial.begin(9600);<br/>}<br/><br/>void loop() {<br/>   voltage = analogRead(tempPin);<br/>   float tempInCelsius = voltage * 0.48828125;<br/>   float tempinFahrenheit = (tempInCelsius*9)/5 + 32;<br/>   Serial.print("Temperature in Celsius is: ");<br/>   Serial.print(tempInCelsius);<br/>   Serial.print("*C");<br/>   Serial.println();<br/>   Serial.print("Temperature in Fahrenheit is: ");<br/>   Serial.print(tempinFahrenheit);<br/>   Serial.print("*F");<br/>   Serial.println();<br/>   delay(1000);<br/>}</pre>
<ol start="5">
<li>Save the application by clicking on the <span class="packt_screen">File</span> | <span class="packt_screen">Save As</span> option. Specify the application name when prompted. Let's name the application <kbd>SensorApp</kbd>. A folder will be created with the name <kbd>SensorApp</kbd> and, within that folder, the application will be created with the filename <kbd>SensorApp.ino</kbd>.</li>
<li>Upload the application to Arduino by clicking on the <span class="packt_screen">Upload</span> icon in the toolbar.</li>
</ol>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We define a variable called <kbd>voltage</kbd>, of the float data type, and a variable called <kbd>tempPin</kbd>, of the integer type; we will set the latter to represent pin 0 of Arduino. In order to make our PC communicate with Arduino using serial communication, we need to set the data rate in terms of bits per second. So, we will call the <kbd>Serial.begin</kbd> function to set the serial data transmission speed to 9,600 bits per second (however, it can be any baud rate).</p>
<p>Within the <kbd>loop</kbd> function, we will invoke the <kbd>analogRead</kbd> function to read the value from the specified analog pin, 0. Recall that the Arduino boards contain a multichannel, 10-bit analog to digital converter that maps input voltages between 0 and the operating voltage (5V or 3.3V) into integer values between 0 and 1023. The value read from the analog pin, 0, is assigned to the <kbd>voltage</kbd> variable.</p>
<p>We are using a 5V Arduino and an LM35 sensor is already connected to its analog pin. We will use the following formula to convert the 10-bit analog reading into a temperature:</p>
<pre>Voltage at pin in milliVolts = Reading from ADC * 5000/1024</pre>
<p>This formula converts the numbers 0-1023 from the ADC into 0-5000 mV. To convert millivolts retrieved from this formula into temperature, we will use another formula:</p>
<pre>Centigrade temperature = Analog voltage in mV / 10</pre>
<p>The two previously mentioned formulas can be rewritten as follows:</p>
<pre>Centigrade temperature = Reading from ADC * 0.48828125;</pre>
<p>Using this formula, the value read into the voltage variable is converted into temperature in Celsius and is assigned to the <kbd>tempInCelsius</kbd> variable. To convert temperature in Celsius (<span>°</span>C) into Fahrenheit (<span>°</span>F), the following formula is used:</p>
<pre>F=(C*9)/5+32</pre>
<p>Using this formula, the temperature in Celsius found in the <kbd>tempInCelsius</kbd> variable is converted into Fahrenheit and assigned to the <kbd>tempinFahrenheit</kbd> variable.</p>
<p>Temperatures in <span>°C and °F</span> are displayed to the serial port by invoking. The temperature reading can be seen by opening the serial monitor. Press <em>Ctrl</em> + <em>Shift</em> + <em>M</em> to open the serial monitor and display the temperature. You can also press the LM35 sensors in your thumbs to see the rise and fall in temperature.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We will introduce a delay of 1,000 milliseconds between every temperature display by invoking the <kbd>delay</kbd> function. That is, the application will keep displaying the temperature in <span>°C and °F</span> infinitely with a delay of 1,000 milliseconds in between.</p>
<p>After uploading the program to Arduino, we can press <em>Ctrl</em> + <em>Shift</em> + <em>M</em> to open the serial monitor. In the serial monitor, we will get the temperature in Celsius as well as in Fahrenheit. You will keep getting a temperature reading continuously with a delay of 1,000 milliseconds in between:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1da08133-eb6e-40eb-a29c-2b463fe3f741.png" style="width:48.42em;height:28.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 5.14</div>
<p>In the following photograph, you can see the LM35 sensor attached to the Arduino board. You can press the LM35 sensor in your thumbs to see the rise in the temperature readings:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/057da4bd-05a4-412b-b6b8-db19a90d7bcd.png" style="width:51.17em;height:43.25em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 5.15</div>
<p>Voilà! We've successfully created a temperature sensor with an LM35 sensor using Arduino.</p>


            </article>

            
        </section>
    </body></html>