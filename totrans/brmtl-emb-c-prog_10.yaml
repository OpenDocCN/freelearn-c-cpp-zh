- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: The Universal Asynchronous Receiver/Transmitter Protocol
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用异步收发器协议
- en: In this chapter, we will learn about the **universal asynchronous receiver/transmitter**
    (**UART**) protocol, an important communication method widely used in embedded
    systems. UART is fundamental for enabling communication between microcontrollers
    and various peripherals, making it an essential component in embedded systems
    development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习**通用异步收发器（UART**）协议，这是一种在嵌入式系统中广泛使用的通信方法。UART对于实现微控制器和各种外设之间的通信至关重要，使其成为嵌入式系统开发中的基本组件。
- en: We will start by discussing the significance of communication protocols in embedded
    systems and highlight common use cases for UART alongside other protocols such
    as SPI and I2C. Following this, we will provide a comprehensive overview of the
    UART protocol, detailing its operational principles and features. Next, we will
    extract and examine the relevant registers for UART from the STM32 reference manual,
    providing the necessary foundational knowledge for driver development. Finally,
    we will apply this knowledge to develop a bare-metal UART driver, illustrating
    the practical aspects of initializing and transmitting data via UART.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论通信协议在嵌入式系统中的重要性，并强调UART与其他协议（如SPI和I2C）一起的常见用例。在此之后，我们将全面概述UART协议，详细说明其操作原理和特性。接下来，我们将从STM32参考手册中提取并检查UART的相关寄存器，为驱动器开发提供必要的知识基础。最后，我们将应用这些知识来开发裸机UART驱动器，展示通过UART初始化和传输数据的实际方面。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Introduction to communication protocols
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信协议简介
- en: Overview of the UART protocol
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UART协议概述
- en: The STM32F4 UART peripheral
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32F4 UART外设
- en: Developing the UART driver
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发UART驱动器
- en: By the end of this chapter, you will have a good understanding of the UART protocol
    and the skills needed to develop bare-metal drivers for UART communication.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将很好地理解UART协议以及开发UART通信的裸机驱动器所需的技术。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，网址为[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: Introduction to communication protocols
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信协议简介
- en: In the world of embedded systems, communication protocols are essential conduits
    that enable microcontrollers and peripheral devices to talk to each other seamlessly.
    Think of them as the languages that different devices use to understand and exchange
    information, ensuring that everything from your smartphone to your smart home
    devices works smoothly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统领域，通信协议是使微控制器和外设设备能够无缝通信的关键通道。把它们想象成不同设备用来理解和交换信息的语言，确保从你的智能手机到你的智能家居设备都能顺畅工作。
- en: Let’s dive into what communication protocols are, how they are grouped, their
    unique features and advantages, and explore some common use cases to see these
    protocols in action.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解通信协议是什么，它们是如何分组的，它们的独特特性和优势，并探索一些常见用例来观察这些协议的实际应用。
- en: What are communication protocols?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是通信协议？
- en: Communication protocols are sets of rules and conventions that allow electronic
    devices to communicate with each other. These protocols define how data is formatted,
    transmitted, and received, ensuring that devices can exchange information accurately
    and reliably. Without these protocols, it would be like trying to have a conversation
    with someone who speaks a completely different language – communication would
    be chaotic and error-prone.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通信协议是一套规则和约定，允许电子设备相互通信。这些协议定义了数据是如何格式化、传输和接收的，确保设备可以准确可靠地交换信息。没有这些协议，就像试图与说完全不同语言的人交谈一样——通信将会混乱且充满错误。
- en: In embedded systems, these protocols are crucial because they facilitate the
    interaction between microcontrollers and peripherals such as sensors, actuators,
    displays, and other microcontrollers. Whether it’s sending a simple temperature
    reading from a sensor to a microcontroller or streaming video data from a camera
    module, communication protocols make it happen.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze the classification of communication protocols, starting with
    the big picture: what communication protocols can be broadly classified into –
    **serial** and **parallel** communication.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Serial versus parallel communication
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with serial communication.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Serial communication
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this category, communication protocols can be further broken down into asynchronous
    and synchronous protocols:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous**: This type of communication sends data one bit at a time without
    a clock signal to synchronize the sender and receiver. Think of it as sending
    letters through the mail without a scheduled delivery time. A common example is
    UART, which is simple and efficient for many applications.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synchronous**: Unlike asynchronous communication, this form of communication
    uses a clock signal to coordinate the transmission of bits. It’s like having a
    drumbeat to ensure everyone marches in step. Examples include **Serial Peripheral
    Interface** (**SPI**) and **Inter-Integrated Circuit** (**I2C**). These protocols
    ensure data integrity and timing, making them suitable for more complex tasks.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel communication
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This type involves transmitting multiple bits simultaneously over multiple channels.
    Imagine sending a whole fleet of cars instead of a single one – it’s faster but
    requires more lanes (or pins, in our case). While parallel communication is faster,
    it’s less common in embedded systems due to the higher pin count. Also, it’s prone
    to crosstalk and signal integrity problems, especially over longer distances.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: We can also classify communication protocols based on their architecture. In
    this classification system, we have point-to-point communication and multi-device
    communication.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Point-to-point versus multi-device communication
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s look at the differences.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Point-to-point
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a direct line of communication between two devices. **UART** is a classic
    example, where data flows directly between a microcontroller and a peripheral
    device. It’s straightforward, reliable, and ideal for many embedded systems.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Multi-device (bus) communication
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here, multiple devices share the same communication lines, which can be either
    of the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-master**: Multiple devices can control the communication bus. **I2C**
    is a great example as it allows multiple masters and slaves on the same bus. It’s
    like a group of friends taking turns talking in a conversation.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Master-slave**: One master device controls the communication, directing traffic
    to and from multiple slave devices. **SPI** operates this way, with a single master
    communicating with multiple slaves through dedicated lines. **I2C** can also operate
    this way. It’s akin to a teacher (master) calling on students one at a time to
    speak.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, communication protocols can be classified based on their data flow capabilities.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Full-duplex versus half-duplex
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s see the differences between full-duplex and half-duplex:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**Full-duplex**: This allows simultaneous two-way communication. Imagine a
    two-lane road where cars can travel in both directions at the same time. **UART**
    and **SPI** support full-duplex communication, making them highly efficient for
    real-time data exchange.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Half-duplex**: Here, communication can occur in both directions, but not
    at the same time – it’s like a single-lane road where cars must take turns. **I2C**
    typically operates in half-duplex mode, which works well for its intended applications
    but can be a limitation in high-speed data scenarios.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s closely compare the three common communication protocols that are
    used in modern embedded systems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Comparing UART, SPI, and I2C
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with UART.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: UART
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some key features of UART:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous communication**: UART doesn’t require a clock signal. Instead,
    it uses start and stop bits to synchronize data transmission.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full-duplex**: UART can send and receive data simultaneously, which is ideal
    for many applications requiring real-time communication.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple and cost-effective**: With minimal hardware requirements, UART is
    easy to implement and cost-effective.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of its advantages:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '**Ease of use**: Setting up UART communication is straightforward, making it
    a popular choice for beginners and simple applications'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wide support**: UART is universally supported by most microcontrollers and
    peripheral devices'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low overhead**: The lack of a clock signal means fewer pins are used, reducing
    complexity'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it also has some disadvantages:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed limitations**: UART is generally slower compared to SPI and I2C, making
    it less suitable for high-speed data transfer'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited distance**: Susceptibility to noise over long distances can limit
    the range of reliable communication'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Point-to-point only**: UART is designed for direct, point-to-point communication,
    which can be a limitation if multiple devices need to communicate'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have SPI.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: SPI
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some key features of SPI:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous communication**: SPI uses a clock signal along with data lines,
    ensuring synchronized data transfer'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full-duplex**: It allows data to be sent and received simultaneously'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Master-slave architecture**: One master device controls multiple slave devices,
    with dedicated lines for each'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of its advantages:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '**High speed**: SPI supports high-speed data transfer, making it ideal for
    applications requiring fast communication'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versatility**: SPI can connect multiple devices with different configurations,
    providing flexibility in design'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it also has some disadvantages:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '**More pins required**: Each slave device needs a separate select line, which
    can increase the pin count significantly'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No standardized acknowledgment**: Unlike I2C, SPI does not have a built-in
    acknowledgment mechanism, which can make error detection more challenging'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited multi-master capability**: SPI is not designed for multi-master systems,
    which can be a limitation in some scenarios'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final common communication protocol we’ll cover is I2C.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: I2C
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some key features of I2C:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous communication**: I2C uses a clock signal for synchronized data
    transfer'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-master capability**: Multiple master devices can share the same bus,
    which is useful in more complex systems'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two-wire interface**: I2C requires only two lines (SDA and SCL) for communication,
    minimizing the pin count'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of its advantages:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity in wiring**: The two-wire interface reduces the complexity and
    number of pins required'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-device support**: I2C easily connects multiple devices on the same
    bus, each with a unique address'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in addressing**: I2C has a built-in addressing mechanism, making communication
    with multiple devices straightforward'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it does have some disadvantages:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '**Slower speed**: I2C is generally slower than SPI, which can be a limitation
    for high-speed applications'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex protocol**: The protocol is more complex than UART and SPI, requiring
    more sophisticated handling of data transfers and addressing'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Susceptible to noise**: Like UART, I2C can be susceptible to noise over longer
    distances, potentially affecting communication reliability'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right communication protocol depends on your specific application
    needs. If you need simple, straightforward communication and can tolerate slower
    speeds, **UART** is a great choice. For high-speed applications with a need for
    full-duplex communication, **SPI** is ideal, especially if you can manage the
    higher pin count. When you need to connect multiple devices with minimal wiring
    and have a complex communication setup, **I2C** is your go-to protocol. To help
    you better understand when to choose which protocol, let’s explore some common
    use cases.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Common use cases for the UART, SPI, and I2C protocols
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing embedded systems, selecting the right communication protocol
    is crucial for ensuring efficient and reliable data exchange. UART, SPI, and I2C
    each have unique strengths, making them suitable for different applications. Let’s
    explore the practical use cases and compelling case studies for each protocol,
    highlighting their professional and real-world relevance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: UART
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at some common use cases for the UART protocol:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '**Serial communication with PCs**: UART is often used for serial communication
    between microcontrollers and computers, particularly for debugging, firmware updates,
    and data logging'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPS modules**: UART can be used to transmit location data from a GPS module
    to a microcontroller'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bluetooth modules**: UART enables wireless communication with devices via
    Bluetooth'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These use cases represent some of the most common applications of UART, but
    the protocol is versatile and can be used in many other scenarios that require
    simple serial communication.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Case study – GPS module integration for autonomous drones
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you’re developing an autonomous drone that requires precise navigation
    to perform tasks such as surveying and mapping. Integrating a GPS module using
    UART can provide real-time location data essential for navigation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup**: Connect the GPS module’s transmit (TX) pin to the microcontroller’s
    receive (RX) pin and vice versa. Configure the baud rate so that it matches the
    GPS module’s output.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation**: The GPS module continuously sends NMEA sentences (text strings)
    containing location data. The microcontroller reads these strings via UART, parses
    them, and uses the location information to navigate the drone accurately.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantage**: UART’s simplicity and widespread support make it straightforward
    to integrate the GPS module, providing reliable and continuous data flow without
    a complex setup.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at SPI.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: SPI
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are some common use cases for the SPI protocol:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '**High-speed data transfer**: It’s ideal for applications such as memory cards,
    **analog-to-digital converters** (**ADCs**), **digital-to-analog converters**
    (**DACs**), and displays'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Display modules**: SPI can be used for communicating with high-resolution
    displays requiring fast refresh rates'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sensors and actuators**: SPI can handle high-frequency data outputs from
    various sensors'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like UART, these examples highlight some typical uses of SPI, but the protocol’s
    high-speed capabilities make it suitable for a wide range of other applications
    requiring rapid data transfer.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Case study – SD card data logging for industrial equipment
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Consider an industrial monitoring system that logs data from various sensors
    to an SD card for long-term analysis. SPI is the perfect protocol for this high-speed
    data transfer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup**: Connect the microcontroller to the SD card using SPI pins (MISO,
    MOSI, SCLK, and CS). Initialize the SPI bus and configure the SD card.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation**: The microcontroller collects data from sensors (for example,
    temperature, pressure, and vibration) and writes this data to the SD card in real
    time.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantage**: SPI’s high-speed data transfer ensures that large amounts of
    data are logged quickly and efficiently, preventing any data loss and ensuring
    accurate monitoring.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Using SPI in this scenario allows the industrial system to maintain precise
    logs of critical parameters, which are essential for predictive maintenance and
    operational efficiency.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下使用SPI允许工业系统精确记录关键参数，这对于预测性维护和运营效率至关重要。
- en: Finally, we have I2C.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有I2C。
- en: I2C
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I2C
- en: 'Let’s consider two common use cases related to I2C:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑两个与I2C相关的常见用例：
- en: '**Multiple sensor integration systems**: This involves connecting several sensors
    with different addresses on the same I2C bus'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多传感器集成系统**：这涉及到在同一I2C总线上连接具有不同地址的多个传感器'
- en: '**Peripheral expansion**: This involves adding more GPIO pins to a microcontroller
    using I2C expanders'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外围扩展**：这涉及到使用I2C扩展器向微控制器添加更多GPIO引脚'
- en: These use cases are just two examples of I2C’s applications. Its ability to
    support multiple devices on a single bus makes it an excellent choice for many
    other scenarios where scalability is important.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用例只是I2C应用的两个例子。它能够在单总线上支持多个设备的能力，使其成为许多其他场景下的优秀选择，在这些场景中，可扩展性很重要。
- en: Case study – environmental monitoring system for smart agriculture
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 案例研究 - 智能农业的环境监控系统
- en: Let’s say you’re developing a smart agriculture system that uses multiple sensors
    (temperature, humidity, and soil moisture) to optimize farming conditions. I2C
    is the ideal protocol for this multi-sensor integration.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发一个使用多个传感器（温度、湿度和土壤湿度）以优化农业条件的智能农业系统。I2C是这种多传感器集成的理想协议。
- en: '**Setup**: Connect all sensors to the I2C bus (SDA and SCL lines). Assign each
    sensor a unique address.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置**：将所有传感器连接到I2C总线（SDA和SCL线）。为每个传感器分配一个唯一的地址。'
- en: '**Operation**: The microcontroller queries each sensor in sequence, collects
    the data, and processes it to provide insights and control irrigation, ventilation,
    and lighting systems.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作**：微控制器按顺序查询每个传感器，收集数据，并对其进行处理以提供见解和控制灌溉、通风和照明系统。'
- en: '**Advantage**: I2C’s ability to support multiple devices on the same bus with
    just two lines simplifies wiring, reduces costs, and saves GPIO pins, making it
    an efficient solution for complex sensor networks.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**优势**：I2C能够在同一总线上仅用两条线支持多个设备，简化了布线，降低了成本，并节省了GPIO引脚，使其成为复杂传感器网络的效率解决方案。'
- en: Starting with the next section, we’ll focus exclusively on the UART protocol.
    We’ll cover the I2C and SPI protocols in the following chapters.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一节开始，我们将专注于UART协议。在接下来的章节中，我们将介绍I2C和SPI协议。
- en: Overview of the UART protocol
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UART协议概述
- en: One of the most fundamental and widely used protocols is UART. Whether you’re
    debugging hardware or enabling communication between a microcontroller and peripherals,
    understanding UART is crucial. Let’s delve into the workings of this protocol.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本且最广泛使用的协议之一是UART。无论你是调试硬件还是使微控制器与外围设备之间进行通信，理解UART都是至关重要的。让我们深入了解这个协议的工作原理。
- en: What is UART?
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是UART？
- en: UART is a hardware communication protocol that operates using asynchronous serial
    communication, allowing for adjustable data transmission speeds. The “asynchronous”
    nature of UART means it doesn’t require a clock signal to align the transmission
    of bits between the sender and receiver. Instead, both devices must agree on a
    specific baud rate, which dictates the speed at which data is exchanged. Let’s
    take a look at the interface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: UART是一种硬件通信协议，它使用异步串行通信进行操作，允许调整数据传输速度。"异步"的UART特性意味着它不需要时钟信号来对齐发送器和接收器之间位传输的对齐。相反，两个设备必须就特定的波特率达成一致，这决定了数据交换的速度。让我们看看接口。
- en: The interface
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: 'The UART interface employs two wires for communication: TX and RX. To establish
    a connection between two devices, we simply connect the TX pin of the first device
    to the RX pin of the second device, and the RX pin of the first device to the
    TX pin of the second device. Additionally, it’s crucial to connect the ground
    pins of both devices to ensure a common electrical reference. *Figure 10**.1*
    shows the connection between two UART devices:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: UART接口使用两条线进行通信：TX和RX。为了在两个设备之间建立连接，我们只需将第一个设备的TX引脚连接到第二个设备的RX引脚，并将第一个设备的RX引脚连接到第二个设备的TX引脚。此外，连接两个设备的接地引脚以确保共同的电气参考至关重要。*图10.1*显示了两个UART设备之间的连接：
- en: '![Figure 10.1: The UART interface](img/B21914_10_1.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1：UART接口](img/B21914_10_1.jpg)'
- en: 'Figure 10.1: The UART interface'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：UART接口
- en: How UART works
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UART是如何工作的
- en: 'Data in UART is transmitted as frames containing a **start bit**, **data bits**,
    an optional **parity bit**, and **stop bits**:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: The UART data packet](img/B21914_10_2.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: The UART data packet'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a step-by-step breakdown of the process:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '**Start bit**: The transmission line is normally held high. To start the data
    transfer, the transmitting UART pulls the line low for one clock cycle. This indicates
    the start of a new data frame.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data frame**: Following the start bit, the data frame typically consists
    of 5 to 9 bits and is sent from the **least significant bit** (**LSB**) to the
    **most significant** **bit** (**MSB**).'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Parity bit**: This is optional and is used for error checking. It ensures
    that the number of set bits (1s) in the data is even or odd.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Stop bits**: This is one or two bits indicating the end of the data packet.
    The line is driven high during the stop bits.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s take a closer look at the start, stop, and parity bits.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The start, stop, and parity bits
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These bits form the backbone of the UART protocol, allowing devices to synchronize
    and verify the integrity of the transmitted data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Start bit
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The start bit is the initial signal that marks the beginning of a data frame
    in UART communication. When the transmitting device is idle, the data line is
    held at a high voltage level (logic 1). To signal the start of transmission, the
    UART transmitter pulls the line to a low voltage level (logic 0) for a 1-bit duration.
    This transition from high to low alerts the receiving device that a new data packet
    is incoming, allowing it to synchronize and prepare for data reception.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Stop bit
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After the data bits and optional parity bit are transmitted, the stop bit signals
    the end of the data frame. The transmitter drives the data line back to a high
    voltage level (logic 1) for 1 or 2-bit durations, depending on the configuration.
    The stop bit(s) ensure that the receiver has time to process the last data bit
    and prepare for the next start bit. In essence, the stop bit acts as a buffer,
    providing a clear demarcation between successive data frames and helping maintain
    synchronization between the communicating devices.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Parity bit
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The parity bit is an optional feature that’s used for basic error checking
    in UART communication. It provides a simple method to detect errors that may have
    occurred during data transmission. The parity bit can be configured for either
    even or odd parity:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '**Even parity**: The parity bit is set to 0 if the number of 1s in the data
    frame is even, and set to 1 if the number of 1s is odd. This ensures that the
    total number of 1s (including the parity bit) is even.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Odd parity**: The parity bit is set to 0 if the number of 1s in the data
    frame is odd, and set to 1 if the number of 1s is even. This ensures that the
    total number of 1s (including the parity bit) is odd.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the receiver gets the data frame, it checks the parity bit against the
    received data bits. If there’s a mismatch, it indicates that an error occurred
    during transmission. While parity doesn’t correct errors, it helps in identifying
    them, prompting for retransmission if necessary.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收方接收到数据帧时，它会将奇偶校验位与接收到的数据比特进行比较。如果存在不匹配，则表明在传输过程中发生了错误。虽然奇偶校验不能纠正错误，但它有助于识别错误，并在必要时提示重新传输。
- en: The start, stop, and parity bits are essential components of UART communication,
    each playing a critical role in ensuring data integrity and synchronization. The
    start bit signals the beginning of transmission, the stop bit marks the end, and
    the parity bit provides a basic error-checking mechanism. Together, they create
    a robust framework for reliable and efficient serial communication between devices.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 开始位、停止位和奇偶校验位是 UART 通信的基本组成部分，每个部分都在确保数据完整性和同步方面发挥着关键作用。开始位表示传输的开始，停止位标记传输的结束，奇偶校验位提供基本的错误检查机制。它们共同构成了一个可靠且高效的设备间串行通信框架。
- en: Before wrapping up this section, let’s take a moment to understand the unit
    of speed that’s used in UART communication.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，让我们花一点时间来了解在 UART 通信中使用的速度单位。
- en: Understanding the baud rate – the speed of communication in embedded systems
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解波特率——嵌入式系统中通信的速度
- en: In the world of embedded systems, **baud rate** is a term you’ll encounter frequently.
    Whether you’re debugging a microcontroller, setting up a serial communication
    link, or working with various peripherals, understanding the baud rate is essential.
    But what exactly is the baud rate, and why is it so important? Let’s break it
    down.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统领域，**波特率**是一个你经常会遇到的术语。无论你是调试微控制器、设置串行通信链路还是处理各种外围设备，理解波特率都是至关重要的。但波特率究竟是什么，为什么它如此重要呢？让我们来分析一下。
- en: What is the baud rate?
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 波特率是什么？
- en: 'The baud rate is essentially the speed at which data is transmitted over a
    communication channel. It’s measured in **bits per second** (**bps**). Think of
    it as the speed limit on a highway: the higher the baud rate, the more data can
    travel along the communication path in a given amount of time.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 波特率本质上是指数据在通信信道上传输的速度。它以每秒比特数（**bps**）来衡量。把它想象成高速公路上的限速：波特率越高，在给定时间内沿通信路径传输的数据就越多。
- en: For example, a baud rate of *9,600* means *9,600 bits* of data are transmitted
    each *second*. In other words, it sets the pace for how fast data packets are
    sent and received.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，波特率为 *9,600* 意味着每 *秒* 传输 *9,600 比特* 的数据。换句话说，它设定了数据包发送和接收的速度。
- en: However, it’s important to distinguish between the baud rate and the **bit rate**.
    While the baud rate refers to the number of signal changes per second, the bit
    rate is the number of bits transmitted per second. In simple systems, *each signal
    change can represent one bit*, making the baud rate and bit rate the same. In
    more complex systems, each signal change can represent multiple bits, resulting
    in a bit rate higher than the baud rate.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，区分波特率和比特率非常重要。波特率指的是每秒信号变化的次数，而比特率是每秒传输的比特数。在简单的系统中，*每次信号变化可以代表一个比特*，这使得波特率和比特率相同。在更复杂的系统中，每次信号变化可以代表多个比特，从而导致比特率高于波特率。
- en: Why does the baud rate matter?
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么波特率很重要？
- en: Imagine trying to have a conversation with someone who speaks at a wildly different
    speed than you. It would be confusing and inefficient, right? The same principle
    applies to electronic devices communicating with each other. Both the transmitting
    and receiving devices need to agree on a common baud rate to understand each other
    correctly. If they don’t, the data might get lost or garbled, leading to communication
    errors.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下试图与一个说话速度与你截然不同的人交谈。这将令人困惑且效率低下，对吧？同样的原则也适用于电子设备之间的通信。发送和接收设备需要就一个共同的波特率达成一致，以便正确理解对方。如果它们不一致，数据可能会丢失或混乱，从而导致通信错误。
- en: For successful communication, both the sender and receiver must have the same
    baud rate to synchronize correctly. If one device is set to 9,600 bps and the
    other to 115,200 bps, the communication will fail, similar to how a conversation
    fails if one person is speaking too fast or too slow for the other to understand.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功通信，发送方和接收方必须具有相同的波特率以正确同步。如果一个设备设置为 9,600 bps，而另一个设置为 115,200 bps，通信将失败，就像一个人说话太快或太慢以至于对方无法理解时，对话会失败一样。
- en: 'There are standard baud rates that are commonly used in serial communication.
    Here are a few:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**300 bps**: Very slow, often used for long-distance communication where bandwidth
    is limited'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**9,600 bps**: A widely used default rate for many devices, including microcontrollers'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**19,200 bps**: Faster, often used in more data-intensive applications'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**115,200 bps**: High-speed communication, common in applications requiring
    quick data transfer'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our overview of the UART protocol. In the next section, we will
    explore the UART peripheral in the STM32F4 microcontroller.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The STM32F4 UART peripheral
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'STM32 microcontrollers often include several UART peripherals, though the number
    varies depending on the specific model. The STM32F411 microcontroller has three
    UART peripherals:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: USART1
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USART2
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USART6
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USART versus UART
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Our STM32 documentation refers to the UART peripheral as **USART** because
    it stands for universal **synchronous/asynchronous** receiver/transmitter. This
    name reflects the dual functionality of the peripheral:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous mode** (**UART**): In this mode, the USART operates as a traditional
    UART. It transmits and receives data without needing a clock signal, which is
    typical for standard serial communication.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous mode** (**USART**): In this mode, the USART can also operate
    with a synchronous clock signal, allowing it to communicate with devices that
    require a clock line in addition to the data lines.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Let’s analyze the key registers of this peripheral, starting with the USART
    Status Register.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: USART Status Register (USART_SR)
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `USART_SR` register is one of the main registers used to monitor the status
    of the UART peripheral. It provides real-time information about various operational
    flags and errors.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the key bits in this register:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**Transmit data register empty** (**TXE**): This bit is set when the data register
    is empty and ready for new data to be written. It indicates that the transmitter
    can send more data.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read data register not empty** (**RXNE**): This bit indicates that the data
    register contains data that has not been read yet. It signals that there is incoming
    data to be processed.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transmission complete** (**TC**): This bit is set when the last transmission
    has been completed, including all the stop bits. It shows that the data has been
    fully sent.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overrun error** (**ORE**): This bit indicates that the data was lost because
    the data register wasn’t read before new data arrived. It flags an error condition.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find detailed information about this register on *page 547* of the *STM32F411
    reference manual (RM0383)*. Next, we have the `USART_DR`).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: USART Data Register (USART_DR)
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `USART_DR` register is used for both transmitting and receiving data. It
    acts as the primary interface for data exchange through the UART peripheral.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key functions in this register:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '`USART_DR` sends the data through the TX line. The UART peripheral handles
    the conversion and transmission serially.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USART_DR` retrieves the data received on the RX line. This should be done
    promptly to avoid data overrun.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have the `USART_BRR`).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: USART Baud Rate Register (USART_BRR)
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `USART_BRR` register is used to set the baud rate for the UART communication,
    which is critical for synchronizing the data transfer speed between devices.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'This register has two fields:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**Mantissa**: The integer part of the division factor that sets the baud rate'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fraction**: The fractional part of the division factor that fine-tunes the
    baud rate'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final register we will examine is the `USART_CR1`).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: USART Control Register 1 (USART_CR1)
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `USART_CR1` register is a comprehensive control register that enables various
    UART functionalities and configurations.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the key bits in this register:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '**USART enable** (**UE**): This bit enables or disables the UART peripheral.
    It must be set to activate UART communication.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Word length** (**M**): This bit configures the word length, allowing 8-bit
    or 9-bit data frames.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parity control enable** (**PCE**): This bit enables parity checking for error
    detection.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parity selection** (**PS**): This bit selects even or odd parity.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transmitter enable** (**TE**): This bit enables the transmitter, allowing
    data to be sent.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receiver enable** (**RE**): This bit enables the receiver, allowing data
    to be received.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these registers in mind, we’re now ready to develop the UART driver. We
    will dive into that in the next section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Developing the UART driver
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will apply everything we’ve learned about the UART peripheral
    to develop a driver for transmitting data using the `USART2` peripheral.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by identifying the GPIO pins connected to the UART2 peripheral.
    To do this, refer to the table on *page 39* of the *STM32F411RE datasheet*. This
    table lists all the GPIO pins of the microcontroller, along with their descriptions
    and additional functionalities. As shown in *Figure 10**.3*, part of this table
    reveals that PA1 has an alternate function labeled as `USART2_TX`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: The USART2_TX pin](img/B21914_10_3.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: The USART2_TX pin'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'To use PA2 as the `USART2_TX` line, we need to configure `PA2` as an alternate
    function pin in the `GPIOA_MODER` register and then specify the alternate function
    number for `USART2_TX` in the `GPIOA_AFRL` register. The STM32F4 microcontroller
    allows us to choose from 16 different alternate functions, numbered from `AF00`
    to `AF15`. The alternate function mapping table, which you can find on *page 47*
    of the datasheet, outlines these functions and their corresponding numbers. As
    shown in *Figure 10**.4*, sourced from the datasheet, configuring `PA2` as `AF07`
    will set it to function as the `USART2_TX` line:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: PA2 alternate function](img/B21914_10_4.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: PA2 alternate function'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the information we need to develop the UART2 transmitter driver.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a copy of your previous project and rename it `UART`. Next, create a
    new file named `uart.c` in the `Src` folder and another file named `uart.h` in
    the `Inc` folder. Populate your `uart.c` file with the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s break it down.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: First, we have the necessary includes and macros.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here are the uses of the macros:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '`GPIOAEN`: This macro enables the clock for GPIOA by setting bit 0 in the `AHB1ENR`
    register.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UART2EN`: This macro enables the clock for UART2 by setting bit 17 in the
    `APB1ENR` register.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DBG_UART_BAUDRATE`: This macro defines the baud rate for UART communication,
    set to `115200` bps.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SYS_FREQ`: This macro defines the system frequency, set to 16 MHz, and the
    default frequency of the STM32F411 microcontroller on the NUCLEO development board.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APB1_CLK`: This macro sets the APB1 peripheral clock frequency to the system
    frequency (16 MHz).'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CR1_TE`: This macro enables the transmitter by setting bit 3 in the `USART_CR1`
    register.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CR1_UE`: This macro enables the UART module by setting bit 13 in the `USART_CR1`
    register.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SR_TXE`: This macro represents the TXE bit in the `USART_SR` register.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we have the helper functions for computing and setting the baud rate:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This helper function calculates the baud rate divisor. It uses the peripheral
    clock and desired baud rate to compute the value to be set in the **Baud Rate**
    **Register** (**BRR**):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function sets the baud rate for UART2 by writing the computed divisor
    to the BRR. Let’s turn our focus to the initialization function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This line enables the clock for GPIOA by setting the appropriate bit in the
    AHB1 peripheral clock enable register:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These lines configure pin PA2 to operate in alternate function mode, which
    is necessary for UART functionality:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These lines configure PA2 as an alternate function (`AF7`), which corresponds
    to `UART2_TX`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This line enables the clock for UART2 by setting the appropriate bit in the
    APB1 peripheral clock enable register:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function call sets the baud rate for UART2 using the `uart_set_baudrate()`
    function:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This configures UART2 for transmission by setting the transmitter enable bit
    in the control register:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This enables the UART2 module by setting the UART enable bit in the control
    register.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the function for writing to UART:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s break it down:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This loop ensures that the transmit data register is empty before we write
    new data:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This line writes the character to the data register for transmission.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have a useful function that allows us to redirect `printf` output
    to our UART transmitter:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It calls `uart_write()` to send the character and then returns the character.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: After sending the character, `__io_putchar` returns the same character, `ch`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Returning the character is a standard practice, allowing the function to comply
    with the typical `putchar` function signature, which returns the character written
    as an `int` variable.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next task is to populate the `uart.h` file. Here’s the code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是填充`uart.h`文件。以下是代码：
- en: '[PRE15]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#include <stdio.h>'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <stdio.h>'
- en: '#include "uart.h"'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "uart.h"'
- en: int main(void)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: int main(void)
- en: '{'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: /*Initialize debug UART*/
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: /*初始化调试串口*/
- en: uart_init();
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: uart_init();
- en: while(1)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: while(1)
- en: '{'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: printf("Hello from STM32...\r\n");
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: printf("来自STM32的问候...\r\n");
- en: '}'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE16]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
