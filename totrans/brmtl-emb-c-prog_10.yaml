- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Universal Asynchronous Receiver/Transmitter Protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the **universal asynchronous receiver/transmitter**
    (**UART**) protocol, an important communication method widely used in embedded
    systems. UART is fundamental for enabling communication between microcontrollers
    and various peripherals, making it an essential component in embedded systems
    development.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by discussing the significance of communication protocols in embedded
    systems and highlight common use cases for UART alongside other protocols such
    as SPI and I2C. Following this, we will provide a comprehensive overview of the
    UART protocol, detailing its operational principles and features. Next, we will
    extract and examine the relevant registers for UART from the STM32 reference manual,
    providing the necessary foundational knowledge for driver development. Finally,
    we will apply this knowledge to develop a bare-metal UART driver, illustrating
    the practical aspects of initializing and transmitting data via UART.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to communication protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of the UART protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The STM32F4 UART peripheral
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the UART driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good understanding of the UART protocol
    and the skills needed to develop bare-metal drivers for UART communication.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to communication protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of embedded systems, communication protocols are essential conduits
    that enable microcontrollers and peripheral devices to talk to each other seamlessly.
    Think of them as the languages that different devices use to understand and exchange
    information, ensuring that everything from your smartphone to your smart home
    devices works smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into what communication protocols are, how they are grouped, their
    unique features and advantages, and explore some common use cases to see these
    protocols in action.
  prefs: []
  type: TYPE_NORMAL
- en: What are communication protocols?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Communication protocols are sets of rules and conventions that allow electronic
    devices to communicate with each other. These protocols define how data is formatted,
    transmitted, and received, ensuring that devices can exchange information accurately
    and reliably. Without these protocols, it would be like trying to have a conversation
    with someone who speaks a completely different language – communication would
    be chaotic and error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: In embedded systems, these protocols are crucial because they facilitate the
    interaction between microcontrollers and peripherals such as sensors, actuators,
    displays, and other microcontrollers. Whether it’s sending a simple temperature
    reading from a sensor to a microcontroller or streaming video data from a camera
    module, communication protocols make it happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze the classification of communication protocols, starting with
    the big picture: what communication protocols can be broadly classified into –
    **serial** and **parallel** communication.'
  prefs: []
  type: TYPE_NORMAL
- en: Serial versus parallel communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with serial communication.
  prefs: []
  type: TYPE_NORMAL
- en: Serial communication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this category, communication protocols can be further broken down into asynchronous
    and synchronous protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous**: This type of communication sends data one bit at a time without
    a clock signal to synchronize the sender and receiver. Think of it as sending
    letters through the mail without a scheduled delivery time. A common example is
    UART, which is simple and efficient for many applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synchronous**: Unlike asynchronous communication, this form of communication
    uses a clock signal to coordinate the transmission of bits. It’s like having a
    drumbeat to ensure everyone marches in step. Examples include **Serial Peripheral
    Interface** (**SPI**) and **Inter-Integrated Circuit** (**I2C**). These protocols
    ensure data integrity and timing, making them suitable for more complex tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel communication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This type involves transmitting multiple bits simultaneously over multiple channels.
    Imagine sending a whole fleet of cars instead of a single one – it’s faster but
    requires more lanes (or pins, in our case). While parallel communication is faster,
    it’s less common in embedded systems due to the higher pin count. Also, it’s prone
    to crosstalk and signal integrity problems, especially over longer distances.
  prefs: []
  type: TYPE_NORMAL
- en: We can also classify communication protocols based on their architecture. In
    this classification system, we have point-to-point communication and multi-device
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: Point-to-point versus multi-device communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s look at the differences.
  prefs: []
  type: TYPE_NORMAL
- en: Point-to-point
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a direct line of communication between two devices. **UART** is a classic
    example, where data flows directly between a microcontroller and a peripheral
    device. It’s straightforward, reliable, and ideal for many embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-device (bus) communication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here, multiple devices share the same communication lines, which can be either
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-master**: Multiple devices can control the communication bus. **I2C**
    is a great example as it allows multiple masters and slaves on the same bus. It’s
    like a group of friends taking turns talking in a conversation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Master-slave**: One master device controls the communication, directing traffic
    to and from multiple slave devices. **SPI** operates this way, with a single master
    communicating with multiple slaves through dedicated lines. **I2C** can also operate
    this way. It’s akin to a teacher (master) calling on students one at a time to
    speak.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, communication protocols can be classified based on their data flow capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Full-duplex versus half-duplex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s see the differences between full-duplex and half-duplex:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full-duplex**: This allows simultaneous two-way communication. Imagine a
    two-lane road where cars can travel in both directions at the same time. **UART**
    and **SPI** support full-duplex communication, making them highly efficient for
    real-time data exchange.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Half-duplex**: Here, communication can occur in both directions, but not
    at the same time – it’s like a single-lane road where cars must take turns. **I2C**
    typically operates in half-duplex mode, which works well for its intended applications
    but can be a limitation in high-speed data scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s closely compare the three common communication protocols that are
    used in modern embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing UART, SPI, and I2C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with UART.
  prefs: []
  type: TYPE_NORMAL
- en: UART
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some key features of UART:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous communication**: UART doesn’t require a clock signal. Instead,
    it uses start and stop bits to synchronize data transmission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full-duplex**: UART can send and receive data simultaneously, which is ideal
    for many applications requiring real-time communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple and cost-effective**: With minimal hardware requirements, UART is
    easy to implement and cost-effective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of its advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ease of use**: Setting up UART communication is straightforward, making it
    a popular choice for beginners and simple applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wide support**: UART is universally supported by most microcontrollers and
    peripheral devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low overhead**: The lack of a clock signal means fewer pins are used, reducing
    complexity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it also has some disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed limitations**: UART is generally slower compared to SPI and I2C, making
    it less suitable for high-speed data transfer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited distance**: Susceptibility to noise over long distances can limit
    the range of reliable communication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Point-to-point only**: UART is designed for direct, point-to-point communication,
    which can be a limitation if multiple devices need to communicate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have SPI.
  prefs: []
  type: TYPE_NORMAL
- en: SPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some key features of SPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous communication**: SPI uses a clock signal along with data lines,
    ensuring synchronized data transfer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full-duplex**: It allows data to be sent and received simultaneously'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Master-slave architecture**: One master device controls multiple slave devices,
    with dedicated lines for each'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of its advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**High speed**: SPI supports high-speed data transfer, making it ideal for
    applications requiring fast communication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versatility**: SPI can connect multiple devices with different configurations,
    providing flexibility in design'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it also has some disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**More pins required**: Each slave device needs a separate select line, which
    can increase the pin count significantly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No standardized acknowledgment**: Unlike I2C, SPI does not have a built-in
    acknowledgment mechanism, which can make error detection more challenging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited multi-master capability**: SPI is not designed for multi-master systems,
    which can be a limitation in some scenarios'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final common communication protocol we’ll cover is I2C.
  prefs: []
  type: TYPE_NORMAL
- en: I2C
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some key features of I2C:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous communication**: I2C uses a clock signal for synchronized data
    transfer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-master capability**: Multiple master devices can share the same bus,
    which is useful in more complex systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two-wire interface**: I2C requires only two lines (SDA and SCL) for communication,
    minimizing the pin count'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of its advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity in wiring**: The two-wire interface reduces the complexity and
    number of pins required'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-device support**: I2C easily connects multiple devices on the same
    bus, each with a unique address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in addressing**: I2C has a built-in addressing mechanism, making communication
    with multiple devices straightforward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it does have some disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Slower speed**: I2C is generally slower than SPI, which can be a limitation
    for high-speed applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex protocol**: The protocol is more complex than UART and SPI, requiring
    more sophisticated handling of data transfers and addressing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Susceptible to noise**: Like UART, I2C can be susceptible to noise over longer
    distances, potentially affecting communication reliability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right communication protocol depends on your specific application
    needs. If you need simple, straightforward communication and can tolerate slower
    speeds, **UART** is a great choice. For high-speed applications with a need for
    full-duplex communication, **SPI** is ideal, especially if you can manage the
    higher pin count. When you need to connect multiple devices with minimal wiring
    and have a complex communication setup, **I2C** is your go-to protocol. To help
    you better understand when to choose which protocol, let’s explore some common
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Common use cases for the UART, SPI, and I2C protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing embedded systems, selecting the right communication protocol
    is crucial for ensuring efficient and reliable data exchange. UART, SPI, and I2C
    each have unique strengths, making them suitable for different applications. Let’s
    explore the practical use cases and compelling case studies for each protocol,
    highlighting their professional and real-world relevance.
  prefs: []
  type: TYPE_NORMAL
- en: UART
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at some common use cases for the UART protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serial communication with PCs**: UART is often used for serial communication
    between microcontrollers and computers, particularly for debugging, firmware updates,
    and data logging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPS modules**: UART can be used to transmit location data from a GPS module
    to a microcontroller'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bluetooth modules**: UART enables wireless communication with devices via
    Bluetooth'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These use cases represent some of the most common applications of UART, but
    the protocol is versatile and can be used in many other scenarios that require
    simple serial communication.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – GPS module integration for autonomous drones
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you’re developing an autonomous drone that requires precise navigation
    to perform tasks such as surveying and mapping. Integrating a GPS module using
    UART can provide real-time location data essential for navigation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup**: Connect the GPS module’s transmit (TX) pin to the microcontroller’s
    receive (RX) pin and vice versa. Configure the baud rate so that it matches the
    GPS module’s output.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation**: The GPS module continuously sends NMEA sentences (text strings)
    containing location data. The microcontroller reads these strings via UART, parses
    them, and uses the location information to navigate the drone accurately.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantage**: UART’s simplicity and widespread support make it straightforward
    to integrate the GPS module, providing reliable and continuous data flow without
    a complex setup.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at SPI.
  prefs: []
  type: TYPE_NORMAL
- en: SPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are some common use cases for the SPI protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '**High-speed data transfer**: It’s ideal for applications such as memory cards,
    **analog-to-digital converters** (**ADCs**), **digital-to-analog converters**
    (**DACs**), and displays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Display modules**: SPI can be used for communicating with high-resolution
    displays requiring fast refresh rates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sensors and actuators**: SPI can handle high-frequency data outputs from
    various sensors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like UART, these examples highlight some typical uses of SPI, but the protocol’s
    high-speed capabilities make it suitable for a wide range of other applications
    requiring rapid data transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – SD card data logging for industrial equipment
  prefs: []
  type: TYPE_NORMAL
- en: Consider an industrial monitoring system that logs data from various sensors
    to an SD card for long-term analysis. SPI is the perfect protocol for this high-speed
    data transfer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup**: Connect the microcontroller to the SD card using SPI pins (MISO,
    MOSI, SCLK, and CS). Initialize the SPI bus and configure the SD card.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation**: The microcontroller collects data from sensors (for example,
    temperature, pressure, and vibration) and writes this data to the SD card in real
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantage**: SPI’s high-speed data transfer ensures that large amounts of
    data are logged quickly and efficiently, preventing any data loss and ensuring
    accurate monitoring.'
  prefs: []
  type: TYPE_NORMAL
- en: Using SPI in this scenario allows the industrial system to maintain precise
    logs of critical parameters, which are essential for predictive maintenance and
    operational efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have I2C.
  prefs: []
  type: TYPE_NORMAL
- en: I2C
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s consider two common use cases related to I2C:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple sensor integration systems**: This involves connecting several sensors
    with different addresses on the same I2C bus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Peripheral expansion**: This involves adding more GPIO pins to a microcontroller
    using I2C expanders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These use cases are just two examples of I2C’s applications. Its ability to
    support multiple devices on a single bus makes it an excellent choice for many
    other scenarios where scalability is important.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – environmental monitoring system for smart agriculture
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you’re developing a smart agriculture system that uses multiple sensors
    (temperature, humidity, and soil moisture) to optimize farming conditions. I2C
    is the ideal protocol for this multi-sensor integration.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup**: Connect all sensors to the I2C bus (SDA and SCL lines). Assign each
    sensor a unique address.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation**: The microcontroller queries each sensor in sequence, collects
    the data, and processes it to provide insights and control irrigation, ventilation,
    and lighting systems.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantage**: I2C’s ability to support multiple devices on the same bus with
    just two lines simplifies wiring, reduces costs, and saves GPIO pins, making it
    an efficient solution for complex sensor networks.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the next section, we’ll focus exclusively on the UART protocol.
    We’ll cover the I2C and SPI protocols in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the UART protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most fundamental and widely used protocols is UART. Whether you’re
    debugging hardware or enabling communication between a microcontroller and peripherals,
    understanding UART is crucial. Let’s delve into the workings of this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: What is UART?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UART is a hardware communication protocol that operates using asynchronous serial
    communication, allowing for adjustable data transmission speeds. The “asynchronous”
    nature of UART means it doesn’t require a clock signal to align the transmission
    of bits between the sender and receiver. Instead, both devices must agree on a
    specific baud rate, which dictates the speed at which data is exchanged. Let’s
    take a look at the interface.
  prefs: []
  type: TYPE_NORMAL
- en: The interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The UART interface employs two wires for communication: TX and RX. To establish
    a connection between two devices, we simply connect the TX pin of the first device
    to the RX pin of the second device, and the RX pin of the first device to the
    TX pin of the second device. Additionally, it’s crucial to connect the ground
    pins of both devices to ensure a common electrical reference. *Figure 10**.1*
    shows the connection between two UART devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: The UART interface](img/B21914_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: The UART interface'
  prefs: []
  type: TYPE_NORMAL
- en: How UART works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data in UART is transmitted as frames containing a **start bit**, **data bits**,
    an optional **parity bit**, and **stop bits**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: The UART data packet](img/B21914_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: The UART data packet'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a step-by-step breakdown of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start bit**: The transmission line is normally held high. To start the data
    transfer, the transmitting UART pulls the line low for one clock cycle. This indicates
    the start of a new data frame.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data frame**: Following the start bit, the data frame typically consists
    of 5 to 9 bits and is sent from the **least significant bit** (**LSB**) to the
    **most significant** **bit** (**MSB**).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Parity bit**: This is optional and is used for error checking. It ensures
    that the number of set bits (1s) in the data is even or odd.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Stop bits**: This is one or two bits indicating the end of the data packet.
    The line is driven high during the stop bits.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s take a closer look at the start, stop, and parity bits.
  prefs: []
  type: TYPE_NORMAL
- en: The start, stop, and parity bits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These bits form the backbone of the UART protocol, allowing devices to synchronize
    and verify the integrity of the transmitted data.
  prefs: []
  type: TYPE_NORMAL
- en: Start bit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The start bit is the initial signal that marks the beginning of a data frame
    in UART communication. When the transmitting device is idle, the data line is
    held at a high voltage level (logic 1). To signal the start of transmission, the
    UART transmitter pulls the line to a low voltage level (logic 0) for a 1-bit duration.
    This transition from high to low alerts the receiving device that a new data packet
    is incoming, allowing it to synchronize and prepare for data reception.
  prefs: []
  type: TYPE_NORMAL
- en: Stop bit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After the data bits and optional parity bit are transmitted, the stop bit signals
    the end of the data frame. The transmitter drives the data line back to a high
    voltage level (logic 1) for 1 or 2-bit durations, depending on the configuration.
    The stop bit(s) ensure that the receiver has time to process the last data bit
    and prepare for the next start bit. In essence, the stop bit acts as a buffer,
    providing a clear demarcation between successive data frames and helping maintain
    synchronization between the communicating devices.
  prefs: []
  type: TYPE_NORMAL
- en: Parity bit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The parity bit is an optional feature that’s used for basic error checking
    in UART communication. It provides a simple method to detect errors that may have
    occurred during data transmission. The parity bit can be configured for either
    even or odd parity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Even parity**: The parity bit is set to 0 if the number of 1s in the data
    frame is even, and set to 1 if the number of 1s is odd. This ensures that the
    total number of 1s (including the parity bit) is even.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Odd parity**: The parity bit is set to 0 if the number of 1s in the data
    frame is odd, and set to 1 if the number of 1s is even. This ensures that the
    total number of 1s (including the parity bit) is odd.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the receiver gets the data frame, it checks the parity bit against the
    received data bits. If there’s a mismatch, it indicates that an error occurred
    during transmission. While parity doesn’t correct errors, it helps in identifying
    them, prompting for retransmission if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The start, stop, and parity bits are essential components of UART communication,
    each playing a critical role in ensuring data integrity and synchronization. The
    start bit signals the beginning of transmission, the stop bit marks the end, and
    the parity bit provides a basic error-checking mechanism. Together, they create
    a robust framework for reliable and efficient serial communication between devices.
  prefs: []
  type: TYPE_NORMAL
- en: Before wrapping up this section, let’s take a moment to understand the unit
    of speed that’s used in UART communication.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the baud rate – the speed of communication in embedded systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the world of embedded systems, **baud rate** is a term you’ll encounter frequently.
    Whether you’re debugging a microcontroller, setting up a serial communication
    link, or working with various peripherals, understanding the baud rate is essential.
    But what exactly is the baud rate, and why is it so important? Let’s break it
    down.
  prefs: []
  type: TYPE_NORMAL
- en: What is the baud rate?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The baud rate is essentially the speed at which data is transmitted over a
    communication channel. It’s measured in **bits per second** (**bps**). Think of
    it as the speed limit on a highway: the higher the baud rate, the more data can
    travel along the communication path in a given amount of time.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, a baud rate of *9,600* means *9,600 bits* of data are transmitted
    each *second*. In other words, it sets the pace for how fast data packets are
    sent and received.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s important to distinguish between the baud rate and the **bit rate**.
    While the baud rate refers to the number of signal changes per second, the bit
    rate is the number of bits transmitted per second. In simple systems, *each signal
    change can represent one bit*, making the baud rate and bit rate the same. In
    more complex systems, each signal change can represent multiple bits, resulting
    in a bit rate higher than the baud rate.
  prefs: []
  type: TYPE_NORMAL
- en: Why does the baud rate matter?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine trying to have a conversation with someone who speaks at a wildly different
    speed than you. It would be confusing and inefficient, right? The same principle
    applies to electronic devices communicating with each other. Both the transmitting
    and receiving devices need to agree on a common baud rate to understand each other
    correctly. If they don’t, the data might get lost or garbled, leading to communication
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: For successful communication, both the sender and receiver must have the same
    baud rate to synchronize correctly. If one device is set to 9,600 bps and the
    other to 115,200 bps, the communication will fail, similar to how a conversation
    fails if one person is speaking too fast or too slow for the other to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are standard baud rates that are commonly used in serial communication.
    Here are a few:'
  prefs: []
  type: TYPE_NORMAL
- en: '**300 bps**: Very slow, often used for long-distance communication where bandwidth
    is limited'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**9,600 bps**: A widely used default rate for many devices, including microcontrollers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**19,200 bps**: Faster, often used in more data-intensive applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**115,200 bps**: High-speed communication, common in applications requiring
    quick data transfer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our overview of the UART protocol. In the next section, we will
    explore the UART peripheral in the STM32F4 microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32F4 UART peripheral
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'STM32 microcontrollers often include several UART peripherals, though the number
    varies depending on the specific model. The STM32F411 microcontroller has three
    UART peripherals:'
  prefs: []
  type: TYPE_NORMAL
- en: USART1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USART2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USART6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USART versus UART
  prefs: []
  type: TYPE_NORMAL
- en: 'Our STM32 documentation refers to the UART peripheral as **USART** because
    it stands for universal **synchronous/asynchronous** receiver/transmitter. This
    name reflects the dual functionality of the peripheral:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous mode** (**UART**): In this mode, the USART operates as a traditional
    UART. It transmits and receives data without needing a clock signal, which is
    typical for standard serial communication.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous mode** (**USART**): In this mode, the USART can also operate
    with a synchronous clock signal, allowing it to communicate with devices that
    require a clock line in addition to the data lines.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s analyze the key registers of this peripheral, starting with the USART
    Status Register.
  prefs: []
  type: TYPE_NORMAL
- en: USART Status Register (USART_SR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `USART_SR` register is one of the main registers used to monitor the status
    of the UART peripheral. It provides real-time information about various operational
    flags and errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the key bits in this register:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transmit data register empty** (**TXE**): This bit is set when the data register
    is empty and ready for new data to be written. It indicates that the transmitter
    can send more data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read data register not empty** (**RXNE**): This bit indicates that the data
    register contains data that has not been read yet. It signals that there is incoming
    data to be processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transmission complete** (**TC**): This bit is set when the last transmission
    has been completed, including all the stop bits. It shows that the data has been
    fully sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overrun error** (**ORE**): This bit indicates that the data was lost because
    the data register wasn’t read before new data arrived. It flags an error condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find detailed information about this register on *page 547* of the *STM32F411
    reference manual (RM0383)*. Next, we have the `USART_DR`).
  prefs: []
  type: TYPE_NORMAL
- en: USART Data Register (USART_DR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `USART_DR` register is used for both transmitting and receiving data. It
    acts as the primary interface for data exchange through the UART peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key functions in this register:'
  prefs: []
  type: TYPE_NORMAL
- en: '`USART_DR` sends the data through the TX line. The UART peripheral handles
    the conversion and transmission serially.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USART_DR` retrieves the data received on the RX line. This should be done
    promptly to avoid data overrun.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have the `USART_BRR`).
  prefs: []
  type: TYPE_NORMAL
- en: USART Baud Rate Register (USART_BRR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `USART_BRR` register is used to set the baud rate for the UART communication,
    which is critical for synchronizing the data transfer speed between devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'This register has two fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mantissa**: The integer part of the division factor that sets the baud rate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fraction**: The fractional part of the division factor that fine-tunes the
    baud rate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final register we will examine is the `USART_CR1`).
  prefs: []
  type: TYPE_NORMAL
- en: USART Control Register 1 (USART_CR1)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `USART_CR1` register is a comprehensive control register that enables various
    UART functionalities and configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the key bits in this register:'
  prefs: []
  type: TYPE_NORMAL
- en: '**USART enable** (**UE**): This bit enables or disables the UART peripheral.
    It must be set to activate UART communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Word length** (**M**): This bit configures the word length, allowing 8-bit
    or 9-bit data frames.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parity control enable** (**PCE**): This bit enables parity checking for error
    detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parity selection** (**PS**): This bit selects even or odd parity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transmitter enable** (**TE**): This bit enables the transmitter, allowing
    data to be sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receiver enable** (**RE**): This bit enables the receiver, allowing data
    to be received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these registers in mind, we’re now ready to develop the UART driver. We
    will dive into that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the UART driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will apply everything we’ve learned about the UART peripheral
    to develop a driver for transmitting data using the `USART2` peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by identifying the GPIO pins connected to the UART2 peripheral.
    To do this, refer to the table on *page 39* of the *STM32F411RE datasheet*. This
    table lists all the GPIO pins of the microcontroller, along with their descriptions
    and additional functionalities. As shown in *Figure 10**.3*, part of this table
    reveals that PA1 has an alternate function labeled as `USART2_TX`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: The USART2_TX pin](img/B21914_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: The USART2_TX pin'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use PA2 as the `USART2_TX` line, we need to configure `PA2` as an alternate
    function pin in the `GPIOA_MODER` register and then specify the alternate function
    number for `USART2_TX` in the `GPIOA_AFRL` register. The STM32F4 microcontroller
    allows us to choose from 16 different alternate functions, numbered from `AF00`
    to `AF15`. The alternate function mapping table, which you can find on *page 47*
    of the datasheet, outlines these functions and their corresponding numbers. As
    shown in *Figure 10**.4*, sourced from the datasheet, configuring `PA2` as `AF07`
    will set it to function as the `USART2_TX` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: PA2 alternate function](img/B21914_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: PA2 alternate function'
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the information we need to develop the UART2 transmitter driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a copy of your previous project and rename it `UART`. Next, create a
    new file named `uart.c` in the `Src` folder and another file named `uart.h` in
    the `Inc` folder. Populate your `uart.c` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break it down.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have the necessary includes and macros.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the uses of the macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GPIOAEN`: This macro enables the clock for GPIOA by setting bit 0 in the `AHB1ENR`
    register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UART2EN`: This macro enables the clock for UART2 by setting bit 17 in the
    `APB1ENR` register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DBG_UART_BAUDRATE`: This macro defines the baud rate for UART communication,
    set to `115200` bps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SYS_FREQ`: This macro defines the system frequency, set to 16 MHz, and the
    default frequency of the STM32F411 microcontroller on the NUCLEO development board.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APB1_CLK`: This macro sets the APB1 peripheral clock frequency to the system
    frequency (16 MHz).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CR1_TE`: This macro enables the transmitter by setting bit 3 in the `USART_CR1`
    register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CR1_UE`: This macro enables the UART module by setting bit 13 in the `USART_CR1`
    register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SR_TXE`: This macro represents the TXE bit in the `USART_SR` register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we have the helper functions for computing and setting the baud rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This helper function calculates the baud rate divisor. It uses the peripheral
    clock and desired baud rate to compute the value to be set in the **Baud Rate**
    **Register** (**BRR**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This function sets the baud rate for UART2 by writing the computed divisor
    to the BRR. Let’s turn our focus to the initialization function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This line enables the clock for GPIOA by setting the appropriate bit in the
    AHB1 peripheral clock enable register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines configure pin PA2 to operate in alternate function mode, which
    is necessary for UART functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines configure PA2 as an alternate function (`AF7`), which corresponds
    to `UART2_TX`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This line enables the clock for UART2 by setting the appropriate bit in the
    APB1 peripheral clock enable register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This function call sets the baud rate for UART2 using the `uart_set_baudrate()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This configures UART2 for transmission by setting the transmitter enable bit
    in the control register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This enables the UART2 module by setting the UART enable bit in the control
    register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the function for writing to UART:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This loop ensures that the transmit data register is empty before we write
    new data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This line writes the character to the data register for transmission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have a useful function that allows us to redirect `printf` output
    to our UART transmitter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It calls `uart_write()` to send the character and then returns the character.
  prefs: []
  type: TYPE_NORMAL
- en: After sending the character, `__io_putchar` returns the same character, `ch`.
  prefs: []
  type: TYPE_NORMAL
- en: Returning the character is a standard practice, allowing the function to comply
    with the typical `putchar` function signature, which returns the character written
    as an `int` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next task is to populate the `uart.h` file. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '#include <stdio.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "uart.h"'
  prefs: []
  type: TYPE_NORMAL
- en: int main(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*Initialize debug UART*/
  prefs: []
  type: TYPE_NORMAL
- en: uart_init();
  prefs: []
  type: TYPE_NORMAL
- en: while(1)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: printf("Hello from STM32...\r\n");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
