- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mastering Abstract Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue expanding our knowledge of object-oriented programming
    in C++. We will begin by exploring a powerful OO concept, **abstract classes**,
    and then progress to understanding how this idea is implemented in C++ through
    *direct language support*.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement abstract classes using pure virtual functions to ultimately
    support refinements in a hierarchy of related classes. We will understand how
    abstract classes augment and pair with our understanding of polymorphism. We will
    also recognize how the OO concept of abstract classes presented in this chapter
    will support powerful and adaptable designs, allowing us to create easily extensible
    C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OO concept of an abstract class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing abstract classes with pure virtual functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating interfaces using abstract classes and pure virtual functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generalizing derived class objects using abstract classes, and upcasting and
    downcasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the OO concept of an abstract
    class, and how to implement this idea in C++ through pure virtual functions. You
    will learn how abstract classes containing only pure virtual functions can define
    an OOP concept of an interface. You will understand how abstract classes and interfaces
    contribute to powerful OO designs.
  prefs: []
  type: TYPE_NORMAL
- en: You will see how we can very easily generalize groups of related, specialized
    objects using sets of abstract types. We will further explore up and downcasting
    within the hierarchy to understand what is allowed and when such typecasting is
    reasonable to employ.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding the direct language support of abstract classes in C++ using
    pure virtual functions, as well as why creating interfaces is useful, you will
    have more tools available to create an extensible hierarchy of related classes.
    Let us expand our understanding of C++ as an OOP language by understanding how
    these concepts are implemented in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter08](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter08).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in this chapter can be found in the subdirectory `Chapter08`
    in a file named `Chp8-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3SZv0jy](https://bit.ly/3SZv0jy).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OO concept of an abstract class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce an essential object-oriented concept, that
    of an abstract class. This concept will add to your growing knowledge base of
    key OO ideas including encapsulation, information hiding, generalization, specialization,
    and polymorphism. You know how to encapsulate a class. You also know how to build
    inheritance hierarchies using single inheritance, and various reasons to build
    hierarchies, such as supporting *Is-A* relationships or for the lesser-used reason
    of supporting implementation inheritance. Furthermore, you know how to employ
    runtime binding of methods to operations using the concept of polymorphism, implemented
    by virtual functions. Let’s extend our growing OO terminology by exploring **abstract
    classes**.
  prefs: []
  type: TYPE_NORMAL
- en: An **abstract class** is a base class that is intended to collect commonalities
    that may exist in derived classes for the purpose of asserting a common interface
    (that is, a set of operations) on the derived class. An abstract class does not
    represent a class that is intended for instantiation. Only objects of the derived
    class types may be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by looking at the C++ language feature that allows us to implement
    abstract classes, that is, pure virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing abstract classes with pure virtual functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An abstract class is specified by introducing at least one abstract method (that
    is, a pure virtual function prototype) in the class definition. The OO concept
    of an **abstract method** is the specification of an operation with only its protocol
    for usage (that is, with only the *name* and *signature* of the member function),
    but with no definition for the function. An abstract method will be polymorphic,
    in that, having no definition, it is expected to be redefined by derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `=0` after the arguments to the function. Additionally, it is important to
    understand the following nuances regarding pure virtual functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, definitions for pure virtual functions are not provided. This equates
    to the operation (prototype only) being specified at the base class level and
    all methods (member function definitions) being supplied at the derived class
    level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derived classes that do not provide methods for all pure virtual functions introduced
    by their base classes are also considered abstract and are therefore not instantiable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `=0` in the prototype is merely an indication to the linker that a definition
    for this function need not be linked in (or resolved) when creating an executable
    program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class is designated by including one or more pure virtual function
    prototypes in the class definition. The optional definitions for these methods
    are not typically provided.
  prefs: []
  type: TYPE_NORMAL
- en: The reason that pure virtual functions will most often not have a definition
    is because they are meant to provide a protocol of usage for polymorphic operations
    to be implemented in descendent classes. A pure virtual function designates a
    class to be abstract; an abstract class cannot be instantiated. Therefore, a definition
    provided in a pure virtual function will never be selected as the appropriate
    method for a polymorphic operation because instances of the abstract type will
    never exist. That being said, a pure virtual function can still provide a definition
    that could be explicitly called using the scope resolution operator (`::`) and
    base class name. Perhaps, this default behavior might be meaningful as a helper
    function used by derived class implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with a brief overview of the syntax required to specify an abstract
    class. Remember, a potential keyword of *abstract* is not used to specify an abstract
    class. Rather, by merely introducing one or more pure virtual functions, we have
    indicated the class to be an abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the abstract class definition, we have introduced four virtual
    functions, three of which are pure virtual functions. The virtual destructor has
    no memory to release but is indicated as `virtual` so that it will be polymorphic,
    and so that the correct destruction sequence can be applied to derived class instances
    stored as pointers to base class types.
  prefs: []
  type: TYPE_NORMAL
- en: The three pure virtual functions, `Print()`, `IsA()`, and `Speak()`, are indicated
    with `=0` in their prototype. There are no definitions for these operations (though
    there optionally can be). A pure virtual function can have a default implementation,
    but not as an inline function. It will be the derived class’ responsibility to
    provide methods for these operations using the interface (that is, signature)
    specified by this base class definition. Here, the pure virtual functions provide
    the *interface* for the polymorphic operations that will be defined in derived
    class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes will certainly have derived classes (since we cannot instantiate
    an abstract class itself). In order to allow the virtual destructor mechanism
    to work appropriately in the eventual hierarchy, be sure to include a *virtual
    destructor* in the abstract class definition. This will ensure that all derived
    class destructors are *virtual*, and can be overridden to provide the correct
    entry point in an object’s destruction sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a deeper look at what it means to have an interface, from an
    OO perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Creating interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **interface class** is an OO concept of a class that is a further refinement
    of an abstract class. Whereas an abstract class can contain generalized attributes
    and default behaviors (by including data members and default definitions for pure
    virtual functions or by providing non-virtual member functions), an interface
    class will only contain abstract methods. An abstract class in C++ containing
    only abstract methods (that is, pure virtual functions with no optional definitions)
    can be thought of as an **interface class**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When considering interface classes as implemented in C++, it is useful to remember
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes are not instantiable; they provide (via inheritance) the interfaces
    (that is, operations) that a derived class must offer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although a pure virtual function may contain an optional implementation (that
    is, method body) in the abstract class, this implementation should not be provided
    if the class wishes to be considered an interface class in pure OO terms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although an abstract class may have data members, it should not if the class
    wishes to be considered an interface class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract method, in OO terms, is an operation without a method; it is the
    interface only and is implemented in C++ as a pure virtual function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a reminder, be sure to include a virtual destructor prototype in the interface
    class definition; this will ensure that derived class destructors will be virtual.
    The destructor definition should be empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s consider various motivations for having interface classes within our OOP
    arsenal of implementation techniques. Some OOP languages follow very strict OO
    concepts and only allow for the implementation of very pure OO designs. Other
    OOP languages, such as C++, offer more flexibility, by allowing more radical OOP
    ideas to be implemented by the language directly.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in pure object-oriented terms, inheritance should be reserved for
    *Is-A* relationships. We’ve seen implementation inheritance, which C++ supports
    through private and protected base classes. We’ve seen some acceptable uses of
    implementation inheritance, that is, to implement a new class in terms of another
    (with the ability to hide the underlying implementation with the use of protected
    and public base classes).
  prefs: []
  type: TYPE_NORMAL
- en: Another example of a fringe OOP feature is that of multiple inheritance. We’ll
    see in [*Chapter 9*](B19087_09.xhtml#_idTextAnchor426), *Exploring Multiple Inheritance*,
    that C++ allows a class to be derived from more than one base class. In some cases,
    we are truly saying that the derived class has an Is-A relationship with potentially
    many base classes, but not always.
  prefs: []
  type: TYPE_NORMAL
- en: Some OOP languages do not allow multiple inheritance and those that do not rely
    more on interface classes to mix in the functionality of (otherwise) multiple
    base classes. In these situations, the OOP language can allow a derived class
    to implement the functionality as specified in multiple interface classes without
    actually using multiple inheritance. Ideally, interfaces are used to *mix-in*
    functionality from multiple classes. These classes, not surprisingly, are sometimes
    referred to as **mix-in** classes. In these situations, we are not saying that
    the Is-A relationship necessarily applies between derived and base classes.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, when we introduce an abstract class with only pure virtual functions,
    we can think of creating an interface class. When a new class mixes in functionality
    from multiple interfaces, we can think of this in OO terms as using each interface
    class as a means to mix-in the desired interfaces for behaviors. Note that the
    derived classes must override each of the pure virtual functions with their own
    implementation; we’re mixing in only the required API.
  prefs: []
  type: TYPE_NORMAL
- en: C++’s implementation of the OO concept of an interface is merely that of an
    abstract class containing only pure virtual functions. Here, we’re using public
    inheritance from an abstract class paired with polymorphism to simulate the OO
    concept of an interface class. Note that other languages (such as Java) implement
    this idea directly in the language (but then those languages do not support multiple
    inheritance). In C++, we can do almost anything, yet it remains important to understand
    how to implement OO ideals (even those not offered with direct language support)
    in reasonable and meaningful ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example to illustrate an abstract class used to implement an interface
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned class definitions, we first notice a simple interface
    class, `Charitable`, implemented using a restricted abstract class. We include
    no data members and a pure virtual function `virtual void Give(float) = 0;` to
    define the interface class. We also include a virtual destructor.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `Person` is derived from `Charitable` using public inheritance to implement
    the `Charitable` interface. We simply override `virtual void Give(float);` to
    provide a default definition for *giving*. We then derive `Student` from `Person`;
    note that a *Student Is-A Person that mixes-in (or implements) the Charitable
    interface*. In our `Student` class, we choose to redefine `virtual void Give(float);`
    to provide a more suitable `Give()` definition for `Student` instances. Perhaps
    students have limited finances and opt to donate an amount of their time that
    is equivalent to a predetermined monetary amount.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have used an abstract class in C++ to model the OO concept of an interface
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue with our discussion relating to abstract classes overall by examining
    how derived class objects may be collected by abstract class types.
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing derived class objects as abstract types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve seen in [*Chapter 7*](B19087_07.xhtml#_idTextAnchor366), *Utilizing Dynamic
    Binding through Polymorphism*, that it is reasonable at times to group related
    derived class instances in a collection that is stored using base class pointers.
    Doing so allows uniform processing of related derived class types using polymorphic
    operations as specified by the base class. We also know that when a polymorphic
    base class operation is invoked, the correct derived class method will be invoked
    at runtime by virtue of the virtual functions and internal v-table that implement
    polymorphism in C++.
  prefs: []
  type: TYPE_NORMAL
- en: You may contemplate, however, whether it is possible to collect a group of related
    derived class types by a base class type that is an abstract class. Remember,
    an abstract class is not instantiable, so how might we store a derived class object
    as an object that cannot be instantiated? The solution is to use *pointers* (or
    even a reference). Whereas we cannot collect derived class instances in a set
    of abstract base class instances (those types cannot be instantiated), we can
    collect derived class instances in a set of pointers of the abstract class type.
    We may also have a reference of the abstract class type refer to a derived class
    instance. We’ve been doing this type of grouping (with base class pointers) since
    we learned about polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Generalized groups of specialized objects employ implicit upcasting. Undoing
    such an upcast must be done using an explicit downcast, and the programmer will
    need to be correct as to the derived type that has been previously generalized.
    An incorrect downcast to the wrong type will cause a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: When is it necessary to collect derived class objects by base class types, including
    abstract base class types? The answer is when it makes sense in your application
    to process related derived class types in a more generic way, that is, when the
    operations specified in the base class type account for all of the operations
    you’d like to utilize. Undeniably, you may find just as many situations where
    keeping derived class instances in their own type (to utilize specialized operations
    introduced at the derived class level) is reasonable. Now you understand what
    is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue by examining a comprehensive example showing abstract classes
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: Putting all the pieces together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have understood the subtleties of abstract classes,
    including pure virtual functions, and how to create interface classes using abstract
    classes and pure virtual functions. It is always important to see our code in
    action, with all its various components and their various nuances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a more complex, full program example to fully illustrate
    abstract classes, implemented using pure virtual functions in C++. In this example,
    we will not further designate an abstract class as an interface class, but we
    will take the opportunity to collect related derived class types using a set of
    pointers of their abstract base class type. This example will be broken into many
    segments; the full program can be found in the following GitHub location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter08/Chp8-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter08/Chp8-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned class definition, we notice that `LifeForm` is an abstract
    class. It is an abstract class because it contains at least one pure virtual function
    definition. In fact, it contains three pure virtual function definitions, namely
    `Print()`, `IsA()`, and `Speak()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s extend `Lifeform` with a concrete derived class, `Cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, we see the class definition for `Cat`. Notice
    that `Cat` has redefined `LifeForm`’s pure virtual functions `Print()`, `IsA()`,
    and `Speak()` by providing definitions for each of these methods in the `Cat`
    class. With the existing methods in place for these functions, any derived class
    of `Cat` may optionally choose to redefine these methods with more suitable versions
    (but they are no longer obligated to do so).
  prefs: []
  type: TYPE_NORMAL
- en: Note that if `Cat` had failed to redefine even one of the pure virtual functions
    of `LifeForm`, then `Cat` would also be considered an abstract class and therefore
    not instantiable.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, even though virtual functions `IsA()` and `Speak()` are written
    inline to abbreviate the code, virtual functions will almost never be inlined
    by the compiler, as their correct method must be determined at runtime (except
    for a few cases involving compiler devirtualization, involving final methods,
    or when an instance’s dynamic type is known).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the `Cat` constructors, the member initialization list is used
    to select the `LifeForm` constructor that takes an integer argument (that is,
    `:LifeForm(CAT_LIFE)`). A value of `15` (`CAT_LIFE`) is passed up to the `LifeForm`
    constructor to initialize `lifeExpectancy`, defined in `LifeForm`, to the value
    of `15`. The member initialization list is additionally used to initialize data
    members defined in the `Cat` class for the cases when in-class initialization
    is not used (that is, the value is determined by a parameter to the method).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s move forward to the class definition for `Person`, along with its
    inline functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `Person` now extends `LifeForm` using public inheritance. In previous
    chapters, `Person` was a base class at the top of the inheritance hierarchy. `Person`
    redefines the pure virtual functions from `LifeForm`, namely, `Print()`, `IsA()`,
    and `Speak()`. As such, `Person` is now a concrete class and can be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s review the member function definitions for `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the `Person` member functions, notice that we have implementations for `Print()`,
    `IsA()`, and `Speak()`. Additionally, notice that in two of the `Person` constructors,
    we select `:LifeForm(PERSON_LIFE)` in their member initialization lists to call
    the `LifeForm(int)` constructor. This call will set the private inherited data
    member `LifeExpectancy` to `80` (`PERSON_LIFE`) in the `LifeForm` subobject of
    a given `Person` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s review the `Student` class definition, along with its inline function
    definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned class definition for `Student` looks much as we’ve seen in
    the past. `Student` extends `Person` using public inheritance because a `Student`
    *Is-A* `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, we’ll recall the non-inline `Student` class member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the previously listed section of code, we see the non-inline member function
    definitions for `Student`. The complete class definition is, at this point, largely
    familiar to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, let’s examine the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, in `main()`, we declare an array of pointers to `LifeForn`. Recall, `LifeForm`
    is an abstract class. We could not create an array of `LifeForm` objects, because
    that would require us to be able to instantiate a `LifeForm`; we can’t – `LifeForm`
    is an abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can create a set of pointers to an abstract type and this allows
    us to collect related types, `Person`, `Student`, and `Cat` instances in this
    set. Of course, the only operations we may apply to instances stored in this generalized
    fashion are those found in the abstract base class, `LifeForm`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we allocate a variety of `Person`, `Student`, and `Cat` instances, storing
    each instance via an element in the generalized set of pointers of type `LifeForm`.
    When any of these derived class instances is stored in this fashion, an implicit
    upcast to the abstract base class type is performed (but the instance is not altered
    in any fashion – we’re just pointing to the most base class subobject comprising
    the entire memory layout).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we proceed through a loop to apply operations as found in the abstract
    class `LifeForm` to all instances in this generalized collection, such as `Speak()`,
    `Print()`, and `IsA()`. These operations happen to be polymorphic, allowing each
    instance’s most appropriate implementation to be utilized via dynamic binding.
    We additionally invoke `GetLifeExpectancy()` on each of these instances, which
    is a non-virtual function found at the `LifeForm` level. This function merely
    returns the life expectancy of the `LifeForm` in question.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we loop through deleting the dynamically allocated instances of `Person`,
    `Student`, and `Cat` again using the generalized `LifeForm` pointers. We know
    that `delete()` will patch in a call to the destructor, and because the destructor
    is virtual, the appropriate starting level of the destructor and proper destruction
    sequence will commence. Additionally, by setting `item = nullptr;`, we are ensuring
    that the deleted pointer will not be used mistakenly as a bonafide address (we
    are overwriting each relinquished address with a `nullptr`).
  prefs: []
  type: TYPE_NORMAL
- en: The utility of the abstract class `LifeForm` in this example is that its use
    allows us to generalize common aspects and behaviors of all `LifeForm` objects
    together in one base class (such as `lifeExpectancy` and `GetLifeExpectancy()`).
    The common behaviors also extend to a set of pure virtual functions with the desired
    interfaces that all `LifeForm` objects should have, namely `Print()`, `IsA()`,
    and `Speak()`.
  prefs: []
  type: TYPE_NORMAL
- en: Important reminder
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class is one that collects common traits of derived classes, yet
    does not itself represent a tangible entity or object that should be instantiated.
    In order to specify a class as abstract, it must contain at least one pure virtual
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the output for the aforementioned program, we can see that objects
    of various related derived class types are instantiated and processed uniformly.
    Here, we’ve collected these objects by their abstract base class type and have
    overridden the pure virtual functions in the base class with meaningful definitions
    in various derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for the full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have now thoroughly examined the OO idea of an abstract class and how it
    is implemented in C++ using pure virtual functions, as well as how these ideas
    can extend to creating OO interfaces. Let’s briefly recap the language features
    and OO concepts we’ve covered in this chapter before moving onward to our next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have continued our progression with object-oriented programming,
    foremost, by understanding how pure virtual functions in C++ provide direct language
    support for the OO concept of an abstract class. We have explored how abstract
    classes without data members that do not contain non-virtual functions can support
    the OO ideal of an interface class. We’ve talked about how other OOP languages
    utilize interface classes, and how C++ may choose to support this paradigm as
    well by using such restricted abstract classes. We’ve upcast related derived class
    types to be stored as pointers of the abstract base class type, as a typical,
    and overall very useful, programming technique.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how abstract classes complement polymorphism not only by providing
    a class to specify common attributes and behaviors that derived classes share,
    but most notably to provide the interfaces of polymorphic behaviors for the related
    classes since abstract classes themselves are not instantiable.
  prefs: []
  type: TYPE_NORMAL
- en: By adding abstract classes and potentially the OO concept of interface classes
    to our programming repertoire in C++, we are able to implement designs that promote
    easily extensible code.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to continue to [*Chapter 9*](B19087_09.xhtml#_idTextAnchor426),
    *Exploring Multiple Inheritance*, to enhance our OOP skills by next learning how
    and when to appropriately utilize the concept of multiple inheritance, while understanding
    trade-offs and potential design alternatives. Let’s move forward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a hierarchy of shapes using the following guidelines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an abstract base class called `Shape`, which defines an operation to
    compute the area of a shape. Do not include a method for the `Area()` operation.
    Hint: use a pure virtual function.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Derive classes `Rectangle`, `Circle`, and `Triangle` from `Shape` using public
    inheritance. Optionally, derive class `Square` from `Rectangle`. Redefine the
    operation `Area()` that `Shape` has introduced, in each derived class. Be sure
    to provide the method to support the operation in each derived class so that you
    can later instantiate each type of `Shape`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add data members and other member functions as necessary to complete the newly
    introduced class definitions. Remember, only common attributes and operations
    should be specified in `Shape` – all others belong in their respective derived
    classes. Don’t forget to implement the copy constructor and access functions within
    each class definition.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an array of pointers of the abstract class type, `Shape`. Assign elements
    in this array point to instances of type `Rectangle`, `Square`, `Circle`, and
    `Triangle`. Since you are now treating derived class objects as generalized `Shape`
    objects, loop through the array of pointers and invoke the `Area()` function for
    each. Be sure to `delete()` any dynamically allocated memory you have allocated.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Is your abstract `Shape` class also an interface class in conceptual OO terms?
    Why, or why not?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
