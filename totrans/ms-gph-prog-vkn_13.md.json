["```cpp\n#extension GL_EXT_ray_query : enable\n```", "```cpp\nrayQueryEXT rayQuery;\nrayQueryInitializeEXT(rayQuery, as, gl_RayFlagsOpaqueEXT |\n    gl_RayFlagsTerminateOnFirstHitEXT, 0xff,\n        world_position, 0.001, l, d);\n```", "```cpp\nrayQueryProceedEXT( rayQuery );\n```", "```cpp\nif ( rayQueryGetIntersectionTypeEXT( rayQuery, true ) ==\n    gl_RayQueryCommittedIntersectionNoneEXT ) {\n        shadow = 1.0;\n}\n```", "```cpp\nfloat depth_diff = abs( 1.0 - ( previous_position_ndc.z /\n    current_position_ndc.z ) );\n```", "```cpp\nfloat c1 = 0.003;\nfloat c2 = 0.017;\nfloat eps = c1 + c2 * abs( view_normal.z );\n```", "```cpp\nvec2 visibility_motion = depth_diff < eps ? vec2(\n    current_position_ndc.xy - previous_position_ndc.xy ) :\n        vec2( -1, -1 );\n```", "```cpp\ngpu_commands->dispatch( x, y, render_scene->active_lights );\n```", "```cpp\nvec4 last_visibility_values = texelFetch(\n    global_textures_3d[ visibility_cache_texture_index ],\n        tex_coord, 0 );\nfloat max_v = max( max( max( last_visibility_values.x,\n    last_visibility_values.y ), last_visibility_values.z ),\n        last_visibility_values.w );\nfloat min_v = min( min( min( last_visibility_values.x,\n    last_visibility_values.y ), last_visibility_values.z ),\n        last_visibility_values.w );\nfloat delta = max_v - min_v;\n```", "```cpp\nlocal_image_data[ local_index.y ][ local_index.x ] =\n    texelFetch( global_textures_3d[ variation_texture_index\n        ], global_index, 0 ).r;\n```", "```cpp\nlocal_max_image_data[ local_index.y ][ local_index.x ] =\n    max_filter( local_index );\n```", "```cpp\nfor ( int y = -2; y <= 2; ++y  ) {\n    for ( int x = -2; x <= 2; ++x ) {\n        ivec2 xy = index.xy + ivec2( x, y );\n        float v = local_image_data[ xy.y ][ xy.x ];\n        max_v = max( max_v, v );\n    }\n}\n```", "```cpp\nfloat spatial_filtered_value = 0.0;\nfor ( int y = -6; y <= 6; ++y ) {\n    for ( int x = -6; x <= 6; ++x ) {\n        ivec2 index = local_index.xy + ivec2( x, y );\n        float v = local_max_image_data[ index.y ][ index.x\n        ];\n        float f = tent_kernel[ y + 6 ][ x + 6 ];\n        spatial_filtered_value += v * f;\n    }\n}\n```", "```cpp\nvec4 last_variation_values = texelFetch(\n    global_textures_3d[ variation_cache_texture_index ],\n        global_index, 0 );\nfloat filtered_value = 0.5 * ( spatial_filtered_value +\n   0.25 * ( last_variation_values.x +\n          last_variation_values.y +\n          last_variation_values.z +\n          last_variation_values.w ) );\n```", "```cpp\nlast_variation_values.w = last_variation_values.z;\nlast_variation_values.z = last_variation_values.y;\nlast_variation_values.y = last_variation_values.x;\nlast_variation_values.x = texelFetch( global_textures_3d[\n    variation_texture_index ], global_index, 0 ).r;\n```", "```cpp\nuint sample_count = MAX_SHADOW_VISIBILITY_SAMPLE_COUNT;\nif ( motion_vectors_value.r != -1.0 ) {\n```", "```cpp\n    sample_count = sample_count_history.x;\n    bool stable_sample_count = \n      ( sample_count_history.x == sample_count_history.y ) &&\n      ( sample_count_history.x == sample_count_history.z ) &&\n      ( sample_count_history.x == sample_count_history.w );\n```", "```cpp\n    float delta = 0.2;\n    if ( filtered_value > delta && sample_count <\n        MAX_SHADOW_VISIBILITY_SAMPLE_COUNT ) {\n            sample_count += 1;\n    } else if ( stable_sample_count &&\n          sample_count >= 1 ) {\n              sample_count -= 1;\n      }\n```", "```cpp\n    bvec4 hasSampleHistory = lessThan(\n        sample_count_history, uvec4( 1 ) );\n    bool zeroSampleHistory = all( hasSampleHistory );\n    if ( sample_count == 0 && zeroSampleHistory ) {\n        sample_count = 1;\n    }\n}\n```", "```cpp\nfloat visibility = 0.0;\nif ( sample_count > 0 ) {\n    // world position and normal are computed the same as\n       before\n    visibility = get_light_visibility(\n       gl_GlobalInvocationID.z, sample_count,\n       pixel_world_position, normal, frame_index );\n}\n```", "```cpp\nconst vec3 position_to_light = light.world_position –\n    world_position;\nconst vec3 l = normalize( position_to_light );\nconst float NoL = clamp(dot(normal, l), 0.0, 1.0);\nfloat d = sqrt( dot( position_to_light, position_to_light ) );\n```", "```cpp\nfloat visiblity = 0.0;\nfloat attenuation =\n    attenuation_square_falloff(position_to_light,\n        1.0f / light.radius);\nconst float scaled_distance = r / d;\nif ( ( NoL > 0.001f ) && ( d <= r ) && ( attenuation >\n    0.001f ) ) {\n```", "```cpp\n    for ( uint s = 0; s < sample_count; ++s ) {\n        vec2 poisson_sample = POISSON_SAMPLES[ s *\n            FRAME_HISTORY_COUNT + frame_index ];\n        vec3 random_dir = normalize( vec3( l.x +\n            poisson_sample.x, l.y + poisson_sample.y, l.z )\n            );\n        vec3 random_x = x_axis * poisson_sample.x *\n            (scaled_distance) * 0.01;\n        vec3 random_y = y_axis * poisson_sample.y *\n            (scaled_distance) * 0.01;\n        vec3 random_dir = normalize(l + random_x +\n            random_y);\n```", "```cpp\n        rayQueryEXT rayQuery;\n        rayQueryInitializeEXT(rayQuery, as,\n           gl_RayFlagsOpaqueEXT |\n           gl_RayFlagsTerminateOnFirstHitEXT,\n           0xff, world_position, 0.001,\n           random_dir, d);\n        rayQueryProceedEXT( rayQuery );\n```", "```cpp\n        if (rayQueryGetIntersectionTypeEXT(rayQuery, true)\n            != gl_RayQueryCommittedIntersectionNoneEXT) {\n                visibility +=\n                    rayQueryGetIntersectionTEXT(rayQuery,\n                        true) < d ? 0.0f : 1.0f;\n        }\n        else {\n            visiblity += 1.0f;\n        }\n    }\n}\n```", "```cpp\nreturn visiblity / float( sample_count );\n```", "```cpp\nvec4 last_visibility_values = vec4(0);\nif ( motion_vectors_value.r != -1.0 ) {\n    last_visibility_values = texelFetch(\n        global_textures_3d[ visibility_cache_texture_index\n            ], global_index, 0 );\n    last_visibility_values.w = last_visibility_values.z;\n    last_visibility_values.z = last_visibility_values.y;\n    last_visibility_values.y = last_visibility_values.x;\n```", "```cpp\n} else {\n    last_visibility_values.w = visibility;\n    last_visibility_values.z = visibility;\n    last_visibility_values.y = visibility;\n}\nlast_visibility_values.x = visibility;\n```", "```cpp\nsample_count_history.w = sample_count_history.z;\nsample_count_history.z = sample_count_history.y;\nsample_count_history.y = sample_count_history.x;\nsample_count_history.x = sample_count;\n```", "```cpp\nlocal_image_data[ local_index.y ][ local_index.x ] =\n    visibility_temporal_filter( global_index );\nlocal_normal_data[ local_index.y ][ local_index.x ] =\n    get_normal( global_index );\n```", "```cpp\nvec4 last_visibility_values = texelFetch(\n    global_textures_3d[ visibility_cache_texture_index ],\n        ivec3( xy, index.z ), 0 );\nfloat filtered_visibility = 0.25 * (\n    last_visibility_values.x + last_visibility_values.y +\n    last_visibility_values.z + last_visibility_values.w );\n```", "```cpp\nvec3 p_normal = local_normal_data[ local_index.y ][\n    local_index.x ];\n```", "```cpp\nfor ( int y = -2; y <= 2; ++y ) {\n    for ( int x = -2; x <= 2; ++x ) {\n        ivec2 index = local_index.xy + ivec2( x, y );\n        vec3 q_normal = local_normal_data[ local_index.y +\n            y ][ local_index.x + x ];\n        if ( dot( p_normal, q_normal ) <= 0.9 ) {\n            continue;\n        }\n```", "```cpp\n        float v = local_image_data[ index.y ][ index.x ];\n        float k = gaussian_kernel[ y + 2 ][ x + 2 ];\n        spatial_filtered_value += v * k;\n    }\n}\n```", "```cpp\nfloat shadow = texelFetch( global_textures_3d[\n    shadow_visibility_texture_index ], ivec3( screen_uv,\n        shadow_light_index ), 0 ).r;\nfloat attenuation =\n    attenuation_square_falloff(position_to_light, 1.0f /\n        light.radius) * shadow;\nif ( attenuation > 0.0001f && NoL > 0.0001f ) {\n// same code as before\n```"]