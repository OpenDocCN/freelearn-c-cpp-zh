<html><head></head><body><div><div><h1 id="_idParaDest-46"><em class="italic"><a id="_idTextAnchor051"/>Chapter 3</em>: Variadic Templates</h1>
			<p>A variadic template is a template with a variable number of arguments. This is a feature that was introduced in C++11. It combines generic code with functions with variable numbers of arguments, a feature that was inherited from the C language. Although the syntax and some details could be seen as cumbersome, variadic templates help us write function templates with a variable number of arguments or class templates with a variable number of data members in a way that was not possible before with compile time evaluation and type safety.</p>
			<p>In this chapter, we will learn about the following topics:</p>
			<ul>
				<li>Understanding the need for variadic templates</li>
				<li>Variadic function templates</li>
				<li>Parameter packs</li>
				<li>Variadic class templates</li>
				<li>Fold expressions</li>
				<li>Variadic alias templates</li>
				<li>Variadic variable templates</li>
			</ul>
			<p>By the end of the chapter, you will have a good understanding of how to write variadic templates and how they work.</p>
			<p>We will start, however, by trying to understand why templates with variable numbers of arguments are helpful.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor052"/>Understanding the need for variadic templates</h1>
			<p>One of the most famous C and C++ functions<a id="_idIndexMarker189"/> is <code>printf</code>, which writes formatted output to the <code>stdout</code> standard output stream. There is actually a family of functions in the I/O library for writing formatted output, which also includes <code>fprintf</code> (which writes to a file stream), <code>sprint</code>, and <code>snprintf</code> (which write to a character buffer). These functions are similar because they take a string defining the output format and a variable number of arguments. The language, however, provides us with the means<a id="_idIndexMarker190"/> to write our own functions with variable numbers of arguments. Here is an example of a function that takes one or more arguments and returns the minimum value:</p>
			<pre class="source-code">#include&lt;stdarg.h&gt;</pre>
			<pre class="source-code">int min(int count, ...)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   va_list args;</pre>
			<pre class="source-code">   va_start(args, count);</pre>
			<pre class="source-code">   int val = va_arg(args, int);</pre>
			<pre class="source-code">   for (int i = 1; i &lt; count; i++)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      int n = va_arg(args, int);</pre>
			<pre class="source-code">      if (n &lt; val)</pre>
			<pre class="source-code">         val = n;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   va_end(args);</pre>
			<pre class="source-code">   return val;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "min(42, 7)=" &lt;&lt; min(2, 42, 7) &lt;&lt; '\n';</pre>
			<pre class="source-code">   std::cout &lt;&lt; "min(1,5,3,-4,9)=" &lt;&lt; </pre>
			<pre class="source-code">                 min(5, 1, 5, 3, -4, </pre>
			<pre class="source-code">              9) &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>This implementation is <a id="_idIndexMarker191"/>specific for values of the <code>int</code> type. However, it is possible to write a similar function that is a function template. The transformation requires minimal changes and the result is as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T min(int count, ...)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   va_list args;</pre>
			<pre class="source-code">   va_start(args, count);</pre>
			<pre class="source-code">   T val = va_arg(args, T);</pre>
			<pre class="source-code">   for (int i = 1; i &lt; count; i++)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      T n = va_arg(args, T);</pre>
			<pre class="source-code">      if (n &lt; val)</pre>
			<pre class="source-code">         val = n;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   va_end(args);</pre>
			<pre class="source-code">   return val;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "min(42.0, 7.5)="</pre>
			<pre class="source-code">             &lt;&lt; min&lt;double&gt;(2, 42.0, 7.5) &lt;&lt; '\n';</pre>
			<pre class="source-code">   std::cout &lt;&lt; "min(1,5,3,-4,9)=" </pre>
			<pre class="source-code">             &lt;&lt; min&lt;int&gt;(5, 1, 5, 3, -4, 9) &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>Writing code like this, whether<a id="_idIndexMarker192"/> generic or not, has several important drawbacks:</p>
			<ul>
				<li>It requires the use of <a id="_idIndexMarker193"/>several macros: <code>va_list</code> (which provides access to the information needed by the others), <code>va_start</code> (starts the iterating of the arguments), <code>va_arg</code> (provides access to the next argument), and <code>va_end</code> (stops the iterating of the arguments).</li>
				<li>Evaluation happens at runtime, even though the number and the type of the arguments passed to the function are known at compile-time.</li>
				<li>Variadic functions implemented in this manner are not type-safe. The <code>va_</code> macros perform low-memory manipulation and type-casts are done in <code>va_arg</code> at runtime. These could lead to runtime exceptions.</li>
				<li>These variadic functions require specifying in some way the number of variable arguments. In the implementation of the earlier <code>min</code> function, there is a first parameter that indicates the number of arguments. The <code>printf</code>-like functions take a formatting string from which the number of expected arguments is determined. The <code>printf</code> function, for example, evaluates and then ignores additional arguments (if more are supplied than the number specified in the formatting string) but has undefined behavior if fewer arguments are supplied.</li>
			</ul>
			<p>In addition to all these things, only functions could be variadic, prior to C++11. However, there are classes that could also benefit from being able to have a variable number of data members. Typical examples are the <code>tuple</code> class, which represents a fixed-size collection of heterogeneous values, and <code>variant</code>, which is a type-safe union.</p>
			<p>Variadic templates help address all these issues. They are evaluated at compile-time, are type-safe, do not require macros, do not require explicitly specifying the number of arguments, and we can <a id="_idIndexMarker194"/>write both variadic function templates and variadic class templates. Moreover, we also have variadic variable templates and variadic alias templates.</p>
			<p>In the next section, we will start looking into variadic function templates.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor053"/>Variadic function templates</h1>
			<p>Variadic function templates<a id="_idIndexMarker195"/> are template functions with a variable number of arguments. They borrow the use of the ellipsis (<code>...</code>) for specifying a pack of arguments, which can have different syntax depending on its nature. </p>
			<p>To understand the fundamentals for variadic function templates, let's start with an example that rewrites the previous <code>min</code> function:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T min(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a &lt; b ? a : b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">T min(T a, Args... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return min(a, min(args...));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "min(42.0, 7.5)=" &lt;&lt; min(42.0, 7.5) </pre>
			<pre class="source-code">             &lt;&lt; '\n';</pre>
			<pre class="source-code">   std::cout &lt;&lt; "min(1,5,3,-4,9)=" &lt;&lt; min(1, 5, 3, -4, 9)</pre>
			<pre class="source-code">             &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>What we have here are two<a id="_idIndexMarker196"/> overloads for the <code>min</code> function. The first is a function template with two parameters that returns the smallest of the two arguments. The second is a function template with a variable number of arguments that recursively calls itself with an expansion of the parameters pack. Although variadic function template implementations look like using some sort of compile-time recursion mechanism (in this case the overload with two parameters acting as the end case), in fact, they're only relying on overloaded functions, instantiated from the template and the set of provided arguments.</p>
			<p>The ellipsis (<code>...</code>) is used in three different places, with different meanings, in the implementation of a variadic function template, as can be seen in our example:</p>
			<ul>
				<li>To specify a pack of <a id="_idIndexMarker197"/>parameters in the template parameters list, as in <code>typename... Args</code>. This is called a <strong class="bold">template parameter pack</strong>. Template<a id="_idIndexMarker198"/> parameter packs can be defined for type templates, non-type templates, and template template parameters.</li>
				<li>To specify a pack of<a id="_idIndexMarker199"/> parameters in the function parameters list, as in <code>Args... args</code>. This is called a <strong class="bold">function parameter pack</strong>.</li>
				<li>To expand a pack<a id="_idIndexMarker200"/> in the body of a function, as in <code>args…</code>, seen in the call <code>min(args…)</code>. This is called a <strong class="bold">parameter pack expansion</strong>. The result of such an expansion is a comma-separated list of zero or more values (or expressions). This topic will be covered in more detail in the next section.</li>
			</ul>
			<p>From the call <code>min(1, 5, 3, -4, 9)</code>, the compiler is instantiating a set of overloaded functions with 5, 4, 3, and 2 arguments. Conceptually, it is the same as having the following set of overloaded functions:</p>
			<pre class="source-code">int min(int a, int b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a &lt; b ? a : b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int min(int a, int b, int c)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return min(a, min(b, c));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int min(int a, int b, int c, int d)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return min(a, min(b, min(c, d)));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int min(int a, int b, int c, int d, int e)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return min(a, min(b, min(c, min(d, e))));</pre>
			<pre class="source-code">}</pre>
			<p>As a result, <code>min(1, 5, 3, -4, 9)</code> expands to <code>min(1, min(5, min(3, min(-4, 9))))</code>. This<a id="_idIndexMarker201"/> can raise questions about the performance of variadic templates. In practice, however, the compilers perform a lot of optimizations, such as inlining as much as possible. The result is that, in practice, when optimizations are enabled, there will be no actual function calls. You can use online resources, such as <code>min</code> is the variadic function template with the implementation shown earlier):</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{    </pre>
			<pre class="source-code">   std::cout &lt;&lt; min(1, 5, 3, -4, 9);</pre>
			<pre class="source-code">}</pre>
			<p>Compiling this with GCC 11.2 with the <code>-O</code> flag for optimizations produces the following assembly code:</p>
			<pre class="source-code">sub     rsp, 8</pre>
			<pre class="source-code">mov     esi, -4</pre>
			<pre class="source-code">mov     edi, OFFSET FLAT:_ZSt4cout</pre>
			<pre class="source-code">call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;</pre>
			<pre class="source-code">           ::operator&lt;&lt;(int)</pre>
			<pre class="source-code">mov     eax, 0</pre>
			<pre class="source-code">add     rsp, 8</pre>
			<pre class="source-code">ret</pre>
			<p>You don't need to be <a id="_idIndexMarker204"/>an expert in assembly to understand what's happening here. The evaluation of the call to <code>min(1, 5, 3, -4, 9)</code> is done at compile-time and the result, <code>-4</code>, is loaded directly into the ESI register. There are no runtime calls, in this particular case, or computation, since everything is known at compile-time. Of course, that is not necessarily always the case. </p>
			<p>The following snippet shows an invocation on the <code>min</code> function template that cannot be evaluated at compile-time because its arguments are only known at runtime:</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{    </pre>
			<pre class="source-code">    int a, b, c, d, e;</pre>
			<pre class="source-code">    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;</pre>
			<pre class="source-code">    std::cout &lt;&lt; min(a, b, c, d, e);</pre>
			<pre class="source-code">}</pre>
			<p>This time, the assembly code generated is the following (only showing here the code for the call to the <code>min</code> function):</p>
			<pre class="source-code">mov     esi, DWORD PTR [rsp+12]</pre>
			<pre class="source-code">mov     eax, DWORD PTR [rsp+16]</pre>
			<pre class="source-code">cmp     esi, eax</pre>
			<pre class="source-code">cmovg   esi, eax</pre>
			<pre class="source-code">mov     eax, DWORD PTR [rsp+20]</pre>
			<pre class="source-code">cmp     esi, eax</pre>
			<pre class="source-code">cmovg   esi, eax</pre>
			<pre class="source-code">mov     eax, DWORD PTR [rsp+24]</pre>
			<pre class="source-code">cmp     esi, eax</pre>
			<pre class="source-code">cmovg   esi, eax</pre>
			<pre class="source-code">mov     eax, DWORD PTR [rsp+28]</pre>
			<pre class="source-code">cmp     esi, eax</pre>
			<pre class="source-code">cmovg   esi, eax</pre>
			<pre class="source-code">mov     edi, OFFSET FLAT:_ZSt4cout</pre>
			<pre class="source-code">call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt; </pre>
			<pre class="source-code">             ::operator&lt;&lt;(int)</pre>
			<p>We can see from this listing <a id="_idIndexMarker205"/>that the compiler has inlined all the calls to the <code>min</code> overloads. There is only a series of instructions for loading values into registers, comparisons of register values, and jumps based on the comparison result, but there are no function calls.</p>
			<p>When optimizations are disabled, function calls do occur. We can trace these calls that occur during the invocation of the <code>min</code> function by using compiler-specific macros. GCC and Clang provide a macro called <code>__PRETTY_FUNCTION__</code> that contains the signature of a function and<a id="_idIndexMarker206"/> its name. Similarly, Visual C++ provides a <a id="_idIndexMarker207"/>macro, called <code>__FUNCSIG__</code>, that does the same. These could be used within the body of a function to print its name and signature. We can use them as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T min(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)</pre>
			<pre class="source-code">   std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n";</pre>
			<pre class="source-code">#elif defined(_MSC_VER)</pre>
			<pre class="source-code">   std::cout &lt;&lt; __FUNCSIG__ &lt;&lt; "\n";</pre>
			<pre class="source-code">#endif</pre>
			<pre class="source-code">   return a &lt; b ? a : b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">T min(T a, Args... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)</pre>
			<pre class="source-code">   std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n";</pre>
			<pre class="source-code">#elif defined(_MSC_VER)</pre>
			<pre class="source-code">   std::cout &lt;&lt; __FUNCSIG__ &lt;&lt; "\n";</pre>
			<pre class="source-code">#endif</pre>
			<pre class="source-code">   return min(a, min(args...));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   min(1, 5, 3, -4, 9);</pre>
			<pre class="source-code">}</pre>
			<p>The result of the execution of this program, when compiled with Clang, is the following:</p>
			<pre>T min(T, Args...) [T = int, Args = &lt;int, int, int, int&gt;]
T min(T, Args...) [T = int, Args = &lt;int, int, int&gt;]
T min(T, Args...) [T = int, Args = &lt;int, int&gt;]
T min(T, T) [T = int]
T min(T, T) [T = int]
T min(T, T) [T = int]
T min(T, T) [T = int]</pre>
			<p>On the other hand, when compiled with Visual C++, the output is the following:</p>
			<pre>int __cdecl min&lt;int,int,int,int,int&gt;(int,int,int,int,int)
int __cdecl min&lt;int,int,int,int&gt;(int,int,int,int)
int __cdecl min&lt;int,int,int&gt;(int,int,int)
int __cdecl min&lt;int&gt;(int,int)
int __cdecl min&lt;int&gt;(int,int)
int __cdecl min&lt;int&gt;(int,int)
int __cdecl min&lt;int&gt;(int,int)</pre>
			<p>Although the way the <a id="_idIndexMarker208"/>signature is formatted is significantly different between Clang/GCC on one hand and VC++ on the other hand, they all show the same: first, an overloaded function with five parameters is called, then one with four parameters, then one with three, and, in the end, there are four calls to the overload with two parameters (which marks the end of the expansion). </p>
			<p>Understanding the expansion<a id="_idIndexMarker209"/> of parameter packs is key to understanding variadic templates. Therefore, we'll explore this topic in detail in the next section.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor054"/>Parameter packs</h1>
			<p>A template or function parameter<a id="_idIndexMarker210"/> pack can accept zero, one, or more arguments. The standard does not specify any upper limit for the number of arguments, but in practice, compilers may have some. What the standard does is recommend minimum values for these limits but it does not require any compliance on them. These limits are as follows:</p>
			<ul>
				<li>For a function parameter pack, the maximum number of arguments depends on the limit of arguments for a function call, which is recommended to be at least 256.</li>
				<li>For a template parameter pack, the maximum number of arguments depends on the limit of template parameters, which is recommended to be at least 1,024.</li>
			</ul>
			<p>The number of arguments in a parameter pack can be retrieved at compile time with the <code>sizeof…</code> operator. This operator returns a <code>constexpr</code> value of the <code>std::size_t</code> type. Let's see this at work in a couple of examples. </p>
			<p>In the first example, the <code>sizeof…</code> operator is used to implement the end of the recursion pattern of the variadic function template <code>sum</code> with the help of a <code>constexpr if</code> statement. If the number of the arguments in the parameter pack is zero (meaning there is a single argument to the function) then we are processing the last argument, so we just return the value. Otherwise, we add the first argument to the sum of the remaining ones. The implementation looks as follows:</p>
			<pre class="source-code">template &lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">T sum(T a, Args... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (sizeof...(args) == 0)</pre>
			<pre class="source-code">      return a;</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      return a + sum(args...);</pre>
			<pre class="source-code">}</pre>
			<p>This is semantically equivalent, but<a id="_idIndexMarker211"/> on the other hand more concise, than the following classical approach for the variadic function template implementation:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T sum(T a)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">T sum(T a, Args... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + sum(args...);</pre>
			<pre class="source-code">}</pre>
			<p>Notice that <code>sizeof…(args)</code> (the function parameter pack) and <code>sizeof…(Args)</code> (the template parameter pack) return the same value. On the other hand, <code>sizeof…(args)</code> and <code>sizeof(args)...</code> are not the same thing. The former is the <code>sizeof</code> operator used on the parameter pack <code>args</code>. The latter is an expansion of the parameter pack <code>args</code> on the <code>sizeof</code> operator. These are both shown in the following example:</p>
			<pre class="source-code">template&lt;typename... Ts&gt;</pre>
			<pre class="source-code">constexpr auto get_type_sizes()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return std::array&lt;std::size_t, </pre>
			<pre class="source-code">                     sizeof...(Ts)&gt;{sizeof(Ts)...};</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">auto sizes = get_type_sizes&lt;short, int, long, long long&gt;();</pre>
			<p>In this snippet, <code>sizeof…(Ts)</code> evaluates to <code>4</code> at compile-time, while <code>sizeof(Ts)...</code> is expanded to the following comma-separated pack of arguments: <code>sizeof(short), sizeof(int), sizeof(long), sizeof(long long)</code>. Conceptually, the preceding function <a id="_idIndexMarker212"/>template, <code>get_type_sizes</code>, is equivalent to the following function template with four template parameters:</p>
			<pre class="source-code">template&lt;typename T1, typename T2, </pre>
			<pre class="source-code">         typename T3, typename T4&gt;</pre>
			<pre class="source-code">constexpr auto get_type_sizes()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return std::array&lt;std::size_t, 4&gt; {</pre>
			<pre class="source-code">      sizeof(T1), sizeof(T2), sizeof(T3), sizeof(T4)</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">}</pre>
			<p>Typically, the parameter pack is the trailing parameter of a function or template. However, if the compiler can deduce the arguments, then a parameter pack can be followed by other parameters including more parameter packs. Let's consider the following example:</p>
			<pre class="source-code">template &lt;typename... Ts, typename... Us&gt;</pre>
			<pre class="source-code">constexpr auto multipacks(Ts... args1, Us... args2)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; sizeof...(args1) &lt;&lt; ','</pre>
			<pre class="source-code">             &lt;&lt; sizeof...(args2) &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>This function is supposed to take two sets of elements of possibly different types and do something with them. It can be invoked <a id="_idIndexMarker213"/>such as in the following examples:</p>
			<pre class="source-code">multipacks&lt;int&gt;(1, 2, 3, 4, 5, 6);</pre>
			<pre class="source-code">                 // 1,5</pre>
			<pre class="source-code">multipacks&lt;int, int, int&gt;(1, 2, 3, 4, 5, 6);</pre>
			<pre class="source-code">                // 3,3</pre>
			<pre class="source-code">multipacks&lt;int, int, int, int&gt;(1, 2, 3, 4, 5, 6);</pre>
			<pre class="source-code">               // 4,2</pre>
			<pre class="source-code">multipacks&lt;int, int, int, int, int, int&gt;(1, 2, 3, 4, 5, 6); </pre>
			<pre class="source-code">               // 6,0</pre>
			<p>For the first call, the <code>args1</code> pack is specified at the function call (as in <code>multipacks&lt;int&gt;</code>) and contains <code>1</code>, and <code>args2</code> is deduced to be <code>2, 3, 4, 5, 6</code> from the function arguments. Similarly, for the second call, the two packs will have an equal number of arguments, more precisely <code>1, 2, 3</code> and <code>3, 4, 6</code>. For the last call, the first pack contains all the elements, and the second pack is empty. In all these examples, all the elements are of the <code>int</code> type. However, in the following examples, the two packs contain elements of different types:</p>
			<pre class="source-code">multipacks&lt;int, int&gt;(1, 2, 4.0, 5.0, 6.0);         // 2,3</pre>
			<pre class="source-code">multipacks&lt;int, int, int&gt;(1, 2, 3, 4.0, 5.0, 6.0); // 3,3</pre>
			<p>For the first call, the <code>args1</code> pack will contain the integers <code>1, 2</code> and the <code>args2</code> pack will be deduced to contain the double values <code>4.0, 5.0, 6.0</code>. Similarly, for the second call, the <code>args1</code> pack will be <code>1, 2, 3</code> and the <code>args2</code> pack will contain <code>4.0, 5.0, 6.0</code>.</p>
			<p>However, if we change the function template <code>multipacks</code> a bit by requiring that the packs be of equal size, then only some of the calls shown earlier would still be possible. This is shown in the following example:</p>
			<pre class="source-code">template &lt;typename... Ts, typename... Us&gt;</pre>
			<pre class="source-code">constexpr auto multipacks(Ts... args1, Us... args2)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static_assert(</pre>
			<pre class="source-code">      sizeof...(args1) == sizeof...(args2),</pre>
			<pre class="source-code">      "Packs must be of equal sizes.");</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">multipacks&lt;int&gt;(1, 2, 3, 4, 5, 6);                   // error</pre>
			<pre class="source-code">multipacks&lt;int, int, int&gt;(1, 2, 3, 4, 5, 6);         // OK</pre>
			<pre class="source-code">multipacks&lt;int, int, int, int&gt;(1, 2, 3, 4, 5, 6);    // error</pre>
			<pre class="source-code">multipacks&lt;int, int, int, int, int, int&gt;(1, 2, 3, 4, 5, 6); </pre>
			<pre class="source-code">                                                     // error</pre>
			<pre class="source-code">multipacks&lt;int, int&gt;(1, 2, 4.0, 5.0, 6.0);           // error</pre>
			<pre class="source-code">multipacks&lt;int, int, int&gt;(1, 2, 3, 4.0, 5.0, 6.0);   // OK</pre>
			<p>In this snippet, only the second and the sixth calls are valid. In these two cases, the two deduced packs have three elements each. In all the other cases, as resulting from the prior example, the packs have different sizes and the <code>static_assert</code> statement will generate an error at compile-time.</p>
			<p>Multiple parameter packs are <a id="_idIndexMarker214"/>not specific to variadic function templates. They can also be used for variadic class templates in partial specialization, provided that the compiler can deduce the template arguments. To exemplify this, we'll consider the case of a class template that represents a pair of function pointers. The implementation should allow for storing pointers to any function. To implement this, we define a primary template, called here <code>func_pair</code>, and a partial specialization with four template parameters: </p>
			<ul>
				<li>A type template parameter for the return type of the first function</li>
				<li>A template parameter pack for the parameter types of the first function</li>
				<li>A second type template parameter for the return type of the second function</li>
				<li>A second template parameter pack for the parameter types of the second function</li>
			</ul>
			<p>The <code>func_pair</code> class template is shown in the next listing:</p>
			<pre class="source-code">template&lt;typename, typename&gt;</pre>
			<pre class="source-code">struct func_pair;</pre>
			<pre class="source-code">template&lt;typename R1, typename... A1, </pre>
			<pre class="source-code">         typename R2, typename... A2&gt;</pre>
			<pre class="source-code">struct func_pair&lt;R1(A1...), R2(A2...)&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::function&lt;R1(A1...)&gt; f;</pre>
			<pre class="source-code">   std::function&lt;R2(A2...)&gt; g;</pre>
			<pre class="source-code">};</pre>
			<p>To demonstrate the use<a id="_idIndexMarker215"/> of this class template, let's also consider the following two functions:</p>
			<pre class="source-code">bool twice_as(int a, int b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a &gt;= b*2;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">double sum_and_div(int a, int b, double c)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return (a + b) / c;</pre>
			<pre class="source-code">}</pre>
			<p>We can instantiate the <code>func_pair</code> class template and use it to call these two functions as shown in the following snippet:</p>
			<pre class="source-code">func_pair&lt;bool(int, int), double(int, int, double)&gt; funcs{</pre>
			<pre class="source-code">   twice_as, sum_and_div };</pre>
			<pre class="source-code">funcs.f(42, 12);</pre>
			<pre class="source-code">funcs.g(42, 12, 10.0);</pre>
			<p>Parameter packs can be <a id="_idIndexMarker216"/>expanded in a variety of contexts and this will make the topic of the next section.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor055"/>Understanding parameter packs expansion</h2>
			<p>Parameter packs can appear<a id="_idIndexMarker217"/> in a multitude of contexts. The form of their expansion may depend on this context. These possible contexts are listed ahead along with examples:</p>
			<ul>
				<li><strong class="bold">Template parameter list</strong>: This is for<a id="_idIndexMarker218"/> when you specify parameters for a template:<pre>template &lt;typename... T&gt;
struct outer
{
   template &lt;T... args&gt;
   struct inner {};
};
outer&lt;int, double, char[5]&gt; a;</pre></li>
				<li><strong class="bold">Template argument list</strong>: This<a id="_idIndexMarker219"/> is when you specify arguments for a template:<pre>template &lt;typename... T&gt;
struct tag {};
template &lt;typename T, typename U, typename ... Args&gt;
void tagger()
{
   tag&lt;T, U, Args...&gt; t1;
   tag&lt;T, Args..., U&gt; t2;
   tag&lt;Args..., T, U&gt; t3;
   tag&lt;U, T, Args...&gt; t4;
}</pre></li>
				<li><strong class="bold">Function parameter list</strong>: This is for when you specify parameters for a function template:<pre>template &lt;typename... Args&gt;
void make_it(Args... args)
{
}
make_it(42);
make_it(42, 'a');</pre></li>
				<li><strong class="bold">Function argument list</strong>: When the <a id="_idIndexMarker220"/>expansion pack appears inside the parenthesis of a function call, the largest expression or brace initialization list to the left of the ellipsis is the pattern that is expanded:<pre>template &lt;typename T&gt;
T step_it(T value)
{
   return value+1;
}
template &lt;typename... T&gt;
int sum(T... args)
{
   return (... + args);
}
template &lt;typename... T&gt;
void do_sums(T... args)
{
   auto s1 = sum(args...);
   // sum(1, 2, 3, 4)
   auto s2 = sum(42, args...);
   // sum(42, 1, 2, 3, 4)
   auto s3 = sum(step_it(args)...); 
   // sum(step_it(1), step_it(2),... step_it(4))
}
do_sums(1, 2, 3, 4);</pre></li>
				<li><strong class="bold">Parenthesized initializers</strong>: When the expansion pack appears inside the parenthesis of a direct initializer, function-style cast, member initializer, new expression, and other <a id="_idIndexMarker221"/>similar contexts, the rules are the same as for the context of function argument lists:<pre>template &lt;typename... T&gt;
struct sum_wrapper
{
   sum_wrapper(T... args)
   {
      value = (... + args);
   }
   std::common_type_t&lt;T...&gt; value;
};
template &lt;typename... T&gt;
void parenthesized(T... args)
{
   std::array&lt;std::common_type_t&lt;T...&gt;, 
              sizeof...(T)&gt; arr {args...};
   // std::array&lt;int, 4&gt; {1, 2, 3, 4}
   sum_wrapper sw1(args...);
   // value = 1 + 2 + 3 + 4
   sum_wrapper sw2(++args...);
   // value = 2 + 3 + 4 + 5
}
parenthesized(1, 2, 3, 4);</pre></li>
				<li><strong class="bold">Brace-enclosed initializers</strong>: This is <a id="_idIndexMarker222"/>when you perform initialization using the brace notation:<pre>template &lt;typename... T&gt;
void brace_enclosed(T... args)
{
   int arr1[sizeof...(args) + 1] = {args..., 0};     
   // arr1: {1,2,3,4,0}
   int arr2[sizeof...(args)] = { step_it(args)... };
   // arr2: {2,3,4,5}
}
brace_enclosed(1, 2, 3, 4);</pre></li>
				<li><strong class="bold">Base specifiers and member initializer lists</strong>: A pack expansion may specify the list of base classes in <a id="_idIndexMarker223"/>a class declaration. In addition, it may also appear in the member initializer list, as this may be necessary to call the constructors of the base classes:<pre>struct A {};
struct B {};
struct C {};
template&lt;typename... Bases&gt;
struct X : public Bases...
{
   X(Bases const &amp; ... args) : Bases(args)...
   { }
};
A a;
B b;
C c;
X x(a, b, c);</pre></li>
				<li><code>using</code> declaration. This is demonstrated based on the previous example:<pre>struct A 
{
   void execute() { std::cout &lt;&lt; "A::execute\n"; }
};
struct B 
{
   void execute() { std::cout &lt;&lt; "B::execute\n"; }
};
struct C 
{
   void execute() { std::cout &lt;&lt; "C::execute\n"; }
};
template&lt;typename... Bases&gt;
struct X : public Bases...
{
   X(Bases const &amp; ... args) : Bases(args)...
   {}
   using Bases::execute...;
};
A a;
B b;
C c;
X x(a, b, c);
x.A::execute();
x.B::execute();
x.C::execute();</pre></li>
				<li><strong class="bold">Lambda captures</strong>: The capture clause <a id="_idIndexMarker225"/>of a lambda expression may contain a pack expansion, as shown in the following example:<pre>template &lt;typename... T&gt;
void captures(T... args)
{
   auto l = [args...]{ 
               return sum(step_it(args)...); };
   auto s = l();
}
captures(1, 2, 3, 4);</pre></li>
				<li><strong class="bold">Fold expressions</strong>: These will be <a id="_idIndexMarker226"/>discussed in detail in the following section in this chapter:<pre>template &lt;typename... T&gt;
int sum(T... args)
{
   return (... + args);
}</pre></li>
				<li>The <code>sizeof…</code> operator: Examples have already been shown earlier in this section. Here is one again:<pre>template &lt;typename... T&gt;
auto make_array(T... args)
{
   return std::array&lt;std::common_type_t&lt;T...&gt;, 
                     sizeof...(T)&gt; {args...};
};
auto arr = make_array(1, 2, 3, 4);</pre></li>
				<li><code>alignas</code> specifiers applied to the same declaration. The parameter pack can be either a type or non-type pack. Examples for both cases are listed here:<pre>template &lt;typename... T&gt;
struct alignment1
{
   alignas(T...) char a;
};
template &lt;int... args&gt;
struct alignment2
{
   alignas(args...) char a;
};
alignment1&lt;int, double&gt; al1;
alignment2&lt;1, 4, 8&gt; al2;</pre></li>
				<li><strong class="bold">Attribute list</strong>: This is not supported by any <a id="_idIndexMarker228"/>compiler yet.</li>
			</ul>
			<p>Now that we have learned more about parameter packs and their expansion we can move forward and explore variadic class templates.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor056"/>Variadic class templates</h1>
			<p>Class templates may <a id="_idIndexMarker229"/>also have a variable number of template arguments. This is key to building some categories of types, such as <code>tuple</code> and <code>variant</code>, that are available in the standard library. In this section, we will see how we could write a simple implementation for a <code>tuple</code> class. A tuple is a type that represents a fixed-size collection of heterogeneous values.</p>
			<p>When implementing variadic function templates we used a recursion pattern with two overloads, one for the general case and one for ending the recursion. The same approach has to be taken with variadic class templates, except that we need to use specialization for this purpose. Next, you can see a minimal implementation for a tuple:</p>
			<pre class="source-code">template &lt;typename T, typename... Ts&gt;</pre>
			<pre class="source-code">struct tuple</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   tuple(T const&amp; t, Ts const &amp;... ts)</pre>
			<pre class="source-code">      : value(t), rest(ts...)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr int size() const { return 1 + rest.size(); }</pre>
			<pre class="source-code">   T            value;</pre>
			<pre class="source-code">   tuple&lt;Ts...&gt; rest;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct tuple&lt;T&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   tuple(const T&amp; t)</pre>
			<pre class="source-code">      : value(t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr int size() const { return 1; }</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">};</pre>
			<p>The first class is the primary template. It has two template parameters: a type template and a parameter pack. This means, at the minimum, there must be one type specified for instantiating this template. The primary template tuple has two member variables: <code>value</code>, of the <code>T</code> type, and <code>rest</code>, of type <code>tuple&lt;Ts…&gt;</code>. This is an expansion of the rest of the template arguments. This <a id="_idIndexMarker230"/>means a tuple of <code>N</code> elements will contain the first element and another tuple; this second tuple, in turn, contains the second element and yet another tuple; this third nested tuple contains the rest. And this pattern continues until we end up with a tuple with a single element. This is defined by the partial specialization <code>tuple&lt;T&gt;</code>. Unlike the primary template, this specialization does not aggregate another tuple object.</p>
			<p>We can use this simple implementation to write code like the following:</p>
			<pre class="source-code">tuple&lt;int&gt; one(42);</pre>
			<pre class="source-code">tuple&lt;int, double&gt; two(42, 42.0);</pre>
			<pre class="source-code">tuple&lt;int, double, char&gt; three(42, 42.0, 'a');</pre>
			<pre class="source-code">std::cout &lt;&lt; one.value &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; two.value &lt;&lt; ',' </pre>
			<pre class="source-code">          &lt;&lt; two.rest.value &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; three.value &lt;&lt; ',' </pre>
			<pre class="source-code">          &lt;&lt; three.rest.value &lt;&lt; ','</pre>
			<pre class="source-code">          &lt;&lt; three.rest.rest.value &lt;&lt; '\n';</pre>
			<p>Although this works, accessing elements through the <code>rest</code> member, such as in <code>three.rest.rest.value</code>, is very cumbersome. And the more elements a tuple has the more difficult it is to write code in this <a id="_idIndexMarker231"/>way. Therefore, we'd like to use some helper function to simplify accessing the elements of a tuple. The following is a snippet of how the previous could be transformed:</p>
			<pre class="source-code">std::cout &lt;&lt; get&lt;0&gt;(one) &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; get&lt;0&gt;(two) &lt;&lt; ','</pre>
			<pre class="source-code">          &lt;&lt; get&lt;1&gt;(two) &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; get&lt;0&gt;(three) &lt;&lt; ','</pre>
			<pre class="source-code">          &lt;&lt; get&lt;1&gt;(three) &lt;&lt; ','</pre>
			<pre class="source-code">          &lt;&lt; get&lt;2&gt;(three) &lt;&lt; '\n';</pre>
			<p>Here, <code>get&lt;N&gt;</code> is a variadic function template that takes a tuple as an argument and returns a reference to the element at the <code>N</code> index in the tuple. Its prototype could look like the following:</p>
			<pre class="source-code">template &lt;size_t N, typename... Ts&gt;</pre>
			<pre class="source-code">typename nth_type&lt;N, Ts...&gt;::value_type &amp; get(tuple&lt;Ts...&gt;&amp; t);</pre>
			<p>The template arguments are the index and a parameter pack of the tuple types. Its implementation, however, requires some helper types. First, we need to know what the type of the element is at the <code>N</code> index in the tuple. This can be retrieved with the help of the following <code>nth_type</code> variadic class template:</p>
			<pre class="source-code">template &lt;size_t N, typename T, typename... Ts&gt;</pre>
			<pre class="source-code">struct nth_type : nth_type&lt;N - 1, Ts...&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static_assert(N &lt; sizeof...(Ts) + 1,</pre>
			<pre class="source-code">                 "index out of bounds");</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T, typename... Ts&gt;</pre>
			<pre class="source-code">struct nth_type&lt;0, T, Ts...&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using value_type = T;</pre>
			<pre class="source-code">};</pre>
			<p>Again, we have a primary template that uses recursive inheritance, and the specialization for the index 0. The specialization defines an alias called <code>value_type</code> for the first type template (which is the head of the list of template arguments). This type is only used as a <a id="_idIndexMarker232"/>mechanism for determining the type of a tuple element. We need another variadic class template for retrieving the value. This is shown in the following listing:</p>
			<pre class="source-code">template &lt;size_t N&gt;</pre>
			<pre class="source-code">struct getter</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename... Ts&gt;</pre>
			<pre class="source-code">   static typename nth_type&lt;N, Ts...&gt;::value_type&amp; </pre>
			<pre class="source-code">   get(tuple&lt;Ts...&gt;&amp; t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return getter&lt;N - 1&gt;::get(t.rest);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct getter&lt;0&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename T, typename... Ts&gt;</pre>
			<pre class="source-code">   static T&amp; get(tuple&lt;T, Ts...&gt;&amp; t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return t.value;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>We can see here the same recursive pattern, with a primary template and an explicit specialization. The class template is called <code>getter</code> and has a single template parameter, which is a non-type template parameter. This represents the index of the tuple element we want to access. This class template has a static member function called <code>get</code>. This is a variadic function template. The implementation in the primary template calls the <code>get</code> function with the <code>rest</code> member of the tuple as an argument. On the other hand, the<a id="_idIndexMarker233"/> implementation of the explicit specialization returns the reference to the member value of the tuple.</p>
			<p>With all these defined, we can now provide an actual implementation for the helper variadic function template <code>get</code>. This implementation relies on the <code>getter</code> class template and calls its <code>get</code> variadic function template: </p>
			<pre class="source-code">template &lt;size_t N, typename... Ts&gt;</pre>
			<pre class="source-code">typename nth_type&lt;N, Ts...&gt;::value_type &amp; </pre>
			<pre class="source-code">get(tuple&lt;Ts...&gt;&amp; t)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return getter&lt;N&gt;::get(t);</pre>
			<pre class="source-code">}</pre>
			<p>If this example seems a little bit complicated, perhaps analyzing it step by step will help you better understand how it all works. Therefore, let's start with the following snippet:</p>
			<pre class="source-code">tuple&lt;int, double, char&gt; three(42, 42.0, 'a');</pre>
			<pre class="source-code">get&lt;2&gt;(three);</pre>
			<p>We will use the <code>cppinsights.io</code> web tools to check the template instantiations that occur from this snippet. The first to look at is the class template <code>tuple</code>. We have a primary template and several <a id="_idIndexMarker234"/>specializations, as follows:</p>
			<pre class="source-code">template &lt;typename T, typename... Ts&gt;</pre>
			<pre class="source-code">struct tuple</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   tuple(T const&amp; t, Ts const &amp;... ts)</pre>
			<pre class="source-code">      : value(t), rest(ts...)</pre>
			<pre class="source-code">   { }</pre>
			<pre class="source-code">   constexpr int size() const { return 1 + rest.size(); }</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">   tuple&lt;Ts...&gt; rest;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt; struct tuple&lt;int, double, char&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  inline tuple(const int &amp; t, </pre>
			<pre class="source-code">               const double &amp; __ts1, const char &amp; __ts2)</pre>
			<pre class="source-code">  : value{t}, rest{tuple&lt;double, char&gt;(__ts1, __ts2)}</pre>
			<pre class="source-code">  {}</pre>
			<pre class="source-code">  inline constexpr int size() const;</pre>
			<pre class="source-code">  int value;</pre>
			<pre class="source-code">  tuple&lt;double, char&gt; rest;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt; struct tuple&lt;double, char&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  inline tuple(const double &amp; t, const char &amp; __ts1)</pre>
			<pre class="source-code">  : value{t}, rest{tuple&lt;char&gt;(__ts1)}</pre>
			<pre class="source-code">  {}</pre>
			<pre class="source-code">  inline constexpr int size() const;</pre>
			<pre class="source-code">  double value;</pre>
			<pre class="source-code">  tuple&lt;char&gt; rest;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt; struct tuple&lt;char&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  inline tuple(const char &amp; t)</pre>
			<pre class="source-code">  : value{t}</pre>
			<pre class="source-code">  {}</pre>
			<pre class="source-code">  inline constexpr int size() const;</pre>
			<pre class="source-code">  char value;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;typename T&gt;</pre>
			<pre class="source-code">struct tuple&lt;T&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   inline tuple(const T &amp; t) : value{t}</pre>
			<pre class="source-code">   { }</pre>
			<pre class="source-code">   inline constexpr int size() const</pre>
			<pre class="source-code">   { return 1; }</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">};</pre>
			<p>The <code>tuple&lt;int, double, char&gt;</code> structure contains an <code>int</code> and a <code>tuple&lt;double, char&gt;</code>, which contains a <code>double</code> and a <code>tuple&lt;char&gt;</code>, which, in turn, contains a <code>char</code> value. This last<a id="_idIndexMarker235"/> class represents the end of the recursive definition of the tuple. This can be conceptually represented graphically as follows:</p>
			<div><div><img src="img/Figure_3.1_B18367.jpg" alt="Figure 3.1 – An example tuple&#13;&#10;" width="684" height="598"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – An example tuple</p>
			<p>Next, we have the <code>nth_type</code> class template, for which, again, we have a primary template and several specializations, as<a id="_idIndexMarker236"/> follows:</p>
			<pre class="source-code">template &lt;size_t N, typename T, typename... Ts&gt;</pre>
			<pre class="source-code">struct nth_type : nth_type&lt;N - 1, Ts...&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static_assert(N &lt; sizeof...(Ts) + 1,</pre>
			<pre class="source-code">                 "index out of bounds");</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct nth_type&lt;2, int, double, char&gt; : </pre>
			<pre class="source-code">   public nth_type&lt;1, double, char&gt;</pre>
			<pre class="source-code">{ };</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct nth_type&lt;1, double, char&gt; : public nth_type&lt;0, char&gt;</pre>
			<pre class="source-code">{ };</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct nth_type&lt;0, char&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using value_type = char;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;typename T, typename ... Ts&gt;</pre>
			<pre class="source-code">struct nth_type&lt;0, T, Ts...&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using value_type = T;</pre>
			<pre class="source-code">};</pre>
			<p>The <code>nth_type&lt;2, int, double, char&gt;</code> specialization is derived from <code>nth_type&lt;1, double, char&gt;</code>, which in turn is derived from <code>nth_type&lt;0, char&gt;</code>, which is the last base class in the hierarchy (the end of the recursive hierarchy).</p>
			<p>The <code>nth_type</code> structure is used as the return type in the <code>getter</code> helper class template, which<a id="_idIndexMarker237"/> is instantiated as follows:</p>
			<pre class="source-code">template &lt;size_t N&gt;</pre>
			<pre class="source-code">struct getter</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename... Ts&gt;</pre>
			<pre class="source-code">   static typename nth_type&lt;N, Ts...&gt;::value_type&amp; </pre>
			<pre class="source-code">   get(tuple&lt;Ts...&gt;&amp; t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return getter&lt;N - 1&gt;::get(t.rest);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct getter&lt;2&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template&lt;&gt;</pre>
			<pre class="source-code">   static inline typename </pre>
			<pre class="source-code">   nth_type&lt;2UL, int, double, char&gt;::value_type &amp; </pre>
			<pre class="source-code">   get&lt;int, double, char&gt;(tuple&lt;int, double,  char&gt; &amp; t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return getter&lt;1&gt;::get(t.rest);</pre>
			<pre class="source-code">   } </pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct getter&lt;1&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template&lt;&gt;</pre>
			<pre class="source-code">   static inline typename nth_type&lt;1UL, double,</pre>
			<pre class="source-code">                                   char&gt;::value_type &amp;</pre>
			<pre class="source-code">   get&lt;double, char&gt;(tuple&lt;double, char&gt; &amp; t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return getter&lt;0&gt;::get(t.rest);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct getter&lt;0&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template&lt;typename T, typename ... Ts&gt;</pre>
			<pre class="source-code">   static inline T &amp; get(tuple&lt;T, Ts...&gt; &amp; t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return t.value;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   template&lt;&gt;</pre>
			<pre class="source-code">   static inline char &amp; get&lt;char&gt;(tuple&lt;char&gt; &amp; t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return t.value;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>Lastly, the <code>get</code> function<a id="_idIndexMarker238"/> template that we use to retrieve the value of an element of a <code>tuple</code> is defined as follows:</p>
			<pre class="source-code">template &lt;size_t N, typename... Ts&gt;</pre>
			<pre class="source-code">typename nth_type&lt;N, Ts...&gt;::value_type &amp; </pre>
			<pre class="source-code">get(tuple&lt;Ts...&gt;&amp; t)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return getter&lt;N&gt;::get(t);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">typename nth_type&lt;2UL, int, double, char&gt;::value_type &amp; </pre>
			<pre class="source-code">get&lt;2, int, double, char&gt;(tuple&lt;int, double, char&gt; &amp; t)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  return getter&lt;2&gt;::get(t);</pre>
			<pre class="source-code">}</pre>
			<p>Should there be more calls to the <code>get</code> function more specializations of <code>get</code> would exist. For instance, for <code>get&lt;1&gt;(three)</code>, the following specialization would be added:</p>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">typename nth_type&lt;1UL, int, double, char&gt;::value_type &amp; </pre>
			<pre class="source-code">get&lt;1, int, double, char&gt;(tuple&lt;int, double, char&gt; &amp; t)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  return getter&lt;1&gt;::get(t);</pre>
			<pre class="source-code">}</pre>
			<p>This example helped us demonstrate how to implement variadic class templates with a primary template for the general case and a specialization for the end case of the variadic recursion.</p>
			<p>You have probably noticed the use of the keyword <code>typename</code> to prefix the <code>nth_type&lt;N, Ts...&gt;::value_type</code> type, which<a id="_idIndexMarker239"/> is a <strong class="bold">dependent type</strong>. In C++20, this is no longer necessary. However, this topic will be addressed in detail in <a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced Template Concepts</em>.</p>
			<p>Because<a id="_idIndexMarker240"/> implementing variadic templates is often verbose and can be cumbersome, the C++17 standard added <strong class="bold">fold expressions</strong> to ease this task. We will explore this topic in the next section.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor057"/>Fold expressions</h1>
			<p>A <code>sum</code> that returned the sum of all its supplied arguments. For convenience, we will show it again here:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T sum(T a)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">T sum(T a, Args... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + sum(args...);</pre>
			<pre class="source-code">}</pre>
			<p>With fold expressions, this implementation that requires two overloads can be reduced to the following form:</p>
			<pre class="source-code">template &lt;typename... T&gt;</pre>
			<pre class="source-code">int sum(T... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return (... + args);</pre>
			<pre class="source-code">}</pre>
			<p>There is no need for overloaded functions anymore. The expression <code>(... + args)</code> represents the fold expression, which<a id="_idIndexMarker242"/> upon evaluation becomes <code>((((arg0 + arg1) + arg2) + … ) + argN)</code>. The enclosing parentheses are part of the fold expression. We can use this new implementation, just as we would use the initial one, as follows:</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    std::cout &lt;&lt; sum(1) &lt;&lt; '\n';</pre>
			<pre class="source-code">    std::cout &lt;&lt; sum(1,2) &lt;&lt; '\n';</pre>
			<pre class="source-code">    std::cout &lt;&lt; sum(1,2,3,4,5) &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>There are four different types of folds, which are listed as follows:</p>
			<div><div><img src="img/B18367_Table_3.1.jpg" alt="Table 3.1&#10;" width="1409" height="414"/>
				</div>
			</div>
			<p class="figure-caption">Table 3.1</p>
			<p>In this table, the following<a id="_idIndexMarker243"/> names are used:</p>
			<ul>
				<li><code>pack</code> is an expression that contains an unexpanded parameter pack, and <code>arg1</code>, <code>arg2</code>, <code>argN-1</code>, and <code>argN</code> are the arguments contained in this pack.</li>
				<li><code>op</code> is one of the following binary operators: <code>+ - * / % ^ &amp; | = &lt; &gt; &lt;&lt; &gt;&gt; += -= *= /= %= ^= &amp;= |= &lt;&lt;= &gt;&gt;= == != &lt;= &gt;= &amp;&amp; || , .* -&gt;*.</code></li>
				<li><code>init</code> is an expression that does not contain an unexpanded parameter pack.</li>
			</ul>
			<p>In a unary fold, if the pack does not contain any elements, only some operators are allowed. These are listed in the following table, along with the value of the empty pack:</p>
			<div><div><img src="img/B18367_Table_3.2.jpg" alt="Table 3.2&#13;&#10;" width="1003" height="318"/>
				</div>
			</div>
			<p class="figure-caption">Table 3.2</p>
			<p>Unary and binary folds differ in the use of an initialization value, that is present only for binary folds. Binary folds have the binary operator repeated twice (it must be the same operator). We can transform the variadic function template <code>sum</code> from using a unary right fold expression into one using a binary right fold by including an initialization value. Here is an example:</p>
			<pre class="source-code">template &lt;typename... T&gt;</pre>
			<pre class="source-code">int sum_from_zero(T... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return (0 + ... + args);</pre>
			<pre class="source-code">}</pre>
			<p>One could say there is no difference between the <code>sum</code> and <code>sum_from_zero</code> function templates. That is not actually true. Let's consider the following invocations:</p>
			<pre class="source-code">int s1 = sum();           // error</pre>
			<pre class="source-code">int s2 = sum_from_zero(); // OK</pre>
			<p>Calling <code>sum</code> without arguments will produce a compiler error, because unary fold expressions (over the operator <code>+</code> in this case) must have non-empty expansions. However, binary fold expressions do not have this problem, so calling <code>sum_from_zero</code> without arguments works and the function will return <code>0</code>.</p>
			<p>In these two examples with <code>sum</code> and <code>sum_from_zero</code>, the parameter pack <code>args</code> appears directly within the<a id="_idIndexMarker244"/> fold expression. However, it can be part of an expression, as long as it is not expanded. This is shown in the following example:</p>
			<pre class="source-code">template &lt;typename... T&gt;</pre>
			<pre class="source-code">void printl(T... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   (..., (std::cout &lt;&lt; args)) &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename... T&gt;</pre>
			<pre class="source-code">void printr(T... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   ((std::cout &lt;&lt; args), ...) &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>Here, the parameter pack <code>args</code> is part of the <code>(std::cout &lt;&lt; args)</code> expression. This is not a fold expression. A fold expression is <code>((std::cout &lt;&lt; args), ...)</code>. This is a unary left fold over the comma operator. The <code>printl</code> and <code>printr</code> functions can be used as in the following snippet:</p>
			<pre class="source-code">printl('d', 'o', 'g');  // dog</pre>
			<pre class="source-code">printr('d', 'o', 'g');  // dog</pre>
			<p>In both these cases, the text printed to the console is <code>dog</code>. This is because the unary left fold expands to <code>(((std::cout &lt;&lt; 'd'), std::cout &lt;&lt; 'o'), &lt;&lt; std::cout &lt;&lt; 'g')</code> and the unary right fold expands to <code>(std::cout &lt;&lt; 'd', (std::cout &lt;&lt; 'o', (std::cout &lt;&lt; 'g')))</code> and these two are evaluated in the same way. This is because a<a id="_idIndexMarker245"/> pair of expressions separated by a comma is evaluated left to right. This is true for the built-in comma operator. For types that overload the comma operator, the behavior depends on how the operator is overloaded. However, there are very few corner cases for overloading the comma operator (such as simplifying indexing multi-dimensional arrays). Libraries such as <code>Boost.Assign</code> and <code>SOCI</code> overload the comma operator, but, in general, this is an operator you should avoid overloading.</p>
			<p>Let's consider another example for using the parameter pack in an expression inside a fold expression. The following variadic function template inserts multiple values to the end of a <code>std::vector</code>:</p>
			<pre class="source-code">template&lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">void push_back_many(std::vector&lt;T&gt;&amp; v, Args&amp;&amp;... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   (v.push_back(args), ...);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">push_back_many(v, 1, 2, 3, 4, 5); // v = {1, 2, 3, 4, 5}</pre>
			<p>The parameter pack <code>args</code> is used with the <code>v.push_back(args)</code> expression that is folded over the comma operator. The unary left fold expression is <code>(v.push_back(args), ...)</code>.</p>
			<p>Fold expressions have several benefits over the use of recursion to implement variadic templates. These benefits<a id="_idIndexMarker246"/> are as follows:</p>
			<ul>
				<li>Less and simpler code to write.</li>
				<li>Fewer template instantiations, which leads to faster compile times.</li>
				<li>Potentially faster code since multiple function calls are replaced with a single expression. However, this point may not be true in practice, at least not when optimizations are enabled. We have already seen that the compilers optimize code by removing these function calls.</li>
			</ul>
			<p>Now that we have seen how to create variadic function templates, variadic class templates, and how to use fold expressions, we are left to discuss the other kinds of templates that can be variadic: alias templates and variable templates. We will start with the former.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor058"/>Variadic alias templates</h1>
			<p>Everything that can be templatized <a id="_idIndexMarker247"/>can also be made variadic. An alias template is an alias (another name) for a family of types. A variadic alias template is a name for a family of types with a variable number of template parameters. With the knowledge accumulated so far, it should be fairly trivial to write alias templates. Let's see an example:</p>
			<pre class="source-code">template &lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">struct foo </pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename... Args&gt;</pre>
			<pre class="source-code">using int_foo = foo&lt;int, Args...&gt;;</pre>
			<p>The class template <code>foo</code> is variadic and takes at least one type template argument. <code>int_foo</code>, on the other hand, is only a different name for a family of types instantiated from the <code>foo</code> type with <code>int</code> as the first type template arguments. These could be used as follows:</p>
			<pre class="source-code">foo&lt;double, char, int&gt; f1;</pre>
			<pre class="source-code">foo&lt;int, char, double&gt; f2;</pre>
			<pre class="source-code">int_foo&lt;char, double&gt; f3;</pre>
			<pre class="source-code">static_assert(std::is_same_v&lt;decltype(f2), decltype(f3)&gt;);</pre>
			<p>In this snippet, <code>f1</code> on one hand and <code>f2</code> and <code>f3</code> on the other are instances of different <code>foo</code> types, as they are instantiated from different sets of template arguments for <code>foo</code>. However, <code>f2</code> and <code>f3</code> are instances of the same type, <code>foo&lt;int, char, double&gt;</code>, since <code>int_foo&lt;char, double&gt;</code> is just an alias for this type.</p>
			<p>A similar example, although a bit more complex, is presented ahead. The standard library contains a class template called <code>std::integer_sequence</code>, which represents a compile-time sequence of integers, along with a bunch of alias templates to help create various kinds of such integer sequences. Although the code shown here is a simplified snippet, their<a id="_idIndexMarker248"/> implementation can, at least conceptually, be as follows:</p>
			<pre class="source-code">template&lt;typename T, T... Ints&gt;</pre>
			<pre class="source-code">struct integer_sequence</pre>
			<pre class="source-code">{};</pre>
			<pre class="source-code">template&lt;std::size_t... Ints&gt;</pre>
			<pre class="source-code">using index_sequence = integer_sequence&lt;std::size_t,</pre>
			<pre class="source-code">                                        Ints...&gt;;</pre>
			<pre class="source-code">template&lt;typename T, std::size_t N, T... Is&gt;</pre>
			<pre class="source-code">struct make_integer_sequence : </pre>
			<pre class="source-code">  make_integer_sequence&lt;T, N - 1, N - 1, Is...&gt; </pre>
			<pre class="source-code">{};</pre>
			<pre class="source-code">template&lt;typename T, T... Is&gt;</pre>
			<pre class="source-code">struct make_integer_sequence&lt;T, 0, Is...&gt; : </pre>
			<pre class="source-code">  integer_sequence&lt;T, Is...&gt; </pre>
			<pre class="source-code">{};</pre>
			<pre class="source-code">template&lt;std::size_t N&gt;</pre>
			<pre class="source-code">using make_index_sequence = make_integer_sequence&lt;std::size_t, </pre>
			<pre class="source-code">                                                  N&gt;;</pre>
			<pre class="source-code">template&lt;typename... T&gt;</pre>
			<pre class="source-code">using index_sequence_for = </pre>
			<pre class="source-code">   make_index_sequence&lt;sizeof...(T)&gt;;</pre>
			<p>There are three alias templates here:</p>
			<ul>
				<li><code>index_sequence</code>, which <a id="_idIndexMarker249"/>creates an <code>integer_sequence</code> for the <code>size_t</code> type; this is a variadic alias template.</li>
				<li><code>index_sequence_for</code>, which <a id="_idIndexMarker250"/>creates an <code>integer_sequence</code> from a parameter pack; this is also a variadic alias template.</li>
				<li><code>make_index_sequence</code>, which<a id="_idIndexMarker251"/> creates an <code>integer_sequence</code> for the <code>size_t</code> type with the values 0, 1, 2, …, <em class="italic">N-1</em>. Unlike the previous ones, this is not an alias for a variadic template.</li>
			</ul>
			<p>The last subject to address in this chapter is variadic variable templates.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor059"/>Variadic variable templates</h1>
			<p>As mentioned before, variable templates may also be variadic. However, variables cannot be defined recursively, nor can they be specialized like class templates. Fold expressions, which simplify<a id="_idIndexMarker252"/> generating expressions from a variable number of arguments, are very handy for creating variadic variable templates.</p>
			<p>In the following example, we define a variadic variable template called <code>Sum</code> that is initialized at compile-time with the sum of all integers supplied as non-type template arguments:</p>
			<pre class="source-code">template &lt;int... R&gt;</pre>
			<pre class="source-code">constexpr int Sum = (... + R);</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    std::cout &lt;&lt; Sum&lt;1&gt; &lt;&lt; '\n';</pre>
			<pre class="source-code">    std::cout &lt;&lt; Sum&lt;1,2&gt; &lt;&lt; '\n';</pre>
			<pre class="source-code">    std::cout &lt;&lt; Sum&lt;1,2,3,4,5&gt; &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>This is similar to the <code>sum</code> function written with the help of fold expressions. However, in that case, the numbers to add were provided as function arguments. Here, they are provided as template arguments to the variable template. The difference is mostly syntactic; with optimizations enabled, the end result is likely the same in terms of generated assembly code, and therefore performance.</p>
			<p>Variadic variable templates follow the same patterns as all the other kinds of templates although they are not used as much as the others. However, by concluding this topic we have now completed the learning of variadic templates in C++.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor060"/>Summary</h1>
			<p>In this chapter, we have explored an important category of templates, variadic templates, which are templates with a variable number of template arguments. We can create variadic function templates, class templates, variable templates, and alias templates. The techniques to create variadic function templates and variadic class templates are different but incur a form of compile-time recursion. For the latter, this is done with template specialization, while for the former with function overloads. Fold expressions help to expand a variable number of arguments into a single expression, avoiding the need of using function overloads and enabling the creation of some categories of variadic variable templates such as the ones we have previously seen.</p>
			<p>In the next chapter, we will look into a series of more advanced features that will help you consolidate your knowledge of templates.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor061"/>Questions</h1>
			<ol>
				<li>What are variadic templates and why are they useful?</li>
				<li>What is a parameter pack?</li>
				<li>What are the contexts where parameter packs can be expanded?</li>
				<li>What are fold expressions?</li>
				<li>What are the benefits of using fold expressions?</li>
			</ol>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor062"/>Further reading</h1>
			<ul>
				<li><em class="italic">C++ Fold Expressions 101</em>,  Jonathan Boccara, <a href="https://www.fluentcpp.com/2021/03/12/cpp-fold-expressions/">https://www.fluentcpp.com/2021/03/12/cpp-fold-expressions/</a></li>
				<li><em class="italic">Fold Expressions in C++ 17</em>,  Vaibhav, <a href="https://mainfunda.com/fold-expressions-in-cpp17/">https://mainfunda.com/fold-expressions-in-cpp17/</a></li>
				<li><em class="italic">Nifty Fold Expression Tricks</em>,  Jonathan Müller, <a href="https://www.foonathan.net/2020/05/fold-tricks/">https://www.foonathan.net/2020/05/fold-tricks/</a></li>
			</ul>
		</div>
	</div></body></html>