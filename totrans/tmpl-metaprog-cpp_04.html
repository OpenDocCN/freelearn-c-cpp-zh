<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer011">
			<h1 id="_idParaDest-46"><em class="italic"><a id="_idTextAnchor051"/>Chapter 3</em>: Variadic Templates</h1>
			<p>A variadic template is a template with a variable number of arguments. This is a feature that was introduced in C++11. It combines generic code with functions with variable numbers of arguments, a feature that was inherited from the C language. Although the syntax and some details could be seen as cumbersome, variadic templates help us write function templates with a variable number of arguments or class templates with a variable number of data members in a way that was not possible before with compile time evaluation and type safety.</p>
			<p>In this chapter, we will learn about the following topics:</p>
			<ul>
				<li>Understanding the need for variadic templates</li>
				<li>Variadic function templates</li>
				<li>Parameter packs</li>
				<li>Variadic class templates</li>
				<li>Fold expressions</li>
				<li>Variadic alias templates</li>
				<li>Variadic variable templates</li>
			</ul>
			<p>By the end of the chapter, you will have a good understanding of how to write variadic templates and how they work.</p>
			<p>We will start, however, by trying to understand why templates with variable numbers of arguments are helpful.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor052"/>Understanding the need for variadic templates</h1>
			<p>One of the most famous C and C++ functions<a id="_idIndexMarker189"/> is <strong class="source-inline">printf</strong>, which writes formatted output to the <strong class="source-inline">stdout</strong> standard output stream. There is actually a family of functions in the I/O library for writing formatted output, which also includes <strong class="source-inline">fprintf</strong> (which writes to a file stream), <strong class="source-inline">sprint</strong>, and <strong class="source-inline">snprintf</strong> (which write to a character buffer). These functions are similar because they take a string defining the output format and a variable number of arguments. The language, however, provides us with the means<a id="_idIndexMarker190"/> to write our own functions with variable numbers of arguments. Here is an example of a function that takes one or more arguments and returns the minimum value:</p>
			<pre class="source-code">#include&lt;stdarg.h&gt;</pre>
			<pre class="source-code">int min(int count, ...)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   va_list args;</pre>
			<pre class="source-code">   va_start(args, count);</pre>
			<pre class="source-code">   int val = va_arg(args, int);</pre>
			<pre class="source-code">   for (int i = 1; i &lt; count; i++)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      int n = va_arg(args, int);</pre>
			<pre class="source-code">      if (n &lt; val)</pre>
			<pre class="source-code">         val = n;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   va_end(args);</pre>
			<pre class="source-code">   return val;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "min(42, 7)=" &lt;&lt; min(2, 42, 7) &lt;&lt; '\n';</pre>
			<pre class="source-code">   std::cout &lt;&lt; "min(1,5,3,-4,9)=" &lt;&lt; </pre>
			<pre class="source-code">                 min(5, 1, 5, 3, -4, </pre>
			<pre class="source-code">              9) &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>This implementation is <a id="_idIndexMarker191"/>specific for values of the <strong class="source-inline">int</strong> type. However, it is possible to write a similar function that is a function template. The transformation requires minimal changes and the result is as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T min(int count, ...)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   va_list args;</pre>
			<pre class="source-code">   va_start(args, count);</pre>
			<pre class="source-code">   T val = va_arg(args, T);</pre>
			<pre class="source-code">   for (int i = 1; i &lt; count; i++)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      T n = va_arg(args, T);</pre>
			<pre class="source-code">      if (n &lt; val)</pre>
			<pre class="source-code">         val = n;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   va_end(args);</pre>
			<pre class="source-code">   return val;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "min(42.0, 7.5)="</pre>
			<pre class="source-code">             &lt;&lt; min&lt;double&gt;(2, 42.0, 7.5) &lt;&lt; '\n';</pre>
			<pre class="source-code">   std::cout &lt;&lt; "min(1,5,3,-4,9)=" </pre>
			<pre class="source-code">             &lt;&lt; min&lt;int&gt;(5, 1, 5, 3, -4, 9) &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>Writing code like this, whether<a id="_idIndexMarker192"/> generic or not, has several important drawbacks:</p>
			<ul>
				<li>It requires the use of <a id="_idIndexMarker193"/>several macros: <strong class="source-inline">va_list</strong> (which provides access to the information needed by the others), <strong class="source-inline">va_start</strong> (starts the iterating of the arguments), <strong class="source-inline">va_arg</strong> (provides access to the next argument), and <strong class="source-inline">va_end</strong> (stops the iterating of the arguments).</li>
				<li>Evaluation happens at runtime, even though the number and the type of the arguments passed to the function are known at compile-time.</li>
				<li>Variadic functions implemented in this manner are not type-safe. The <strong class="source-inline">va_</strong> macros perform low-memory manipulation and type-casts are done in <strong class="source-inline">va_arg</strong> at runtime. These could lead to runtime exceptions.</li>
				<li>These variadic functions require specifying in some way the number of variable arguments. In the implementation of the earlier <strong class="source-inline">min</strong> function, there is a first parameter that indicates the number of arguments. The <strong class="source-inline">printf</strong>-like functions take a formatting string from which the number of expected arguments is determined. The <strong class="source-inline">printf</strong> function, for example, evaluates and then ignores additional arguments (if more are supplied than the number specified in the formatting string) but has undefined behavior if fewer arguments are supplied.</li>
			</ul>
			<p>In addition to all these things, only functions could be variadic, prior to C++11. However, there are classes that could also benefit from being able to have a variable number of data members. Typical examples are the <strong class="source-inline">tuple</strong> class, which represents a fixed-size collection of heterogeneous values, and <strong class="source-inline">variant</strong>, which is a type-safe union.</p>
			<p>Variadic templates help address all these issues. They are evaluated at compile-time, are type-safe, do not require macros, do not require explicitly specifying the number of arguments, and we can <a id="_idIndexMarker194"/>write both variadic function templates and variadic class templates. Moreover, we also have variadic variable templates and variadic alias templates.</p>
			<p>In the next section, we will start looking into variadic function templates.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor053"/>Variadic function templates</h1>
			<p>Variadic function templates<a id="_idIndexMarker195"/> are template functions with a variable number of arguments. They borrow the use of the ellipsis (<strong class="source-inline">...</strong>) for specifying a pack of arguments, which can have different syntax depending on its nature. </p>
			<p>To understand the fundamentals for variadic function templates, let's start with an example that rewrites the previous <strong class="source-inline">min</strong> function:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T min(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a &lt; b ? a : b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">T min(T a, Args... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return min(a, min(args...));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; "min(42.0, 7.5)=" &lt;&lt; min(42.0, 7.5) </pre>
			<pre class="source-code">             &lt;&lt; '\n';</pre>
			<pre class="source-code">   std::cout &lt;&lt; "min(1,5,3,-4,9)=" &lt;&lt; min(1, 5, 3, -4, 9)</pre>
			<pre class="source-code">             &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>What we have here are two<a id="_idIndexMarker196"/> overloads for the <strong class="source-inline">min</strong> function. The first is a function template with two parameters that returns the smallest of the two arguments. The second is a function template with a variable number of arguments that recursively calls itself with an expansion of the parameters pack. Although variadic function template implementations look like using some sort of compile-time recursion mechanism (in this case the overload with two parameters acting as the end case), in fact, they're only relying on overloaded functions, instantiated from the template and the set of provided arguments.</p>
			<p>The ellipsis (<strong class="source-inline">...</strong>) is used in three different places, with different meanings, in the implementation of a variadic function template, as can be seen in our example:</p>
			<ul>
				<li>To specify a pack of <a id="_idIndexMarker197"/>parameters in the template parameters list, as in <strong class="source-inline">typename... Args</strong>. This is called a <strong class="bold">template parameter pack</strong>. Template<a id="_idIndexMarker198"/> parameter packs can be defined for type templates, non-type templates, and template template parameters.</li>
				<li>To specify a pack of<a id="_idIndexMarker199"/> parameters in the function parameters list, as in <strong class="source-inline">Args... args</strong>. This is called a <strong class="bold">function parameter pack</strong>.</li>
				<li>To expand a pack<a id="_idIndexMarker200"/> in the body of a function, as in <strong class="source-inline">args…</strong>, seen in the call <strong class="source-inline">min(args…)</strong>. This is called a <strong class="bold">parameter pack expansion</strong>. The result of such an expansion is a comma-separated list of zero or more values (or expressions). This topic will be covered in more detail in the next section.</li>
			</ul>
			<p>From the call <strong class="source-inline">min(1, 5, 3, -4, 9)</strong>, the compiler is instantiating a set of overloaded functions with 5, 4, 3, and 2 arguments. Conceptually, it is the same as having the following set of overloaded functions:</p>
			<pre class="source-code">int min(int a, int b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a &lt; b ? a : b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int min(int a, int b, int c)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return min(a, min(b, c));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int min(int a, int b, int c, int d)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return min(a, min(b, min(c, d)));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int min(int a, int b, int c, int d, int e)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return min(a, min(b, min(c, min(d, e))));</pre>
			<pre class="source-code">}</pre>
			<p>As a result, <strong class="source-inline">min(1, 5, 3, -4, 9)</strong> expands to <strong class="source-inline">min(1, min(5, min(3, min(-4, 9))))</strong>. This<a id="_idIndexMarker201"/> can raise questions about the performance of variadic templates. In practice, however, the compilers perform a lot of optimizations, such as inlining as much as possible. The result is that, in practice, when optimizations are enabled, there will be no actual function calls. You can use online resources, such as <strong class="bold">Compiler Explorer</strong> (<a href="https://godbolt.org/">https://godbolt.org/</a>), to see the code generated by <a id="_idIndexMarker202"/>different compilers with different options (such as optimization settings). For instance, let's consider the<a id="_idIndexMarker203"/> following snippet (where <strong class="source-inline">min</strong> is the variadic function template with the implementation shown earlier):</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{    </pre>
			<pre class="source-code">   std::cout &lt;&lt; min(1, 5, 3, -4, 9);</pre>
			<pre class="source-code">}</pre>
			<p>Compiling this with GCC 11.2 with the <strong class="source-inline">-O</strong> flag for optimizations produces the following assembly code:</p>
			<pre class="source-code">sub     rsp, 8</pre>
			<pre class="source-code">mov     esi, -4</pre>
			<pre class="source-code">mov     edi, OFFSET FLAT:_ZSt4cout</pre>
			<pre class="source-code">call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;</pre>
			<pre class="source-code">           ::operator&lt;&lt;(int)</pre>
			<pre class="source-code">mov     eax, 0</pre>
			<pre class="source-code">add     rsp, 8</pre>
			<pre class="source-code">ret</pre>
			<p>You don't need to be <a id="_idIndexMarker204"/>an expert in assembly to understand what's happening here. The evaluation of the call to <strong class="source-inline">min(1, 5, 3, -4, 9)</strong> is done at compile-time and the result, <strong class="source-inline">-4</strong>, is loaded directly into the ESI register. There are no runtime calls, in this particular case, or computation, since everything is known at compile-time. Of course, that is not necessarily always the case. </p>
			<p>The following snippet shows an invocation on the <strong class="source-inline">min</strong> function template that cannot be evaluated at compile-time because its arguments are only known at runtime:</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{    </pre>
			<pre class="source-code">    int a, b, c, d, e;</pre>
			<pre class="source-code">    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;</pre>
			<pre class="source-code">    std::cout &lt;&lt; min(a, b, c, d, e);</pre>
			<pre class="source-code">}</pre>
			<p>This time, the assembly code generated is the following (only showing here the code for the call to the <strong class="source-inline">min</strong> function):</p>
			<pre class="source-code">mov     esi, DWORD PTR [rsp+12]</pre>
			<pre class="source-code">mov     eax, DWORD PTR [rsp+16]</pre>
			<pre class="source-code">cmp     esi, eax</pre>
			<pre class="source-code">cmovg   esi, eax</pre>
			<pre class="source-code">mov     eax, DWORD PTR [rsp+20]</pre>
			<pre class="source-code">cmp     esi, eax</pre>
			<pre class="source-code">cmovg   esi, eax</pre>
			<pre class="source-code">mov     eax, DWORD PTR [rsp+24]</pre>
			<pre class="source-code">cmp     esi, eax</pre>
			<pre class="source-code">cmovg   esi, eax</pre>
			<pre class="source-code">mov     eax, DWORD PTR [rsp+28]</pre>
			<pre class="source-code">cmp     esi, eax</pre>
			<pre class="source-code">cmovg   esi, eax</pre>
			<pre class="source-code">mov     edi, OFFSET FLAT:_ZSt4cout</pre>
			<pre class="source-code">call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt; </pre>
			<pre class="source-code">             ::operator&lt;&lt;(int)</pre>
			<p>We can see from this listing <a id="_idIndexMarker205"/>that the compiler has inlined all the calls to the <strong class="source-inline">min</strong> overloads. There is only a series of instructions for loading values into registers, comparisons of register values, and jumps based on the comparison result, but there are no function calls.</p>
			<p>When optimizations are disabled, function calls do occur. We can trace these calls that occur during the invocation of the <strong class="source-inline">min</strong> function by using compiler-specific macros. GCC and Clang provide a macro called <strong class="source-inline">__PRETTY_FUNCTION__</strong> that contains the signature of a function and<a id="_idIndexMarker206"/> its name. Similarly, Visual C++ provides a <a id="_idIndexMarker207"/>macro, called <strong class="source-inline">__FUNCSIG__</strong>, that does the same. These could be used within the body of a function to print its name and signature. We can use them as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T min(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)</pre>
			<pre class="source-code">   std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n";</pre>
			<pre class="source-code">#elif defined(_MSC_VER)</pre>
			<pre class="source-code">   std::cout &lt;&lt; __FUNCSIG__ &lt;&lt; "\n";</pre>
			<pre class="source-code">#endif</pre>
			<pre class="source-code">   return a &lt; b ? a : b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">T min(T a, Args... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)</pre>
			<pre class="source-code">   std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n";</pre>
			<pre class="source-code">#elif defined(_MSC_VER)</pre>
			<pre class="source-code">   std::cout &lt;&lt; __FUNCSIG__ &lt;&lt; "\n";</pre>
			<pre class="source-code">#endif</pre>
			<pre class="source-code">   return min(a, min(args...));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   min(1, 5, 3, -4, 9);</pre>
			<pre class="source-code">}</pre>
			<p>The result of the execution of this program, when compiled with Clang, is the following:</p>
			<p class="source-code">T min(T, Args...) [T = int, Args = &lt;int, int, int, int&gt;]</p>
			<p class="source-code">T min(T, Args...) [T = int, Args = &lt;int, int, int&gt;]</p>
			<p class="source-code">T min(T, Args...) [T = int, Args = &lt;int, int&gt;]</p>
			<p class="source-code">T min(T, T) [T = int]</p>
			<p class="source-code">T min(T, T) [T = int]</p>
			<p class="source-code">T min(T, T) [T = int]</p>
			<p class="source-code">T min(T, T) [T = int]</p>
			<p>On the other hand, when compiled with Visual C++, the output is the following:</p>
			<p class="source-code">int __cdecl min&lt;int,int,int,int,int&gt;(int,int,int,int,int)</p>
			<p class="source-code">int __cdecl min&lt;int,int,int,int&gt;(int,int,int,int)</p>
			<p class="source-code">int __cdecl min&lt;int,int,int&gt;(int,int,int)</p>
			<p class="source-code">int __cdecl min&lt;int&gt;(int,int)</p>
			<p class="source-code">int __cdecl min&lt;int&gt;(int,int)</p>
			<p class="source-code">int __cdecl min&lt;int&gt;(int,int)</p>
			<p class="source-code">int __cdecl min&lt;int&gt;(int,int)</p>
			<p>Although the way the <a id="_idIndexMarker208"/>signature is formatted is significantly different between Clang/GCC on one hand and VC++ on the other hand, they all show the same: first, an overloaded function with five parameters is called, then one with four parameters, then one with three, and, in the end, there are four calls to the overload with two parameters (which marks the end of the expansion). </p>
			<p>Understanding the expansion<a id="_idIndexMarker209"/> of parameter packs is key to understanding variadic templates. Therefore, we'll explore this topic in detail in the next section.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor054"/>Parameter packs</h1>
			<p>A template or function parameter<a id="_idIndexMarker210"/> pack can accept zero, one, or more arguments. The standard does not specify any upper limit for the number of arguments, but in practice, compilers may have some. What the standard does is recommend minimum values for these limits but it does not require any compliance on them. These limits are as follows:</p>
			<ul>
				<li>For a function parameter pack, the maximum number of arguments depends on the limit of arguments for a function call, which is recommended to be at least 256.</li>
				<li>For a template parameter pack, the maximum number of arguments depends on the limit of template parameters, which is recommended to be at least 1,024.</li>
			</ul>
			<p>The number of arguments in a parameter pack can be retrieved at compile time with the <strong class="source-inline">sizeof…</strong> operator. This operator returns a <strong class="source-inline">constexpr</strong> value of the <strong class="source-inline">std::size_t</strong> type. Let's see this at work in a couple of examples. </p>
			<p>In the first example, the <strong class="source-inline">sizeof…</strong> operator is used to implement the end of the recursion pattern of the variadic function template <strong class="source-inline">sum</strong> with the help of a <strong class="source-inline">constexpr if</strong> statement. If the number of the arguments in the parameter pack is zero (meaning there is a single argument to the function) then we are processing the last argument, so we just return the value. Otherwise, we add the first argument to the sum of the remaining ones. The implementation looks as follows:</p>
			<pre class="source-code">template &lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">T sum(T a, Args... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (sizeof...(args) == 0)</pre>
			<pre class="source-code">      return a;</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">      return a + sum(args...);</pre>
			<pre class="source-code">}</pre>
			<p>This is semantically equivalent, but<a id="_idIndexMarker211"/> on the other hand more concise, than the following classical approach for the variadic function template implementation:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T sum(T a)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">T sum(T a, Args... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + sum(args...);</pre>
			<pre class="source-code">}</pre>
			<p>Notice that <strong class="source-inline">sizeof…(args)</strong> (the function parameter pack) and <strong class="source-inline">sizeof…(Args)</strong> (the template parameter pack) return the same value. On the other hand, <strong class="source-inline">sizeof…(args)</strong> and <strong class="source-inline">sizeof(args)...</strong> are not the same thing. The former is the <strong class="source-inline">sizeof</strong> operator used on the parameter pack <strong class="source-inline">args</strong>. The latter is an expansion of the parameter pack <strong class="source-inline">args</strong> on the <strong class="source-inline">sizeof</strong> operator. These are both shown in the following example:</p>
			<pre class="source-code">template&lt;typename... Ts&gt;</pre>
			<pre class="source-code">constexpr auto get_type_sizes()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return std::array&lt;std::size_t, </pre>
			<pre class="source-code">                     sizeof...(Ts)&gt;{sizeof(Ts)...};</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">auto sizes = get_type_sizes&lt;short, int, long, long long&gt;();</pre>
			<p>In this snippet, <strong class="source-inline">sizeof…(Ts)</strong> evaluates to <strong class="source-inline">4</strong> at compile-time, while <strong class="source-inline">sizeof(Ts)...</strong> is expanded to the following comma-separated pack of arguments: <strong class="source-inline">sizeof(short), sizeof(int), sizeof(long), sizeof(long long)</strong>. Conceptually, the preceding function <a id="_idIndexMarker212"/>template, <strong class="source-inline">get_type_sizes</strong>, is equivalent to the following function template with four template parameters:</p>
			<pre class="source-code">template&lt;typename T1, typename T2, </pre>
			<pre class="source-code">         typename T3, typename T4&gt;</pre>
			<pre class="source-code">constexpr auto get_type_sizes()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return std::array&lt;std::size_t, 4&gt; {</pre>
			<pre class="source-code">      sizeof(T1), sizeof(T2), sizeof(T3), sizeof(T4)</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">}</pre>
			<p>Typically, the parameter pack is the trailing parameter of a function or template. However, if the compiler can deduce the arguments, then a parameter pack can be followed by other parameters including more parameter packs. Let's consider the following example:</p>
			<pre class="source-code">template &lt;typename... Ts, typename... Us&gt;</pre>
			<pre class="source-code">constexpr auto multipacks(Ts... args1, Us... args2)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::cout &lt;&lt; sizeof...(args1) &lt;&lt; ','</pre>
			<pre class="source-code">             &lt;&lt; sizeof...(args2) &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>This function is supposed to take two sets of elements of possibly different types and do something with them. It can be invoked <a id="_idIndexMarker213"/>such as in the following examples:</p>
			<pre class="source-code">multipacks&lt;int&gt;(1, 2, 3, 4, 5, 6);</pre>
			<pre class="source-code">                 // 1,5</pre>
			<pre class="source-code">multipacks&lt;int, int, int&gt;(1, 2, 3, 4, 5, 6);</pre>
			<pre class="source-code">                // 3,3</pre>
			<pre class="source-code">multipacks&lt;int, int, int, int&gt;(1, 2, 3, 4, 5, 6);</pre>
			<pre class="source-code">               // 4,2</pre>
			<pre class="source-code">multipacks&lt;int, int, int, int, int, int&gt;(1, 2, 3, 4, 5, 6); </pre>
			<pre class="source-code">               // 6,0</pre>
			<p>For the first call, the <strong class="source-inline">args1</strong> pack is specified at the function call (as in <strong class="source-inline">multipacks&lt;int&gt;</strong>) and contains <strong class="source-inline">1</strong>, and <strong class="source-inline">args2</strong> is deduced to be <strong class="source-inline">2, 3, 4, 5, 6</strong> from the function arguments. Similarly, for the second call, the two packs will have an equal number of arguments, more precisely <strong class="source-inline">1, 2, 3</strong> and <strong class="source-inline">3, 4, 6</strong>. For the last call, the first pack contains all the elements, and the second pack is empty. In all these examples, all the elements are of the <strong class="source-inline">int</strong> type. However, in the following examples, the two packs contain elements of different types:</p>
			<pre class="source-code">multipacks&lt;int, int&gt;(1, 2, 4.0, 5.0, 6.0);         // 2,3</pre>
			<pre class="source-code">multipacks&lt;int, int, int&gt;(1, 2, 3, 4.0, 5.0, 6.0); // 3,3</pre>
			<p>For the first call, the <strong class="source-inline">args1</strong> pack will contain the integers <strong class="source-inline">1, 2</strong> and the <strong class="source-inline">args2</strong> pack will be deduced to contain the double values <strong class="source-inline">4.0, 5.0, 6.0</strong>. Similarly, for the second call, the <strong class="source-inline">args1</strong> pack will be <strong class="source-inline">1, 2, 3</strong> and the <strong class="source-inline">args2</strong> pack will contain <strong class="source-inline">4.0, 5.0, 6.0</strong>.</p>
			<p>However, if we change the function template <strong class="source-inline">multipacks</strong> a bit by requiring that the packs be of equal size, then only some of the calls shown earlier would still be possible. This is shown in the following example:</p>
			<pre class="source-code">template &lt;typename... Ts, typename... Us&gt;</pre>
			<pre class="source-code">constexpr auto multipacks(Ts... args1, Us... args2)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static_assert(</pre>
			<pre class="source-code">      sizeof...(args1) == sizeof...(args2),</pre>
			<pre class="source-code">      "Packs must be of equal sizes.");</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">multipacks&lt;int&gt;(1, 2, 3, 4, 5, 6);                   // error</pre>
			<pre class="source-code">multipacks&lt;int, int, int&gt;(1, 2, 3, 4, 5, 6);         // OK</pre>
			<pre class="source-code">multipacks&lt;int, int, int, int&gt;(1, 2, 3, 4, 5, 6);    // error</pre>
			<pre class="source-code">multipacks&lt;int, int, int, int, int, int&gt;(1, 2, 3, 4, 5, 6); </pre>
			<pre class="source-code">                                                     // error</pre>
			<pre class="source-code">multipacks&lt;int, int&gt;(1, 2, 4.0, 5.0, 6.0);           // error</pre>
			<pre class="source-code">multipacks&lt;int, int, int&gt;(1, 2, 3, 4.0, 5.0, 6.0);   // OK</pre>
			<p>In this snippet, only the second and the sixth calls are valid. In these two cases, the two deduced packs have three elements each. In all the other cases, as resulting from the prior example, the packs have different sizes and the <strong class="source-inline">static_assert</strong> statement will generate an error at compile-time.</p>
			<p>Multiple parameter packs are <a id="_idIndexMarker214"/>not specific to variadic function templates. They can also be used for variadic class templates in partial specialization, provided that the compiler can deduce the template arguments. To exemplify this, we'll consider the case of a class template that represents a pair of function pointers. The implementation should allow for storing pointers to any function. To implement this, we define a primary template, called here <strong class="source-inline">func_pair</strong>, and a partial specialization with four template parameters: </p>
			<ul>
				<li>A type template parameter for the return type of the first function</li>
				<li>A template parameter pack for the parameter types of the first function</li>
				<li>A second type template parameter for the return type of the second function</li>
				<li>A second template parameter pack for the parameter types of the second function</li>
			</ul>
			<p>The <strong class="source-inline">func_pair</strong> class template is shown in the next listing:</p>
			<pre class="source-code">template&lt;typename, typename&gt;</pre>
			<pre class="source-code">struct func_pair;</pre>
			<pre class="source-code">template&lt;typename R1, typename... A1, </pre>
			<pre class="source-code">         typename R2, typename... A2&gt;</pre>
			<pre class="source-code">struct func_pair&lt;R1(A1...), R2(A2...)&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::function&lt;R1(A1...)&gt; f;</pre>
			<pre class="source-code">   std::function&lt;R2(A2...)&gt; g;</pre>
			<pre class="source-code">};</pre>
			<p>To demonstrate the use<a id="_idIndexMarker215"/> of this class template, let's also consider the following two functions:</p>
			<pre class="source-code">bool twice_as(int a, int b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a &gt;= b*2;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">double sum_and_div(int a, int b, double c)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return (a + b) / c;</pre>
			<pre class="source-code">}</pre>
			<p>We can instantiate the <strong class="source-inline">func_pair</strong> class template and use it to call these two functions as shown in the following snippet:</p>
			<pre class="source-code">func_pair&lt;bool(int, int), double(int, int, double)&gt; funcs{</pre>
			<pre class="source-code">   twice_as, sum_and_div };</pre>
			<pre class="source-code">funcs.f(42, 12);</pre>
			<pre class="source-code">funcs.g(42, 12, 10.0);</pre>
			<p>Parameter packs can be <a id="_idIndexMarker216"/>expanded in a variety of contexts and this will make the topic of the next section.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor055"/>Understanding parameter packs expansion</h2>
			<p>Parameter packs can appear<a id="_idIndexMarker217"/> in a multitude of contexts. The form of their expansion may depend on this context. These possible contexts are listed ahead along with examples:</p>
			<ul>
				<li><strong class="bold">Template parameter list</strong>: This is for<a id="_idIndexMarker218"/> when you specify parameters for a template:<p class="source-code">template &lt;typename... T&gt;</p><p class="source-code">struct outer</p><p class="source-code">{</p><p class="source-code">   template &lt;T... args&gt;</p><p class="source-code">   struct inner {};</p><p class="source-code">};</p><p class="source-code">outer&lt;int, double, char[5]&gt; a;</p></li>
				<li><strong class="bold">Template argument list</strong>: This<a id="_idIndexMarker219"/> is when you specify arguments for a template:<p class="source-code">template &lt;typename... T&gt;</p><p class="source-code">struct tag {};</p><p class="source-code">template &lt;typename T, typename U, typename ... Args&gt;</p><p class="source-code">void tagger()</p><p class="source-code">{</p><p class="source-code">   tag&lt;T, U, Args...&gt; t1;</p><p class="source-code">   tag&lt;T, Args..., U&gt; t2;</p><p class="source-code">   tag&lt;Args..., T, U&gt; t3;</p><p class="source-code">   tag&lt;U, T, Args...&gt; t4;</p><p class="source-code">}</p></li>
				<li><strong class="bold">Function parameter list</strong>: This is for when you specify parameters for a function template:<p class="source-code">template &lt;typename... Args&gt;</p><p class="source-code">void make_it(Args... args)</p><p class="source-code">{</p><p class="source-code">}</p><p class="source-code">make_it(42);</p><p class="source-code">make_it(42, 'a');</p></li>
				<li><strong class="bold">Function argument list</strong>: When the <a id="_idIndexMarker220"/>expansion pack appears inside the parenthesis of a function call, the largest expression or brace initialization list to the left of the ellipsis is the pattern that is expanded:<p class="source-code">template &lt;typename T&gt;</p><p class="source-code">T step_it(T value)</p><p class="source-code">{</p><p class="source-code">   return value+1;</p><p class="source-code">}</p><p class="source-code">template &lt;typename... T&gt;</p><p class="source-code">int sum(T... args)</p><p class="source-code">{</p><p class="source-code">   return (... + args);</p><p class="source-code">}</p><p class="source-code">template &lt;typename... T&gt;</p><p class="source-code">void do_sums(T... args)</p><p class="source-code">{</p><p class="source-code">   auto s1 = sum(args...);</p><p class="source-code">   // sum(1, 2, 3, 4)</p><p class="source-code">   auto s2 = sum(42, args...);</p><p class="source-code">   // sum(42, 1, 2, 3, 4)</p><p class="source-code">   auto s3 = sum(step_it(args)...); </p><p class="source-code">   // sum(step_it(1), step_it(2),... step_it(4))</p><p class="source-code">}</p><p class="source-code">do_sums(1, 2, 3, 4);</p></li>
				<li><strong class="bold">Parenthesized initializers</strong>: When the expansion pack appears inside the parenthesis of a direct initializer, function-style cast, member initializer, new expression, and other <a id="_idIndexMarker221"/>similar contexts, the rules are the same as for the context of function argument lists:<p class="source-code">template &lt;typename... T&gt;</p><p class="source-code">struct sum_wrapper</p><p class="source-code">{</p><p class="source-code">   sum_wrapper(T... args)</p><p class="source-code">   {</p><p class="source-code">      value = (... + args);</p><p class="source-code">   }</p><p class="source-code">   std::common_type_t&lt;T...&gt; value;</p><p class="source-code">};</p><p class="source-code">template &lt;typename... T&gt;</p><p class="source-code">void parenthesized(T... args)</p><p class="source-code">{</p><p class="source-code">   std::array&lt;std::common_type_t&lt;T...&gt;, </p><p class="source-code">              sizeof...(T)&gt; arr {args...};</p><p class="source-code">   // std::array&lt;int, 4&gt; {1, 2, 3, 4}</p><p class="source-code">   sum_wrapper sw1(args...);</p><p class="source-code">   // value = 1 + 2 + 3 + 4</p><p class="source-code">   sum_wrapper sw2(++args...);</p><p class="source-code">   // value = 2 + 3 + 4 + 5</p><p class="source-code">}</p><p class="source-code">parenthesized(1, 2, 3, 4);</p></li>
				<li><strong class="bold">Brace-enclosed initializers</strong>: This is <a id="_idIndexMarker222"/>when you perform initialization using the brace notation:<p class="source-code">template &lt;typename... T&gt;</p><p class="source-code">void brace_enclosed(T... args)</p><p class="source-code">{</p><p class="source-code">   int arr1[sizeof...(args) + 1] = {args..., 0};     </p><p class="source-code">   // arr1: {1,2,3,4,0}</p><p class="source-code">   int arr2[sizeof...(args)] = { step_it(args)... };</p><p class="source-code">   // arr2: {2,3,4,5}</p><p class="source-code">}</p><p class="source-code">brace_enclosed(1, 2, 3, 4);</p></li>
				<li><strong class="bold">Base specifiers and member initializer lists</strong>: A pack expansion may specify the list of base classes in <a id="_idIndexMarker223"/>a class declaration. In addition, it may also appear in the member initializer list, as this may be necessary to call the constructors of the base classes:<p class="source-code">struct A {};</p><p class="source-code">struct B {};</p><p class="source-code">struct C {};</p><p class="source-code">template&lt;typename... Bases&gt;</p><p class="source-code">struct X : public Bases...</p><p class="source-code">{</p><p class="source-code">   X(Bases const &amp; ... args) : Bases(args)...</p><p class="source-code">   { }</p><p class="source-code">};</p><p class="source-code">A a;</p><p class="source-code">B b;</p><p class="source-code">C c;</p><p class="source-code">X x(a, b, c);</p></li>
				<li><strong class="bold">Using declarations</strong>: In the <a id="_idIndexMarker224"/>context of deriving from a pack of base classes, it may also be useful to be able to introduce names from the base classes into the definition of the derived class. Therefore, a pack expansion may also appear in a <strong class="source-inline">using</strong> declaration. This is demonstrated based on the previous example:<p class="source-code">struct A </p><p class="source-code">{</p><p class="source-code">   void execute() { std::cout &lt;&lt; "A::execute\n"; }</p><p class="source-code">};</p><p class="source-code">struct B </p><p class="source-code">{</p><p class="source-code">   void execute() { std::cout &lt;&lt; "B::execute\n"; }</p><p class="source-code">};</p><p class="source-code">struct C </p><p class="source-code">{</p><p class="source-code">   void execute() { std::cout &lt;&lt; "C::execute\n"; }</p><p class="source-code">};</p><p class="source-code">template&lt;typename... Bases&gt;</p><p class="source-code">struct X : public Bases...</p><p class="source-code">{</p><p class="source-code">   X(Bases const &amp; ... args) : Bases(args)...</p><p class="source-code">   {}</p><p class="source-code">   using Bases::execute...;</p><p class="source-code">};</p><p class="source-code">A a;</p><p class="source-code">B b;</p><p class="source-code">C c;</p><p class="source-code">X x(a, b, c);</p><p class="source-code">x.A::execute();</p><p class="source-code">x.B::execute();</p><p class="source-code">x.C::execute();</p></li>
				<li><strong class="bold">Lambda captures</strong>: The capture clause <a id="_idIndexMarker225"/>of a lambda expression may contain a pack expansion, as shown in the following example:<p class="source-code">template &lt;typename... T&gt;</p><p class="source-code">void captures(T... args)</p><p class="source-code">{</p><p class="source-code">   auto l = [args...]{ </p><p class="source-code">               return sum(step_it(args)...); };</p><p class="source-code">   auto s = l();</p><p class="source-code">}</p><p class="source-code">captures(1, 2, 3, 4);</p></li>
				<li><strong class="bold">Fold expressions</strong>: These will be <a id="_idIndexMarker226"/>discussed in detail in the following section in this chapter:<p class="source-code">template &lt;typename... T&gt;</p><p class="source-code">int sum(T... args)</p><p class="source-code">{</p><p class="source-code">   return (... + args);</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">sizeof…</strong> operator: Examples have already been shown earlier in this section. Here is one again:<p class="source-code">template &lt;typename... T&gt;</p><p class="source-code">auto make_array(T... args)</p><p class="source-code">{</p><p class="source-code">   return std::array&lt;std::common_type_t&lt;T...&gt;, </p><p class="source-code">                     sizeof...(T)&gt; {args...};</p><p class="source-code">};</p><p class="source-code">auto arr = make_array(1, 2, 3, 4);</p></li>
				<li><strong class="bold">Alignment specifier</strong>: A pack expansion<a id="_idIndexMarker227"/> in an alignment specifier has the same effect as having multiple <strong class="source-inline">alignas</strong> specifiers applied to the same declaration. The parameter pack can be either a type or non-type pack. Examples for both cases are listed here:<p class="source-code">template &lt;typename... T&gt;</p><p class="source-code">struct alignment1</p><p class="source-code">{</p><p class="source-code">   alignas(T...) char a;</p><p class="source-code">};</p><p class="source-code">template &lt;int... args&gt;</p><p class="source-code">struct alignment2</p><p class="source-code">{</p><p class="source-code">   alignas(args...) char a;</p><p class="source-code">};</p><p class="source-code">alignment1&lt;int, double&gt; al1;</p><p class="source-code">alignment2&lt;1, 4, 8&gt; al2;</p></li>
				<li><strong class="bold">Attribute list</strong>: This is not supported by any <a id="_idIndexMarker228"/>compiler yet.</li>
			</ul>
			<p>Now that we have learned more about parameter packs and their expansion we can move forward and explore variadic class templates.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor056"/>Variadic class templates</h1>
			<p>Class templates may <a id="_idIndexMarker229"/>also have a variable number of template arguments. This is key to building some categories of types, such as <strong class="source-inline">tuple</strong> and <strong class="source-inline">variant</strong>, that are available in the standard library. In this section, we will see how we could write a simple implementation for a <strong class="source-inline">tuple</strong> class. A tuple is a type that represents a fixed-size collection of heterogeneous values.</p>
			<p>When implementing variadic function templates we used a recursion pattern with two overloads, one for the general case and one for ending the recursion. The same approach has to be taken with variadic class templates, except that we need to use specialization for this purpose. Next, you can see a minimal implementation for a tuple:</p>
			<pre class="source-code">template &lt;typename T, typename... Ts&gt;</pre>
			<pre class="source-code">struct tuple</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   tuple(T const&amp; t, Ts const &amp;... ts)</pre>
			<pre class="source-code">      : value(t), rest(ts...)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr int size() const { return 1 + rest.size(); }</pre>
			<pre class="source-code">   T            value;</pre>
			<pre class="source-code">   tuple&lt;Ts...&gt; rest;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct tuple&lt;T&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   tuple(const T&amp; t)</pre>
			<pre class="source-code">      : value(t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr int size() const { return 1; }</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">};</pre>
			<p>The first class is the primary template. It has two template parameters: a type template and a parameter pack. This means, at the minimum, there must be one type specified for instantiating this template. The primary template tuple has two member variables: <strong class="source-inline">value</strong>, of the <strong class="source-inline">T</strong> type, and <strong class="source-inline">rest</strong>, of type <strong class="source-inline">tuple&lt;Ts…&gt;</strong>. This is an expansion of the rest of the template arguments. This <a id="_idIndexMarker230"/>means a tuple of <strong class="source-inline">N</strong> elements will contain the first element and another tuple; this second tuple, in turn, contains the second element and yet another tuple; this third nested tuple contains the rest. And this pattern continues until we end up with a tuple with a single element. This is defined by the partial specialization <strong class="source-inline">tuple&lt;T&gt;</strong>. Unlike the primary template, this specialization does not aggregate another tuple object.</p>
			<p>We can use this simple implementation to write code like the following:</p>
			<pre class="source-code">tuple&lt;int&gt; one(42);</pre>
			<pre class="source-code">tuple&lt;int, double&gt; two(42, 42.0);</pre>
			<pre class="source-code">tuple&lt;int, double, char&gt; three(42, 42.0, 'a');</pre>
			<pre class="source-code">std::cout &lt;&lt; one.value &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; two.value &lt;&lt; ',' </pre>
			<pre class="source-code">          &lt;&lt; two.rest.value &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; three.value &lt;&lt; ',' </pre>
			<pre class="source-code">          &lt;&lt; three.rest.value &lt;&lt; ','</pre>
			<pre class="source-code">          &lt;&lt; three.rest.rest.value &lt;&lt; '\n';</pre>
			<p>Although this works, accessing elements through the <strong class="source-inline">rest</strong> member, such as in <strong class="source-inline">three.rest.rest.value</strong>, is very cumbersome. And the more elements a tuple has the more difficult it is to write code in this <a id="_idIndexMarker231"/>way. Therefore, we'd like to use some helper function to simplify accessing the elements of a tuple. The following is a snippet of how the previous could be transformed:</p>
			<pre class="source-code">std::cout &lt;&lt; get&lt;0&gt;(one) &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; get&lt;0&gt;(two) &lt;&lt; ','</pre>
			<pre class="source-code">          &lt;&lt; get&lt;1&gt;(two) &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; get&lt;0&gt;(three) &lt;&lt; ','</pre>
			<pre class="source-code">          &lt;&lt; get&lt;1&gt;(three) &lt;&lt; ','</pre>
			<pre class="source-code">          &lt;&lt; get&lt;2&gt;(three) &lt;&lt; '\n';</pre>
			<p>Here, <strong class="source-inline">get&lt;N&gt;</strong> is a variadic function template that takes a tuple as an argument and returns a reference to the element at the <strong class="source-inline">N</strong> index in the tuple. Its prototype could look like the following:</p>
			<pre class="source-code">template &lt;size_t N, typename... Ts&gt;</pre>
			<pre class="source-code">typename nth_type&lt;N, Ts...&gt;::value_type &amp; get(tuple&lt;Ts...&gt;&amp; t);</pre>
			<p>The template arguments are the index and a parameter pack of the tuple types. Its implementation, however, requires some helper types. First, we need to know what the type of the element is at the <strong class="source-inline">N</strong> index in the tuple. This can be retrieved with the help of the following <strong class="source-inline">nth_type</strong> variadic class template:</p>
			<pre class="source-code">template &lt;size_t N, typename T, typename... Ts&gt;</pre>
			<pre class="source-code">struct nth_type : nth_type&lt;N - 1, Ts...&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static_assert(N &lt; sizeof...(Ts) + 1,</pre>
			<pre class="source-code">                 "index out of bounds");</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T, typename... Ts&gt;</pre>
			<pre class="source-code">struct nth_type&lt;0, T, Ts...&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using value_type = T;</pre>
			<pre class="source-code">};</pre>
			<p>Again, we have a primary template that uses recursive inheritance, and the specialization for the index 0. The specialization defines an alias called <strong class="source-inline">value_type</strong> for the first type template (which is the head of the list of template arguments). This type is only used as a <a id="_idIndexMarker232"/>mechanism for determining the type of a tuple element. We need another variadic class template for retrieving the value. This is shown in the following listing:</p>
			<pre class="source-code">template &lt;size_t N&gt;</pre>
			<pre class="source-code">struct getter</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename... Ts&gt;</pre>
			<pre class="source-code">   static typename nth_type&lt;N, Ts...&gt;::value_type&amp; </pre>
			<pre class="source-code">   get(tuple&lt;Ts...&gt;&amp; t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return getter&lt;N - 1&gt;::get(t.rest);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;&gt;</pre>
			<pre class="source-code">struct getter&lt;0&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename T, typename... Ts&gt;</pre>
			<pre class="source-code">   static T&amp; get(tuple&lt;T, Ts...&gt;&amp; t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return t.value;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>We can see here the same recursive pattern, with a primary template and an explicit specialization. The class template is called <strong class="source-inline">getter</strong> and has a single template parameter, which is a non-type template parameter. This represents the index of the tuple element we want to access. This class template has a static member function called <strong class="source-inline">get</strong>. This is a variadic function template. The implementation in the primary template calls the <strong class="source-inline">get</strong> function with the <strong class="source-inline">rest</strong> member of the tuple as an argument. On the other hand, the<a id="_idIndexMarker233"/> implementation of the explicit specialization returns the reference to the member value of the tuple.</p>
			<p>With all these defined, we can now provide an actual implementation for the helper variadic function template <strong class="source-inline">get</strong>. This implementation relies on the <strong class="source-inline">getter</strong> class template and calls its <strong class="source-inline">get</strong> variadic function template: </p>
			<pre class="source-code">template &lt;size_t N, typename... Ts&gt;</pre>
			<pre class="source-code">typename nth_type&lt;N, Ts...&gt;::value_type &amp; </pre>
			<pre class="source-code">get(tuple&lt;Ts...&gt;&amp; t)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return getter&lt;N&gt;::get(t);</pre>
			<pre class="source-code">}</pre>
			<p>If this example seems a little bit complicated, perhaps analyzing it step by step will help you better understand how it all works. Therefore, let's start with the following snippet:</p>
			<pre class="source-code">tuple&lt;int, double, char&gt; three(42, 42.0, 'a');</pre>
			<pre class="source-code">get&lt;2&gt;(three);</pre>
			<p>We will use the <strong class="source-inline">cppinsights.io</strong> web tools to check the template instantiations that occur from this snippet. The first to look at is the class template <strong class="source-inline">tuple</strong>. We have a primary template and several <a id="_idIndexMarker234"/>specializations, as follows:</p>
			<pre class="source-code">template &lt;typename T, typename... Ts&gt;</pre>
			<pre class="source-code">struct tuple</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   tuple(T const&amp; t, Ts const &amp;... ts)</pre>
			<pre class="source-code">      : value(t), rest(ts...)</pre>
			<pre class="source-code">   { }</pre>
			<pre class="source-code">   constexpr int size() const { return 1 + rest.size(); }</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">   tuple&lt;Ts...&gt; rest;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt; struct tuple&lt;int, double, char&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  inline tuple(const int &amp; t, </pre>
			<pre class="source-code">               const double &amp; __ts1, const char &amp; __ts2)</pre>
			<pre class="source-code">  : value{t}, rest{tuple&lt;double, char&gt;(__ts1, __ts2)}</pre>
			<pre class="source-code">  {}</pre>
			<pre class="source-code">  inline constexpr int size() const;</pre>
			<pre class="source-code">  int value;</pre>
			<pre class="source-code">  tuple&lt;double, char&gt; rest;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt; struct tuple&lt;double, char&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  inline tuple(const double &amp; t, const char &amp; __ts1)</pre>
			<pre class="source-code">  : value{t}, rest{tuple&lt;char&gt;(__ts1)}</pre>
			<pre class="source-code">  {}</pre>
			<pre class="source-code">  inline constexpr int size() const;</pre>
			<pre class="source-code">  double value;</pre>
			<pre class="source-code">  tuple&lt;char&gt; rest;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt; struct tuple&lt;char&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  inline tuple(const char &amp; t)</pre>
			<pre class="source-code">  : value{t}</pre>
			<pre class="source-code">  {}</pre>
			<pre class="source-code">  inline constexpr int size() const;</pre>
			<pre class="source-code">  char value;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;typename T&gt;</pre>
			<pre class="source-code">struct tuple&lt;T&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   inline tuple(const T &amp; t) : value{t}</pre>
			<pre class="source-code">   { }</pre>
			<pre class="source-code">   inline constexpr int size() const</pre>
			<pre class="source-code">   { return 1; }</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">};</pre>
			<p>The <strong class="source-inline">tuple&lt;int, double, char&gt;</strong> structure contains an <strong class="source-inline">int</strong> and a <strong class="source-inline">tuple&lt;double, char&gt;</strong>, which contains a <strong class="source-inline">double</strong> and a <strong class="source-inline">tuple&lt;char&gt;</strong>, which, in turn, contains a <strong class="source-inline">char</strong> value. This last<a id="_idIndexMarker235"/> class represents the end of the recursive definition of the tuple. This can be conceptually represented graphically as follows:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="Images/Figure_3.1_B18367.jpg" alt="Figure 3.1 – An example tuple&#13;&#10;" width="684" height="598"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – An example tuple</p>
			<p>Next, we have the <strong class="source-inline">nth_type</strong> class template, for which, again, we have a primary template and several specializations, as<a id="_idIndexMarker236"/> follows:</p>
			<pre class="source-code">template &lt;size_t N, typename T, typename... Ts&gt;</pre>
			<pre class="source-code">struct nth_type : nth_type&lt;N - 1, Ts...&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static_assert(N &lt; sizeof...(Ts) + 1,</pre>
			<pre class="source-code">                 "index out of bounds");</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct nth_type&lt;2, int, double, char&gt; : </pre>
			<pre class="source-code">   public nth_type&lt;1, double, char&gt;</pre>
			<pre class="source-code">{ };</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct nth_type&lt;1, double, char&gt; : public nth_type&lt;0, char&gt;</pre>
			<pre class="source-code">{ };</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct nth_type&lt;0, char&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using value_type = char;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;typename T, typename ... Ts&gt;</pre>
			<pre class="source-code">struct nth_type&lt;0, T, Ts...&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using value_type = T;</pre>
			<pre class="source-code">};</pre>
			<p>The <strong class="source-inline">nth_type&lt;2, int, double, char&gt;</strong> specialization is derived from <strong class="source-inline">nth_type&lt;1, double, char&gt;</strong>, which in turn is derived from <strong class="source-inline">nth_type&lt;0, char&gt;</strong>, which is the last base class in the hierarchy (the end of the recursive hierarchy).</p>
			<p>The <strong class="source-inline">nth_type</strong> structure is used as the return type in the <strong class="source-inline">getter</strong> helper class template, which<a id="_idIndexMarker237"/> is instantiated as follows:</p>
			<pre class="source-code">template &lt;size_t N&gt;</pre>
			<pre class="source-code">struct getter</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template &lt;typename... Ts&gt;</pre>
			<pre class="source-code">   static typename nth_type&lt;N, Ts...&gt;::value_type&amp; </pre>
			<pre class="source-code">   get(tuple&lt;Ts...&gt;&amp; t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return getter&lt;N - 1&gt;::get(t.rest);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct getter&lt;2&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template&lt;&gt;</pre>
			<pre class="source-code">   static inline typename </pre>
			<pre class="source-code">   nth_type&lt;2UL, int, double, char&gt;::value_type &amp; </pre>
			<pre class="source-code">   get&lt;int, double, char&gt;(tuple&lt;int, double,  char&gt; &amp; t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return getter&lt;1&gt;::get(t.rest);</pre>
			<pre class="source-code">   } </pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct getter&lt;1&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template&lt;&gt;</pre>
			<pre class="source-code">   static inline typename nth_type&lt;1UL, double,</pre>
			<pre class="source-code">                                   char&gt;::value_type &amp;</pre>
			<pre class="source-code">   get&lt;double, char&gt;(tuple&lt;double, char&gt; &amp; t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return getter&lt;0&gt;::get(t.rest);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">struct getter&lt;0&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   template&lt;typename T, typename ... Ts&gt;</pre>
			<pre class="source-code">   static inline T &amp; get(tuple&lt;T, Ts...&gt; &amp; t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return t.value;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   template&lt;&gt;</pre>
			<pre class="source-code">   static inline char &amp; get&lt;char&gt;(tuple&lt;char&gt; &amp; t)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return t.value;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>Lastly, the <strong class="source-inline">get</strong> function<a id="_idIndexMarker238"/> template that we use to retrieve the value of an element of a <strong class="source-inline">tuple</strong> is defined as follows:</p>
			<pre class="source-code">template &lt;size_t N, typename... Ts&gt;</pre>
			<pre class="source-code">typename nth_type&lt;N, Ts...&gt;::value_type &amp; </pre>
			<pre class="source-code">get(tuple&lt;Ts...&gt;&amp; t)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return getter&lt;N&gt;::get(t);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">typename nth_type&lt;2UL, int, double, char&gt;::value_type &amp; </pre>
			<pre class="source-code">get&lt;2, int, double, char&gt;(tuple&lt;int, double, char&gt; &amp; t)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  return getter&lt;2&gt;::get(t);</pre>
			<pre class="source-code">}</pre>
			<p>Should there be more calls to the <strong class="source-inline">get</strong> function more specializations of <strong class="source-inline">get</strong> would exist. For instance, for <strong class="source-inline">get&lt;1&gt;(three)</strong>, the following specialization would be added:</p>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">typename nth_type&lt;1UL, int, double, char&gt;::value_type &amp; </pre>
			<pre class="source-code">get&lt;1, int, double, char&gt;(tuple&lt;int, double, char&gt; &amp; t)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  return getter&lt;1&gt;::get(t);</pre>
			<pre class="source-code">}</pre>
			<p>This example helped us demonstrate how to implement variadic class templates with a primary template for the general case and a specialization for the end case of the variadic recursion.</p>
			<p>You have probably noticed the use of the keyword <strong class="source-inline">typename</strong> to prefix the <strong class="source-inline">nth_type&lt;N, Ts...&gt;::value_type</strong> type, which<a id="_idIndexMarker239"/> is a <strong class="bold">dependent type</strong>. In C++20, this is no longer necessary. However, this topic will be addressed in detail in <a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced Template Concepts</em>.</p>
			<p>Because<a id="_idIndexMarker240"/> implementing variadic templates is often verbose and can be cumbersome, the C++17 standard added <strong class="bold">fold expressions</strong> to ease this task. We will explore this topic in the next section.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor057"/>Fold expressions</h1>
			<p>A <strong class="bold">fold expression</strong> is an expression<a id="_idIndexMarker241"/> involving a parameter pack that folds (or reduces) the elements of the parameter pack over a binary operator. To understand how this works, we will look at several examples. Earlier in this chapter, we implemented a variable function template called <strong class="source-inline">sum</strong> that returned the sum of all its supplied arguments. For convenience, we will show it again here:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T sum(T a)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">T sum(T a, Args... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + sum(args...);</pre>
			<pre class="source-code">}</pre>
			<p>With fold expressions, this implementation that requires two overloads can be reduced to the following form:</p>
			<pre class="source-code">template &lt;typename... T&gt;</pre>
			<pre class="source-code">int sum(T... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return (... + args);</pre>
			<pre class="source-code">}</pre>
			<p>There is no need for overloaded functions anymore. The expression <strong class="source-inline">(... + args)</strong> represents the fold expression, which<a id="_idIndexMarker242"/> upon evaluation becomes <strong class="source-inline">((((arg0 + arg1) + arg2) + … ) + argN)</strong>. The enclosing parentheses are part of the fold expression. We can use this new implementation, just as we would use the initial one, as follows:</p>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    std::cout &lt;&lt; sum(1) &lt;&lt; '\n';</pre>
			<pre class="source-code">    std::cout &lt;&lt; sum(1,2) &lt;&lt; '\n';</pre>
			<pre class="source-code">    std::cout &lt;&lt; sum(1,2,3,4,5) &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>There are four different types of folds, which are listed as follows:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="Images/B18367_Table_3.1.jpg" alt="Table 3.1&#10;" width="1409" height="414"/>
				</div>
			</div>
			<p class="figure-caption">Table 3.1</p>
			<p>In this table, the following<a id="_idIndexMarker243"/> names are used:</p>
			<ul>
				<li><strong class="source-inline">pack</strong> is an expression that contains an unexpanded parameter pack, and <strong class="source-inline">arg1</strong>, <strong class="source-inline">arg2</strong>, <strong class="source-inline">argN-1</strong>, and <strong class="source-inline">argN</strong> are the arguments contained in this pack.</li>
				<li><strong class="source-inline">op</strong> is one of the following binary operators: <strong class="source-inline">+ - * / % ^ &amp; | = &lt; &gt; &lt;&lt; &gt;&gt; += -= *= /= %= ^= &amp;= |= &lt;&lt;= &gt;&gt;= == != &lt;= &gt;= &amp;&amp; || , .* -&gt;*.</strong></li>
				<li><strong class="source-inline">init</strong> is an expression that does not contain an unexpanded parameter pack.</li>
			</ul>
			<p>In a unary fold, if the pack does not contain any elements, only some operators are allowed. These are listed in the following table, along with the value of the empty pack:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="Images/B18367_Table_3.2.jpg" alt="Table 3.2&#13;&#10;" width="1003" height="318"/>
				</div>
			</div>
			<p class="figure-caption">Table 3.2</p>
			<p>Unary and binary folds differ in the use of an initialization value, that is present only for binary folds. Binary folds have the binary operator repeated twice (it must be the same operator). We can transform the variadic function template <strong class="source-inline">sum</strong> from using a unary right fold expression into one using a binary right fold by including an initialization value. Here is an example:</p>
			<pre class="source-code">template &lt;typename... T&gt;</pre>
			<pre class="source-code">int sum_from_zero(T... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return (0 + ... + args);</pre>
			<pre class="source-code">}</pre>
			<p>One could say there is no difference between the <strong class="source-inline">sum</strong> and <strong class="source-inline">sum_from_zero</strong> function templates. That is not actually true. Let's consider the following invocations:</p>
			<pre class="source-code">int s1 = sum();           // error</pre>
			<pre class="source-code">int s2 = sum_from_zero(); // OK</pre>
			<p>Calling <strong class="source-inline">sum</strong> without arguments will produce a compiler error, because unary fold expressions (over the operator <strong class="source-inline">+</strong> in this case) must have non-empty expansions. However, binary fold expressions do not have this problem, so calling <strong class="source-inline">sum_from_zero</strong> without arguments works and the function will return <strong class="source-inline">0</strong>.</p>
			<p>In these two examples with <strong class="source-inline">sum</strong> and <strong class="source-inline">sum_from_zero</strong>, the parameter pack <strong class="source-inline">args</strong> appears directly within the<a id="_idIndexMarker244"/> fold expression. However, it can be part of an expression, as long as it is not expanded. This is shown in the following example:</p>
			<pre class="source-code">template &lt;typename... T&gt;</pre>
			<pre class="source-code">void printl(T... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   (..., (std::cout &lt;&lt; args)) &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename... T&gt;</pre>
			<pre class="source-code">void printr(T... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   ((std::cout &lt;&lt; args), ...) &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>Here, the parameter pack <strong class="source-inline">args</strong> is part of the <strong class="source-inline">(std::cout &lt;&lt; args)</strong> expression. This is not a fold expression. A fold expression is <strong class="source-inline">((std::cout &lt;&lt; args), ...)</strong>. This is a unary left fold over the comma operator. The <strong class="source-inline">printl</strong> and <strong class="source-inline">printr</strong> functions can be used as in the following snippet:</p>
			<pre class="source-code">printl('d', 'o', 'g');  // dog</pre>
			<pre class="source-code">printr('d', 'o', 'g');  // dog</pre>
			<p>In both these cases, the text printed to the console is <strong class="source-inline">dog</strong>. This is because the unary left fold expands to <strong class="source-inline">(((std::cout &lt;&lt; 'd'), std::cout &lt;&lt; 'o'), &lt;&lt; std::cout &lt;&lt; 'g')</strong> and the unary right fold expands to <strong class="source-inline">(std::cout &lt;&lt; 'd', (std::cout &lt;&lt; 'o', (std::cout &lt;&lt; 'g')))</strong> and these two are evaluated in the same way. This is because a<a id="_idIndexMarker245"/> pair of expressions separated by a comma is evaluated left to right. This is true for the built-in comma operator. For types that overload the comma operator, the behavior depends on how the operator is overloaded. However, there are very few corner cases for overloading the comma operator (such as simplifying indexing multi-dimensional arrays). Libraries such as <strong class="source-inline">Boost.Assign</strong> and <strong class="source-inline">SOCI</strong> overload the comma operator, but, in general, this is an operator you should avoid overloading.</p>
			<p>Let's consider another example for using the parameter pack in an expression inside a fold expression. The following variadic function template inserts multiple values to the end of a <strong class="source-inline">std::vector</strong>:</p>
			<pre class="source-code">template&lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">void push_back_many(std::vector&lt;T&gt;&amp; v, Args&amp;&amp;... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   (v.push_back(args), ...);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">push_back_many(v, 1, 2, 3, 4, 5); // v = {1, 2, 3, 4, 5}</pre>
			<p>The parameter pack <strong class="source-inline">args</strong> is used with the <strong class="source-inline">v.push_back(args)</strong> expression that is folded over the comma operator. The unary left fold expression is <strong class="source-inline">(v.push_back(args), ...)</strong>.</p>
			<p>Fold expressions have several benefits over the use of recursion to implement variadic templates. These benefits<a id="_idIndexMarker246"/> are as follows:</p>
			<ul>
				<li>Less and simpler code to write.</li>
				<li>Fewer template instantiations, which leads to faster compile times.</li>
				<li>Potentially faster code since multiple function calls are replaced with a single expression. However, this point may not be true in practice, at least not when optimizations are enabled. We have already seen that the compilers optimize code by removing these function calls.</li>
			</ul>
			<p>Now that we have seen how to create variadic function templates, variadic class templates, and how to use fold expressions, we are left to discuss the other kinds of templates that can be variadic: alias templates and variable templates. We will start with the former.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor058"/>Variadic alias templates</h1>
			<p>Everything that can be templatized <a id="_idIndexMarker247"/>can also be made variadic. An alias template is an alias (another name) for a family of types. A variadic alias template is a name for a family of types with a variable number of template parameters. With the knowledge accumulated so far, it should be fairly trivial to write alias templates. Let's see an example:</p>
			<pre class="source-code">template &lt;typename T, typename... Args&gt;</pre>
			<pre class="source-code">struct foo </pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename... Args&gt;</pre>
			<pre class="source-code">using int_foo = foo&lt;int, Args...&gt;;</pre>
			<p>The class template <strong class="source-inline">foo</strong> is variadic and takes at least one type template argument. <strong class="source-inline">int_foo</strong>, on the other hand, is only a different name for a family of types instantiated from the <strong class="source-inline">foo</strong> type with <strong class="source-inline">int</strong> as the first type template arguments. These could be used as follows:</p>
			<pre class="source-code">foo&lt;double, char, int&gt; f1;</pre>
			<pre class="source-code">foo&lt;int, char, double&gt; f2;</pre>
			<pre class="source-code">int_foo&lt;char, double&gt; f3;</pre>
			<pre class="source-code">static_assert(std::is_same_v&lt;decltype(f2), decltype(f3)&gt;);</pre>
			<p>In this snippet, <strong class="source-inline">f1</strong> on one hand and <strong class="source-inline">f2</strong> and <strong class="source-inline">f3</strong> on the other are instances of different <strong class="source-inline">foo</strong> types, as they are instantiated from different sets of template arguments for <strong class="source-inline">foo</strong>. However, <strong class="source-inline">f2</strong> and <strong class="source-inline">f3</strong> are instances of the same type, <strong class="source-inline">foo&lt;int, char, double&gt;</strong>, since <strong class="source-inline">int_foo&lt;char, double&gt;</strong> is just an alias for this type.</p>
			<p>A similar example, although a bit more complex, is presented ahead. The standard library contains a class template called <strong class="source-inline">std::integer_sequence</strong>, which represents a compile-time sequence of integers, along with a bunch of alias templates to help create various kinds of such integer sequences. Although the code shown here is a simplified snippet, their<a id="_idIndexMarker248"/> implementation can, at least conceptually, be as follows:</p>
			<pre class="source-code">template&lt;typename T, T... Ints&gt;</pre>
			<pre class="source-code">struct integer_sequence</pre>
			<pre class="source-code">{};</pre>
			<pre class="source-code">template&lt;std::size_t... Ints&gt;</pre>
			<pre class="source-code">using index_sequence = integer_sequence&lt;std::size_t,</pre>
			<pre class="source-code">                                        Ints...&gt;;</pre>
			<pre class="source-code">template&lt;typename T, std::size_t N, T... Is&gt;</pre>
			<pre class="source-code">struct make_integer_sequence : </pre>
			<pre class="source-code">  make_integer_sequence&lt;T, N - 1, N - 1, Is...&gt; </pre>
			<pre class="source-code">{};</pre>
			<pre class="source-code">template&lt;typename T, T... Is&gt;</pre>
			<pre class="source-code">struct make_integer_sequence&lt;T, 0, Is...&gt; : </pre>
			<pre class="source-code">  integer_sequence&lt;T, Is...&gt; </pre>
			<pre class="source-code">{};</pre>
			<pre class="source-code">template&lt;std::size_t N&gt;</pre>
			<pre class="source-code">using make_index_sequence = make_integer_sequence&lt;std::size_t, </pre>
			<pre class="source-code">                                                  N&gt;;</pre>
			<pre class="source-code">template&lt;typename... T&gt;</pre>
			<pre class="source-code">using index_sequence_for = </pre>
			<pre class="source-code">   make_index_sequence&lt;sizeof...(T)&gt;;</pre>
			<p>There are three alias templates here:</p>
			<ul>
				<li><strong class="source-inline">index_sequence</strong>, which <a id="_idIndexMarker249"/>creates an <strong class="source-inline">integer_sequence</strong> for the <strong class="source-inline">size_t</strong> type; this is a variadic alias template.</li>
				<li><strong class="source-inline">index_sequence_for</strong>, which <a id="_idIndexMarker250"/>creates an <strong class="source-inline">integer_sequence</strong> from a parameter pack; this is also a variadic alias template.</li>
				<li><strong class="source-inline">make_index_sequence</strong>, which<a id="_idIndexMarker251"/> creates an <strong class="source-inline">integer_sequence</strong> for the <strong class="source-inline">size_t</strong> type with the values 0, 1, 2, …, <em class="italic">N-1</em>. Unlike the previous ones, this is not an alias for a variadic template.</li>
			</ul>
			<p>The last subject to address in this chapter is variadic variable templates.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor059"/>Variadic variable templates</h1>
			<p>As mentioned before, variable templates may also be variadic. However, variables cannot be defined recursively, nor can they be specialized like class templates. Fold expressions, which simplify<a id="_idIndexMarker252"/> generating expressions from a variable number of arguments, are very handy for creating variadic variable templates.</p>
			<p>In the following example, we define a variadic variable template called <strong class="source-inline">Sum</strong> that is initialized at compile-time with the sum of all integers supplied as non-type template arguments:</p>
			<pre class="source-code">template &lt;int... R&gt;</pre>
			<pre class="source-code">constexpr int Sum = (... + R);</pre>
			<pre class="source-code">int main()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    std::cout &lt;&lt; Sum&lt;1&gt; &lt;&lt; '\n';</pre>
			<pre class="source-code">    std::cout &lt;&lt; Sum&lt;1,2&gt; &lt;&lt; '\n';</pre>
			<pre class="source-code">    std::cout &lt;&lt; Sum&lt;1,2,3,4,5&gt; &lt;&lt; '\n';</pre>
			<pre class="source-code">}</pre>
			<p>This is similar to the <strong class="source-inline">sum</strong> function written with the help of fold expressions. However, in that case, the numbers to add were provided as function arguments. Here, they are provided as template arguments to the variable template. The difference is mostly syntactic; with optimizations enabled, the end result is likely the same in terms of generated assembly code, and therefore performance.</p>
			<p>Variadic variable templates follow the same patterns as all the other kinds of templates although they are not used as much as the others. However, by concluding this topic we have now completed the learning of variadic templates in C++.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor060"/>Summary</h1>
			<p>In this chapter, we have explored an important category of templates, variadic templates, which are templates with a variable number of template arguments. We can create variadic function templates, class templates, variable templates, and alias templates. The techniques to create variadic function templates and variadic class templates are different but incur a form of compile-time recursion. For the latter, this is done with template specialization, while for the former with function overloads. Fold expressions help to expand a variable number of arguments into a single expression, avoiding the need of using function overloads and enabling the creation of some categories of variadic variable templates such as the ones we have previously seen.</p>
			<p>In the next chapter, we will look into a series of more advanced features that will help you consolidate your knowledge of templates.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor061"/>Questions</h1>
			<ol>
				<li>What are variadic templates and why are they useful?</li>
				<li>What is a parameter pack?</li>
				<li>What are the contexts where parameter packs can be expanded?</li>
				<li>What are fold expressions?</li>
				<li>What are the benefits of using fold expressions?</li>
			</ol>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor062"/>Further reading</h1>
			<ul>
				<li><em class="italic">C++ Fold Expressions 101</em>,  Jonathan Boccara, <a href="https://www.fluentcpp.com/2021/03/12/cpp-fold-expressions/">https://www.fluentcpp.com/2021/03/12/cpp-fold-expressions/</a></li>
				<li><em class="italic">Fold Expressions in C++ 17</em>,  Vaibhav, <a href="https://mainfunda.com/fold-expressions-in-cpp17/">https://mainfunda.com/fold-expressions-in-cpp17/</a></li>
				<li><em class="italic">Nifty Fold Expression Tricks</em>,  Jonathan Müller, <a href="https://www.foonathan.net/2020/05/fold-tricks/">https://www.foonathan.net/2020/05/fold-tricks/</a></li>
			</ul>
		</div>
	</div></body></html>