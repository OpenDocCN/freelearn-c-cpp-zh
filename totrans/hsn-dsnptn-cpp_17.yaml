- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: The Visitor Pattern and Multiple Dispatch
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者模式与多态
- en: The Visitor pattern is another classic object-oriented design pattern, one of
    the 23 patterns introduced in the book *Design Patterns – Elements of Reusable
    Object-Oriented Software*, by Erich Gamma, Richard Helm, Ralph Johnson, and John
    Vlissides. It was one of the more popular patterns during the golden age of object-oriented
    programming since it can be used to make large class hierarchies more maintainable.
    In recent years, the use of Visitor in C++ declined, as large complex hierarchies
    became less common, and the Visitor pattern is a fairly complex pattern to implement.
    Generic programming - in particular, the language features added in C++11 and
    C++14 - makes it easier to implement and maintain the Visitor classes, while the
    new applications of the old pattern have served to rekindle some of the fading
    interest in it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式是另一种经典面向对象设计模式，它是Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides在《设计模式——可重用面向对象软件元素》一书中介绍的23个模式之一。在面向对象编程的黄金时代，它是较为流行的模式之一，因为它可以使大型类层次结构更易于维护。近年来，由于大型复杂层次结构变得不那么常见，访问者模式在C++中的使用有所下降，因为实现访问者模式相对复杂。泛型编程——特别是C++11和C++14中添加的语言特性——使得实现和维护访问者类变得更加容易，而旧模式的新应用也重新点燃了对它的部分兴趣。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The Visitor pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者模式
- en: Implementations of Visitor in C++
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中访问者模式的实现
- en: The use of generic programming to simplify the Visitor classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型编程简化访问者类
- en: The use of Visitor for composite objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用访问者处理组合对象
- en: Compile-time Visitor and reflection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时访问者和反射
- en: Technical requirements
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The example code for this chapter can be found at the following GitHub link:
    [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter17](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter17).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在以下GitHub链接中找到：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter17](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter17)。
- en: The Visitor pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者模式
- en: The Visitor pattern stands out from the other classic object-oriented patterns
    due to its complexity. On the one hand, the basic structure of the Visitor pattern
    is quite complex and involves many coordinated classes that must work together
    to form the pattern. On the other hand, even the description of the Visitor pattern
    is complex - there are several very different ways to describe the same pattern.
    Many patterns can be applied to multiple kinds of problems, but the Visitor pattern
    goes beyond that - there are several ways to describe what it does that use completely
    different languages, talk about seemingly unrelated problems, and overall have
    nothing in common. However, they all describe the same pattern. Let’s start by
    examining the many faces of the Visitor pattern, and then move on to the implementation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式因其复杂性而与其他经典面向对象模式脱颖而出。一方面，访问者模式的基本结构相当复杂，涉及许多必须协同工作的类，以形成该模式。另一方面，即使是访问者模式的描述也很复杂——有几种非常不同的方式来描述同一个模式。许多模式可以应用于多种类型的问题，但访问者模式超越了这一点——有几种描述其功能的语言，讨论看似无关的问题，总体上没有共同之处。然而，它们都描述了同一个模式。让我们首先考察访问者模式的众多面貌，然后继续探讨其实现。
- en: What is the Visitor pattern?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是访问者模式？
- en: The Visitor pattern is a pattern that separates the algorithm from the object
    structure, which is the data for this algorithm. Using the Visitor pattern, we
    can add a new operation to the class hierarchy without modifying the classes themselves.
    The use of the Visitor pattern follows the **open/closed principle** of software
    design - a class (or another unit of code, such as a module) should be closed
    for modifications; once the class presents an interface to its clients, the clients
    come to depend on this interface and the functionality it provides. This interface
    should remain stable; it should not be necessary to modify the classes in order
    to maintain the software and continue its development. At the same time, a class
    should be open for extensions - new functionality can be added to satisfy new
    requirements. As with all very general principles, a counter-example can be found
    where the rigorous application of a rule is worse than breaking it. Again, as
    with all general principles, its value lies not in being an absolute rule for
    every case, but rather a *default* rule, a guideline that should be followed in
    the absence of a good reason not to; the reality is that the majority of everyday
    work is *not special* and the result is better if this principle is followed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式是一种将算法与对象结构分离的模式，这是该算法的数据。使用访问者模式，我们可以在不修改类本身的情况下向类层次结构添加新的操作。访问者模式的使用遵循软件设计的**开/闭原则**
    - 一个类（或另一个代码单元，如模块）应该对修改封闭；一旦类向其客户端提供了一个接口，客户端就会依赖于这个接口及其提供的功能。这个接口应该保持稳定；不应该需要修改类来维护软件并继续其开发。同时，一个类应该对扩展开放
    - 可以添加新功能以满足新的需求。与所有非常通用的原则一样，可以找到一个反例，其中严格应用规则比违反规则更糟。同样，与所有通用原则一样，其价值不在于成为每个情况的绝对规则，而在于一个**默认**规则，一个在没有充分理由不遵循的情况下应该遵循的指南；现实是，大多数日常工作的**不特殊**，如果遵循这个原则，结果会更好。
- en: When viewed this way, the Visitor pattern allows us to add functionality to
    a class or an entire class hierarchy without having to modify the class. This
    feature can be particularly useful when dealing with public APIs - the users of
    the API can extend it with additional operations without having to modify the
    source code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，访问者模式允许我们在不修改类的情况下向类或整个类层次结构添加功能。当处理公共API时，这个特性尤其有用 - API的用户可以扩展它以添加额外的操作，而无需修改源代码。
- en: 'A very different, more technical way to describe the Visitor pattern is to
    say that it implements **double dispatch**. This requires some explanation. Let’s
    start with the regular virtual function calls:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 描述访问者模式的一个非常不同、更技术的方法是说它实现了**双分派**。这需要一些解释。让我们从常规的虚函数调用开始：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we invoke the `b->f()` virtual function through a pointer to the `b` base
    class, the call is dispatched to `Derived1::f()` or `Derived2::f()`, depending
    on the real type of the object. This is the **single dispatch** - the function
    that is actually called is determined by a single factor, the type of the object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过指向`b`基类的指针调用`b->f()`虚函数，调用将根据对象的实际类型分发到`Derived1::f()`或`Derived2::f()`。这是**单分派**
    - 实际调用的函数由一个单一因素决定，即对象类型。
- en: 'Now let''s assume that the function `f()` also takes an argument that is a
    pointer to a base class:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们假设函数`f()`还接受一个指向基类的指针作为参数：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The actual type of the `*p` object is also one of the derived classes. Now,
    the `b->f(p)` call can have four different versions; both the `*b` and `*p` objects
    can be of either of the two derived types. It is reasonable to want the implementation
    to do something different in each of these cases. This would be double dispatch
    - the code that ultimately runs is determined by two separate factors. Virtual
    functions do not provide a way to implement double dispatch directly, but the
    Visitor pattern does exactly that.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`*p`对象的实际类型也是派生类之一。现在，`b->f(p)`调用可以有四种不同的版本；`*b`和`*p`对象可以是两种派生类型中的任何一种。在每种情况下都希望实现不同的行为是合理的。这将实现**双分派**
    - 最终运行的代码由两个独立因素决定。虚函数不提供直接实现双分派的方法，但访问者模式正是如此。'
- en: When presented this way, it is not obvious that the **double-dispatch** Visitor
    pattern has anything to do with the **operation-adding** Visitor pattern. However,
    they are exactly the same pattern, and the two requirements are really one and
    the same. Here is a way to look at it that might help - if we want to add an operation
    to all classes in a hierarchy, that is equivalent to adding a virtual function,
    so we have one factor controlling the final disposition of each call, the object
    type. But, if we can effectively add virtual functions, we can add more than one
    - one for each operation we need to support. The type of operation is the second
    factor controlling the dispatch, similar to the argument to the function in our
    previous example. Thus, the operation-adding visitor is able to provide double
    dispatch. Alternatively, if we had a way to implement double dispatch, we could
    do what the Visitor pattern does - effectively add a virtual function for each
    operation we want to support.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式呈现时，并不明显地看出双分派访问者模式与操作添加访问者模式有什么关系。然而，它们实际上是同一个模式，这两个要求实际上是相同的。这里有另一种看待它的方法，可能有助于理解——如果我们想向层次结构中的所有类添加一个操作，那么这相当于添加一个虚函数，因此我们有一个因素控制着每个调用的最终处理，即对象类型。但是，如果我们能够有效地添加虚函数，我们可以添加多个——每个操作一个。操作类型是控制分派的第二个因素，类似于我们之前示例中的函数参数。因此，操作添加访问者能够提供双分派。或者，如果我们有实现双分派的方法，我们可以做访问者模式所能做的——为每个我们想要支持的运算添加一个虚拟函数。
- en: Now that we know what the Visitor pattern does, it is reasonable to ask, *why*
    would we want to do it? *What* is the use of double dispatch? And why would we
    want *another way* to add a virtual function substitute to a class when we can
    just add a *genuine* virtual function? Setting aside the case of the public API
    with unavailable source code, why would we want to add an operation *externally*
    instead of implementing it in every class? Consider the example of the serialization/deserialization
    problem. Serialization is an operation that converts an object into a format that
    can be stored or transmitted (for example, written into a file). Deserialization
    is the inverse operation - it constructs a new object from its serialized and
    stored image. To support serialization and deserialization in a straightforward,
    object-oriented way, each class in the hierarchy would need two methods, one for
    each operation. But what if there is more than one way to store an object? For
    example, we may need to write an object into a memory buffer, to be transmitted
    across the network and deserialized on another machine. Alternatively, we may
    need to save the object to disk, or else we may need to convert all objects in
    a container to a markup format such as JSON. The straightforward approach would
    have us add a serialization and a deserialization method to every object for every
    serialization mechanism. If a new and different serialization approach is needed,
    we have to go over the entire class hierarchy and add support for it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了访问者模式的作用，合理的疑问是，*为什么*我们要这样做？双分派有什么用？当我们可以直接添加一个*真正的*虚函数时，为什么我们还想*另一种方式*给一个类添加一个虚拟函数的替代品？不考虑公共API不可用源代码的情况，为什么我们想要在外部添加一个操作而不是在每一个类中实现它？考虑序列化/反序列化问题。序列化是一个将对象转换为可以存储或传输的格式的操作（例如，写入文件）。反序列化是逆操作——它从其序列化和存储的图像中构建一个新的对象。为了以简单、面向对象的方式支持序列化和反序列化，层次结构中的每个类都需要两个方法，每个操作一个。但如果存在多种存储对象的方式呢？例如，我们可能需要将对象写入内存缓冲区，以便在网络中传输并在另一台机器上反序列化。或者，我们可能需要将对象保存到磁盘，或者我们可能需要将容器中的所有对象转换为JSON等标记格式。直接的方法会要求我们为每种序列化机制给每个对象添加序列化和反序列化方法。如果需要新的不同的序列化方法，我们必须遍历整个类层次结构并添加对其的支持。
- en: An alternative is to implement the entire serialization/deserialization operation
    in a separate function that can handle all classes. The resulting code is a loop
    that iterates over all objects, with a large decision tree inside of it. The code
    must interrogate every object and determine its type, for example, using dynamic
    casts. When a new class is added to the hierarchy, all serialization and deserialization
    implementations must be updated to handle the new objects.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是在一个单独的函数中实现整个序列化/反序列化操作，该函数可以处理所有类。生成的代码是一个循环，它遍历所有对象，并在其中包含一个大的决策树。代码必须查询每个对象并确定其类型，例如，使用动态类型转换。当向层次结构中添加新类时，必须更新所有序列化和反序列化实现以处理新对象。
- en: Both implementations are difficult to maintain for large hierarchies. The Visitor
    pattern offers a solution - it allows us to implement a new operation - in our
    case, the serialization - outside of the classes and without modifying them, but
    also without the downside of a huge decision tree in a loop (note that the Visitor
    pattern is not the only solution to the serialization problem; C++ offers other
    possible approaches as well, but we focus on the Visitor pattern in this chapter).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种实现对于大型层次结构来说都难以维护。访问者模式提供了一个解决方案 - 它允许我们在类外部实现一个新操作 - 在我们的情况下，是序列化 - 而不修改它们，但也没有循环中巨大的决策树的缺点（注意，访问者模式不是序列化问题的唯一解决方案；C++还提供了其他可能的方法，但我们在本章中专注于访问者模式）。
- en: As we stated at the beginning, the Visitor pattern is a complex pattern with
    a complex description. We can best handle this difficult pattern by studying concrete
    examples, starting from the very simple ones in the next section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们一开始所说的，访问者模式是一个复杂的模式，具有复杂的描述。我们可以通过研究具体示例来最好地处理这个困难的模式，从下一节中的非常简单的示例开始。
- en: Basic Visitor in C++
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++中的基本访问者
- en: 'The only way to really understand how the Visitor pattern operates is to work
    through an example. Let’s start with a very simple one. First, we need a class
    hierarchy:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 真正理解访问者模式如何操作的唯一方法是通过一个示例来工作。让我们从一个非常简单的示例开始。首先，我们需要一个类层次结构：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this hierarchy, we have the `Pet` base class and several derived classes
    for different pet animals. Now we want to add some operations to our classes,
    such as “feed the pet” or “play with the pet.” The implementation depends on the
    type of pet, so these would have to be virtual functions if added directly to
    each class. This is not a problem for such a simple class hierarchy, but we are
    anticipating the future need for maintaining a much larger system in which modifying
    every class in the hierarchy is going to be expensive and time-consuming. We need
    a better way, and we begin by creating a new class, `PetVisitor`, which will be
    applied to every `Pet` object (visit it) and perform the operations we need. First,
    we need to declare the class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个层次结构中，我们有`Pet`基类和几个派生类，用于不同的宠物动物。现在我们想要给我们的类添加一些操作，比如“喂宠物”或“和宠物玩耍”。实现取决于宠物的类型，所以如果直接添加到每个类中，这些将必须是虚拟函数。对于这样一个简单的类层次结构来说，这不是问题，但我们预计未来需要维护一个更大的系统，其中修改层次结构中的每个类将非常昂贵且耗时。我们需要一种更好的方法，我们首先创建一个新的类，`PetVisitor`，它将被应用于每个`Pet`对象（访问它）并执行我们需要的操作。首先，我们需要声明这个类：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We had to forward-declare the `Pet` hierarchy classes because `PetVisitor`
    has to be declared before the concrete `Pet` classes. Now we need to make the
    `Pet` hierarchy visitable, which means we do need to modify it, but only once,
    regardless of how many operations we want to add later. We need to add a virtual
    function to accept the Visitor pattern to every class that can be visited:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须提前声明`Pet`层次结构类，因为`PetVisitor`必须在具体的`Pet`类之前声明。现在我们需要使`Pet`层次结构可访问，这意味着我们确实需要修改它，但只需修改一次，无论我们以后想添加多少操作。我们需要为每个可访问的类添加一个虚拟函数以接受访问者模式：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now our `Pet` hierarchy is visitable, and we have an abstract `PetVisitor`
    class. Everything is ready to implement new operations for our classes (note that
    nothing we have done so far depends on what operations we are going to add; we
    have created the visiting infrastructure that has to be implemented once). The
    operations are added by implementing concrete Visitor classes derived from `PetVisitor`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`Pet`层次结构是可访问的，并且我们有一个抽象的`PetVisitor`类。一切准备就绪，为我们的类实现新的操作（注意，到目前为止我们所做的一切都不依赖于我们将要添加的操作；我们已经创建了必须实现一次的访问基础设施）。操作是通过实现从`PetVisitor`派生的具体访问者类来添加的：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Assuming the visitation infrastructure is already built into our class hierarchy,
    we can implement a new operation by implementing a derived Visitor class, and
    all its virtual functions overrides for `visit()`. To invoke one of the new operations
    on an object from our class hierarchy, we need to create a visitor and visit the
    object:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设访问者基础设施已经集成到我们的类层次结构中，我们可以通过实现一个派生访问者类来实施新的操作，并覆盖所有`visit()`的虚拟函数。要从我们的类层次结构中的对象上调用新的操作，我们需要创建一个访问者并访问该对象：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The latest example of the call is too simple in one important way - at the
    point of calling the visitor, we know the exact type of the object we are visiting.
    To make the example more realistic, we have to visit an object polymorphically:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用访问者的最新示例中，有一个重要的方面过于简单——在调用访问者的那一刻，我们知道我们正在访问的对象的确切类型。为了使示例更真实，我们必须以多态的方式访问对象：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here we do not know at compile time the actual type of the object pointed to
    by `p`; at the point where the visitor is accepted, `p` could have come from different
    sources. While less common, the visitor can also be used polymorphically:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，我们并不知道`p`所指向的对象的实际类型；在访问者被接受的那一刻，`p`可能来自不同的来源。虽然不太常见，访问者也可以被多态地使用：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When written this way, the code highlights the double-dispatch aspect of the
    Visitor pattern - the call to `accept()` ends up dispatched to a particular `visit()`
    function based on two factors - the type of the visitable `*p` object and the
    type of the `*v` visitor. If we wish to stress this aspect of the Visitor pattern,
    we can invoke the visitors using a helper function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当以这种方式编写时，代码突出了访问者模式的二分派特性——对`accept()`的调用最终会根据两个因素分派到特定的`visit()`函数——一个是可访问对象`*p`的类型，另一个是访问者`*v`的类型。如果我们想强调访问者模式的这一特性，我们可以使用辅助函数来调用访问者：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We now have the most bare-bones example of the classic object-oriented visitor
    in C++. Despite its simplicity, it has all the necessary components; an implementation
    for a large real-life class hierarchy and multiple visitor operations has a lot
    more code, but no new kinds of code, just more of the things we have already done.
    This example shows both aspects of the Visitor pattern; on the one hand, if we
    focus on the functionality of the software, with the visitation infrastructure
    now in place, we can add new operations without any changes to the classes themselves.
    On the other hand, if we look just at the way the operation is invoked, the `accept()`
    call, we have implemented double dispatch.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了经典面向对象访问者模式在C++中的最简单示例。尽管它很简单，但它包含了所有必要的组件；对于大型现实生活类层次结构和多个访问者操作，代码会更多，但并没有新的代码类型，只是更多我们已经做过的东西。这个示例展示了访问者模式的两个方面；一方面，如果我们关注软件的功能，现在有了访问者基础设施，我们可以添加新的操作而无需对类本身进行任何更改。另一方面，如果我们只看操作调用的方式，即`accept()`调用，我们已经实现了双分派。
- en: We can immediately see the appeal of the Visitor pattern, we can add any number
    of new operations without having to modify every class in the hierarchy. If a
    new class is added to the `Pet` hierarchy, it is impossible to forget to handle
    it - if we do nothing at all to the visitor, the `accept()` call on the new class
    will not compile since there is no corresponding `visit()` function to call. Once
    we add the new `visit()` overload to the `PetVisitor` base class, we have to add
    it to all derived classes as well; otherwise, the compiler will let us know that
    we have a pure virtual function without an override. The latter is also one of
    the main disadvantages of the Visitor pattern - if a new class is added to the
    hierarchy, all visitors must be updated, whether the new classes actually need
    to support these operations or not. For this reason, it is sometimes recommended
    to use the visitor only on *relatively stable* hierarchies that do not have new
    classes added often. There is also an alternative visitor implementation that
    somewhat mitigates this problem; we will see it later in this chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即看到访问者模式的吸引力，我们可以添加任意数量的新操作，而无需修改层次结构中的每个类。如果向`Pet`层次结构中添加了一个新类，不可能忘记处理它——如果我们对访问者不做任何操作，新类上的`accept()`调用将无法编译，因为没有相应的`visit()`函数可以调用。一旦我们向`PetVisitor`基类添加了新的`visit()`重载，我们也必须将其添加到所有派生类中；否则，编译器会告诉我们有一个没有重载的纯虚函数。后者也是访问者模式的主要缺点之一——如果向层次结构中添加了一个新类，所有访问者都必须更新，无论新类实际上是否需要支持这些操作。因此，有时建议只在*相对稳定*的层次结构上使用访问者，这些层次结构不经常添加新类。还有一个替代的访问者实现，它在某种程度上减轻了这个问题；我们将在本章后面看到它。
- en: The example in this section is very simple - our new operations take no arguments
    and return no results. We will now consider whether these limitations are significant,
    and how they can be removed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例非常简单——我们的新操作不接收任何参数也不返回任何结果。我们现在将考虑这些限制是否重要，以及它们如何被消除。
- en: Visitor generalizations and limitations
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问者泛化和限制
- en: 'Our very first visitor, in the previous section, allowed us to effectively
    add a virtual function to every class in the hierarchy. That virtual function
    had no parameters and no return value. The former is easy to extend; there is
    no reason at all why our `visit()` functions cannot have parameters. Let’s expand
    our class hierarchy by allowing our pets to have kittens and puppies. This extension
    cannot be done using only the Visitor pattern - we need to add not only new operations
    but also new data members. The Visitor pattern can be used for the former, but
    the latter requires code changes. A policy-based design could have let us factor
    out this change into a new implementation of an existing policy if we had the
    foresight to provide the appropriate policy. We do have a separate chapter on
    [*Chapter 15*](B19262_15.xhtml#_idTextAnchor689), *Policy-Based Design* in this
    book, so here we will avoid mixing several patterns together and just add the
    new data members:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们的第一个访问者使我们能够有效地为层次结构中的每个类添加一个虚函数。这个虚函数没有参数也没有返回值。前者很容易扩展；我们的`visit()`函数为什么不能有参数，完全没有理由。让我们通过允许我们的宠物拥有小猫和小狗来扩展我们的类层次结构。仅使用访问者模式无法完成这个扩展——我们需要添加不仅新的操作，还有新的数据成员。访问者模式可以用于前者，但后者需要代码更改。如果我们有先见之明提供适当的策略，基于策略的设计可以让我们将这个更改因式分解为现有策略的新实现。我们确实在本书中有一个关于[*第15章*](B19262_15.xhtml#_idTextAnchor689)，*基于策略的设计*的独立章节，所以在这里我们将避免混合多个模式，只是添加新的数据成员：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Each parent `Pet` object tracks its child objects (note that the container
    is a vector of pointers, not a vector of unique pointers, so the object does not
    own its children, but merely has access to them). We have also added the new `add_child()`
    member function to add objects to the vector. We could have done this with a visitor,
    but this function is non-virtual, so we have to add it only once to the base class,
    not to every derived class - the visitor is unnecessary here. The `accept()` function
    has been modified to have an additional parameter that would have to be added
    to all derived classes as well, where it is simply forwarded to the `visit()`
    function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每个父`Pet`对象跟踪其子对象（请注意，容器是一个指针向量，而不是唯一指针向量，因此对象不拥有其子对象，只是可以访问它们）。我们还添加了新的`add_child()`成员函数来向向量中添加对象。我们本来可以用访问者来做这件事，但这个函数是非虚的，所以我们必须只将它添加到基类中，而不是每个派生类中——访问者在这里是不必要的。`accept()`函数已被修改，增加了一个额外的参数，这个参数也必须添加到所有派生类中，它只是简单地转发到`visit()`函数：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `visit()` function also has to be modified to accept the additional argument,
    even for the visitors that do not need it. Changing the parameters of the `accept()`
    function is, therefore, an expensive global operation that should not be done
    often, if at all. Note that all overrides for the same virtual function in the
    hierarchy already have to have the same parameters. The Visitor pattern extends
    this restriction to all operations added using the same base Visitor object. A
    common workaround for this problem is to pass parameters using aggregates (classes
    or structures that combine multiple parameters together). The `visit()` function
    is declared to accept a pointer to the base aggregate class, while each visitor
    receives a pointer to a derived class that may have additional fields, and uses
    them as needed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`visit()` 函数也必须修改以接受额外的参数，即使对于不需要它的访问者也是如此。因此，更改 `accept()` 函数的参数是一个昂贵的全局操作，如果可能的话，不应该经常进行，甚至根本不应该进行。请注意，层次结构中相同虚拟函数的所有覆盖版本已经必须具有相同的参数。访问者模式将这种限制扩展到使用相同的基本访问者对象添加的所有操作。对于这个问题的一个常见解决方案是使用聚合（将多个参数组合在一起的类或结构）来传递参数。`visit()`
    函数被声明为接受对基本聚合类指针的引用，而每个访问者都接收对派生类的指针，该派生类可能具有额外的字段，并且根据需要使用它们。'
- en: 'Now, our additional argument is forwarded through the chain of virtual function
    calls to the visitor, where we can make use of it. Let’s create a visitor that
    records the pet births and adds new pet objects as children to their parent objects:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的额外参数将通过虚拟函数调用的链路传递给访问者，在那里我们可以利用它。让我们创建一个记录宠物出生并作为子对象添加新宠物对象到其父对象中的访问者：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that if we want to make sure that there are no biological impossibilities
    in our family tree, the verification has to be done at run time - at compile time,
    we do not know the actual types of the polymorphic objects. The new visitor is
    just as easy to use as the ones from the last section:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们想确保我们的家族树中没有生物学上的不可能性，验证必须在运行时进行——在编译时，我们不知道多态对象的实际类型。新的访问者与上一节中的访问者一样容易使用：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once we have established the parenthood relationships, we may want to examine
    our pet families. That is another operation we want to add, which calls for another
    Visitor:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了亲子关系，我们可能想检查我们的宠物家族。这是我们想要添加的另一个操作，需要另一个访问者：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have hit a slight problem, though, because as written, the code will not
    compile. The reason is that the `FamilyTreeVisitor` class is trying to access
    the `Pet::children_` data member, which is private. This is another weakness of
    the Visitor pattern - from our point of view, the visitors add new operations
    to the classes, just like virtual functions, but from the compiler’s point of
    view, they are completely separate classes, not at all like member functions of
    the `Pet` classes and have no special access. Application of the Visitor pattern
    usually requires that the encapsulation is relaxed in one of two ways - we can
    either allow public access to the data (directly or through accessor member functions)
    or declare the Visitor classes to be friends (which does require changes to the
    source code). In our example, we will follow the second route:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们遇到了一个小问题，因为按照目前的编写方式，代码将无法编译。原因是 `FamilyTreeVisitor` 类试图访问 `Pet::children_`
    私有数据成员。这是访问者模式的一个弱点——从我们的角度来看，访问者向类添加新操作，就像虚拟函数一样，但从编译器的角度来看，它们是完全独立的类，根本不像 `Pet`
    类的成员函数，也没有特殊访问权限。访问者模式的通常应用需要放松封装，有两种方式——我们可以允许对数据进行公共访问（直接或通过访问器成员函数）或声明访问者类为友元（这确实需要更改源代码）。在我们的例子中，我们将遵循第二条路线：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now the family tree visitor works as expected:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在家族树访问者按预期工作：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Unlike `BirthVisitor`, `FamilyTreeVisitor` does not need the additional argument.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `BirthVisitor` 不同，`FamilyTreeVisitor` 不需要额外的参数。
- en: 'Now we have visitors that implement operations with parameters. What about
    the return values? Technically, there is no requirement for the `visit()` and
    `accept()` functions to return `void`. They can return anything else. However,
    the limitation that they have to all return the same type usually makes this capability
    useless. Virtual functions can have covariant return types, where the base class
    virtual function returns an object of some class and the derived class overrides
    return objects derived from that class, but even that is usually too limiting.
    There is another, much simpler solution - the `visit()` functions of every Visitor
    object have full access to the data members of that object. There is no reason
    why we cannot store the return value in the Visitor class itself and access it
    later. This fits well with the most common use where each visitor adds a different
    operation and is likely to have a unique return type, but the operation itself
    usually has the same return type for all classes in the hierarchy. For example,
    we can make our `FamilyTreeVisitor` count the total number of children and return
    the value through the Visitor object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了使用参数执行操作的访客。那么返回值怎么办呢？技术上讲，`visit()` 和 `accept()` 函数没有必须返回 `void` 的要求。它们可以返回任何其他类型。然而，它们必须返回相同类型的限制通常使得这种能力变得无用。虚函数可以有协变返回类型，其中基类虚函数返回某个类的对象，而派生类覆盖返回的对象是从该类派生出来的，但即使是这也通常过于限制。还有一个更简单、更有效的解决方案——每个访客对象的
    `visit()` 函数可以完全访问该对象的数据成员。我们没有理由不能在访客类本身中存储返回值并在稍后访问它。这对于最常见的使用情况非常合适，即每个访客添加不同的操作，并且可能具有唯一的返回类型，但操作本身对于层次结构中的所有类通常具有相同的返回类型。例如，我们可以让我们的
    `FamilyTreeVisitor` 计算子代总数并通过访客对象返回该值：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This approach imposes some limitations in multithreaded programs - the visitor
    is now not thread-safe since multiple threads cannot use the same Visitor object
    to visit different pet objects. The most common solution is to use one Visitor
    object per thread, usually a local variable created on the stack of the function
    that calls the visitor. If this is not possible, more complex options are available
    to give the visitor a per-thread (thread-local) state, but the analysis of such
    options lies outside of the scope of this book. On the other hand, sometimes we
    want to accumulate results over multiple visitations, in which case the previous
    technique of storing the result in the Visitor object works perfectly. Also note
    that the same solution can be used to pass arguments into the Visitor operations,
    instead of adding them to the `visit()` functions; we can store the arguments
    inside the Visitor object itself, and then we don’t need anything special to access
    them from the visitor. This technique works particularly well when the arguments
    don’t change on every invocation of the visitor, but may vary from one Visitor
    object to another.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在多线程程序中会带来一些限制——访客现在不是线程安全的，因为多个线程不能使用同一个访客对象来访问不同的宠物对象。最常见的解决方案是每个线程使用一个访客对象，通常是在调用访客的函数栈上创建的一个局部变量。如果这不可能，还有更复杂的选项可以给访客提供一个线程（线程局部）状态，但分析这些选项超出了本书的范围。另一方面，有时我们想在多次访问中累积结果，在这种情况下，将结果存储在访客对象中的先前技术可以完美工作。此外，请注意，相同的解决方案也可以用来将参数传递到访客操作中，而不是将它们添加到
    `visit()` 函数中；我们可以在访客对象内部存储参数，然后我们就不需要任何特殊的东西来从访客那里访问它们。当参数在每次调用访客时都不变，但可能从一个访客对象到另一个访客对象有所变化时，这种技术特别有效。
- en: Let’s return for a moment and examine the `FamilyTreeVisitor` implementation
    again. Note that it iterates over the child objects of the parent object and calls
    the same operation on each one, in turn. It does not, however, process the children
    of the child object - our family tree is only one-generation deep. The problem
    of visiting objects that contain other objects is very general and occurs rather
    often. Our motivational example from the very beginning of this chapter, the problem
    of serialization, demonstrates this need perfectly - every complex object is serialized
    by serializing its components, one by one, and they, in turn, are serialized the
    same way, until we get all the way down to the built-in types such as `int` and
    `double`, which we know how to read and write. The next section deals with visiting
    complex objects in a more comprehensive way than what we have done so far.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时回顾一下`FamilyTreeVisitor`的实现。请注意，它遍历父对象的子对象，并依次对每个对象调用相同的操作。然而，它并没有处理子对象的子对象——我们的家谱树只有一代。访问包含其他对象的对象的这个问题非常普遍，并且相当常见。我们本章开头提到的动机示例，序列化问题，完美地展示了这种需求——每个复杂对象都是通过逐个序列化其组件来序列化的，然后它们依次以相同的方式序列化，直到我们到达内置类型，如`int`和`double`，我们知道如何读写这些类型。下一节将更全面地处理访问复杂对象的问题。
- en: Visiting complex objects
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问复杂对象
- en: In the last section, we saw how the Visitor pattern allows us to add new operations
    to the existing hierarchy. In one of the examples, we visited a complex object
    that contained pointers to other objects. The visitor iterated over these pointers,
    in a limited way. We are now going to consider the general problem of visiting
    objects that are composed of other objects, or objects that contain other objects
    and build up to the demonstration of a working serialization/deserialization solution
    at the end.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们看到了访问者模式如何允许我们向现有层次结构中添加新操作。在一个示例中，我们访问了一个包含其他对象指针的复杂对象。访问者以有限的方式遍历这些指针。我们现在将考虑访问由其他对象组成或包含其他对象的对象的普遍问题，并在最后演示一个有效的序列化/反序列化解决方案。
- en: Visiting composite objects
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问组合对象
- en: The general idea of visiting complex objects is quite straightforward - when
    visiting the object itself, we generally do not know all the details of how to
    handle each component or contained object. But there is something else that does
    - the visitor for that object type is written specifically to handle that class
    and nothing else. This observation suggests that the correct way to handle the
    component objects is to simply visit each one, and thus delegate the problem to
    someone else (a generally powerful technique, in programming and otherwise).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 访问复杂对象的一般思想非常直接——在访问对象本身时，我们通常不知道如何处理每个组件或包含对象的详细信息。但是，有一种东西可以做到这一点——针对该对象类型的访问者被专门编写来处理该类，而不会处理其他任何东西。这个观察表明，正确处理组件对象的方法是简单地访问每个对象，并将问题委托给其他人（这是一种在编程和其他方面都普遍有效的技术）。
- en: 'Let’s first demonstrate this idea on the example of a simple container class,
    such as the `Shelter` class, which can contain any number of pet objects representing
    the pets waiting for adoption:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先以一个简单的容器类为例来演示这个想法，比如`Shelter`类，它可以包含任意数量的宠物对象，代表等待领养的宠物：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This class is essentially an adapter to make a vector of pet objects visitable
    (we have discussed the Adapter pattern in detail in the eponymous chapter). Note
    that the objects of this class do own the pet objects they contain - when the
    `Shelter` object is destroyed, so are all the `Pet` objects in the vector. Any
    container of unique pointers is a container that owns its contained objects; this
    is how polymorphic objects should be stored in a container such as `std::vector`
    (For non-polymorphic objects we can store objects themselves, but that won’t work
    in our case, objects derived from `Pet` are of different types.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类本质上是一个适配器，用于使宠物对象的向量可访问（我们已经在同名的章节中详细讨论了适配器模式）。请注意，这个类的对象确实拥有它们包含的宠物对象——当`Shelter`对象被销毁时，向量中的所有`Pet`对象也会被销毁。任何包含唯一指针的容器都是一个拥有其包含对象的容器；这就是如何在`std::vector`等容器中存储多态对象的方式（对于非多态对象，我们可以存储对象本身，但这种情况不适用，因为从`Pet`派生的对象属于不同的类型。）
- en: The code relevant to our current problem is, of course, `Shelter::accept()`,
    which determines how a `Shelter` object is visited. As you can see, we do not
    invoke the Visitor on the `Shelter` object itself. Instead, we delegate the visitation
    to each of the containing objects. Since our Visitors are already written to handle
    Pet objects, nothing more needs to be done. When `Shelter` is visited by, say,
    `FeedingVisitor`, every pet in the shelter gets fed, and we didn’t have to write
    any special code to make it happen.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们当前问题相关的代码当然是`Shelter::accept()`，它决定了`Shelter`对象是如何被访问的。正如你所看到的，我们没有在`Shelter`对象本身上调用访问者。相反，我们将访问委托给每个包含的对象。由于我们的访问者已经编写好了来处理宠物对象，所以不需要做更多的事情。当`Shelter`被`FeedingVisitor`等访问者访问时，庇护所中的每只宠物都会被喂食，我们不需要编写任何特殊的代码来实现这一点。
- en: 'Visitation of composite objects is done in a similar manner - if an object
    is composed of several smaller objects, we have to visit each of these objects.
    Let’s consider an object representing a family with two family pets, a dog and
    a cat (the humans who serve the pets are not included in the following code, but
    we assume they are there too):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 复合对象的访问以类似的方式进行 - 如果一个对象由几个较小的对象组成，我们必须访问这些对象中的每一个。让我们考虑一个代表一个家庭及其两只宠物（狗和猫）的对象（在下面的代码中，照顾宠物的家庭成员没有被包括在内，但我们假设他们也在那里）：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Again, visiting the family with a visitor from the `PetVisitor` hierarchy is
    delegated so that each `Pet` object is visited, and the visitors already have
    everything they need to handle these objects (of course, a `Family` object could
    accept visitors of other types as well, we would have to write separate `accept()`
    methods for them).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，使用来自`PetVisitor`层次结构的访问者访问家庭被委托，以便每个`Pet`对象都被访问，访问者已经拥有了处理这些对象所需的一切（当然，`Family`对象也可以接受其他类型的访问者，我们将不得不为它们编写单独的`accept()`方法）。
- en: Now, at last, we have all the pieces we need to tackle the problem of serialization
    and deserialization of arbitrary objects. The next subsection shows how this can
    be done using the Visitor pattern.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后，我们拥有了处理任意对象序列化和反序列化问题所需的所有部件。下一个小节将展示如何使用访问者模式来完成这项工作。
- en: Serialization and deserialization with Visitor
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问者进行序列化和反序列化
- en: The problem itself was described in detail in the previous section - for serialization,
    each object needs to be converted to a sequence of bits, and these bits need to
    be stored, copied, or sent. The first part of the action depends on the object
    (each object is converted differently) but the second part depends on the specific
    application of the serialization (saving to disk is different from sending across
    the network). The implementation depends on two factors, hence the need for double
    dispatch, which is exactly what the Visitor pattern provides. Furthermore, if
    we have a way to serialize some object and then deserialize it (reconstruct the
    object from the sequence of bits), we should use the same method when this object
    is included in another object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题本身在上一节中已详细描述 - 对于序列化，每个对象都需要被转换为一系列位，这些位需要被存储、复制或发送。动作的第一部分取决于对象（每个对象的转换方式不同），但第二部分取决于序列化的具体应用（保存到磁盘与通过网络发送不同）。实现取决于两个因素，因此需要双重分派，这正是访问者模式提供的。此外，如果我们有方法可以序列化某些对象然后反序列化它（从位序列中重建对象），那么当这个对象包含在其他对象中时，我们应该使用相同的方法。
- en: 'To demonstrate serialization/deserialization of a class hierarchy using the
    Visitor pattern, we need a more complex hierarchy than the toy examples we have
    used so far. Let’s consider this hierarchy of two-dimensional geometric objects:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示使用访问者模式进行类层次结构的序列化和反序列化，我们需要一个比我们迄今为止使用的玩具示例更复杂的层次结构。让我们考虑这个二维几何对象的层次结构：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All objects are derived from the abstract `Geometry` base class, but the more
    complex object contains one or more of the simpler objects; for example, `Line`
    is defined by two `Point` objects. Note that, at the end of the day, all our objects
    are made of `double` numbers, and, therefore, will serialize into a sequence of
    numbers. The key is knowing which `double` represents which field of which object;
    we need this to restore the original objects correctly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对象都从抽象的`Geometry`基类派生，但更复杂的对象包含一个或多个更简单的对象；例如，`Line`由两个`Point`对象定义。请注意，最终，我们所有的对象都是由`double`数字组成的，因此将序列化为一系列数字。关键是知道哪个`double`代表哪个对象的哪个字段；我们需要这个来正确地恢复原始对象。
- en: 'To serialize these objects using the Visitor pattern, we follow the same process
    we used in the last section. First, we need to declare the base Visitor class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用访问者模式序列化这些对象，我们遵循与上一节相同的流程。首先，我们需要声明基访问者类：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There is one additional detail here - we can also visit double values; each
    visitor would need to handle them appropriately (write them, read them, and so
    on). Visiting any geometry object will result, eventually, in visiting the numbers
    it is composed of.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个额外的细节 - 我们也可以访问`double`值；每个访问者都需要适当地处理它们（写入它们、读取它们等）。访问任何几何对象最终都会导致访问它所组成的数字。
- en: 'Our base `Geometry` class and all the classes derived from it need to accept
    this visitor:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本`Geometry`类及其所有派生类都需要接受这个访问者：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There is, of course, no way to add an `accept()` member function to double,
    but we won’t have to. The `accept()` member functions for the derived classes,
    each of which is composed of one or more numbers and other classes, visit every
    data member in order:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们无法向`double`添加一个`accept()`成员函数，但我们将不必这样做。派生类的`accept()`成员函数，每个都由一个或多个数字和其他类组成，会按顺序访问每个数据成员：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The concrete Visitor classes, all derived from the base `Visitor` class, are
    responsible for the specific mechanisms of serialization and deserialization.
    The order in which the objects are broken down into their parts, all the way down
    to the numbers, is controlled by each object, but the visitors determine what
    is done with these numbers. For example, we can serialize all objects into a string
    using the formatted I/O (similar to what we get if we print the numbers into `cout`):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的访问者类，所有都是基`Visitor`类的派生，负责序列化和反序列化的具体机制。对象分解成其部分的顺序，一直到底层的数字，由每个对象控制，但访问者决定了如何处理这些数字。例如，我们可以使用格式化输入输出将所有对象序列化成一个字符串（类似于我们将数字打印到`cout`时得到的结果）：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The string is accumulated in `stringstream` until all the necessary objects
    are serialized:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串会在`stringstream`中累积，直到所有必要的对象都被序列化：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have the objects printed into the `s` string, we can restore them
    from this string, perhaps on a different machine (if we arranged for the string
    to be sent there). First, we need the deserializing Visitor:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将对象打印到字符串`s`中，我们可以从这个字符串中恢复它们，也许是在不同的机器上（如果我们安排将字符串发送到那里）。首先，我们需要反序列化的访问者：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This Visitor reads the numbers from the string and saves them in the variables
    given to it by the object that is visited. The key to successful deserialization
    is to read the numbers in the same order as they were saved - for example, if
    we started by writing *X* and *Y* coordinates of a point, we should construct
    a point from the first two numbers we read and use them as *X* and *Y* coordinates.
    If the first point we wrote was the endpoint of a line, we should use the point
    we constructed as the endpoint of the new line. The beauty of the Visitor pattern
    is that the functions that do the actual reading and writing don’t need to do
    anything special to preserve this order - the order is determined by each object
    and is guaranteed to be the same for all visitors (the object makes no distinction
    between the specific visitors and doesn’t even know what kind of visitor is it).
    All we need to do is to visit the objects in the same order they were serialized
    in:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个访问者从字符串中读取数字，并将它们保存为被访问对象提供的变量中。成功反序列化的关键是按照保存时的顺序读取数字 - 例如，如果我们首先写入一个点的 *X*
    和 *Y* 坐标，我们应该从读取的前两个数字构建一个点，并将它们用作 *X* 和 *Y* 坐标。如果第一个写入的点是一条线的终点，我们应该使用构建的点作为新线的终点。访问者模式的美妙之处在于，执行实际读取和写入的函数不需要做任何特殊的事情来保持这个顺序
    - 顺序由每个对象确定，并且对所有访问者保证是相同的（对象不会区分特定的访问者，甚至不知道它是什么类型的访问者）。我们唯一需要做的就是按照序列化时的顺序访问对象：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So far, we have known which objects are serialized and in what order. Therefore,
    we can deserialize the same objects in the same order. A more general case is
    when we don’t know what objects to expect during deserialization - the objects
    are stored in a visitable container, similar to `Shelter` in the earlier example,
    which has to ensure that the objects are serialized and deserialized in the same
    order. For example, consider this class, which stores a geometry represented as
    an intersection of two other geometries:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经知道了哪些对象被序列化以及它们的顺序。因此，我们可以以相同的顺序反序列化相同的对象。更一般的情况是，在反序列化过程中我们不知道期望哪些对象——对象存储在一个可访问的容器中，类似于早期示例中的
    `Shelter`，它必须确保对象以相同的顺序进行序列化和反序列化。例如，考虑这个类，它存储一个表示为两个其他几何体交集的几何体：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Serialization of this object is straightforward - we serialize both geometries,
    in order, by delegating the details to these objects. We cannot call `v.visit()`
    directly because we do not know the types of the `*g1_` and `*g2_` geometries,
    but we can let these objects dispatch the call as appropriate. But deserialization,
    as written, will fail - the geometry pointers are `null`, there are no objects
    allocated yet, and we do not know what type of objects should be allocated. Somehow,
    we need to encode the types of objects in the serialized stream first, then construct
    them based on these encoded types. There is another pattern that offers the standard
    solution for this problem, and that is the Factory pattern (it is quite common
    to have to use more than one design pattern when building a complex system).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象的序列化很简单——我们按顺序序列化几何体，通过将这些细节委托给这些对象来实现。我们不能直接调用 `v.visit()`，因为我们不知道 `*g1_`
    和 `*g2_` 几何体的类型，但我们可以让这些对象根据适当的情况分派调用。但是，按照目前的写法，反序列化将失败——几何指针是 `null`，还没有分配任何对象，我们也不知道应该分配哪种类型的对象。某种方式，我们首先需要在序列化流中编码对象的类型，然后根据这些编码的类型构建它们。还有另一种模式为这个问题提供了标准的解决方案，那就是工厂模式（在构建复杂系统时，通常需要使用多个设计模式）。
- en: 'There are several ways in which this can be done, but they all boil down to
    converting types to numbers and serializing those numbers. In our case, we have
    to know the complete list of geometry types when we declare the base `Visitor`
    class, so that we can also define an enumeration for all these types at the same
    time:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以实现这一点，但它们都归结为将类型转换为数字并将这些数字序列化。在我们的情况下，当我们声明基类 `Visitor` 时，我们必须知道完整的几何类型列表，这样我们才能同时定义所有这些类型的枚举：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It is not essential that `enum type_tag` be defined inside the `Geometry` class,
    or that the `make_geometry` factory constructor be a static member function of
    the `Visitor` class. They can be declared outside of any class as well, but the
    virtual `tag()` method that will return the correct tag for every derived geometry
    type needs to be declared exactly as shown. The `tag()` overrides must be defined
    in every derived `Geometry` class, for example, the `Point` class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum type_tag` 不一定需要在 `Geometry` 类内部定义，或者 `make_geometry` 工厂构造函数必须是 `Visitor`
    类的静态成员函数。它们也可以在任何类外部声明，但返回每个派生几何类型正确标记的虚拟 `tag()` 方法需要按照所示方式声明。必须在每个派生 `Geometry`
    类中定义 `tag()` 重写，例如，`Point` 类：'
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Other derived classes have to be similarly modified.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 其他派生类也需要进行类似的修改。
- en: 'Then we need to define the factory constructor:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要定义工厂构造函数：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This factory function constructs the right derived object depending on the
    specified type tag. All that is left is for the `Intersection` object to serialize
    and deserialize the tags of the two geometries that form the intersection:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此工厂函数根据指定的类型标记构建正确的派生对象。剩下的只是让 `Intersection` 对象序列化和反序列化构成交集的两个几何体的标记：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'First, the tags are sent to the visitor. The serializing visitor should write
    the tags along with the rest of the data:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，标记被发送到访问者。序列化访问者应该将标记与数据的其他部分一起写入：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The deserializing visitor has to read the tag (actually, it reads a `size_t`
    number and converts it to the tag):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化访问者必须读取标记（实际上，它读取一个 `size_t` 数字并将其转换为标记）：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Once the tag is restored by the deserializing visitor, the `Intersection` object
    can invoke the factory constructor to construct the right geometry object. Now
    we can deserialize this object from the stream, and our `Intersection` is restored
    as an exact copy of the one we serialized. Note that there are other ways to package
    visiting the tags and the calls to the factory constructor; the optimal solution
    depends on the roles of different objects in the system - for example, the deserializing
    visitor may construct the objects based on the tag instead of the composite object
    that owns these geometries. The sequence of events that need to take place, however,
    remains the same.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦反序列化访问者恢复了标签，`Intersection`对象可以调用工厂构造函数来构建正确的几何对象。现在我们可以从这个流中反序列化这个对象，我们的`Intersection`就被恢复成了与序列化时完全相同的副本。请注意，还有其他方法来封装访问标签和调用工厂构造函数；最佳解决方案取决于系统中不同对象的角色——例如，反序列化访问者可能会根据标签而不是拥有这些几何形状的复合对象来构建对象。然而，需要发生的事件序列仍然是相同的。
- en: So far, we have been learning about the classic object-oriented Visitor pattern.
    Before we see what the C++-specific twists on the classic pattern are, we should
    learn about another type of visitor that addresses some of the inconveniences
    in the Visitor pattern.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在学习经典的面向对象访问者模式。在我们看到经典模式在C++中的特定变化之前，我们应该了解另一种类型的访问者，它解决了访问者模式中的一些不便之处。
- en: Acyclic Visitor
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无环访问者
- en: The Visitor pattern, as we have seen it so far, does what we wanted it to do.
    It separates the implementation of the algorithm from the object that is the data
    for the algorithm, and it allows us to select the correct implementation based
    on two run-time factors - the specific object type and the concrete operation
    we want to perform, both of which are selected from their corresponding class
    hierarchies. There is, however, a fly in the ointment - we wanted to reduce complexity
    and simplified the code maintenance, and we did, but now we have to maintain two
    parallel class hierarchies, the visitable objects and the visitors, and the dependencies
    between the two are non-trivial. The worst part of these dependencies is that
    they form a cycle - the Visitor object depends on the types of the visitable objects
    (there is an overload of the `visit()` methods for every visitable type), and
    the base visitable type depends on the base visitor type. The first half of this
    dependency is the worst. Every time a new object is added to the hierarchy, every
    visitor must be updated. The second half does not take much work from the programmer
    as new visitors can be added at any time and without any other changes - this
    is the whole point of the Visitor pattern. But there is still the compile-time
    dependency of the base visitable class, and, perforce, all derived classes, on
    the base Visitor class. Were the Visitor class to change, every file that uses
    one of the visitable classes would need to be recompiled. The visitors are, for
    the most part, stable in their interface and implementation, except for one case
    - adding a new visitable class. Thus, the cycle in action looks like this - a
    new class is added to the hierarchy of the visitable objects. The Visitor classes
    need to be updated with the new type. Since the base Visitor class was changed,
    the base visitable class and every line of code that depends on it must be recompiled,
    including the code that does not use the new visitable class, only the old ones.
    Even using forward declarations whenever possible does not help - if a new visitable
    class is added, all the old ones must be recompiled.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，访问者模式到目前为止已经做到了我们想要它做的事情。它将算法的实现与作为算法数据的目标对象分离，并允许我们根据两个运行时因素来选择正确的实现——具体的对象类型和我们要执行的具体操作，这两个因素都从它们各自的类层次结构中选择。然而，这里有一个问题——我们想要减少复杂性并简化代码维护，我们确实做到了，但现在我们必须维护两个并行类层次结构，即可访问对象和访问者，以及两者之间的依赖关系是非平凡的。这些依赖关系中最糟糕的部分是它们形成了一个循环——访问者对象依赖于可访问对象的类型（对于每个可访问类型都有一个`visit()`方法的重载），而基础可访问类型依赖于基础访问者类型。这个依赖关系的前半部分是最糟糕的。每次向层次结构中添加新对象时，每个访问者都必须更新。后半部分对程序员的工作量不大，因为可以在任何时候添加新的访问者，而不需要任何其他更改——这就是访问者模式的核心所在。但仍然存在基础可访问类及其所有派生类对基础访问者类的编译时依赖。访问者的大部分接口和实现都是稳定的，除了一个情况——添加新的可访问类。因此，这个循环在操作中看起来是这样的——向可访问对象的层次结构中添加了一个新类。访问者类需要更新以包含新类型。由于基础访问者类已更改，基础可访问类及其所有依赖于它的代码行都必须重新编译，包括不使用新可访问类的代码，只使用旧的。即使尽可能使用前向声明也无法帮助——如果添加了新的可访问类，所有旧的都必须重新编译。
- en: The additional problem of the traditional Visitor pattern is that every possible
    combination of the object type and the visitor type must be handled. Often there
    are cases when some combinations do not make sense, and certain objects will never
    be visited by some types of visitors. But we cannot take advantage of this as
    every combination must have a defined action (the action could be very simple,
    but still, every Visitor class must have the full set of `visit()` member functions
    defined).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 传统访问者模式的附加问题是必须处理对象类型和访问者类型的所有可能组合。通常情况下，有些组合是没有意义的，某些对象永远不会被某些类型的访问者访问。但我们不能利用这一点，因为每个组合都必须有一个定义好的动作（动作可能非常简单，但仍然，每个访问者类都必须定义完整的`visit()`成员函数集）。
- en: 'The Acyclic Visitor pattern is a variant of the Visitor pattern that is specifically
    designed to break the dependency cycle and allow partial visitation. The base
    visitable class for the Acyclic Visitor pattern is the same as for the regular
    Visitor pattern:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 无环访问者模式是访问者模式的一种变体，它专门设计用来打破依赖循环并允许部分访问。无环访问者模式的基础可访问类与常规访问者模式相同：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, that is where the similarity ends. The base Visitor class does not
    have the `visit()` overloads for every visitable. In fact, it has no `visit()`
    member function at all:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，相似之处到此为止。基访问者类没有为每个可访问对象提供`visit()`重载。事实上，它根本没有任何`visit()`成员函数：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So, who does the visiting then? For every derived class in the original hierarchy,
    we also declare the corresponding Visitor class, and that is where the `visit()`
    function is:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，谁来进行访问呢？对于原始层次结构中的每个派生类，我们也声明相应的访问者类，这就是`visit()`函数所在的地方：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note that each visitor can visit only the class it was designed for - the `CatVisitor`
    visits only `Cat` objects, the `DogVisitor` visits only `Dog` objects, and so
    on. The magic is in the new `accept()` function - when a class is asked to accept
    a visitor, it first uses `dynamic_cast` to check whether this is the right type
    of visitor. If it is, all is well, and the visitor is accepted. If it isn’t, we
    have a problem and must handle the error (the exact mechanism of error handling
    depends on the application; for example, an exception can be thrown). The concrete
    Visitor classes, therefore, must be derived from both the common `PetVisitor`
    base class and the class-specific base class such as `CatVisitor`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个访问者只能访问它被设计为访问的类——`CatVisitor`只访问`Cat`对象，`DogVisitor`只访问`Dog`对象，等等。魔法在于新的`accept()`函数——当一个类被要求接受一个访问者时，它首先使用`dynamic_cast`来检查这是否是正确的访问者类型。如果是，一切顺利，访问者被接受。如果不是，我们就有问题，必须处理错误（错误处理的精确机制取决于应用程序；例如，可以抛出异常）。因此，具体的访问者类必须从公共的`PetVisitor`基类以及如`CatVisitor`之类的特定基类派生：
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Each concrete visitor class is derived from the common visitor base and from
    every per-type visitor base (`CatVisitor`, `DogVisitor`, and so on) for every
    type that must be handled by this visitor. On the other hand, if this visitor
    is not designed to visit some of the classes in the hierarchy, we can simply omit
    the corresponding visitor base, and then we won’t need to implement the virtual
    function override either:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个具体的访问者类都从公共访问者基类派生，并且从每个必须由该访问者处理的类型的每个特定类型的访问者基类（例如`CatVisitor`、`DogVisitor`等）派生。另一方面，如果这个访问者没有被设计为访问层次结构中的某些类，我们可以简单地省略相应的访问者基类，然后我们也就不需要实现虚拟函数的重载了：
- en: '[PRE39]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The invocation of the Acyclic Visitor pattern is done in exactly the same way
    as with the regular Visitor pattern:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无环访问者模式的调用方式与常规访问者模式完全相同：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If we try to visit an object that is not supported by the particular Visitor,
    the error is detected. Therefore, we have solved the problem of partial visitation.
    What about the dependency cycle? That is taken care of as well - the common `PetVisitor`
    base class does not need to list the complete hierarchy of visitable objects,
    and the concrete visitable classes depend only on their per-class visitors, but
    not on any visitors for other types. Therefore, when another visitable object
    is added to the hierarchy, the existing ones do not need to be recompiled.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试访问特定访问者不支持的对象，错误就会被检测到。因此，我们已经解决了部分访问的问题。那么依赖循环怎么办？这也得到了妥善处理——公共的`PetVisitor`基类不需要列出可访问对象的完整层次结构，具体的可访问类只依赖于它们各自的类访问者，而不是任何其他类型的访问者。因此，当向层次结构中添加另一个可访问对象时，现有的对象不需要重新编译。
- en: The Acyclic Visitor pattern looks so good that one has to wonder, *why not use
    it all the time instead of the regular Visitor pattern?* There are a few reasons.
    First of all, the Acyclic Visitor pattern uses `dynamic_cast` to cast from one
    base class to another (sometimes called cross-cast). This operation is typically
    more expensive than the virtual function call, so the Acyclic Visitor pattern
    is slower than the alternative. Also, the Acyclic Visitor pattern requires a Visitor
    class for every visitable class, so twice as many classes, and it uses multiple
    inheritance with a lot of base classes. That second issue is not much of a problem
    for most modern compilers, but many programmers find it difficult to deal with
    multiple inheritance. Whether the first issue - the runtime cost of the dynamic
    cast - is a problem depends on the application, but it is something you need to
    be aware of. On the other hand, the Acyclic Visitor pattern really shines when
    the visitable object hierarchy changes frequently or when the cost of recompiling
    the entire code base is significant.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Acyclic Visitor模式看起来如此之好，以至于人们不禁要问，*为什么不总是使用它而不是常规的Visitor模式呢？* 有几个原因。首先，Acyclic
    Visitor模式使用`dynamic_cast`从一个基类转换到另一个基类（有时称为交叉转换）。这个操作通常比虚函数调用更昂贵，所以Acyclic Visitor模式比替代方案更慢。此外，Acyclic
    Visitor模式要求为每个可访问类提供一个Visitor类，因此类数增加了一倍，并且它使用了多个继承和许多基类。第二个问题对于大多数现代编译器来说不是什么大问题，但许多程序员发现处理多重继承很困难。第一个问题——动态转换的运行时成本——是否是问题取决于应用程序，但这是你需要注意的事情。另一方面，当可访问对象层次结构频繁变化或整个代码库重新编译的成本很高时，Acyclic
    Visitor模式确实很出色。
- en: 'You may have noticed one more issue with the Acyclic Visitor pattern - it has
    a lot of boilerplate code. Several lines of code have to be copied for every visitable
    class. In fact, the regular Visitor pattern suffers from the same problem in that
    implementing either kind of visitor involves a lot of repetitive typing. But C++
    has a special set of tools to replace code repetition with code reuse: that is
    exactly what generic programming is for. We shall see next how the Visitor pattern
    is adapted to modern C++.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到Acyclic Visitor模式的一个问题——它有很多样板代码。对于每个可访问类，必须复制几行代码。实际上，常规的Visitor模式也面临着同样的问题，即实现任何一种Visitor都涉及到大量的重复输入。但是C++有一套特殊的工具来用代码复用来替换代码重复：这正是泛型编程的目的。我们将在下一节中看到Visitor模式是如何适应现代C++的。
- en: Visitors in modern C++
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代C++中的Visitor
- en: As we have just seen, the Visitor pattern promotes the separation of concerns;
    for example, the order of serialization and the mechanism of serialization are
    made independent, and a separate class is responsible for each. The pattern also
    simplifies code maintenance by collecting all code that performs a given task
    in one place. What the Visitor pattern does not promote is code reuse with no
    duplication. But that’s the object-oriented Visitor pattern, before modern C++.
    Let’s see what we can do with the generic capabilities of C++, starting from the
    regular Visitor pattern.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，Visitor模式促进了关注点的分离；例如，序列化的顺序和序列化的机制被独立出来，每个都由一个单独的类负责。该模式还通过将执行给定任务的代码收集到一个地方来简化代码维护。Visitor模式不促进的是没有重复的代码复用。但那是现代C++之前的面向对象的Visitor模式。让我们看看我们可以如何利用C++的泛型能力，从常规的Visitor模式开始。
- en: Generic Visitor
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型Visitor
- en: 'We are going to try to reduce the boilerplate code in the implementation of
    the Visitor pattern. Let’s start with the `accept()` member function, which must
    be copied into every visitable class; it always looks the same:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试减少Visitor模式实现中的样板代码。让我们从`accept()`成员函数开始，它必须复制到每个可访问类中；它总是看起来一样：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This function cannot be moved to the base class because we need to call the
    visitor with the actual type, not the base type - `visit()` accepts `Cat*`, `Dog*`,
    and so on, but not `Pet*`. We can get a template to generate this function for
    us if we introduce an intermediate templated base class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不能移动到基类，因为我们需要调用具有实际类型的访问者，而不是基类型——`visit()`接受`Cat*`、`Dog*`等，但不接受`Pet*`。如果我们引入一个中间的模板基类，我们可以得到一个模板来为我们生成这个函数：
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The template is parameterized by the derived class. In this regard, it is similar
    to the `this` pointer to the correct derived class pointer. Now we just need to
    derive each pet class from the right instantiation of the template, and we get
    the `accept()` function automatically:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 模板由派生类参数化。在这方面，它与指向正确派生类指针的 `this` 指针类似。现在我们只需要从模板的正确实例化中派生每个宠物类，我们就会自动获得 `accept()`
    函数：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'That takes care of half of the boilerplate code - the code inside the derived
    visitable objects. Now there is only the other half left: the code inside the
    Visitor classes, where we have to type the same declaration over and over again
    for every visitable class. We can’t do much about the specific visitors; after
    all, that’s where the real work is done, and, presumably, we need to do different
    things for different visitable classes (otherwise why use double dispatch at all?)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了样板代码的一半——派生可访问对象内部的代码。现在只剩下另一半：访问者类内部的代码，在那里我们必须为每个可访问类重复相同的声明。我们对特定访问者无能为力；毕竟，那里才是真正的工作所在，而且，假设我们需要为不同的可访问类做不同的事情（否则为什么要使用双重分派呢？）
- en: 'However, we can simplify the declaration of the base Visitor class if we introduce
    this generic Visitor template:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们引入这个通用访问者模板，我们可以简化基访问者类的声明：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Note that we have to implement this template only once: not once for each class
    hierarchy, but once forever (or at least until we need to change the signature
    of the `visit()` function, for example, to add arguments). This is a good generic
    library class. Once we have it, declaring a visitor base for a particular class
    hierarchy becomes so trivial that it feels anticlimactic:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只需要实现这个模板一次：不是为每个类层次结构实现一次，而是永远实现一次（或者至少直到我们需要更改 `visit()` 函数的签名，例如，添加参数）。这是一个好的通用库类。一旦我们有了它，声明特定类层次结构的访问者基类就变得如此简单，以至于感觉有些平淡无奇：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Notice the somewhat unusual syntax with the `class` keyword - it combines the
    template argument list with a forward declaration and is equivalent to the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `class` 关键字有些不寻常的语法——它将模板参数列表与前置声明结合起来，相当于以下内容：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How does the Generic Visitor base work? It uses the variadic template to capture
    an arbitrary number of type arguments, but the primary template is only declared,
    not defined. The rest are specializations. First, we have the special case of
    one type argument. We declare the pure `visit()` virtual member function for that
    type. Then we have a specialization for more than one type argument, where the
    first argument is explicit, and the rest are in the parameter pack. We generate
    the `visit()` function for the explicitly specified type and inherit the rest
    of them from an instantiation of the same variadic template but with one less
    argument. The instantiation is recursive until we are down to only one type argument,
    and then the first specialization is used.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通用访问者基类是如何工作的？它使用变长模板来捕获任意数量的类型参数，但主要模板只声明了，没有定义。其余的是特化。首先，我们有一个只有一个类型参数的特殊情况。我们为该类型声明了纯
    `visit()` 虚拟成员函数。然后我们有一个针对多个类型参数的特化，其中第一个参数是显式的，其余的都在参数包中。我们为显式指定的类型生成 `visit()`
    函数，并从具有一个较少参数的相同变长模板的实例化中继承其余的。实例化是递归的，直到我们只剩下一个类型参数，然后使用第一个特化。
- en: 'This generic and reusable code has one restriction: it does not handle deep
    hierarchies. Recall that each visitable class is derived from a common base:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这段通用且可重用的代码有一个限制：它不能处理深层层次结构。回想一下，每个可访问的类都派生自一个共同的基类：
- en: '[PRE47]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we were to derive another class from `Cat`, it would have to be derived
    from `Visitable` as well:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要从 `Cat` 派生另一个类，它也必须从 `Visitable` 派生：
- en: '[PRE48]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We cannot just derive `SiameseCat` from `Cat` because it is the Visitable template
    that provides the `accept()` method for each derived class. But we can’t use the
    double inheritance as we just tried either, because now, the `SiameseCat` class
    inherits from Pet twice: once through the `Cat` base and once through the `Visitable`
    base. The only solution to this, if you still want to use the templates to generate
    `accept()` methods, is to separate the hierarchy so each visitable class such
    as `Cat` inherits from `Visitable` and from a corresponding base class `CatBase`
    that has all the “cat-specific” functionality except for the visitation support.
    This doubles the number of classes in the hierarchy and is a major drawback.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能仅仅从`Cat`派生出`SiameseCat`，因为它是提供每个派生类`accept()`方法的`Visitable`模板。但我们也不能像之前尝试的那样使用双重继承，因为现在`SiameseCat`类从`Pet`基类和`Visitable`基类继承两次：一次是通过`Cat`基类，一次是通过`Visitable`基类。如果你仍然想使用模板生成`accept()`方法，唯一的解决方案是将层次结构分开，使得每个可访问类（如`Cat`）都从`Visitable`继承，并从具有所有“猫特定”功能（除了访问支持）的相应基类`CatBase`继承。这会使层次结构中的类数量加倍，这是一个主要的缺点。
- en: Now that we have the boilerplate visitor code generated by templates, we can
    also make it simpler to define concrete visitors.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了由模板生成的样板访问者代码，我们也可以使其定义具体的访问者更加简单。
- en: Lambda Visitor
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda访问者
- en: 'Most of the work in defining a concrete visitor is writing code for the actual
    work that has to happen for every visitable object. There is not a lot of boilerplate
    code in a specific visitor class. But sometimes we may not want to declare the
    class itself. Think about lambda expressions - anything that can be done with
    a lambda expression can also be done with an explicitly declared callable class
    because lambdas are (anonymous) callable classes. Nonetheless, we find lambda
    expressions very useful for writing one-off callable objects. Similarly, we may
    want to write a visitor without explicitly naming it - a lambda Visitor. We would
    want it to look something like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 定义具体访问者的大部分工作是为每个可访问对象必须发生的实际工作编写代码。在特定的访问者类中并没有很多样板代码。但有时我们可能不想声明这个类本身。想想lambda表达式——任何可以用lambda表达式完成的事情也可以用显式声明的可调用类完成，因为lambda是（匿名）可调用类。尽管如此，我们发现lambda表达式对于编写一次性可调用对象非常有用。同样，我们可能想要编写一个没有显式命名的访问者——一个lambda访问者。我们希望它看起来像这样：
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There are two problems to be solved - how to create a class that handles a list
    of types and corresponding objects (in our case, the visitable types and the corresponding
    lambdas), and how to generate a set of overloaded functions using lambda expressions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个问题需要解决——如何创建一个处理类型列表及其相应对象（在我们的例子中，是可访问类型和相应的lambda）的类，以及如何使用lambda表达式生成一组重载函数。
- en: The former problem will require us to recursively instantiate a template on
    the parameter pack, peeling off one argument at a time. The solution to the latter
    problem is similar to the overload set of the lambda expression, which was described
    in the chapter on class templates. We could use the overload set from that chapter,
    but we can use the recursive template instantiation that we need anyway, to build
    the overloaded set of functions directly.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个问题将需要我们递归地在参数包上实例化一个模板，每次剥掉一个参数。后一个问题与lambda表达式的重载集类似，这在类模板章节中已经描述过。我们可以使用那一章中的重载集，但我们可以使用我们需要的递归模板实例化来直接构建函数的重载集。
- en: 'There is going to be one new challenge in this implementation - we have to
    process not one but two lists of types. The first list has all visitable types
    in it; in our case, `Cat` and `Dog`. The second list has the types of lambda expressions,
    one for each visitable type. We have not seen a variadic template with two parameter
    packs yet, and for a good reason - it is not possible to simply declare `template<typename...
    A, typename... B>` as the compiler would not know where the first list ends and
    the second begins. The trick is to hide one or both lists of types inside other
    templates. In our case, we already have the `Visitor` template that is instantiated
    on the list of visitable types:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们将面临一个新的挑战——我们必须处理不止一个类型列表。第一个列表包含所有可访问类型；在我们的例子中，是`Cat`和`Dog`。第二个列表包含lambda表达式的类型，每个可访问类型一个。我们还没有看到带有两个参数包的变长模板，而且有很好的理由——不能简单地声明`template<typename...
    A, typename... B>`，因为编译器不知道第一个列表在哪里结束，第二个在哪里开始。技巧是将一个或两个类型列表隐藏在其他模板中。在我们的例子中，我们已经有了一个`Visitor`模板，它在可访问类型的列表上实例化：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can extract this list from the `Visitor` template and match each type with
    its lambda expression. The partial specialization syntax used to process two parameter
    packs in sync is tricky, so we will work through it in steps. First of all, we
    need to declare the general template for our `LambdaVisitor` class:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note that there is only one general parameter pack here, plus the base class
    for the visitor (in our case, it will be `PetVisitor`). This template must be
    declared, but it is never going to be used - we will provide a specialization
    for every case that needs to be handled. The first specialization is used when
    there is only one visitable type and one corresponding lambda expression:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This specialization, in addition to handling the case where we have only one
    visitable type, is used as the last instantiation in every chain of recursive
    template instantiations. Since it is always the first base class in the recursive
    hierarchy of `LambdaVisitor` instantiations, it is the only one that directly
    inherits from the base Visitor class such as `PetVisitor`. Note that, even with
    a single `T1` visitable type, we use the `Visitor` template as a wrapper for it.
    This is done in preparation for the general case where we will have a list of
    types whose length is unknown. The two constructors store the `f1` lambda expression
    inside the `LambdaVisitor` class, using move instead of copy if possible. Finally,
    the `visit(T1*)` virtual function override simply forwards the call to the lambda
    expression. It may appear simpler, at first glance, to inherit publicly from `F1`
    and just agree to use the functional calling syntax (in other words, to rename
    all calls to `visit()` to calls to `operator()` everywhere). This is not going
    to work; we need the indirection because the `operator()` instance of the lambda
    expression itself cannot be a virtual function override. By the way, the `override`
    keyword here is invaluable in detecting bugs in code where the template is not
    inherited from the right base class or the virtual function declarations do not
    match exactly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'The general case of any number of visitable types and lambda expressions is
    handled by this partial specialization, which explicitly deals with the first
    types in both lists, then recursively instantiates itself to process the rest
    of the lists:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Again, we have two constructors that store the first lambda expression in the
    class and forward the rest to the next instantiation. One virtual function override
    is generated on each step of the recursion, always for the first type in the remaining
    list of the visitable classes. That type is then removed from the list, and the
    processing continues in the same manner until we reach the last instantiation,
    the one for a single visitable type.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it is not possible to explicitly name the types of lambda expressions,
    we also cannot explicitly declare the type of the lambda visitor. Instead, the
    lambda expression types must be deduced by the template argument deduction, so
    we need a `lambda_visitor()` template function that accepts multiple lambda expression
    arguments and constructs the `LambdaVisitor` object from all of them:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法显式命名lambda表达式的类型，因此我们也不能显式声明lambda访问者的类型。相反，lambda表达式的类型必须通过模板参数推导来推断，因此我们需要一个接受多个lambda表达式参数并从所有这些参数中构建`LambdaVisitor`对象的`lambda_visitor()`模板函数：
- en: '[PRE54]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In C++17, the same can be accomplished with a deduction guide. Now that we
    have a class that stores any number of lambda expressions and binds each one to
    the corresponding `visit()` override, we can write lambda visitors just as easily
    as we write lambda expressions:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，可以使用推导指南实现相同的功能。现在我们有一个存储任意数量lambda表达式并将每个lambda表达式绑定到相应的`visit()`重写的类，我们可以像编写lambda表达式一样轻松地编写lambda访问者：
- en: '[PRE55]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that, because of the way we declare the `visit()` function in the same
    class that inherits from the corresponding lambda expression, the order of the
    lambda expression in the argument list of the `lambda_visitor()` function must
    match the order of classes in the list of types in `PetVisitor` definition. This
    restriction can be removed, if desired, at the cost of some additional complexity
    of the implementation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们在继承相应lambda表达式的同一类中声明了`visit()`函数，因此`lambda_visitor()`函数参数列表中lambda表达式的顺序必须与`PetVisitor`定义中类型列表中类的顺序相匹配。如果需要，可以通过增加一些实现复杂性的代价来移除这种限制。
- en: 'Another common way of dealing with type lists in C++ is to store them in a
    `std::tuple`: for example, we can use `std::tuple<Cat, Dog>` to represent a list
    consisting of the two types. Similarly, an entire parameter pack can be stored
    in a tuple:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中处理类型列表的另一种常见方法是将它们存储在`std::tuple`中：例如，我们可以使用`std::tuple<Cat, Dog>`来表示由两种类型组成的列表。同样，整个参数包也可以存储在元组中：
- en: '[PRE56]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can compare examples 13 and 14 to see how to use `std::tuple` to store a
    type list.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将示例13和14进行比较，以了解如何使用`std::tuple`来存储类型列表。
- en: We have now seen how the common fragments of the visitor code can be turned
    into reusable templates, and how this, in turn, lets us create a lambda visitor.
    But we have not forgotten the other visitor implementation we learned in this
    chapter, the Acyclic Visitor pattern. Let’s see how it, too, can benefit from
    the modern C++ language features.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何将访问者代码的常见片段转换为可重用的模板，以及这如何反过来让我们创建lambda访问者。但我们没有忘记在本章中学到的另一种访问者实现，即非循环访问者模式。让我们看看它如何也能从现代C++语言特性中受益。
- en: Generic Acyclic Visitor
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型非循环访问者
- en: 'The Acyclic Visitor pattern does not need a base class with a list of all visitable
    types. However, it has its own share of boilerplate code. First of all, each visitable
    type needs the `accept()` member function, and it has more code than the similar
    function in the original Visitor pattern:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 非循环访问者模式不需要具有所有可访问类型列表的基类。然而，它也有自己的样板代码。首先，每个可访问类型都需要一个`accept()`成员函数，并且它比原始访问者模式中的类似函数有更多的代码：
- en: '[PRE57]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Assuming that the error handling is uniform, this function is repeated over
    and over for different types of visitors, each corresponding to its visitable
    type (such as `CatVisitor` here). Then there is the per-type Visitor class itself,
    for example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 假设错误处理是统一的，这个函数会针对不同的访问者类型重复使用，每个访问者类型对应其可访问类型（例如这里的`CatVisitor`）。然后还有每个类型的访问者类本身，例如：
- en: '[PRE58]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Again, this code is pasted all over the program, with slight modifications.
    Let’s convert this error-prone code duplication into easy-to-maintain reusable
    code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这段代码被粘贴到程序的所有地方，只有细微的修改。让我们将这种容易出错的代码复制粘贴转换为易于维护的可重用代码。
- en: 'We will need to create some infrastructure first. The Acyclic Visitor pattern
    bases its hierarchy on a common base class for all visitors, such as the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要创建一些基础设施。非循环访问者模式以其所有访问者的公共基类为基础构建其层次结构，如下所示：
- en: '[PRE59]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Note that there is nothing specific to the `Pet` hierarchy here. With a better
    name, this class can serve as a base class for any visitor hierarchy:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里没有针对`Pet`层次结构的具体内容。通过更好的命名，这个类可以作为任何访问者层次结构的基类：
- en: '[PRE60]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We also need a template to generate all these Visitor base classes specific
    to visitable types, to replace the near-identical `CatVisitor`, `DogVisitor`,
    and so on. Since all that is needed from these classes is the declaration of the
    pure virtual `visit()` method, we can parameterize the template by the visitable
    type:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个模板来生成所有这些针对可访问类型的特定`Visitor`基类，以替换几乎相同的`CatVisitor`、`DogVisitor`等。由于这些类所需的所有内容仅仅是纯虚`visit()`方法的声明，我们可以通过可访问类型来参数化模板：
- en: '[PRE61]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The base visitable class for any class hierarchy now accepts visitors using
    the common `VisitorBase` base class:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何类层次结构，其基可访问类现在使用共同的`VisitorBase`基类接受访问者：
- en: '[PRE62]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Instead of deriving each visitable class directly from `Pet` and pasting a
    copy of the `accept()` method, we introduce an intermediate template base class
    that can generate this method with the correct types:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再直接从`Pet`派生每个可访问类并粘贴`accept()`方法的副本，而是引入一个中间模板基类，它可以生成具有正确类型的此方法：
- en: '[PRE63]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This is the only copy of the `accept()` function we need to write, and it contains
    the preferred error handling implementation for our application to deal with cases
    when the visitor is not accepted by the base class (recall that Acyclic Visitor
    allows partial visitation, where some combinations of the visitor and visitable
    are not supported). Just like for the regular Visitor, the intermediate CRTP base
    class makes it hard to use deep hierarchies with this approach.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要编写的`accept()`函数的唯一副本，它包含了我们应用程序处理访问者不被基类接受的情况的首选错误处理实现（回想一下，循环访问者允许部分访问，其中某些访问者和可访问类型的组合不受支持）。就像常规访问者一样，中间的CRTP基类使得使用深度层次结构变得困难。
- en: 'The concrete visitable classes inherit from the common `Pet` base class indirectly,
    through the intermediate `PetVisitable` base class, which also provides them with
    the visitable interface. The argument to the `PetVisitable` template is the derived
    class itself (again, we see the CRTP in action):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的可访问类通过中间的`PetVisitable`基类间接继承自共同的`Pet`基类，该基类还为他们提供了可访问接口。`PetVisitable`模板的参数是派生类本身（再次，我们看到CRTP的作用）：
- en: '[PRE64]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: It is, of course, not mandatory to use the same base class constructors for
    all derived classes, as custom constructors can be defined in every class as needed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于所有派生类，使用相同的基类构造函数并不是强制性的，因为每个类都可以根据需要定义自定义构造函数。
- en: 'The only thing left is to implement the Visitor class. Recall that the specific
    visitor in the Acyclic Visitor pattern inherits from the common visitor base and
    each of the visitor classes that represent the supported visitable types. That
    is not going to change, but we now have a way to generate these visitor classes
    on demand:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情是实现访问者类。回想一下，在循环访问者模式中，特定的访问者从共同的访问者基类继承，并且每个代表受支持的可访问类型的访问者类。这不会改变，但现在我们有了按需生成这些访问者类的方法：
- en: '[PRE65]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let’s look back at the work we have done - the parallel hierarchy of visitor
    classes no longer needs to be typed explicitly; instead, they are generated as
    needed. The repetitive `accept()` functions are reduced to the single `PetVisitable`
    class template. Still, we have to write this template for every new visitable
    class hierarchy. We can generalize this too, and create a single reusable template
    for all hierarchies, parameterized by the base visitable class:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们所做的工作——访问者类的并行层次结构不再需要显式地指定类型；相反，它们按需生成。重复的`accept()`函数减少到单个`PetVisitable`类模板。尽管如此，我们仍然需要为每个新的可访问类层次结构编写这个模板。我们也可以将其泛化，并为所有层次结构创建一个可重用的模板，该模板通过基可访问类进行参数化：
- en: '[PRE66]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, for every visitable class hierarchy, we just need to create a template
    alias:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于每个可访问类层次结构，我们只需要创建一个模板别名：
- en: '[PRE67]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can make one more simplification and allow the programmer to specify the
    list of visitable classes as a list of types, instead of inheriting from `Visitor<Cat>`,
    `Visitor<Dog>`, and so on, as we have done previously. This requires a variadic
    template to store the list of types. The implementation is similar to the `LambdaVisitor`
    instance we saw earlier:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步简化，允许程序员将可访问类的列表指定为类型列表，而不是像之前那样从`Visitor<Cat>`、`Visitor<Dog>`等继承。这需要一个变长模板来存储类型列表。实现与之前看到的`LambdaVisitor`实例类似：
- en: '[PRE68]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can use this wrapper template to shorten the declarations of the specific
    visitors:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个包装模板来缩短特定访问者的声明：
- en: '[PRE69]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If desired, we can even hide `VisitorBase` in the definition of the `Visitors`
    template for the single type argument.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们甚至可以将`VisitorBase`隐藏在为单个类型参数定义的`Visitors`模板的定义中。
- en: We have now seen both the classic object-oriented Visitor pattern and its reusable
    implementations, made possible by the generic programming tools of C++. In the
    earlier chapters, we have seen how some patterns can be applied entirely at compile
    time. Let’s now consider whether the same can be done with the Visitor pattern.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了经典面向对象的访问者模式及其可重用的实现，这些实现是由C++的泛型编程工具实现的。在早期章节中，我们看到了一些模式可以完全在编译时应用。现在让我们考虑是否也可以用访问者模式做到这一点。
- en: Compile-time Visitor
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时访问者
- en: In this section, we will analyze the possibility of using the Visitor pattern
    at compile time, in a similar fashion to, say, the application of the Strategy
    pattern that leads to policy-based design.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析在编译时使用访问者模式的可行性，类似于应用策略模式导致基于策略的设计。
- en: 'First of all, the multiple dispatch aspect of the Visitor pattern becomes trivial
    when used in the template context:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当在模板上下文中使用时，访问者模式的多个分派方面变得非常简单：
- en: '[PRE70]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'A template function can easily run a different algorithm for any combination
    of the `T1` and `T2` types. Unlike the run-time polymorphism implemented with
    virtual functions, dispatching the call differently based on two or more types
    comes at no extra cost (other than writing code for all the combinations we need
    to handle, of course). Based on this observation, we can easily mimic the classic
    Visitor pattern at compile time:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 模板函数可以轻松地为`T1`和`T2`类型的任何组合运行不同的算法。与使用虚函数实现的运行时多态不同，根据两个或更多类型的不同调用分发并不需要额外的成本（当然，除了编写处理所有组合所需的代码之外）。基于这个观察，我们可以在编译时轻松地模仿经典的访问者模式：
- en: '[PRE71]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `accept()` function is now a template and a static member function - the
    actual type of the first argument, the visitable object derived from the `Pet`
    class, will be deduced at compile time. The concrete visitable classes are derived
    from the base class in the usual way:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`accept()`函数现在是一个模板和静态成员函数 - 第一个参数的实际类型，即从`Pet`类派生的可访问对象，将在编译时推断出来。具体的可访问类以通常的方式从基类派生：'
- en: '[PRE72]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The visitors do not need to be derived from a common base since we now resolve
    the types at compile time:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者不需要从公共基类派生，因为我们现在在编译时解析类型：
- en: '[PRE73]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The visitable classes can accept any visitor that has the correct interface,
    that is, `visit()` overloads for all classes in the hierarchy:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问的类可以接受任何具有正确接口的访问者，即对层次结构中所有类都有`visit()`重载：
- en: '[PRE74]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Of course, any function that accepts the visitor arguments and needs to support
    multiple visitors would have to be made a template as well (it is no longer sufficient
    to have a common base class, which only helps to determine the actual object type
    at run time).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，任何接受访问者参数并需要支持多个访问者的函数也必须是一个模板（仅仅有一个公共基类已经不再足够，它只能帮助在运行时确定实际对象类型）。
- en: The compile-time visitor solves the same problem as the classic visitor, it
    allows us to effectively add new member functions to a class without editing the
    class definition. It does, however, look much less exciting than the run-time
    version.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时访问者解决了经典访问者相同的问题，它允许我们有效地向类添加新成员函数，而无需编辑类定义。然而，它看起来比运行时版本要无趣得多。
- en: 'More interesting possibilities arise when we combine the Visitor pattern with
    the Composition pattern. We have done this once already when we discussed the
    visitation of complex objects, especially in the context of the serialization
    problem. The reason this is particularly interesting is that it relates to the
    connection with one of the few *big-ticket* features missing in C++; namely, the
    reflection. Reflection in programming is the ability of a program to examine and
    introspect its own source and then generate new behavior based on this introspection.
    Some programming languages, such as Delphi or Python, have native reflection capability,
    but C++ does not. Reflection is useful for solving many problems: for example,
    the serialization problem could be easily solved if we could make the compiler
    iterate over all data members of the object and serialize each one, recursively,
    until we reach the built-in types. We can implement something similar using a
    compile-time Visitor pattern.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将访问者模式与组合模式结合使用时，会出现更多有趣的可能。我们在讨论复杂对象的访问问题时已经这样做过一次，尤其是在序列化问题的背景下。这之所以特别有趣，是因为它与C++中缺失的少数几个“重要特性”之一——反射——有关。在编程中，反射是指程序检查和内省其自身源代码的能力，然后根据这种内省生成新的行为。一些编程语言，如Delphi或Python，具有原生的反射能力，但C++没有。反射对于解决许多问题很有用：例如，如果我们能够使编译器遍历对象的所有数据成员并递归地序列化每个成员，直到我们达到内置类型，那么序列化问题就可以轻松解决。我们可以使用编译时访问者模式实现类似的功能。
- en: 'Again, we will consider the hierarchy of geometric objects. Since everything
    is now happening at compile time, we are not interested in the polymorphic nature
    of the classes (they could still use virtual functions if needed for runtime operations;
    we just won’t be writing them or looking at them in this section). For example,
    here is the `Point` class:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将考虑几何对象的层次结构。由于现在所有事情都在编译时发生，我们对类的多态性质不感兴趣（如果需要运行时操作，它们仍然可以使用虚拟函数；我们只是不会在本节中编写或查看它们）。例如，这是`Point`类：
- en: '[PRE75]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The visitation is provided via the `accept()` function, as before, but it is
    class-specific now. The only reason we have the first template parameter, `This`,
    is to support both const and non-const operations easily: `This` can be `Point`
    or `const Point`. Any visitor to this class is sent to visit the two values that
    define the point, `x_` and `y_`. The visitor must have the appropriate interface,
    specifically, the `visit()` member function that accepts `double` arguments. Like
    most C++ template libraries, including the `Line` class:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 访问是通过`accept()`函数提供的，就像之前一样，但现在它是特定于类的。我们只有一个模板参数`This`的原因是为了方便地支持const和非const操作：`This`可以是`Point`或`const
    Point`。任何访问这个类的访问者都会被发送去访问定义点的两个值，`x_`和`y_`。访问者必须具有适当的接口，具体来说，就是接受`double`参数的`visit()`成员函数。像大多数C++模板库一样，包括`Line`类：
- en: '[PRE76]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `Line` class is composed of two points. At compile time, the visitor is
    directed to visit each point. That is the end of the involvement of the `Line`
    class; the `Point` class gets to determine how it is visited (as we have just
    seen, it also delegates the work to another visitor). Since we are not using runtime
    polymorphism anymore, the container classes that can hold geometries of different
    types now have to be templates:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Line`类由两个点组成。在编译时，访问者被引导访问每个点。这就是`Line`类的参与结束；`Point`类将决定如何被访问（正如我们刚才看到的，它也将工作委托给另一个访问者）。由于我们不再使用运行时多态，现在可以容纳不同类型几何形状的容器类现在必须使用模板：'
- en: '[PRE77]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We now have visitable types. We can use different kinds of visitors with this
    interface, not just serialization visitors. However, we are focused on serialization
    now. Previously, we have seen a visitor that converts objects into ASCII strings.
    Now let’s serialize our objects as binary data, continuous streams of bits. The
    serialization visitor has access to a buffer of a certain size and writes the
    objects into that buffer, one `double` at a time:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可访问的类型。我们可以使用具有此接口的不同类型的访问者，而不仅仅是序列化访问者。然而，我们现在专注于序列化。之前，我们看到了一个将对象转换为ASCII字符串的访问者。现在让我们将对象序列化为二进制数据，连续的位流。序列化访问者可以访问一定大小的缓冲区，并将对象写入该缓冲区，每次写入一个`double`值：
- en: '[PRE78]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The deserialization visitor reads memory from the buffer and copies it into
    the data members of the objects it restores:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化访问者从缓冲区读取内存并将其复制到它恢复的对象的数据成员中：
- en: '[PRE79]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Both visitors process built-in types directly by copying them to and from the
    buffer while letting the more complex types decide how the objects should be processed.
    In both cases, the visitors throw an exception if the size of the buffer is exceeded.
    Now we can use our visitors to, for example, send objects through a socket to
    another machine:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 两个访问者都通过将它们复制到缓冲区并从缓冲区复制来直接处理内置类型，同时让更复杂的类型决定如何处理对象。在这两种情况下，如果超出缓冲区大小，访问者都会抛出异常。现在我们可以使用我们的访问者，例如，将对象通过套接字发送到另一台机器：
- en: '[PRE80]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: While we cannot implement universal reflection without language support, we
    can have classes reflect on their content in limited ways, such as this composite
    visitation pattern. There are also a few variations on the theme that we can consider.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有语言支持，我们无法实现通用的反射，但我们可以以有限的方式让类反映其内容，例如这种复合访问模式。我们还可以考虑这个主题的一些变体。
- en: 'First of all, it is conventional to make the objects that have only one *important*
    member function callable; in other words, instead of calling the member function,
    we invoke the object itself using the function call syntax. This convention dictates
    that the `visit()` member function should be called `operator()` instead:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通常的做法是将只有一个**重要**成员函数的对象使其可调用；换句话说，不是调用成员函数，而是使用函数调用语法来调用对象本身。这个约定规定`visit()`成员函数应该被命名为`operator()`：
- en: '[PRE81]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The visitable classes now call the visitors like functions:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问的类现在像函数一样调用访问者：
- en: '[PRE82]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'It may also be convenient to implement wrapper functions to invoke visitors
    on more than one object:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 实现包装函数以在多个对象上调用访问者可能也很方便：
- en: '[PRE83]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This is easy to implement using a variadic template:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过变长模板轻松实现：
- en: '[PRE84]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In C++17, we have fold expressions and do not need a recursive template:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，我们有折叠表达式，不需要递归模板：
- en: '[PRE85]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'In C++14 we can mimic fold expressions using a hack based on `std::initializer_list`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++14中，我们可以使用基于`std::initializer_list`的技巧来模拟折叠表达式：
- en: '[PRE86]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This works, but it is not going to win any prizes for clarity or maintainability.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以工作，但它不太可能因为清晰度或可维护性而获奖。
- en: The compile-time visitors are, in general, easier to implement because we don’t
    have to do anything clever to get multiple dispatch, as the templates provide
    it out of the box. We just need to come up with interesting applications of the
    pattern, such as the serialization/deserialization problem we just explored.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时访问者通常更容易实现，因为我们不需要做任何巧妙的事情来获得多态，因为模板已经提供了这种功能。我们只需要想出有趣的应用模式，比如我们刚刚探索的序列化/反序列化问题。
- en: Visitor in C++17
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++17中的访问者
- en: 'C++17 introduced a major change in the way we use the Visitor pattern with
    the addition of `std::variant` to the standard library. The `std::variant` template
    is essentially a “smart union:” `std::variant<T1, T2, T3>` is similar to `union
    { T1 v1; T2 v2; T3 v3; }` in that both can store a value of one of the specified
    types and only one value can be stored at a time. The key difference is that a
    variant object knows which type it contains, while with a union the programmer
    is wholly responsible for reading the same type as what was written earlier. It
    is undefined behavior to access a union as a type that differs from the one used
    to initialize it:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: C++17通过在标准库中添加`std::variant`引入了我们对访问者模式使用方式的重大变化。`std::variant`模板本质上是一个“智能联合体：”`std::variant<T1,
    T2, T3>`与`union { T1 v1; T2 v2; T3 v3; }`类似，因为它们都可以存储指定类型中的一个值，并且一次只能存储一个值。关键区别在于，变体对象知道它包含哪种类型，而联合体则要求程序员完全负责读取与之前写入相同的类型。将联合体作为与初始化时不同的类型访问是不确定的操作：
- en: '[PRE87]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In contrast, `std::variant` offers a safe way to store values of different
    types in the same memory. It is easy to check at runtime which alternative type
    is currently stored in the variant, and accessing a variant as the wrong type
    throws an exception:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`std::variant`提供了一种安全的方式在相同的内存中存储不同类型的值。在运行时很容易检查当前存储在变体中的是哪种备选类型，如果以错误类型访问变体，则会抛出异常：
- en: '[PRE88]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In many ways, `std::variant` offers capabilities similar to inheritance-based
    run-time polymorphism: both let us write code where the same variable name can
    refer to objects of different types at run time. The two major differences are:
    first, a `std::variant` does not require that all its types come from the same
    hierarchy (they need not be classes at all), and second, a variant object can
    store only one of the types listed in its declaration, while a base class pointer
    can point to any derived class. In other words, adding a new type to the hierarchy
    generally does not require recompilation of the code that uses the base class,
    while adding a new type to the variant requires changing the type of the variant
    object, so all code that refers to this object must be recompiled.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，`std::variant` 提供了类似于基于继承的运行时多态的能力：两者都允许我们编写代码，其中相同的变量名在运行时可以引用不同类型的对象。两个主要区别是：首先，`std::variant`
    不要求所有类型都来自同一个层次结构（它们甚至不必是类），其次，变体对象只能存储其声明中列出的类型之一，而基类指针可以指向任何派生类。换句话说，向层次结构添加新类型通常不需要重新编译使用基类的代码，而向变体添加新类型则需要更改变体对象的类型，因此所有引用此对象的代码都必须重新编译。
- en: 'In this section, we will focus on the use of `std::variant` for visitation.
    This capability is provided by the aptly named function `std::visit` that takes
    a callable and a variant:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注 `std::variant` 的访问使用。这种能力是由名为 `std::visit` 的函数提供的，它接受一个可调用对象和一个变体：
- en: '[PRE89]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To use with `std::visit`, the callable must have an `operator()` declared for
    every type that can be stored in the variant (otherwise the call will not compile).
    Of course, if the implementation is similar, we can use a template `operator()`,
    either in a function object or in a lambda:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 `std::visit` 一起使用，可调用对象必须为变体中可以存储的每种类型声明一个 `operator()`（否则调用将无法编译）。当然，如果实现相似，我们可以在函数对象或
    lambda 中使用模板 `operator()`：
- en: '[PRE90]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We will now reimplement our pet visitors using `std::variant` and `std::visit`.
    First of all, the `Pet` type is no longer the base class of the hierarchy but
    the variant, containing all possible type alternatives:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 `std::variant` 和 `std::visit` 重新实现我们的宠物访客。首先，`Pet` 类型不再是层次结构的基类，而是变体，包含所有可能的类型替代项：
- en: '[PRE91]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The types themselves do not need any visitation machinery. We may still use
    inheritance to reuse common implementation code, but there is no need for the
    types to belong to a single hierarchy:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 类型本身不需要任何访问机制。我们仍然可以使用继承来重用常见的实现代码，但不需要类型属于单个层次结构：
- en: '[PRE92]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now we need to implement some visitors. The visitors are just callable objects
    that can be invoked with every alternative type that might be stored in the variant:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实现一些访问者。访问者只是可调用对象，可以用变体中可能存储的任何替代类型来调用：
- en: '[PRE93]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'To apply a visitor to a variant, we call `std::visit`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要将访问者应用于变体，我们调用 `std::visit`：
- en: '[PRE94]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The variant `p` can contain any of the types we listed when we defined the type
    `Pet` (in this example, it’s a `Cat`). We then invoke `std::visit` and the resulting
    action depends both on the visitor itself and on the type currently stored in
    the variant. The result looks a lot like a virtual function call, so we can say
    that `std::visit` allows us to add new polymorphic functions to a set of types
    (it would be misleading to call them “virtual functions” since the types do not
    have to even be classes).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 变体 `p` 可以包含我们在定义 `Pet` 类型时列出的任何类型（在这个例子中，它是一个 `Cat`）。然后我们调用 `std::visit`，产生的动作既取决于访问者本身，也取决于当前存储在变体中的类型。结果看起来很像虚拟函数调用，因此我们可以说
    `std::visit` 允许我们向一组类型添加新的多态函数（由于这些类型不必是类，所以称它们为“虚拟函数”可能会有误导性）。
- en: 'Whenever we see a callable object with the user-defined `operator()`, we must
    be thinking about lambdas. However, the use of lambdas with `std::visit` is not
    straightforward: we need the object to be callable with every type that can be
    stored in the variant, while a lambda has only one `operator()`. The first option
    is to make that operator a template (polymorphic lambdas) and handle all the possible
    types inside:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们看到一个具有用户定义的 `operator()` 的可调用对象时，我们必须在考虑 lambdas。然而，与 `std::visit` 一起使用
    lambdas 并不简单：我们需要对象能够以变体中可以存储的任何类型进行调用，而 lambda 只有一个 `operator()`。第一个选项是将该操作符做成模板（多态
    lambda）并处理所有可能的类型：
- en: '[PRE95]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here the lambda can be invoked with an argument of any type, and inside the
    body of the lambda, we use `if constexpr` to handle all types that can be stored
    in the variant. The disadvantage of this approach is that we no longer have compile-time
    validation that all possible types are handled by the visitor. The flip side of
    this is, however, that the code will now compile even if not all types are handled,
    and, as long as the visitor is not called with a type for which we have no action
    defined, the program will work fine. In this way, this version is similar to the
    acyclic visitor, while the previous implementation was similar to the regular
    visitor.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，lambda可以用任何类型的参数调用，并在lambda体内部，我们使用`if constexpr`来处理可以存储在变体中的所有类型。这种方法的缺点是我们不再有编译时验证，即所有可能的类型都被访问者处理。然而，另一方面，如果代码现在没有处理所有类型，代码仍然可以编译，并且只要访问者没有被调用带有我们没有定义操作的类型，程序将正常工作。以这种方式，这个版本类似于无环访问者，而之前的实现类似于常规访问者。
- en: 'It is also possible to implement the familiar set of overloaded `operator()`
    using lambdas and the technique for creating overload sets we have seen in [*Chapter
    1*](B19262_01.xhtml#_idTextAnchor014), *An Introduction to Inheritance and Polymorphism*:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用lambda和我们在[*第1章*](B19262_01.xhtml#_idTextAnchor014)中看到的创建重载集的技术来实现熟悉的重载`operator()`集：
- en: '[PRE96]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This visitor is a class that inherits from all the lambdas and exposes their
    `operator()`, thus creating a set of overloads. It is used just like the visitor
    where we explicitly wrote each `operator()`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个访问者是一个继承自所有lambda的类，并暴露它们的`operator()`，从而创建了一组重载。它就像我们明确写出每个`operator()`的访问者一样使用：
- en: '[PRE97]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'So far, we have not used the full potential of `std::visit`: it can be called
    with any number of variant arguments. This allows us to perform an action that
    depends on more than two run-time conditions:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有充分利用`std::visit`的潜力：它可以与任意数量的变体参数一起调用。这允许我们执行依赖于超过两个运行时条件的操作：
- en: '[PRE98]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The visitor has to be written in a way that handles all possible combinations
    of the types that can be stored in each variant:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者必须以处理每个变体中可以存储的所有类型可能组合的方式编写：
- en: '[PRE99]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In practice, the only way it is feasible to write a callable for all possible
    type combinations is by using a template `operator()`, which works only if the
    visitor actions can be written in a generic way. Still, the ability to do multiple
    dispatch is a potentially useful feature of `std::visit` that goes beyond the
    double dispatch capability of the regular Visitor pattern.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，唯一可行的方式来编写适用于所有可能类型组合的可调用函数是使用模板`operator()`，这仅在访问者操作可以用通用方式编写时才有效。尽管如此，`std::visit`能够进行多重分派的能力是一个潜在的有用特性，它超越了常规访问者模式的双分派能力。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the Visitor pattern and the different ways
    it can be implemented in C++. The classic object-oriented Visitor pattern allows
    us to effectively add a new virtual function to the entire class hierarchy without
    changing the source code of the classes. The hierarchy must be made visitable,
    but after that, any number of operations can be added, and their implementation
    is kept separate from the objects themselves. In the classic Visitor pattern implementation,
    the source code containing the visited hierarchy does not need to be changed,
    but it does need to be recompiled when a new class is added to the hierarchy.
    The Acyclic Visitor pattern solves this problem but at the cost of the additional
    dynamic cast. On the other hand, the Acyclic Visitor pattern also supports partial
    visitation - ignoring some visitor/visitable combinations - while the classic
    Visitor pattern requires that all combinations must at least be declared.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了访问者模式及其在C++中的不同实现方式。经典的面向对象访问者模式允许我们在不更改类源代码的情况下，有效地向整个类层次结构添加一个新的虚拟函数。层次结构必须可访问，但在此之后，可以添加任意数量的操作，并且它们的实现与对象本身保持分离。在经典访问者模式的实现中，包含被访问层次结构的源代码不需要更改，但在添加新类到层次结构时，需要重新编译。无环访问者模式解决了这个问题，但代价是额外的动态转换。另一方面，无环访问者模式还支持部分访问
    - 忽略一些访问者/可访问组合 - 而经典访问者模式要求所有组合至少被声明。
- en: For all visitor variants, the tradeoff for extensibility is the need to weaken
    the encapsulation and, frequently, grant external visitor classes access to what
    should be private data members.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有访问者变体，可扩展性的权衡是需要弱化封装，并且经常授予外部访问者类访问应该为私有数据成员的权限。
- en: The Visitor pattern is often combined with other design patterns, in particular,
    the Composition pattern, to create complex visitable objects. The composite object
    delegates the visitation to its contained objects. This combined pattern is particularly
    useful when an object must be decomposed into its smallest building blocks; for
    example, for serialization.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式通常与其他设计模式结合使用，特别是组合模式，以创建复杂的可访问对象。组合对象将访问委托给其包含的对象。这种组合模式特别有用，当对象必须分解为其最小的构建块时；例如，用于序列化。
- en: The classic Visitor pattern implements the double dispatch at run-time - during
    execution, the program selects which code to run based on two factors, the types
    of the visitor and the visitable objects. The pattern can be similarly used at
    compile time, where it provides a limited reflection capability.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的访问者模式在运行时实现双重分派 - 在执行过程中，程序根据两个因素选择要运行的代码，即访问者和可访问对象类型。该模式也可以在编译时类似地使用，它提供有限的反射能力。
- en: In C++17, `std::visit` can be used to extend the Visitor pattern to types not
    bound into a common hierarchy, and even to implement multiple dispatch.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，可以使用`std::visit`将访问者模式扩展到未绑定到公共层次结构中的类型，甚至实现多重分派。
- en: This chapter on the Visitor pattern used to conclude this book dedicated to
    C++ idioms and design patterns. But, like new stars, the birth of new patterns
    never stops – new frontiers and new ideas bring with them new challenges to be
    solved and new solutions to be invented, and they evolve and develop until the
    programming community collectively arrives at something we can point to and say,
    with confidence, *this is usually a good way to handle that problem*. We will
    elaborate on the strengths of each new approach, consider its drawbacks, and give
    it a name so we can concisely refer to the entire set of knowledge about the problem,
    its solutions, and its caveats. With that, a new pattern enters our design toolset
    and our programming vocabulary. To illustrate this process, in the next and final
    chapter, we have collected some of the patterns that emerged to address problems
    specific to concurrent programs.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 本章关于访问者模式，原本是这本书的结尾，这本书致力于C++惯用和设计模式。但是，就像新星一样，新模式的诞生永远不会停止 - 新的前沿和新思想带来了新的挑战要解决，新的解决方案要发明，它们会不断发展和演变，直到编程社区集体达成共识，我们可以自信地说，*这通常是处理那个问题的好方法*。我们将详细阐述每种新方法的优点，考虑其缺点，并给它起一个名字，这样我们就可以简洁地引用关于该问题、其解决方案及其注意事项的全部知识。有了这个，一个新的模式就进入了我们的设计工具集和编程词汇。为了说明这个过程，在下一章和最后一章中，我们收集了一些出现以解决特定于并发程序的问题的模式。
- en: Questions
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the Visitor pattern?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问者模式是什么？
- en: What problem does the Visitor pattern solve?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问者模式解决了什么问题？
- en: What is double dispatch?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双重分派是什么？
- en: What are the advantages of the Acyclic Visitor pattern?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无环访问者模式的优势是什么？
- en: How does the Visitor pattern help implement serialization?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问者模式如何帮助实现序列化？
