- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Visitor Pattern and Multiple Dispatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Visitor pattern is another classic object-oriented design pattern, one of
    the 23 patterns introduced in the book *Design Patterns – Elements of Reusable
    Object-Oriented Software*, by Erich Gamma, Richard Helm, Ralph Johnson, and John
    Vlissides. It was one of the more popular patterns during the golden age of object-oriented
    programming since it can be used to make large class hierarchies more maintainable.
    In recent years, the use of Visitor in C++ declined, as large complex hierarchies
    became less common, and the Visitor pattern is a fairly complex pattern to implement.
    Generic programming - in particular, the language features added in C++11 and
    C++14 - makes it easier to implement and maintain the Visitor classes, while the
    new applications of the old pattern have served to rekindle some of the fading
    interest in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The Visitor pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementations of Visitor in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of generic programming to simplify the Visitor classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of Visitor for composite objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile-time Visitor and reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs: []
  type: TYPE_NORMAL
- en: 'The example code for this chapter can be found at the following GitHub link:
    [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter17](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter17).'
  prefs: []
  type: TYPE_NORMAL
- en: The Visitor pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Visitor pattern stands out from the other classic object-oriented patterns
    due to its complexity. On the one hand, the basic structure of the Visitor pattern
    is quite complex and involves many coordinated classes that must work together
    to form the pattern. On the other hand, even the description of the Visitor pattern
    is complex - there are several very different ways to describe the same pattern.
    Many patterns can be applied to multiple kinds of problems, but the Visitor pattern
    goes beyond that - there are several ways to describe what it does that use completely
    different languages, talk about seemingly unrelated problems, and overall have
    nothing in common. However, they all describe the same pattern. Let’s start by
    examining the many faces of the Visitor pattern, and then move on to the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Visitor pattern?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Visitor pattern is a pattern that separates the algorithm from the object
    structure, which is the data for this algorithm. Using the Visitor pattern, we
    can add a new operation to the class hierarchy without modifying the classes themselves.
    The use of the Visitor pattern follows the **open/closed principle** of software
    design - a class (or another unit of code, such as a module) should be closed
    for modifications; once the class presents an interface to its clients, the clients
    come to depend on this interface and the functionality it provides. This interface
    should remain stable; it should not be necessary to modify the classes in order
    to maintain the software and continue its development. At the same time, a class
    should be open for extensions - new functionality can be added to satisfy new
    requirements. As with all very general principles, a counter-example can be found
    where the rigorous application of a rule is worse than breaking it. Again, as
    with all general principles, its value lies not in being an absolute rule for
    every case, but rather a *default* rule, a guideline that should be followed in
    the absence of a good reason not to; the reality is that the majority of everyday
    work is *not special* and the result is better if this principle is followed.
  prefs: []
  type: TYPE_NORMAL
- en: When viewed this way, the Visitor pattern allows us to add functionality to
    a class or an entire class hierarchy without having to modify the class. This
    feature can be particularly useful when dealing with public APIs - the users of
    the API can extend it with additional operations without having to modify the
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very different, more technical way to describe the Visitor pattern is to
    say that it implements **double dispatch**. This requires some explanation. Let’s
    start with the regular virtual function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we invoke the `b->f()` virtual function through a pointer to the `b` base
    class, the call is dispatched to `Derived1::f()` or `Derived2::f()`, depending
    on the real type of the object. This is the **single dispatch** - the function
    that is actually called is determined by a single factor, the type of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s assume that the function `f()` also takes an argument that is a
    pointer to a base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The actual type of the `*p` object is also one of the derived classes. Now,
    the `b->f(p)` call can have four different versions; both the `*b` and `*p` objects
    can be of either of the two derived types. It is reasonable to want the implementation
    to do something different in each of these cases. This would be double dispatch
    - the code that ultimately runs is determined by two separate factors. Virtual
    functions do not provide a way to implement double dispatch directly, but the
    Visitor pattern does exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: When presented this way, it is not obvious that the **double-dispatch** Visitor
    pattern has anything to do with the **operation-adding** Visitor pattern. However,
    they are exactly the same pattern, and the two requirements are really one and
    the same. Here is a way to look at it that might help - if we want to add an operation
    to all classes in a hierarchy, that is equivalent to adding a virtual function,
    so we have one factor controlling the final disposition of each call, the object
    type. But, if we can effectively add virtual functions, we can add more than one
    - one for each operation we need to support. The type of operation is the second
    factor controlling the dispatch, similar to the argument to the function in our
    previous example. Thus, the operation-adding visitor is able to provide double
    dispatch. Alternatively, if we had a way to implement double dispatch, we could
    do what the Visitor pattern does - effectively add a virtual function for each
    operation we want to support.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what the Visitor pattern does, it is reasonable to ask, *why*
    would we want to do it? *What* is the use of double dispatch? And why would we
    want *another way* to add a virtual function substitute to a class when we can
    just add a *genuine* virtual function? Setting aside the case of the public API
    with unavailable source code, why would we want to add an operation *externally*
    instead of implementing it in every class? Consider the example of the serialization/deserialization
    problem. Serialization is an operation that converts an object into a format that
    can be stored or transmitted (for example, written into a file). Deserialization
    is the inverse operation - it constructs a new object from its serialized and
    stored image. To support serialization and deserialization in a straightforward,
    object-oriented way, each class in the hierarchy would need two methods, one for
    each operation. But what if there is more than one way to store an object? For
    example, we may need to write an object into a memory buffer, to be transmitted
    across the network and deserialized on another machine. Alternatively, we may
    need to save the object to disk, or else we may need to convert all objects in
    a container to a markup format such as JSON. The straightforward approach would
    have us add a serialization and a deserialization method to every object for every
    serialization mechanism. If a new and different serialization approach is needed,
    we have to go over the entire class hierarchy and add support for it.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to implement the entire serialization/deserialization operation
    in a separate function that can handle all classes. The resulting code is a loop
    that iterates over all objects, with a large decision tree inside of it. The code
    must interrogate every object and determine its type, for example, using dynamic
    casts. When a new class is added to the hierarchy, all serialization and deserialization
    implementations must be updated to handle the new objects.
  prefs: []
  type: TYPE_NORMAL
- en: Both implementations are difficult to maintain for large hierarchies. The Visitor
    pattern offers a solution - it allows us to implement a new operation - in our
    case, the serialization - outside of the classes and without modifying them, but
    also without the downside of a huge decision tree in a loop (note that the Visitor
    pattern is not the only solution to the serialization problem; C++ offers other
    possible approaches as well, but we focus on the Visitor pattern in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: As we stated at the beginning, the Visitor pattern is a complex pattern with
    a complex description. We can best handle this difficult pattern by studying concrete
    examples, starting from the very simple ones in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Visitor in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only way to really understand how the Visitor pattern operates is to work
    through an example. Let’s start with a very simple one. First, we need a class
    hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this hierarchy, we have the `Pet` base class and several derived classes
    for different pet animals. Now we want to add some operations to our classes,
    such as “feed the pet” or “play with the pet.” The implementation depends on the
    type of pet, so these would have to be virtual functions if added directly to
    each class. This is not a problem for such a simple class hierarchy, but we are
    anticipating the future need for maintaining a much larger system in which modifying
    every class in the hierarchy is going to be expensive and time-consuming. We need
    a better way, and we begin by creating a new class, `PetVisitor`, which will be
    applied to every `Pet` object (visit it) and perform the operations we need. First,
    we need to declare the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We had to forward-declare the `Pet` hierarchy classes because `PetVisitor`
    has to be declared before the concrete `Pet` classes. Now we need to make the
    `Pet` hierarchy visitable, which means we do need to modify it, but only once,
    regardless of how many operations we want to add later. We need to add a virtual
    function to accept the Visitor pattern to every class that can be visited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our `Pet` hierarchy is visitable, and we have an abstract `PetVisitor`
    class. Everything is ready to implement new operations for our classes (note that
    nothing we have done so far depends on what operations we are going to add; we
    have created the visiting infrastructure that has to be implemented once). The
    operations are added by implementing concrete Visitor classes derived from `PetVisitor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming the visitation infrastructure is already built into our class hierarchy,
    we can implement a new operation by implementing a derived Visitor class, and
    all its virtual functions overrides for `visit()`. To invoke one of the new operations
    on an object from our class hierarchy, we need to create a visitor and visit the
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The latest example of the call is too simple in one important way - at the
    point of calling the visitor, we know the exact type of the object we are visiting.
    To make the example more realistic, we have to visit an object polymorphically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we do not know at compile time the actual type of the object pointed to
    by `p`; at the point where the visitor is accepted, `p` could have come from different
    sources. While less common, the visitor can also be used polymorphically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When written this way, the code highlights the double-dispatch aspect of the
    Visitor pattern - the call to `accept()` ends up dispatched to a particular `visit()`
    function based on two factors - the type of the visitable `*p` object and the
    type of the `*v` visitor. If we wish to stress this aspect of the Visitor pattern,
    we can invoke the visitors using a helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We now have the most bare-bones example of the classic object-oriented visitor
    in C++. Despite its simplicity, it has all the necessary components; an implementation
    for a large real-life class hierarchy and multiple visitor operations has a lot
    more code, but no new kinds of code, just more of the things we have already done.
    This example shows both aspects of the Visitor pattern; on the one hand, if we
    focus on the functionality of the software, with the visitation infrastructure
    now in place, we can add new operations without any changes to the classes themselves.
    On the other hand, if we look just at the way the operation is invoked, the `accept()`
    call, we have implemented double dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: We can immediately see the appeal of the Visitor pattern, we can add any number
    of new operations without having to modify every class in the hierarchy. If a
    new class is added to the `Pet` hierarchy, it is impossible to forget to handle
    it - if we do nothing at all to the visitor, the `accept()` call on the new class
    will not compile since there is no corresponding `visit()` function to call. Once
    we add the new `visit()` overload to the `PetVisitor` base class, we have to add
    it to all derived classes as well; otherwise, the compiler will let us know that
    we have a pure virtual function without an override. The latter is also one of
    the main disadvantages of the Visitor pattern - if a new class is added to the
    hierarchy, all visitors must be updated, whether the new classes actually need
    to support these operations or not. For this reason, it is sometimes recommended
    to use the visitor only on *relatively stable* hierarchies that do not have new
    classes added often. There is also an alternative visitor implementation that
    somewhat mitigates this problem; we will see it later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The example in this section is very simple - our new operations take no arguments
    and return no results. We will now consider whether these limitations are significant,
    and how they can be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Visitor generalizations and limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our very first visitor, in the previous section, allowed us to effectively
    add a virtual function to every class in the hierarchy. That virtual function
    had no parameters and no return value. The former is easy to extend; there is
    no reason at all why our `visit()` functions cannot have parameters. Let’s expand
    our class hierarchy by allowing our pets to have kittens and puppies. This extension
    cannot be done using only the Visitor pattern - we need to add not only new operations
    but also new data members. The Visitor pattern can be used for the former, but
    the latter requires code changes. A policy-based design could have let us factor
    out this change into a new implementation of an existing policy if we had the
    foresight to provide the appropriate policy. We do have a separate chapter on
    [*Chapter 15*](B19262_15.xhtml#_idTextAnchor689), *Policy-Based Design* in this
    book, so here we will avoid mixing several patterns together and just add the
    new data members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Each parent `Pet` object tracks its child objects (note that the container
    is a vector of pointers, not a vector of unique pointers, so the object does not
    own its children, but merely has access to them). We have also added the new `add_child()`
    member function to add objects to the vector. We could have done this with a visitor,
    but this function is non-virtual, so we have to add it only once to the base class,
    not to every derived class - the visitor is unnecessary here. The `accept()` function
    has been modified to have an additional parameter that would have to be added
    to all derived classes as well, where it is simply forwarded to the `visit()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `visit()` function also has to be modified to accept the additional argument,
    even for the visitors that do not need it. Changing the parameters of the `accept()`
    function is, therefore, an expensive global operation that should not be done
    often, if at all. Note that all overrides for the same virtual function in the
    hierarchy already have to have the same parameters. The Visitor pattern extends
    this restriction to all operations added using the same base Visitor object. A
    common workaround for this problem is to pass parameters using aggregates (classes
    or structures that combine multiple parameters together). The `visit()` function
    is declared to accept a pointer to the base aggregate class, while each visitor
    receives a pointer to a derived class that may have additional fields, and uses
    them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our additional argument is forwarded through the chain of virtual function
    calls to the visitor, where we can make use of it. Let’s create a visitor that
    records the pet births and adds new pet objects as children to their parent objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if we want to make sure that there are no biological impossibilities
    in our family tree, the verification has to be done at run time - at compile time,
    we do not know the actual types of the polymorphic objects. The new visitor is
    just as easy to use as the ones from the last section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have established the parenthood relationships, we may want to examine
    our pet families. That is another operation we want to add, which calls for another
    Visitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have hit a slight problem, though, because as written, the code will not
    compile. The reason is that the `FamilyTreeVisitor` class is trying to access
    the `Pet::children_` data member, which is private. This is another weakness of
    the Visitor pattern - from our point of view, the visitors add new operations
    to the classes, just like virtual functions, but from the compiler’s point of
    view, they are completely separate classes, not at all like member functions of
    the `Pet` classes and have no special access. Application of the Visitor pattern
    usually requires that the encapsulation is relaxed in one of two ways - we can
    either allow public access to the data (directly or through accessor member functions)
    or declare the Visitor classes to be friends (which does require changes to the
    source code). In our example, we will follow the second route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the family tree visitor works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Unlike `BirthVisitor`, `FamilyTreeVisitor` does not need the additional argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have visitors that implement operations with parameters. What about
    the return values? Technically, there is no requirement for the `visit()` and
    `accept()` functions to return `void`. They can return anything else. However,
    the limitation that they have to all return the same type usually makes this capability
    useless. Virtual functions can have covariant return types, where the base class
    virtual function returns an object of some class and the derived class overrides
    return objects derived from that class, but even that is usually too limiting.
    There is another, much simpler solution - the `visit()` functions of every Visitor
    object have full access to the data members of that object. There is no reason
    why we cannot store the return value in the Visitor class itself and access it
    later. This fits well with the most common use where each visitor adds a different
    operation and is likely to have a unique return type, but the operation itself
    usually has the same return type for all classes in the hierarchy. For example,
    we can make our `FamilyTreeVisitor` count the total number of children and return
    the value through the Visitor object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This approach imposes some limitations in multithreaded programs - the visitor
    is now not thread-safe since multiple threads cannot use the same Visitor object
    to visit different pet objects. The most common solution is to use one Visitor
    object per thread, usually a local variable created on the stack of the function
    that calls the visitor. If this is not possible, more complex options are available
    to give the visitor a per-thread (thread-local) state, but the analysis of such
    options lies outside of the scope of this book. On the other hand, sometimes we
    want to accumulate results over multiple visitations, in which case the previous
    technique of storing the result in the Visitor object works perfectly. Also note
    that the same solution can be used to pass arguments into the Visitor operations,
    instead of adding them to the `visit()` functions; we can store the arguments
    inside the Visitor object itself, and then we don’t need anything special to access
    them from the visitor. This technique works particularly well when the arguments
    don’t change on every invocation of the visitor, but may vary from one Visitor
    object to another.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return for a moment and examine the `FamilyTreeVisitor` implementation
    again. Note that it iterates over the child objects of the parent object and calls
    the same operation on each one, in turn. It does not, however, process the children
    of the child object - our family tree is only one-generation deep. The problem
    of visiting objects that contain other objects is very general and occurs rather
    often. Our motivational example from the very beginning of this chapter, the problem
    of serialization, demonstrates this need perfectly - every complex object is serialized
    by serializing its components, one by one, and they, in turn, are serialized the
    same way, until we get all the way down to the built-in types such as `int` and
    `double`, which we know how to read and write. The next section deals with visiting
    complex objects in a more comprehensive way than what we have done so far.
  prefs: []
  type: TYPE_NORMAL
- en: Visiting complex objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we saw how the Visitor pattern allows us to add new operations
    to the existing hierarchy. In one of the examples, we visited a complex object
    that contained pointers to other objects. The visitor iterated over these pointers,
    in a limited way. We are now going to consider the general problem of visiting
    objects that are composed of other objects, or objects that contain other objects
    and build up to the demonstration of a working serialization/deserialization solution
    at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Visiting composite objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The general idea of visiting complex objects is quite straightforward - when
    visiting the object itself, we generally do not know all the details of how to
    handle each component or contained object. But there is something else that does
    - the visitor for that object type is written specifically to handle that class
    and nothing else. This observation suggests that the correct way to handle the
    component objects is to simply visit each one, and thus delegate the problem to
    someone else (a generally powerful technique, in programming and otherwise).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first demonstrate this idea on the example of a simple container class,
    such as the `Shelter` class, which can contain any number of pet objects representing
    the pets waiting for adoption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This class is essentially an adapter to make a vector of pet objects visitable
    (we have discussed the Adapter pattern in detail in the eponymous chapter). Note
    that the objects of this class do own the pet objects they contain - when the
    `Shelter` object is destroyed, so are all the `Pet` objects in the vector. Any
    container of unique pointers is a container that owns its contained objects; this
    is how polymorphic objects should be stored in a container such as `std::vector`
    (For non-polymorphic objects we can store objects themselves, but that won’t work
    in our case, objects derived from `Pet` are of different types.)
  prefs: []
  type: TYPE_NORMAL
- en: The code relevant to our current problem is, of course, `Shelter::accept()`,
    which determines how a `Shelter` object is visited. As you can see, we do not
    invoke the Visitor on the `Shelter` object itself. Instead, we delegate the visitation
    to each of the containing objects. Since our Visitors are already written to handle
    Pet objects, nothing more needs to be done. When `Shelter` is visited by, say,
    `FeedingVisitor`, every pet in the shelter gets fed, and we didn’t have to write
    any special code to make it happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visitation of composite objects is done in a similar manner - if an object
    is composed of several smaller objects, we have to visit each of these objects.
    Let’s consider an object representing a family with two family pets, a dog and
    a cat (the humans who serve the pets are not included in the following code, but
    we assume they are there too):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Again, visiting the family with a visitor from the `PetVisitor` hierarchy is
    delegated so that each `Pet` object is visited, and the visitors already have
    everything they need to handle these objects (of course, a `Family` object could
    accept visitors of other types as well, we would have to write separate `accept()`
    methods for them).
  prefs: []
  type: TYPE_NORMAL
- en: Now, at last, we have all the pieces we need to tackle the problem of serialization
    and deserialization of arbitrary objects. The next subsection shows how this can
    be done using the Visitor pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Serialization and deserialization with Visitor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem itself was described in detail in the previous section - for serialization,
    each object needs to be converted to a sequence of bits, and these bits need to
    be stored, copied, or sent. The first part of the action depends on the object
    (each object is converted differently) but the second part depends on the specific
    application of the serialization (saving to disk is different from sending across
    the network). The implementation depends on two factors, hence the need for double
    dispatch, which is exactly what the Visitor pattern provides. Furthermore, if
    we have a way to serialize some object and then deserialize it (reconstruct the
    object from the sequence of bits), we should use the same method when this object
    is included in another object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate serialization/deserialization of a class hierarchy using the
    Visitor pattern, we need a more complex hierarchy than the toy examples we have
    used so far. Let’s consider this hierarchy of two-dimensional geometric objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: All objects are derived from the abstract `Geometry` base class, but the more
    complex object contains one or more of the simpler objects; for example, `Line`
    is defined by two `Point` objects. Note that, at the end of the day, all our objects
    are made of `double` numbers, and, therefore, will serialize into a sequence of
    numbers. The key is knowing which `double` represents which field of which object;
    we need this to restore the original objects correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To serialize these objects using the Visitor pattern, we follow the same process
    we used in the last section. First, we need to declare the base Visitor class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There is one additional detail here - we can also visit double values; each
    visitor would need to handle them appropriately (write them, read them, and so
    on). Visiting any geometry object will result, eventually, in visiting the numbers
    it is composed of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our base `Geometry` class and all the classes derived from it need to accept
    this visitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There is, of course, no way to add an `accept()` member function to double,
    but we won’t have to. The `accept()` member functions for the derived classes,
    each of which is composed of one or more numbers and other classes, visit every
    data member in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The concrete Visitor classes, all derived from the base `Visitor` class, are
    responsible for the specific mechanisms of serialization and deserialization.
    The order in which the objects are broken down into their parts, all the way down
    to the numbers, is controlled by each object, but the visitors determine what
    is done with these numbers. For example, we can serialize all objects into a string
    using the formatted I/O (similar to what we get if we print the numbers into `cout`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The string is accumulated in `stringstream` until all the necessary objects
    are serialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the objects printed into the `s` string, we can restore them
    from this string, perhaps on a different machine (if we arranged for the string
    to be sent there). First, we need the deserializing Visitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This Visitor reads the numbers from the string and saves them in the variables
    given to it by the object that is visited. The key to successful deserialization
    is to read the numbers in the same order as they were saved - for example, if
    we started by writing *X* and *Y* coordinates of a point, we should construct
    a point from the first two numbers we read and use them as *X* and *Y* coordinates.
    If the first point we wrote was the endpoint of a line, we should use the point
    we constructed as the endpoint of the new line. The beauty of the Visitor pattern
    is that the functions that do the actual reading and writing don’t need to do
    anything special to preserve this order - the order is determined by each object
    and is guaranteed to be the same for all visitors (the object makes no distinction
    between the specific visitors and doesn’t even know what kind of visitor is it).
    All we need to do is to visit the objects in the same order they were serialized
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have known which objects are serialized and in what order. Therefore,
    we can deserialize the same objects in the same order. A more general case is
    when we don’t know what objects to expect during deserialization - the objects
    are stored in a visitable container, similar to `Shelter` in the earlier example,
    which has to ensure that the objects are serialized and deserialized in the same
    order. For example, consider this class, which stores a geometry represented as
    an intersection of two other geometries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Serialization of this object is straightforward - we serialize both geometries,
    in order, by delegating the details to these objects. We cannot call `v.visit()`
    directly because we do not know the types of the `*g1_` and `*g2_` geometries,
    but we can let these objects dispatch the call as appropriate. But deserialization,
    as written, will fail - the geometry pointers are `null`, there are no objects
    allocated yet, and we do not know what type of objects should be allocated. Somehow,
    we need to encode the types of objects in the serialized stream first, then construct
    them based on these encoded types. There is another pattern that offers the standard
    solution for this problem, and that is the Factory pattern (it is quite common
    to have to use more than one design pattern when building a complex system).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways in which this can be done, but they all boil down to
    converting types to numbers and serializing those numbers. In our case, we have
    to know the complete list of geometry types when we declare the base `Visitor`
    class, so that we can also define an enumeration for all these types at the same
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not essential that `enum type_tag` be defined inside the `Geometry` class,
    or that the `make_geometry` factory constructor be a static member function of
    the `Visitor` class. They can be declared outside of any class as well, but the
    virtual `tag()` method that will return the correct tag for every derived geometry
    type needs to be declared exactly as shown. The `tag()` overrides must be defined
    in every derived `Geometry` class, for example, the `Point` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Other derived classes have to be similarly modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we need to define the factory constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This factory function constructs the right derived object depending on the
    specified type tag. All that is left is for the `Intersection` object to serialize
    and deserialize the tags of the two geometries that form the intersection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the tags are sent to the visitor. The serializing visitor should write
    the tags along with the rest of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The deserializing visitor has to read the tag (actually, it reads a `size_t`
    number and converts it to the tag):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Once the tag is restored by the deserializing visitor, the `Intersection` object
    can invoke the factory constructor to construct the right geometry object. Now
    we can deserialize this object from the stream, and our `Intersection` is restored
    as an exact copy of the one we serialized. Note that there are other ways to package
    visiting the tags and the calls to the factory constructor; the optimal solution
    depends on the roles of different objects in the system - for example, the deserializing
    visitor may construct the objects based on the tag instead of the composite object
    that owns these geometries. The sequence of events that need to take place, however,
    remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been learning about the classic object-oriented Visitor pattern.
    Before we see what the C++-specific twists on the classic pattern are, we should
    learn about another type of visitor that addresses some of the inconveniences
    in the Visitor pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Acyclic Visitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Visitor pattern, as we have seen it so far, does what we wanted it to do.
    It separates the implementation of the algorithm from the object that is the data
    for the algorithm, and it allows us to select the correct implementation based
    on two run-time factors - the specific object type and the concrete operation
    we want to perform, both of which are selected from their corresponding class
    hierarchies. There is, however, a fly in the ointment - we wanted to reduce complexity
    and simplified the code maintenance, and we did, but now we have to maintain two
    parallel class hierarchies, the visitable objects and the visitors, and the dependencies
    between the two are non-trivial. The worst part of these dependencies is that
    they form a cycle - the Visitor object depends on the types of the visitable objects
    (there is an overload of the `visit()` methods for every visitable type), and
    the base visitable type depends on the base visitor type. The first half of this
    dependency is the worst. Every time a new object is added to the hierarchy, every
    visitor must be updated. The second half does not take much work from the programmer
    as new visitors can be added at any time and without any other changes - this
    is the whole point of the Visitor pattern. But there is still the compile-time
    dependency of the base visitable class, and, perforce, all derived classes, on
    the base Visitor class. Were the Visitor class to change, every file that uses
    one of the visitable classes would need to be recompiled. The visitors are, for
    the most part, stable in their interface and implementation, except for one case
    - adding a new visitable class. Thus, the cycle in action looks like this - a
    new class is added to the hierarchy of the visitable objects. The Visitor classes
    need to be updated with the new type. Since the base Visitor class was changed,
    the base visitable class and every line of code that depends on it must be recompiled,
    including the code that does not use the new visitable class, only the old ones.
    Even using forward declarations whenever possible does not help - if a new visitable
    class is added, all the old ones must be recompiled.
  prefs: []
  type: TYPE_NORMAL
- en: The additional problem of the traditional Visitor pattern is that every possible
    combination of the object type and the visitor type must be handled. Often there
    are cases when some combinations do not make sense, and certain objects will never
    be visited by some types of visitors. But we cannot take advantage of this as
    every combination must have a defined action (the action could be very simple,
    but still, every Visitor class must have the full set of `visit()` member functions
    defined).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Acyclic Visitor pattern is a variant of the Visitor pattern that is specifically
    designed to break the dependency cycle and allow partial visitation. The base
    visitable class for the Acyclic Visitor pattern is the same as for the regular
    Visitor pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'However, that is where the similarity ends. The base Visitor class does not
    have the `visit()` overloads for every visitable. In fact, it has no `visit()`
    member function at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So, who does the visiting then? For every derived class in the original hierarchy,
    we also declare the corresponding Visitor class, and that is where the `visit()`
    function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that each visitor can visit only the class it was designed for - the `CatVisitor`
    visits only `Cat` objects, the `DogVisitor` visits only `Dog` objects, and so
    on. The magic is in the new `accept()` function - when a class is asked to accept
    a visitor, it first uses `dynamic_cast` to check whether this is the right type
    of visitor. If it is, all is well, and the visitor is accepted. If it isn’t, we
    have a problem and must handle the error (the exact mechanism of error handling
    depends on the application; for example, an exception can be thrown). The concrete
    Visitor classes, therefore, must be derived from both the common `PetVisitor`
    base class and the class-specific base class such as `CatVisitor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Each concrete visitor class is derived from the common visitor base and from
    every per-type visitor base (`CatVisitor`, `DogVisitor`, and so on) for every
    type that must be handled by this visitor. On the other hand, if this visitor
    is not designed to visit some of the classes in the hierarchy, we can simply omit
    the corresponding visitor base, and then we won’t need to implement the virtual
    function override either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The invocation of the Acyclic Visitor pattern is done in exactly the same way
    as with the regular Visitor pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If we try to visit an object that is not supported by the particular Visitor,
    the error is detected. Therefore, we have solved the problem of partial visitation.
    What about the dependency cycle? That is taken care of as well - the common `PetVisitor`
    base class does not need to list the complete hierarchy of visitable objects,
    and the concrete visitable classes depend only on their per-class visitors, but
    not on any visitors for other types. Therefore, when another visitable object
    is added to the hierarchy, the existing ones do not need to be recompiled.
  prefs: []
  type: TYPE_NORMAL
- en: The Acyclic Visitor pattern looks so good that one has to wonder, *why not use
    it all the time instead of the regular Visitor pattern?* There are a few reasons.
    First of all, the Acyclic Visitor pattern uses `dynamic_cast` to cast from one
    base class to another (sometimes called cross-cast). This operation is typically
    more expensive than the virtual function call, so the Acyclic Visitor pattern
    is slower than the alternative. Also, the Acyclic Visitor pattern requires a Visitor
    class for every visitable class, so twice as many classes, and it uses multiple
    inheritance with a lot of base classes. That second issue is not much of a problem
    for most modern compilers, but many programmers find it difficult to deal with
    multiple inheritance. Whether the first issue - the runtime cost of the dynamic
    cast - is a problem depends on the application, but it is something you need to
    be aware of. On the other hand, the Acyclic Visitor pattern really shines when
    the visitable object hierarchy changes frequently or when the cost of recompiling
    the entire code base is significant.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed one more issue with the Acyclic Visitor pattern - it has
    a lot of boilerplate code. Several lines of code have to be copied for every visitable
    class. In fact, the regular Visitor pattern suffers from the same problem in that
    implementing either kind of visitor involves a lot of repetitive typing. But C++
    has a special set of tools to replace code repetition with code reuse: that is
    exactly what generic programming is for. We shall see next how the Visitor pattern
    is adapted to modern C++.'
  prefs: []
  type: TYPE_NORMAL
- en: Visitors in modern C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have just seen, the Visitor pattern promotes the separation of concerns;
    for example, the order of serialization and the mechanism of serialization are
    made independent, and a separate class is responsible for each. The pattern also
    simplifies code maintenance by collecting all code that performs a given task
    in one place. What the Visitor pattern does not promote is code reuse with no
    duplication. But that’s the object-oriented Visitor pattern, before modern C++.
    Let’s see what we can do with the generic capabilities of C++, starting from the
    regular Visitor pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Visitor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to try to reduce the boilerplate code in the implementation of
    the Visitor pattern. Let’s start with the `accept()` member function, which must
    be copied into every visitable class; it always looks the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This function cannot be moved to the base class because we need to call the
    visitor with the actual type, not the base type - `visit()` accepts `Cat*`, `Dog*`,
    and so on, but not `Pet*`. We can get a template to generate this function for
    us if we introduce an intermediate templated base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The template is parameterized by the derived class. In this regard, it is similar
    to the `this` pointer to the correct derived class pointer. Now we just need to
    derive each pet class from the right instantiation of the template, and we get
    the `accept()` function automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'That takes care of half of the boilerplate code - the code inside the derived
    visitable objects. Now there is only the other half left: the code inside the
    Visitor classes, where we have to type the same declaration over and over again
    for every visitable class. We can’t do much about the specific visitors; after
    all, that’s where the real work is done, and, presumably, we need to do different
    things for different visitable classes (otherwise why use double dispatch at all?)'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can simplify the declaration of the base Visitor class if we introduce
    this generic Visitor template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have to implement this template only once: not once for each class
    hierarchy, but once forever (or at least until we need to change the signature
    of the `visit()` function, for example, to add arguments). This is a good generic
    library class. Once we have it, declaring a visitor base for a particular class
    hierarchy becomes so trivial that it feels anticlimactic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the somewhat unusual syntax with the `class` keyword - it combines the
    template argument list with a forward declaration and is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How does the Generic Visitor base work? It uses the variadic template to capture
    an arbitrary number of type arguments, but the primary template is only declared,
    not defined. The rest are specializations. First, we have the special case of
    one type argument. We declare the pure `visit()` virtual member function for that
    type. Then we have a specialization for more than one type argument, where the
    first argument is explicit, and the rest are in the parameter pack. We generate
    the `visit()` function for the explicitly specified type and inherit the rest
    of them from an instantiation of the same variadic template but with one less
    argument. The instantiation is recursive until we are down to only one type argument,
    and then the first specialization is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'This generic and reusable code has one restriction: it does not handle deep
    hierarchies. Recall that each visitable class is derived from a common base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to derive another class from `Cat`, it would have to be derived
    from `Visitable` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We cannot just derive `SiameseCat` from `Cat` because it is the Visitable template
    that provides the `accept()` method for each derived class. But we can’t use the
    double inheritance as we just tried either, because now, the `SiameseCat` class
    inherits from Pet twice: once through the `Cat` base and once through the `Visitable`
    base. The only solution to this, if you still want to use the templates to generate
    `accept()` methods, is to separate the hierarchy so each visitable class such
    as `Cat` inherits from `Visitable` and from a corresponding base class `CatBase`
    that has all the “cat-specific” functionality except for the visitation support.
    This doubles the number of classes in the hierarchy and is a major drawback.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the boilerplate visitor code generated by templates, we can
    also make it simpler to define concrete visitors.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Visitor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the work in defining a concrete visitor is writing code for the actual
    work that has to happen for every visitable object. There is not a lot of boilerplate
    code in a specific visitor class. But sometimes we may not want to declare the
    class itself. Think about lambda expressions - anything that can be done with
    a lambda expression can also be done with an explicitly declared callable class
    because lambdas are (anonymous) callable classes. Nonetheless, we find lambda
    expressions very useful for writing one-off callable objects. Similarly, we may
    want to write a visitor without explicitly naming it - a lambda Visitor. We would
    want it to look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: There are two problems to be solved - how to create a class that handles a list
    of types and corresponding objects (in our case, the visitable types and the corresponding
    lambdas), and how to generate a set of overloaded functions using lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The former problem will require us to recursively instantiate a template on
    the parameter pack, peeling off one argument at a time. The solution to the latter
    problem is similar to the overload set of the lambda expression, which was described
    in the chapter on class templates. We could use the overload set from that chapter,
    but we can use the recursive template instantiation that we need anyway, to build
    the overloaded set of functions directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is going to be one new challenge in this implementation - we have to
    process not one but two lists of types. The first list has all visitable types
    in it; in our case, `Cat` and `Dog`. The second list has the types of lambda expressions,
    one for each visitable type. We have not seen a variadic template with two parameter
    packs yet, and for a good reason - it is not possible to simply declare `template<typename...
    A, typename... B>` as the compiler would not know where the first list ends and
    the second begins. The trick is to hide one or both lists of types inside other
    templates. In our case, we already have the `Visitor` template that is instantiated
    on the list of visitable types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extract this list from the `Visitor` template and match each type with
    its lambda expression. The partial specialization syntax used to process two parameter
    packs in sync is tricky, so we will work through it in steps. First of all, we
    need to declare the general template for our `LambdaVisitor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is only one general parameter pack here, plus the base class
    for the visitor (in our case, it will be `PetVisitor`). This template must be
    declared, but it is never going to be used - we will provide a specialization
    for every case that needs to be handled. The first specialization is used when
    there is only one visitable type and one corresponding lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This specialization, in addition to handling the case where we have only one
    visitable type, is used as the last instantiation in every chain of recursive
    template instantiations. Since it is always the first base class in the recursive
    hierarchy of `LambdaVisitor` instantiations, it is the only one that directly
    inherits from the base Visitor class such as `PetVisitor`. Note that, even with
    a single `T1` visitable type, we use the `Visitor` template as a wrapper for it.
    This is done in preparation for the general case where we will have a list of
    types whose length is unknown. The two constructors store the `f1` lambda expression
    inside the `LambdaVisitor` class, using move instead of copy if possible. Finally,
    the `visit(T1*)` virtual function override simply forwards the call to the lambda
    expression. It may appear simpler, at first glance, to inherit publicly from `F1`
    and just agree to use the functional calling syntax (in other words, to rename
    all calls to `visit()` to calls to `operator()` everywhere). This is not going
    to work; we need the indirection because the `operator()` instance of the lambda
    expression itself cannot be a virtual function override. By the way, the `override`
    keyword here is invaluable in detecting bugs in code where the template is not
    inherited from the right base class or the virtual function declarations do not
    match exactly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general case of any number of visitable types and lambda expressions is
    handled by this partial specialization, which explicitly deals with the first
    types in both lists, then recursively instantiates itself to process the rest
    of the lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Again, we have two constructors that store the first lambda expression in the
    class and forward the rest to the next instantiation. One virtual function override
    is generated on each step of the recursion, always for the first type in the remaining
    list of the visitable classes. That type is then removed from the list, and the
    processing continues in the same manner until we reach the last instantiation,
    the one for a single visitable type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it is not possible to explicitly name the types of lambda expressions,
    we also cannot explicitly declare the type of the lambda visitor. Instead, the
    lambda expression types must be deduced by the template argument deduction, so
    we need a `lambda_visitor()` template function that accepts multiple lambda expression
    arguments and constructs the `LambdaVisitor` object from all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++17, the same can be accomplished with a deduction guide. Now that we
    have a class that stores any number of lambda expressions and binds each one to
    the corresponding `visit()` override, we can write lambda visitors just as easily
    as we write lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note that, because of the way we declare the `visit()` function in the same
    class that inherits from the corresponding lambda expression, the order of the
    lambda expression in the argument list of the `lambda_visitor()` function must
    match the order of classes in the list of types in `PetVisitor` definition. This
    restriction can be removed, if desired, at the cost of some additional complexity
    of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common way of dealing with type lists in C++ is to store them in a
    `std::tuple`: for example, we can use `std::tuple<Cat, Dog>` to represent a list
    consisting of the two types. Similarly, an entire parameter pack can be stored
    in a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You can compare examples 13 and 14 to see how to use `std::tuple` to store a
    type list.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how the common fragments of the visitor code can be turned
    into reusable templates, and how this, in turn, lets us create a lambda visitor.
    But we have not forgotten the other visitor implementation we learned in this
    chapter, the Acyclic Visitor pattern. Let’s see how it, too, can benefit from
    the modern C++ language features.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Acyclic Visitor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Acyclic Visitor pattern does not need a base class with a list of all visitable
    types. However, it has its own share of boilerplate code. First of all, each visitable
    type needs the `accept()` member function, and it has more code than the similar
    function in the original Visitor pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that the error handling is uniform, this function is repeated over
    and over for different types of visitors, each corresponding to its visitable
    type (such as `CatVisitor` here). Then there is the per-type Visitor class itself,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Again, this code is pasted all over the program, with slight modifications.
    Let’s convert this error-prone code duplication into easy-to-maintain reusable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to create some infrastructure first. The Acyclic Visitor pattern
    bases its hierarchy on a common base class for all visitors, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is nothing specific to the `Pet` hierarchy here. With a better
    name, this class can serve as a base class for any visitor hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a template to generate all these Visitor base classes specific
    to visitable types, to replace the near-identical `CatVisitor`, `DogVisitor`,
    and so on. Since all that is needed from these classes is the declaration of the
    pure virtual `visit()` method, we can parameterize the template by the visitable
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The base visitable class for any class hierarchy now accepts visitors using
    the common `VisitorBase` base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of deriving each visitable class directly from `Pet` and pasting a
    copy of the `accept()` method, we introduce an intermediate template base class
    that can generate this method with the correct types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This is the only copy of the `accept()` function we need to write, and it contains
    the preferred error handling implementation for our application to deal with cases
    when the visitor is not accepted by the base class (recall that Acyclic Visitor
    allows partial visitation, where some combinations of the visitor and visitable
    are not supported). Just like for the regular Visitor, the intermediate CRTP base
    class makes it hard to use deep hierarchies with this approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concrete visitable classes inherit from the common `Pet` base class indirectly,
    through the intermediate `PetVisitable` base class, which also provides them with
    the visitable interface. The argument to the `PetVisitable` template is the derived
    class itself (again, we see the CRTP in action):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: It is, of course, not mandatory to use the same base class constructors for
    all derived classes, as custom constructors can be defined in every class as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left is to implement the Visitor class. Recall that the specific
    visitor in the Acyclic Visitor pattern inherits from the common visitor base and
    each of the visitor classes that represent the supported visitable types. That
    is not going to change, but we now have a way to generate these visitor classes
    on demand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look back at the work we have done - the parallel hierarchy of visitor
    classes no longer needs to be typed explicitly; instead, they are generated as
    needed. The repetitive `accept()` functions are reduced to the single `PetVisitable`
    class template. Still, we have to write this template for every new visitable
    class hierarchy. We can generalize this too, and create a single reusable template
    for all hierarchies, parameterized by the base visitable class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for every visitable class hierarchy, we just need to create a template
    alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make one more simplification and allow the programmer to specify the
    list of visitable classes as a list of types, instead of inheriting from `Visitor<Cat>`,
    `Visitor<Dog>`, and so on, as we have done previously. This requires a variadic
    template to store the list of types. The implementation is similar to the `LambdaVisitor`
    instance we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this wrapper template to shorten the declarations of the specific
    visitors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: If desired, we can even hide `VisitorBase` in the definition of the `Visitors`
    template for the single type argument.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen both the classic object-oriented Visitor pattern and its reusable
    implementations, made possible by the generic programming tools of C++. In the
    earlier chapters, we have seen how some patterns can be applied entirely at compile
    time. Let’s now consider whether the same can be done with the Visitor pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time Visitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will analyze the possibility of using the Visitor pattern
    at compile time, in a similar fashion to, say, the application of the Strategy
    pattern that leads to policy-based design.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, the multiple dispatch aspect of the Visitor pattern becomes trivial
    when used in the template context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'A template function can easily run a different algorithm for any combination
    of the `T1` and `T2` types. Unlike the run-time polymorphism implemented with
    virtual functions, dispatching the call differently based on two or more types
    comes at no extra cost (other than writing code for all the combinations we need
    to handle, of course). Based on this observation, we can easily mimic the classic
    Visitor pattern at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `accept()` function is now a template and a static member function - the
    actual type of the first argument, the visitable object derived from the `Pet`
    class, will be deduced at compile time. The concrete visitable classes are derived
    from the base class in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The visitors do not need to be derived from a common base since we now resolve
    the types at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The visitable classes can accept any visitor that has the correct interface,
    that is, `visit()` overloads for all classes in the hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Of course, any function that accepts the visitor arguments and needs to support
    multiple visitors would have to be made a template as well (it is no longer sufficient
    to have a common base class, which only helps to determine the actual object type
    at run time).
  prefs: []
  type: TYPE_NORMAL
- en: The compile-time visitor solves the same problem as the classic visitor, it
    allows us to effectively add new member functions to a class without editing the
    class definition. It does, however, look much less exciting than the run-time
    version.
  prefs: []
  type: TYPE_NORMAL
- en: 'More interesting possibilities arise when we combine the Visitor pattern with
    the Composition pattern. We have done this once already when we discussed the
    visitation of complex objects, especially in the context of the serialization
    problem. The reason this is particularly interesting is that it relates to the
    connection with one of the few *big-ticket* features missing in C++; namely, the
    reflection. Reflection in programming is the ability of a program to examine and
    introspect its own source and then generate new behavior based on this introspection.
    Some programming languages, such as Delphi or Python, have native reflection capability,
    but C++ does not. Reflection is useful for solving many problems: for example,
    the serialization problem could be easily solved if we could make the compiler
    iterate over all data members of the object and serialize each one, recursively,
    until we reach the built-in types. We can implement something similar using a
    compile-time Visitor pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we will consider the hierarchy of geometric objects. Since everything
    is now happening at compile time, we are not interested in the polymorphic nature
    of the classes (they could still use virtual functions if needed for runtime operations;
    we just won’t be writing them or looking at them in this section). For example,
    here is the `Point` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The visitation is provided via the `accept()` function, as before, but it is
    class-specific now. The only reason we have the first template parameter, `This`,
    is to support both const and non-const operations easily: `This` can be `Point`
    or `const Point`. Any visitor to this class is sent to visit the two values that
    define the point, `x_` and `y_`. The visitor must have the appropriate interface,
    specifically, the `visit()` member function that accepts `double` arguments. Like
    most C++ template libraries, including the `Line` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Line` class is composed of two points. At compile time, the visitor is
    directed to visit each point. That is the end of the involvement of the `Line`
    class; the `Point` class gets to determine how it is visited (as we have just
    seen, it also delegates the work to another visitor). Since we are not using runtime
    polymorphism anymore, the container classes that can hold geometries of different
    types now have to be templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have visitable types. We can use different kinds of visitors with this
    interface, not just serialization visitors. However, we are focused on serialization
    now. Previously, we have seen a visitor that converts objects into ASCII strings.
    Now let’s serialize our objects as binary data, continuous streams of bits. The
    serialization visitor has access to a buffer of a certain size and writes the
    objects into that buffer, one `double` at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The deserialization visitor reads memory from the buffer and copies it into
    the data members of the objects it restores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Both visitors process built-in types directly by copying them to and from the
    buffer while letting the more complex types decide how the objects should be processed.
    In both cases, the visitors throw an exception if the size of the buffer is exceeded.
    Now we can use our visitors to, for example, send objects through a socket to
    another machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: While we cannot implement universal reflection without language support, we
    can have classes reflect on their content in limited ways, such as this composite
    visitation pattern. There are also a few variations on the theme that we can consider.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, it is conventional to make the objects that have only one *important*
    member function callable; in other words, instead of calling the member function,
    we invoke the object itself using the function call syntax. This convention dictates
    that the `visit()` member function should be called `operator()` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The visitable classes now call the visitors like functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'It may also be convenient to implement wrapper functions to invoke visitors
    on more than one object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This is easy to implement using a variadic template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++17, we have fold expressions and do not need a recursive template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++14 we can mimic fold expressions using a hack based on `std::initializer_list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This works, but it is not going to win any prizes for clarity or maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: The compile-time visitors are, in general, easier to implement because we don’t
    have to do anything clever to get multiple dispatch, as the templates provide
    it out of the box. We just need to come up with interesting applications of the
    pattern, such as the serialization/deserialization problem we just explored.
  prefs: []
  type: TYPE_NORMAL
- en: Visitor in C++17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++17 introduced a major change in the way we use the Visitor pattern with
    the addition of `std::variant` to the standard library. The `std::variant` template
    is essentially a “smart union:” `std::variant<T1, T2, T3>` is similar to `union
    { T1 v1; T2 v2; T3 v3; }` in that both can store a value of one of the specified
    types and only one value can be stored at a time. The key difference is that a
    variant object knows which type it contains, while with a union the programmer
    is wholly responsible for reading the same type as what was written earlier. It
    is undefined behavior to access a union as a type that differs from the one used
    to initialize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, `std::variant` offers a safe way to store values of different
    types in the same memory. It is easy to check at runtime which alternative type
    is currently stored in the variant, and accessing a variant as the wrong type
    throws an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'In many ways, `std::variant` offers capabilities similar to inheritance-based
    run-time polymorphism: both let us write code where the same variable name can
    refer to objects of different types at run time. The two major differences are:
    first, a `std::variant` does not require that all its types come from the same
    hierarchy (they need not be classes at all), and second, a variant object can
    store only one of the types listed in its declaration, while a base class pointer
    can point to any derived class. In other words, adding a new type to the hierarchy
    generally does not require recompilation of the code that uses the base class,
    while adding a new type to the variant requires changing the type of the variant
    object, so all code that refers to this object must be recompiled.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will focus on the use of `std::variant` for visitation.
    This capability is provided by the aptly named function `std::visit` that takes
    a callable and a variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'To use with `std::visit`, the callable must have an `operator()` declared for
    every type that can be stored in the variant (otherwise the call will not compile).
    Of course, if the implementation is similar, we can use a template `operator()`,
    either in a function object or in a lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now reimplement our pet visitors using `std::variant` and `std::visit`.
    First of all, the `Pet` type is no longer the base class of the hierarchy but
    the variant, containing all possible type alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The types themselves do not need any visitation machinery. We may still use
    inheritance to reuse common implementation code, but there is no need for the
    types to belong to a single hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to implement some visitors. The visitors are just callable objects
    that can be invoked with every alternative type that might be stored in the variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply a visitor to a variant, we call `std::visit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The variant `p` can contain any of the types we listed when we defined the type
    `Pet` (in this example, it’s a `Cat`). We then invoke `std::visit` and the resulting
    action depends both on the visitor itself and on the type currently stored in
    the variant. The result looks a lot like a virtual function call, so we can say
    that `std::visit` allows us to add new polymorphic functions to a set of types
    (it would be misleading to call them “virtual functions” since the types do not
    have to even be classes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we see a callable object with the user-defined `operator()`, we must
    be thinking about lambdas. However, the use of lambdas with `std::visit` is not
    straightforward: we need the object to be callable with every type that can be
    stored in the variant, while a lambda has only one `operator()`. The first option
    is to make that operator a template (polymorphic lambdas) and handle all the possible
    types inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Here the lambda can be invoked with an argument of any type, and inside the
    body of the lambda, we use `if constexpr` to handle all types that can be stored
    in the variant. The disadvantage of this approach is that we no longer have compile-time
    validation that all possible types are handled by the visitor. The flip side of
    this is, however, that the code will now compile even if not all types are handled,
    and, as long as the visitor is not called with a type for which we have no action
    defined, the program will work fine. In this way, this version is similar to the
    acyclic visitor, while the previous implementation was similar to the regular
    visitor.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to implement the familiar set of overloaded `operator()`
    using lambdas and the technique for creating overload sets we have seen in [*Chapter
    1*](B19262_01.xhtml#_idTextAnchor014), *An Introduction to Inheritance and Polymorphism*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This visitor is a class that inherits from all the lambdas and exposes their
    `operator()`, thus creating a set of overloads. It is used just like the visitor
    where we explicitly wrote each `operator()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have not used the full potential of `std::visit`: it can be called
    with any number of variant arguments. This allows us to perform an action that
    depends on more than two run-time conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The visitor has to be written in a way that handles all possible combinations
    of the types that can be stored in each variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: In practice, the only way it is feasible to write a callable for all possible
    type combinations is by using a template `operator()`, which works only if the
    visitor actions can be written in a generic way. Still, the ability to do multiple
    dispatch is a potentially useful feature of `std::visit` that goes beyond the
    double dispatch capability of the regular Visitor pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the Visitor pattern and the different ways
    it can be implemented in C++. The classic object-oriented Visitor pattern allows
    us to effectively add a new virtual function to the entire class hierarchy without
    changing the source code of the classes. The hierarchy must be made visitable,
    but after that, any number of operations can be added, and their implementation
    is kept separate from the objects themselves. In the classic Visitor pattern implementation,
    the source code containing the visited hierarchy does not need to be changed,
    but it does need to be recompiled when a new class is added to the hierarchy.
    The Acyclic Visitor pattern solves this problem but at the cost of the additional
    dynamic cast. On the other hand, the Acyclic Visitor pattern also supports partial
    visitation - ignoring some visitor/visitable combinations - while the classic
    Visitor pattern requires that all combinations must at least be declared.
  prefs: []
  type: TYPE_NORMAL
- en: For all visitor variants, the tradeoff for extensibility is the need to weaken
    the encapsulation and, frequently, grant external visitor classes access to what
    should be private data members.
  prefs: []
  type: TYPE_NORMAL
- en: The Visitor pattern is often combined with other design patterns, in particular,
    the Composition pattern, to create complex visitable objects. The composite object
    delegates the visitation to its contained objects. This combined pattern is particularly
    useful when an object must be decomposed into its smallest building blocks; for
    example, for serialization.
  prefs: []
  type: TYPE_NORMAL
- en: The classic Visitor pattern implements the double dispatch at run-time - during
    execution, the program selects which code to run based on two factors, the types
    of the visitor and the visitable objects. The pattern can be similarly used at
    compile time, where it provides a limited reflection capability.
  prefs: []
  type: TYPE_NORMAL
- en: In C++17, `std::visit` can be used to extend the Visitor pattern to types not
    bound into a common hierarchy, and even to implement multiple dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter on the Visitor pattern used to conclude this book dedicated to
    C++ idioms and design patterns. But, like new stars, the birth of new patterns
    never stops – new frontiers and new ideas bring with them new challenges to be
    solved and new solutions to be invented, and they evolve and develop until the
    programming community collectively arrives at something we can point to and say,
    with confidence, *this is usually a good way to handle that problem*. We will
    elaborate on the strengths of each new approach, consider its drawbacks, and give
    it a name so we can concisely refer to the entire set of knowledge about the problem,
    its solutions, and its caveats. With that, a new pattern enters our design toolset
    and our programming vocabulary. To illustrate this process, in the next and final
    chapter, we have collected some of the patterns that emerged to address problems
    specific to concurrent programs.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the Visitor pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What problem does the Visitor pattern solve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is double dispatch?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of the Acyclic Visitor pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the Visitor pattern help implement serialization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
