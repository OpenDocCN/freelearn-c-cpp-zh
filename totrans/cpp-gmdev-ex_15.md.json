["```cpp\n struct Vertex { \n\n   glm::vec3 pos; \n   glm::vec3 normal; \n   glm::vec3 color; \nglm::vec2 texCoords; \n\n}; \n```", "```cpp\n   static VkVertexInputBindingDescription getBindingDescription() { \n\n         VkVertexInputBindingDescription bindingDescription = {}; \n\n         bindingDescription.binding = 0;  \n         bindingDescription.stride = sizeof(Vertex); \n         bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX; \n\n         return bindingDescription; \n} \n\n```", "```cpp\nstatic std::array<VkVertexInputAttributeDescription, 4> getAttributeDescriptions() { \n\n   std::array<VkVertexInputAttributeDescription, 4> \n   attributeDescriptions = {}; \n\n   attributeDescriptions[0].binding = 0; // binding index, it is 0 as \n                                            specified above \n   attributeDescriptions[0].location = 0; // location layout\n\n   // data format\n   attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT; \n   attributeDescriptions[0].offset = offsetof(Vertex, pos); // bytes             \n      since the start of the per vertex data \n\n   attributeDescriptions[1].binding = 0; \n   attributeDescriptions[1].location = 1; \n   attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT; \n   attributeDescriptions[1].offset = offsetof(Vertex, normal); \n\n   attributeDescriptions[2].binding = 0; \n   attributeDescriptions[2].location = 2; \n   attributeDescriptions[2].format = VK_FORMAT_R32G32B32_SFLOAT; \n   attributeDescriptions[2].offset = offsetof(Vertex, color); \n\n   attributeDescriptions[3].binding = 0; \n   attributeDescriptions[3].location = 3; \n   attributeDescriptions[3].format = VK_FORMAT_R32G32_SFLOAT; \n   attributeDescriptions[3].offset = offsetof(Vertex, texCoords); \n\n   return attributeDescriptions; \n}   \n```", "```cpp\nstruct UniformBufferObject { \n\n   glm::mat4 model; \n   glm::mat4 view; \n   glm::mat4 proj; \n\n}; \n```", "```cpp\n#define GLM_FORCE_RADIAN \n#define GLM_FORCE_DEPTH_ZERO_TO_ONE \n```", "```cpp\n#include <vulkan\\vulkan.h> \n#include <vector> \n\n#include \"Mesh.h\"  \n```", "```cpp\nclass ObjectBuffers \n{ \npublic: \n   ObjectBuffers(); \n   ~ObjectBuffers(); \n\n   std::vector<Vertex> vertices; \n   VkBuffer vertexBuffer; \n   VkDeviceMemory vertexBufferMemory; \n\n   std::vector<uint32_t> indices; \n   VkBuffer indexBuffer; \n   VkDeviceMemory indexBufferMemory; \n\n   VkBuffer uniformBuffers; \n   VkDeviceMemory uniformBuffersMemory; \n\n   void createVertexIndexUniformsBuffers(MeshType modelType); \n   void destroy(); \n\nprivate: \n\n   void createVertexBuffer(); \n   void createIndexBuffer(); \n   void createUniformBuffers(); \n\n}; \n\n```", "```cpp\n#include \"ObjectBuffers.h\" \n#include \"Tools.h\" \n#include \"VulkanContext.h\" \n\nObjectBuffers::ObjectBuffers(){} \n\nObjectBuffers::~ObjectBuffers(){} \n```", "```cpp\nvoid ObjectBuffers::createVertexIndexUniformsBuffers(MeshType modelType){ \n\n   switch (modelType) { \n\n         case kTriangle: Mesh::setTriData(vertices, indices); break; \n         case kQuad: Mesh::setQuadData(vertices, indices); break; \n         case kCube: Mesh::setCubeData(vertices, indices); break; \n         case kSphere: Mesh::setSphereData(vertices, indices); break; \n\n   } \n\n    createVertexBuffer(); \n    createIndexBuffer(); \n    createUniformBuffers(); \n\n}\n```", "```cpp\nnamespace vkTools { \n\n   VkImageView createImageView(VkImage image, \n         VkFormat format, \n         VkImageAspectFlags aspectFlags); \n\n   void createBuffer(VkDeviceSize size, \n         VkBufferUsageFlags usage, \n         VkMemoryPropertyFlags properties, \n         VkBuffer &buffer, \n         VkDeviceMemory& bufferMemory); \n} \n```", "```cpp\n   void createBuffer(VkDeviceSize size, \n         VkBufferUsageFlags usage, \n         VkMemoryPropertyFlags properties, \n         VkBuffer &buffer, // output \n         VkDeviceMemory& bufferMemory) { \n\n// code  \n} \n```", "```cpp\n   VkBufferCreateInfo bufferInfo = {}; \n   bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO; \n   bufferInfo.size = size; \n   bufferInfo.usage = usage; \n   bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE; \n\n   if (vkCreateBuffer(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, &bufferInfo, \n      nullptr, &buffer) != VK_SUCCESS) { \n\n         throw std::runtime_error(\" failed to create \n           vertex buffer \"); \n   }\n```", "```cpp\n   VkMemoryRequirements memrequirements; \n   vkGetBufferMemoryRequirements(VulkanContext::getInstance()->getDevice()->\n     logicalDevice, buffer, &memrequirements);  \n```", "```cpp\nuint32_t findMemoryTypeIndex(uint32_t typeFilter, VkMemoryPropertyFlags \n    properties); \n```", "```cpp\nuint32_t findMemoryTypeIndex(uint32_t typeFilter, VkMemoryPropertyFlags properties) { \n\n   //-- Properties has two arrays -- memory types and memory heaps \n   VkPhysicalDeviceMemoryProperties memProperties; \n     vkGetPhysicalDeviceMemoryProperties(VulkanContext::\n     getInstance()->getDevice()->physicalDevice, \n     &memProperties); \n\n   for (uint32_t i = 0; i < memProperties.memoryTypeCount; i++) { \n\n         if ((typeFilter & (1 << i)) &&  \n             (memProperties.memoryTypes[i].propertyFlags &                                 \n              properties) == properties) { \n\n                     return i; \n               } \n         } \n\n         throw std::runtime_error(\"failed to find \n            suitable memory type!\"); \n   } \n```", "```cpp\n   VkMemoryAllocateInfo allocInfo = {}; \n   allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO; \n   allocInfo.allocationSize = memrequirements.size; \n   allocInfo.memoryTypeIndex = findMemoryTypeIndex(memrequirements.\n                               memoryTypeBits, properties); \n\n   if (vkAllocateMemory(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, &allocInfo, nullptr, \n      &bufferMemory) != VK_SUCCESS) { \n\n         throw std::runtime_error(\"failed to allocate \n            vertex buffer memory\"); \n   } \n\n   vkBindBufferMemory(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, buffer, \n      bufferMemory, 0); \n```", "```cpp\nvoid ObjectBuffers::createVertexBuffer() { \n// code \n} \n\n```", "```cpp\nVkDeviceSize bufferSize = sizeof(vertices[0]) * vertices.size(); \n```", "```cpp\nVkBuffer stagingBuffer; \nVkDeviceMemory stagingBufferMemory; \n```", "```cpp\nvkTools::createBuffer(bufferSize, \n   VK_BUFFER_USAGE_TRANSFER_SRC_BIT,  \n   VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | \n   VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, \n   stagingBuffer, stagingBufferMemory);\n```", "```cpp\n   void* data; \n\n   vkMapMemory(VulkanContext::getInstance()->getDevice()->\n      logicalDevice, stagingBufferMemory, \n         0, // offet \n         bufferSize,// size \n         0,// flag \n         &data);  \n```", "```cpp\nmemcpy(data, vertices.data(), (size_t)bufferSize);  \n```", "```cpp\nvkUnmapMemory(VulkanContext::getInstance()->getDevice()->logicalDevice, \n   stagingBufferMemory); \n```", "```cpp\n// Create Vertex Buffer \n   vkTools::createBuffer(bufferSize, \n         VK_BUFFER_USAGE_TRANSFER_DST_BIT | \n         VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, \n         VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,  \n         vertexBuffer, \n         vertexBufferMemory);\n```", "```cpp\nVkCommandBuffer beginSingleTimeCommands(VkCommandPool commandPool); \n   void endSingleTimeCommands(VkCommandBuffer commandBuffer, \n   VkCommandPool commandPool);  \n```", "```cpp\n   VkCommandBuffer beginSingleTimeCommands(VkCommandPool commandPool) { \n\n         //-- Alloc Command buffer   \n         VkCommandBufferAllocateInfo allocInfo = {}; \n\n         allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND*BUFFER\n*                           ALLOCATE_INFO; \n         allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; \n         allocInfo.commandPool = commandPool; \n         allocInfo.commandBufferCount = 1; \n\n         VkCommandBuffer commandBuffer; \n         vkAllocateCommandBuffers(VulkanContext::getInstance()->\n           getDevice()->logicalDevice, \n           &allocInfo, &commandBuffer); \n\n         //-- Record command buffer \n\n         VkCommandBufferBeginInfo beginInfo = {}; \n         beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; \n         beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT; \n\n         //start recording \n         vkBeginCommandBuffer(commandBuffer, &beginInfo); \n\n         return commandBuffer; \n\n   } \n\n   void endSingleTimeCommands(VkCommandBuffer commandBuffer, \n      VkCommandPool commandPool) { \n\n         //-- End recording \n         vkEndCommandBuffer(commandBuffer); \n\n         //-- Execute the Command Buffer to complete the transfer \n         VkSubmitInfo submitInfo = {}; \n         submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; \n         submitInfo.commandBufferCount = 1; \n         submitInfo.pCommandBuffers = &commandBuffer; \n\n         vkQueueSubmit(VulkanContext::getInstance()->\n            getDevice()->graphicsQueue, 1, &submitInfo, \n            VK_NULL_HANDLE); \n\n         vkQueueWaitIdle(VulkanContext::getInstance()->\n            getDevice()->graphicsQueue); \n\n         vkFreeCommandBuffers(VulkanContext::getInstance()->\n            getDevice()->logicalDevice, commandPool, 1, \n            &commandBuffer); \n\n   } \n```", "```cpp\n   VkCommandBuffer beginSingleTimeCommands(VkCommandPool commandPool); \n   void endSingleTimeCommands(VkCommandBuffer commandBuffer, \n      VkCommandPool commandPool); \n\n   void copyBuffer(VkBuffer srcBuffer, \n         VkBuffer dstBuffer, \n         VkDeviceSize size);\n```", "```cpp\nvoid copyBuffer(VkBuffer srcBuffer, \n         VkBuffer dstBuffer, \n         VkDeviceSize size) { \n\nQueueFamilyIndices qFamilyIndices = VulkanContext::getInstance()->\n   getDevice()->getQueueFamiliesIndicesOfCurrentDevice(); \n\n   // Create Command Pool \n   VkCommandPool commandPool; \n\n   VkCommandPoolCreateInfo cpInfo = {}; \n\n   cpInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; \n   cpInfo.queueFamilyIndex = qFamilyIndices.graphicsFamily; \n   cpInfo.flags = 0; \n\nif (vkCreateCommandPool(VulkanContext::getInstance()->\n   getDevice()->logicalDevice, &cpInfo, nullptr, &commandPool) != \n   VK_SUCCESS) { \n         throw std::runtime_error(\" failed to create \n            command pool !!\"); \n   } \n\n   // Allocate command buffer and start recording \n   VkCommandBuffer commandBuffer = beginSingleTimeCommands(commandPool); \n\n   //-- Copy the buffer \n   VkBufferCopy copyregion = {}; \n   copyregion.srcOffset = 0; \n   copyregion.dstOffset = 0; \n   copyregion.size = size; \n   vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer,\n      1, &copyregion); \n\n   // End recording and Execute command buffer and free command buffer \n   endSingleTimeCommands(commandBuffer, commandPool); \n\n   vkDestroyCommandPool(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, commandPool, \n      nullptr); \n\n} \n\n```", "```cpp\n   vkTools::copyBuffer(stagingBuffer, \n         vertexBuffer, \n         bufferSize); \n\n   vkDestroyBuffer(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, stagingBuffer, nullptr); \n   vkFreeMemory(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, stagingBufferMemory, nullptr); \n```", "```cpp\n\nvoid ObjectBuffers::createIndexBuffer() { \n\n   VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size(); \n\n   VkBuffer stagingBuffer; \n   VkDeviceMemory stagingBufferMemory; \n\n   vkTools::createBuffer(bufferSize, \n       VK_BUFFER_USAGE_TRANSFER_SRC_BIT, \n       VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | \n       VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, \n       stagingBuffer, stagingBufferMemory); \n\n   void* data; \n   vkMapMemory(VulkanContext::getInstance()->\n     getDevice()->logicalDevice, stagingBufferMemory, \n     0, bufferSize, 0, &data); \n   memcpy(data, indices.data(), (size_t)bufferSize); \n   vkUnmapMemory(VulkanContext::getInstance()->\n     getDevice()->logicalDevice, stagingBufferMemory); \n\n   vkTools::createBuffer(bufferSize, \n        VK_BUFFER_USAGE_TRANSFER_DST_BIT |    \n        VK_BUFFER_USAGE_INDEX_BUFFER_BIT, \n        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, \n        indexBuffer,  \n        indexBufferMemory); \n\n   vkTools::copyBuffer(stagingBuffer, \n         indexBuffer, \n         bufferSize); \n\n   vkDestroyBuffer(VulkanContext::getInstance()->\n     getDevice()->logicalDevice, \n     stagingBuffer, nullptr); \n   vkFreeMemory(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, \n      stagingBufferMemory, nullptr); \n\n}    \n```", "```cpp\nvoid ObjectBuffers::createUniformBuffers() { \n\n   VkDeviceSize bufferSize = sizeof(UniformBufferObject); \n\n   vkTools::createBuffer(bufferSize, \n               VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, \n               VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | \n               VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, \n               uniformBuffers, uniformBuffersMemory); \n\n} \n```", "```cpp\nvoid ObjectBuffers::destroy(){ \n\n   vkDestroyBuffer(VulkanContext::getInstance()->\n     getDevice()->logicalDevice, uniformBuffers, nullptr); \n   vkFreeMemory(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, uniformBuffersMemory, \n      nullptr); \n\n   vkDestroyBuffer(VulkanContext::getInstance()->\n     getDevice()->logicalDevice, indexBuffer, nullptr); \n   vkFreeMemory(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, indexBufferMemory, \n      nullptr); \n\n   vkDestroyBuffer(VulkanContext::getInstance()->\n     getDevice()->logicalDevice, vertexBuffer, nullptr); \n   vkFreeMemory(VulkanContext::getInstance()->\n     getDevice()->logicalDevice, vertexBufferMemory, nullptr); \n\n} \n\n```", "```cpp\n#pragma once \n#include <vulkan\\vulkan.h> \n#include <vector> \n\nclass Descriptor \n{ \npublic: \n   Descriptor(); \n   ~Descriptor(); \n\n   // all the descriptor bindings are combined into a single layout \n\n   VkDescriptorSetLayout descriptorSetLayout;  \n   VkDescriptorPool descriptorPool; \n   VkDescriptorSet descriptorSet; \n\n   void createDescriptorLayoutSetPoolAndAllocate(uint32_t \n      _swapChainImageCount); \n   void populateDescriptorSets(uint32_t _swapChainImageCount, \n      VkBuffer uniformBuffers); \n\n   void destroy(); \n\nprivate: \n\n   void createDescriptorSetLayout(); \n   void createDescriptorPoolAndAllocateSets(uint32_t \n      _swapChainImageCount); \n\n};  \n\n```", "```cpp\n#include \"Descriptor.h\" \n\n#include<array> \n#include \"VulkanContext.h\" \n\n#include \"Mesh.h\" \n\nDescriptor::Descriptor(){ \n\n} \nDescriptor::~Descriptor(){ \n\n} \n\nvoid Descriptor::createDescriptorLayoutSetPoolAndAllocate(uint32_t \n    _swapChainImageCount){ \n\n   createDescriptorSetLayout(); \n   createDescriptorPoolAndAllocateSets(_swapChainImageCount); \n\n} \n\n```", "```cpp\nvoid Descriptor::createDescriptorSetLayout() { \n\n   VkDescriptorSetLayoutBinding uboLayoutBinding = {}; \n   uboLayoutBinding.binding = 0;// binding location \n   uboLayoutBinding.descriptorCount = 1; \n   uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;  \n   uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;  \n\n   std::array<VkDescriptorSetLayoutBinding, 1> \n      layoutBindings = { uboLayoutBinding }; \n\n   VkDescriptorSetLayoutCreateInfo layoutCreateInfo = {}; \n   layoutCreateInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR*SET\n*                            LAYOUT_CREATE_INFO; \n   layoutCreateInfo.bindingCount = static_cast<uint32_t> \n                                   (layoutBindings.size()); \n   layoutCreateInfo.pBindings = layoutBindings.data();  \n\n   if (vkCreateDescriptorSetLayout(VulkanContext::getInstance()->\n     getDevice()->logicalDevice, &layoutCreateInfo, nullptr, \n     &descriptorSetLayout) != VK_SUCCESS) { \n\n         throw std::runtime_error(\"failed to create \n           descriptor set layout\"); \n   } \n} \n```", "```cpp\nvoid Descriptor::createDescriptorPoolAndAllocateSets(uint32_t \n    _swapChainImageCount) { \n\n   // create pool \n   std::array<VkDescriptorPoolSize, 1> poolSizes = {}; \n\n   poolSizes[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER; \n   poolSizes[0].descriptorCount = _swapChainImageCount; \n\n   VkDescriptorPoolCreateInfo poolInfo = {}; \n   poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO; \n   poolInfo.poolSizeCount = static_cast<uint32_t>(poolSizes.size());  \n   poolInfo.pPoolSizes = poolSizes.data(); \n\n   poolInfo.maxSets = _swapChainImageCount;  \n\n   if (vkCreateDescriptorPool(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, &poolInfo, nullptr, \n      &descriptorPool) != VK_SUCCESS) { \n\n         throw std::runtime_error(\"failed to create descriptor pool \"); \n   } \n\n   // allocate \n   std::vector<VkDescriptorSetLayout> layouts(_swapChainImageCount, \n       descriptorSetLayout); \n\n   VkDescriptorSetAllocateInfo allocInfo = {}; \n   allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO; \n   allocInfo.descriptorPool = descriptorPool; \n   allocInfo.descriptorSetCount = _swapChainImageCount; \n   allocInfo.pSetLayouts = layouts.data(); \n\n   if (vkAllocateDescriptorSets(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, &allocInfo, &descriptorSet) \n      != VK_SUCCESS) { \n\n         throw std::runtime_error(\"failed to allocate descriptor\n            sets ! \"); \n   }  \n}\n```", "```cpp\nvoid Descriptor::populateDescriptorSets(uint32_t _swapChainImageCount, \n   VkBuffer uniformBuffers) { \n\n   for (size_t i = 0; i < _swapChainImageCount; i++) { \n\n         // Uniform buffer info \n\n         VkDescriptorBufferInfo uboBufferDescInfo = {}; \n         uboBufferDescInfo.buffer = uniformBuffers; \n         uboBufferDescInfo.offset = 0; \n         uboBufferDescInfo.range = sizeof(UniformBufferObject); \n\n         VkWriteDescriptorSet uboDescWrites; \n         uboDescWrites.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET; \n         uboDescWrites.pNext = NULL; \n         uboDescWrites.dstSet = descriptorSet; \n         uboDescWrites.dstBinding = 0; // binding index of 0  \n         uboDescWrites.dstArrayElement = 0;  \n         uboDescWrites.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER; \n         uboDescWrites.descriptorCount = 1;  \n         uboDescWrites.pBufferInfo = &uboBufferDescInfo; // uniforms \n                                                            buffers \n         uboDescWrites.pImageInfo = nullptr; \n         uboDescWrites.pTexelBufferView = nullptr; \n\n         std::array<VkWriteDescriptorSet, 1> descWrites = { uboDescWrites}; \n\n         vkUpdateDescriptorSets(VulkanContext::getInstance()->\n           getDevice()->logicalDevice, static_cast<uint32_t>\n           (descWrites.size()), descWrites.data(), 0, \n           nullptr); \n   } \n\n} \n```", "```cpp\nvoid Descriptor::destroy(){ \n\n   vkDestroyDescriptorPool(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, descriptorPool, nullptr); \n   vkDestroyDescriptorSetLayout(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, descriptorSetLayout, nullptr); \n} \n```", "```cpp\n#version 450 \n#extension GL_ARB_separate_shader_objects : enable \n\nlayout (binding = 0) uniform UniformBufferOBject{ \n\nmat4 model; \nmat4 view; \nmat4 proj; \n\n} ubo; \n\nlayout(location = 0) in vec3 inPosition; \nlayout(location = 1) in vec3 inNormal; \nlayout(location = 2) in vec3 inColor; \nlayout(location = 3) in vec2 inTexCoord; \n\nlayout(location = 0) out vec3 fragColor; \n\nvoid main() { \n\n    gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 1.0); \n    fragColor = inColor; \n\n}\n```", "```cpp\n#version 450 \n#extension GL_ARB_separate_shader_objects : enable \n\nlayout(location = 0) in vec3 fragColor; \n\nlayout(location = 0) out vec4 outColor; \n\nvoid main() { \n\n   outColor = vec4(fragColor, 1.0f); \n\n}\n```", "```cpp\nglslangValidator.exe -V basic.frag -o basic.frag.spv \n```", "```cpp\n@echo off \necho compiling glsl shaders to spirv  \nfor /r %%i in (*.vert;*.frag) do %VULKAN_SDK%\\Bin32\\glslangValidator.exe -V \"%%i\" -o  \"%%~dpiSPIRV\\%%~nxi\".spv \n```"]