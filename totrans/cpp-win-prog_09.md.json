["```cpp\nenum TokenId {Plus, Minus, Star, Slash, LeftParenthesis, \n              RightParenthesis, RefToken, Number, EndOfLine}; \n\n```", "```cpp\nclass Token { \n  public: \n    Token(TokenId tokenId); \n    Token(double value); \n    Token(Reference reference); \n\n    TokenId Id() const {return tokenId;} \n    double Value() const {return value;} \n    Reference ReferenceField() const {return reference;} \n\n  private: \n    TokenId tokenId; \n    double value; \n    Reference reference; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"Token.h\" \n\nToken::Token(TokenId tokenId) \n :tokenId(tokenId) { \n  // Empty. \n} \n\nToken::Token(double value) \n :tokenId(Number), \n  value(value) { \n  // Empty. \n} \n\nToken::Token(Reference reference) \n :tokenId(RefToken), \n  reference(reference) { \n  // Empty. \n} \n\n```", "```cpp\nenum TreeId {EmptyTree, UnaryAdd, UnarySubtract, BinaryAdd, BinarySubtract, \n             Multiply, Divide, Parenthesis, RefId, ValueId}; \n\n```", "```cpp\nclass TreeNode { \n  public: \n    TreeNode(); \n    TreeNode(TreeId id); \n    TreeNode(Reference reference); \n    TreeNode(double value); \n\n```", "```cpp\n    bool WriteTreeNodeToStream(ostream& outStream) const; \n    bool ReadTreeNodeFromStream(istream& inStream); \n    void WriteTreeNodeToClipboard(InfoList& infoList) const; \n    void ReadTreeNodeFromClipboard(InfoList& infoList); \n\n```", "```cpp\n    TreeId Id() const {return id;} \n    double Value() const {return value;} \n    Reference ReferenceField() const {return reference;} \n    Reference& ReferenceField() {return reference;} \n\n  private: \n    TreeId id; \n    Reference reference; \n    double value; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"TreeNode.h\" \n\nTreeNode::TreeNode() \n :id(EmptyTree), \n  value(0) { \n  // Empty. \n} \n\nTreeNode::TreeNode(TreeId id) \n :id(id), \n  value(0) { \n    // Empty. \n} \n\nTreeNode::TreeNode(Reference reference) \n: id(RefId), \n  value(0), \n  reference(reference) { \n  // Empty. \n} \n\nTreeNode::TreeNode(double value) \n :id(ValueId), \n  value(value) { \n  // Empty. \n} \n\n```", "```cpp\nbool TreeNode::WriteTreeNodeToStream(ostream& outStream) const { \n  outStream.write((char*) &id, sizeof id); \n  outStream.write((char*) &value, sizeof value); \n  reference.WriteReferenceToStream(outStream); \n  return ((bool) outStream); \n} \n\nbool TreeNode::ReadTreeNodeFromStream(istream& inStream) { \n  inStream.read((char*) &id, sizeof id); \n  inStream.read((char*) &value, sizeof value); \n  reference.ReadReferenceFromStream(inStream); \n  return ((bool) inStream); \n} \n\nvoid TreeNode::WriteTreeNodeToClipboard(InfoList& infoList) const  { \n  infoList.AddValue<TreeId>(id); \n  infoList.AddValue<double>(value); \n  reference.WriteReferenceToClipboard(infoList); \n} \n\nvoid TreeNode::ReadTreeNodeFromClipboard(InfoList& infoList) { \n  infoList.GetValue<TreeId>(id); \n  infoList.GetValue<double>(value); \n  reference.ReadReferenceFromClipboard(infoList); \n} \n\n```", "```cpp\nclass Scanner { \n  public: \n    Scanner(String buffer); \n    list<Token> Scan(); \n\n```", "```cpp\n    Token NextToken(); \n    bool ScanValue(double& value); \n    bool ScanReference(Reference& reference); \n\n```", "```cpp\n  private: \n    String buffer; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"Token.h\" \n#include \"Error.h\" \n#include \"Scanner.h\" \n\n```", "```cpp\nScanner::Scanner(String buffer) \n :buffer(buffer + TEXT('\\0')) { \n  // Empty. \n} \n\n```", "```cpp\nlist<Token> Scanner::Scan() { \n  list<Token> tokenList; \n\n  while (true) { \n    Token token = NextToken(); \n    tokenList.push_back(token); \n\n    if (token.Id() == EndOfLine) { \n      break; \n    } \n  } \n\n  return tokenList; \n} \n\n```", "```cpp\nToken Scanner::NextToken() { \n  while (buffer[0] == TEXT(' ')) { \n    buffer.erase(0, 1); \n  } \n\n   switch (buffer[0]) { \n    case TEXT('\\0'): \n      return Token(EndOfLine); \n\n    case TEXT('+'): \n      buffer.erase(0, 1); \n      return Token(Plus); \n\n    case TEXT('-'): \n      buffer.erase(0, 1); \n      return Token(Minus); \n\n    case TEXT('*'): \n      buffer.erase(0, 1); \n      return Token(Star); \n\n    case TEXT('/'): \n      buffer.erase(0, 1); \n      return Token(Slash); \n\n    case TEXT('('): \n      buffer.erase(0, 1); \n      return Token(LeftParenthesis); \n\n    case TEXT(')'): \n      buffer.erase(0, 1); \n      return Token(RightParenthesis); \n\n```", "```cpp\n    default: { \n      double value; \n      Reference reference; \n      if (ScanValue(value)) { \n        return Token(value); \n      } \n\n      else if (ScanReference(reference)) { \n        return Token(reference); \n      } \n      else { \n        throw Error(SyntaxError); \n      } \n    } \n    break; \n  } \n} \n\n```", "```cpp\nbool Scanner::ScanValue(double& value) { \n  int charCount; \n  int fieldCount = _stscanf_s(buffer.c_str(), TEXT(\"%lf%n\"), \n                              &value, &charCount); \n\n  if (fieldCount > 0) { \n    buffer.erase(0, charCount); \n    return true; \n  } \n\n  return false; \n} \n\n```", "```cpp\nbool Scanner::ScanReference(Reference& reference) { \n  if (isalpha(buffer[0]) && (isdigit(buffer[1]))) { \n\n```", "```cpp\n    reference.Col() = tolower(buffer[0]) - TEXT('a'); \n    buffer.erase(0, 1); \n\n```", "```cpp\n    int row; \n    int charCount; \n    _stscanf_s(buffer.c_str(), TEXT(\"%d%n\"), &row, &charCount); \n    reference.Row() = row - 1; \n    buffer.erase(0, charCount); \n    return true; \n  } \n\n  return false; \n} \n\n```", "```cpp\nTree<TreeNode>* Parser::Expression() { \n  Token token = tokenList.front(); \n\n  switch (token.Id()) { \n    case Plus: \n      Tree<TreeNode>* plusTree = Expression(); \n      // ... \n      break; \n  } \n} \n\n```", "```cpp\nclass Parser { \n  public: \n    Parser(String buffer); \n    Tree<TreeNode>* Parse(); \n    void Match(int tokenId); \n    Tree<TreeNode>* Expression(); \n    Tree<TreeNode>* NextExpression(Tree<TreeNode>* leftTermPtr); \n    Tree<TreeNode>* Term(); \n    Tree<TreeNode>* NextTerm(Tree<TreeNode>* leftFactorPtr); \n    Tree<TreeNode>* Factor(); \n\n  private: \n    list<Token> tokenList; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"Token.h\" \n#include \"Error.h\" \n#include \"Scanner.h\" \n#include \"TreeNode.h\" \n#include \"Parser.h\" \n\nParser::Parser(String buffer) { \n  Scanner scanner(buffer); \n  tokenList = scanner.Scan(); \n} \n\nTree<TreeNode>* Parser::Parse() { \n  Tree<TreeNode>* resultTreePtr = Expression(); \n  Match(EndOfLine); \n  return resultTreePtr; \n} \n\n```", "```cpp\nvoid Parser::Match(int tokenId) { \n  if (tokenList.empty() || (tokenList.front().Id() != tokenId)) { \n    throw Error(SyntaxError); \n  } \n\n  tokenList.pop_front(); \n} \n\n```", "```cpp\nTree<TreeNode>* Parser::Expression() { \n  Tree<TreeNode>* termTreePtr = Term(); \n  return NextExpression(termTreePtr); \n} \n\n```", "```cpp\nTree<TreeNode>* Parser::NextExpression(Tree<TreeNode>* \n                                       leftTermTreePtr) { \n  Token token = tokenList.front();  \n  switch (token.Id()) { \n    case Plus: { \n      Match(Plus); \n      Tree<TreeNode>* rightTermTreePtr = Term(); \n      Tree<TreeNode>* sumTreePtr = \n        new Tree<TreeNode>(TreeNode(BinaryAdd), \n                           {leftTermTreePtr, rightTermTreePtr}); \n      assert(sumTreePtr != nullptr); \n      return NextExpression(sumTreePtr); \n    } \n\n    case Minus: { \n      Match(Minus); \n      Tree<TreeNode>* rightTermTreePtr = Term(); \n         Tree<TreeNode>* diffTreePtr = \n             new Tree<TreeNode>(TreeNode(BinarySubtract),\n                                {leftTermTreePtr, rightTermTreePtr});\n      assert(diffTreePtr != nullptr); \n      return NextExpression(diffTreePtr); \n    } \n\n    default: \n      return leftTermTreePtr; \n  } \n}  \n\nTree<TreeNode>* Parser::Term() { \n  Tree<TreeNode>* pFactorTree = Factor(); \n  return NextTerm(pFactorTree); \n} \n\n```", "```cpp\nTree<TreeNode>* Parser::NextTerm(Tree<TreeNode>*leftFactorTreePtr) { \n  Token token = tokenList.front(); \n\n  switch (token.Id()) { \n    case Star: { \n      Match(Star); \n      Tree<TreeNode>* rightFactorTreePtr = Factor(); \n      Tree<TreeNode>* productTreePtr = \n        new Tree<TreeNode>(TreeNode(Multiply), \n      Tree<TreeNode>* productTreePtr = \n        new Tree<TreeNode>(TreeNode(Multiply), \n                       {leftFactorTreePtr, rightFactorTreePtr}); \n      assert(productTreePtr != nullptr); \n      return NextExpression(productTreePtr); \n    } \n\n    case Slash: { \n      Match(Slash); \n      Tree<TreeNode>* rightFactorTreePtr = Factor(); \n      Tree<TreeNode>* quotientTreePtr = \n        new Tree<TreeNode>(TreeNode(Divide), \n                       {leftFactorTreePtr, rightFactorTreePtr}); \n      assert(quotientTreePtr != nullptr); \n      return NextExpression(quotientTreePtr); \n    } \n\n    default: \n      return leftFactorTreePtr; \n  } \n} \n\n```", "```cpp\nTree<TreeNode>* Parser::Factor() { \n  Token token = tokenList.front(); \n\n  switch (token.Id()) { \n    case Plus: { \n      Match(Plus); \n      Tree<TreeNode>* nextExprTreePtr = Expression(); \n      Tree<TreeNode>* plusTreePtr = \n        new Tree<TreeNode>(TreeNode(UnaryAdd), \n                           {nextExprTreePtr}); \n      assert(plusTreePtr!= nullptr); \n      return plusTreePtr; \n    } \n\n    case Minus: { \n      Match(Minus); \n      Tree<TreeNode>* nextExprTreePtr = Expression(); \n      Tree<TreeNode>* minusTreePtr = \n        new Tree<TreeNode>(TreeNode(UnaryAdd), \n                           {nextExprTreePtr}); \n      assert(minusTreePtr!= nullptr); \n      return minusTreePtr; \n    } \n\n```", "```cpp\n    case LeftParenthesis: { \n      Match(LeftParenthesis); \n      Tree<TreeNode>* innerExprTreePtr = Expression(); \n      Match(RightParenthesis); \n      Tree<TreeNode>* resultTreePtr =  \n        new Tree<TreeNode>(TreeNode(Parenthesis), \n                           {innerExprTreePtr}); \n      assert(resultTreePtr != nullptr); \n      return resultTreePtr; \n    } \n\n```", "```cpp\n    case RefToken: { \n      Match(RefToken); \n      Tree<TreeNode>* resultTreePtr = \n        new Tree<TreeNode>(TreeNode(token.ReferenceField())); \n      assert(resultTreePtr != nullptr); \n      return resultTreePtr; \n    }  \n\n    case Number: { \n      Match(Number); \n      Tree<TreeNode>* resultTreePtr = \n        new Tree<TreeNode>(TreeNode(token.Value())); \n      assert(resultTreePtr != nullptr); \n      return resultTreePtr; \n    } \n\n```", "```cpp\n    default: \n      throw Error(SyntaxError); \n  } \n} \n\n```", "```cpp\nnamespace SmallWindows { \n  class Reference; \n  extern const Reference ZeroReference;  \n\n  class Reference { \n    public: \n\n```", "```cpp\n      Reference(); \n      Reference(int row, int col); \n      Reference(const Reference& ref); \n      Reference& operator=(const Reference& ref); \n\n```", "```cpp\n      friend bool operator==(const Reference& ref1, \n                             const Reference& ref2); \n      friend bool operator!=(const Reference& ref1, \n                             const Reference& ref2); \n      friend bool operator<(const Reference& ref1, \n                            const Reference& ref2); \n      friend bool operator<=(const Reference& ref1, \n                             const Reference& ref2); \n\n      friend bool operator>(const Reference& ref1, \n                            const Reference& ref2); \n      friend bool operator>=(const Reference& ref1, \n                             const Reference& ref2); \n\n```", "```cpp\n      Reference& operator+=(const Reference& ref); \n      Reference& operator-=(const Reference& ref); \n      friend Reference operator+(const Reference& ref1, \n                                 const Reference& ref2); \n      friend Reference operator-(const Reference& ref1, \n                                 const Reference& ref2); \n\n```", "```cpp\n      void Clear() {row = 0; col = 0;} \n      bool IsEmpty() const {return ((row == 0) && (col == 0));} \n\n```", "```cpp\n      String ToString() const; \n\n```", "```cpp\n      bool Inside(Reference minRef, Reference maxRef); \n\n```", "```cpp\n      bool WriteReferenceToStream(ostream& outStream) const; \n      bool ReadReferenceFromStream(istream& inStream); \n      void WriteReferenceToClipboard(InfoList& infoList) const; \n      void ReadReferenceFromClipboard(InfoList& infoList); \n      void WriteReferenceToRegistry(String key) const; \n      void ReadReferenceFromRegistry(String key, \n                            Reference defaultRef = ZeroReference); \n\n```", "```cpp\n      int Row() const {return row;} \n      int Col() const {return col;} \n      int& Row() {return row;} \n      int& Col() {return col;} \n\n    private: \n      int row, col; \n  }; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\"  \nnamespace SmallWindows { \n  const Reference ZeroReference(0, 0);  \n  Reference::Reference() \n   :row(0), \n    col(0) { \n    // Empty. \n  }  \n\n  Reference::Reference(int row, int col) \n   :row(row), \n    col(col) { \n    // Empty. \n  }  \n\n  Reference::Reference(const Reference& ref) \n   :row(ref.row), \n    col(ref.col) { \n    // Empty. \n  }  \n\n  Reference& Reference::operator=(const Reference& ref) { \n    if (this != &ref) { \n      row = ref.row; \n      col = ref.col; \n    } \n    return *this; \n  } \n\n  bool operator==(const Reference& ref1, const Reference& ref2) { \n    return (ref1.row == ref2.row) && (ref1.col == ref2.col); \n  } \n\n  bool operator!=(const Reference& ref1, const Reference& ref2) { \n    return !(ref1 == ref2); \n  } \n\n  bool operator<(const Reference& ref1, const Reference& ref2) { \n    return (ref1.row < ref2.row) || \n           ((ref1.row == ref2.row) && (ref1.col < ref2.col)); \n  } \n\n  bool operator<=(const Reference& ref1, const Reference& ref2) { \n    return (ref1 < ref2) || (ref1 == ref2); \n  } \n\n  bool operator>(const Reference& ref1, const Reference& ref2) { \n    return !(ref1 <= ref2); \n  } \n\n  bool operator>=(const Reference& ref1, const Reference& ref2) { \n    return !(ref1 < ref2); \n  }  \n\n  Reference& Reference::operator+=(const Reference& ref) { \n    row += ref.row; \n    col += ref.col; \n    return *this; \n  }  \n\n  Reference& Reference::operator-=(const Reference& ref) { \n    row -= ref.row; \n    col -= ref.col; \n    return *this; \n  }  \n\n  Reference operator+(const Reference& ref1, \n                      const Reference& ref2) { \n    return Reference(ref1.row + ref2.row, ref1.col + ref2.col); \n  }  \n\n  Reference operator-(const Reference& ref1, \n                      const Reference& ref2) { \n    return Reference(ref1.row - ref2.row, ref1.col - ref2.col); \n  } \n\n```", "```cpp\n  String Reference::ToString() const {\n    String result;\n\n    if (row >= 0) {\n      result.push_back((TCHAR) (col + TEXT('a')));\n    }\n    else {\n      result.push_back(TEXT('?'));\n    }\n\n    if (col >= 0) {\n      result.append(to_String(row + 1));\n    }\n    else {\n      result.push_back(TEXT('?'));\n    }\n\n    return result;\n  } \n\n  bool Reference::Inside(Reference minRef, Reference maxRef) { \n    return ((minRef.row <= row) && (row <= maxRef.row) &&\n            (minRef.col <= col) && (col <= maxRef.col));\n  } \n\n  bool Reference::WriteReferenceToStream(ostream& outStream)const { \n    outStream.write((char*) &row, sizeof row); \n    outStream.write((char*) &col, sizeof col); \n    return ((bool) outStream); \n  } \n\n  bool Reference::ReadReferenceFromStream(istream& inStream) { \n    inStream.read((char*) &row, sizeof row); \n    inStream.read((char*) &col, sizeof col); \n    return ((bool) inStream); \n  } \n\n  void Reference::WriteReferenceToClipboard(InfoList& infoList) const { \n    infoList.AddValue<int>(row); \n    infoList.AddValue<int>(col); \n  } \n\n  void Reference::ReadReferenceFromClipboard(InfoList& infoList) { \n    infoList.GetValue<int>(row); \n    infoList.GetValue<int>(col); \n  } \n\n```", "```cpp\n  struct ReferenceStruct {int row, col;}; \n\n  void Reference::WriteReferenceToRegistry(String key) const { \n    ReferenceStruct writeStruct = {row, col}; \n    Registry::WriteBuffer(key, &writeStruct, sizeof writeStruct); \n  } \n\n  void Reference::ReadReferenceFromRegistry(String key,\n                      Reference defaultRef /* = ZeroReference */){\n    ReferenceStruct readStruct; \n    ReferenceStruct defaultStruct = \n      {defaultRef.row, defaultRef.col}; \n    Registry::ReadBuffer(key, &readStruct, sizeof readStruct, \n                         &defaultStruct); \n    row = readStruct.row; \n    col = readStruct.col; \n  } \n} \n\n```", "```cpp\nnamespace SmallWindows { \n  template <int Rows, int Cols, class Type> \n\n  class Matrix { \n    public: \n\n```", "```cpp\n    public: \n      Matrix(); \n      Matrix(const Matrix& matrix); \n      Matrix& operator=(const Matrix& matrix); \n\n    private: \n      void Init(const Matrix<Rows,Cols,Type>& matrix); \n\n```", "```cpp\n    public: \n      const Type* operator[](int row) const \n                          {return ((const Type*) buffer[row]);} \n\n      Type& operator[](const Reference& ref) \n                      {return buffer[ref.Row()][ref.Col()];} \n      Type operator[](const Reference& ref) const \n                     {return buffer[ref.Row()][ref.Col()];} \n\n    private: \n      Type buffer[Rows][Cols]; \n  }; \n\n```", "```cpp\n  template <int Rows, int Cols, class Type> \n  Matrix<Rows,Cols,Type>::Matrix() { \n    // Empty. \n  } \n\n```", "```cpp\n  template <int Rows, int Cols, class Type> \n  Matrix<Rows,Cols,Type>::Matrix(const Matrix<Rows,Cols,Type>& \n                                 matrix) { \n    Init(matrix); \n  } \n\n  template<int Rows, int Cols, class Type> \n  Matrix<Rows,Cols,Type>& Matrix<Rows,Cols,Type>::operator= \n                          (const Matrix<Rows,Cols,Type>& matrix) { \n    if (this != &matrix) { \n      Init(matrix); \n    } \n\n    return *this; \n  } \n\n  template <int Rows, int Cols, class Type> \n  void Matrix<Rows,Cols,Type>::Init \n                        (const Matrix<Rows,Cols,Type>& matrix) { \n    for (int row = 0; row < Rows; ++row) { \n      for (int col = 0; col < Cols; ++col) { \n        buffer[row][col] = matrix.buffer[row][col]; \n      } \n    } \n  } \n} \n\n```", "```cpp\nextern const int HeaderWidth, HeaderHeight, \n                 ColWidth, RowHeight, CellMargin; \n\n#define Rows 10 \n#define Cols 4 \n\n```", "```cpp\nenum Alignment {Left, Center, Right, Justified, Top, Bottom};  \n\nclass Cell { \n  public: \n    Cell(); \n    ~Cell(); \n\n    Cell(const Cell& cell); \n    Cell& operator=(const Cell& cell); \n\n```", "```cpp\n    void Clear(); \n    void Reset(); \n\n```", "```cpp\n    void CharDown(int editIndex, TCHAR tChar, \n                  KeyboardMode keyboardMode); \n    int MouseToIndex(int x) const; \n\n```", "```cpp\n    vector<Rect> CaretList() const {return caretList;} \n\n    String GetText() const {return text;} \n    void SetText(String& t) {text = t;} \n\n    bool IsFormula() const {return (cellMode == FormulaMode);} \n\n```", "```cpp\n    Font CellFont() const {return font;} \n    Font& CellFont() {return font;} \n    Color BackgroundColor() const {return backgroundColor;} \n    Color& BackgroundColor() {return backgroundColor;} \n\n    Alignment HorizontalAlignment() const \n                        {return horizontalAlignignment;} \n    Alignment& HorizontalAlignment() \n                         {return horizontalAlignignment;} \n    Alignment VerticalAlignment() const \n                      {return verticalAlignignment;} \n    Alignment& VerticalAlignment() {return verticalAlignignment;} \n\n```", "```cpp\n    void DrawCell(Graphics& graphics, Reference cellRef, \n                  bool inverse) const; \n    void GenerateCaretList(Window* windowPtr); \n\n```", "```cpp\n    void DisplayFormula (); \n\n```", "```cpp\n    void InterpretCell(set<Reference>& sourceSet); \n\n```", "```cpp\n    void GenerateSourceSet(set<Reference>& sourceSet) const; \n    void GenerateSourceSet(Tree<TreeNode>* syntaxNodePtr, \n                           set<Reference>& sourceSet) const; \n\n```", "```cpp\n    String TreeToString() const; \n    String TreeToString(Tree<TreeNode>* syntaxNodePtr) const; \n\n```", "```cpp\n    void UpdateTree(Reference diffRef, set<Reference>& sourceSet); \n    void UpdateTree(Tree<TreeNode>* syntaxNodePtr, \n                    Reference diffRef, set<Reference>& sourceSet); \n\n```", "```cpp\n    bool HasValue() const; \n    double GetValue() const {return value;} \n\n```", "```cpp\n    void Evaluate(map<Reference,double>& valueMap); \n    double Evaluate(Tree<TreeNode>* syntaxNodePtr, \n                    map<Reference,double>& valueMap); \n\n```", "```cpp\n    bool WriteCellToStream(ostream& outStream) const; \n    bool ReadCellFromStream(istream& inStream); \n\n    void WriteCellToClipboard(InfoList& infoList) const; \n    void ReadCellFromClipboard(InfoList& infoList); \n\n```", "```cpp\n  private: \n    enum CellMode {TextMode, ValueMode, FormulaMode} cellMode; \n\n```", "```cpp\n    Font font; \n    Color backgroundColor; \n    Alignment horizontalAlignignment, verticalAlignignment; \n\n```", "```cpp\n    String text; \n\n```", "```cpp\n    vector<Rect> caretList; \n\n```", "```cpp\n    bool hasValue; \n    double value; \n\n```", "```cpp\n    Tree<TreeNode>* syntaxTreePtr; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"Token.h\" \n#include \"Error.h\" \n#include \"Scanner.h\" \n#include \"TreeNode.h\" \n#include \"Parser.h\" \n#include \"Cell.h\" \n\nconst int CellMargin = 100, \n          ColWidth = 4000, RowHeight = 1000, \n          HeaderWidth = 1000, HeaderHeight = 700; \n\n```", "```cpp\nconst int CellWidth = ColWidth - (2 * CellMargin), \n          CellHeight = RowHeight - (2 * CellMargin); \n\n```", "```cpp\nCell::Cell() \n :cellMode(TextMode), \n  font(SystemFont), \n  backgroundColor(White), \n  horizontalAlignignment(Center), \n  verticalAlignignment(Center), \n  hasValue(false), \n  value(0), \n  syntaxTreePtr(nullptr) { \n  // Empty. \n} \n\n```", "```cpp\nCell::Cell(const Cell& cell) \n :cellMode(cell.cellMode), \n  font(cell.font), \n  backgroundColor(cell.backgroundColor), \n  horizontalAlignignment(cell.horizontalAlignignment), \n  verticalAlignignment(cell.verticalAlignignment), \n  text(cell.text), \n  caretList(cell.caretList), \n  hasValue(cell.hasValue), \n  value(cell.value) { \n  if (cell.syntaxTreePtr != nullptr) { \n    syntaxTreePtr = new Tree<TreeNode>(*cell.syntaxTreePtr); \n    assert(syntaxTreePtr != nullptr); \n  } \n  else { \n    syntaxTreePtr = nullptr; \n  } \n} \n\n```", "```cpp\nCell& Cell::operator=(const Cell& cell) { \n  if (this != &cell) { \n    cellMode = cell.cellMode; \n    font = cell.font; \n    backgroundColor = cell.backgroundColor; \n    horizontalAlignignment = cell.horizontalAlignignment; \n    verticalAlignignment = cell.verticalAlignignment; \n    text = cell.text; \n    caretList = cell.caretList; \n    hasValue = cell.hasValue; \n    value = cell.value; \n    delete syntaxTreePtr; \n\n    if (cell.syntaxTreePtr != nullptr) { \n      syntaxTreePtr = new Tree<TreeNode>(*cell.syntaxTreePtr); \n      assert(syntaxTreePtr != nullptr); \n    } \n\n    else { \n      syntaxTreePtr = nullptr; \n    } \n  } \n\n  return *this; \n} \n\n```", "```cpp\nCell::~Cell() { \n  delete syntaxTreePtr; \n} \n\n```", "```cpp\nvoid Cell::Clear() { \n  font = SystemFont; \n  backgroundColor = White; \n  horizontalAlignignment = Center; \n  verticalAlignignment = Center; \n  Reset(); \n} \n\nvoid Cell::Reset() { \n  cellMode = TextMode; \n  text.clear(); \n  delete syntaxTreePtr; \n  syntaxTreePtr = nullptr; \n} \n\n```", "```cpp\nvoid Cell::CharDown(int editIndex, TCHAR tChar, \n                    KeyboardMode keyboardMode) { \n  if (editIndex == text.length()) { \n    text.append(1, tChar); \n  } \n  else { \n    switch (keyboardMode) { \n      case InsertKeyboard: \n        text.insert(editIndex, 1, tChar); \n        break; \n\n      case OverwriteKeyboard: \n        text[editIndex] = tChar; \n        break; \n    } \n  } \n} \n\n```", "```cpp\nint Cell::MouseToIndex(int x) const { \n  x -= CellMargin; \n\n  if (x < caretList[0].Left()) { \n    return 0; \n  } \n\n  int size = text.length(); \n  for (int index = 0; index < size; ++index) { \n    if (x < caretList[index].Right()) { \n      return index; \n    } \n  } \n\n  return size; \n} \n\n```", "```cpp\nvoid Cell::DrawCell(Graphics& graphics, Reference cellRef, \n                    bool inverse) const { \n  Point topLeft(HeaderWidth + cellRef.Col() * ColWidth, \n                HeaderHeight + cellRef.Row() * RowHeight); \n  Size cellSize(ColWidth, RowHeight); \n  Rect cellRect(topLeft, cellSize); \n\n  Color textColor = font.FontColor(), \n        backColor = backgroundColor, borderColor = Black; \n\n  if (inverse) { \n    textColor = textColor.Inverse(); \n    backColor = backColor.Inverse(); \n    borderColor = borderColor.Inverse(); \n  } \n\n  graphics.FillRectangle(cellRect, borderColor, backColor); \n  Size marginSize(CellMargin, CellMargin); \n  int size = text.length(); \n\n  for (int index = 0; index < size; ++index) { \n    TCHAR tChar = text[index]; \n    Rect caretRect = caretList[index]; \n\n    Rect charRect = (topLeft + marginSize) + caretRect; \n    TCHAR text[] = {tChar, TEXT('\\0')}; \n    graphics.DrawText(charRect, text, font, textColor, backColor); \n  } \n} \n\n```", "```cpp\nvoid Cell::GenerateCaretList(Window* windowPtr) { \n  vector<int> widthList; \n  int textWidth = 0, spaceCount = 0, noSpaceWidth = 0; \n\n  for (const TCHAR tChar : text) { \n    int charWidth = windowPtr->GetCharacterWidth(font, tChar); \n    widthList.push_back(charWidth); \n    textWidth += charWidth; \n\n    if (horizontalAlignignment == Justified) { \n      if (tChar == TEXT(' ')) { \n        ++spaceCount; \n      } \n      else { \n        noSpaceWidth += charWidth; \n      } \n    } \n  } \n\n```", "```cpp\n  int startPos = 0, spaceWidth, cellWidth = ColWidth - (2 * CellMargin); \n\n  switch (horizontalAlignignment) { \n    case Left: \n      startPos = CellMargin; \n      break; \n\n    case Justified: { \n        startPos = CellMargin; \n        if (spaceCount > 0) { \n          spaceWidth = max(0,(cellWidth-noSpaceWidth)/spaceCount); \n        } \n      } \n      break; \n\n    case Right: \n      startPos = CellMargin + max(0, cellWidth - textWidth); \n      break; \n\n    case Center: \n      startPos = CellMargin + max(0, (cellWidth - textWidth) / 2); \n      break; \n  } \n\n```", "```cpp\n  int topPos = 0, \n      textHeight = windowPtr->GetCharacterHeight(font), \n      cellHeight = RowHeight - (2 * CellMargin); \n\n  switch (verticalAlignignment) { \n    case Top: \n      topPos = CellMargin; \n      break; \n\n    case Bottom: \n      topPos = CellMargin + max(0, cellHeight - textHeight); \n      break; \n\n    case Center: \n      topPos = CellMargin + max(0, (cellHeight - textHeight) / 2); \n      break; \n  } \n\n```", "```cpp\n  caretList.clear(); \n  int size = text.size(); \n  for (int index = 0; index < size; ++index) { \n    int charWidth = widthList[index]; \n\n    if ((horizontalAlignignment == Justified) && \n        (text[index] == TEXT(' '))) { \n      charWidth = spaceWidth; \n    } \n\n    Point topLeft(startPos, topPos); \n    Size charSize(charWidth, textHeight); \n    caretList.push_back(Rect(topLeft, charSize)); \n    startPos += charWidth; \n  } \n\n```", "```cpp\n  Point topLeft(startPos, topPos); \n  int averageWidth = windowPtr->GetCharacterAverageWidth(font); \n  Size charSize(averageWidth, textHeight); \n  caretList.push_back(Rect(topLeft, charSize)); \n} \n\n```", "```cpp\nvoid Cell::DisplayFormula() { \n  switch (cellMode) { \n    case TextMode: \n    case ValueMode: \n      break; \n\n    case FormulaMode: \n      text = TEXT(\"=\") + TreeToString(syntaxTreePtr); \n      break; \n  } \n} \n\n```", "```cpp\nvoid Cell::InterpretCell(set<Reference>& sourceSet) { \n  String trimText = Trim(text); \n\n  if (IsNumeric(trimText)) { \n    cellMode = ValueMode; \n    value = stod(trimText); \n  } \n  else if (!trimText.empty() && (trimText[0] == TEXT('='))) { \n    cellMode = FormulaMode; \n    Parser parser(trimText.substr(1)); \n    syntaxTreePtr = parser.Parse(); \n    GenerateSourceSet(syntaxTreePtr, sourceSet); \n  } \n  else { \n    cellMode = TextMode; \n  } \n} \n\n```", "```cpp\nvoid Cell::GenerateSourceSet(set<Reference>& sourceSet) const{ \n  if (cellMode == FormulaMode) { \n    GenerateSourceSet(syntaxTreePtr, sourceSet); \n  } \n} \n\n```", "```cpp\nvoid Cell::GenerateSourceSet(Tree<TreeNode>* syntaxNodePtr, \n                             set<Reference>& sourceSet) const{ \n  DynamicList<Tree<TreeNode>*> childList = \n    syntaxNodePtr->ChildList();  \n  switch (syntaxNodePtr->NodeValue().Id()) { \n    case UnaryAdd: \n    case UnarySubtract: \n    case Parenthesis: \n      return GenerateSourceSet(childList[0]); \n\n```", "```cpp\n    case BinaryAdd: \n    case BinarySubtract: \n    case Multiply: \n    case Divide: { \n        set<Reference> leftSet = GenerateSourceSet(childList[0]), \n                       rightSet = GenerateSourceSet(childList[1]); \n        leftSet.insert(rightSet.begin(), rightSet.end()); \n        return leftSet; \n      } \n\n```", "```cpp\n    case RefId: { \n        set<Reference> singleSet; \n        Reference sourceRef = \n          syntaxNodePtr->NodeValue().ReferenceField(); \n\n        if ((sourceRef.Row() >= 0) && (sourceRef.Row() < Rows) && \n            (sourceRef.Col() >= 0) && (sourceRef.Col() < Cols)) { \n          singleSet.insert(sourceRef); \n        } \n\n        return singleSet; \n      } \n\n```", "```cpp\n    case ValueId: \n      return set<Reference>(); \n  } \n\n  assert(false); \n  return set<Reference>(); \n} \n\n```", "```cpp\nString Cell::TreeToString() const { \n  if (cellMode == FormulaMode) { \n    return TEXT(\"=\") + TreeToString(syntaxTreePtr); \n  } \n\n  else { \n    return text; \n  } \n} \n\n```", "```cpp\nString Cell::TreeToString(Tree<TreeNode>* syntaxNodePtr) const { \n  DynamicList<Tree<TreeNode>*> childList = \n    syntaxNodePtr->ChildList(); \n\n  switch (syntaxNodePtr->NodeValue().Id()) { \n    case UnaryAdd: \n      return TEXT(\"+\") + TreeToString(childList[0]); \n\n    case UnarySubtract: \n      return TEXT(\"-\") + TreeToString(childList[0]); \n      break; \n\n```", "```cpp\n    case BinaryAdd: \n      return TreeToString(childList[0]) + TEXT(\"+\") + \n             TreeToString(childList[1]); \n\n    case BinarySubtract: \n      return TreeToString(childList[0]) + TEXT(\"-\") + \n             TreeToString(childList[1]); \n\n    case Multiply: \n      return TreeToString(childList[0]) + TEXT(\"*\") + \n             TreeToString(childList[1]); \n\n    case Divide: \n      return TreeToString(childList[0]) + TEXT(\"/\") + \n             TreeToString(childList[1]); \n\n```", "```cpp\n    case Parenthesis: \n      return TEXT(\"(\") + TreeToString(childList[0]) + TEXT(\")\"); \n\n```", "```cpp\n    case RefId: \n      return syntaxNodePtr-> \n             NodeValue().ReferenceField().ToString(); \n\n```", "```cpp\n    case ValueId: \n      return to_String(syntaxNodePtr->NodeValue().Value()); \n  } \n\n  assert(false); \n  return TEXT(\"\"); \n} \n\n```", "```cpp\nvoid Cell::UpdateTree(Reference diffRef,set<Reference>&sourceSet) { \n  if (cellMode == FormulaMode) { \n    UpdateTree(syntaxTreePtr, diffRef, sourceSet); \n  } \n}  \n\nvoid Cell::UpdateTree(Tree<TreeNode>* syntaxNodePtr, \n                 Reference diffRef, set<Reference>& sourceSet) { \n  if (syntaxNodePtr->NodeValue().Id() == RefId) { \n    syntaxNodePtr->NodeValue().ReferenceField() += diffRef;\n    sourceSet.insert(syntaxNodePtr->NodeValue().ReferenceField()); \n  } \n  else { \n    for (Tree<TreeNode>* childNodePtr : \n         syntaxNodePtr->ChildList()) { \n      UpdateTree(childNodePtr, diffRef, sourceSet); \n    } \n  } \n} \n\n```", "```cpp\nbool Cell::HasValue() const{ \n  switch (cellMode) { \n    case TextMode: \n      return false;  \n    case ValueMode: \n      return true; \n\n    case FormulaMode: \n      return hasValue; \n  }  \n\n  assert(false); \n  return false; \n} \n\n```", "```cpp\nvoid Cell::Evaluate(map<Reference,double>& valueMap) { \n  if (cellMode == FormulaMode) { \n    try { \n      value = Evaluate(syntaxTreePtr, valueMap); \n      text = to_String(value); \n      hasValue = true; \n    } \n    catch (Error error) { \n      text = error.ErrorText(); \n      hasValue = false; \n    } \n  } \n} \n\n```", "```cpp\ndouble Cell::Evaluate(Tree<TreeNode>* syntaxNodePtr, \n                      map<Reference,double>& valueMap) { \n  DynamicList<Tree<TreeNode>*> childList = \n    syntaxNodePtr->ChildList(); \n\n```", "```cpp\n  switch (syntaxNodePtr->NodeValue().Id()) { \n    case UnaryAdd: \n      return Evaluate(childList[0], valueMap); \n\n    case UnarySubtract: \n      return -Evaluate(childList[0], valueMap); \n\n    case BinaryAdd: \n      return Evaluate(childList[0], valueMap) + \n             Evaluate(childList[1], valueMap); \n\n    case BinarySubtract: \n      return Evaluate(childList[0], valueMap) - \n             Evaluate(childList[1], valueMap); \n\n    case Multiply: \n      return Evaluate(childList[0], valueMap) * \n             Evaluate(childList[1], valueMap); \n\n```", "```cpp\n    case Divide: { \n        double remainder = Evaluate(childList[1], valueMap); \n\n        if (remainder != 0) { \n          return Evaluate(childList[0], valueMap) / remainder; \n        } \n        else { \n          throw Error(DivisionByZero); \n        } \n      } \n      break; \n\n```", "```cpp\n    case Parenthesis: \n      return Evaluate(childList[0], valueMap); \n\n```", "```cpp\n    case RefId: { \n        Reference sourceRef = \n          syntaxNodePtr->NodeValue().ReferenceField(); \n\n        if ((sourceRef.Row() >= 0) && (sourceRef.Row() < Rows) && \n            (sourceRef.Col() >= 0) && (sourceRef.Col() < Cols)) { \n          if (valueMap.find(sourceRef) != valueMap.end()) { \n            return valueMap[sourceRef]; \n          } \n          else { \n            throw Error(MissingValue); \n          } \n        } \n        else { \n          throw Error(ReferenceOutOfRange); \n        } \n      } \n      break; \n\n```", "```cpp\n    case ValueId: \n      return syntaxNodePtr->NodeValue().Value(); \n  } \n\n  assert(false); \n  return 0; \n} \n\n```", "```cpp\nbool Cell::WriteCellToStream(ostream& outStream) const { \n  outStream.write((char*) &cellMode, sizeof cellMode); \n  outStream.write((char*) &horizontalAlignignment, \n                  sizeof horizontalAlignignment); \n  outStream.write((char*) &verticalAlignignment, \n                  sizeof verticalAlignignment); \n  outStream.write((char*) &hasValue, sizeof hasValue); \n  outStream.write((char*) &value, sizeof value); \n\n  backgroundColor.WriteColorToStream(outStream); \n  font.WriteFontToStream(outStream); \n\n  int charListSize = text.size(); \n  outStream.write((char*) &charListSize, sizeof charListSize); \n\n  for (const TCHAR tChar : text) { \n    outStream.write((char*) &tChar, sizeof tChar); \n  } \n\n  for (const Rect caretRect : caretList) { \n    caretRect.WriteRectToStream(outStream); \n  } \n\n  if (cellMode == FormulaMode) { \n    syntaxTreePtr->WriteTreeToStream(outStream); \n  } \n\n  return ((bool) outStream); \n} \n\n```", "```cpp\nbool Cell::ReadCellFromStream(istream& inStream) { \n  inStream.read((char*) &cellMode, sizeof cellMode); \n  inStream.read((char*) &horizontalAlignignment, \n                sizeof horizontalAlignignment); \n  inStream.read((char*) &verticalAlignignment, \n                sizeof verticalAlignignment); \n  inStream.read((char*) &hasValue, sizeof hasValue); \n  inStream.read((char*) &value, sizeof value); \n\n  backgroundColor.ReadColorFromStream(inStream); \n  font.ReadFontFromStream(inStream); \n\n  int charListSize; \n  inStream.read((char*) &charListSize, sizeof charListSize); \n\n  for (int count = 0; count < charListSize; ++count) { \n    TCHAR tChar; \n    inStream.read((char*) &tChar, sizeof tChar); \n    text.append(1, tChar); \n  } \n\n  for (int count = 0; count < (charListSize + 1); ++count) { \n    Rect caretRect; \n    caretRect.ReadRectFromStream(inStream); \n    caretList.push_back(caretRect); \n  } \n\n  if (cellMode == FormulaMode) { \n    syntaxTreePtr = new Tree<TreeNode>(); \n    assert(syntaxTreePtr != nullptr); \n    syntaxTreePtr->ReadTreeFromStream(inStream); \n  } \n  else { \n    syntaxTreePtr = nullptr; \n  } \n\n  return ((bool) inStream); \n} \n\n```", "```cpp\nvoid Cell::WriteCellToClipboard(InfoList& infoList) const { \n  infoList.AddValue<CellMode>(cellMode); \n  infoList.AddValue<Alignment>(horizontalAlignignment); \n  infoList.AddValue<Alignment>(verticalAlignignment); \n  infoList.AddValue<double>(value); \n  infoList.AddValue<bool>(hasValue); \n\n  font.WriteFontToClipboard(infoList); \n  backgroundColor.WriteColorToClipboard(infoList); \n  infoList.AddValue<int>(text.size()); \n\n  for (const TCHAR tChar : text) { \n    infoList.AddValue<TCHAR>(tChar); \n  } \n\n  if (cellMode == FormulaMode) { \n    syntaxTreePtr->WriteTreeToClipboard(infoList); \n  } \n} \n\nvoid Cell::ReadCellFromClipboard(InfoList& infoList) { \n  infoList.GetValue<CellMode>(cellMode); \n  infoList.GetValue<Alignment>(horizontalAlignignment); \n  infoList.GetValue<Alignment>(verticalAlignignment); \n  infoList.GetValue<double>(value); \n  infoList.GetValue<bool>(hasValue); \n\n  font.ReadFontFromClipboard(infoList); \n  backgroundColor.ReadColorFromClipboard(infoList); \n\n  int listSize; \n  infoList.GetValue<int>(listSize); \n\n  for (int count = 0; count < listSize; ++count) { \n    TCHAR tChar; \n    infoList.GetValue<TCHAR>(tChar); \n    text.push_back(tChar);\n  } \n\n  for (int count = 0; count < (listSize + 1); ++count) { \n    Rect caretRect; \n    caretRect.ReadRectFromClipboard(infoList); \n    caretList.push_back(caretRect); \n  } \n\n  if (cellMode == FormulaMode) { \n    syntaxTreePtr = new Tree<TreeNode>(); \n    assert(syntaxTreePtr != nullptr); \n    syntaxTreePtr->ReadTreeFromClipboard(infoList); \n  } \n  else { \n    syntaxTreePtr = nullptr; \n  } \n} \n\n```"]