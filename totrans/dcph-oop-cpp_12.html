<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer051">
<h1 class="chapter-number" id="_idParaDest-203"><a id="_idTextAnchor526"/>12</h1>
<h1 id="_idParaDest-204"><a id="_idTextAnchor527"/>Friends and Operator Overloading</h1>
<p>This chapter will continue our pursuit of expanding your C++ programming repertoire beyond OOP concepts, with the goal of writing more extensible code. We will next explore <strong class="bold">friend functions</strong>, <strong class="bold">friend classes</strong>, and <strong class="bold">operator overloading</strong> in C++. <a id="_idTextAnchor528"/>We will understand how operator overloading can extend operators beyond their usage with standard types to behave uniformly with user defined types, and why this is a powerful OOP tool. We will learn how friend functions and classes can be safely used to achieve this goal.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding friend functions and friend classes, appropriate reasons to utilize, and measures to add safety to their usage</li>
<li>Learning about operator overloading essentials – how and why to overload operators, ensuring operators are polymorphic between standard and user defined types</li>
<li>Implementing operator functions and knowing when friends may be necessary</li>
</ul>
<p>By the end of this chapter, you will unlock the proper usage of friends and understand their utility in harnessing C++’s ability to overload operators. Though the usage of friend functions and classes can be exploited, you will instead insist on their contained usage only within two tightly coupled classes. You will understand how the proper usage of friends can enhance operator overloading, allowing operators to be extended to support user defined types so they may work associatively with their operands.</p>
<p>Let’s increase our understanding of C++ by expanding your programming repertoire through exploring friend functions, friend classes, and operator overloading. </p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor529"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter12">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter12</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <strong class="source-inline">Chapter12</strong> in a file named <strong class="source-inline">Chp12-Ex1.cpp</strong> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3K0f4tb">https://bit.ly/3K0f4tb</a>.</p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor530"/><a id="_idTextAnchor531"/>Understanding friend classes and friend functions</h1>
<p>Encapsulation is a valuable <a id="_idIndexMarker815"/>OOP feature that C++ offers through the proper usage of classes and access regions. Encapsulation offers uniformity in the manner in which data and behaviors are manipulated. In general, it is unwise to forfeit the encapsulated protection that a class offers.</p>
<p>There are, however, selected programming situations in which breaking encapsulation slightly is considered more acceptable than the alternative of providing an <em class="italic">overly public</em> interface to a class. That is, when a class needs to provide methods for two classes to cooperate, yet, in general, those methods are inappropriate to be publicly accessible.</p>
<p>Let’s consider a scenario that may lead us to consider slightly forfeiting (that is, breaking)<a id="_idTextAnchor532"/> the sacred OOP concept of <a id="_idIndexMarker816"/>encapsulation:</p>
<ul>
<li>Two tightly coupled classes may exist that are not otherwise related to one another. One class may have one or more associations with the other class and need to manipulate the other class’s members. Yet, a public interface to allow access to such members would make these internals <em class="italic">overly public</em> and subject to manipulation well beyond the needs of the pair of tightly coupled classes.</li>
<li>In this situation, it is a better choice to allow one class in the tightly coupled pair to have access to the other class’s members versus providing a public interface in the other class that allows for more manipulation of these members than is generally safe. We will see, momentarily, how to minimize this prospective loss of encapsulation. </li>
<li>Selected operator overloading situations, which we will soon see, may require an instance to have access to its members while in a function that is outside of its class scope. Again, a fully accessible public interface may be considered dangerous.</li>
</ul>
<p><strong class="bold">Friend functions</strong> and <strong class="bold">friend classes</strong> allow this selective breaking of encapsulation to occur. Breaking encapsulation is serious and <a id="_idIndexMarker817"/>should not be done to simply override access regions. Instead, friends can be used – with added safety measures – when the choices<a id="_idIndexMarker818"/> are slightly breaking encapsulation between two tightly coupled classes or providing an overly public interface that would yield greater and potentially unwanted access to another class’s members from various scopes in the application.</p>
<p>Let us take a look at how each may be used, and then we will add the relevant safety measures we should insist on employing. Let’s start with friend functions and friend class<a id="_idTextAnchor533"/>es.</p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor534"/>Using friend functions and friend classes</h2>
<p><strong class="bold">Friend functions</strong> are functions that are individually granted <em class="italic">extended scope</em> to include the class with which they <a id="_idIndexMarker819"/>are associated. Let’s examine the implications and logist<a id="_idTextAnchor535"/>ics:</p>
<ul>
<li>In the scope of friend functions, an instance of the associated type can access its own members as if it were in the scope of its own class.</li>
<li>A friend function needs to be prototyped as a friend in the class definition of the class relinquishing access (that is, extending its scope).</li>
<li>The keyword <strong class="source-inline">friend</strong> is used in front of the prototype that provides access.</li>
<li>Functions overloading friend functions are not considered friends.</li>
</ul>
<p><strong class="bold">Friend classes</strong> are classes in <a id="_idIndexMarker820"/>which every member function of the class is a friend function of the associated class. Let’s examine the logistics:</p>
<ul>
<li>A friend class should have a forward declaration in the class definition of the class that is providing it with access to its members (that is, scope). </li>
<li>The keyword <strong class="source-inline">friend</strong> should precede the forward declaration of the class gaining <a id="_idTextAnchor536"/>access (that is, whose scope has been extended).</li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">Friend classes and friend functions should be utilized sparingly, only when breaking encapsulation selectively and slightly is it a better choice than offering an <em class="italic">overly public</em> interface (that is, a public interface that would universally offer undesired access to selected members within any scope of the application). </p>
<p>Let’s begin by examining the syntax for friend classes and friend function declarations. The following classes<a id="_idIndexMarker821"/> do not represent complete class definitions; however, the complete <a id="_idIndexMarker822"/>program can be found in our online in our GitHub repository as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex1.cpp</a></p>
<pre class="source-code">
class Student;  // forward declaration of Student class
class Id  // Partial class – full class can be found online
{
private:
    string idNumber;
    Student *student = nullptr;  // in-class initialization
public:  // Assume constructors, destructor, etc. exist
    void SetStudent(Student *);
    <strong class="bold">// all member fns. of Student are friend fns to/of Id</strong>
    <strong class="bold">friend class Student;</strong>
};
// Note: Person class is as often defined; see online code
class Student : public Person
{
private:
    float gpa = 0.0;    // in-class initialization
    string currentCourse;
    static int numStudents;
    Id *studentId = nullptr;
public:   // Assume constructors, destructor, etc. exist
    <strong class="bold">// only the following mbr fn. of Id is a friend fn.</strong>
    <strong class="bold">friend void Id::SetStudent(Student *);</strong> <strong class="bold">// to/of Student</strong>
};</pre>
<p>In the preceding code<a id="_idIndexMarker823"/> fragment, we first notice a friend class definition within the <strong class="source-inline">Id</strong> class. The<a id="_idIndexMarker824"/> statement <strong class="source-inline">friend class Student;</strong> indicates that all member functions in <strong class="source-inline">Student</strong> are friend functions to <strong class="source-inline">Id</strong>. This all-inclusive statement is in lieu of naming every function of the <strong class="source-inline">Student</strong> class as a friend function of <strong class="source-inline">Id</strong>.</p>
<p>Also, in the <strong class="source-inline">Student</strong> class, notice the declaration of <strong class="source-inline">friend void Id::SetStudent(Student *);</strong>. This friend function declaration indicates that only this specific member function of <strong class="source-inline">Id</strong> is a friend function of <strong class="source-inline">Student</strong>. </p>
<p>The implication of the friend function prototype <strong class="source-inline">friend void Id::SetStudent(Student *);</strong> is that if a <strong class="source-inline">Student</strong> finds itself in the scope of the <strong class="source-inline">Id::SetStudent()</strong> method, that <strong class="source-inline">Student</strong> may manipulate its own members as though it is in its own scope, namely that of <strong class="source-inline">Student</strong>. You may ask, which <strong class="source-inline">Student</strong> may find itself in the scope of <strong class="source-inline">Id::SetStudent(Student *)</strong>? That’s easy, it is the one passed to the method as an input parameter. The result is that the input parameter of type <strong class="source-inline">Student *</strong> in the <strong class="source-inline">Id::SetStudent()</strong> method may access its own private and protected members as if the <strong class="source-inline">Student</strong> instance were in its own class scope – it is in the scope of a friend function.</p>
<p>Similarly, the implication of the friend class forward declaration: <strong class="source-inline">friend class Student;</strong> found in the <strong class="source-inline">Id</strong> class is that if any <strong class="source-inline">Id</strong> instance finds itself in a <strong class="source-inline">Student</strong> method, that <strong class="source-inline">Id</strong> instance can access its own private or protected methods as if it were in its own class. The <strong class="source-inline">Id</strong> instance may be in any member function of its friend class, <strong class="source-inline">Student</strong>; it is as though those methods have been augmented to also have the scope of the <strong class="source-inline">Id</strong> class.</p>
<p>Notice that the class giving up access – that is, the class widening scope – is the one to announce friendship. That is, the <strong class="source-inline">friend class Student;</strong> statement in <strong class="source-inline">Id</strong> says: If any <strong class="source-inline">Id</strong> happens to <a id="_idIndexMarker825"/>be in any member function of <strong class="source-inline">Student</strong>, allow that <strong class="source-inline">Id</strong> to have full access to its members as if it is in its own scope. Likewise, the friend<a id="_idIndexMarker826"/> function statement in <strong class="source-inline">Student</strong> indicates that if a <strong class="source-inline">Student</strong> instance is found (via the input parameter) in this particular method of <strong class="source-inline">Id</strong>, it may have access to its elements fully, as though it were in a member function of its own class. Think in terms of friendship as a means of augmenting scope.</p>
<p>Now that we have seen the basic mechanics of friend functions and friend classes, let’s employ a simple contract to make it a bit more appealing to selectively break encapsulation.</p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor537"/>Making access safer when using friends</h2>
<p>We have seen that two<a id="_idIndexMarker827"/> tightly coupled classes, such as those related through an association, may need to extend their scope somewhat to selectively include one another through the use of <strong class="bold">friend functions</strong> or <strong class="bold">friend classes</strong>. The alternative is offering a public interface to select elements of each class. However, consider that you may not want the public interface to those elements to be uniformly accessible to be used in any scope of the application. You are truly facing a tough choice: utilize friends or provide an <em class="italic">overly public</em> interface. </p>
<p>Though it may make you initially cringe to utilize friends, it may be safer than the alternative of providing an undesired public interface to class elements. </p>
<p>To lessen the panic that you feel<a id="_idIndexMarker828"/> towards the selective breaking of encapsulation that friends allow, consider adding the following contract to <a id="_idTextAnchor538"/>your usage of friends:</p>
<ul>
<li>When utilizing friends, to lessen the loss of encapsulation, one class can provide private access methods to the other class’ data members. Consider making these methods inline for efficiency, as they are simple access methods (typically single line methods not likely to add software bloat through their expansion).</li>
<li>The instance in question should agree to only utilize the private access methods created to appropriately access its desired members while in the scope of the friend function (even though it could actually unrestrictedly access any data or methods of its own type in the scope of the friend function). This informal understanding is, of course, a gentleman’s agreement, and not language imposed.</li>
</ul>
<p>Here is a simple example to illustrate<a id="_idIndexMarker829"/> two tightly coupled classes appropriately using a <strong class="bold">friend class</strong>. Though the <strong class="source-inline">main()</strong> function and several methods are not <a id="_idIndexMarker830"/>shown to save space, the complete example can be found in our GitHub reposi<a id="_idTextAnchor539"/>tory as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex2.cpp</a></p>
<pre class="source-code">
using Item = int;  
class LinkList;  // forward declaration
class LinkListElement
{
private:
   void *data = nullptr;   // in-class initialization
   LinkListElement *next = nullptr;
   <strong class="bold">// private access methods to be used in scope of friend </strong>
   <strong class="bold">void *GetData() const { return data; }</strong> 
   <strong class="bold">LinkListElement *GetNext() const { return next; }</strong>
   <strong class="bold">void SetNext(LinkListElement *e) { next = e; }</strong>
public:
<strong class="bold">   // All member functions of LinkList are friend </strong>
<strong class="bold">   // functions of LinkListElement</strong> 
   <strong class="bold">friend class LinkList;</strong>   
   LinkListElement() = default;
   LinkListElement(Item *i): data(i), next(nullptr) { }
   ~LinkListElement() { delete static_cast&lt;Item *&gt;(data); 
                        next = nullptr; }
};
// LinkList should only be extended as a protected/private
// base class; it does not contain a virtual destructor. It
// can be used as-is, or as implementation for another ADT.
class LinkList
{
private:
   LinkListElement *head = nullptr, *tail = nullptr, 
                   *current = nullptr;  // in-class init.
public:
   LinkList() = default;
   LinkList(LinkListElement *e) 
       { head = tail = current = e; }
   void InsertAtFront(Item *);
   LinkListElement *RemoveAtFront();  
   void DeleteAtFront()  { delete RemoveAtFront(); }
   bool IsEmpty() const { return head == nullptr; } 
   void Print() const;    // see online definition
   ~LinkList() { while (!IsEmpty()) DeleteAtFront(); }
};</pre>
<p>Let’s examine the preceding class definitions for <strong class="source-inline">LinkListElement</strong> and <strong class="source-inline">LinkList</strong>. Notice that in the <strong class="source-inline">LinkListElement</strong> class, we have three private member functions: <strong class="source-inline">void *GetData();</strong>, <strong class="source-inline">LinkListElement *GetNext();</strong>, and <strong class="source-inline">void SetNext(LinkListElement *);</strong>. These three member functions should not be part of the public class interface. It is only appropriate for these methods to be used within the scope of <strong class="source-inline">LinkList</strong>, a class that is tightly coupled with <strong class="source-inline">LinkListElement</strong>. </p>
<p>Next, notice the <strong class="source-inline">friend class LinkList;</strong> forward declaration in the <strong class="source-inline">LinkListElement</strong> class. This declaration means that all member functions of <strong class="source-inline">LinkList</strong> are friend<a id="_idIndexMarker831"/> functions of <strong class="source-inline">LinkListElement</strong>. As a result, any <strong class="source-inline">LinkListElement</strong> instances that find themselves in <strong class="source-inline">LinkList</strong> methods may access their own aforementioned private <strong class="source-inline">GetData()</strong>, <strong class="source-inline">GetNext()</strong>, and <strong class="source-inline">SetNext()</strong> methods simply because they will be in the scope of a friend class.</p>
<p>Next, let’s take a look<a id="_idIndexMarker832"/> at the <strong class="source-inline">LinkList</strong> class in the preceding code. The class definition itself does not have any unique declarations with respect to friendship. After all, it is the <strong class="source-inline">LinkListElement</strong> class that has widened its scope to include methods of the<strong class="source-inline"> LinkedList</strong> class, not the other way around.</p>
<p>Now, let’s take a look at two selected member functions of the <strong class="source-inline">LinkList</strong> class. The full complement of these methods may be found online, at the previously mentioned URL:</p>
<pre class="source-code">
void LinkList::InsertAtFront(Item *theItem)
{
   LinkListElement *newHead = new LinkListElement(theItem);
   <strong class="bold">// Note: temp can access private SetNext() as if it were</strong>
   <strong class="bold">// in its own scope – it is in the scope of a friend fn.</strong>
   <strong class="bold">newHead-&gt;SetNext(head);</strong>// same as: newHead-&gt;next = head;
   head = newHead;
}
LinkListElement *LinkList::RemoveAtFront()
{
   LinkListElement *remove = head;
   <strong class="bold">head = head-&gt;GetNext();</strong>  // head = head-&gt;next;
   current = head;    // reset current for usage elsewhere
   return remove;
}</pre>
<p>As we examine the aforementioned code, we<a id="_idIndexMarker833"/> can see that in a sampling of <strong class="source-inline">LinkList</strong> methods, a <strong class="source-inline">LinkListElement</strong> can call private methods on itself because it is in the scope of a friend function (which is essentially its own scope, widened). For example, in <strong class="source-inline">LinkList::InsertAtFront()</strong>, <strong class="source-inline">LinkListElement *temp</strong> sets its <strong class="source-inline">next</strong> member to <strong class="source-inline">head</strong> using <strong class="source-inline">temp-&gt;SetNext(head)</strong>. Certainly, we could<a id="_idIndexMarker834"/> have also directly accessed the private data member here using <strong class="source-inline">temp-&gt;next = head;</strong>. However, we maintained a modicum of encapsulation by <strong class="source-inline">LinkListElement</strong> providing private access functions, such as <strong class="source-inline">SetNext()</strong>, and asking <strong class="source-inline">LinkList</strong> methods (friend functions) to have <strong class="source-inline">temp</strong> utilize private method <strong class="source-inline">SetNext()</strong>, rather than just directly manipulating the data member itself. </p>
<p>Because <strong class="source-inline">GetData()</strong>, <strong class="source-inline">GetNext()</strong>, and <strong class="source-inline">SetNext()</strong> in <strong class="source-inline">LinkListElement</strong> are inline functions, we do not forfeit performance by providing a sense of encapsulated access to members <strong class="source-inline">data</strong> and <strong class="source-inline">next</strong>.</p>
<p>We can similarly see that other member functions of <strong class="source-inline">LinkList</strong>, such as <strong class="source-inline">RemoveAtFront()</strong> (and <strong class="source-inline">Print()</strong> which appears in th<a id="_idTextAnchor540"/>e online code) have <strong class="source-inline">LinkListElement</strong> instances utilizing its private access methods, rather than allowing the <strong class="source-inline">LinkListElement</strong> instances to grab their private <strong class="source-inline">data</strong> and <strong class="source-inline">next</strong> members directly. </p>
<p><strong class="source-inline">LinkListElement</strong> and <strong class="source-inline">LinkList</strong> are iconic examples of two tightly coupled classes in which it may be better to extend one class to include the other’s scope for access, rather than providing an <em class="italic">overly public</em> interface. After all, we wouldn’t want users in <strong class="source-inline">main()</strong> to get their hands on a <strong class="source-inline">LinkListElement</strong> and apply <strong class="source-inline">SetNext()</strong>, for example, which could change an entire <strong class="source-inline">LinkedList</strong> without the <strong class="source-inline">LinkList<a id="_idTextAnchor541"/><a id="_idTextAnchor542"/></strong> class’ knowledge.</p>
<p>Now that we have seen the mechanics as well as suggested usage for friend functions and classes, let’s explore<a id="_idIndexMarker835"/> another language feature that may need to <a id="_idIndexMarker836"/>utilize friends – that of operator overloading.</p>
<h1 id="_idParaDest-209"><a id="_idTextAnchor543"/>Deciphering operator overloading essentials</h1>
<p>C++ has a variety of operators in the language. C++ allows most operators to be redefined to include usage<a id="_idIndexMarker837"/> with user defined types; this is known as <strong class="bold">operator overloading</strong>. In this way, user <a id="_idIndexMarker838"/>defined types may utilize the same notation as standard types to perform these well-understood operations. We can view an overloaded operator as polymorphic in that its same form can be used with a variety of types – standard and user defined.</p>
<p>Not all operators may be overloaded in C++. The following operators cannot be overloaded: the member access operator (<strong class="source-inline">.</strong>), the ternary conditional operator (<strong class="source-inline">?:</strong>), the scope resolution operator (<strong class="source-inline">::</strong>), the pointer-to-member operator (<strong class="source-inline">.*</strong>), the <strong class="source-inline">sizeof()</strong> operator, and the <strong class="source-inline">typeid()</strong> operator. All the rest may be overloaded, provided at least one operand is a user defined type.</p>
<p>When overloading an operator, it is important to promote the same meaning that the operator has for standard types. For example, the extraction operator (<strong class="source-inline">&lt;&lt;</strong>) is defined when used in conjunction with <strong class="source-inline">cout</strong> to print to standard output. This operator can be applied to various standard types, such as integers, floating-point numbers, character strings, and so on. Should the extraction operator (<strong class="source-inline">&lt;&lt;</strong>) be overloaded for a user defined type, such as <strong class="source-inline">Student</strong>, it should also mean to print to standard output. In this fashion, operator <strong class="source-inline">&lt;&lt;</strong> is polymorphic when used in the context of an output buffer, such as <strong class="source-inline">cout</strong>; that is, it has the same meaning but different implementation for all types.</p>
<p>It is important to note that when overloading an operator in C++, we may not change the predefined precedence of the operators as they occur in the language. This makes sense – we are not rewriting the compiler to parse and interpret expressions differently. We are merely extending the meaning of an operator from its usage with standard types to include usage with user defined types. Operator precedence will remain unchanged.</p>
<p>An <strong class="bold">operator function</strong> is utilized to<a id="_idIndexMarker839"/> redefine or <em class="italic">overload</em> an operator in C++. The name of the function is simply the name <strong class="source-inline">operator</strong>, followed by the symbol representing the operator which you wish to overload.</p>
<p>Let’s take a look at the simple syntax of an operator function prototype:</p>
<pre class="source-code">
Student &amp;<strong class="bold">operator+</strong>(float gpa, const Student &amp;s);</pre>
<p>Here, we intend to provide a means to add a floating-point number and a <strong class="source-inline">Student</strong> instance using the C++ addition operator (<strong class="source-inline">+</strong>). The meaning of this addition might be to average the new floating-point number with the student’s existing grade point average. Here, the name of the operator function is <strong class="source-inline">operator+()</strong>.</p>
<p>In the aforementioned <a id="_idIndexMarker840"/>prototype, the operator function is not a member function of any class. The left expected operand will be a <strong class="source-inline">float</strong> and the right operand will be a <strong class="source-inline">Student</strong>. The return type of the function (<strong class="source-inline">Student &amp;</strong>) allows us to cascade the use of <strong class="source-inline">+</strong> with multiple operands or be paired with multiple operators, such as <strong class="source-inline">s1 = 3.45 + s2;</strong>. The overall concept is that we can define how to use <strong class="source-inline">+</strong> with multiple types, provided at least one operand is a user defined type.</p>
<p>There’s actually a lot more involved than the simple syntax shown in the previous prototype. Before we fully examine a detailed example, let’s first take a look at more logistics relating to impleme<a id="_idTextAnchor544"/>nting operator functions.</p>
<h2 id="_idParaDest-210">Implementing operator functions and knowing when f<a id="_idTextAnchor545"/><a id="_idTextAnchor546"/>riends might be necessary</h2>
<p>An <strong class="bold">operator function</strong>, the mechanism to overload an operator, may be implemented as a member function or as a regular, external function. Let’s summarize the mechanics of implementing operator functions<a id="_idIndexMarker841"/> with the following key points: </p>
<ul>
<li>Operator functions that are implemented as member functions will receive an implicit argument (the <strong class="source-inline">this</strong> pointer), plus, at most, one explicit argument. If the left operand in the overloaded operation is a user defined type in which modifications to the class can easily be made, implementing the operator function as a member function is reasonable and preferred.</li>
<li>Operator functions that are implemented as external functions will receive one or two explicit arguments. If the left operand in the overloaded operation is a standard type or a class type that is not modifiable, then an external (non-member) function must be used to overload this operator. This external function may need to be a <strong class="source-inline">friend</strong> of any object type that is used as the right-hand function argument.</li>
<li>Operator functions should most often be implemented reciprocally. That is, when overloading a binary operator, ensure that it has been defined to work no matter what order the <a id="_idIndexMarker842"/>data types (should they differ) appear in the operator. </li>
</ul>
<p>Let’s take a look at a full program example to illustrate the mechanics of operator overloading, including member and non-member functions, as well as scenarios requiring the usage of friends. Though some well-known portions of the program have been excluded to save space, the full program example can be found onli<a id="_idTextAnchor547"/>ne in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex3.cpp</a></p>
<pre class="source-code">
// Assume usual header files and std namespace inclusions
class Person
{
private: 
    string firstName, lastname;
    char middleInitial = '\0';
    char *title = nullptr; // use ptr member to demonstrate
                           // deep assignment
protected:
    void ModifyTitle(const string &amp;); // converts to char *
public:                               
    Person() = default;   // default constructor
    Person(const string &amp;, const string &amp;, char, 
           const char *);  
    Person(const Person &amp;);  // copy constructor
    virtual ~Person();  // virtual destructor
    const string &amp;GetFirstName() const 
        { return firstName; }  
    const string &amp;GetLastName() const { return lastName; }    
    const char *GetTitle() const { return title; } 
    char GetMiddleInitial() const { return middleInitial; }
    virtual void Print() const;
  <a id="_idTextAnchor548"/>  virtual void IsA() const;
    <strong class="bold">// overloaded operator functions</strong>
    <strong class="bold">Person &amp;operator=(const Person &amp;);</strong> <strong class="bold">// overloaded assign</strong>
    <strong class="bold">bool operator==(const Person &amp;);</strong>   <strong class="bold">// overloaded</strong>
<strong class="bold">                                       // comparison</strong>
    <strong class="bold">Person &amp;operator+(const string &amp;);</strong> <strong class="bold">// overloaded plus</strong>
    <strong class="bold">// non-mbr friend fn. for op+ (to make associative)</strong>
    <strong class="bold">friend Person &amp;operator+(const string &amp;, Person &amp;);</strong>  
};</pre>
<p>Let’s begin our code examination by first looking at the preceding class definition for <strong class="source-inline">Person</strong>. In addition to the class elements that we are accustomed to seeing, we have four operator functions prototyped: <strong class="source-inline">operator=()</strong>, <strong class="source-inline">operator==()</strong>, and <strong class="source-inline">operator+()</strong> (which is implemented twice so that the operands to <strong class="source-inline">+</strong> can be reversed).</p>
<p>Functions for <strong class="source-inline">operator=()</strong>, <strong class="source-inline">operator==()</strong>, and one version of <strong class="source-inline">operator+()</strong> will be implemented as member functions of this class, whereas the other <strong class="source-inline">operator+()</strong>, with <strong class="source-inline">const char *</strong> and <strong class="source-inline">Person</strong> parameters, will be implemented as a non-member function and will additionally necessitate the use of a friend function.</p>
<h3>Overloading the assignment operator</h3>
<p>Let’s move forward to examine<a id="_idIndexMarker843"/> the applicable operator function definitions for this class, starting by overloading the assignment operator:</p>
<pre class="source-code">
// Assume the required constructors, destructor and basic
// member functions prototyped in the class def. exist.
<strong class="bold">// overloaded assignment operator</strong>
<strong class="bold">Person &amp;Person::operator=(const Person &amp;p)</strong>
{
    if (this != &amp;p)  <strong class="bold">// make sure we're not assigning an</strong> 
    {                <strong class="bold">// object to itself</strong>
        // delete any previously dynamically allocated data 
        // from the destination object
        delete title;
        // Also, remember to reallocate memory for any 
        // data members that are pointers
        // Then, copy from source to destination object 
        // for each data member
        firstName = p.firstName;
        lastName = p.lastName;
        middleInitial = p.middleInitial;
        // Note: a pointer is used for title to demo the
        // necessary steps to implement a deep assignment -
        // otherwise, we would implement title with string
        title = new char[strlen(p.title) + 1]; // mem alloc
        strcpy(title, p.title);
    }
    return *this;  // allo<a id="_idTextAnchor549"/>w for cascaded assignments
}</pre>
<p>Let us now review the overloaded assignment operator in the preceding code. It is designated by the member function <strong class="source-inline">Person &amp;Person::operator=(const Person &amp;p);</strong>. Here, we will be assigning memory from a source object, which will be input parameter <strong class="source-inline">p</strong>, to a destination object, which will be pointed to by <strong class="source-inline">this</strong>. </p>
<p>Our first order of business will be to <a id="_idIndexMarker844"/>ensure that we are not assigning an object to itself. Should this be the case, there is no work to be done! We make this check by testing <strong class="source-inline">if (this != &amp;p)</strong> to see whether both addresses point to the same object. If we’re not assigning an object to itself, we continue.</p>
<p>Next, within the conditional statement (<strong class="source-inline">if</strong>), we first deallocate the existing memory for the dynamically allocated data members pointed to by <strong class="source-inline">this</strong>. After all, the object on the left-hand of the assignment pre-exists and undoubtedly has allocations for these data members. </p>
<p>Now, we notice that the core piece of code within the conditional statement looks very similar to that of the copy constructor. That is, we carefully allocate space for pointer data members to match the sizes needed from their corresponding data members of input parameter <strong class="source-inline">p</strong>. We then copy the applicable data members from input parameter <strong class="source-inline">p</strong> to the data members pointed to by <strong class="source-inline">this</strong>. For the <strong class="source-inline">char</strong> data member, <strong class="source-inline">middleInitial</strong>, a memory allocation is not necessary; we merely use an assignment. This is also true for the <strong class="source-inline">string</strong> data members, <strong class="source-inline">firstName</strong> and <strong class="source-inline">lastName</strong>. In this segment of code, we ensure that we have performed a deep assignment for any pointer data members. A shallow (pointer) assignment, where the source and destination object would otherwise share memory for the data portions of data members that are pointers, would be a disaster waiting to happen.</p>
<p>Lastly, at the end of our implementation of <strong class="source-inline">operator=()</strong>, we return <strong class="source-inline">*this</strong>. Notice that the return type from this function is a reference to a <strong class="source-inline">Person</strong>. Since <strong class="source-inline">this</strong> is a pointer, we merely dereference it so that we may return a referenceable object. This is done so that assignments between <strong class="source-inline">Person</strong> instances can be cascaded; that is, <strong class="source-inline">p1 = p2 = p3;</strong> where <strong class="source-inline">p1</strong>, <strong class="source-inline">p2</strong>, and <strong class="source-inline">p3</strong> are each an instance of <strong class="source-inline">Person</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">When overloading <strong class="source-inline">operator=</strong>, always check for self-assignment. That is, make sure you are not assigning an object to itself. Not only is there no work to be done in the case of self-assignment, but proceeding with an unnecessary self-assignment can actually create unexpected errors! For example, if we have dynamically allocated data members, we will be releasing destination object memory and re-allocating those data members based on the details of the source object’s memory (which, when being the same object, will have been released). The resulting behavior can be unpredictable and error-prone.</p>
<p>Should the programmer<a id="_idIndexMarker845"/> wish to disallow assignment between two objects, the keyword <strong class="source-inline">delete</strong> can be used in the prototype of the overloaded assignment operator as follows:</p>
<pre class="source-code">
    <strong class="bold">// disallow assignment</strong>
    Person &amp;operator=(const Person &amp;) <strong class="bold">= delete</strong>;<strong class="bold"> </strong></pre>
<p>It is useful to remember that an overloaded assignment operator shares many similarities with the copy constructor; the same care and cautions apply to both language features. Keep in mind, however, that the assignment operator will be invoked when conducting an assignment between two pre-existing objects, whereas the copy constructor is implicitly invoked for initialization following the creation of a new instance. With the copy constructor, the new instance uses the existing instance as its basis for initialization; similarly, the left-hand object of the assignment operator uses the right-hand object as its basis for the assignment.</p>
<p class="callout-heading">Important note</p>
<p class="callout">An overloaded assignment operator is not inherited by derived classes; therefore, it must be defined by each class in the hierarchy. Neglecting to overload <strong class="source-inline">operator=</strong> for a class will force the compiler to provide you with a default, shallow assignment operator for that class; this is dangerous for any classes containing data members that are pointers.</p>
<h3>Overloading the comparison operator</h3>
<p>Next, let’s take a look at our<a id="_idIndexMarker846"/> implementation of the overloaded comparison operator:</p>
<pre class="source-code">
<strong class="bold">// overloaded comparison operator</strong>
<strong class="bold">bool Person::operator==(const Person &amp;p)</strong>
{   
    // if the objects are the same object, or if the
    // contents are equal, return true. Otherwise, false.
    if (this == &amp;p) 
        return true;
    else if ( (!firstName.compare(p.firstName)) &amp;&amp;
              (!lastName.compare(p.lastName)) &amp;&amp;
              (!strcmp(title, p.title)) &amp;&amp;
              (middleInitial == p.middleInitial) )
        return true;
    else
        return false;
}</pre>
<p>Continuing with a segment<a id="_idIndexMarker847"/> from our previous program, we overload the comparison operator. It is designated by the member function <strong class="source-inline">int Person::operator==(const Person &amp;p);</strong>. Here, we will be comparing a <strong class="source-inline">Person</strong> object on the right-hand side of the operator, which will be referenced by input parameter <strong class="source-inline">p</strong>, to a <strong class="source-inline">Person</strong> object on the left-hand side of the operator, which will be pointed to by <strong class="source-inline">this</strong>. </p>
<p>Similarly, our first order of business will be to test whether the object on the <strong class="bold">right-hand side</strong> (<strong class="bold">rhs</strong>) is the same as the object on the <strong class="bold">left-hand side</strong> (<strong class="bold">lhs</strong>). We make this check by testing <strong class="source-inline">if (this != &amp;p)</strong> to see whether both addresses point to the same object. If both addresses point to the same object, we return the boolean (<strong class="source-inline">bool</strong>) value of <strong class="source-inline">true</strong>. </p>
<p>Next, we check whether the two <strong class="source-inline">Person</strong> objects contain identical values. They may be separate objects in memory, yet if they contain identical values, we can likewise choose to return a <strong class="source-inline">bool</strong> value of <strong class="source-inline">true</strong>. If there is no match, we then return a <strong class="source-inline">bool</strong> value of <strong class="source-inline">false</strong>. </p>
<h3>Overloading the addition operator as a member function</h3>
<p>Now, let’s take a look at how to <a id="_idIndexMarker848"/>overload <strong class="source-inline">operator+</strong> for <strong class="source-inline">Person</strong> and a <strong class="source-inline">string</strong>:</p>
<pre class="source-code">
<strong class="bold">// overloaded operator + (member function)</strong>
<strong class="bold">Person &amp;Person::operator+(const string &amp;t)</strong>
{
    ModifyTitle(t);
    return *this;
}</pre>
<p>Moving forward with the preceding program, we overload the addition operator (<strong class="source-inline">+</strong>) to be used with a <strong class="source-inline">Person</strong> and a <strong class="source-inline">string</strong>. The operator function is designated by the member function prototype <strong class="source-inline">Person&amp; Person::operator+(const string &amp;t);</strong>. The parameter, <strong class="source-inline">t</strong>, will represent the right operand of <strong class="source-inline">operator+</strong>, which is a character string (which will bind to a reference to a string). The left-hand operand will be pointed to by <strong class="source-inline">t<a id="_idTextAnchor550"/>his</strong>. An example use would be <strong class="source-inline">p1 + "Miss"</strong>, where we wish to add a <strong class="source-inline">title</strong> to the <strong class="source-inline">Person</strong> <strong class="source-inline">p1</strong> using <strong class="source-inline">operator+</strong>. </p>
<p>In the body of this member function, we merely use the input parameter <strong class="source-inline">t</strong> as an argument to <strong class="source-inline">ModifyTitle()</strong>, that is, <strong class="source-inline">ModifyTitle(t);</strong>. We then return <strong class="source-inline">*this</strong> so that we may cascade the use of this operator (notice the return type is a <strong class="source-inline">Person &amp;</strong>).</p>
<h3>Overloading the addition operator as a non-member function (using friends)</h3>
<p>Now, let’s reverse the order of<a id="_idIndexMarker849"/> operands with <strong class="source-inline">operator+</strong> to allow for a <strong class="source-inline">string</strong> and a <strong class="source-inline">Person</strong>:</p>
<pre class="source-code">
<strong class="bold">// overloaded + operator (not a mbr function) </strong>
<strong class="bold">Person &amp;operator+(const string &amp;t, Person &amp;p)</strong>
{
    p.ModifyTitle(t);
    return p;
}</pre>
<p>Continuing forward with the preceding program, we would ideally like <strong class="source-inline">operator+</strong> to work not only with a <strong class="source-inline">Person</strong> and a <strong class="source-inline">string</strong> but also with the operands reversed, that is, with a <strong class="source-inline">string</strong> and a <strong class="source-inline">Person</strong>. There is no reason this operator should work one way and not the other. </p>
<p>To implement <strong class="source-inline">operator+</strong> fully, we next overload <strong class="source-inline">operator+()</strong> to be used with <strong class="source-inline">const string &amp;</strong> and <strong class="source-inline">Person</strong>. The operator function is designated by the non-member function <strong class="source-inline">Person&amp; operator+(const string &amp;t, Person &amp;p);</strong>, which has two explicit input parameters. The first parameter, <strong class="source-inline">t</strong>, will represent the left operand of <strong class="source-inline">operator+</strong>, which is a character string (binding this parameter to a reference to a string as the first<a id="_idIndexMarker850"/> formal parameter in the operator function). The second parameter, <strong class="source-inline">p</strong>, will be a reference to the right operand used in<a id="_idTextAnchor551"/> <strong class="source-inline">operator+</strong>. An example use might be <strong class="source-inline">"Miss" + p1</strong>, where we wish to add a title to the <strong class="source-inline">Person p1</strong> using <strong class="source-inline">operator+</strong>. Note that <strong class="source-inline">"Miss"</strong> will be constructed as a <strong class="source-inline">string</strong> using the <strong class="source-inline">std::string(const char *)</strong> constructor—the string literal is simply the initial value for the string object.</p>
<p>In the body of this non-member function, we merely take input parameter <strong class="source-inline">p</strong> and apply the protected method <strong class="source-inline">ModifyTitle()</strong> using the string of characters specified by parameter <strong class="source-inline">t</strong>, that is, <strong class="source-inline">p.ModifyTitle(t)</strong>. However, because <strong class="source-inline">Person::ModifyTitle()</strong> is protected, <strong class="source-inline">Person &amp;p</strong> may not invoke this method outside of member functions of <strong class="source-inline">Person</strong>. We are in an external function; we are not in the scope of <strong class="source-inline">Person</strong>. Therefore, unless this member function is a <strong class="source-inline">friend</strong> of <strong class="source-inline">Person</strong>, <strong class="source-inline">p</strong> may not invoke <strong class="source-inline">ModifyTitle()</strong>. Luckily, <strong class="source-inline">Person &amp;operator+(const string &amp;, Person &amp;);</strong> has been prototyped as a friend function in the <strong class="source-inline">Person</strong> class, providing the necessary scope to <strong class="source-inline">p</strong> to allow it to invoke its protected method. It is as if <strong class="source-inline">p</strong> is in the scope of <strong class="source-inline">Person</strong>; it is in the scope of a friend function of <strong class="source-inline">Person</strong>!</p>
<p>Let us now move forward to our <strong class="source-inline">main()</strong> function, tying together our many aforementioned code segments, so we may see how to invoke our operator functions utilizing our overloaded operators:</p>
<pre class="source-code">
int main()
{
    Person p1;      // default constructed Per<a id="_idTextAnchor552"/>son
    Person p2("Gabby", "Doone", 'A', "Miss");
    Person p3("Renee", "Alexander", 'Z', "Dr.");
    p1.Print();
    p2.Print();
    p3.Print();  
    <strong class="bold">p1 = p2;</strong>       <strong class="bold">// invoke overloaded assignment operator</strong>
    p1.Print();
    <strong class="bold">p2 = "Ms." + p2;</strong>  <strong class="bold">// invoke overloaded + operator</strong>
    p2.Print();       <strong class="bold">// then invoke overloaded = operator</strong>
    <strong class="bold">p1 = p2 = p3;</strong>     <strong class="bold">// overloaded = can handle cascaded =</strong>
    p2.Print();     
    p1.Print();
    if (<strong class="bold">p2 == p2</strong>)   <strong class="bold">// overloaded<a id="_idTextAnchor553"/> comparison operator</strong>
       cout &lt;&lt; "Same people" &lt;&lt; endl;
    if (<strong class="bold">p1 == p3</strong>)
       cout &lt;&lt; "Same people" &lt;&lt; endl;
   return 0;
}</pre>
<p>Finally, let us examine our <strong class="source-inline">main()</strong> function for the preceding program. We begin by instantiating three<a id="_idIndexMarker851"/> instances of <strong class="source-inline">Person</strong>, namely <strong class="source-inline">p1</strong>, <strong class="source-inline">p2</strong>, and <strong class="source-inline">p3</strong>; we then print their values using member function <strong class="source-inline">Print()</strong> for each instance.</p>
<p>Now, we invoke our overloaded assignment operator with the statement <strong class="source-inline">p1 = p2;</strong>. Under the hood, this translates to the following operator function invocation: <strong class="source-inline">p1.operator=(p2);</strong>. From this, we can clearly see that we are invoking the previously defined <strong class="source-inline">operator=()</strong> method of <strong class="source-inline">Person</strong>, which performs a deep copy from source object <strong class="source-inline">p2</strong> to destination object <strong class="source-inline">p1</strong>. We apply <strong class="source-inline">p1.Print();</strong> to see our resulting copy.</p>
<p>Next, we invoke our overloaded <strong class="source-inline">operator+</strong> with <strong class="source-inline">"Ms." + p2</strong>. This portion of this line of code translates to<a id="_idIndexMarker852"/> the follow<a id="_idTextAnchor554"/>ing operator function call: <strong class="source-inline">operator+("Ms.", p2);</strong>. Here, we simply invoke our previously described <strong class="source-inline">operator+()</strong> function, which is a non-member function and <strong class="source-inline">friend</strong> of the <strong class="source-inline">Person</strong> class. Because this function returns a <strong class="source-inline">Person &amp;</strong>, we can cascade this function call to look more like the usual context of ad<a id="_idTextAnchor555"/>dition and additionally write <strong class="source-inline">p2 = "Ms." + p2;</strong>. In this full line of code, first, <strong class="source-inline">operator+()</strong> is invoked for <strong class="source-inline">"Ms." + p2</strong>. The return value of this invocation is <strong class="source-inline">p2</strong>, which is then used as the right-hand operand of the cascaded call to <strong class="source-inline">operator=</strong>. Notice that the left-hand operand to <strong class="source-inline">operator=</strong> also happens to be <strong class="source-inline">p2</strong>. Fortunately, the overloaded assignment operator checks for self-assignment.</p>
<p>Now, we see a cascaded assignment of <strong class="source-inline">p1 = p2 = p3;</strong>. Here, we are invoking the overloaded assignment operator twice. First, we invoke <strong class="source-inline">operator=</strong> with <strong class="source-inline">p2</strong> and <strong class="source-inline">p3</strong>. The translated call would be <strong class="source-inline">p2.operator=(p3);</strong>. Then, using the return value of the first function call, we would invoke <strong class="source-inline">operator=</strong> a second time. The nested, translated call for <strong class="source-inline">p1 = p2 = p3;</strong> would look like this: <strong class="source-inline">p1.operator=(p2.operator=(p3));</strong>.</p>
<p>Lastly in this program, we invoke the overloaded comparison operator twice. For example, each comparison of <strong class="source-inline">if (p2 == p2)</strong> or <strong class="source-inline">if (p1 == p3)</strong> merely calls the <strong class="source-inline">operator==</strong> member function we have defined previously. Recall that we’ve written this function to report <strong class="source-inline">true</strong> either if the objects are the same in memory or simply contain the same values, and return <strong class="source-inline">false</strong> otherwise.</p>
<p>Let’s take a look at the output for this program:</p>
<p class="source-code">No first name No last name</p>
<p class="source-code">Miss Gabby A. Doone</p>
<p class="source-code">Dr. Renee Z. Alexander</p>
<p class="source-code">Miss Gabby A. Doone</p>
<p class="source-code">Ms. Gabby A. Doone</p>
<p class="source-code">Dr. Renee Z. Alexander</p>
<p class="source-code">Dr. Renee Z. Alexander</p>
<p class="source-code">Same people</p>
<p class="source-code">Same people</p>
<p>We have now seen how to <a id="_idIndexMarker853"/>specify and utilize friend classes and friend functions, how to overload C++ operators, and have seen cases when these two concepts can complement each other. Let us now briefly recap the features we have learned in this chapter before moving forward to our next chapter.</p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor556"/>Summary</h1>
<p>In this chapter, we have furthered our C++ programming endeavors beyond OOP language features to include features that will enable us to write more extensible programs. We have learned how to utilize friend functions and friend classes and we have learned how to overload operators in C++.</p>
<p>We have seen that friend functions and classes should be used sparingly and with caution. They are not meant to provide a blatant means to circumvent access regions. Instead, they are meant to handle programming situations to allow access between two tightly coupled classes without providing the alternative of an <em class="italic">overly public</em> interface in either of those classes, which could be misused on a broader scale.</p>
<p>We have seen how to overload operators in C++ using operator functions, both as member and non-member functions. We have learned that overloading operators will allow us to extend the meaning of C++ operators to include user defined types in the same way they encompass standard types. We have also seen that, in some cases, friend functions or classes may come in handy to help implement operator functions so they may behave associatively.</p>
<p>We have added important features to our C++ repertoire through exploring friends and operator overloading, the latter of which will help us to ensure code we will soon write using templates can be used for nearly any data type, contributing to highly extensible and reusable code. We are now ready to move forward to <a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em>, so that we can continue expanding our C++ programming skills with essential language features that will make us better p<a id="_idTextAnchor557"/>rogrammers. Let’s move ahead!</p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor558"/>Questions</h1>
<ol>
<li>Overload <strong class="source-inline">operator=</strong> in your <strong class="source-inline">Shape</strong> exercise from <a href="B19087_08.xhtml#_idTextAnchor399"><em class="italic">Chapter 8</em></a>, <em class="italic">Mastering Abstract Classes</em>, or alternatively, overload <strong class="source-inline">operator=</strong> in your ongoing <strong class="source-inline">LifeForm</strong>/<strong class="source-inline">Person</strong>/<strong class="source-inline">Student</strong> classes as follows:</li>
</ol>
<p>Define <strong class="source-inline">operator=</strong> in <strong class="source-inline">Shape</strong> (or <strong class="source-inline">LifeForm</strong>) and override this method in all of its derived classes. Hint: the derived implementation of <strong class="source-inline">operator=()</strong> will do more work than its ancestor, yet could call its ancestor’s implementation to perform the base class part of the work.</p>
<ol>
<li value="2">Overload <strong class="source-inline">operator&lt;&lt;</strong> in your <strong class="source-inline">Shape</strong> class (or <strong class="source-inline">LifeForm</strong> class) to print information about each <strong class="source-inline">Shape</strong> (or <strong class="source-inline">LifeForm</strong>). The arguments to this function should be an <strong class="source-inline">ostream &amp;</strong> and a <strong class="source-inline">Shape &amp;</strong> (or a <strong class="source-inline">LifeForm &amp;</strong>). Note that <strong class="source-inline">ostream</strong> is from the C++ St<a id="_idTextAnchor559"/>andard Library (<strong class="source-inline">using namespace std;</strong>).</li>
</ol>
<p>You may<a id="_idTextAnchor560"/> either provide one function, <strong class="source-inline">ostream &amp;operator&lt;&lt;(ostream &amp;, Shape &amp;);</strong>, and from it call a polymorphic <strong class="source-inline">Print()</strong>, which is defined in <strong class="source-inline">Shape</strong> and redefined in each derived class. Or, provide multiple <strong class="source-inline">operator&lt;&lt;</strong> methods to implement this functionality (one for each derived class). If using the <strong class="source-inline">Lifeform</strong> hierarchy, substitute <strong class="source-inline">LifeForm</strong> for <strong class="source-inline">Shape</strong>, in the aforementioned <strong class="source-inline">operator&lt;&lt;</strong> function signature. </p>
<ol>
<li value="3">Create an <strong class="source-inline">ArrayInt</strong> class to provide safe integer arrays with bounds checking. Overload <strong class="source-inline">operator[]</strong> to return an element if it exists in the array, or throw an exception if it is <strong class="source-inline">OutOfBounds</strong>. Add other methods to <strong class="source-inline">ArrayInt</strong>, such as <strong class="source-inline">Resize()</strong>, <strong class="source-inline">RemoveElement()</strong>, and so on. Model the data comprising the array using a dynamically allocated array (that is, using <strong class="source-inline">int *contents</strong>) so that you can easily handle resizing. The code would begin as follows:<p class="source-code">class ArrayInt // starting point for the class def.</p><p class="source-code">{          // be sure to add: using std::to_string;</p><p class="source-code">private:   // and also: using std::out_of_range;</p><p class="source-code">    int numElements = 0;     // in-class init.</p><p class="source-code">    int *contents = nullptr; // dynam. alloc. array</p><p class="source-code">public:</p><p class="source-code">    ArrayInt(int size); // set numElements and</p><p class="source-code">                        // allocate contents</p><p class="source-code">    // returns a referenceable memory location or</p><p class="source-code">    // throws an exception</p><p class="source-code">    <strong class="bold">int &amp;operator[](int index</strong>) </p><p class="source-code">    {             </p><p class="source-code">        if (index &lt; numElements) </p><p class="source-code">            return contents[index];</p><p class="source-code">        else    // index is out of bounds</p><p class="source-code">            throw std::out_of_range(</p><p class="source-code">                              std::to_string(index));</p><p class="source-code">    }                        </p><p class="source-code">};</p><p class="source-code">int main()</p><p class="source-code">{</p><p class="source-code">    ArrayInt a1(5); // Create ArrayInt of 5 elements</p><p class="source-code">    try</p><p class="source-code">    {</p><p class="source-code">        <strong class="bold">a1[4] = 7;</strong>      // a1.operator[](4) = 7;</p><p class="source-code">    }</p><p class="source-code">    catch (const std::out_of_range &amp;e)</p><p class="source-code">    {</p><p class="source-code">        cout &lt;&lt; "Out of range: " &lt;&lt; e.what() &lt;&lt; endl;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
</div>
<div>
<div id="_idContainer052">
</div>
</div>
</div></body></html>