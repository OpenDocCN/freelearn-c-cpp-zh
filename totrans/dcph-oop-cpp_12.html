<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-203"><a id="_idTextAnchor526"/>12</h1>
<h1 id="_idParaDest-204"><a id="_idTextAnchor527"/>Friends and Operator Overloading</h1>
<p>This chapter will continue our pursuit of expanding your C++ programming repertoire beyond OOP concepts, with the goal of writing more extensible code. We will next explore <strong class="bold">friend functions</strong>, <strong class="bold">friend classes</strong>, and <strong class="bold">operator overloading</strong> in C++. <a id="_idTextAnchor528"/>We will understand how operator overloading can extend operators beyond their usage with standard types to behave uniformly with user defined types, and why this is a powerful OOP tool. We will learn how friend functions and classes can be safely used to achieve this goal.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding friend functions and friend classes, appropriate reasons to utilize, and measures to add safety to their usage</li>
<li>Learning about operator overloading essentials – how and why to overload operators, ensuring operators are polymorphic between standard and user defined types</li>
<li>Implementing operator functions and knowing when friends may be necessary</li>
</ul>
<p>By the end of this chapter, you will unlock the proper usage of friends and understand their utility in harnessing C++’s ability to overload operators. Though the usage of friend functions and classes can be exploited, you will instead insist on their contained usage only within two tightly coupled classes. You will understand how the proper usage of friends can enhance operator overloading, allowing operators to be extended to support user defined types so they may work associatively with their operands.</p>
<p>Let’s increase our understanding of C++ by expanding your programming repertoire through exploring friend functions, friend classes, and operator overloading. </p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor529"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter12">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter12</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <code>Chapter12</code> in a file named <code>Chp12-Ex1.cpp</code> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3K0f4tb">https://bit.ly/3K0f4tb</a>.</p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor530"/><a id="_idTextAnchor531"/>Understanding friend classes and friend functions</h1>
<p>Encapsulation is a valuable <a id="_idIndexMarker815"/>OOP feature that C++ offers through the proper usage of classes and access regions. Encapsulation offers uniformity in the manner in which data and behaviors are manipulated. In general, it is unwise to forfeit the encapsulated protection that a class offers.</p>
<p>There are, however, selected programming situations in which breaking encapsulation slightly is considered more acceptable than the alternative of providing an <em class="italic">overly public</em> interface to a class. That is, when a class needs to provide methods for two classes to cooperate, yet, in general, those methods are inappropriate to be publicly accessible.</p>
<p>Let’s consider a scenario that may lead us to consider slightly forfeiting (that is, breaking)<a id="_idTextAnchor532"/> the sacred OOP concept of <a id="_idIndexMarker816"/>encapsulation:</p>
<ul>
<li>Two tightly coupled classes may exist that are not otherwise related to one another. One class may have one or more associations with the other class and need to manipulate the other class’s members. Yet, a public interface to allow access to such members would make these internals <em class="italic">overly public</em> and subject to manipulation well beyond the needs of the pair of tightly coupled classes.</li>
<li>In this situation, it is a better choice to allow one class in the tightly coupled pair to have access to the other class’s members versus providing a public interface in the other class that allows for more manipulation of these members than is generally safe. We will see, momentarily, how to minimize this prospective loss of encapsulation. </li>
<li>Selected operator overloading situations, which we will soon see, may require an instance to have access to its members while in a function that is outside of its class scope. Again, a fully accessible public interface may be considered dangerous.</li>
</ul>
<p><strong class="bold">Friend functions</strong> and <strong class="bold">friend classes</strong> allow this selective breaking of encapsulation to occur. Breaking encapsulation is serious and <a id="_idIndexMarker817"/>should not be done to simply override access regions. Instead, friends can be used – with added safety measures – when the choices<a id="_idIndexMarker818"/> are slightly breaking encapsulation between two tightly coupled classes or providing an overly public interface that would yield greater and potentially unwanted access to another class’s members from various scopes in the application.</p>
<p>Let us take a look at how each may be used, and then we will add the relevant safety measures we should insist on employing. Let’s start with friend functions and friend class<a id="_idTextAnchor533"/>es.</p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor534"/>Using friend functions and friend classes</h2>
<p><strong class="bold">Friend functions</strong> are functions that are individually granted <em class="italic">extended scope</em> to include the class with which they <a id="_idIndexMarker819"/>are associated. Let’s examine the implications and logist<a id="_idTextAnchor535"/>ics:</p>
<ul>
<li>In the scope of friend functions, an instance of the associated type can access its own members as if it were in the scope of its own class.</li>
<li>A friend function needs to be prototyped as a friend in the class definition of the class relinquishing access (that is, extending its scope).</li>
<li>The keyword <code>friend</code> is used in front of the prototype that provides access.</li>
<li>Functions overloading friend functions are not considered friends.</li>
</ul>
<p><strong class="bold">Friend classes</strong> are classes in <a id="_idIndexMarker820"/>which every member function of the class is a friend function of the associated class. Let’s examine the logistics:</p>
<ul>
<li>A friend class should have a forward declaration in the class definition of the class that is providing it with access to its members (that is, scope). </li>
<li>The keyword <code>friend</code> should precede the forward declaration of the class gaining <a id="_idTextAnchor536"/>access (that is, whose scope has been extended).</li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">Friend classes and friend functions should be utilized sparingly, only when breaking encapsulation selectively and slightly is it a better choice than offering an <em class="italic">overly public</em> interface (that is, a public interface that would universally offer undesired access to selected members within any scope of the application). </p>
<p>Let’s begin by examining the syntax for friend classes and friend function declarations. The following classes<a id="_idIndexMarker821"/> do not represent complete class definitions; however, the complete <a id="_idIndexMarker822"/>program can be found in our online in our GitHub repository as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex1.cpp</a></p>
<pre class="source-code">
class Student;  // forward declaration of Student class
class Id  // Partial class – full class can be found online
{
private:
    string idNumber;
    Student *student = nullptr;  // in-class initialization
public:  // Assume constructors, destructor, etc. exist
    void SetStudent(Student *);
    <strong class="bold">// all member fns. of Student are friend fns to/of Id</strong>
    <strong class="bold">friend class Student;</strong>
};
// Note: Person class is as often defined; see online code
class Student : public Person
{
private:
    float gpa = 0.0;    // in-class initialization
    string currentCourse;
    static int numStudents;
    Id *studentId = nullptr;
public:   // Assume constructors, destructor, etc. exist
    <strong class="bold">// only the following mbr fn. of Id is a friend fn.</strong>
    <strong class="bold">friend void Id::SetStudent(Student *);</strong> <strong class="bold">// to/of Student</strong>
};</pre>
<p>In the preceding code<a id="_idIndexMarker823"/> fragment, we first notice a friend class definition within the <code>Id</code> class. The<a id="_idIndexMarker824"/> statement <code>friend class Student;</code> indicates that all member functions in <code>Student</code> are friend functions to <code>Id</code>. This all-inclusive statement is in lieu of naming every function of the <code>Student</code> class as a friend function of <code>Id</code>.</p>
<p>Also, in the <code>Student</code> class, notice the declaration of <code>friend void Id::SetStudent(Student *);</code>. This friend function declaration indicates that only this specific member function of <code>Id</code> is a friend function of <code>Student</code>. </p>
<p>The implication of the friend function prototype <code>friend void Id::SetStudent(Student *);</code> is that if a <code>Student</code> finds itself in the scope of the <code>Id::SetStudent()</code> method, that <code>Student</code> may manipulate its own members as though it is in its own scope, namely that of <code>Student</code>. You may ask, which <code>Student</code> may find itself in the scope of <code>Id::SetStudent(Student *)</code>? That’s easy, it is the one passed to the method as an input parameter. The result is that the input parameter of type <code>Student *</code> in the <code>Id::SetStudent()</code> method may access its own private and protected members as if the <code>Student</code> instance were in its own class scope – it is in the scope of a friend function.</p>
<p>Similarly, the implication of the friend class forward declaration: <code>friend class Student;</code> found in the <code>Id</code> class is that if any <code>Id</code> instance finds itself in a <code>Student</code> method, that <code>Id</code> instance can access its own private or protected methods as if it were in its own class. The <code>Id</code> instance may be in any member function of its friend class, <code>Student</code>; it is as though those methods have been augmented to also have the scope of the <code>Id</code> class.</p>
<p>Notice that the class giving up access – that is, the class widening scope – is the one to announce friendship. That is, the <code>friend class Student;</code> statement in <code>Id</code> says: If any <code>Id</code> happens to <a id="_idIndexMarker825"/>be in any member function of <code>Student</code>, allow that <code>Id</code> to have full access to its members as if it is in its own scope. Likewise, the friend<a id="_idIndexMarker826"/> function statement in <code>Student</code> indicates that if a <code>Student</code> instance is found (via the input parameter) in this particular method of <code>Id</code>, it may have access to its elements fully, as though it were in a member function of its own class. Think in terms of friendship as a means of augmenting scope.</p>
<p>Now that we have seen the basic mechanics of friend functions and friend classes, let’s employ a simple contract to make it a bit more appealing to selectively break encapsulation.</p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor537"/>Making access safer when using friends</h2>
<p>We have seen that two<a id="_idIndexMarker827"/> tightly coupled classes, such as those related through an association, may need to extend their scope somewhat to selectively include one another through the use of <strong class="bold">friend functions</strong> or <strong class="bold">friend classes</strong>. The alternative is offering a public interface to select elements of each class. However, consider that you may not want the public interface to those elements to be uniformly accessible to be used in any scope of the application. You are truly facing a tough choice: utilize friends or provide an <em class="italic">overly public</em> interface. </p>
<p>Though it may make you initially cringe to utilize friends, it may be safer than the alternative of providing an undesired public interface to class elements. </p>
<p>To lessen the panic that you feel<a id="_idIndexMarker828"/> towards the selective breaking of encapsulation that friends allow, consider adding the following contract to <a id="_idTextAnchor538"/>your usage of friends:</p>
<ul>
<li>When utilizing friends, to lessen the loss of encapsulation, one class can provide private access methods to the other class’ data members. Consider making these methods inline for efficiency, as they are simple access methods (typically single line methods not likely to add software bloat through their expansion).</li>
<li>The instance in question should agree to only utilize the private access methods created to appropriately access its desired members while in the scope of the friend function (even though it could actually unrestrictedly access any data or methods of its own type in the scope of the friend function). This informal understanding is, of course, a gentleman’s agreement, and not language imposed.</li>
</ul>
<p>Here is a simple example to illustrate<a id="_idIndexMarker829"/> two tightly coupled classes appropriately using a <code>main()</code> function and several methods are not <a id="_idIndexMarker830"/>shown to save space, the complete example can be found in our GitHub reposi<a id="_idTextAnchor539"/>tory as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex2.cpp</a></p>
<pre class="source-code">
using Item = int;  
class LinkList;  // forward declaration
class LinkListElement
{
private:
   void *data = nullptr;   // in-class initialization
   LinkListElement *next = nullptr;
   <strong class="bold">// private access methods to be used in scope of friend </strong>
   <strong class="bold">void *GetData() const { return data; }</strong> 
   <strong class="bold">LinkListElement *GetNext() const { return next; }</strong>
   <strong class="bold">void SetNext(LinkListElement *e) { next = e; }</strong>
public:
<strong class="bold">   // All member functions of LinkList are friend </strong>
<strong class="bold">   // functions of LinkListElement</strong> 
   <strong class="bold">friend class LinkList;</strong>   
   LinkListElement() = default;
   LinkListElement(Item *i): data(i), next(nullptr) { }
   ~LinkListElement() { delete static_cast&lt;Item *&gt;(data); 
                        next = nullptr; }
};
// LinkList should only be extended as a protected/private
// base class; it does not contain a virtual destructor. It
// can be used as-is, or as implementation for another ADT.
class LinkList
{
private:
   LinkListElement *head = nullptr, *tail = nullptr, 
                   *current = nullptr;  // in-class init.
public:
   LinkList() = default;
   LinkList(LinkListElement *e) 
       { head = tail = current = e; }
   void InsertAtFront(Item *);
   LinkListElement *RemoveAtFront();  
   void DeleteAtFront()  { delete RemoveAtFront(); }
   bool IsEmpty() const { return head == nullptr; } 
   void Print() const;    // see online definition
   ~LinkList() { while (!IsEmpty()) DeleteAtFront(); }
};</pre>
<p>Let’s examine the preceding class definitions for <code>LinkListElement</code> and <code>LinkList</code>. Notice that in the <code>LinkListElement</code> class, we have three private member functions: <code>void *GetData();</code>, <code>LinkListElement *GetNext();</code>, and <code>void SetNext(LinkListElement *);</code>. These three member functions should not be part of the public class interface. It is only appropriate for these methods to be used within the scope of <code>LinkList</code>, a class that is tightly coupled with <code>LinkListElement</code>. </p>
<p>Next, notice the <code>friend class LinkList;</code> forward declaration in the <code>LinkListElement</code> class. This declaration means that all member functions of <code>LinkList</code> are friend<a id="_idIndexMarker831"/> functions of <code>LinkListElement</code>. As a result, any <code>LinkListElement</code> instances that find themselves in <code>LinkList</code> methods may access their own aforementioned private <code>GetData()</code>, <code>GetNext()</code>, and <code>SetNext()</code> methods simply because they will be in the scope of a friend class.</p>
<p>Next, let’s take a look<a id="_idIndexMarker832"/> at the <code>LinkList</code> class in the preceding code. The class definition itself does not have any unique declarations with respect to friendship. After all, it is the <code>LinkListElement</code> class that has widened its scope to include methods of the<code> LinkedList</code> class, not the other way around.</p>
<p>Now, let’s take a look at two selected member functions of the <code>LinkList</code> class. The full complement of these methods may be found online, at the previously mentioned URL:</p>
<pre class="source-code">
void LinkList::InsertAtFront(Item *theItem)
{
   LinkListElement *newHead = new LinkListElement(theItem);
   <strong class="bold">// Note: temp can access private SetNext() as if it were</strong>
   <strong class="bold">// in its own scope – it is in the scope of a friend fn.</strong>
   <strong class="bold">newHead-&gt;SetNext(head);</strong>// same as: newHead-&gt;next = head;
   head = newHead;
}
LinkListElement *LinkList::RemoveAtFront()
{
   LinkListElement *remove = head;
   <strong class="bold">head = head-&gt;GetNext();</strong>  // head = head-&gt;next;
   current = head;    // reset current for usage elsewhere
   return remove;
}</pre>
<p>As we examine the aforementioned code, we<a id="_idIndexMarker833"/> can see that in a sampling of <code>LinkList</code> methods, a <code>LinkListElement</code> can call private methods on itself because it is in the scope of a friend function (which is essentially its own scope, widened). For example, in <code>LinkList::InsertAtFront()</code>, <code>LinkListElement *temp</code> sets its <code>next</code> member to <code>head</code> using <code>temp-&gt;SetNext(head)</code>. Certainly, we could<a id="_idIndexMarker834"/> have also directly accessed the private data member here using <code>temp-&gt;next = head;</code>. However, we maintained a modicum of encapsulation by <code>LinkListElement</code> providing private access functions, such as <code>SetNext()</code>, and asking <code>LinkList</code> methods (friend functions) to have <code>temp</code> utilize private method <code>SetNext()</code>, rather than just directly manipulating the data member itself. </p>
<p>Because <code>GetData()</code>, <code>GetNext()</code>, and <code>SetNext()</code> in <code>LinkListElement</code> are inline functions, we do not forfeit performance by providing a sense of encapsulated access to members <code>data</code> and <code>next</code>.</p>
<p>We can similarly see that other member functions of <code>LinkList</code>, such as <code>RemoveAtFront()</code> (and <code>Print()</code> which appears in th<a id="_idTextAnchor540"/>e online code) have <code>LinkListElement</code> instances utilizing its private access methods, rather than allowing the <code>LinkListElement</code> instances to grab their private <code>data</code> and <code>next</code> members directly. </p>
<p><code>LinkListElement</code> and <code>LinkList</code> are iconic examples of two tightly coupled classes in which it may be better to extend one class to include the other’s scope for access, rather than providing an <em class="italic">overly public</em> interface. After all, we wouldn’t want users in <code>main()</code> to get their hands on a <code>LinkListElement</code> and apply <code>SetNext()</code>, for example, which could change an entire <code>LinkedList</code> without the <code>LinkList<a id="_idTextAnchor541"/><a id="_idTextAnchor542"/></code> class’ knowledge.</p>
<p>Now that we have seen the mechanics as well as suggested usage for friend functions and classes, let’s explore<a id="_idIndexMarker835"/> another language feature that may need to <a id="_idIndexMarker836"/>utilize friends – that of operator overloading.</p>
<h1 id="_idParaDest-209"><a id="_idTextAnchor543"/>Deciphering operator overloading essentials</h1>
<p>C++ has a variety of operators in the language. C++ allows most operators to be redefined to include usage<a id="_idIndexMarker837"/> with user defined types; this is known as <strong class="bold">operator overloading</strong>. In this way, user <a id="_idIndexMarker838"/>defined types may utilize the same notation as standard types to perform these well-understood operations. We can view an overloaded operator as polymorphic in that its same form can be used with a variety of types – standard and user defined.</p>
<p>Not all operators may be overloaded in C++. The following operators cannot be overloaded: the member access operator (<code>.</code>), the ternary conditional operator (<code>?:</code>), the scope resolution operator (<code>::</code>), the pointer-to-member operator (<code>.*</code>), the <code>sizeof()</code> operator, and the <code>typeid()</code> operator. All the rest may be overloaded, provided at least one operand is a user defined type.</p>
<p>When overloading an operator, it is important to promote the same meaning that the operator has for standard types. For example, the extraction operator (<code>&lt;&lt;</code>) is defined when used in conjunction with <code>cout</code> to print to standard output. This operator can be applied to various standard types, such as integers, floating-point numbers, character strings, and so on. Should the extraction operator (<code>&lt;&lt;</code>) be overloaded for a user defined type, such as <code>Student</code>, it should also mean to print to standard output. In this fashion, operator <code>&lt;&lt;</code> is polymorphic when used in the context of an output buffer, such as <code>cout</code>; that is, it has the same meaning but different implementation for all types.</p>
<p>It is important to note that when overloading an operator in C++, we may not change the predefined precedence of the operators as they occur in the language. This makes sense – we are not rewriting the compiler to parse and interpret expressions differently. We are merely extending the meaning of an operator from its usage with standard types to include usage with user defined types. Operator precedence will remain unchanged.</p>
<p>An <code>operator</code>, followed by the symbol representing the operator which you wish to overload.</p>
<p>Let’s take a look at the simple syntax of an operator function prototype:</p>
<pre class="source-code">
Student &amp;<strong class="bold">operator+</strong>(float gpa, const Student &amp;s);</pre>
<p>Here, we intend to provide a means to add a floating-point number and a <code>Student</code> instance using the C++ addition operator (<code>+</code>). The meaning of this addition might be to average the new floating-point number with the student’s existing grade point average. Here, the name of the operator function is <code>operator+()</code>.</p>
<p>In the aforementioned <a id="_idIndexMarker840"/>prototype, the operator function is not a member function of any class. The left expected operand will be a <code>float</code> and the right operand will be a <code>Student</code>. The return type of the function (<code>Student &amp;</code>) allows us to cascade the use of <code>+</code> with multiple operands or be paired with multiple operators, such as <code>s1 = 3.45 + s2;</code>. The overall concept is that we can define how to use <code>+</code> with multiple types, provided at least one operand is a user defined type.</p>
<p>There’s actually a lot more involved than the simple syntax shown in the previous prototype. Before we fully examine a detailed example, let’s first take a look at more logistics relating to impleme<a id="_idTextAnchor544"/>nting operator functions.</p>
<h2 id="_idParaDest-210">Implementing operator functions and knowing when f<a id="_idTextAnchor545"/><a id="_idTextAnchor546"/>riends might be necessary</h2>
<p>An <strong class="bold">operator function</strong>, the mechanism to overload an operator, may be implemented as a member function or as a regular, external function. Let’s summarize the mechanics of implementing operator functions<a id="_idIndexMarker841"/> with the following key points: </p>
<ul>
<li>Operator functions that are implemented as member functions will receive an implicit argument (the <code>this</code> pointer), plus, at most, one explicit argument. If the left operand in the overloaded operation is a user defined type in which modifications to the class can easily be made, implementing the operator function as a member function is reasonable and preferred.</li>
<li>Operator functions that are implemented as external functions will receive one or two explicit arguments. If the left operand in the overloaded operation is a standard type or a class type that is not modifiable, then an external (non-member) function must be used to overload this operator. This external function may need to be a <code>friend</code> of any object type that is used as the right-hand function argument.</li>
<li>Operator functions should most often be implemented reciprocally. That is, when overloading a binary operator, ensure that it has been defined to work no matter what order the <a id="_idIndexMarker842"/>data types (should they differ) appear in the operator. </li>
</ul>
<p>Let’s take a look at a full program example to illustrate the mechanics of operator overloading, including member and non-member functions, as well as scenarios requiring the usage of friends. Though some well-known portions of the program have been excluded to save space, the full program example can be found onli<a id="_idTextAnchor547"/>ne in our GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter12/Chp12-Ex3.cpp</a></p>
<pre class="source-code">
// Assume usual header files and std namespace inclusions
class Person
{
private: 
    string firstName, lastname;
    char middleInitial = '\0';
    char *title = nullptr; // use ptr member to demonstrate
                           // deep assignment
protected:
    void ModifyTitle(const string &amp;); // converts to char *
public:                               
    Person() = default;   // default constructor
    Person(const string &amp;, const string &amp;, char, 
           const char *);  
    Person(const Person &amp;);  // copy constructor
    virtual ~Person();  // virtual destructor
    const string &amp;GetFirstName() const 
        { return firstName; }  
    const string &amp;GetLastName() const { return lastName; }    
    const char *GetTitle() const { return title; } 
    char GetMiddleInitial() const { return middleInitial; }
    virtual void Print() const;
  <a id="_idTextAnchor548"/>  virtual void IsA() const;
    <strong class="bold">// overloaded operator functions</strong>
    <strong class="bold">Person &amp;operator=(const Person &amp;);</strong> <strong class="bold">// overloaded assign</strong>
    <strong class="bold">bool operator==(const Person &amp;);</strong>   <strong class="bold">// overloaded</strong>
<strong class="bold">                                       // comparison</strong>
    <strong class="bold">Person &amp;operator+(const string &amp;);</strong> <strong class="bold">// overloaded plus</strong>
    <strong class="bold">// non-mbr friend fn. for op+ (to make associative)</strong>
    <strong class="bold">friend Person &amp;operator+(const string &amp;, Person &amp;);</strong>  
};</pre>
<p>Let’s begin our code examination by first looking at the preceding class definition for <code>Person</code>. In addition to the class elements that we are accustomed to seeing, we have four operator functions prototyped: <code>operator=()</code>, <code>operator==()</code>, and <code>operator+()</code> (which is implemented twice so that the operands to <code>+</code> can be reversed).</p>
<p>Functions for <code>operator=()</code>, <code>operator==()</code>, and one version of <code>operator+()</code> will be implemented as member functions of this class, whereas the other <code>operator+()</code>, with <code>const char *</code> and <code>Person</code> parameters, will be implemented as a non-member function and will additionally necessitate the use of a friend function.</p>
<h3>Overloading the assignment operator</h3>
<p>Let’s move forward to examine<a id="_idIndexMarker843"/> the applicable operator function definitions for this class, starting by overloading the assignment operator:</p>
<pre class="source-code">
// Assume the required constructors, destructor and basic
// member functions prototyped in the class def. exist.
<strong class="bold">// overloaded assignment operator</strong>
<strong class="bold">Person &amp;Person::operator=(const Person &amp;p)</strong>
{
    if (this != &amp;p)  <strong class="bold">// make sure we're not assigning an</strong> 
    {                <strong class="bold">// object to itself</strong>
        // delete any previously dynamically allocated data 
        // from the destination object
        delete title;
        // Also, remember to reallocate memory for any 
        // data members that are pointers
        // Then, copy from source to destination object 
        // for each data member
        firstName = p.firstName;
        lastName = p.lastName;
        middleInitial = p.middleInitial;
        // Note: a pointer is used for title to demo the
        // necessary steps to implement a deep assignment -
        // otherwise, we would implement title with string
        title = new char[strlen(p.title) + 1]; // mem alloc
        strcpy(title, p.title);
    }
    return *this;  // allo<a id="_idTextAnchor549"/>w for cascaded assignments
}</pre>
<p>Let us now review the overloaded assignment operator in the preceding code. It is designated by the member function <code>Person &amp;Person::operator=(const Person &amp;p);</code>. Here, we will be assigning memory from a source object, which will be input parameter <code>p</code>, to a destination object, which will be pointed to by <code>this</code>. </p>
<p>Our first order of business will be to <a id="_idIndexMarker844"/>ensure that we are not assigning an object to itself. Should this be the case, there is no work to be done! We make this check by testing <code>if (this != &amp;p)</code> to see whether both addresses point to the same object. If we’re not assigning an object to itself, we continue.</p>
<p>Next, within the conditional statement (<code>if</code>), we first deallocate the existing memory for the dynamically allocated data members pointed to by <code>this</code>. After all, the object on the left-hand of the assignment pre-exists and undoubtedly has allocations for these data members. </p>
<p>Now, we notice that the core piece of code within the conditional statement looks very similar to that of the copy constructor. That is, we carefully allocate space for pointer data members to match the sizes needed from their corresponding data members of input parameter <code>p</code>. We then copy the applicable data members from input parameter <code>p</code> to the data members pointed to by <code>this</code>. For the <code>char</code> data member, <code>middleInitial</code>, a memory allocation is not necessary; we merely use an assignment. This is also true for the <code>string</code> data members, <code>firstName</code> and <code>lastName</code>. In this segment of code, we ensure that we have performed a deep assignment for any pointer data members. A shallow (pointer) assignment, where the source and destination object would otherwise share memory for the data portions of data members that are pointers, would be a disaster waiting to happen.</p>
<p>Lastly, at the end of our implementation of <code>operator=()</code>, we return <code>*this</code>. Notice that the return type from this function is a reference to a <code>Person</code>. Since <code>this</code> is a pointer, we merely dereference it so that we may return a referenceable object. This is done so that assignments between <code>Person</code> instances can be cascaded; that is, <code>p1 = p2 = p3;</code> where <code>p1</code>, <code>p2</code>, and <code>p3</code> are each an instance of <code>Person</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">When overloading <code>operator=</code>, always check for self-assignment. That is, make sure you are not assigning an object to itself. Not only is there no work to be done in the case of self-assignment, but proceeding with an unnecessary self-assignment can actually create unexpected errors! For example, if we have dynamically allocated data members, we will be releasing destination object memory and re-allocating those data members based on the details of the source object’s memory (which, when being the same object, will have been released). The resulting behavior can be unpredictable and error-prone.</p>
<p>Should the programmer<a id="_idIndexMarker845"/> wish to disallow assignment between two objects, the keyword <code>delete</code> can be used in the prototype of the overloaded assignment operator as follows:</p>
<pre class="source-code">
    <strong class="bold">// disallow assignment</strong>
    Person &amp;operator=(const Person &amp;) <strong class="bold">= delete</strong>;<strong class="bold"> </strong></pre>
<p>It is useful to remember that an overloaded assignment operator shares many similarities with the copy constructor; the same care and cautions apply to both language features. Keep in mind, however, that the assignment operator will be invoked when conducting an assignment between two pre-existing objects, whereas the copy constructor is implicitly invoked for initialization following the creation of a new instance. With the copy constructor, the new instance uses the existing instance as its basis for initialization; similarly, the left-hand object of the assignment operator uses the right-hand object as its basis for the assignment.</p>
<p class="callout-heading">Important note</p>
<p class="callout">An overloaded assignment operator is not inherited by derived classes; therefore, it must be defined by each class in the hierarchy. Neglecting to overload <code>operator=</code> for a class will force the compiler to provide you with a default, shallow assignment operator for that class; this is dangerous for any classes containing data members that are pointers.</p>
<h3>Overloading the comparison operator</h3>
<p>Next, let’s take a look at our<a id="_idIndexMarker846"/> implementation of the overloaded comparison operator:</p>
<pre class="source-code">
<strong class="bold">// overloaded comparison operator</strong>
<strong class="bold">bool Person::operator==(const Person &amp;p)</strong>
{   
    // if the objects are the same object, or if the
    // contents are equal, return true. Otherwise, false.
    if (this == &amp;p) 
        return true;
    else if ( (!firstName.compare(p.firstName)) &amp;&amp;
              (!lastName.compare(p.lastName)) &amp;&amp;
              (!strcmp(title, p.title)) &amp;&amp;
              (middleInitial == p.middleInitial) )
        return true;
    else
        return false;
}</pre>
<p>Continuing with a segment<a id="_idIndexMarker847"/> from our previous program, we overload the comparison operator. It is designated by the member function <code>int Person::operator==(const Person &amp;p);</code>. Here, we will be comparing a <code>Person</code> object on the right-hand side of the operator, which will be referenced by input parameter <code>p</code>, to a <code>Person</code> object on the left-hand side of the operator, which will be pointed to by <code>this</code>. </p>
<p>Similarly, our first order of business will be to test whether the object on the <code>if (this != &amp;p)</code> to see whether both addresses point to the same object. If both addresses point to the same object, we return the boolean (<code>bool</code>) value of <code>true</code>. </p>
<p>Next, we check whether the two <code>Person</code> objects contain identical values. They may be separate objects in memory, yet if they contain identical values, we can likewise choose to return a <code>bool</code> value of <code>true</code>. If there is no match, we then return a <code>bool</code> value of <code>false</code>. </p>
<h3>Overloading the addition operator as a member function</h3>
<p>Now, let’s take a look at how to <a id="_idIndexMarker848"/>overload <code>operator+</code> for <code>Person</code> and a <code>string</code>:</p>
<pre class="source-code">
<strong class="bold">// overloaded operator + (member function)</strong>
<strong class="bold">Person &amp;Person::operator+(const string &amp;t)</strong>
{
    ModifyTitle(t);
    return *this;
}</pre>
<p>Moving forward with the preceding program, we overload the addition operator (<code>+</code>) to be used with a <code>Person</code> and a <code>string</code>. The operator function is designated by the member function prototype <code>Person&amp; Person::operator+(const string &amp;t);</code>. The parameter, <code>t</code>, will represent the right operand of <code>operator+</code>, which is a character string (which will bind to a reference to a string). The left-hand operand will be pointed to by <code>t<a id="_idTextAnchor550"/>his</code>. An example use would be <code>p1 + "Miss"</code>, where we wish to add a <code>title</code> to the <code>Person</code> <code>p1</code> using <code>operator+</code>. </p>
<p>In the body of this member function, we merely use the input parameter <code>t</code> as an argument to <code>ModifyTitle()</code>, that is, <code>ModifyTitle(t);</code>. We then return <code>*this</code> so that we may cascade the use of this operator (notice the return type is a <code>Person &amp;</code>).</p>
<h3>Overloading the addition operator as a non-member function (using friends)</h3>
<p>Now, let’s reverse the order of<a id="_idIndexMarker849"/> operands with <code>operator+</code> to allow for a <code>string</code> and a <code>Person</code>:</p>
<pre class="source-code">
<strong class="bold">// overloaded + operator (not a mbr function) </strong>
<strong class="bold">Person &amp;operator+(const string &amp;t, Person &amp;p)</strong>
{
    p.ModifyTitle(t);
    return p;
}</pre>
<p>Continuing forward with the preceding program, we would ideally like <code>operator+</code> to work not only with a <code>Person</code> and a <code>string</code> but also with the operands reversed, that is, with a <code>string</code> and a <code>Person</code>. There is no reason this operator should work one way and not the other. </p>
<p>To implement <code>operator+</code> fully, we next overload <code>operator+()</code> to be used with <code>const string &amp;</code> and <code>Person</code>. The operator function is designated by the non-member function <code>Person&amp; operator+(const string &amp;t, Person &amp;p);</code>, which has two explicit input parameters. The first parameter, <code>t</code>, will represent the left operand of <code>operator+</code>, which is a character string (binding this parameter to a reference to a string as the first<a id="_idIndexMarker850"/> formal parameter in the operator function). The second parameter, <code>p</code>, will be a reference to the right operand used in<a id="_idTextAnchor551"/> <code>operator+</code>. An example use might be <code>"Miss" + p1</code>, where we wish to add a title to the <code>Person p1</code> using <code>operator+</code>. Note that <code>"Miss"</code> will be constructed as a <code>string</code> using the <code>std::string(const char *)</code> constructor—the string literal is simply the initial value for the string object.</p>
<p>In the body of this non-member function, we merely take input parameter <code>p</code> and apply the protected method <code>ModifyTitle()</code> using the string of characters specified by parameter <code>t</code>, that is, <code>p.ModifyTitle(t)</code>. However, because <code>Person::ModifyTitle()</code> is protected, <code>Person &amp;p</code> may not invoke this method outside of member functions of <code>Person</code>. We are in an external function; we are not in the scope of <code>Person</code>. Therefore, unless this member function is a <code>friend</code> of <code>Person</code>, <code>p</code> may not invoke <code>ModifyTitle()</code>. Luckily, <code>Person &amp;operator+(const string &amp;, Person &amp;);</code> has been prototyped as a friend function in the <code>Person</code> class, providing the necessary scope to <code>p</code> to allow it to invoke its protected method. It is as if <code>p</code> is in the scope of <code>Person</code>; it is in the scope of a friend function of <code>Person</code>!</p>
<p>Let us now move forward to our <code>main()</code> function, tying together our many aforementioned code segments, so we may see how to invoke our operator functions utilizing our overloaded operators:</p>
<pre class="source-code">
int main()
{
    Person p1;      // default constructed Per<a id="_idTextAnchor552"/>son
    Person p2("Gabby", "Doone", 'A', "Miss");
    Person p3("Renee", "Alexander", 'Z', "Dr.");
    p1.Print();
    p2.Print();
    p3.Print();  
    <strong class="bold">p1 = p2;</strong>       <strong class="bold">// invoke overloaded assignment operator</strong>
    p1.Print();
    <strong class="bold">p2 = "Ms." + p2;</strong>  <strong class="bold">// invoke overloaded + operator</strong>
    p2.Print();       <strong class="bold">// then invoke overloaded = operator</strong>
    <strong class="bold">p1 = p2 = p3;</strong>     <strong class="bold">// overloaded = can handle cascaded =</strong>
    p2.Print();     
    p1.Print();
    if (<strong class="bold">p2 == p2</strong>)   <strong class="bold">// overloaded<a id="_idTextAnchor553"/> comparison operator</strong>
       cout &lt;&lt; "Same people" &lt;&lt; endl;
    if (<strong class="bold">p1 == p3</strong>)
       cout &lt;&lt; "Same people" &lt;&lt; endl;
   return 0;
}</pre>
<p>Finally, let us examine our <code>main()</code> function for the preceding program. We begin by instantiating three<a id="_idIndexMarker851"/> instances of <code>Person</code>, namely <code>p1</code>, <code>p2</code>, and <code>p3</code>; we then print their values using member function <code>Print()</code> for each instance.</p>
<p>Now, we invoke our overloaded assignment operator with the statement <code>p1 = p2;</code>. Under the hood, this translates to the following operator function invocation: <code>p1.operator=(p2);</code>. From this, we can clearly see that we are invoking the previously defined <code>operator=()</code> method of <code>Person</code>, which performs a deep copy from source object <code>p2</code> to destination object <code>p1</code>. We apply <code>p1.Print();</code> to see our resulting copy.</p>
<p>Next, we invoke our overloaded <code>operator+</code> with <code>"Ms." + p2</code>. This portion of this line of code translates to<a id="_idIndexMarker852"/> the follow<a id="_idTextAnchor554"/>ing operator function call: <code>operator+("Ms.", p2);</code>. Here, we simply invoke our previously described <code>operator+()</code> function, which is a non-member function and <code>friend</code> of the <code>Person</code> class. Because this function returns a <code>Person &amp;</code>, we can cascade this function call to look more like the usual context of ad<a id="_idTextAnchor555"/>dition and additionally write <code>p2 = "Ms." + p2;</code>. In this full line of code, first, <code>operator+()</code> is invoked for <code>"Ms." + p2</code>. The return value of this invocation is <code>p2</code>, which is then used as the right-hand operand of the cascaded call to <code>operator=</code>. Notice that the left-hand operand to <code>operator=</code> also happens to be <code>p2</code>. Fortunately, the overloaded assignment operator checks for self-assignment.</p>
<p>Now, we see a cascaded assignment of <code>p1 = p2 = p3;</code>. Here, we are invoking the overloaded assignment operator twice. First, we invoke <code>operator=</code> with <code>p2</code> and <code>p3</code>. The translated call would be <code>p2.operator=(p3);</code>. Then, using the return value of the first function call, we would invoke <code>operator=</code> a second time. The nested, translated call for <code>p1 = p2 = p3;</code> would look like this: <code>p1.operator=(p2.operator=(p3));</code>.</p>
<p>Lastly in this program, we invoke the overloaded comparison operator twice. For example, each comparison of <code>if (p2 == p2)</code> or <code>if (p1 == p3)</code> merely calls the <code>operator==</code> member function we have defined previously. Recall that we’ve written this function to report <code>true</code> either if the objects are the same in memory or simply contain the same values, and return <code>false</code> otherwise.</p>
<p>Let’s take a look at the output for this program:</p>
<pre>No first name No last name
Miss Gabby A. Doone
Dr. Renee Z. Alexander
Miss Gabby A. Doone
Ms. Gabby A. Doone
Dr. Renee Z. Alexander
Dr. Renee Z. Alexander
Same people
Same people</pre>
<p>We have now seen how to <a id="_idIndexMarker853"/>specify and utilize friend classes and friend functions, how to overload C++ operators, and have seen cases when these two concepts can complement each other. Let us now briefly recap the features we have learned in this chapter before moving forward to our next chapter.</p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor556"/>Summary</h1>
<p>In this chapter, we have furthered our C++ programming endeavors beyond OOP language features to include features that will enable us to write more extensible programs. We have learned how to utilize friend functions and friend classes and we have learned how to overload operators in C++.</p>
<p>We have seen that friend functions and classes should be used sparingly and with caution. They are not meant to provide a blatant means to circumvent access regions. Instead, they are meant to handle programming situations to allow access between two tightly coupled classes without providing the alternative of an <em class="italic">overly public</em> interface in either of those classes, which could be misused on a broader scale.</p>
<p>We have seen how to overload operators in C++ using operator functions, both as member and non-member functions. We have learned that overloading operators will allow us to extend the meaning of C++ operators to include user defined types in the same way they encompass standard types. We have also seen that, in some cases, friend functions or classes may come in handy to help implement operator functions so they may behave associatively.</p>
<p>We have added important features to our C++ repertoire through exploring friends and operator overloading, the latter of which will help us to ensure code we will soon write using templates can be used for nearly any data type, contributing to highly extensible and reusable code. We are now ready to move forward to <a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em>, so that we can continue expanding our C++ programming skills with essential language features that will make us better p<a id="_idTextAnchor557"/>rogrammers. Let’s move ahead!</p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor558"/>Questions</h1>
<ol>
<li>Overload <code>operator=</code> in your <code>Shape</code> exercise from <a href="B19087_08.xhtml#_idTextAnchor399"><em class="italic">Chapter 8</em></a>, <em class="italic">Mastering Abstract Classes</em>, or alternatively, overload <code>operator=</code> in your ongoing <code>LifeForm</code>/<code>Person</code>/<code>Student</code> classes as follows:</li>
</ol>
<p>Define <code>operator=</code> in <code>Shape</code> (or <code>LifeForm</code>) and override this method in all of its derived classes. Hint: the derived implementation of <code>operator=()</code> will do more work than its ancestor, yet could call its ancestor’s implementation to perform the base class part of the work.</p>
<ol>
<li value="2">Overload <code>operator&lt;&lt;</code> in your <code>Shape</code> class (or <code>LifeForm</code> class) to print information about each <code>Shape</code> (or <code>LifeForm</code>). The arguments to this function should be an <code>ostream &amp;</code> and a <code>Shape &amp;</code> (or a <code>LifeForm &amp;</code>). Note that <code>ostream</code> is from the C++ St<a id="_idTextAnchor559"/>andard Library (<code>using namespace std;</code>).</li>
</ol>
<p>You may<a id="_idTextAnchor560"/> either provide one function, <code>ostream &amp;operator&lt;&lt;(ostream &amp;, Shape &amp;);</code>, and from it call a polymorphic <code>Print()</code>, which is defined in <code>Shape</code> and redefined in each derived class. Or, provide multiple <code>operator&lt;&lt;</code> methods to implement this functionality (one for each derived class). If using the <code>Lifeform</code> hierarchy, substitute <code>LifeForm</code> for <code>Shape</code>, in the aforementioned <code>operator&lt;&lt;</code> function signature. </p>
<ol>
<li value="3">Create an <code>ArrayInt</code> class to provide safe integer arrays with bounds checking. Overload <code>operator[]</code> to return an element if it exists in the array, or throw an exception if it is <code>OutOfBounds</code>. Add other methods to <code>ArrayInt</code>, such as <code>Resize()</code>, <code>RemoveElement()</code>, and so on. Model the data comprising the array using a dynamically allocated array (that is, using <code>int *contents</code>) so that you can easily handle resizing. The code would begin as follows:<pre>class ArrayInt // starting point for the class def.
{          // be sure to add: using std::to_string;
private:   // and also: using std::out_of_range;
    int numElements = 0;     // in-class init.
    int *contents = nullptr; // dynam. alloc. array
public:
    ArrayInt(int size); // set numElements and
                        // allocate contents
    // returns a referenceable memory location or
    // throws an exception
    <strong class="bold">int &amp;operator[](int index</strong>) 
    {             
        if (index &lt; numElements) 
            return contents[index];
        else    // index is out of bounds
            throw std::out_of_range(
                              std::to_string(index));
    }                        
};
int main()
{
    ArrayInt a1(5); // Create ArrayInt of 5 elements
    try
    {
        <strong class="bold">a1[4] = 7;</strong>      // a1.operator[](4) = 7;
    }
    catch (const std::out_of_range &amp;e)
    {
        cout &lt;&lt; "Out of range: " &lt;&lt; e.what() &lt;&lt; endl;
    }
}</pre></li>
</ol>
</div>
<div><div></div>
</div>
</div></body></html>