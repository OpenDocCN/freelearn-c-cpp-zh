<html><head></head><body>
		<div id="_idContainer127">
			<h1 id="_idParaDest-400"><a id="_idTextAnchor414"/><em class="italic">Chapter 20</em>: Game Objects and Components</h1>
			<p>In this chapter, we will be doing all the coding related to the Entity-Component pattern we discussed at the beginning of the previous chapter. This means we will code the base <strong class="source-inline">Component</strong> class, which all the other components will be derived from. We will also put our new knowledge of smart pointers to good use so that we don't have to concern ourselves with keeping track of the memory we allocate for these components. We will also code the <strong class="source-inline">GameObject</strong> class in this chapter.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Preparing to code the components</li>
				<li>Coding the Component base class</li>
				<li>Coding the collider components</li>
				<li>Coding the graphics components</li>
				<li>Coding the update components</li>
				<li>Coding the GameObject class</li>
			</ul>
			<p>Let's discuss the components a bit more before we start coding. Please note that, in this chapter, I will try and reinforce how the Entity-Component system fits together and how all the components compose a game object. I will not be explaining each and every line or even block of logic or SFML-related code that we have seen many times already. It is up to you to study these details.</p>
			<h1 id="_idParaDest-401"><a id="_idTextAnchor415"/>Preparing to code the components</h1>
			<p>As you work through this chapter, there will be lots of errors, and some of them won't seem logical. For example, you will get errors saying that a class doesn't exist when it is one of the classes you have already coded. The reason for this is that, when a class has an error in it, other classes can't reliably use it without getting errors as well. It is because of the interconnected nature of all the classes that we will not get rid of all the errors and have executable code again until near the end of the next chapter. It would have been possible to add code in smaller chunks to the various classes and the project would have been error-free more frequently. Doing things that gradually, however, would have meant constantly dipping in and out of classes. When you are building your own projects, this is sometimes a good way to do it, but I thought the most instructive thing to do for this project would be to help you get it built as quickly as possible. </p>
			<h1 id="_idParaDest-402"><a id="_idTextAnchor416"/>Coding the Component base class</h1>
			<p>Create a new header file in the <strong class="source-inline">Header Files/GameObjects</strong> filter called <strong class="source-inline">Component.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "GameObjectSharer.h"</p>
			<p class="source-code">#include &lt;string&gt;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">class GameObject;</p>
			<p class="source-code">class Component {</p>
			<p class="source-code">public:</p>
			<p class="source-code">    virtual string getType() = 0;</p>
			<p class="source-code">    virtual string getSpecificType() = 0;</p>
			<p class="source-code">    virtual void disableComponent() = 0;</p>
			<p class="source-code">    virtual void enableComponent() = 0;</p>
			<p class="source-code">    virtual bool enabled() = 0;</p>
			<p class="source-code">    virtual void start(GameObjectSharer* gos, GameObject* self) = 0;</p>
			<p class="source-code">};</p>
			<p>This is the base class of every component in every game object. The pure virtual functions mean that a component can never be instantiated and must always be inherited from first. Functions allow the type and specific type of a component to be accessed. Component types include collider, graphics, transform, and update, but more types could be added in line with the requirements of the game. Specific types include standard graphics, invader update, player update, and more besides.</p>
			<p>There are two functions that allow the component to be enabled and disabled. This is useful because a component can then be tested for whether it is currently enabled before it is used. For example, you could call the <strong class="source-inline">enabled</strong> function to test whether a component's update component was enabled before calling its <strong class="source-inline">update</strong> function or that a graphics component is enabled before calling its <strong class="source-inline">draw</strong> function. </p>
			<p>The <strong class="source-inline">start</strong> function is probably the most interesting function because it has a new class type as one of its parameters. The <strong class="source-inline">GameObjectSharer</strong> class will give access to all the game objects after they have been instantiated with all their components. This will give every component in every game object the opportunity to query details and even obtain a pointer to a specific piece of data in another game object. As an example, all an invader's update components will need to know the location of the player's transform component so that it knows when to fire a bullet. Absolutely any part of any object can be accessed in the <strong class="source-inline">start</strong> function. The point is that each specific component will decide what they need and there is no requirement during the critical game loop to start querying for the details of another game object.</p>
			<p>The <strong class="source-inline">GameObject</strong> that the component is contained in is also passed to the <strong class="source-inline">start</strong> function so that any component can find out more about itself as well. For example, a graphics component needs to know about the transform component so that it knows where to draw itself. As a second example, the update components of the invaders and the player's ship will need a pointer to their own collider component so that they can update its location whenever they move. </p>
			<p>We will see more use cases for the <strong class="source-inline">start</strong> function as we progress.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/GameObjects</strong> filter called <strong class="source-inline">Component.cpp</strong> and add the following code:</p>
			<p class="source-code">/*********************************</p>
			<p class="source-code">******THIS IS AN INTERFACE********</p>
			<p class="source-code">*********************************/</p>
			<p>As the <strong class="source-inline">Component</strong> class can never be instantiated, I have put the preceding comments in <strong class="source-inline">Component.cpp</strong> as a reminder.</p>
			<h1 id="_idParaDest-403"><a id="_idTextAnchor417"/>Coding the collider components</h1>
			<p>The Space Invaders ++ game will only have one simple type of collider. It will be a rectangular box around the object, just like those we had in the Zombie Apocalypse and Pong games. However, it is easily conceivable that you might need other types of collider; perhaps a circle-shaped collider or a non-encompassing collider such as those we used for the head, feet, and sides of Thomas and Bob back in the Thomas Was Late game.</p>
			<p>For this reason, there will be a base <strong class="source-inline">ColliderComponent</strong> class (that inherits from <strong class="source-inline">Component</strong>) which will handle the basic functionality of all the colliders, as well as <strong class="source-inline">RectColliderComponent</strong>, which will add the specific functionality of an all-encompassing rectangle-shaped collider. New collider types can then be added as required for the game being developed.</p>
			<p>What follows is the base class to the specific collider, <strong class="source-inline">ColliderComponent</strong>.</p>
			<h2 id="_idParaDest-404"><a id="_idTextAnchor418"/>Coding the ColliderComponent class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/GameObjects</strong> filter called <strong class="source-inline">ColliderComponent.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "Component.h"</p>
			<p class="source-code">#include &lt;iostream&gt;</p>
			<p class="source-code">class ColliderComponent : public Component</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    string m_Type = "collider";</p>
			<p class="source-code">    bool m_Enabled = false;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    /****************************************************</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    From Component interface</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    *****************************************************/</p>
			<p class="source-code">    string Component::getType() {</p>
			<p class="source-code">        return m_Type;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void Component::disableComponent() {</p>
			<p class="source-code">        m_Enabled = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void Component::enableComponent() {</p>
			<p class="source-code">        m_Enabled = true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    bool Component::enabled() {</p>
			<p class="source-code">        return m_Enabled;</p>
			<p class="source-code">    }</p>
			<p class="source-code">   void Component::start(GameObjectSharer* gos, GameObject* self)</p>
			<p class="source-code">   {</p>
			<p class="source-code">        </p>
			<p class="source-code">    }</p>
			<p class="source-code">};</p>
			<p>The <strong class="source-inline">ColliderComponent</strong> class inherits from the <strong class="source-inline">Component</strong> class. In the preceding code, you can see that the <strong class="source-inline">m_Type</strong> member variable is initialized to <strong class="source-inline">"collider"</strong> and that <strong class="source-inline">m_Enabled</strong> is initialized to <strong class="source-inline">false</strong>.</p>
			<p>In the <strong class="source-inline">public</strong> section, the code overrides the pure virtual functions of the <strong class="source-inline">Component</strong> class. Study them to become familiar with them because they work in a very similar way in all the component classes. The <strong class="source-inline">getType</strong> function returns <strong class="source-inline">m_Type</strong>. The <strong class="source-inline">disableComponent</strong> function sets <strong class="source-inline">m_Enabled</strong> to <strong class="source-inline">false</strong>. The <strong class="source-inline">enableComponent</strong> function sets <strong class="source-inline">m_Enabled</strong> to <strong class="source-inline">true</strong>. The <strong class="source-inline">enabled</strong> function returns the value of <strong class="source-inline">m_Enabled</strong>. The <strong class="source-inline">start</strong> function has no code but will be overridden by many of the more specific component-based classes.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/GameObjects</strong> filter called <strong class="source-inline">ColliderComponent.cpp</strong> and add the following code:</p>
			<p class="source-code">/*</p>
			<p class="source-code">All Functionality in ColliderComponent.h</p>
			<p class="source-code">*/</p>
			<p>I added the preceding comments to <strong class="source-inline">ColliderComponent.cpp</strong> to remind myself that all the functionality is in the header file.</p>
			<h2 id="_idParaDest-405"><a id="_idTextAnchor419"/>Coding the RectColliderComponent class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/GameObjects</strong> filter called <strong class="source-inline">RectColliderComponent.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "ColliderComponent.h"</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class RectColliderComponent : public ColliderComponent</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    string m_SpecificType = "rect";</p>
			<p class="source-code">    FloatRect m_Collider;</p>
			<p class="source-code">    string m_Tag = "";</p>
			<p class="source-code">public:</p>
			<p class="source-code">    RectColliderComponent(string name);</p>
			<p class="source-code">    string getColliderTag();</p>
			<p class="source-code">    void setOrMoveCollider(</p>
			<p class="source-code">        float x, float y, float width, float height);</p>
			<p class="source-code">        </p>
			<p class="source-code">    FloatRect&amp; getColliderRectF();</p>
			<p class="source-code">    /****************************************************</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    From Component interface base class</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    *****************************************************/</p>
			<p class="source-code">    string getSpecificType() {</p>
			<p class="source-code">        return m_SpecificType;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    void Component::start(</p>
			<p class="source-code">        GameObjectSharer* gos, GameObject* self) {}</p>
			<p class="source-code">};</p>
			<p>The <strong class="source-inline">RectColliderComponent</strong> class inherits from the <strong class="source-inline">ColliderComponent</strong> class. It has a <strong class="source-inline">m_SpecificType</strong> variable initialized to <strong class="source-inline">"rect"</strong>. It is now possible to query any <strong class="source-inline">RectColliderComponent</strong> instance in a vector of generic <strong class="source-inline">Component</strong> instances and determine that it has a type of  <strong class="source-inline">"collider"</strong> and a specific type of  <strong class="source-inline">"rect"</strong>. All component-based classes will have this functionality because of the pure virtual functions of the <strong class="source-inline">Component</strong> class.</p>
			<p>There is also a <strong class="source-inline">FloatRect</strong> instance called <strong class="source-inline">m_Collider</strong> that will store the coordinates of this collider.</p>
			<p>In the <strong class="source-inline">public</strong> section, we can view the constructor. Notice that it receives a <strong class="source-inline">string</strong>. The value that's passed in will be text that identifies the type of game object this <strong class="source-inline">RectColliderComponent</strong> is attached to, such as an invader, a bullet, or the player's ship. It will then be possible to determine what type of objects have collided with each other.</p>
			<p>There are three more functions before the overridden functions; make a note of their names and parameters and then we will discuss them in a moment when we code their definitions.</p>
			<p>Note that the <strong class="source-inline">getSpecificType</strong> function definition returns <strong class="source-inline">m_SpecificType</strong>.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/GameObjects</strong> filter called <strong class="source-inline">RectColliderComponent.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "RectColliderComponent.h"</p>
			<p class="source-code">RectColliderComponent::RectColliderComponent(string name) {</p>
			<p class="source-code">    m_Tag = "" + name;</p>
			<p class="source-code">}</p>
			<p class="source-code">string RectColliderComponent::getColliderTag() {</p>
			<p class="source-code">    return m_Tag;</p>
			<p class="source-code">}</p>
			<p class="source-code">void RectColliderComponent::setOrMoveCollider(</p>
			<p class="source-code">    float x, float y, float width, float height) {</p>
			<p class="source-code">        </p>
			<p class="source-code">    m_Collider.left = x;</p>
			<p class="source-code">    m_Collider.top = y;</p>
			<p class="source-code">    m_Collider.width = width;</p>
			<p class="source-code">    m_Collider.height = height;</p>
			<p class="source-code">}</p>
			<p class="source-code">FloatRect&amp; RectColliderComponent::getColliderRectF() {</p>
			<p class="source-code">    return m_Collider;</p>
			<p class="source-code">}</p>
			<p>In the constructor, the passed-in <strong class="source-inline">string</strong> value is assigned to the <strong class="source-inline">m_Tag</strong> variable and the <strong class="source-inline">getColliderTag</strong> function makes that value available via the instance of the class.</p>
			<p>The <strong class="source-inline">setOrMoveCollider</strong> function positions <strong class="source-inline">m_Collider</strong> at the coordinates passed in as arguments. </p>
			<p>The <strong class="source-inline">getColliderRectF</strong> function returns a reference to <strong class="source-inline">m_Collider</strong>. This is ideal for carrying out a collision test with another collider using the <strong class="source-inline">intersects</strong> function of the <strong class="source-inline">FloatRect</strong> class.</p>
			<p>Our colliders are now complete and we can move on to the graphics.</p>
			<h1 id="_idParaDest-406"><a id="_idTextAnchor420"/>Coding the graphics components</h1>
			<p>The Space Invaders ++ game will only have one specific type of graphics component. It is called <strong class="source-inline">StandardGraphicsComponent</strong>. As with the collider components, we will implement a base <strong class="source-inline">GraphicsComponent</strong> class to make it easy to add other graphics-related components, should we wish. For example, in the classic arcade version of Space Invaders, the invaders flapped their arms up and down with two frames of animation. Once you see how <strong class="source-inline">StandardGraphicsComponent</strong> works, you will be able to easily code another class (perhaps <strong class="source-inline">AnimatedGraphicsComponent</strong>) that draws itself with a different <strong class="source-inline">Sprite</strong> instance every half a second or so. You could also have a graphics component that has a shader (perhaps <strong class="source-inline">ShaderGraphicsComponent</strong>) for fast and cool effects. There are more possibilities besides these.</p>
			<h2 id="_idParaDest-407"><a id="_idTextAnchor421"/>Coding the GraphicsComponent class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/GameObjects</strong> filter called <strong class="source-inline">GraphicsComponent.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "Component.h"</p>
			<p class="source-code">#include "TransformComponent.h"</p>
			<p class="source-code">#include &lt;string&gt;</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "GameObjectSharer.h"</p>
			<p class="source-code">#include &lt;iostream&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">class GraphicsComponent : public Component {</p>
			<p class="source-code">private:</p>
			<p class="source-code">    string m_Type = "graphics";</p>
			<p class="source-code">    bool m_Enabled = false;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    virtual void draw(</p>
			<p class="source-code">        RenderWindow&amp; window,</p>
			<p class="source-code">        shared_ptr&lt;TransformComponent&gt; t) = 0;</p>
			<p class="source-code">    virtual void initializeGraphics(</p>
			<p class="source-code">        string bitmapName,</p>
			<p class="source-code">        Vector2f objectSize) = 0;</p>
			<p class="source-code">    /****************************************************</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    From Component interface</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    *****************************************************/</p>
			<p class="source-code">    string Component::getType() {</p>
			<p class="source-code">        return m_Type;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void Component::disableComponent() {</p>
			<p class="source-code">        m_Enabled = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void Component::enableComponent() {</p>
			<p class="source-code">        m_Enabled = true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    bool Component::enabled() {</p>
			<p class="source-code">        return m_Enabled;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void Component::start(</p>
			<p class="source-code">        GameObjectSharer* gos, GameObject* self) {}</p>
			<p class="source-code">};</p>
			<p>Most of the preceding code implements the <strong class="source-inline">Component</strong> class's pure virtual functions. What's new to the <strong class="source-inline">GraphicsComponent</strong> class is the <strong class="source-inline">draw</strong> function, which has two parameters. The first parameter is a reference to the <strong class="source-inline">RenderWindow</strong> instance so that the component can draw itself, while the second is a shared smart pointer to the <strong class="source-inline">TransformComponent</strong> instance of the <strong class="source-inline">GameObject</strong> so that vital data such as position and scale can be accessed each frame of the game.</p>
			<p>What's also new in the <strong class="source-inline">GraphicsComponent</strong> class is the <strong class="source-inline">initializeGraphics</strong> function, which also has two parameters. The first is a <strong class="source-inline">string</strong> value that represents the file name of the graphics file to be used, while the second is a <strong class="source-inline">Vector2f</strong> instance that will represent the size of the object in the game world. </p>
			<p>Both preceding functions are pure virtual, which makes the <strong class="source-inline">GraphicsComponent</strong> class abstract. Any class that inherits from <strong class="source-inline">GraphicsComponent</strong> will need to implement these functions. In the next section, we will see how <strong class="source-inline">StandardGraphicsComponent</strong> does so.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/GameObjects</strong> filter called <strong class="source-inline">GraphicsComponent.cpp</strong> and add the following code:</p>
			<p class="source-code">/*</p>
			<p class="source-code">All Functionality in GraphicsComponent.h</p>
			<p class="source-code">*/</p>
			<p>The preceding comment is a reminder that the code is all within the related header file.</p>
			<h2 id="_idParaDest-408"><a id="_idTextAnchor422"/>Coding the StandardGraphicsComponent class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/GameObjects</strong> filter called <strong class="source-inline">StandardGraphicsComponent.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "Component.h"</p>
			<p class="source-code">#include "GraphicsComponent.h"</p>
			<p class="source-code">#include &lt;string&gt;</p>
			<p class="source-code">class Component;</p>
			<p class="source-code">class StandardGraphicsComponent : public GraphicsComponent {</p>
			<p class="source-code">private:</p>
			<p class="source-code">    sf::Sprite m_Sprite;</p>
			<p class="source-code">    string m_SpecificType = "standard";</p>
			<p class="source-code">public:</p>
			<p class="source-code">    /****************************************************</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    From Component interface base class</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    *****************************************************/</p>
			<p class="source-code">    string Component::getSpecificType() {</p>
			<p class="source-code">        return m_SpecificType;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    void Component::start(</p>
			<p class="source-code">        GameObjectSharer* gos, GameObject* self) {</p>
			<p class="source-code">    }</p>
			<p class="source-code">    /****************************************************</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    From GraphicsComponent</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    *****************************************************/</p>
			<p class="source-code">    void draw(</p>
			<p class="source-code">        RenderWindow&amp; window,</p>
			<p class="source-code">        shared_ptr&lt;TransformComponent&gt; t) override;</p>
			<p class="source-code">    void initializeGraphics(</p>
			<p class="source-code">        string bitmapName,</p>
			<p class="source-code">        Vector2f objectSize) override;</p>
			<p class="source-code">};</p>
			<p>The <strong class="source-inline">StandardGraphicsComponent</strong> class has a <strong class="source-inline">Sprite</strong> member. It doesn't need a <strong class="source-inline">Texture</strong> instance because that will be obtained each frame from the <strong class="source-inline">BitmapStore</strong> class. This class also overrides the required functions from both the <strong class="source-inline">Component</strong> and <strong class="source-inline">GraphicsComponent</strong> classes.</p>
			<p>Let's code the implementation of the two pure virtual functions, <strong class="source-inline">draw</strong> and <strong class="source-inline">initializeGraphics</strong>.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/GameObjects</strong> filter called <strong class="source-inline">StandardGraphicsComponent.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "StandardGraphicsComponent.h"</p>
			<p class="source-code">#include "BitmapStore.h"</p>
			<p class="source-code">#include &lt;iostream&gt;</p>
			<p class="source-code">void StandardGraphicsComponent::initializeGraphics(</p>
			<p class="source-code">    string bitmapName,</p>
			<p class="source-code">    Vector2f objectSize)</p>
			<p class="source-code">{</p>
			<p class="source-code">    BitmapStore::addBitmap("graphics/" + bitmapName + ".png");</p>
			<p class="source-code">    m_Sprite.setTexture(BitmapStore::getBitmap(</p>
			<p class="source-code">        "graphics/" + bitmapName + ".png"));</p>
			<p class="source-code">    auto textureSize = m_Sprite.getTexture()-&gt;getSize();</p>
			<p class="source-code">    m_Sprite.setScale(float(objectSize.x) / textureSize.x, </p>
			<p class="source-code">        float(objectSize.y) / textureSize.y);    </p>
			<p class="source-code">    m_Sprite.setColor(sf::Color(0, 255, 0)); </p>
			<p class="source-code">}</p>
			<p class="source-code">void StandardGraphicsComponent::draw(</p>
			<p class="source-code">    RenderWindow&amp; window,</p>
			<p class="source-code">    shared_ptr&lt;TransformComponent&gt; t)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Sprite.setPosition(t-&gt;getLocation());</p>
			<p class="source-code">    window.draw(m_Sprite);</p>
			<p class="source-code">}</p>
			<p>In the <strong class="source-inline">initializeGraphics</strong> function, the <strong class="source-inline">addBitmap</strong> function of the <strong class="source-inline">BitmapStore</strong> class is called and the file path of the image, along with the size of the object in the game world, is passed in.</p>
			<p>Next, the <strong class="source-inline">Texture</strong> instance that was just added to the <strong class="source-inline">BitmapStore</strong> class is retrieved and set as the image for the <strong class="source-inline">Sprite</strong>. Following on, two functions, <strong class="source-inline">getTexture</strong> and <strong class="source-inline">getSize</strong>, are chained together to get the size of the texture.</p>
			<p>The next line of code uses the <strong class="source-inline">setScale</strong> function to make the <strong class="source-inline">Sprite</strong> the same size as the texture, which in turn was set to the size of this object in the game world.</p>
			<p>The <strong class="source-inline">setColor</strong> function then applies a green tint to the <strong class="source-inline">Sprite</strong>. This gives it a bit more of a retro feel.</p>
			<p>In the <strong class="source-inline">draw</strong> function, the <strong class="source-inline">Sprite</strong> is moved into position using <strong class="source-inline">setPosition</strong> and the <strong class="source-inline">getLocation</strong> function of <strong class="source-inline">TransformComponent</strong>. We'll code the <strong class="source-inline">TransformComponent</strong> class next.</p>
			<p>The final line of code draws the <strong class="source-inline">Sprite</strong> to <strong class="source-inline">RenderWindow</strong>.</p>
			<h1 id="_idParaDest-409"><a id="_idTextAnchor423"/>Coding the TransformComponent class</h1>
			<p>Create a new header file in the <strong class="source-inline">Header Files/GameObjects</strong> filter called <strong class="source-inline">TransformComponent.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "Component.h"</p>
			<p class="source-code">#include&lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Component;</p>
			<p class="source-code">class TransformComponent : public Component {</p>
			<p class="source-code">private:</p>
			<p class="source-code">    const string m_Type = "transform";</p>
			<p class="source-code">    Vector2f m_Location;</p>
			<p class="source-code">    float m_Height;</p>
			<p class="source-code">    float m_Width;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    TransformComponent(</p>
			<p class="source-code">        float width, float height, Vector2f location);</p>
			<p class="source-code">    Vector2f&amp; getLocation();</p>
			<p class="source-code">    Vector2f getSize();</p>
			<p class="source-code">    /****************************************************</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    From Component interface</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    *****************************************************/</p>
			<p class="source-code">    string Component::getType()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return m_Type;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    string Component::getSpecificType()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Only one type of Transform so just return m_Type</p>
			<p class="source-code">        return m_Type;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void Component::disableComponent(){}</p>
			<p class="source-code">    void Component::enableComponent(){}</p>
			<p class="source-code">    bool Component::enabled()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void Component::start(GameObjectSharer* gos, GameObject* self)    {}</p>
			<p class="source-code">};</p>
			<p>This class has a <strong class="source-inline">Vector2f</strong> to store the position of the object in the game world, a <strong class="source-inline">float</strong> to store the height, and another <strong class="source-inline">float</strong> to store the width.</p>
			<p>In the <strong class="source-inline">public</strong> section, there is a constructor we will use to set up the instances of this class, as well as two functions, <strong class="source-inline">getLocation</strong> and <strong class="source-inline">getSize</strong>, we'll use to share the location and size of the object. We  used these functions already when we coded the <strong class="source-inline">StandardGraphicsComponent</strong> class.</p>
			<p>The remaining code in the <strong class="source-inline">TransformComponent.h</strong> file is the implementation of the <strong class="source-inline">Component</strong> class.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/GameObjects</strong> filter called <strong class="source-inline">TransformComponent.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "TransformComponent.h"</p>
			<p class="source-code">TransformComponent::TransformComponent(</p>
			<p class="source-code">    float width, float height, Vector2f location)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Height = height;</p>
			<p class="source-code">    m_Width = width;</p>
			<p class="source-code">    m_Location = location;</p>
			<p class="source-code">}</p>
			<p class="source-code">Vector2f&amp; TransformComponent::getLocation() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Location;</p>
			<p class="source-code">}</p>
			<p class="source-code">Vector2f TransformComponent::getSize() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return Vector2f(m_Width, m_Height);</p>
			<p class="source-code">}</p>
			<p>Implementing the three functions of this class is straightforward. The constructor receives a size and location and initializes the appropriate member variables. The <strong class="source-inline">getLocation</strong> and <strong class="source-inline">getSize</strong> functions return this data when it is requested. Notice that the values are returned by reference, so they will be modifiable by the calling code.</p>
			<p>Next, we will code all update-related components.</p>
			<h1 id="_idParaDest-410"><a id="_idTextAnchor424"/>Coding update components</h1>
			<p>As you might expect by now, we will code an <strong class="source-inline">UpdateComponent</strong> class that will inherit from the <strong class="source-inline">Component</strong> class. It will have all the functionality that every <strong class="source-inline">UpdateComponent</strong> will need and then we will code classes derived from <strong class="source-inline">UpdateComponent</strong>. These will contain functionality specific to individual objects in the game. For this game, we will have <strong class="source-inline">BulletUpdateComponent</strong>, <strong class="source-inline">InvaderUpdateComponent</strong>, and <strong class="source-inline">PlayerUpdateComponent</strong>. When you work on your own project and you want an object in the game that behaves in a specific unique manner, just code a new update-based component for it and you'll be good-to-go. Update-based components define behavior.</p>
			<h2 id="_idParaDest-411"><a id="_idTextAnchor425"/>Coding the UpdateComponent class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/GameObjects</strong> filter called <strong class="source-inline">UpdateComponent.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "Component.h"</p>
			<p class="source-code">class UpdateComponent : public Component</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    string m_Type = "update";</p>
			<p class="source-code">    bool m_Enabled = false;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    virtual void update(float fps) = 0;</p>
			<p class="source-code">    </p>
			<p class="source-code">    /****************************************************</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    From Component interface</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    *****************************************************/</p>
			<p class="source-code">    string Component::getType() {</p>
			<p class="source-code">        return m_Type;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void Component::disableComponent() {</p>
			<p class="source-code">        m_Enabled = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void Component::enableComponent() {</p>
			<p class="source-code">        m_Enabled = true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    bool Component::enabled() {</p>
			<p class="source-code">        return m_Enabled;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void Component::start(</p>
			<p class="source-code">        GameObjectSharer* gos, GameObject* self) {</p>
			<p class="source-code">    }</p>
			<p class="source-code">};</p>
			<p><strong class="source-inline">UpdateComponent</strong> only brings one piece of functionality: the <strong class="source-inline">update</strong> function. This function is pure virtual so it must be implemented by any class that aspires to be a usable instance of <strong class="source-inline">UpdateComponent</strong>.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/GameObjects</strong> filter called <strong class="source-inline">UpdateComponent.cpp</strong> and add the following code:</p>
			<p class="source-code">/*</p>
			<p class="source-code">All Functionality in UpdateComponent.h</p>
			<p class="source-code">*/</p>
			<p>This is a helpful comment to remind us that this class has all its code in the related header file.</p>
			<h2 id="_idParaDest-412"><a id="_idTextAnchor426"/>Coding the BulletUpdateComponent class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/GameObjects</strong> filter called <strong class="source-inline">BulletUpdateComponent.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "UpdateComponent.h"</p>
			<p class="source-code">#include "TransformComponent.h"</p>
			<p class="source-code">#include "GameObjectSharer.h"</p>
			<p class="source-code">#include "RectColliderComponent.h"</p>
			<p class="source-code">#include "GameObject.h"</p>
			<p class="source-code">class BulletUpdateComponent : public UpdateComponent</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    string m_SpecificType = "bullet";</p>
			<p class="source-code">    shared_ptr&lt;TransformComponent&gt; m_TC;</p>
			<p class="source-code">    shared_ptr&lt;RectColliderComponent&gt; m_RCC;</p>
			<p class="source-code">    float m_Speed = 75.0f;</p>
			<p class="source-code">    </p>
			<p class="source-code">    int m_AlienBulletSpeedModifier;</p>
			<p class="source-code">    int m_ModifierRandomComponent = 5;</p>
			<p class="source-code">    int m_MinimumAdditionalModifier = 5;</p>
			<p class="source-code">    bool m_MovingUp = true;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    bool m_BelongsToPlayer = false;</p>
			<p class="source-code">    bool m_IsSpawned = false;</p>
			<p class="source-code">    void spawnForPlayer(Vector2f spawnPosition);</p>
			<p class="source-code">    void spawnForInvader(Vector2f spawnPosition);</p>
			<p class="source-code">    void deSpawn();</p>
			<p class="source-code">    bool isMovingUp();</p>
			<p class="source-code">    /****************************************************</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    From Component interface base class</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    *****************************************************/</p>
			<p class="source-code">    string Component::getSpecificType() {</p>
			<p class="source-code">        return m_SpecificType;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    void Component::start(</p>
			<p class="source-code">        GameObjectSharer* gos, GameObject* self) {        </p>
			<p class="source-code">        // Where is this specific invader</p>
			<p class="source-code">        m_TC = static_pointer_cast&lt;TransformComponent&gt;(</p>
			<p class="source-code">            self-&gt;getComponentByTypeAndSpecificType(</p>
			<p class="source-code">                "transform", "transform"));</p>
			<p class="source-code">        m_RCC = static_pointer_cast&lt;RectColliderComponent&gt;(</p>
			<p class="source-code">            self-&gt;getComponentByTypeAndSpecificType(</p>
			<p class="source-code">                "collider", "rect"));</p>
			<p class="source-code">    }</p>
			<p class="source-code">    /****************************************************</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    From UpdateComponent</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    *****************************************************/</p>
			<p class="source-code">    void update(float fps) override;</p>
			<p class="source-code">};</p>
			<p>If you want to understand the behavior/logic of a bullet, you will need to spend some time learning the names and types of the member variables as I won't be explaining precisely how a bullet behaves; we have covered these topics many times. I will, however, point out that there are variables to cover basics such as movement, variables to help randomize the speed of each bullet within a certain range, and Booleans that identify whether the bullet belongs to the player or an invader.</p>
			<p>The key thing which you don't yet know but will have to learn here is that each <strong class="source-inline">BulletUpdateComponent</strong> instance will hold a shared pointer to the owning game object's <strong class="source-inline">TransformComponent</strong> instance and a shared pointer to the owning game object's <strong class="source-inline">RectColliderComponent</strong> instance.</p>
			<p>Now, look closely at the overridden <strong class="source-inline">start</strong> function. In the <strong class="source-inline">start</strong> function, the aforementioned shared pointers are initialized. The code achieves this by using the <strong class="source-inline">getComponentByTypeAndSpecificType</strong> function of the owning game object (<strong class="source-inline">self</strong>), which is a pointer to the owning game object. We will code the <strong class="source-inline">GameObject</strong> class, including this function, in a later section.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/GameObjects</strong> filter called <strong class="source-inline">BulletUpdate.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "BulletUpdateComponent.h"</p>
			<p class="source-code">#include "WorldState.h"</p>
			<p class="source-code">void BulletUpdateComponent::spawnForPlayer(</p>
			<p class="source-code">    Vector2f spawnPosition)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_MovingUp = true;</p>
			<p class="source-code">    m_BelongsToPlayer = true;</p>
			<p class="source-code">    m_IsSpawned = true;</p>
			<p class="source-code">    </p>
			<p class="source-code">    m_TC-&gt;getLocation().x = spawnPosition.x;</p>
			<p class="source-code">    // Tweak the y location based on the height of the bullet </p>
			<p class="source-code">    // The x location is already tweaked to the center of the player</p>
			<p class="source-code">    m_TC-&gt;getLocation().y = spawnPosition.y - m_TC-&gt;getSize().y;</p>
			<p class="source-code">    // Update the collider</p>
			<p class="source-code">    m_RCC-&gt;setOrMoveCollider(m_TC-&gt;getLocation().x,</p>
			<p class="source-code">        m_TC-&gt;getLocation().y, </p>
			<p class="source-code">        m_TC-&gt;getSize().x, m_TC-&gt;getSize().y);</p>
			<p class="source-code">}</p>
			<p class="source-code">void BulletUpdateComponent::spawnForInvader(</p>
			<p class="source-code">    Vector2f spawnPosition)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_MovingUp = false;</p>
			<p class="source-code">    m_BelongsToPlayer = false;</p>
			<p class="source-code">    m_IsSpawned = true;</p>
			<p class="source-code">    srand((int)time(0));</p>
			<p class="source-code">    m_AlienBulletSpeedModifier = (</p>
			<p class="source-code">        ((rand() % m_ModifierRandomComponent)))  </p>
			<p class="source-code">        + m_MinimumAdditionalModifier;    </p>
			<p class="source-code">    m_TC-&gt;getLocation().x = spawnPosition.x;</p>
			<p class="source-code">    // Tweak the y location based on the height of the bullet </p>
			<p class="source-code">    // The x location already tweaked to the center of the invader</p>
			<p class="source-code">    m_TC-&gt;getLocation().y = spawnPosition.y;</p>
			<p class="source-code">    // Update the collider</p>
			<p class="source-code">    m_RCC-&gt;setOrMoveCollider(</p>
			<p class="source-code">        m_TC-&gt;getLocation().x, m_TC-&gt;</p>
			<p class="source-code">        getLocation().y, m_TC-&gt;getSize().x, m_TC-&gt;getSize().y);</p>
			<p class="source-code">}</p>
			<p class="source-code">void BulletUpdateComponent::deSpawn()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_IsSpawned = false;</p>
			<p class="source-code">}</p>
			<p class="source-code">bool BulletUpdateComponent::isMovingUp()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_MovingUp;</p>
			<p class="source-code">}</p>
			<p class="source-code">void BulletUpdateComponent::update(float fps)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_IsSpawned)</p>
			<p class="source-code">    {    </p>
			<p class="source-code">        if (m_MovingUp)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_TC-&gt;getLocation().y -= m_Speed * fps;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_TC-&gt;getLocation().y += m_Speed / </p>
			<p class="source-code">                m_AlienBulletSpeedModifier * fps;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        if (m_TC-&gt;getLocation().y &gt; WorldState::WORLD_HEIGHT </p>
			<p class="source-code">            || m_TC-&gt;getLocation().y &lt; -2)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            deSpawn();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        // Update the collider</p>
			<p class="source-code">        m_RCC-&gt;setOrMoveCollider(m_TC-&gt;getLocation().x, </p>
			<p class="source-code">            m_TC-&gt;getLocation().y, </p>
			<p class="source-code">            m_TC-&gt;getSize().x, m_TC-&gt;getSize().y);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The first two functions are unique to the <strong class="source-inline">BulletUpdateComponent</strong> class; they are <strong class="source-inline">spawnForPlayer</strong> and <strong class="source-inline">spawnForInvader</strong>. Both of these functions prepare the member variables, transform component and collider component for action. Each one does so in a slightly different way. For example, for a player-owned bullet, it is prepared to move up the screen from the top of the player's ship, while a bullet is prepared for an invader to move down the screen from the underside of an invader. The key thing to notice is that all this is achievable via the shared pointers to the transform component and the collider component. Also, note that the <strong class="source-inline">m_IsSpawned</strong> Boolean is set to true, making this update component's <strong class="source-inline">update</strong> function ready to call each frame of the game.</p>
			<p>In the <strong class="source-inline">update</strong> function, the bullet is moved up or down the screen at the appropriate speed. It is tested to see if it has disappeared off the top or bottom of the screen, and the collider is updated to wrap around the current location so that we can test for collisions. </p>
			<p>This is the same logic we have seen throughout this book; what's new is the shared pointers we are using to communicate with the other components that make up this game object.</p>
			<p>The bullets just need to be spawned and tested for collisions; we will see how to do that in the next two chapters. Now, we will code the behavior of the invaders.</p>
			<h2 id="_idParaDest-413"><a id="_idTextAnchor427"/>Coding the InvaderUpdateComponent class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/GameObjects</strong> filter called <strong class="source-inline">InvaderUpdateComponent.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "UpdateComponent.h"</p>
			<p class="source-code">#include "TransformComponent.h"</p>
			<p class="source-code">#include "GameObjectSharer.h"</p>
			<p class="source-code">#include "RectColliderComponent.h"</p>
			<p class="source-code">#include "GameObject.h"</p>
			<p class="source-code">class BulletSpawner;</p>
			<p class="source-code">class InvaderUpdateComponent : public UpdateComponent</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    string m_SpecificType = "invader";</p>
			<p class="source-code">    shared_ptr&lt;TransformComponent&gt; m_TC;</p>
			<p class="source-code">    shared_ptr &lt; RectColliderComponent&gt; m_RCC;</p>
			<p class="source-code">    shared_ptr &lt; TransformComponent&gt; m_PlayerTC;</p>
			<p class="source-code">    shared_ptr &lt; RectColliderComponent&gt; m_PlayerRCC;</p>
			<p class="source-code">    BulletSpawner* m_BulletSpawner;</p>
			<p class="source-code">    float m_Speed = 10.0f;</p>
			<p class="source-code">    bool m_MovingRight = true;</p>
			<p class="source-code">    float m_TimeSinceLastShot;</p>
			<p class="source-code">    float m_TimeBetweenShots = 5.0f;</p>
			<p class="source-code">    float m_AccuracyModifier;</p>
			<p class="source-code">    float m_SpeedModifier = 0.05;</p>
			<p class="source-code">    int m_RandSeed;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    void dropDownAndReverse();</p>
			<p class="source-code">    bool isMovingRight();</p>
			<p class="source-code">    void initializeBulletSpawner(BulletSpawner* </p>
			<p class="source-code">        bulletSpawner, int randSeed);</p>
			<p class="source-code">    /****************************************************</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    From Component interface base class</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    *****************************************************/</p>
			<p class="source-code">    string Component::getSpecificType() {</p>
			<p class="source-code">        return m_SpecificType;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void Component::start(GameObjectSharer* gos, </p>
			<p class="source-code">        GameObject* self) {</p>
			<p class="source-code">            </p>
			<p class="source-code">        // Where is the player?</p>
			<p class="source-code">        m_PlayerTC = static_pointer_cast&lt;TransformComponent&gt;(</p>
			<p class="source-code">            gos-&gt;findFirstObjectWithTag("Player")</p>
			<p class="source-code">            .getComponentByTypeAndSpecificType(</p>
			<p class="source-code">                "transform", "transform"));</p>
			<p class="source-code">        m_PlayerRCC = static_pointer_cast&lt;RectColliderComponent&gt;(</p>
			<p class="source-code">            gos-&gt;findFirstObjectWithTag("Player")</p>
			<p class="source-code">            .getComponentByTypeAndSpecificType(</p>
			<p class="source-code">                "collider", "rect"));</p>
			<p class="source-code">        // Where is this specific invader</p>
			<p class="source-code">        m_TC = static_pointer_cast&lt;TransformComponent&gt;(</p>
			<p class="source-code">            self-&gt;getComponentByTypeAndSpecificType(</p>
			<p class="source-code">                "transform", "transform"));</p>
			<p class="source-code">        m_RCC = static_pointer_cast&lt;RectColliderComponent&gt;(</p>
			<p class="source-code">            self-&gt;getComponentByTypeAndSpecificType(</p>
			<p class="source-code">                "collider", "rect"));</p>
			<p class="source-code">    }</p>
			<p class="source-code">    /****************************************************</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    From UpdateComponent</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    *****************************************************/</p>
			<p class="source-code">    void update(float fps) override;    </p>
			<p class="source-code">};</p>
			<p>In the class declaration, we can see all the features that we need in order to code the behavior of an invader. There is a pointer to the transform component so that the invader can move, as well as a pointer to the collider component so that it can update its location and be collided with:</p>
			<p class="source-code">shared_ptr&lt;TransformComponent&gt; m_TC;</p>
			<p class="source-code">shared_ptr &lt; RectColliderComponent&gt; m_RCC;</p>
			<p>There are pointers to the player's transform and collider so that an invader can query the position of the player and make decisions about when to shoot bullets:</p>
			<p class="source-code">shared_ptr &lt; TransformComponent&gt; m_PlayerTC;</p>
			<p class="source-code">shared_ptr &lt; RectColliderComponent&gt; m_PlayerRCC;</p>
			<p>Next, there is a <strong class="source-inline">BulletSpawner</strong> instance, which we will code in the next chapter. The <strong class="source-inline">BulletSpawner</strong> class will allow an invader or the player to spawn a bullet. </p>
			<p>What follows is a whole bunch of variables that we will use to control the speed, direction, rate of fire, the precision with which the invader aims, and the speed of bullets that are fired. Familiarize yourself with them as they will be used in fairly in-depth logic in the function definitions:</p>
			<p class="source-code">float m_Speed = 10.0f;</p>
			<p class="source-code">bool m_MovingRight = true;</p>
			<p class="source-code">float m_TimeSinceLastShot;</p>
			<p class="source-code">float m_TimeBetweenShots = 5.0f;</p>
			<p class="source-code">float m_AccuracyModifier;</p>
			<p class="source-code">float m_SpeedModifier = 0.05;</p>
			<p class="source-code">int m_RandSeed;</p>
			<p>Next, we can see three new public functions that different parts of the system can call to make the invaders move down a little and head in the other direction, test the direction of travel, and pass in a pointer to the aforementioned <strong class="source-inline">BulletSpawner</strong> class, respectively: </p>
			<p class="source-code">void dropDownAndReverse();</p>
			<p class="source-code">bool isMovingRight();</p>
			<p class="source-code">void initializeBulletSpawner(BulletSpawner* </p>
			<p class="source-code">        bulletSpawner, int randSeed);</p>
			<p>Be sure to study the <strong class="source-inline">start</strong> function where the smart pointers to the invader and the player are initialized. Now, we will code the function definitions.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/GameObjects</strong> filter called <strong class="source-inline">InvaderUpdate.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "InvaderUpdateComponent.h"</p>
			<p class="source-code">#include "BulletSpawner.h"</p>
			<p class="source-code">#include "WorldState.h"</p>
			<p class="source-code">#include "SoundEngine.h"</p>
			<p class="source-code">void InvaderUpdateComponent::update(float fps)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_MovingRight)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_TC-&gt;getLocation().x += m_Speed * fps;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_TC-&gt;getLocation().x -= m_Speed * fps;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Update the collider</p>
			<p class="source-code">    m_RCC-&gt;setOrMoveCollider(m_TC-&gt;getLocation().x, </p>
			<p class="source-code">        m_TC-&gt;getLocation().y, m_TC-&gt;getSize().x, m_TC-</p>
			<p class="source-code">      &gt;getSize().y);</p>
			<p class="source-code">    m_TimeSinceLastShot += fps;</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Is the middle of the invader above the </p>
			<p class="source-code">   // player +- 1 world units</p>
			<p class="source-code">    if ((m_TC-&gt;getLocation().x + (m_TC-&gt;getSize().x / 2)) &gt; </p>
			<p class="source-code">        (m_PlayerTC-&gt;getLocation().x - m_AccuracyModifier) &amp;&amp;</p>
			<p class="source-code">        (m_TC-&gt;getLocation().x + (m_TC-&gt;getSize().x / 2)) &lt; </p>
			<p class="source-code">        (m_PlayerTC-&gt;getLocation().x + </p>
			<p class="source-code">        (m_PlayerTC-&gt;getSize().x + m_AccuracyModifier)))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Has the invader waited long enough since the last shot</p>
			<p class="source-code">        if (m_TimeSinceLastShot &gt; m_TimeBetweenShots)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            SoundEngine::playShoot();</p>
			<p class="source-code">            Vector2f spawnLocation;</p>
			<p class="source-code">            spawnLocation.x = m_TC-&gt;getLocation().x + </p>
			<p class="source-code">                m_TC-&gt;getSize().x / 2;</p>
			<p class="source-code">            spawnLocation.y = m_TC-&gt;getLocation().y + </p>
			<p class="source-code">                m_TC-&gt;getSize().y;</p>
			<p class="source-code">            m_BulletSpawner-&gt;spawnBullet(spawnLocation, false);</p>
			<p class="source-code">            srand(m_RandSeed);</p>
			<p class="source-code">            int mTimeBetweenShots = (((rand() % 10))+1) / </p>
			<p class="source-code">                WorldState::WAVE_NUMBER;</p>
			<p class="source-code">            m_TimeSinceLastShot = 0;            </p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">void InvaderUpdateComponent::dropDownAndReverse()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_MovingRight = !m_MovingRight;</p>
			<p class="source-code">    m_TC-&gt;getLocation().y += m_TC-&gt;getSize().y;</p>
			<p class="source-code">    m_Speed += (WorldState::WAVE_NUMBER) + </p>
			<p class="source-code">        (WorldState::NUM_INVADERS_AT_START </p>
			<p class="source-code">       - WorldState::NUM_INVADERS) </p>
			<p class="source-code">        * m_SpeedModifier;</p>
			<p class="source-code">}</p>
			<p class="source-code">bool InvaderUpdateComponent::isMovingRight()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_MovingRight;</p>
			<p class="source-code">}</p>
			<p class="source-code">void InvaderUpdateComponent::initializeBulletSpawner(</p>
			<p class="source-code">    BulletSpawner* bulletSpawner, int randSeed)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_BulletSpawner = bulletSpawner;</p>
			<p class="source-code">    m_RandSeed = randSeed;</p>
			<p class="source-code">    srand(m_RandSeed);</p>
			<p class="source-code">    m_TimeBetweenShots = (rand() % 15 + m_RandSeed);</p>
			<p class="source-code">    m_AccuracyModifier = (rand() % 2);</p>
			<p class="source-code">    m_AccuracyModifier += 0 + static_cast &lt;float&gt; (</p>
			<p class="source-code">        rand()) / (static_cast &lt;float&gt; (RAND_MAX / (10)));</p>
			<p class="source-code">}</p>
			<p>That was a lot of code. Actually, there's no C++ code in there that we haven't seen before. It is all just logic to control the behavior of an invader. Let's get an overview of what it all does, with parts of the code reprinted for convenience.</p>
			<h3>Explaining the update function</h3>
			<p>The first <strong class="source-inline">if</strong> and <strong class="source-inline">else</strong> blocks move the invader right or left each frame, as appropriate:</p>
			<p class="source-code">void InvaderUpdateComponent::update(float fps)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_MovingRight)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_TC-&gt;getLocation().x += m_Speed * fps;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_TC-&gt;getLocation().x -= m_Speed * fps;</p>
			<p class="source-code">    }</p>
			<p>Next, the collider is updated to the new position:</p>
			<p class="source-code">    // Update the collider</p>
			<p class="source-code">    m_RCC-&gt;setOrMoveCollider(m_TC-&gt;getLocation().x, </p>
			<p class="source-code">        m_TC-&gt;getLocation().y, m_TC-&gt;getSize().x, m_TC </p>
			<p class="source-code">      -&gt;getSize().y);</p>
			<p>This code tracks how long it's been since this invader last fired a shot and then tests to see if the player is one world unit to the left or right of the invader (+ or – for the random accuracy modifier, so that each invader is a little bit different):</p>
			<p class="source-code">   m_TimeSinceLastShot += fps;</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Is the middle of the invader above the </p>
			<p class="source-code">   // player +- 1 world units</p>
			<p class="source-code">    if ((m_TC-&gt;getLocation().x + (m_TC-&gt;getSize().x / 2)) &gt; </p>
			<p class="source-code">        (m_PlayerTC-&gt;getLocation().x - m_AccuracyModifier) &amp;&amp;</p>
			<p class="source-code">        (m_TC-&gt;getLocation().x + (m_TC-&gt;getSize().x / 2)) &lt; </p>
			<p class="source-code">        (m_PlayerTC-&gt;getLocation().x + </p>
			<p class="source-code">        (m_PlayerTC-&gt;getSize().x + m_AccuracyModifier)))</p>
			<p class="source-code">    {</p>
			<p>Inside the preceding <strong class="source-inline">if</strong> test, another test makes sure that the invader has waited long enough since the last shot it took. If it has, then a shot is taken. A sound is played, a spawn location for the bullet is calculated, the <strong class="source-inline">spawnBullet</strong> function of the <strong class="source-inline">BulletSpawner</strong> instance is called, and a new random time to wait before another shot can be taken is calculated:</p>
			<p class="source-code">        // Has the invader waited long enough since the last shot</p>
			<p class="source-code">        if (m_TimeSinceLastShot &gt; m_TimeBetweenShots)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            SoundEngine::playShoot();</p>
			<p class="source-code">            Vector2f spawnLocation;</p>
			<p class="source-code">            spawnLocation.x = m_TC-&gt;getLocation().x + </p>
			<p class="source-code">                m_TC-&gt;getSize().x / 2;</p>
			<p class="source-code">            spawnLocation.y = m_TC-&gt;getLocation().y + </p>
			<p class="source-code">                m_TC-&gt;getSize().y;</p>
			<p class="source-code">            m_BulletSpawner-&gt;spawnBullet(spawnLocation, false);</p>
			<p class="source-code">            srand(m_RandSeed);</p>
			<p class="source-code">            int mTimeBetweenShots = (((rand() % 10))+1) / </p>
			<p class="source-code">                WorldState::WAVE_NUMBER;</p>
			<p class="source-code">            m_TimeSinceLastShot = 0;            </p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The details of the <strong class="source-inline">BulletSpawner</strong> class will be revealed in the next chapter, but as a glimpse into the future, it will be an abstract class with one function called <strong class="source-inline">spawnBullet</strong> and will be inherited from by the <strong class="source-inline">GameScreen</strong> class.</p>
			<h3>Explaining the dropDownAndReverse function</h3>
			<p>In the <strong class="source-inline">dropDownAndReverse</strong> function, the direction is reversed and the vertical location is increased by the height of an invader. In addition, the speed of the invader is increased relative to how many waves the player has cleared and how many invaders remain to be destroyed. The more waves that are cleared and the fewer invaders remaining, the faster the invaders will move:</p>
			<p class="source-code">void InvaderUpdateComponent::dropDownAndReverse()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_MovingRight = !m_MovingRight;</p>
			<p class="source-code">    m_TC-&gt;getLocation().y += m_TC-&gt;getSize().y;</p>
			<p class="source-code">    m_Speed += (WorldState::WAVE_NUMBER) + </p>
			<p class="source-code">        (WorldState::NUM_INVADERS_AT_START </p>
			<p class="source-code">      - WorldState::NUM_INVADERS) </p>
			<p class="source-code">        * m_SpeedModifier;</p>
			<p class="source-code">}</p>
			<p>The next function is simple but included for the sake of completeness.</p>
			<h3>Explaining the isMovingRight function</h3>
			<p>This code simply provides access to the current direction of travel:</p>
			<p class="source-code">bool InvaderUpdateComponent::isMovingRight()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_MovingRight;</p>
			<p class="source-code">}</p>
			<p>It will be used to test whether to look out for collisions with the left of the screen (when moving left) or the right of the screen (when moving right) and will allow the collision to trigger a call to the <strong class="source-inline">dropDownAndReverse</strong> function.</p>
			<h3>Explaining the initializeBulletSpawner function</h3>
			<p>I have already mentioned that the <strong class="source-inline">BulletSpawner</strong> class is abstract and will be implemented by the <strong class="source-inline">GameScreen</strong> class. When the <strong class="source-inline">GameScreen</strong> class' <strong class="source-inline">initialize</strong> function is called, this <strong class="source-inline">initializeBulletSpawner</strong> function will be called on each of the invaders. As you can see, the first parameter is a pointer to a <strong class="source-inline">BulletSpawner</strong> instance. This gives every <strong class="source-inline">InvaderUpdateComponent</strong> the ability to call the <strong class="source-inline">spawnBullet</strong> function: </p>
			<p class="source-code">void InvaderUpdateComponent::initializeBulletSpawner(</p>
			<p class="source-code">    BulletSpawner* bulletSpawner, int randSeed)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_BulletSpawner = bulletSpawner;</p>
			<p class="source-code">    m_RandSeed = randSeed;</p>
			<p class="source-code">    srand(m_RandSeed);</p>
			<p class="source-code">    m_TimeBetweenShots = (rand() % 15 + m_RandSeed);</p>
			<p class="source-code">    m_AccuracyModifier = (rand() % 2);</p>
			<p class="source-code">    m_AccuracyModifier += 0 + static_cast &lt;float&gt; (</p>
			<p class="source-code">        rand()) / (static_cast &lt;float&gt; (RAND_MAX / (10)));</p>
			<p class="source-code">}</p>
			<p>The rest of the code in the <strong class="source-inline">initializeBulletSpawner</strong> function sets up the random values that make each invader behave slightly differently from the others.</p>
			<h2 id="_idParaDest-414"><a id="_idTextAnchor428"/>Coding the PlayerUpdateComponent class</h2>
			<p>Create a new header file in the <strong class="source-inline">Header Files/GameObjects</strong> filter called <strong class="source-inline">PlayerUpdateComponent.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "UpdateComponent.h"</p>
			<p class="source-code">#include "TransformComponent.h"</p>
			<p class="source-code">#include "GameObjectSharer.h"</p>
			<p class="source-code">#include "RectColliderComponent.h"</p>
			<p class="source-code">#include "GameObject.h"</p>
			<p class="source-code">class PlayerUpdateComponent : public UpdateComponent</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    string m_SpecificType = "player";</p>
			<p class="source-code">    shared_ptr&lt;TransformComponent&gt; m_TC;</p>
			<p class="source-code">    shared_ptr&lt;RectColliderComponent&gt; m_RCC;</p>
			<p class="source-code">    float m_Speed = 50.0f;</p>
			<p class="source-code">    float m_XExtent = 0;</p>
			<p class="source-code">    float m_YExtent = 0;</p>
			<p class="source-code">    bool m_IsHoldingLeft = false;</p>
			<p class="source-code">    bool m_IsHoldingRight = false;</p>
			<p class="source-code">    bool m_IsHoldingUp = false;</p>
			<p class="source-code">    bool m_IsHoldingDown = false;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    void updateShipTravelWithController(float x, float y);</p>
			<p class="source-code">    void moveLeft();</p>
			<p class="source-code">    void moveRight();</p>
			<p class="source-code">    void moveUp();</p>
			<p class="source-code">    void moveDown();</p>
			<p class="source-code">    void stopLeft();</p>
			<p class="source-code">    void stopRight();</p>
			<p class="source-code">    void stopUp();</p>
			<p class="source-code">    void stopDown();</p>
			<p class="source-code">    /****************************************************</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    From Component interface base class</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    *****************************************************/</p>
			<p class="source-code">    string Component::getSpecificType() {</p>
			<p class="source-code">        return m_SpecificType;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    void Component::start(GameObjectSharer* gos, GameObject* self) {        </p>
			<p class="source-code">        m_TC = static_pointer_cast&lt;TransformComponent&gt;(self-&gt;</p>
			<p class="source-code">            getComponentByTypeAndSpecificType(</p>
			<p class="source-code">                "transform", "transform"));</p>
			<p class="source-code">        m_RCC = static_pointer_cast&lt;RectColliderComponent&gt;(self-&gt;</p>
			<p class="source-code">            getComponentByTypeAndSpecificType(</p>
			<p class="source-code">                "collider", "rect"));        </p>
			<p class="source-code">    }</p>
			<p class="source-code">    /****************************************************</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    From UpdateComponent</p>
			<p class="source-code">    *****************************************************</p>
			<p class="source-code">    *****************************************************/</p>
			<p class="source-code">    void update(float fps) override;</p>
			<p class="source-code">};</p>
			<p>In the <strong class="source-inline">PlayerUpdateComponent</strong> class, we have all the Boolean variables needed to keep track of whether the player is holding down a keyboard key, as well as functions that can toggle these Boolean values. We haven't seen anything like the <strong class="source-inline">m_XExtent</strong> and <strong class="source-inline">M_YExtent float</strong> type variables before and we will explain them when we look at their usage in the function definitions.</p>
			<p>Note, just like the <strong class="source-inline">BulletUpdateComponent</strong> and the <strong class="source-inline">InvaderUpdateComponent</strong> classes, that we have shared pointers to this game object's transform and collider components. These shared pointers, as we are coming to expect, are initialized in the <strong class="source-inline">start</strong> function.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/GameObjects</strong> filter called <strong class="source-inline">PlayerUpdate.cpp</strong> and add the following code:</p>
			<p class="source-code">#include "PlayerUpdateComponent.h"</p>
			<p class="source-code">#include "WorldState.h"</p>
			<p class="source-code">void PlayerUpdateComponent::update(float fps)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (sf::Joystick::isConnected(0))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_TC-&gt;getLocation().x += ((m_Speed / 100) </p>
			<p class="source-code">            * m_XExtent) * fps;</p>
			<p class="source-code">        m_TC-&gt;getLocation().y += ((m_Speed / 100) </p>
			<p class="source-code">            * m_YExtent) * fps;        </p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Left and right</p>
			<p class="source-code">    if (m_IsHoldingLeft)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_TC-&gt;getLocation().x -= m_Speed * fps;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else if (m_IsHoldingRight)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_TC-&gt;getLocation().x += m_Speed * fps;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Up and down</p>
			<p class="source-code">    if (m_IsHoldingUp)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_TC-&gt;getLocation().y -= m_Speed * fps;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else if (m_IsHoldingDown)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_TC-&gt;getLocation().y += m_Speed * fps;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Update the collider</p>
			<p class="source-code">    m_RCC-&gt;setOrMoveCollider(m_TC-&gt;getLocation().x, </p>
			<p class="source-code">        m_TC-&gt;getLocation().y, m_TC-&gt;getSize().x, </p>
			<p class="source-code">        m_TC-&gt;getSize().y);</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Make sure the ship doesn't go outside the allowed area</p>
			<p class="source-code">    if (m_TC-&gt;getLocation().x &gt;</p>
			<p class="source-code">        WorldState::WORLD_WIDTH - m_TC-&gt;getSize().x) </p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_TC-&gt;getLocation().x = </p>
			<p class="source-code">            WorldState::WORLD_WIDTH - m_TC-&gt;getSize().x;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else if (m_TC-&gt;getLocation().x &lt; 0)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_TC-&gt;getLocation().x = 0;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (m_TC-&gt;getLocation().y &gt; </p>
			<p class="source-code">        WorldState::WORLD_HEIGHT - m_TC-&gt;getSize().y)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_TC-&gt;getLocation().y = </p>
			<p class="source-code">            WorldState::WORLD_HEIGHT - m_TC-&gt;getSize().y;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else if (m_TC-&gt;getLocation().y &lt; </p>
			<p class="source-code">        WorldState::WORLD_HEIGHT / 2)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_TC-&gt;getLocation().y = </p>
			<p class="source-code">            WorldState::WORLD_HEIGHT / 2;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}    </p>
			<p class="source-code">void PlayerUpdateComponent::</p>
			<p class="source-code">    updateShipTravelWithController(float x, float y)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_XExtent = x;</p>
			<p class="source-code">    m_YExtent = y;</p>
			<p class="source-code">}</p>
			<p class="source-code">void PlayerUpdateComponent::moveLeft()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_IsHoldingLeft = true;</p>
			<p class="source-code">    stopRight();</p>
			<p class="source-code">}</p>
			<p class="source-code">void PlayerUpdateComponent::moveRight()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_IsHoldingRight = true;</p>
			<p class="source-code">    stopLeft();</p>
			<p class="source-code">}</p>
			<p class="source-code">void PlayerUpdateComponent::moveUp()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_IsHoldingUp = true;</p>
			<p class="source-code">    stopDown();</p>
			<p class="source-code">}</p>
			<p class="source-code">void PlayerUpdateComponent::moveDown()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_IsHoldingDown = true;</p>
			<p class="source-code">    stopUp();</p>
			<p class="source-code">}</p>
			<p class="source-code">void PlayerUpdateComponent::stopLeft()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_IsHoldingLeft = false;</p>
			<p class="source-code">}</p>
			<p class="source-code">void PlayerUpdateComponent::stopRight()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_IsHoldingRight = false;</p>
			<p class="source-code">}</p>
			<p class="source-code">void PlayerUpdateComponent::stopUp()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_IsHoldingUp = false;</p>
			<p class="source-code">}</p>
			<p class="source-code">void PlayerUpdateComponent::stopDown()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_IsHoldingDown = false;</p>
			<p class="source-code">}</p>
			<p>In the first <strong class="source-inline">if</strong> block of the update function, the condition is <strong class="source-inline">sf::Joystick::isConnected(0)</strong>. This condition returns true when the player has a gamepad plugged in to a USB port. Inside the <strong class="source-inline">if</strong> block, the location of both the horizontal and vertical positions of the transform component are altered:</p>
			<p class="source-code">…((m_Speed / 100) * m_YExtent) * fps;</p>
			<p>The preceding code divides the target speed by 100 before multiplying it by <strong class="source-inline">m_YExtent</strong>. <strong class="source-inline">The m_XExtent</strong> and <strong class="source-inline">m_YExtent</strong> variables will be updated each frame to hold values that represent the extent to which the player has moved their gamepad thumbstick in a horizontal and vertical direction. The range of values is from -100 to 100, and so the preceding code has the effect of moving the transform component at full speed in any direction when the thumbstick is positioned at any of its full extents or a fraction of that speed when it is partially positioned between the center (not moving at all) and its full extent. This means that the player will have finer control over the speed of the ship should they opt to use a gamepad instead of the keyboard.</p>
			<p>We will see more details about the operation of the gamepad in <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>, <em class="italic">Using Game Objects and Building a Game</em>.</p>
			<p>The rest of the <strong class="source-inline">update</strong> function responds to the Boolean variables, which represent the keyboard keys that the player is holding down or has released.</p>
			<p>After the gamepad and keyboard handling, the collider component is moved into the new position and a series of <strong class="source-inline">if</strong> blocks ensures the player ship can't move outside of the screen or above the half-way-up point on the screen.</p>
			<p>The next function is the <strong class="source-inline">updateShipTravelWithController</strong> function; when a controller is plugged in, it will update the extent to which the thumbstick is moved or at rest for each frame.</p>
			<p>The remaining functions update the Boolean values that indicate whether keyboard keys are being used to move the ship. Notice that the update component does not handle firing a bullet. We could have handled it from here, and some games might have a good reason to do so. In this game, it was slightly more direct to handle shooting a bullet from the <strong class="source-inline">GameInputHandler</strong> class. The <strong class="source-inline">GameInputHandler</strong> class, as we will see in <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>, <em class="italic">Using Game Objects and Building a Game</em>, will call all the functions that let the <strong class="source-inline">PlayerUpdateComponent</strong> class know what is happening with the gamepad and keyboard. We coded the basics of keyboard responses in the <strong class="source-inline">GameInputHandler</strong> class in the previous chapter.</p>
			<p>Now, let's code the <strong class="source-inline">GameObject</strong> class, which will hold all the various component instances.</p>
			<h1 id="_idParaDest-415"><a id="_idTextAnchor429"/>Coding the GameObject class</h1>
			<p>I am going to go through the code in this class in quite a lot of detail because it is key to how all the other classes work. I think you will benefit, however, from seeing the code in its entirety and studying it first. With this in mind, create a new header file in the <strong class="source-inline">Header Files/GameObjects</strong> filter called <strong class="source-inline">GameObject.h</strong> and add the following code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include &lt;vector&gt;</p>
			<p class="source-code">#include &lt;string&gt;</p>
			<p class="source-code">#include "Component.h"</p>
			<p class="source-code">#include "GraphicsComponent.h"</p>
			<p class="source-code">#include "GameObjectSharer.h"</p>
			<p class="source-code">#include "UpdateComponent.h"</p>
			<p class="source-code">class GameObject {</p>
			<p class="source-code">private:</p>
			<p class="source-code">    vector&lt;shared_ptr&lt;Component&gt;&gt; m_Components;</p>
			<p class="source-code">    string m_Tag;</p>
			<p class="source-code">    bool m_Active = false;</p>
			<p class="source-code">    int m_NumberUpdateComponents = 0;</p>
			<p class="source-code">    bool m_HasUpdateComponent = false;</p>
			<p class="source-code">    int m_FirstUpdateComponentLocation = -1;</p>
			<p class="source-code">    int m_GraphicsComponentLocation = -1;</p>
			<p class="source-code">    bool m_HasGraphicsComponent = false;</p>
			<p class="source-code">    int m_TransformComponentLocation = -1;</p>
			<p class="source-code">    int m_NumberRectColliderComponents = 0;</p>
			<p class="source-code">    int m_FirstRectColliderComponentLocation = -1;</p>
			<p class="source-code">    bool m_HasCollider = false;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    void update(float fps);</p>
			<p class="source-code">    void draw(RenderWindow&amp; window);</p>
			<p class="source-code">    void addComponent(shared_ptr&lt;Component&gt; component);</p>
			<p class="source-code">    void setActive();</p>
			<p class="source-code">    void setInactive();</p>
			<p class="source-code">    bool isActive();</p>
			<p class="source-code">    void setTag(String tag);</p>
			<p class="source-code">    string getTag();</p>
			<p class="source-code">    void start(GameObjectSharer* gos);</p>
			<p class="source-code">    // Slow only use in init and start</p>
			<p class="source-code">    shared_ptr&lt;Component&gt; getComponentByTypeAndSpecificType(</p>
			<p class="source-code">        string type, string specificType);</p>
			<p class="source-code">    FloatRect&amp; getEncompassingRectCollider();</p>
			<p class="source-code">    bool hasCollider();</p>
			<p class="source-code">    bool hasUpdateComponent();</p>
			<p class="source-code">    string getEncompassingRectColliderTag();</p>
			<p class="source-code">    shared_ptr&lt;GraphicsComponent&gt; getGraphicsComponent();</p>
			<p class="source-code">    shared_ptr&lt;TransformComponent&gt; getTransformComponent();</p>
			<p class="source-code">    shared_ptr&lt;UpdateComponent&gt; getFirstUpdateComponent();</p>
			<p class="source-code">};</p>
			<p>In the preceding code, be sure to closely examine the variables, types, function names, and their parameters.</p>
			<p>Create a new source file in the <strong class="source-inline">Source Files/GameObjects</strong> filter called <strong class="source-inline">GameObject.cpp</strong> and then study and add the following code:</p>
			<p class="source-code">#include "DevelopState.h"</p>
			<p class="source-code">#include "GameObject.h"</p>
			<p class="source-code">#include &lt;iostream&gt; </p>
			<p class="source-code">#include "UpdateComponent.h"</p>
			<p class="source-code">#include "RectColliderComponent.h"</p>
			<p class="source-code">void GameObject::update(float fps)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_Active &amp;&amp; m_HasUpdateComponent)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        for (int i = m_FirstUpdateComponentLocation; i &lt; </p>
			<p class="source-code">            m_FirstUpdateComponentLocation + </p>
			<p class="source-code">            m_NumberUpdateComponents; i++) </p>
			<p class="source-code">        {</p>
			<p class="source-code">            shared_ptr&lt;UpdateComponent&gt; tempUpdate =</p>
			<p class="source-code">                static_pointer_cast&lt;UpdateComponent&gt;(</p>
			<p class="source-code">             m_Components[i]);</p>
			<p class="source-code">            if (tempUpdate-&gt;enabled()) </p>
			<p class="source-code">            {</p>
			<p class="source-code">                tempUpdate-&gt;update(fps);</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObject::draw(RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_Active &amp;&amp; m_HasGraphicsComponent)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (m_Components[m_GraphicsComponentLocation]-&gt;enabled())</p>
			<p class="source-code">        {</p>
			<p class="source-code">            getGraphicsComponent()-&gt;draw(window, </p>
			<p class="source-code">                getTransformComponent());</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">shared_ptr&lt;GraphicsComponent&gt; GameObject::getGraphicsComponent() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return static_pointer_cast&lt;GraphicsComponent&gt;(</p>
			<p class="source-code">        m_Components[m_GraphicsComponentLocation]);</p>
			<p class="source-code">}</p>
			<p class="source-code">shared_ptr&lt;TransformComponent&gt; GameObject::getTransformComponent() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return static_pointer_cast&lt;TransformComponent&gt;(</p>
			<p class="source-code">        m_Components[m_TransformComponentLocation]);</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObject::addComponent(shared_ptr&lt;Component&gt; component)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Components.push_back(component);</p>
			<p class="source-code">    component-&gt;enableComponent();</p>
			<p class="source-code">    </p>
			<p class="source-code">   if (component-&gt;getType() == "update") </p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_HasUpdateComponent = true;</p>
			<p class="source-code">        m_NumberUpdateComponents++;</p>
			<p class="source-code">        if (m_NumberUpdateComponents == 1) </p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_FirstUpdateComponentLocation = </p>
			<p class="source-code">                m_Components.size() - 1;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else if (component-&gt;getType() == "graphics") </p>
			<p class="source-code">    {</p>
			<p class="source-code">        // No iteration in the draw method required</p>
			<p class="source-code">        m_HasGraphicsComponent = true;</p>
			<p class="source-code">        m_GraphicsComponentLocation = m_Components.size() - 1;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else if (component-&gt;getType() == "transform") </p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Remember where the Transform component is</p>
			<p class="source-code">        m_TransformComponentLocation = m_Components.size() - 1;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else if (component-&gt;getType() == "collider" &amp;&amp; </p>
			<p class="source-code">        component-&gt;getSpecificType() == "rect") </p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Remember where the collider component(s) is</p>
			<p class="source-code">        m_HasCollider = true;</p>
			<p class="source-code">        m_NumberRectColliderComponents++;</p>
			<p class="source-code">        if (m_NumberRectColliderComponents == 1) </p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_FirstRectColliderComponentLocation = </p>
			<p class="source-code">                m_Components.size() - 1;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }    </p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObject::setActive()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Active = true;</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObject::setInactive()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Active = false;</p>
			<p class="source-code">}</p>
			<p class="source-code">bool GameObject::isActive()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Active;</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObject::setTag(String tag)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Tag = "" + tag;</p>
			<p class="source-code">}</p>
			<p class="source-code">std::string GameObject::getTag()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Tag;</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObject::start(GameObjectSharer* gos) </p>
			<p class="source-code">{</p>
			<p class="source-code">    auto it = m_Components.begin();</p>
			<p class="source-code">    auto end = m_Components.end();</p>
			<p class="source-code">    for (it;</p>
			<p class="source-code">        it != end;</p>
			<p class="source-code">        ++it)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        (*it)-&gt;start(gos, this);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">// Slow - only use in start function</p>
			<p class="source-code">shared_ptr&lt;Component&gt; GameObject::</p>
			<p class="source-code">   getComponentByTypeAndSpecificType(</p>
			<p class="source-code">    string type, string specificType) {</p>
			<p class="source-code">    auto it = m_Components.begin();</p>
			<p class="source-code">    auto end = m_Components.end();</p>
			<p class="source-code">    for (it;</p>
			<p class="source-code">        it != end;</p>
			<p class="source-code">        ++it)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if ((*it)-&gt;getType() == type)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            if ((*it)-&gt;getSpecificType() == specificType)</p>
			<p class="source-code">            {</p>
			<p class="source-code">                return  (*it);</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    #ifdef debuggingErrors        </p>
			<p class="source-code">        cout &lt;&lt; </p>
			<p class="source-code">            "GameObject.cpp::getComponentByTypeAndSpecificType-" </p>
			<p class="source-code">            &lt;&lt; "COMPONENT NOT FOUND ERROR!" </p>
			<p class="source-code">            &lt;&lt; endl;</p>
			<p class="source-code">    #endif</p>
			<p class="source-code">        return m_Components[0];</p>
			<p class="source-code">}</p>
			<p class="source-code">FloatRect&amp; GameObject::getEncompassingRectCollider() </p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_HasCollider) </p>
			<p class="source-code">    {</p>
			<p class="source-code">        return (static_pointer_cast&lt;RectColliderComponent&gt;(</p>
			<p class="source-code">            m_Components[m_FirstRectColliderComponentLocation]))</p>
			<p class="source-code">            -&gt;getColliderRectF();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">string GameObject::getEncompassingRectColliderTag() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return static_pointer_cast&lt;RectColliderComponent&gt;(</p>
			<p class="source-code">        m_Components[m_FirstRectColliderComponentLocation])-&gt;</p>
			<p class="source-code">        getColliderTag();</p>
			<p class="source-code">}</p>
			<p class="source-code">shared_ptr&lt;UpdateComponent&gt; GameObject::getFirstUpdateComponent()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return static_pointer_cast&lt;UpdateComponent&gt;(</p>
			<p class="source-code">        m_Components[m_FirstUpdateComponentLocation]);</p>
			<p class="source-code">}</p>
			<p class="source-code">bool GameObject::hasCollider() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_HasCollider;</p>
			<p class="source-code">}</p>
			<p class="source-code">bool GameObject::hasUpdateComponent()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_HasUpdateComponent;</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Be sure to study the preceding code before moving on. The explanations that follow assume that you have a basic awareness of variable names and types, as well as function names, parameters, and return types.</p>
			<h2 id="_idParaDest-416"><a id="_idTextAnchor430"/>Explaining the GameObject class</h2>
			<p>Let's go through the <strong class="source-inline">GameObject</strong> class one function at a time and reprint the code to make it easy to discuss.</p>
			<h3>Explaining the update function</h3>
			<p>The <strong class="source-inline">update</strong> function is called once for each frame of the game loop for each game object. Like most of our other projects, the current frame rate is required. Inside the <strong class="source-inline">update</strong> function, a test is done to see if this <strong class="source-inline">GameObject</strong> instance is active and has an update component. A game object does not have to have an update component, although it is true that all the game objects in this project do.</p>
			<p>Next, the <strong class="source-inline">update</strong> function loops through all the components it has, starting from <strong class="source-inline">m_FirstUpdateComponent</strong> through to <strong class="source-inline">m_FirstUpdateComponent + m_NumberUpdateComponents</strong>. This code implies that a game object can have multiple update components. This is so that you can design game objects with layers of behavior. This layering of behavior is discussed further in <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>, <em class="italic">Using Game Objects and Building a Game</em>. All the game objects in this project have just one update component, so you could simplify (and speed up) the logic in the <strong class="source-inline">update</strong> function, but I suggest leaving it as it is until you have read <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>, <em class="italic">Using Game Objects and Building a Game</em>. </p>
			<p>It is because a component could be one of many types that we create a temporary update-related component (<strong class="source-inline">tempUpdate</strong>), cast the component from the vector of components to <strong class="source-inline">UpdateComponent</strong>, and call the <strong class="source-inline">update</strong> function. It doesn't matter about the specific derivation of the <strong class="source-inline">UpdateComponent</strong> class; it will have the <strong class="source-inline">update</strong> function implemented, so the <strong class="source-inline">UpdateComponent</strong> type is specific enough:</p>
			<p class="source-code">void GameObject::update(float fps)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_Active &amp;&amp; m_HasUpdateComponent)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        for (int i = m_FirstUpdateComponentLocation; i &lt; </p>
			<p class="source-code">            m_FirstUpdateComponentLocation + </p>
			<p class="source-code">            m_NumberUpdateComponents; i++) </p>
			<p class="source-code">        {</p>
			<p class="source-code">            shared_ptr&lt;UpdateComponent&gt; tempUpdate =</p>
			<p class="source-code">                static_pointer_cast&lt;UpdateComponent&gt;(</p>
			<p class="source-code">             m_Components[i]);</p>
			<p class="source-code">            if (tempUpdate-&gt;enabled()) </p>
			<p class="source-code">            {</p>
			<p class="source-code">                tempUpdate-&gt;update(fps);</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>When we get to the <strong class="source-inline">addComponent</strong> function in a later section, we will see how we can initialize the various control variables, such as <strong class="source-inline">m_FirstUpdateComponentLocation</strong> and <strong class="source-inline">m_NumberOfUpdateComponents</strong>.</p>
			<h3>Explaining the draw function</h3>
			<p>The <strong class="source-inline">draw</strong> function checks whether the game object is active and that it has a graphics component. If it does, then a check is done to see if the graphics component is enabled. If all these tests succeed, then the <strong class="source-inline">draw</strong> function is called:</p>
			<p class="source-code">void GameObject::draw(RenderWindow&amp; window)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_Active &amp;&amp; m_HasGraphicsComponent)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (m_Components[m_GraphicsComponentLocation]-&gt;enabled())</p>
			<p class="source-code">        {</p>
			<p class="source-code">            getGraphicsComponent()-&gt;draw(window, </p>
			<p class="source-code">                getTransformComponent());</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The structure of the <strong class="source-inline">draw</strong> function implies that not every game object has to draw itself. I mentioned in <a href="B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372"><em class="italic">Chapter 19</em></a>, <em class="italic">Game Programming Design Patterns – Starting the Space Invaders ++ Game</em>, that you might want game objects that can never be seen to act as invisible trigger regions (with no graphics component) that respond when the player passes over them or game objects that remain invisible temporarily (temporarily disabled but with a graphics component). In this project, all game objects have a permanently enabled graphics component.</p>
			<h3>Explaining the getGraphicsComponent function</h3>
			<p>This function returns a shared pointer to the graphics component:</p>
			<p class="source-code">shared_ptr&lt;GraphicsComponent&gt; GameObject::getGraphicsComponent() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return static_pointer_cast&lt;GraphicsComponent&gt;(</p>
			<p class="source-code">        m_Components[m_GraphicsComponentLocation]);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">getGraphicsComponent</strong> function gives any code that has an instance of the contained game object access to the graphics component.</p>
			<h3>Explaining the getTransformComponent function</h3>
			<p>This function returns a shared pointer to the transform component:</p>
			<p class="source-code">shared_ptr&lt;TransformComponent&gt; GameObject::getTransformComponent() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return static_pointer_cast&lt;TransformComponent&gt;(</p>
			<p class="source-code">        m_Components[m_TransformComponentLocation]);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">getTransformComponent</strong> function gives any code that has an instance of the contained game object access to the transform component.</p>
			<h3>Explaining the addComponent function</h3>
			<p>The <strong class="source-inline">addComponent</strong> function will be used by a factory pattern class we will code in the next chapter. The function receives a shared pointer to a <strong class="source-inline">Component</strong> instance. The first thing that happens inside the function is that the <strong class="source-inline">Component</strong> instance is added to the <strong class="source-inline">m_Components</strong> vector. Next, the component is enabled using the <strong class="source-inline">enabled</strong> function.</p>
			<p>What follows is a series of <strong class="source-inline">if</strong> and <strong class="source-inline">else if</strong> statements that deal with each possible type of component. When the type of a component is identified, the various control variables are initialized to enable the logic in the rest of the class to work correctly.</p>
			<p>For example, if an update component is detected, then the <strong class="source-inline">m_HasUpdateComponent</strong>, <strong class="source-inline">m_NumberUpdateComponents</strong>, and <strong class="source-inline">m_FirstUpdateComponentLocation</strong> variables are initialized. </p>
			<p>As another example, if a collider component is detected along with the <strong class="source-inline">rect</strong> specific type, then the <strong class="source-inline">m_HasCollider</strong>, <strong class="source-inline">m_NumberRectColliderComponents</strong>, and <strong class="source-inline">m_FirstRectColliderComponent</strong> variables are initialized:</p>
			<p class="source-code">void GameObject::addComponent(shared_ptr&lt;Component&gt; component)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Components.push_back(component);</p>
			<p class="source-code">    component-&gt;enableComponent();</p>
			<p class="source-code">    </p>
			<p class="source-code">   if (component-&gt;getType() == "update") </p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_HasUpdateComponent = true;</p>
			<p class="source-code">        m_NumberUpdateComponents++;</p>
			<p class="source-code">        if (m_NumberUpdateComponents == 1) </p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_FirstUpdateComponentLocation = </p>
			<p class="source-code">                m_Components.size() - 1;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else if (component-&gt;getType() == "graphics") </p>
			<p class="source-code">    {</p>
			<p class="source-code">        // No iteration in the draw method required</p>
			<p class="source-code">        m_HasGraphicsComponent = true;</p>
			<p class="source-code">        m_GraphicsComponentLocation = m_Components.size() - 1;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else if (component-&gt;getType() == "transform") </p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Remember where the Transform component is</p>
			<p class="source-code">        m_TransformComponentLocation = m_Components.size() - 1;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else if (component-&gt;getType() == "collider" &amp;&amp; </p>
			<p class="source-code">        component-&gt;getSpecificType() == "rect") </p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Remember where the collider component(s) is</p>
			<p class="source-code">        m_HasCollider = true;</p>
			<p class="source-code">        m_NumberRectColliderComponents++;</p>
			<p class="source-code">        if (m_NumberRectColliderComponents == 1) </p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_FirstRectColliderComponentLocation = </p>
			<p class="source-code">                m_Components.size() - 1;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }    </p>
			<p class="source-code">}</p>
			<p>Note that the <strong class="source-inline">GameObject</strong> class plays no part in configuring or setting up the actual components themselves. It is all handled in the factory pattern class we will code in the next chapter.</p>
			<h3>Explaining the getter and setter functions</h3>
			<p>The following code is a series of very simple getters and setters:</p>
			<p class="source-code">void GameObject::setActive()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Active = true;</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObject::setInactive()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Active = false;</p>
			<p class="source-code">}</p>
			<p class="source-code">bool GameObject::isActive()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Active;</p>
			<p class="source-code">}</p>
			<p class="source-code">void GameObject::setTag(String tag)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Tag = "" + tag;</p>
			<p class="source-code">}</p>
			<p class="source-code">std::string GameObject::getTag()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Tag;</p>
			<p class="source-code">}</p>
			<p>The preceding getters and setters provide information about a game object, such as whether it is active and what its tag is. They also allow you to set the tag and tell us whether or not the game object is active.</p>
			<h3>Explaining the start function</h3>
			<p>The <strong class="source-inline">start</strong> function is an important one. As we saw when we coded all the components, the <strong class="source-inline">start</strong> function gives access to any component in any game object the components of any other game object. The <strong class="source-inline">start</strong> function is called once all the <strong class="source-inline">GameObject</strong> instances have been composed from all their components. In the next chapter, we will see how this happens, as well as when the <strong class="source-inline">start</strong> function is called on every <strong class="source-inline">GameObject</strong> instance. As we can see, in the <strong class="source-inline">start</strong> function, it loops through every component and shares a new class instance, a <strong class="source-inline">GameObjectSharer</strong> instance. This <strong class="source-inline">GameObjectSharer</strong> class will be coded in the next chapter and will give access to any component from any class. We saw how the invaders need to know where the player is and how the <strong class="source-inline">GameObjectSharer</strong> parameter is used when we coded the various components. When <strong class="source-inline">start</strong> is called on each component, the <strong class="source-inline">this</strong> pointer is also passed in to give each component easy access to its contained <strong class="source-inline">GameObject</strong> instance:</p>
			<p class="source-code">void GameObject::start(GameObjectSharer* gos) </p>
			<p class="source-code">{</p>
			<p class="source-code">    auto it = m_Components.begin();</p>
			<p class="source-code">    auto end = m_Components.end();</p>
			<p class="source-code">    for (it;</p>
			<p class="source-code">        it != end;</p>
			<p class="source-code">        ++it)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        (*it)-&gt;start(gos, this);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's move on to the <strong class="source-inline">getComponentByTypeAndSpecificType</strong> function.</p>
			<h3>Explaining the getComponentByTypeAndSpecificType function</h3>
			<p>The <strong class="source-inline">getComponentByTypeAndSpecificType</strong> function has a nested <strong class="source-inline">for</strong> loop that looks for a match of a component type to the first <strong class="source-inline">string</strong> parameter and then looks for a match of the specific component type in the second <strong class="source-inline">string</strong> parameter. It returns a shared pointer to a base class <strong class="source-inline">Component</strong> instance. This implies that the calling code needs to know exactly what derived <strong class="source-inline">Component</strong> type is being returned so that it can cast it to the required type. This shouldn't be a problem because, of course, they are requesting both a type and a specific type:</p>
			<p class="source-code">// Slow only use in start</p>
			<p class="source-code">shared_ptr&lt;Component&gt; GameObject::getComponentByTypeAndSpecificType(</p>
			<p class="source-code">    string type, string specificType) {</p>
			<p class="source-code">    auto it = m_Components.begin();</p>
			<p class="source-code">    auto end = m_Components.end();</p>
			<p class="source-code">    for (it;</p>
			<p class="source-code">        it != end;</p>
			<p class="source-code">        ++it)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if ((*it)-&gt;getType() == type)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            if ((*it)-&gt;getSpecificType() == specificType)</p>
			<p class="source-code">            {</p>
			<p class="source-code">                return  (*it);</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    #ifdef debuggingErrors        </p>
			<p class="source-code">        cout &lt;&lt; </p>
			<p class="source-code">            "GameObject.cpp::getComponentByTypeAndSpecificType-" </p>
			<p class="source-code">            &lt;&lt; "COMPONENT NOT FOUND ERROR!" </p>
			<p class="source-code">            &lt;&lt; endl;</p>
			<p class="source-code">    #endif</p>
			<p class="source-code">        return m_Components[0];</p>
			<p class="source-code">}</p>
			<p>The code in this function is quite slow and is therefore intended for use outside of the main game loop. At the end of this function, the code writes an error message to the console if <strong class="source-inline">debuggingErrors</strong> has been defined. The reason for this is because, if execution reaches this point, it means that no matching component was found, and the game will crash. The output to the console should make the error easy to find. The cause of the crash would be that the function was called for an invalid type or specific type.</p>
			<h3>Explaining the getEncompassingRectCollider function</h3>
			<p>The <strong class="source-inline">getEncompassingRectCollider</strong> function checks whether the game object has a collider and, if it has, returns it to the calling code:</p>
			<p class="source-code">FloatRect&amp; GameObject::getEncompassingRectCollider() </p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_HasCollider) </p>
			<p class="source-code">    {</p>
			<p class="source-code">        return (static_pointer_cast&lt;RectColliderComponent&gt;(</p>
			<p class="source-code">            m_Components[m_FirstRectColliderComponentLocation]))</p>
			<p class="source-code">            -&gt;getColliderRectF();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>It is worth noting that, if you extend this project to handle more than one type of collider, then this code would need adapting too.</p>
			<h3>Explaining the getEncompassingRectColliderTag function</h3>
			<p>This simple function returns the tag of the collider. This will be useful for determining what type of object is being tested for collision:</p>
			<p class="source-code">string GameObject::getEncompassingRectColliderTag() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return static_pointer_cast&lt;RectColliderComponent&gt;(</p>
			<p class="source-code">        m_Components[m_FirstRectColliderComponentLocation])-&gt;</p>
			<p class="source-code">        getColliderTag();</p>
			<p class="source-code">}</p>
			<p>We have just a few more functions to discuss.</p>
			<h3>Explaining the getFirstUpdateComponent function</h3>
			<p><strong class="source-inline">getFirstUpdateComponent</strong> uses the <strong class="source-inline">m_FirstUpdateComponent</strong> variable to locate the update component and then returns it to the calling code:</p>
			<p class="source-code">shared_ptr&lt;UpdateComponent&gt; GameObject::getFirstUpdateComponent()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return static_pointer_cast&lt;UpdateComponent&gt;(</p>
			<p class="source-code">        m_Components[m_FirstUpdateComponentLocation]);</p>
			<p class="source-code">}</p>
			<p>Now we're just going to go over a couple of getters, and then we are done.</p>
			<h3>Explaining the final getter functions</h3>
			<p>These two remaining functions return a Boolean (each) to tell the calling code whether the game object has a collider and/or an update component:</p>
			<p class="source-code">bool GameObject::hasCollider() </p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_HasCollider;</p>
			<p class="source-code">}</p>
			<p class="source-code">bool GameObject::hasUpdateComponent()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_HasUpdateComponent;</p>
			<p class="source-code">}</p>
			<p>We have coded the <strong class="source-inline">GameObject</strong> class in full. We can now look at putting it (and all the components it will be composed of) to work.</p>
			<h1 id="_idParaDest-417"><a id="_idTextAnchor431"/>Summary</h1>
			<p>In this chapter, we have completed all the code that will draw our game objects to the screen, control their behavior, and let them interact with other classes through collisions. The most important thing to take away from this chapter is not how any of the specific component-based classes work but how flexible the Entity-Component system is. If you want a game object that behaves in a certain way, create a new update component. If it needs to know about other objects in the game, get a pointer to the appropriate component in the <strong class="source-inline">start</strong> function. If it needs to be drawn in a fancy manner, perhaps with a shader or an animation, code a graphics component that performs the actions in the <strong class="source-inline">draw</strong> function. If you need multiple colliders, like we did for Thomas and Bob in the Thomas Was Late project, this is no problem: code a new collider-based component.</p>
			<p>In the next chapter, we will code the file input and output system, as well as the class that will be the factory that builds all the game objects and composes them with components.</p>
		</div>
	</body></html>