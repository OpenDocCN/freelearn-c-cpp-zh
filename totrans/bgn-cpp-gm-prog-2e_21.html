<html><head></head><body>
		<div><h1 id="_idParaDest-400"><a id="_idTextAnchor414"/><em class="italic">Chapter 20</em>: Game Objects and Components</h1>
			<p>In this chapter, we will be doing all the coding related to the Entity-Component pattern we discussed at the beginning of the previous chapter. This means we will code the base <code>Component</code> class, which all the other components will be derived from. We will also put our new knowledge of smart pointers to good use so that we don't have to concern ourselves with keeping track of the memory we allocate for these components. We will also code the <code>GameObject</code> class in this chapter.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Preparing to code the components</li>
				<li>Coding the Component base class</li>
				<li>Coding the collider components</li>
				<li>Coding the graphics components</li>
				<li>Coding the update components</li>
				<li>Coding the GameObject class</li>
			</ul>
			<p>Let's discuss the components a bit more before we start coding. Please note that, in this chapter, I will try and reinforce how the Entity-Component system fits together and how all the components compose a game object. I will not be explaining each and every line or even block of logic or SFML-related code that we have seen many times already. It is up to you to study these details.</p>
			<h1 id="_idParaDest-401"><a id="_idTextAnchor415"/>Preparing to code the components</h1>
			<p>As you work through this chapter, there will be lots of errors, and some of them won't seem logical. For example, you will get errors saying that a class doesn't exist when it is one of the classes you have already coded. The reason for this is that, when a class has an error in it, other classes can't reliably use it without getting errors as well. It is because of the interconnected nature of all the classes that we will not get rid of all the errors and have executable code again until near the end of the next chapter. It would have been possible to add code in smaller chunks to the various classes and the project would have been error-free more frequently. Doing things that gradually, however, would have meant constantly dipping in and out of classes. When you are building your own projects, this is sometimes a good way to do it, but I thought the most instructive thing to do for this project would be to help you get it built as quickly as possible. </p>
			<h1 id="_idParaDest-402"><a id="_idTextAnchor416"/>Coding the Component base class</h1>
			<p>Create a new header file in the <code>Header Files/GameObjects</code> filter called <code>Component.h</code> and add the following code:</p>
			<pre>#pragma once
#include "GameObjectSharer.h"
#include &lt;string&gt;
using namespace std;
class GameObject;
class Component {
public:
    virtual string getType() = 0;
    virtual string getSpecificType() = 0;
    virtual void disableComponent() = 0;
    virtual void enableComponent() = 0;
    virtual bool enabled() = 0;
    virtual void start(GameObjectSharer* gos, GameObject* self) = 0;
};</pre>
			<p>This is the base class of every component in every game object. The pure virtual functions mean that a component can never be instantiated and must always be inherited from first. Functions allow the type and specific type of a component to be accessed. Component types include collider, graphics, transform, and update, but more types could be added in line with the requirements of the game. Specific types include standard graphics, invader update, player update, and more besides.</p>
			<p>There are two functions that allow the component to be enabled and disabled. This is useful because a component can then be tested for whether it is currently enabled before it is used. For example, you could call the <code>enabled</code> function to test whether a component's update component was enabled before calling its <code>update</code> function or that a graphics component is enabled before calling its <code>draw</code> function. </p>
			<p>The <code>start</code> function is probably the most interesting function because it has a new class type as one of its parameters. The <code>GameObjectSharer</code> class will give access to all the game objects after they have been instantiated with all their components. This will give every component in every game object the opportunity to query details and even obtain a pointer to a specific piece of data in another game object. As an example, all an invader's update components will need to know the location of the player's transform component so that it knows when to fire a bullet. Absolutely any part of any object can be accessed in the <code>start</code> function. The point is that each specific component will decide what they need and there is no requirement during the critical game loop to start querying for the details of another game object.</p>
			<p>The <code>GameObject</code> that the component is contained in is also passed to the <code>start</code> function so that any component can find out more about itself as well. For example, a graphics component needs to know about the transform component so that it knows where to draw itself. As a second example, the update components of the invaders and the player's ship will need a pointer to their own collider component so that they can update its location whenever they move. </p>
			<p>We will see more use cases for the <code>start</code> function as we progress.</p>
			<p>Create a new source file in the <code>Source Files/GameObjects</code> filter called <code>Component.cpp</code> and add the following code:</p>
			<pre>/*********************************
******THIS IS AN INTERFACE********
*********************************/</pre>
			<p>As the <code>Component</code> class can never be instantiated, I have put the preceding comments in <code>Component.cpp</code> as a reminder.</p>
			<h1 id="_idParaDest-403"><a id="_idTextAnchor417"/>Coding the collider components</h1>
			<p>The Space Invaders ++ game will only have one simple type of collider. It will be a rectangular box around the object, just like those we had in the Zombie Apocalypse and Pong games. However, it is easily conceivable that you might need other types of collider; perhaps a circle-shaped collider or a non-encompassing collider such as those we used for the head, feet, and sides of Thomas and Bob back in the Thomas Was Late game.</p>
			<p>For this reason, there will be a base <code>ColliderComponent</code> class (that inherits from <code>Component</code>) which will handle the basic functionality of all the colliders, as well as <code>RectColliderComponent</code>, which will add the specific functionality of an all-encompassing rectangle-shaped collider. New collider types can then be added as required for the game being developed.</p>
			<p>What follows is the base class to the specific collider, <code>ColliderComponent</code>.</p>
			<h2 id="_idParaDest-404"><a id="_idTextAnchor418"/>Coding the ColliderComponent class</h2>
			<p>Create a new header file in the <code>Header Files/GameObjects</code> filter called <code>ColliderComponent.h</code> and add the following code:</p>
			<pre>#pragma once
#include "Component.h"
#include &lt;iostream&gt;
class ColliderComponent : public Component
{
private:
    string m_Type = "collider";
    bool m_Enabled = false;
public:
    /****************************************************
    *****************************************************
    From Component interface
    *****************************************************
    *****************************************************/
    string Component::getType() {
        return m_Type;
    }
    void Component::disableComponent() {
        m_Enabled = false;
    }
    void Component::enableComponent() {
        m_Enabled = true;
    }
    bool Component::enabled() {
        return m_Enabled;
    }
   void Component::start(GameObjectSharer* gos, GameObject* self)
   {
        
    }
};</pre>
			<p>The <code>ColliderComponent</code> class inherits from the <code>Component</code> class. In the preceding code, you can see that the <code>m_Type</code> member variable is initialized to <code>"collider"</code> and that <code>m_Enabled</code> is initialized to <code>false</code>.</p>
			<p>In the <code>public</code> section, the code overrides the pure virtual functions of the <code>Component</code> class. Study them to become familiar with them because they work in a very similar way in all the component classes. The <code>getType</code> function returns <code>m_Type</code>. The <code>disableComponent</code> function sets <code>m_Enabled</code> to <code>false</code>. The <code>enableComponent</code> function sets <code>m_Enabled</code> to <code>true</code>. The <code>enabled</code> function returns the value of <code>m_Enabled</code>. The <code>start</code> function has no code but will be overridden by many of the more specific component-based classes.</p>
			<p>Create a new source file in the <code>Source Files/GameObjects</code> filter called <code>ColliderComponent.cpp</code> and add the following code:</p>
			<pre>/*
All Functionality in ColliderComponent.h
*/</pre>
			<p>I added the preceding comments to <code>ColliderComponent.cpp</code> to remind myself that all the functionality is in the header file.</p>
			<h2 id="_idParaDest-405"><a id="_idTextAnchor419"/>Coding the RectColliderComponent class</h2>
			<p>Create a new header file in the <code>Header Files/GameObjects</code> filter called <code>RectColliderComponent.h</code> and add the following code:</p>
			<pre>#pragma once
#include "ColliderComponent.h"
#include &lt;SFML/Graphics.hpp&gt;
using namespace sf;
class RectColliderComponent : public ColliderComponent
{
private:
    string m_SpecificType = "rect";
    FloatRect m_Collider;
    string m_Tag = "";
public:
    RectColliderComponent(string name);
    string getColliderTag();
    void setOrMoveCollider(
        float x, float y, float width, float height);
        
    FloatRect&amp; getColliderRectF();
    /****************************************************
    *****************************************************
    From Component interface base class
    *****************************************************
    *****************************************************/
    string getSpecificType() {
        return m_SpecificType;
    }
    
    void Component::start(
        GameObjectSharer* gos, GameObject* self) {}
};</pre>
			<p>The <code>RectColliderComponent</code> class inherits from the <code>ColliderComponent</code> class. It has a <code>m_SpecificType</code> variable initialized to <code>"rect"</code>. It is now possible to query any <code>RectColliderComponent</code> instance in a vector of generic <code>Component</code> instances and determine that it has a type of  <code>"collider"</code> and a specific type of  <code>"rect"</code>. All component-based classes will have this functionality because of the pure virtual functions of the <code>Component</code> class.</p>
			<p>There is also a <code>FloatRect</code> instance called <code>m_Collider</code> that will store the coordinates of this collider.</p>
			<p>In the <code>public</code> section, we can view the constructor. Notice that it receives a <code>string</code>. The value that's passed in will be text that identifies the type of game object this <code>RectColliderComponent</code> is attached to, such as an invader, a bullet, or the player's ship. It will then be possible to determine what type of objects have collided with each other.</p>
			<p>There are three more functions before the overridden functions; make a note of their names and parameters and then we will discuss them in a moment when we code their definitions.</p>
			<p>Note that the <code>getSpecificType</code> function definition returns <code>m_SpecificType</code>.</p>
			<p>Create a new source file in the <code>Source Files/GameObjects</code> filter called <code>RectColliderComponent.cpp</code> and add the following code:</p>
			<pre>#include "RectColliderComponent.h"
RectColliderComponent::RectColliderComponent(string name) {
    m_Tag = "" + name;
}
string RectColliderComponent::getColliderTag() {
    return m_Tag;
}
void RectColliderComponent::setOrMoveCollider(
    float x, float y, float width, float height) {
        
    m_Collider.left = x;
    m_Collider.top = y;
    m_Collider.width = width;
    m_Collider.height = height;
}
FloatRect&amp; RectColliderComponent::getColliderRectF() {
    return m_Collider;
}</pre>
			<p>In the constructor, the passed-in <code>string</code> value is assigned to the <code>m_Tag</code> variable and the <code>getColliderTag</code> function makes that value available via the instance of the class.</p>
			<p>The <code>setOrMoveCollider</code> function positions <code>m_Collider</code> at the coordinates passed in as arguments. </p>
			<p>The <code>getColliderRectF</code> function returns a reference to <code>m_Collider</code>. This is ideal for carrying out a collision test with another collider using the <code>intersects</code> function of the <code>FloatRect</code> class.</p>
			<p>Our colliders are now complete and we can move on to the graphics.</p>
			<h1 id="_idParaDest-406"><a id="_idTextAnchor420"/>Coding the graphics components</h1>
			<p>The Space Invaders ++ game will only have one specific type of graphics component. It is called <code>StandardGraphicsComponent</code>. As with the collider components, we will implement a base <code>GraphicsComponent</code> class to make it easy to add other graphics-related components, should we wish. For example, in the classic arcade version of Space Invaders, the invaders flapped their arms up and down with two frames of animation. Once you see how <code>StandardGraphicsComponent</code> works, you will be able to easily code another class (perhaps <code>AnimatedGraphicsComponent</code>) that draws itself with a different <code>Sprite</code> instance every half a second or so. You could also have a graphics component that has a shader (perhaps <code>ShaderGraphicsComponent</code>) for fast and cool effects. There are more possibilities besides these.</p>
			<h2 id="_idParaDest-407"><a id="_idTextAnchor421"/>Coding the GraphicsComponent class</h2>
			<p>Create a new header file in the <code>Header Files/GameObjects</code> filter called <code>GraphicsComponent.h</code> and add the following code:</p>
			<pre>#pragma once
#include "Component.h"
#include "TransformComponent.h"
#include &lt;string&gt;
#include &lt;SFML/Graphics.hpp&gt;
#include "GameObjectSharer.h"
#include &lt;iostream&gt;
using namespace sf;
using namespace std;
class GraphicsComponent : public Component {
private:
    string m_Type = "graphics";
    bool m_Enabled = false;
public:
    virtual void draw(
        RenderWindow&amp; window,
        shared_ptr&lt;TransformComponent&gt; t) = 0;
    virtual void initializeGraphics(
        string bitmapName,
        Vector2f objectSize) = 0;
    /****************************************************
    *****************************************************
    From Component interface
    *****************************************************
    *****************************************************/
    string Component::getType() {
        return m_Type;
    }
    void Component::disableComponent() {
        m_Enabled = false;
    }
    void Component::enableComponent() {
        m_Enabled = true;
    }
    bool Component::enabled() {
        return m_Enabled;
    }
    void Component::start(
        GameObjectSharer* gos, GameObject* self) {}
};</pre>
			<p>Most of the preceding code implements the <code>Component</code> class's pure virtual functions. What's new to the <code>GraphicsComponent</code> class is the <code>draw</code> function, which has two parameters. The first parameter is a reference to the <code>RenderWindow</code> instance so that the component can draw itself, while the second is a shared smart pointer to the <code>TransformComponent</code> instance of the <code>GameObject</code> so that vital data such as position and scale can be accessed each frame of the game.</p>
			<p>What's also new in the <code>GraphicsComponent</code> class is the <code>initializeGraphics</code> function, which also has two parameters. The first is a <code>string</code> value that represents the file name of the graphics file to be used, while the second is a <code>Vector2f</code> instance that will represent the size of the object in the game world. </p>
			<p>Both preceding functions are pure virtual, which makes the <code>GraphicsComponent</code> class abstract. Any class that inherits from <code>GraphicsComponent</code> will need to implement these functions. In the next section, we will see how <code>StandardGraphicsComponent</code> does so.</p>
			<p>Create a new source file in the <code>Source Files/GameObjects</code> filter called <code>GraphicsComponent.cpp</code> and add the following code:</p>
			<pre>/*
All Functionality in GraphicsComponent.h
*/</pre>
			<p>The preceding comment is a reminder that the code is all within the related header file.</p>
			<h2 id="_idParaDest-408"><a id="_idTextAnchor422"/>Coding the StandardGraphicsComponent class</h2>
			<p>Create a new header file in the <code>Header Files/GameObjects</code> filter called <code>StandardGraphicsComponent.h</code> and add the following code:</p>
			<pre>#pragma once
#include "Component.h"
#include "GraphicsComponent.h"
#include &lt;string&gt;
class Component;
class StandardGraphicsComponent : public GraphicsComponent {
private:
    sf::Sprite m_Sprite;
    string m_SpecificType = "standard";
public:
    /****************************************************
    *****************************************************
    From Component interface base class
    *****************************************************
    *****************************************************/
    string Component::getSpecificType() {
        return m_SpecificType;
    }
    
    void Component::start(
        GameObjectSharer* gos, GameObject* self) {
    }
    /****************************************************
    *****************************************************
    From GraphicsComponent
    *****************************************************
    *****************************************************/
    void draw(
        RenderWindow&amp; window,
        shared_ptr&lt;TransformComponent&gt; t) override;
    void initializeGraphics(
        string bitmapName,
        Vector2f objectSize) override;
};</pre>
			<p>The <code>StandardGraphicsComponent</code> class has a <code>Sprite</code> member. It doesn't need a <code>Texture</code> instance because that will be obtained each frame from the <code>BitmapStore</code> class. This class also overrides the required functions from both the <code>Component</code> and <code>GraphicsComponent</code> classes.</p>
			<p>Let's code the implementation of the two pure virtual functions, <code>draw</code> and <code>initializeGraphics</code>.</p>
			<p>Create a new source file in the <code>Source Files/GameObjects</code> filter called <code>StandardGraphicsComponent.cpp</code> and add the following code:</p>
			<pre>#include "StandardGraphicsComponent.h"
#include "BitmapStore.h"
#include &lt;iostream&gt;
void StandardGraphicsComponent::initializeGraphics(
    string bitmapName,
    Vector2f objectSize)
{
    BitmapStore::addBitmap("graphics/" + bitmapName + ".png");
    m_Sprite.setTexture(BitmapStore::getBitmap(
        "graphics/" + bitmapName + ".png"));
    auto textureSize = m_Sprite.getTexture()-&gt;getSize();
    m_Sprite.setScale(float(objectSize.x) / textureSize.x, 
        float(objectSize.y) / textureSize.y);    
    m_Sprite.setColor(sf::Color(0, 255, 0)); 
}
void StandardGraphicsComponent::draw(
    RenderWindow&amp; window,
    shared_ptr&lt;TransformComponent&gt; t)
{
    m_Sprite.setPosition(t-&gt;getLocation());
    window.draw(m_Sprite);
}</pre>
			<p>In the <code>initializeGraphics</code> function, the <code>addBitmap</code> function of the <code>BitmapStore</code> class is called and the file path of the image, along with the size of the object in the game world, is passed in.</p>
			<p>Next, the <code>Texture</code> instance that was just added to the <code>BitmapStore</code> class is retrieved and set as the image for the <code>Sprite</code>. Following on, two functions, <code>getTexture</code> and <code>getSize</code>, are chained together to get the size of the texture.</p>
			<p>The next line of code uses the <code>setScale</code> function to make the <code>Sprite</code> the same size as the texture, which in turn was set to the size of this object in the game world.</p>
			<p>The <code>setColor</code> function then applies a green tint to the <code>Sprite</code>. This gives it a bit more of a retro feel.</p>
			<p>In the <code>draw</code> function, the <code>Sprite</code> is moved into position using <code>setPosition</code> and the <code>getLocation</code> function of <code>TransformComponent</code>. We'll code the <code>TransformComponent</code> class next.</p>
			<p>The final line of code draws the <code>Sprite</code> to <code>RenderWindow</code>.</p>
			<h1 id="_idParaDest-409"><a id="_idTextAnchor423"/>Coding the TransformComponent class</h1>
			<p>Create a new header file in the <code>Header Files/GameObjects</code> filter called <code>TransformComponent.h</code> and add the following code:</p>
			<pre>#pragma once
#include "Component.h"
#include&lt;SFML/Graphics.hpp&gt;
using namespace sf;
class Component;
class TransformComponent : public Component {
private:
    const string m_Type = "transform";
    Vector2f m_Location;
    float m_Height;
    float m_Width;
public:
    TransformComponent(
        float width, float height, Vector2f location);
    Vector2f&amp; getLocation();
    Vector2f getSize();
    /****************************************************
    *****************************************************
    From Component interface
    *****************************************************
    *****************************************************/
    string Component::getType()
    {
        return m_Type;
    }
    string Component::getSpecificType()
    {
        // Only one type of Transform so just return m_Type
        return m_Type;
    }
    void Component::disableComponent(){}
    void Component::enableComponent(){}
    bool Component::enabled()
    {
        return false;
    }
    void Component::start(GameObjectSharer* gos, GameObject* self)    {}
};</pre>
			<p>This class has a <code>Vector2f</code> to store the position of the object in the game world, a <code>float</code> to store the height, and another <code>float</code> to store the width.</p>
			<p>In the <code>public</code> section, there is a constructor we will use to set up the instances of this class, as well as two functions, <code>getLocation</code> and <code>getSize</code>, we'll use to share the location and size of the object. We  used these functions already when we coded the <code>StandardGraphicsComponent</code> class.</p>
			<p>The remaining code in the <code>TransformComponent.h</code> file is the implementation of the <code>Component</code> class.</p>
			<p>Create a new source file in the <code>Source Files/GameObjects</code> filter called <code>TransformComponent.cpp</code> and add the following code:</p>
			<pre>#include "TransformComponent.h"
TransformComponent::TransformComponent(
    float width, float height, Vector2f location)
{
    m_Height = height;
    m_Width = width;
    m_Location = location;
}
Vector2f&amp; TransformComponent::getLocation() 
{
    return m_Location;
}
Vector2f TransformComponent::getSize() 
{
    return Vector2f(m_Width, m_Height);
}</pre>
			<p>Implementing the three functions of this class is straightforward. The constructor receives a size and location and initializes the appropriate member variables. The <code>getLocation</code> and <code>getSize</code> functions return this data when it is requested. Notice that the values are returned by reference, so they will be modifiable by the calling code.</p>
			<p>Next, we will code all update-related components.</p>
			<h1 id="_idParaDest-410"><a id="_idTextAnchor424"/>Coding update components</h1>
			<p>As you might expect by now, we will code an <code>UpdateComponent</code> class that will inherit from the <code>Component</code> class. It will have all the functionality that every <code>UpdateComponent</code> will need and then we will code classes derived from <code>UpdateComponent</code>. These will contain functionality specific to individual objects in the game. For this game, we will have <code>BulletUpdateComponent</code>, <code>InvaderUpdateComponent</code>, and <code>PlayerUpdateComponent</code>. When you work on your own project and you want an object in the game that behaves in a specific unique manner, just code a new update-based component for it and you'll be good-to-go. Update-based components define behavior.</p>
			<h2 id="_idParaDest-411"><a id="_idTextAnchor425"/>Coding the UpdateComponent class</h2>
			<p>Create a new header file in the <code>Header Files/GameObjects</code> filter called <code>UpdateComponent.h</code> and add the following code:</p>
			<pre>#pragma once
#include "Component.h"
class UpdateComponent : public Component
{
private:
    string m_Type = "update";
    bool m_Enabled = false;
public:
    virtual void update(float fps) = 0;
    
    /****************************************************
    *****************************************************
    From Component interface
    *****************************************************
    *****************************************************/
    string Component::getType() {
        return m_Type;
    }
    void Component::disableComponent() {
        m_Enabled = false;
    }
    void Component::enableComponent() {
        m_Enabled = true;
    }
    bool Component::enabled() {
        return m_Enabled;
    }
    void Component::start(
        GameObjectSharer* gos, GameObject* self) {
    }
};</pre>
			<p><code>UpdateComponent</code> only brings one piece of functionality: the <code>update</code> function. This function is pure virtual so it must be implemented by any class that aspires to be a usable instance of <code>UpdateComponent</code>.</p>
			<p>Create a new source file in the <code>Source Files/GameObjects</code> filter called <code>UpdateComponent.cpp</code> and add the following code:</p>
			<pre>/*
All Functionality in UpdateComponent.h
*/</pre>
			<p>This is a helpful comment to remind us that this class has all its code in the related header file.</p>
			<h2 id="_idParaDest-412"><a id="_idTextAnchor426"/>Coding the BulletUpdateComponent class</h2>
			<p>Create a new header file in the <code>Header Files/GameObjects</code> filter called <code>BulletUpdateComponent.h</code> and add the following code:</p>
			<pre>#pragma once
#include "UpdateComponent.h"
#include "TransformComponent.h"
#include "GameObjectSharer.h"
#include "RectColliderComponent.h"
#include "GameObject.h"
class BulletUpdateComponent : public UpdateComponent
{
private:
    string m_SpecificType = "bullet";
    shared_ptr&lt;TransformComponent&gt; m_TC;
    shared_ptr&lt;RectColliderComponent&gt; m_RCC;
    float m_Speed = 75.0f;
    
    int m_AlienBulletSpeedModifier;
    int m_ModifierRandomComponent = 5;
    int m_MinimumAdditionalModifier = 5;
    bool m_MovingUp = true;
public:
    bool m_BelongsToPlayer = false;
    bool m_IsSpawned = false;
    void spawnForPlayer(Vector2f spawnPosition);
    void spawnForInvader(Vector2f spawnPosition);
    void deSpawn();
    bool isMovingUp();
    /****************************************************
    *****************************************************
    From Component interface base class
    *****************************************************
    *****************************************************/
    string Component::getSpecificType() {
        return m_SpecificType;
    }
    
    void Component::start(
        GameObjectSharer* gos, GameObject* self) {        
        // Where is this specific invader
        m_TC = static_pointer_cast&lt;TransformComponent&gt;(
            self-&gt;getComponentByTypeAndSpecificType(
                "transform", "transform"));
        m_RCC = static_pointer_cast&lt;RectColliderComponent&gt;(
            self-&gt;getComponentByTypeAndSpecificType(
                "collider", "rect"));
    }
    /****************************************************
    *****************************************************
    From UpdateComponent
    *****************************************************
    *****************************************************/
    void update(float fps) override;
};</pre>
			<p>If you want to understand the behavior/logic of a bullet, you will need to spend some time learning the names and types of the member variables as I won't be explaining precisely how a bullet behaves; we have covered these topics many times. I will, however, point out that there are variables to cover basics such as movement, variables to help randomize the speed of each bullet within a certain range, and Booleans that identify whether the bullet belongs to the player or an invader.</p>
			<p>The key thing which you don't yet know but will have to learn here is that each <code>BulletUpdateComponent</code> instance will hold a shared pointer to the owning game object's <code>TransformComponent</code> instance and a shared pointer to the owning game object's <code>RectColliderComponent</code> instance.</p>
			<p>Now, look closely at the overridden <code>start</code> function. In the <code>start</code> function, the aforementioned shared pointers are initialized. The code achieves this by using the <code>getComponentByTypeAndSpecificType</code> function of the owning game object (<code>self</code>), which is a pointer to the owning game object. We will code the <code>GameObject</code> class, including this function, in a later section.</p>
			<p>Create a new source file in the <code>Source Files/GameObjects</code> filter called <code>BulletUpdate.cpp</code> and add the following code:</p>
			<pre>#include "BulletUpdateComponent.h"
#include "WorldState.h"
void BulletUpdateComponent::spawnForPlayer(
    Vector2f spawnPosition)
{
    m_MovingUp = true;
    m_BelongsToPlayer = true;
    m_IsSpawned = true;
    
    m_TC-&gt;getLocation().x = spawnPosition.x;
    // Tweak the y location based on the height of the bullet 
    // The x location is already tweaked to the center of the player
    m_TC-&gt;getLocation().y = spawnPosition.y - m_TC-&gt;getSize().y;
    // Update the collider
    m_RCC-&gt;setOrMoveCollider(m_TC-&gt;getLocation().x,
        m_TC-&gt;getLocation().y, 
        m_TC-&gt;getSize().x, m_TC-&gt;getSize().y);
}
void BulletUpdateComponent::spawnForInvader(
    Vector2f spawnPosition)
{
    m_MovingUp = false;
    m_BelongsToPlayer = false;
    m_IsSpawned = true;
    srand((int)time(0));
    m_AlienBulletSpeedModifier = (
        ((rand() % m_ModifierRandomComponent)))  
        + m_MinimumAdditionalModifier;    
    m_TC-&gt;getLocation().x = spawnPosition.x;
    // Tweak the y location based on the height of the bullet 
    // The x location already tweaked to the center of the invader
    m_TC-&gt;getLocation().y = spawnPosition.y;
    // Update the collider
    m_RCC-&gt;setOrMoveCollider(
        m_TC-&gt;getLocation().x, m_TC-&gt;
        getLocation().y, m_TC-&gt;getSize().x, m_TC-&gt;getSize().y);
}
void BulletUpdateComponent::deSpawn()
{
    m_IsSpawned = false;
}
bool BulletUpdateComponent::isMovingUp()
{
    return m_MovingUp;
}
void BulletUpdateComponent::update(float fps)
{
    if (m_IsSpawned)
    {    
        if (m_MovingUp)
        {
            m_TC-&gt;getLocation().y -= m_Speed * fps;
        }
        else
        {
            m_TC-&gt;getLocation().y += m_Speed / 
                m_AlienBulletSpeedModifier * fps;
        }
        if (m_TC-&gt;getLocation().y &gt; WorldState::WORLD_HEIGHT 
            || m_TC-&gt;getLocation().y &lt; -2)
        {
            deSpawn();
        }
        // Update the collider
        m_RCC-&gt;setOrMoveCollider(m_TC-&gt;getLocation().x, 
            m_TC-&gt;getLocation().y, 
            m_TC-&gt;getSize().x, m_TC-&gt;getSize().y);
    }
}</pre>
			<p>The first two functions are unique to the <code>BulletUpdateComponent</code> class; they are <code>spawnForPlayer</code> and <code>spawnForInvader</code>. Both of these functions prepare the member variables, transform component and collider component for action. Each one does so in a slightly different way. For example, for a player-owned bullet, it is prepared to move up the screen from the top of the player's ship, while a bullet is prepared for an invader to move down the screen from the underside of an invader. The key thing to notice is that all this is achievable via the shared pointers to the transform component and the collider component. Also, note that the <code>m_IsSpawned</code> Boolean is set to true, making this update component's <code>update</code> function ready to call each frame of the game.</p>
			<p>In the <code>update</code> function, the bullet is moved up or down the screen at the appropriate speed. It is tested to see if it has disappeared off the top or bottom of the screen, and the collider is updated to wrap around the current location so that we can test for collisions. </p>
			<p>This is the same logic we have seen throughout this book; what's new is the shared pointers we are using to communicate with the other components that make up this game object.</p>
			<p>The bullets just need to be spawned and tested for collisions; we will see how to do that in the next two chapters. Now, we will code the behavior of the invaders.</p>
			<h2 id="_idParaDest-413"><a id="_idTextAnchor427"/>Coding the InvaderUpdateComponent class</h2>
			<p>Create a new header file in the <code>Header Files/GameObjects</code> filter called <code>InvaderUpdateComponent.h</code> and add the following code:</p>
			<pre>#pragma once
#include "UpdateComponent.h"
#include "TransformComponent.h"
#include "GameObjectSharer.h"
#include "RectColliderComponent.h"
#include "GameObject.h"
class BulletSpawner;
class InvaderUpdateComponent : public UpdateComponent
{
private:
    string m_SpecificType = "invader";
    shared_ptr&lt;TransformComponent&gt; m_TC;
    shared_ptr &lt; RectColliderComponent&gt; m_RCC;
    shared_ptr &lt; TransformComponent&gt; m_PlayerTC;
    shared_ptr &lt; RectColliderComponent&gt; m_PlayerRCC;
    BulletSpawner* m_BulletSpawner;
    float m_Speed = 10.0f;
    bool m_MovingRight = true;
    float m_TimeSinceLastShot;
    float m_TimeBetweenShots = 5.0f;
    float m_AccuracyModifier;
    float m_SpeedModifier = 0.05;
    int m_RandSeed;
public:
    void dropDownAndReverse();
    bool isMovingRight();
    void initializeBulletSpawner(BulletSpawner* 
        bulletSpawner, int randSeed);
    /****************************************************
    *****************************************************
    From Component interface base class
    *****************************************************
    *****************************************************/
    string Component::getSpecificType() {
        return m_SpecificType;
    }
    void Component::start(GameObjectSharer* gos, 
        GameObject* self) {
            
        // Where is the player?
        m_PlayerTC = static_pointer_cast&lt;TransformComponent&gt;(
            gos-&gt;findFirstObjectWithTag("Player")
            .getComponentByTypeAndSpecificType(
                "transform", "transform"));
        m_PlayerRCC = static_pointer_cast&lt;RectColliderComponent&gt;(
            gos-&gt;findFirstObjectWithTag("Player")
            .getComponentByTypeAndSpecificType(
                "collider", "rect"));
        // Where is this specific invader
        m_TC = static_pointer_cast&lt;TransformComponent&gt;(
            self-&gt;getComponentByTypeAndSpecificType(
                "transform", "transform"));
        m_RCC = static_pointer_cast&lt;RectColliderComponent&gt;(
            self-&gt;getComponentByTypeAndSpecificType(
                "collider", "rect"));
    }
    /****************************************************
    *****************************************************
    From UpdateComponent
    *****************************************************
    *****************************************************/
    void update(float fps) override;    
};</pre>
			<p>In the class declaration, we can see all the features that we need in order to code the behavior of an invader. There is a pointer to the transform component so that the invader can move, as well as a pointer to the collider component so that it can update its location and be collided with:</p>
			<pre>shared_ptr&lt;TransformComponent&gt; m_TC;
shared_ptr &lt; RectColliderComponent&gt; m_RCC;</pre>
			<p>There are pointers to the player's transform and collider so that an invader can query the position of the player and make decisions about when to shoot bullets:</p>
			<pre>shared_ptr &lt; TransformComponent&gt; m_PlayerTC;
shared_ptr &lt; RectColliderComponent&gt; m_PlayerRCC;</pre>
			<p>Next, there is a <code>BulletSpawner</code> instance, which we will code in the next chapter. The <code>BulletSpawner</code> class will allow an invader or the player to spawn a bullet. </p>
			<p>What follows is a whole bunch of variables that we will use to control the speed, direction, rate of fire, the precision with which the invader aims, and the speed of bullets that are fired. Familiarize yourself with them as they will be used in fairly in-depth logic in the function definitions:</p>
			<pre>float m_Speed = 10.0f;
bool m_MovingRight = true;
float m_TimeSinceLastShot;
float m_TimeBetweenShots = 5.0f;
float m_AccuracyModifier;
float m_SpeedModifier = 0.05;
int m_RandSeed;</pre>
			<p>Next, we can see three new public functions that different parts of the system can call to make the invaders move down a little and head in the other direction, test the direction of travel, and pass in a pointer to the aforementioned <code>BulletSpawner</code> class, respectively: </p>
			<pre>void dropDownAndReverse();
bool isMovingRight();
void initializeBulletSpawner(BulletSpawner* 
        bulletSpawner, int randSeed);</pre>
			<p>Be sure to study the <code>start</code> function where the smart pointers to the invader and the player are initialized. Now, we will code the function definitions.</p>
			<p>Create a new source file in the <code>Source Files/GameObjects</code> filter called <code>InvaderUpdate.cpp</code> and add the following code:</p>
			<pre>#include "InvaderUpdateComponent.h"
#include "BulletSpawner.h"
#include "WorldState.h"
#include "SoundEngine.h"
void InvaderUpdateComponent::update(float fps)
{
    if (m_MovingRight)
    {
        m_TC-&gt;getLocation().x += m_Speed * fps;
    }
    else
    {
        m_TC-&gt;getLocation().x -= m_Speed * fps;
    }
    // Update the collider
    m_RCC-&gt;setOrMoveCollider(m_TC-&gt;getLocation().x, 
        m_TC-&gt;getLocation().y, m_TC-&gt;getSize().x, m_TC-
      &gt;getSize().y);
    m_TimeSinceLastShot += fps;
    
    // Is the middle of the invader above the 
   // player +- 1 world units
    if ((m_TC-&gt;getLocation().x + (m_TC-&gt;getSize().x / 2)) &gt; 
        (m_PlayerTC-&gt;getLocation().x - m_AccuracyModifier) &amp;&amp;
        (m_TC-&gt;getLocation().x + (m_TC-&gt;getSize().x / 2)) &lt; 
        (m_PlayerTC-&gt;getLocation().x + 
        (m_PlayerTC-&gt;getSize().x + m_AccuracyModifier)))
    {
        // Has the invader waited long enough since the last shot
        if (m_TimeSinceLastShot &gt; m_TimeBetweenShots)
        {
            SoundEngine::playShoot();
            Vector2f spawnLocation;
            spawnLocation.x = m_TC-&gt;getLocation().x + 
                m_TC-&gt;getSize().x / 2;
            spawnLocation.y = m_TC-&gt;getLocation().y + 
                m_TC-&gt;getSize().y;
            m_BulletSpawner-&gt;spawnBullet(spawnLocation, false);
            srand(m_RandSeed);
            int mTimeBetweenShots = (((rand() % 10))+1) / 
                WorldState::WAVE_NUMBER;
            m_TimeSinceLastShot = 0;            
        }
    }
}
void InvaderUpdateComponent::dropDownAndReverse()
{
    m_MovingRight = !m_MovingRight;
    m_TC-&gt;getLocation().y += m_TC-&gt;getSize().y;
    m_Speed += (WorldState::WAVE_NUMBER) + 
        (WorldState::NUM_INVADERS_AT_START 
       - WorldState::NUM_INVADERS) 
        * m_SpeedModifier;
}
bool InvaderUpdateComponent::isMovingRight()
{
    return m_MovingRight;
}
void InvaderUpdateComponent::initializeBulletSpawner(
    BulletSpawner* bulletSpawner, int randSeed)
{
    m_BulletSpawner = bulletSpawner;
    m_RandSeed = randSeed;
    srand(m_RandSeed);
    m_TimeBetweenShots = (rand() % 15 + m_RandSeed);
    m_AccuracyModifier = (rand() % 2);
    m_AccuracyModifier += 0 + static_cast &lt;float&gt; (
        rand()) / (static_cast &lt;float&gt; (RAND_MAX / (10)));
}</pre>
			<p>That was a lot of code. Actually, there's no C++ code in there that we haven't seen before. It is all just logic to control the behavior of an invader. Let's get an overview of what it all does, with parts of the code reprinted for convenience.</p>
			<h3>Explaining the update function</h3>
			<p>The first <code>if</code> and <code>else</code> blocks move the invader right or left each frame, as appropriate:</p>
			<pre>void InvaderUpdateComponent::update(float fps)
{
    if (m_MovingRight)
    {
        m_TC-&gt;getLocation().x += m_Speed * fps;
    }
    else
    {
        m_TC-&gt;getLocation().x -= m_Speed * fps;
    }</pre>
			<p>Next, the collider is updated to the new position:</p>
			<pre>    // Update the collider
    m_RCC-&gt;setOrMoveCollider(m_TC-&gt;getLocation().x, 
        m_TC-&gt;getLocation().y, m_TC-&gt;getSize().x, m_TC 
      -&gt;getSize().y);</pre>
			<p>This code tracks how long it's been since this invader last fired a shot and then tests to see if the player is one world unit to the left or right of the invader (+ or – for the random accuracy modifier, so that each invader is a little bit different):</p>
			<pre>   m_TimeSinceLastShot += fps;
    
    // Is the middle of the invader above the 
   // player +- 1 world units
    if ((m_TC-&gt;getLocation().x + (m_TC-&gt;getSize().x / 2)) &gt; 
        (m_PlayerTC-&gt;getLocation().x - m_AccuracyModifier) &amp;&amp;
        (m_TC-&gt;getLocation().x + (m_TC-&gt;getSize().x / 2)) &lt; 
        (m_PlayerTC-&gt;getLocation().x + 
        (m_PlayerTC-&gt;getSize().x + m_AccuracyModifier)))
    {</pre>
			<p>Inside the preceding <code>if</code> test, another test makes sure that the invader has waited long enough since the last shot it took. If it has, then a shot is taken. A sound is played, a spawn location for the bullet is calculated, the <code>spawnBullet</code> function of the <code>BulletSpawner</code> instance is called, and a new random time to wait before another shot can be taken is calculated:</p>
			<pre>        // Has the invader waited long enough since the last shot
        if (m_TimeSinceLastShot &gt; m_TimeBetweenShots)
        {
            SoundEngine::playShoot();
            Vector2f spawnLocation;
            spawnLocation.x = m_TC-&gt;getLocation().x + 
                m_TC-&gt;getSize().x / 2;
            spawnLocation.y = m_TC-&gt;getLocation().y + 
                m_TC-&gt;getSize().y;
            m_BulletSpawner-&gt;spawnBullet(spawnLocation, false);
            srand(m_RandSeed);
            int mTimeBetweenShots = (((rand() % 10))+1) / 
                WorldState::WAVE_NUMBER;
            m_TimeSinceLastShot = 0;            
        }
    }
}</pre>
			<p>The details of the <code>BulletSpawner</code> class will be revealed in the next chapter, but as a glimpse into the future, it will be an abstract class with one function called <code>spawnBullet</code> and will be inherited from by the <code>GameScreen</code> class.</p>
			<h3>Explaining the dropDownAndReverse function</h3>
			<p>In the <code>dropDownAndReverse</code> function, the direction is reversed and the vertical location is increased by the height of an invader. In addition, the speed of the invader is increased relative to how many waves the player has cleared and how many invaders remain to be destroyed. The more waves that are cleared and the fewer invaders remaining, the faster the invaders will move:</p>
			<pre>void InvaderUpdateComponent::dropDownAndReverse()
{
    m_MovingRight = !m_MovingRight;
    m_TC-&gt;getLocation().y += m_TC-&gt;getSize().y;
    m_Speed += (WorldState::WAVE_NUMBER) + 
        (WorldState::NUM_INVADERS_AT_START 
      - WorldState::NUM_INVADERS) 
        * m_SpeedModifier;
}</pre>
			<p>The next function is simple but included for the sake of completeness.</p>
			<h3>Explaining the isMovingRight function</h3>
			<p>This code simply provides access to the current direction of travel:</p>
			<pre>bool InvaderUpdateComponent::isMovingRight()
{
    return m_MovingRight;
}</pre>
			<p>It will be used to test whether to look out for collisions with the left of the screen (when moving left) or the right of the screen (when moving right) and will allow the collision to trigger a call to the <code>dropDownAndReverse</code> function.</p>
			<h3>Explaining the initializeBulletSpawner function</h3>
			<p>I have already mentioned that the <code>BulletSpawner</code> class is abstract and will be implemented by the <code>GameScreen</code> class. When the <code>GameScreen</code> class' <code>initialize</code> function is called, this <code>initializeBulletSpawner</code> function will be called on each of the invaders. As you can see, the first parameter is a pointer to a <code>BulletSpawner</code> instance. This gives every <code>InvaderUpdateComponent</code> the ability to call the <code>spawnBullet</code> function: </p>
			<pre>void InvaderUpdateComponent::initializeBulletSpawner(
    BulletSpawner* bulletSpawner, int randSeed)
{
    m_BulletSpawner = bulletSpawner;
    m_RandSeed = randSeed;
    srand(m_RandSeed);
    m_TimeBetweenShots = (rand() % 15 + m_RandSeed);
    m_AccuracyModifier = (rand() % 2);
    m_AccuracyModifier += 0 + static_cast &lt;float&gt; (
        rand()) / (static_cast &lt;float&gt; (RAND_MAX / (10)));
}</pre>
			<p>The rest of the code in the <code>initializeBulletSpawner</code> function sets up the random values that make each invader behave slightly differently from the others.</p>
			<h2 id="_idParaDest-414"><a id="_idTextAnchor428"/>Coding the PlayerUpdateComponent class</h2>
			<p>Create a new header file in the <code>Header Files/GameObjects</code> filter called <code>PlayerUpdateComponent.h</code> and add the following code:</p>
			<pre>#pragma once
#include "UpdateComponent.h"
#include "TransformComponent.h"
#include "GameObjectSharer.h"
#include "RectColliderComponent.h"
#include "GameObject.h"
class PlayerUpdateComponent : public UpdateComponent
{
private:
    string m_SpecificType = "player";
    shared_ptr&lt;TransformComponent&gt; m_TC;
    shared_ptr&lt;RectColliderComponent&gt; m_RCC;
    float m_Speed = 50.0f;
    float m_XExtent = 0;
    float m_YExtent = 0;
    bool m_IsHoldingLeft = false;
    bool m_IsHoldingRight = false;
    bool m_IsHoldingUp = false;
    bool m_IsHoldingDown = false;
public:
    void updateShipTravelWithController(float x, float y);
    void moveLeft();
    void moveRight();
    void moveUp();
    void moveDown();
    void stopLeft();
    void stopRight();
    void stopUp();
    void stopDown();
    /****************************************************
    *****************************************************
    From Component interface base class
    *****************************************************
    *****************************************************/
    string Component::getSpecificType() {
        return m_SpecificType;
    }
    void Component::start(GameObjectSharer* gos, GameObject* self) {        
        m_TC = static_pointer_cast&lt;TransformComponent&gt;(self-&gt;
            getComponentByTypeAndSpecificType(
                "transform", "transform"));
        m_RCC = static_pointer_cast&lt;RectColliderComponent&gt;(self-&gt;
            getComponentByTypeAndSpecificType(
                "collider", "rect"));        
    }
    /****************************************************
    *****************************************************
    From UpdateComponent
    *****************************************************
    *****************************************************/
    void update(float fps) override;
};</pre>
			<p>In the <code>PlayerUpdateComponent</code> class, we have all the Boolean variables needed to keep track of whether the player is holding down a keyboard key, as well as functions that can toggle these Boolean values. We haven't seen anything like the <code>m_XExtent</code> and <code>M_YExtent float</code> type variables before and we will explain them when we look at their usage in the function definitions.</p>
			<p>Note, just like the <code>BulletUpdateComponent</code> and the <code>InvaderUpdateComponent</code> classes, that we have shared pointers to this game object's transform and collider components. These shared pointers, as we are coming to expect, are initialized in the <code>start</code> function.</p>
			<p>Create a new source file in the <code>Source Files/GameObjects</code> filter called <code>PlayerUpdate.cpp</code> and add the following code:</p>
			<pre>#include "PlayerUpdateComponent.h"
#include "WorldState.h"
void PlayerUpdateComponent::update(float fps)
{
    if (sf::Joystick::isConnected(0))
    {
        m_TC-&gt;getLocation().x += ((m_Speed / 100) 
            * m_XExtent) * fps;
        m_TC-&gt;getLocation().y += ((m_Speed / 100) 
            * m_YExtent) * fps;        
    }
    // Left and right
    if (m_IsHoldingLeft)
    {
        m_TC-&gt;getLocation().x -= m_Speed * fps;
    }
    else if (m_IsHoldingRight)
    {
        m_TC-&gt;getLocation().x += m_Speed * fps;
    }
    // Up and down
    if (m_IsHoldingUp)
    {
        m_TC-&gt;getLocation().y -= m_Speed * fps;
    }
    else if (m_IsHoldingDown)
    {
        m_TC-&gt;getLocation().y += m_Speed * fps;
    }
    
    // Update the collider
    m_RCC-&gt;setOrMoveCollider(m_TC-&gt;getLocation().x, 
        m_TC-&gt;getLocation().y, m_TC-&gt;getSize().x, 
        m_TC-&gt;getSize().y);
    
    // Make sure the ship doesn't go outside the allowed area
    if (m_TC-&gt;getLocation().x &gt;
        WorldState::WORLD_WIDTH - m_TC-&gt;getSize().x) 
    {
        m_TC-&gt;getLocation().x = 
            WorldState::WORLD_WIDTH - m_TC-&gt;getSize().x;
    }
    else if (m_TC-&gt;getLocation().x &lt; 0)
    {
        m_TC-&gt;getLocation().x = 0;
    }
    if (m_TC-&gt;getLocation().y &gt; 
        WorldState::WORLD_HEIGHT - m_TC-&gt;getSize().y)
    {
        m_TC-&gt;getLocation().y = 
            WorldState::WORLD_HEIGHT - m_TC-&gt;getSize().y;
    }
    else if (m_TC-&gt;getLocation().y &lt; 
        WorldState::WORLD_HEIGHT / 2)
    {
        m_TC-&gt;getLocation().y = 
            WorldState::WORLD_HEIGHT / 2;
    }
}    
void PlayerUpdateComponent::
    updateShipTravelWithController(float x, float y)
{
    m_XExtent = x;
    m_YExtent = y;
}
void PlayerUpdateComponent::moveLeft()
{
    m_IsHoldingLeft = true;
    stopRight();
}
void PlayerUpdateComponent::moveRight()
{
    m_IsHoldingRight = true;
    stopLeft();
}
void PlayerUpdateComponent::moveUp()
{
    m_IsHoldingUp = true;
    stopDown();
}
void PlayerUpdateComponent::moveDown()
{
    m_IsHoldingDown = true;
    stopUp();
}
void PlayerUpdateComponent::stopLeft()
{
    m_IsHoldingLeft = false;
}
void PlayerUpdateComponent::stopRight()
{
    m_IsHoldingRight = false;
}
void PlayerUpdateComponent::stopUp()
{
    m_IsHoldingUp = false;
}
void PlayerUpdateComponent::stopDown()
{
    m_IsHoldingDown = false;
}</pre>
			<p>In the first <code>if</code> block of the update function, the condition is <code>sf::Joystick::isConnected(0)</code>. This condition returns true when the player has a gamepad plugged in to a USB port. Inside the <code>if</code> block, the location of both the horizontal and vertical positions of the transform component are altered:</p>
			<pre>…((m_Speed / 100) * m_YExtent) * fps;</pre>
			<p>The preceding code divides the target speed by 100 before multiplying it by <code>m_YExtent</code>. <code>The m_XExtent</code> and <code>m_YExtent</code> variables will be updated each frame to hold values that represent the extent to which the player has moved their gamepad thumbstick in a horizontal and vertical direction. The range of values is from -100 to 100, and so the preceding code has the effect of moving the transform component at full speed in any direction when the thumbstick is positioned at any of its full extents or a fraction of that speed when it is partially positioned between the center (not moving at all) and its full extent. This means that the player will have finer control over the speed of the ship should they opt to use a gamepad instead of the keyboard.</p>
			<p>We will see more details about the operation of the gamepad in <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>, <em class="italic">Using Game Objects and Building a Game</em>.</p>
			<p>The rest of the <code>update</code> function responds to the Boolean variables, which represent the keyboard keys that the player is holding down or has released.</p>
			<p>After the gamepad and keyboard handling, the collider component is moved into the new position and a series of <code>if</code> blocks ensures the player ship can't move outside of the screen or above the half-way-up point on the screen.</p>
			<p>The next function is the <code>updateShipTravelWithController</code> function; when a controller is plugged in, it will update the extent to which the thumbstick is moved or at rest for each frame.</p>
			<p>The remaining functions update the Boolean values that indicate whether keyboard keys are being used to move the ship. Notice that the update component does not handle firing a bullet. We could have handled it from here, and some games might have a good reason to do so. In this game, it was slightly more direct to handle shooting a bullet from the <code>GameInputHandler</code> class. The <code>GameInputHandler</code> class, as we will see in <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>, <em class="italic">Using Game Objects and Building a Game</em>, will call all the functions that let the <code>PlayerUpdateComponent</code> class know what is happening with the gamepad and keyboard. We coded the basics of keyboard responses in the <code>GameInputHandler</code> class in the previous chapter.</p>
			<p>Now, let's code the <code>GameObject</code> class, which will hold all the various component instances.</p>
			<h1 id="_idParaDest-415"><a id="_idTextAnchor429"/>Coding the GameObject class</h1>
			<p>I am going to go through the code in this class in quite a lot of detail because it is key to how all the other classes work. I think you will benefit, however, from seeing the code in its entirety and studying it first. With this in mind, create a new header file in the <code>Header Files/GameObjects</code> filter called <code>GameObject.h</code> and add the following code:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include "Component.h"
#include "GraphicsComponent.h"
#include "GameObjectSharer.h"
#include "UpdateComponent.h"
class GameObject {
private:
    vector&lt;shared_ptr&lt;Component&gt;&gt; m_Components;
    string m_Tag;
    bool m_Active = false;
    int m_NumberUpdateComponents = 0;
    bool m_HasUpdateComponent = false;
    int m_FirstUpdateComponentLocation = -1;
    int m_GraphicsComponentLocation = -1;
    bool m_HasGraphicsComponent = false;
    int m_TransformComponentLocation = -1;
    int m_NumberRectColliderComponents = 0;
    int m_FirstRectColliderComponentLocation = -1;
    bool m_HasCollider = false;
public:
    void update(float fps);
    void draw(RenderWindow&amp; window);
    void addComponent(shared_ptr&lt;Component&gt; component);
    void setActive();
    void setInactive();
    bool isActive();
    void setTag(String tag);
    string getTag();
    void start(GameObjectSharer* gos);
    // Slow only use in init and start
    shared_ptr&lt;Component&gt; getComponentByTypeAndSpecificType(
        string type, string specificType);
    FloatRect&amp; getEncompassingRectCollider();
    bool hasCollider();
    bool hasUpdateComponent();
    string getEncompassingRectColliderTag();
    shared_ptr&lt;GraphicsComponent&gt; getGraphicsComponent();
    shared_ptr&lt;TransformComponent&gt; getTransformComponent();
    shared_ptr&lt;UpdateComponent&gt; getFirstUpdateComponent();
};</pre>
			<p>In the preceding code, be sure to closely examine the variables, types, function names, and their parameters.</p>
			<p>Create a new source file in the <code>Source Files/GameObjects</code> filter called <code>GameObject.cpp</code> and then study and add the following code:</p>
			<pre>#include "DevelopState.h"
#include "GameObject.h"
#include &lt;iostream&gt; 
#include "UpdateComponent.h"
#include "RectColliderComponent.h"
void GameObject::update(float fps)
{
    if (m_Active &amp;&amp; m_HasUpdateComponent)
    {
        for (int i = m_FirstUpdateComponentLocation; i &lt; 
            m_FirstUpdateComponentLocation + 
            m_NumberUpdateComponents; i++) 
        {
            shared_ptr&lt;UpdateComponent&gt; tempUpdate =
                static_pointer_cast&lt;UpdateComponent&gt;(
             m_Components[i]);
            if (tempUpdate-&gt;enabled()) 
            {
                tempUpdate-&gt;update(fps);
            }
        }
    }
}
void GameObject::draw(RenderWindow&amp; window)
{
    if (m_Active &amp;&amp; m_HasGraphicsComponent)
    {
        if (m_Components[m_GraphicsComponentLocation]-&gt;enabled())
        {
            getGraphicsComponent()-&gt;draw(window, 
                getTransformComponent());
        }
    }
}
shared_ptr&lt;GraphicsComponent&gt; GameObject::getGraphicsComponent() 
{
    return static_pointer_cast&lt;GraphicsComponent&gt;(
        m_Components[m_GraphicsComponentLocation]);
}
shared_ptr&lt;TransformComponent&gt; GameObject::getTransformComponent() 
{
    return static_pointer_cast&lt;TransformComponent&gt;(
        m_Components[m_TransformComponentLocation]);
}
void GameObject::addComponent(shared_ptr&lt;Component&gt; component)
{
    m_Components.push_back(component);
    component-&gt;enableComponent();
    
   if (component-&gt;getType() == "update") 
    {
        m_HasUpdateComponent = true;
        m_NumberUpdateComponents++;
        if (m_NumberUpdateComponents == 1) 
        {
            m_FirstUpdateComponentLocation = 
                m_Components.size() - 1;
        }
    }
    else if (component-&gt;getType() == "graphics") 
    {
        // No iteration in the draw method required
        m_HasGraphicsComponent = true;
        m_GraphicsComponentLocation = m_Components.size() - 1;
    }
    else if (component-&gt;getType() == "transform") 
    {
        // Remember where the Transform component is
        m_TransformComponentLocation = m_Components.size() - 1;
    }
    else if (component-&gt;getType() == "collider" &amp;&amp; 
        component-&gt;getSpecificType() == "rect") 
    {
        // Remember where the collider component(s) is
        m_HasCollider = true;
        m_NumberRectColliderComponents++;
        if (m_NumberRectColliderComponents == 1) 
        {
            m_FirstRectColliderComponentLocation = 
                m_Components.size() - 1;
        }
    }    
}
void GameObject::setActive()
{
    m_Active = true;
}
void GameObject::setInactive()
{
    m_Active = false;
}
bool GameObject::isActive()
{
    return m_Active;
}
void GameObject::setTag(String tag)
{
    m_Tag = "" + tag;
}
std::string GameObject::getTag()
{
    return m_Tag;
}
void GameObject::start(GameObjectSharer* gos) 
{
    auto it = m_Components.begin();
    auto end = m_Components.end();
    for (it;
        it != end;
        ++it)
    {
        (*it)-&gt;start(gos, this);
    }
}
// Slow - only use in start function
shared_ptr&lt;Component&gt; GameObject::
   getComponentByTypeAndSpecificType(
    string type, string specificType) {
    auto it = m_Components.begin();
    auto end = m_Components.end();
    for (it;
        it != end;
        ++it)
    {
        if ((*it)-&gt;getType() == type)
        {
            if ((*it)-&gt;getSpecificType() == specificType)
            {
                return  (*it);
            }
        }
    }
    #ifdef debuggingErrors        
        cout &lt;&lt; 
            "GameObject.cpp::getComponentByTypeAndSpecificType-" 
            &lt;&lt; "COMPONENT NOT FOUND ERROR!" 
            &lt;&lt; endl;
    #endif
        return m_Components[0];
}
FloatRect&amp; GameObject::getEncompassingRectCollider() 
{
    if (m_HasCollider) 
    {
        return (static_pointer_cast&lt;RectColliderComponent&gt;(
            m_Components[m_FirstRectColliderComponentLocation]))
            -&gt;getColliderRectF();
    }
}
string GameObject::getEncompassingRectColliderTag() 
{
    return static_pointer_cast&lt;RectColliderComponent&gt;(
        m_Components[m_FirstRectColliderComponentLocation])-&gt;
        getColliderTag();
}
shared_ptr&lt;UpdateComponent&gt; GameObject::getFirstUpdateComponent()
{
    return static_pointer_cast&lt;UpdateComponent&gt;(
        m_Components[m_FirstUpdateComponentLocation]);
}
bool GameObject::hasCollider() 
{
    return m_HasCollider;
}
bool GameObject::hasUpdateComponent()
{
    return m_HasUpdateComponent;
}</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">Be sure to study the preceding code before moving on. The explanations that follow assume that you have a basic awareness of variable names and types, as well as function names, parameters, and return types.</p>
			<h2 id="_idParaDest-416"><a id="_idTextAnchor430"/>Explaining the GameObject class</h2>
			<p>Let's go through the <code>GameObject</code> class one function at a time and reprint the code to make it easy to discuss.</p>
			<h3>Explaining the update function</h3>
			<p>The <code>update</code> function is called once for each frame of the game loop for each game object. Like most of our other projects, the current frame rate is required. Inside the <code>update</code> function, a test is done to see if this <code>GameObject</code> instance is active and has an update component. A game object does not have to have an update component, although it is true that all the game objects in this project do.</p>
			<p>Next, the <code>update</code> function loops through all the components it has, starting from <code>m_FirstUpdateComponent</code> through to <code>m_FirstUpdateComponent + m_NumberUpdateComponents</code>. This code implies that a game object can have multiple update components. This is so that you can design game objects with layers of behavior. This layering of behavior is discussed further in <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>, <em class="italic">Using Game Objects and Building a Game</em>. All the game objects in this project have just one update component, so you could simplify (and speed up) the logic in the <code>update</code> function, but I suggest leaving it as it is until you have read <a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>, <em class="italic">Using Game Objects and Building a Game</em>. </p>
			<p>It is because a component could be one of many types that we create a temporary update-related component (<code>tempUpdate</code>), cast the component from the vector of components to <code>UpdateComponent</code>, and call the <code>update</code> function. It doesn't matter about the specific derivation of the <code>UpdateComponent</code> class; it will have the <code>update</code> function implemented, so the <code>UpdateComponent</code> type is specific enough:</p>
			<pre>void GameObject::update(float fps)
{
    if (m_Active &amp;&amp; m_HasUpdateComponent)
    {
        for (int i = m_FirstUpdateComponentLocation; i &lt; 
            m_FirstUpdateComponentLocation + 
            m_NumberUpdateComponents; i++) 
        {
            shared_ptr&lt;UpdateComponent&gt; tempUpdate =
                static_pointer_cast&lt;UpdateComponent&gt;(
             m_Components[i]);
            if (tempUpdate-&gt;enabled()) 
            {
                tempUpdate-&gt;update(fps);
            }
        }
    }
}</pre>
			<p>When we get to the <code>addComponent</code> function in a later section, we will see how we can initialize the various control variables, such as <code>m_FirstUpdateComponentLocation</code> and <code>m_NumberOfUpdateComponents</code>.</p>
			<h3>Explaining the draw function</h3>
			<p>The <code>draw</code> function checks whether the game object is active and that it has a graphics component. If it does, then a check is done to see if the graphics component is enabled. If all these tests succeed, then the <code>draw</code> function is called:</p>
			<pre>void GameObject::draw(RenderWindow&amp; window)
{
    if (m_Active &amp;&amp; m_HasGraphicsComponent)
    {
        if (m_Components[m_GraphicsComponentLocation]-&gt;enabled())
        {
            getGraphicsComponent()-&gt;draw(window, 
                getTransformComponent());
        }
    }
}</pre>
			<p>The structure of the <code>draw</code> function implies that not every game object has to draw itself. I mentioned in <a href="B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372"><em class="italic">Chapter 19</em></a>, <em class="italic">Game Programming Design Patterns – Starting the Space Invaders ++ Game</em>, that you might want game objects that can never be seen to act as invisible trigger regions (with no graphics component) that respond when the player passes over them or game objects that remain invisible temporarily (temporarily disabled but with a graphics component). In this project, all game objects have a permanently enabled graphics component.</p>
			<h3>Explaining the getGraphicsComponent function</h3>
			<p>This function returns a shared pointer to the graphics component:</p>
			<pre>shared_ptr&lt;GraphicsComponent&gt; GameObject::getGraphicsComponent() 
{
    return static_pointer_cast&lt;GraphicsComponent&gt;(
        m_Components[m_GraphicsComponentLocation]);
}</pre>
			<p>The <code>getGraphicsComponent</code> function gives any code that has an instance of the contained game object access to the graphics component.</p>
			<h3>Explaining the getTransformComponent function</h3>
			<p>This function returns a shared pointer to the transform component:</p>
			<pre>shared_ptr&lt;TransformComponent&gt; GameObject::getTransformComponent() 
{
    return static_pointer_cast&lt;TransformComponent&gt;(
        m_Components[m_TransformComponentLocation]);
}</pre>
			<p>The <code>getTransformComponent</code> function gives any code that has an instance of the contained game object access to the transform component.</p>
			<h3>Explaining the addComponent function</h3>
			<p>The <code>addComponent</code> function will be used by a factory pattern class we will code in the next chapter. The function receives a shared pointer to a <code>Component</code> instance. The first thing that happens inside the function is that the <code>Component</code> instance is added to the <code>m_Components</code> vector. Next, the component is enabled using the <code>enabled</code> function.</p>
			<p>What follows is a series of <code>if</code> and <code>else if</code> statements that deal with each possible type of component. When the type of a component is identified, the various control variables are initialized to enable the logic in the rest of the class to work correctly.</p>
			<p>For example, if an update component is detected, then the <code>m_HasUpdateComponent</code>, <code>m_NumberUpdateComponents</code>, and <code>m_FirstUpdateComponentLocation</code> variables are initialized. </p>
			<p>As another example, if a collider component is detected along with the <code>rect</code> specific type, then the <code>m_HasCollider</code>, <code>m_NumberRectColliderComponents</code>, and <code>m_FirstRectColliderComponent</code> variables are initialized:</p>
			<pre>void GameObject::addComponent(shared_ptr&lt;Component&gt; component)
{
    m_Components.push_back(component);
    component-&gt;enableComponent();
    
   if (component-&gt;getType() == "update") 
    {
        m_HasUpdateComponent = true;
        m_NumberUpdateComponents++;
        if (m_NumberUpdateComponents == 1) 
        {
            m_FirstUpdateComponentLocation = 
                m_Components.size() - 1;
        }
    }
    else if (component-&gt;getType() == "graphics") 
    {
        // No iteration in the draw method required
        m_HasGraphicsComponent = true;
        m_GraphicsComponentLocation = m_Components.size() - 1;
    }
    else if (component-&gt;getType() == "transform") 
    {
        // Remember where the Transform component is
        m_TransformComponentLocation = m_Components.size() - 1;
    }
    else if (component-&gt;getType() == "collider" &amp;&amp; 
        component-&gt;getSpecificType() == "rect") 
    {
        // Remember where the collider component(s) is
        m_HasCollider = true;
        m_NumberRectColliderComponents++;
        if (m_NumberRectColliderComponents == 1) 
        {
            m_FirstRectColliderComponentLocation = 
                m_Components.size() - 1;
        }
    }    
}</pre>
			<p>Note that the <code>GameObject</code> class plays no part in configuring or setting up the actual components themselves. It is all handled in the factory pattern class we will code in the next chapter.</p>
			<h3>Explaining the getter and setter functions</h3>
			<p>The following code is a series of very simple getters and setters:</p>
			<pre>void GameObject::setActive()
{
    m_Active = true;
}
void GameObject::setInactive()
{
    m_Active = false;
}
bool GameObject::isActive()
{
    return m_Active;
}
void GameObject::setTag(String tag)
{
    m_Tag = "" + tag;
}
std::string GameObject::getTag()
{
    return m_Tag;
}</pre>
			<p>The preceding getters and setters provide information about a game object, such as whether it is active and what its tag is. They also allow you to set the tag and tell us whether or not the game object is active.</p>
			<h3>Explaining the start function</h3>
			<p>The <code>start</code> function is an important one. As we saw when we coded all the components, the <code>start</code> function gives access to any component in any game object the components of any other game object. The <code>start</code> function is called once all the <code>GameObject</code> instances have been composed from all their components. In the next chapter, we will see how this happens, as well as when the <code>start</code> function is called on every <code>GameObject</code> instance. As we can see, in the <code>start</code> function, it loops through every component and shares a new class instance, a <code>GameObjectSharer</code> instance. This <code>GameObjectSharer</code> class will be coded in the next chapter and will give access to any component from any class. We saw how the invaders need to know where the player is and how the <code>GameObjectSharer</code> parameter is used when we coded the various components. When <code>start</code> is called on each component, the <code>this</code> pointer is also passed in to give each component easy access to its contained <code>GameObject</code> instance:</p>
			<pre>void GameObject::start(GameObjectSharer* gos) 
{
    auto it = m_Components.begin();
    auto end = m_Components.end();
    for (it;
        it != end;
        ++it)
    {
        (*it)-&gt;start(gos, this);
    }
}</pre>
			<p>Let's move on to the <code>getComponentByTypeAndSpecificType</code> function.</p>
			<h3>Explaining the getComponentByTypeAndSpecificType function</h3>
			<p>The <code>getComponentByTypeAndSpecificType</code> function has a nested <code>for</code> loop that looks for a match of a component type to the first <code>string</code> parameter and then looks for a match of the specific component type in the second <code>string</code> parameter. It returns a shared pointer to a base class <code>Component</code> instance. This implies that the calling code needs to know exactly what derived <code>Component</code> type is being returned so that it can cast it to the required type. This shouldn't be a problem because, of course, they are requesting both a type and a specific type:</p>
			<pre>// Slow only use in start
shared_ptr&lt;Component&gt; GameObject::getComponentByTypeAndSpecificType(
    string type, string specificType) {
    auto it = m_Components.begin();
    auto end = m_Components.end();
    for (it;
        it != end;
        ++it)
    {
        if ((*it)-&gt;getType() == type)
        {
            if ((*it)-&gt;getSpecificType() == specificType)
            {
                return  (*it);
            }
        }
    }
    #ifdef debuggingErrors        
        cout &lt;&lt; 
            "GameObject.cpp::getComponentByTypeAndSpecificType-" 
            &lt;&lt; "COMPONENT NOT FOUND ERROR!" 
            &lt;&lt; endl;
    #endif
        return m_Components[0];
}</pre>
			<p>The code in this function is quite slow and is therefore intended for use outside of the main game loop. At the end of this function, the code writes an error message to the console if <code>debuggingErrors</code> has been defined. The reason for this is because, if execution reaches this point, it means that no matching component was found, and the game will crash. The output to the console should make the error easy to find. The cause of the crash would be that the function was called for an invalid type or specific type.</p>
			<h3>Explaining the getEncompassingRectCollider function</h3>
			<p>The <code>getEncompassingRectCollider</code> function checks whether the game object has a collider and, if it has, returns it to the calling code:</p>
			<pre>FloatRect&amp; GameObject::getEncompassingRectCollider() 
{
    if (m_HasCollider) 
    {
        return (static_pointer_cast&lt;RectColliderComponent&gt;(
            m_Components[m_FirstRectColliderComponentLocation]))
            -&gt;getColliderRectF();
    }
}</pre>
			<p>It is worth noting that, if you extend this project to handle more than one type of collider, then this code would need adapting too.</p>
			<h3>Explaining the getEncompassingRectColliderTag function</h3>
			<p>This simple function returns the tag of the collider. This will be useful for determining what type of object is being tested for collision:</p>
			<pre>string GameObject::getEncompassingRectColliderTag() 
{
    return static_pointer_cast&lt;RectColliderComponent&gt;(
        m_Components[m_FirstRectColliderComponentLocation])-&gt;
        getColliderTag();
}</pre>
			<p>We have just a few more functions to discuss.</p>
			<h3>Explaining the getFirstUpdateComponent function</h3>
			<p><code>getFirstUpdateComponent</code> uses the <code>m_FirstUpdateComponent</code> variable to locate the update component and then returns it to the calling code:</p>
			<pre>shared_ptr&lt;UpdateComponent&gt; GameObject::getFirstUpdateComponent()
{
    return static_pointer_cast&lt;UpdateComponent&gt;(
        m_Components[m_FirstUpdateComponentLocation]);
}</pre>
			<p>Now we're just going to go over a couple of getters, and then we are done.</p>
			<h3>Explaining the final getter functions</h3>
			<p>These two remaining functions return a Boolean (each) to tell the calling code whether the game object has a collider and/or an update component:</p>
			<pre>bool GameObject::hasCollider() 
{
    return m_HasCollider;
}
bool GameObject::hasUpdateComponent()
{
    return m_HasUpdateComponent;
}</pre>
			<p>We have coded the <code>GameObject</code> class in full. We can now look at putting it (and all the components it will be composed of) to work.</p>
			<h1 id="_idParaDest-417"><a id="_idTextAnchor431"/>Summary</h1>
			<p>In this chapter, we have completed all the code that will draw our game objects to the screen, control their behavior, and let them interact with other classes through collisions. The most important thing to take away from this chapter is not how any of the specific component-based classes work but how flexible the Entity-Component system is. If you want a game object that behaves in a certain way, create a new update component. If it needs to know about other objects in the game, get a pointer to the appropriate component in the <code>start</code> function. If it needs to be drawn in a fancy manner, perhaps with a shader or an animation, code a graphics component that performs the actions in the <code>draw</code> function. If you need multiple colliders, like we did for Thomas and Bob in the Thomas Was Late project, this is no problem: code a new collider-based component.</p>
			<p>In the next chapter, we will code the file input and output system, as well as the class that will be the factory that builds all the game objects and composes them with components.</p>
		</div>
	</body></html>