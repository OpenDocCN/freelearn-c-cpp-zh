["```cpp\nclass BaseArrow:\n   func describe_damage():\n      print(\"Pierces a person\")\nclass FireArrow extends BaseArrow:\n   func describe_damage():\n      super()\n      print(\"And sets them ablaze\")\n```", "```cpp\nvar fire_arrow: FireArrow = FireArrow.new()\nfire_arrow.describe_damage()\n```", "```cpp\nPierces a person\nAnd sets them ablaze\n```", "```cpp\nclass Enemy:\n   static var damage: float = 10.0\n   static func do_battle_cry():\n      print(\"Aaaaaargh!\")\n```", "```cpp\nprint(Enemy.damage)\nEnemy.do_battle_cry ()\n```", "```cpp\nenum DAMAGE_TYPES {\n   NONE,\n   FIRE,\n   ICE\n}\n```", "```cpp\nDAMAGE_TYPES.FIRE\n```", "```cpp\nprint(DAMAGE_TYPES.NONE)\nprint(DAMAGE_TYPES.FIRE)\nprint(DAMAGE_TYPES.ICE)\n```", "```cpp\n0\n1\n2\n```", "```cpp\nvar damage_type: DAMAGE_TYPES = DAMAGE_TYPES.FIRE\nmatch damage_type:\n   DAMAGE_TYPES.NONE:\n      print(\"Nothing special happens\")\n   DAMAGE_TYPES.FIRE:\n      print(\"You catch fire! \")\n   DAMAGE_TYPES.ICE:\n      print(\"You freeze!\")\n```", "```cpp\nclass Arrow:\n   Enum DAMAGE_TYPES {\n      NONE,\n      FIRE\n   }\nfunc _ready():\n   var damage_type: DAMAGE_TYPES enum from within the Arrow class. Later, we can access this enum by using Arrow.DAMAGE_TYPES directly.\n\t\t\tIn this section, we looked at enums, named values that help us by providing human-readable labels. Next, we’ll take a look at lambda functions.\n\t\t\tLambda functions\n\t\t\tSo far, every function we have written belonged to a class or file, which could be treated as a class, but there is actually a way to define functions separately from any class definition. These kinds of functions are called **lambda functions**.\n\t\t\tCreating a lambda function\n\t\t\tLet’s take a look at a lambda function:\n\n```", "```cpp\n\n\t\t\tYou can see that we’ve defined a function, just as we normally do, but this time without a function name. Instead, we assigned the function to a variable. This variable now contains the function in the form of the `Callable` object type. We can call a `Callable` object later on, like this:\n\n```", "```cpp\n\n\t\t\tThis will run the function that we defined and, thus, print out `Hello` to the console.\n\t\t\tLambda functions, just like normal functions, can take arguments too:\n\n```", "```cpp\n\n\t\t\tIn this example, you can also see that lambda functions can contain multiple lines of code in the form of a code block, where each line has the same level of indentation.\n\t\t\tWhere to use lambda functions\n\t\t\tSo, where would we use lambda functions? Well, they are very useful in scenarios where you need a relatively small function but don’t want to have it as a permanent residence in the class.\n\t\t\tOne great application of lambda functions is connecting signals. If we have a button for example, then we can connect to its pressed signal using a lambda function, as follows:\n\n```", "```cpp\n[0, 1, 2, 3, 4].filter(func(number: int): return number % 2 == 0)\n[0, 3, 2, 4, 1].sort_custome(func(number_a: int, number_b: int): return number_a < number_b)\n```", "```cpp\n[0, 2, 4]\n[0, 1, 2, 3, 4]\n```", "```cpp\nfunc _ready():\n   var number: int = 5\n   print(\"Number before the function: \", number)\n   function_taking_integers(number)\n   print(\"Number after the function: \", number)\n   var string: String = \"Hello there!\"\n   print(\"String before the function: \", string)\n   function_taking_strings(string)\n   print(\"String after the function: \", string)\nfunc function_taking_integers(number: int):\n   number += 10\n   print(\"Number during the function: \", number)\nfunc function_taking_strings(string: String):\n   string[0] = \"W\"\n   print(\"String during the function: \", string)\n```", "```cpp\nNumber before the function: 5\nNumber during the function: 15\nNumber after the function: 5\nString before the function: Hello there!\nString during the function: Wello there!\nString after the function: Hello there!\n```", "```cpp\nfunc _ready():\n   var dictionary: Dictionary = { \"value\": 5 }\n   print(\"Dictionary before the function: \", dictionary)\n   function_taking_dictionary(dictionary)\n   print(\"Dictionary after the function: \", dictionary)\nfunc function_taking_dictionary(dictionary: Dictionary):\n   dictionary[\"a_value\"] = \"has changed\"\n   print(\"Dictionary during the function: \", dictionary)\n```", "```cpp\nDictionary before the function: { \"value\": 5 }\nDictionary during the function: { \"value\": 5, \"a_value\": \"has changed\" }\nDictionary after the function: { \"value\": 5, \"a_value\": \"has changed\" }\n```", "```cpp\n@tool\nclass_name Player extends CharacterBody2D\nconst MAX_HEALTH: int = 10\n@onready var _health_label: Label = $Health\n@export var health: int = 10:\n   set(new_value):\n      health = new_value\n      update_health_label()\nfunc _ready():\n   update_health_label()\nfunc update_health_label():\n   if not is_instance_valid(_health_label):\n      return\n   _health_label.text = str(health) + \"/\" + str(MAX_HEALTH)\n```", "```cpp\nif Engine.is_editor_hint():\n   # Code to execute in editor.\nif not Engine.is_editor_hint():\n   # Code to execute in game.\n```", "```cpp\n    enum COLLECTIBLE_TYPE {\n       HEALTH,\n       UPGRADE,\n       DAMAGE,\n    }\n    print(COLLECTIBLE_TYPES.DAMAGE)\n    ```", "```cpp\n\n```"]