<html><head></head><body>
        

                            
                    <h1 class="header-title">Assessments</h1>
                
            
            
                


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 1</h1>
                
            
            
                
<ol>
<li>No. A system with real-time requirements simply means that actions need to be deterministic. The timing requirements are determined by the needs of each system.</li>
<li>No. There are several different ways to achieve real-time performance.</li>
<li>No.</li>
<li>Any system that has a deterministic response to a given event can be considered as <em>real-time</em>.</li>
<li>Most industrial controls, closed-loop control systems, UAV flight controllers, <strong>Anti-Lock Braking Systems</strong> (<strong>ABS</strong>), <strong>Engine Control Units</strong> (<strong>ECUs</strong>), inkjet printers, test equipment (such as oscilloscopes and network analyzers), and so on.</li>
<li>An MCU-based RTOS's strong point is moderately complex systems.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 2</h1>
                
            
            
                
<ol>
<li>Both of the above options.</li>
<li>False.</li>
<li>Complex super loops tend to have a large amount of variability in how long it takes them to execute the loop. This can lead to poor determinism in the system, since there is no easy way to provide a means for higher-priority work to take precedence over everything else happening in the loop.</li>
<li>Interrupts and DMA can both be used to improve the response of super loops to external events. They allow hardware peripherals to be serviced without waiting to be polled during a super-loop cycle.</li>
<li>There is only one super loop being run in the system. It shares the system stack. Tasks, however, each receive their own dedicated stack. Each task receives a priority, unlike a superloop, which has no inherent concept of prioritization.</li>
<li>Prioritization.</li>
<li>A preemptive scheduler attempts to ensure that the task with the highest priority is always the one executing.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 3</h1>
                
            
            
                
<ol>
<li>Queues.</li>
<li>Yes.</li>
<li>Semaphore.</li>
<li>Networking stacks or anything where a maximum number of simultaneous users must be enforced.</li>
<li>Priority inheritance.</li>
<li>Mutex.</li>
<li>Priority inversion allows lower-priority tasks to take precedence over a higher-priority task. This is dangerous because it increases the chances of a high-priority task missing a deadline.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 4</h1>
                
            
            
                
<ol>
<li>Firmware programming, especially for MCUs, is extremely low-level, meaning it is very close to the hardware. There are often hardware-specific features that firmware engineers must be familiar with to get the best performance out of an MCU. </li>
<li>False.</li>
<li>Hardware peripherals.</li>
<li>Rapid prototyping, pre-existing hardware, community, consistent high-level APIs across different MCUs.</li>
<li>Evaluation boards often showcase a product's main differentiating qualities. They are also designed to be as complete as possible, providing easy access to all aspects of a device.</li>
<li>Sleep current, wake-up time, power efficiency (uA/MHz), the functionality of low-power modes, and power supply voltage.</li>
<li>To make it accessible for the widest number of readers – so make sure to get one and work through the exercises on some real hardware!</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 5</h1>
                
            
            
                
<ol>
<li>False. The ideal IDE will reflect personal/organizational preferences. A particular IDE that fits well into one team or workflow may not be suitable somewhere else.</li>
</ol>
<ol start="2">
<li>False. Many of the freely available IDEs are well suited for professional embedded system development.</li>
<li>False. Vendor-supplied IDEs will often vary widely in their quality. Be careful of getting too tightly bound to a vendor's IDE, especially if you prefer to use MCUs from other vendors.</li>
<li>False. At a minimum, we would expect software-generated code to be syntactically correct the first time. Beyond this, the code generation is only as good as the frontend supplying it, which tends to evolve more slowly than the underlying code bases (so you'll still need to write in customizations later on).</li>
<li>False. The IDE for this book was selected based on cost and only considered compatibility with STM32 devices.</li>
<li>Device selection, hardware bring-up, and middleware integration. <em>Why</em> it is useful in each of these areas is covered in the <em>Considering STMCube</em> section.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 6</h1>
                
            
            
                
<ol>
<li>False. In this chapter, the ST-Link on the Nucleo development board was re-flashed to provide the same functionality as a J-Link.</li>
<li>False. There are many ways to verify the timing requirements of a real-time system. Segger SystemView provides a means to measure response time, as does looking at system inputs and outputs via a traditional logic analyzer.</li>
<li>False. An RTOS-aware debugger provides the ability to view all of the stacks in the system. This is also an option with any Open GDB-based debugging using Eclipse, as mentioned in the previous chapter.</li>
<li>False. Each module that you write should be tested as thoroughly as possible to minimize any surprises and complex interactions when it is time to integrate the modules and perform a system-level test.</li>
<li>Unit testing. In unit testing, each individual module is tested as it is developed. Integration testing is testing to ensure multiple modules work as expected after they have been "integrated" with one another. System testing tests the complete system (typically after everything has been integrated). Black-box testing is simply a style of testing that assumes nothing about the system inside the "black box," and only compares outputs against the expected behavior given a set of inputs.</li>
<li><strong>Test-Driven Development</strong> (<strong>TDD</strong>).</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 7</h1>
                
            
            
                
<ol>
<li>There are two options – <kbd>xTaskCreate()</kbd> and <kbd>xTaskCreateStatic()</kbd>.</li>
<li>True. <kbd>xTaskCreate()</kbd> may fail if the required memory is not available.</li>
<li>True. <kbd>vTaskStartScheduler()</kbd> may fail if the required memory for the IDLE task is not available.</li>
<li>False. The required RAM for each task is 64 bytes plus the task stack size. The exact stack size requirements are completely dependent on your code, not FreeRTOS.</li>
<li>False. Tasks can be removed by calling <kbd>vTaskDelete()</kbd>, provided a compatible heap is used (see <a href="0f98e454-9804-4589-9854-5c38c9d8d416.xhtml">Chapter 15</a>, <em>FreeRTOS Memory Management</em>, for details).</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 8</h1>
                
            
            
                
<ol>
<li>Synchronization; shared resource protection.</li>
<li>Priority inversion (visit the <em>Priority inversion (how not to use semaphores) section </em>for details)</li>
<li><strong>MUT</strong>utual <strong>EX</strong>clusion, which refers to how access to a shared resource is controlled.</li>
<li>They limit priority inversion by ensuring high-priority tasks block as little as possible by automatically raising the priority of a low-priority task holding a mutex that the high priority task is waiting on.</li>
<li>False. Although easy to use, software timers have limitations including jitter and frequency.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 9</h1>
                
            
            
                
<ol>
<li>A queue can hold any data type, thanks to the underlying <kbd>void*</kbd> input parameter.</li>
<li>A task waiting to send data to a queue is placed into the blocked state (suspended if <kbd>portMAX_DELAY</kbd> was specified).</li>
</ol>
<p class="mce-root"/>
<ol start="3">
<li>There were three considerations mentioned: data ownership of the underlying value, ensuring the correct data type is passed into the queue, and making sure the data stays intact (by not placing it onto a volatile stack).</li>
<li>False. Task notifications only store a single <kbd>uint32_t</kbd> and allow a single task with a known task handle to be unblocked. Queues are capable of storing any datatype and can be used across multiple arbitrary tasks.</li>
<li>False. Task notifications only store a single <kbd>uint32_t</kbd>.  </li>
<li>Speed and RAM efficiency.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 10</h1>
                
            
            
                
<ol>
<li>Interrupt-driven drivers are more complex because there are at least three pieces of code involved (setup code, ISR code, and callback code). With a polled driver, all of this happens serially.  </li>
<li>False. Only functions ending in <kbd>FromISR</kbd> may be called within an ISR.</li>
<li>False. Interrupts take precedence over the scheduler since the scheduler should be configured to run from the lowest priority interrupt. </li>
<li>DMA – it uses hardware to transfer data between peripherals and memory, without any CPU intervention.</li>
<li>Direct Memory Access.</li>
<li>Attempting to receive data at any point in time is very difficult to do well with a raw buffer. Raw buffers can also become a bit complex when receiving data of unknown length.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 11</h1>
                
            
            
                
<ol>
<li>False.</li>
<li>False. Timing trade-offs such as increased latency and lower determinism, along with less communication bandwidth, must also be taken into account before deciding a shared hardware peripheral is acceptable.</li>
<li>All of the above.</li>
<li>False. Stream buffers can be used by a single writer and a single reader. These writers and readers don't need to be the same task. If there are multiple writers or multiple readers, then a synchronization mechanism (such as a mutex) is required.</li>
<li>Mutexes.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 12</h1>
                
            
            
                
<ol>
<li>False. Abstractions are useful even in the smallest MCUs.</li>
<li>False. A method for implementing consistent interfaces was presented in this chapter.</li>
<li>Possible answers include the following:
<ul>
<li>Common components will be reused in other projects.</li>
<li>Portability to different hardware is desirable.</li>
<li>Code will be unit tested.</li>
<li>Teams will be working in parallel.</li>
</ul>
</li>
<li>False. Review the <em>Avoiding the copy-paste-modify trap</em> section for more details.</li>
<li>False. When properly written, tasks can be excellent candidates for reuse across projects (see the <em>Reusing code containing tasks</em> section for more details).</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 13</h1>
                
            
            
                
<ol>
<li>False. Queues create a definitive interface, which decouples components from one another.</li>
<li>False. Any datatype can be placed into a queue.</li>
<li>No, omitting the underlying formatting allows more flexibility for the producers of items to be queued. If the data isn't tied to a specific format, the format can be modified without affecting the queue or the consumer of data coming out of the queue.</li>
<li>Possible answers include the following:
<ul>
<li>A queued item's lifetime doesn't need to be taken into consideration since a copy of it is made. </li>
<li>The queued item's scope doesn't need to be taken into account if it is passed by value into the queue. </li>
<li>If an item is passed by reference, a clear understanding of who <em>owns</em> the item is necessary, as well as who is responsible for freeing the resources associated with it.</li>
</ul>
</li>
<li>Possible answers include the following:
<ul>
<li>Latency introduced by deep queues</li>
<li>Non-deterministic behavior caused by requests sitting in a queue instead of being immediately executed (or rejected)</li>
<li>Memory constraints</li>
</ul>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 14</h1>
                
            
            
                
<ol>
<li><strong>CMSIS-RTOS</strong> stands for <strong>Cortex Microcontroller Software Interface Standard - Real-Time Operating System</strong>. The CMSIS-RTOS specification was written by ARM, but there are many vendors that can elect to supply CMSIS-RTOS-compliant interfaces in their RTOSes.</li>
<li>Linux and Android.</li>
<li>False.</li>
<li>False.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 15</h1>
                
            
            
                
<ol>
<li>False.</li>
<li>False.</li>
<li>There are five implementations: <kbd>heap_1.c</kbd> through <kbd>heap_5.c</kbd>.</li>
<li><kbd>vApplicationStackOverflowHook</kbd> and <kbd>vApplicationMallocFailedHook</kbd>.</li>
<li><strong>MPU</strong> stands for <strong>Memory Protection Unit</strong>. It is used to guard against illegal memory access, especially as a way to partition tasks so they are only allowed access to their own memory space.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 16</h1>
                
            
            
                
<ol>
<li><em>Multi-core</em> means multiple cores on the same IC while <em>multi-processor</em> means multiple processors (ICs) in the same design.</li>
<li>True. Asymmetric architectures don't require the various processing cores to be treated in the same way, so any combination of operating systems and bare-metal programming languages can be used (within the restrictions of the hardware).</li>
<li>False. There are many aspects to consider when selecting the <em>best</em> bus for a given application since each application will have its own set of unique circumstances and requirements.</li>
<li>The additional complexity needs to be weighed against the possibility of not performing the same work twice. When reusable subsystems are developed, they can create considerable cost savings under the right circumstances. They have little to no <strong>nonrecurring engineering</strong> (<strong>NRE</strong>) costs associated with them when re-used.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Chapter 17</h1>
                
            
            
                
<ol>
<li>You should do the following:
<ol>
<li>Connect a debugger.</li>
<li>Figure out where the program stopped.</li>
<li>If it is a <kbd>configASSERT</kbd>, read the comments surrounding the assertion. If it fails before the scheduler starts, you've likely overflowed your FreeRTOS heap.</li>
</ol>
</li>
<li>Any one of the following:
<ul>
<li>Task stack overflows</li>
<li>Misprioritized ISRs</li>
<li>Inadequate heap size</li>
</ul>
</li>
<li>False. Debugging tools such as Segger SystemView exist, which provide both printf-style output as well as instrumentation for observing the code's behavior.</li>
</ol>


            

            
        
    </body></html>