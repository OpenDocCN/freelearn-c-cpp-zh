- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: JIT Compilation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JIT 编译
- en: The LLVM core libraries come with the **ExecutionEngine** component that allows
    the compilation and execution of **intermediate representation** (**IR**) code
    in memory. Using this component, we can build **just-in-time** (**JIT**) compilers,
    which allows for direct execution of IR code. A JIT compiler works more like an
    interpreter because no object code needs to be stored on secondary storage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 核心库包含一个名为 **ExecutionEngine** 的组件，该组件允许在内存中编译和执行 **中间表示**（**IR**）代码。使用此组件，我们可以构建
    **即时**（**JIT**）编译器，这允许直接执行 IR 代码。即时编译器更像是一个解释器，因为不需要在辅助存储上存储目标代码。
- en: In this chapter, you will learn about applications for JIT compilers, and how
    the LLVM JIT compiler works in principle. You will explore the LLVM dynamic compiler
    and interpreter and learn how to implement JIT compiler tools on your own. Furthermore,
    you will also learn how to use a JIT compiler as part of a static compiler, and
    the associated challenges.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解即时编译器的应用，以及 LLVM 即时编译器在原理上是如何工作的。你将探索 LLVM 动态编译器和解释器，并学习如何自己实现即时编译器工具。此外，你还将学习如何将即时编译器作为静态编译器的一部分使用，以及相关的挑战。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Getting an overview of LLVM’s JIT implementation and use cases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 LLVM 的 JIT 实现和使用案例概述
- en: Using JIT compilation for direct execution
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JIT 编译进行直接执行
- en: Implementing your own JIT compiler from existing classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现有类实现自己的 JIT 编译器
- en: Implementing your own JIT compiler from scratch
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从零开始实现自己的 JIT 编译器
- en: By the end of the chapter, you will understand and know how to develop a JIT
    compiler, either using a preconfigured class or a customized version fitting for
    your needs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将理解并知道如何开发一个即时编译器，无论是使用预配置的类还是定制版本以满足你的需求。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code used in this chapter at [https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter09](https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter09)
    .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter09](https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter09)
    找到本章使用的代码。
- en: LLVM’s overall JIT implementation and use cases
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLVM 的整体 JIT 实现和使用案例
- en: 'So far, we have only looked at **ahead-of-time** (**AOT**) compilers. These
    compilers compile the whole application. The application can only run after the
    compilation is finished. If the compilation is performed at the runtime of the
    application, then the compiler is a JIT compiler. A JIT compiler has interesting
    use cases:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看了 **预编译**（**AOT**）编译器。这些编译器编译整个应用程序。应用程序只能在编译完成后运行。如果编译是在应用程序的运行时执行的，那么编译器就是一个
    JIT 编译器。JIT 编译器有一些有趣的用例：
- en: '**Implementation of a virtual machine**: A programming language can be translated
    to byte code with an AOT compiler. At runtime, a JIT compiler is used to compile
    the byte code to machine code. The advantage of this approach is that the byte
    code is hardware-independent, and thanks to the JIT compiler, there is no performance
    penalty compared to an AOT compiler. Java and C# use this model today, but this
    is not a new idea: the USCD Pascal compiler from 1977 already used a similar approach.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟机的实现**：一种编程语言可以使用 AOT 编译器转换为字节码。在运行时，使用 JIT 编译器将字节码编译为机器代码。这种方法的优点是字节码是硬件无关的，而且由于
    JIT 编译器的存在，与 AOT 编译器相比没有性能损失。Java 和 C# 目前使用这种模型，但这并不是一个新想法：1977 年的 USCD Pascal
    编译器已经使用了类似的方法。'
- en: '`lldb` LLVM debugger uses this approach to evaluate source expressions at debug
    time.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lldb` LLVM 调试器使用这种方法在调试时评估源表达式。'
- en: '**Database queries**: A database creates an execution plan from a database
    query. The execution plan describes operations on tables and columns, which leads
    to a query answer when executed. A JIT compiler can be used to translate the execution
    plan into machine code, which speeds up the execution of the query.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库查询**：数据库从数据库查询中创建一个执行计划。执行计划描述了对表和列的操作，当执行时，这些操作导致查询结果。可以使用即时编译器将执行计划转换为机器代码，从而加快查询的执行速度。'
- en: The static compilation model of LLVM is not as far away from the JIT model as
    one may think. The `llc` LLVM static compiler compiles LLVM IR into machine code
    and saves the result as an object file on disk. If the object file is not stored
    on disk but in memory, would the code be executable? Not directly, as references
    to global functions and global data use relocations instead of absolute addresses.
    Conceptually, a **relocation** describes how to calculate the address – for example,
    as an offset to a known address. If we resolve relocations into addresses, as
    the linker and the dynamic loader do, then we can execute the object code. Running
    the static compiler to compile IR code into an object file in memory, performing
    a link step on the in-memory object file, and running the code gives us a JIT
    compiler. The JIT implementation in the LLVM core libraries is based on this idea.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 的静态编译模型并不像人们想象的那样远离 JIT 模型。`llc` LLVM 静态编译器将 LLVM IR 编译成机器代码，并将结果保存为磁盘上的目标文件。如果目标文件不是存储在磁盘上而是在内存中，代码是否可执行？不是直接可执行，因为对全局函数和全局数据的引用使用重定位而不是绝对地址。从概念上讲，**重定位**描述了如何计算地址——例如，作为已知地址的偏移量。如果我们像链接器和动态加载器那样解析重定位到地址，那么我们可以执行目标代码。运行静态编译器将
    IR 代码编译成内存中的目标文件，对内存中的目标文件执行链接步骤，然后运行代码，我们就得到了一个 JIT 编译器。LLVM 核心库中的 JIT 实现基于这个想法。
- en: During the development history of LLVM, there were several JIT implementations,
    with different feature sets. The latest JIT API is the **On-Request Compilation**
    (**ORC**) engine. In case you were curious about the acronym, it was the lead
    developer’s intention to invent yet another acronym based on Tolkien’s universe,
    after **Executable and Linking Format** (**ELF**) and **Debugging Standard** (**DWARF**)
    were already present.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LLVM 的发展历史中，有几种 JIT 实现，具有不同的功能集。最新的 JIT API 是 **按需编译**（**ORC**）引擎。如果你对缩写词感兴趣，这是主要开发者的意图，在
    **可执行和链接格式**（**ELF**）和 **调试标准**（**DWARF**）已经存在之后，再次发明一个基于托尔金的宇宙的缩写词。
- en: The ORC engine builds on and extends the idea of using the static compiler and
    a dynamic linker on the in-memory object file. The implementation uses a layered
    approach. The two basic levels are the compile layer and the link layer. On top
    of this sits a layer providing support for lazy compilation. A transformation
    layer can be stacked on top or below the lazy compilation layer, allowing the
    developer to add arbitrary transformations or simply to be notified of certain
    events. Moreover, this layered approach has the advantage that the JIT engine
    is customizable for diverse requirements. For example, a high-performance virtual
    machine may choose to compile everything upfront and make no use of the lazy compilation
    layer. On the other hand, other virtual machines will emphasize startup time and
    responsiveness to the user and will achieve this with the help of the lazy compilation
    layer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ORC 引擎建立在并扩展了在内存中的目标文件上使用静态编译器和动态链接器的想法。该实现使用分层方法。两个基本级别是编译层和链接层。在这之上是一个提供懒编译支持的层。可以在懒编译层之上或之下堆叠一个转换层，允许开发者添加任意的转换或简单地通知某些事件。此外，这种分层方法的优势在于
    JIT 引擎可以根据不同的需求进行定制。例如，高性能虚拟机可能会选择预先编译所有内容，并且不使用懒编译层。另一方面，其他虚拟机可能会强调启动时间和对用户的响应性，并借助懒编译层来实现这一点。
- en: The older MCJIT engine is still available, and its API is derived from an even
    older, already-removed JIT engine. Over time, this API gradually became bloated,
    and it lacks the flexibility of the ORC API. The goal is to remove this implementation,
    as the ORC engine now provides all the functionality of the MCJIT engine, and
    new developments should use the ORC API.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧的 MCJIT 引擎仍然可用，其 API 来自一个更早、已经删除的 JIT 引擎。随着时间的推移，这个 API 逐渐变得臃肿，并且缺乏 ORC API
    的灵活性。目标是移除这个实现，因为 ORC 引擎现在提供了 MCJIT 引擎的所有功能，新的开发应该使用 ORC API。
- en: In the next section, we look at `lli`, the LLVM interpreter, and the dynamic
    compiler, before we dive into implementing a JIT compiler.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实现 JIT 编译器之前，下一节我们将探讨 `lli`，LLVM 解释器和动态编译器。
- en: Using JIT compilation for direct execution
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JIT 编译进行直接执行
- en: Running LLVM IR directly is the first idea that comes to mind when thinking
    about a JIT compiler. This is what the `lli` tool, the LLVM interpreter, and the
    dynamic compiler do. We will explore the `lli` tool in the next section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 直接运行 LLVM IR 是想到即时编译器时的第一个想法。这正是 `lli` 工具、LLVM 解释器和动态编译器所做的事情。我们将在下一节中探讨 `lli`
    工具。
- en: Exploring the lli tool
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 lli 工具
- en: Let’s try the `lli` tool with a very simple example. The following LLVM IR can
    be stored as a file called `hello.ll`, which is the equivalent of a C hello world
    application. This file declares a prototype for the `printf()` function from the
    C library. The `hellostr` constant contains the message to be printed. Inside
    the `main()` function, a call to the `printf()` function is generated, and this
    function contains a `hellostr` message that will be printed. The application always
    returns `0`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个非常简单的例子来尝试 `lli` 工具。下面的 LLVM IR 可以存储在一个名为 `hello.ll` 的文件中，这相当于一个 C 的 hello
    world 应用程序。此文件声明了来自 C 库的 `printf()` 函数的原型。`hellostr` 常量包含要打印的消息。在 `main()` 函数内部，会生成对
    `printf()` 函数的调用，并且这个函数包含一个将要打印的 `hellostr` 消息。应用程序总是返回 `0`。
- en: 'The complete source code is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码如下：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This LLVM IR file is generic enough that it is valid for all platforms. We
    can directly execute the IR using the `lli` tool with the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 LLVM IR 文件足够通用，适用于所有平台。我们可以直接使用以下命令使用 `lli` 工具执行 IR：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The interesting point here is how the `printf()` function is found. The IR code
    is compiled to machine code, and a lookup for the `printf` symbol is triggered.
    This symbol is not found in the IR, so the current process is searched for it.
    The `lli` tool dynamically links against the C library, and the symbol is found
    there.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的一点是如何找到 `printf()` 函数。IR 代码被编译成机器代码，并触发对 `printf` 符号的查找。这个符号在 IR 中找不到，因此当前进程会搜索它。`lli`
    工具动态链接到 C 库，并在那里找到符号。
- en: 'Of course, the `lli` tool does not link against the libraries you created.
    To enable the use of such functions, the `lli` tool supports the loading of shared
    libraries and objects. The following C source just prints a friendly message:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`lli` 工具不会链接到你创建的库。为了启用这些函数的使用，`lli` 工具支持加载共享库和对象。以下 C 源代码仅打印一条友好的消息：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Stored in `greetings.c`, we use this to explore loading objects with `lli`.
    The following command will compile this source into a shared library. The `–fPIC`
    option instructs `clang` to generate position-independent code, which is required
    for shared libraries. Moreover, the compiler creates a `greetings.so` shared library
    with `–``shared`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 `greetings.c` 中，我们使用它来探索使用 `lli` 加载对象。以下命令将此源代码编译成一个共享库。`–fPIC` 选项指示 `clang`
    生成位置无关代码，这对于共享库是必需的。此外，编译器使用 `–shared` 创建一个名为 `greetings.so` 的共享库：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also compile the file into the `greetings.o` object file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将文件编译成 `greetings.o` 对象文件：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We now have two files, the `greetings.so` shared library and the `greetings.o`
    object file, which we will load into the `lli` tool.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个文件，即 `greetings.so` 共享库和 `greetings.o` 对象文件，我们将它们加载到 `lli` 工具中。
- en: 'We also need an LLVM IR file that calls the `greetings()` function. For this,
    create a `main.ll` file that contains a single call to the function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个调用 `greetings()` 函数的 LLVM IR 文件。为此，创建一个包含对函数的单个调用的 `main.ll` 文件：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice that on executing, the previous IR crashes, as `lli` cannot locate the
    greetings symbol:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在执行时，之前的 IR 会崩溃，因为 `lli` 无法定位到问候符号：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `greetings()` function is defined in an external file, and to fix the crash,
    we have to tell the `lli` tool which additional file needs to be loaded. In order
    to use the shared library, you must use the `–load` option, which takes the path
    to the shared library as an argument:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`greetings()` 函数定义在一个外部文件中，为了修复崩溃，我们必须告诉 `lli` 工具需要加载哪些额外的文件。为了使用共享库，你必须使用
    `–load` 选项，它接受共享库的路径作为参数：'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is important to specify the path to the shared library if the directory containing
    the shared library is not in the search path for the dynamic loader. If omitted,
    then the library will not be found.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含共享库的目录不在动态加载器的搜索路径中，则指定共享库的路径很重要。如果省略，则库将无法找到。
- en: 'Alternatively, we can instruct `lli` to load the object file with `–extra-object`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以指示 `lli` 使用 `–extra-object` 加载对象文件：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Other supported options are `–extra-archive`, which loads an archive, and `–extra-module`,
    which loads another bitcode file. Both options require the path to the file as
    an argument.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 其他支持选项包括 `–extra-archive`，它加载一个存档，以及 `–extra-module`，它加载另一个位代码文件。这两个选项都需要文件路径作为参数。
- en: You now know how you can use the `lli` tool to directly execute LLVM IR. In
    the next section, we will implement our own JIT tool.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道了如何使用 `lli` 工具直接执行 LLVM IR。在下一节中，我们将实现自己的 JIT 工具。
- en: Implementing our own JIT compiler with LLJIT
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LLJIT 实现自己的 JIT 编译器
- en: The `lli` tool is nothing more than a thin wrapper around LLVM APIs. In the
    first section, we learned that the ORC engine uses a layered approach. The `ExecutionSession`
    class represents a running JIT program. Besides other items, this class holds
    information such as used `JITDylib` instances. A `JITDylib` instance is a symbol
    table that maps symbol names to addresses. For example, these can be symbols defined
    in an LLVM IR file or the symbols of a loaded shared library.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`lli` 工具不过是围绕 LLVM API 的一个薄包装。在第一部分，我们了解到 ORC 引擎使用分层方法。`ExecutionSession` 类代表一个正在运行的
    JIT 程序。除了其他项目外，这个类还持有诸如使用的 `JITDylib` 实例等信息。一个 `JITDylib` 实例是一个符号表，它将符号名称映射到地址。例如，这些可以是定义在
    LLVM 立即编译代码文件中的符号，或者加载的共享库中的符号。'
- en: For executing LLVM IR, we do not need to create a JIT stack on our own, as the
    `LLJIT` class provides this functionality. You can also make use of this class
    when migrating from the older MCJIT implementation, as this class essentially
    provides the same functionality.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于执行 LLVM 立即编译代码，我们不需要自己创建 JIT 栈，因为 `LLJIT` 类提供了这一功能。在从较老的 MCJIT 实现迁移时，您也可以使用这个类，因为这个类本质上提供了相同的功能。
- en: To illustrate the functions of the `LLJIT` utility, we will be creating an interactive
    calculator application while incorporating JIT functionality. The main source
    code of our JIT calculator will be extended from the `calc` example from [*Chapter
    2*](B19561_02.xhtml#_idTextAnchor037), *The Structure of* *a Compiler*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 `LLJIT` 工具的功能，我们将创建一个包含 JIT 功能的交互式计算器应用程序。我们的 JIT 计算器的主要源代码将扩展自 [*第 2 章*](B19561_02.xhtml#_idTextAnchor037)，《编译器结构》中的
    `calc` 示例。
- en: 'The primary idea behind our interactive JIT calculator will be as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们交互式即时编译计算器的核心思想如下：
- en: Allow the user to input a function definition, such as `def f(x) =` `x*2`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许用户输入一个函数定义，例如 `def f(x) =` `x*2`。
- en: The function inputted by the user is then compiled by the `LLJIT` utility into
    a function – in this case, `f`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户输入的函数随后将由 `LLJIT` 工具编译成一个函数——在这种情况下，是 `f` 函数。
- en: 'Allow the user to call the function they have defined with a numerical value:
    `f(3)`.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许用户使用数值调用他们定义的函数：`f(3)`。
- en: 'Evaluate the function with the provided argument, and print the result to the
    console: `6`.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的参数评估函数，并将结果打印到控制台：`6`。
- en: 'Before we discuss incorporating JIT functionality into the calculator source
    code, there are a few main differences to point out with respect to the original
    calculator example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论将 JIT 功能集成到计算器源代码之前，有一些主要差异需要指出，与原始计算器示例相比：
- en: Firstly, we previously only input and parsed functions beginning with the `with`
    keyword, rather than the `def` keyword described previously. For this chapter,
    we instead only accept function definitions beginning with `def`, and this is
    represented as a particular node in our `DefDecl`. The `DefDecl` class is aware
    of the arguments and their names it is defined with, and the function name is
    also stored within this class.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们之前只输入和解析以 `with` 关键字开头的函数，而不是之前描述的 `def` 关键字。对于本章，我们只接受以 `def` 关键字开头的函数定义，并在我们的
    `DefDecl` 中表示为特定的节点。`DefDecl` 类知道它所定义的参数及其名称，并且函数名也存储在这个类中。
- en: Secondly, we also need our AST to be aware of function calls, to represent the
    functions that the `LLJIT` utility has consumed or JIT’ted. Whenever a user inputs
    the name of a function, followed by arguments enclosed in parentheses, the AST
    recognizes these as `FuncCallFromDef` nodes. This class essentially is aware of
    the same information as the `DefDecl` class.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们还需要我们的抽象语法树（AST）能够识别函数调用，以表示 `LLJIT` 工具所消耗或即时编译（JIT）的函数。每当用户输入一个函数名，后面跟着括号内的参数时，AST
    会将这些识别为 `FuncCallFromDef` 节点。这个类本质上知道与 `DefDecl` 类相同的信息。
- en: Due to the addition of these two AST classes, it is obvious to expect that the
    semantic analysis, parser, and code generation classes will be adapted accordingly
    to handle the changes in our AST. One additional thing to note is the addition
    of a new data structure, called `JITtedFunctions`, which all these classes are
    aware of. This data structure is a map with the defined function names as keys,
    and the number of arguments a function is defined with is stored as values within
    the map. We will see later how this data structure will be utilized in our JIT
    calculator.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于增加了这两个AST类，可以明显预期语义分析、解析器和代码生成类将相应地调整以处理我们AST中的变化。需要注意的是，还增加了一个新的数据结构，称为`JITtedFunctions`，这些类都了解这个数据结构。这个数据结构是一个映射，其中定义的函数名作为键，函数定义中存储的参数数量作为映射中的值。我们将在稍后看到这个数据结构如何在我们的JIT计算器中利用。
- en: For more details on the changes we have made to the `calc` example, the full
    source containing the changes from `calc` and this section’s JIT implementation
    can be found within the `lljit` source directory.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们对`calc`示例所做的更改的更多细节，包含从`calc`和本节JIT实现的更改的完整源代码可以在`lljit`源目录中找到。
- en: Integrating the LLJIT engine into the calculator
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将LLJIT引擎集成到计算器中
- en: 'Firstly, let’s discuss how to set up the JIT engine in our interactive calculator.
    All of the implementation pertaining to the JIT engine exists within `Calc.cpp`,
    and this file has one `main()` loop for the execution of the program:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论如何在交互式计算器中设置JIT引擎。与JIT引擎相关的所有实现都存在于`Calc.cpp`文件中，该文件有一个`main()`循环用于程序的执行：
- en: 'We must include several header files, aside from the headers including our
    code generation, semantic analyzer, and parser implementation. The `LLJIT.h` header
    defines the `LLJIT` class and the core classes of the ORC API. Next, the `InitLLVM.h`
    header is needed for the basic initialization of the tool, and the `TargetSelect.h`
    header is needed for the initialization of the native target. Finally, we also
    include the `<iostream>` C++ header to allow for user input into our calculator
    application:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了包括我们的代码生成、语义分析器和解析器实现的头文件外，我们还必须包含几个头文件。《LLJIT.h》头文件定义了`LLJIT`类和ORC API的核心类。接下来，需要`InitLLVM.h`头文件来进行工具的基本初始化，以及需要`TargetSelect.h`头文件来进行本地目标的初始化。最后，我们还包含了`<iostream>`
    C++头文件，以便允许用户在我们的计算器应用程序中输入：
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we add the `llvm` and `llvm::orc` namespaces to the current scope:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将`llvm`和`llvm::orc`命名空间添加到当前作用域：
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Many of the calls from our `LLJIT` instance that we will be creating return
    an error type, `Error`. The `ExitOnError` class allows us to discard `Error` values
    that are returned by the calls from the `LLJIT` instance while logging to `stderr`
    and exiting the application. We declare a global `ExitOnError` variable as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要创建的`LLJIT`实例中的许多调用都会返回一个错误类型，`Error`。`ExitOnError`类允许我们在记录到`stderr`并退出应用程序的同时丢弃由`LLJIT`实例返回的`Error`值。我们声明一个全局的`ExitOnError`变量如下：
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we add the `main()` function, which initializes the tool and the native
    target:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加`main()`函数，该函数初始化工具和本地目标：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We use the `LLJITBuilder` class to create an `LLJIT` instance, wrapped in the
    previously declared `ExitOnErr` variable in case an error occurs. A possible source
    of error would be that the platform does not yet support JIT compilation:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`LLJITBuilder`类创建一个`LLJIT`实例，并将其封装在之前声明的`ExitOnErr`变量中，以防出现错误。一个可能出错的原因是平台尚未支持JIT编译：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we declare our `JITtedFunctions` map that keeps track of the function
    definitions, as we have previously described:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们声明我们的`JITtedFunctions`映射，该映射跟踪函数定义，正如我们之前所描述的：
- en: '[PRE14]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To facilitate an environment that waits for user input, we add a `while()`
    loop and allow the user to type in an expression, saving the line that the user
    typed within a string called `calcExp`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便等待用户输入的环境，我们添加了一个`while()`循环，并允许用户输入一个表达式，将用户输入的行保存到一个名为`calcExp`的字符串中：
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Afterward, the LLVM context class is initialized, along with a new LLVM module.
    The module’s data layout is also set accordingly, and we also declare a code generator,
    which will be used to generate IR for the function that the user has defined on
    the command line:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，初始化LLVM上下文类和新的LLVM模块。模块的数据布局也相应设置，我们还声明了一个代码生成器，该生成器将用于为用户在命令行上定义的函数生成IR：
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We must interpret the line that was entered by the user to determine if the
    user is defining a new function or calling a previous function that they have
    defined with an argument. A `Lexer` class is defined while taking in the line
    of input that the user has given. We will see that there are two main cases that
    the lexer cares about:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须解释用户输入的行，以确定用户是定义一个新函数还是调用他们之前定义并带有参数的函数。在接收用户输入的行时定义了一个`Lexer`类。我们将看到词法分析器主要关注两个主要情况：
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The lexer can check the first token of the user input. If the user is defining
    a new function (represented by the `def` keyword, or the `Token::KW_def` token),
    then we parse it and check its semantics. If the parser or the semantic analyzer
    detects any issues with the user-defined function, errors will be emitted accordingly,
    and the calculator program will halt. If no errors are detected from either the
    parser or the semantic analyzer, this means we have a valid AST data structure,
    `DefDecl`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 词法分析器可以检查用户输入的第一个标记。如果用户正在定义一个新的函数（由`def`关键字或`Token::KW_def`标记表示），那么我们将解析它并检查其语义。如果解析器或语义分析器检测到用户定义的函数有任何问题，将相应地发出错误，计算器程序将停止。如果没有检测到解析器或语义分析器的错误，这意味着我们有一个有效的AST数据结构，即`DefDecl`：
- en: '[PRE18]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then can pass our newly constructed AST into our code generator to compile
    the IR for the function that the user has defined. The specifics of IR generation
    will be discussed afterward, but this function that compiles to the IR needs to
    be aware of the module and our `JITtedFunctions` map. After generating the IR,
    we can add this information to our `LLJIT` instance by calling `addIRModule()`
    and wrapping our module and context in a `ThreadSafeModule` class, to prevent
    these from being accessed by other concurrent threads:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将新构建的AST传递给我们的代码生成器，编译用户定义函数的中间表示（IR）。IR生成的具体细节将在之后讨论，但这个编译为IR的函数需要知道模块和我们的`JITtedFunctions`映射。在生成IR之后，我们可以通过调用`addIRModule()`并将模块和上下文包装在`ThreadSafeModule`类中来将此信息添加到我们的`LLJIT`实例中，以防止这些信息被其他并发线程访问：
- en: '[PRE19]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Instead, if the user is calling a function with parameters, which is represented
    by the `Token::ident` token, we also need to parse and semantically check if the
    user input is valid prior to converting the input into a valid AST. The parsing
    and checking here are slightly different compared to before, as it can include
    checks such as ensuring the number of parameters that the user has supplied to
    the function call matches the number of parameters that the function was originally
    defined with:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，如果用户正在调用带有参数的函数，这由`Token::ident`标记表示，我们还需要在将输入转换为有效的AST之前解析和语义检查用户输入是否有效。这里的解析和检查与之前略有不同，因为它可能包括确保用户提供给函数调用的参数数量与函数最初定义的参数数量相匹配的检查：
- en: '[PRE20]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once a valid AST is constructed for a function call, `FuncCallFromDef`, we
    get the name of the function from the AST, and then the code generator prepares
    to generate the call to the function that was previously added to the `LLJIT`
    instance. What occurs under the cover is that the user-defined function is regenerated
    as an LLVM call within a separate function that will be created that does the
    actual evaluation of the original function. This step requires the AST, the module,
    the function call name, and our map of function definitions:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦为函数调用构建了一个有效的抽象语法树（AST），即`FuncCallFromDef`，我们就从AST中获取函数名称，然后代码生成器准备生成对之前添加到`LLJIT`实例中的函数的调用。在幕后发生的是，用户定义的函数被重新生成为一个LLVM调用，在一个将执行原始函数实际评估的单独函数中。这一步需要AST、模块、函数调用名称以及我们的函数定义映射：
- en: '[PRE21]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After the code generator has completed its work to regenerate the original
    function and to create a separate evaluation function, we must add this information
    to the `LLJIT` instance. We create a `ResourceTracker` instance to track the memory
    that is allocated to the functions that have been added to `LLJIT`, as well as
    another `ThreadSafeModule` instance of the module and context. These two instances
    are then added to the JIT as an IR module:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码生成器完成重新生成原始函数和创建单独评估函数的工作后，我们必须将此信息添加到`LLJIT`实例中。我们创建一个`ResourceTracker`实例来跟踪分配给添加到`LLJIT`的函数的内存，以及另一个模块和上下文的`ThreadSafeModule`实例。然后，这两个实例被添加到JIT作为一个IR模块：
- en: '[PRE22]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The separate evaluation function is then queried for within our `LLJIT` instance
    through the `lookup()` method, by supplying the name of our evaluation function,
    `calc_expr_func`, into the function. If the query is successful, the address for
    the `calc_expr_func` function is cast to the appropriate type, which is a function
    that takes no arguments and returns a single integer. Once the function’s address
    is acquired, we call the function to generate the result of the user-defined function
    with the parameters they have supplied and then print the result to the console:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过`lookup()`方法在我们的`LLJIT`实例中查询单独的评估函数，通过将我们的评估函数名称`calc_expr_func`提供给函数。如果查询成功，`calc_expr_func`函数的地址被转换为适当类型，这是一个不接受任何参数并返回单个整数的函数。一旦获得函数的地址，我们就调用该函数以生成用户定义函数的参数所提供的参数的结果，然后将结果打印到控制台：
- en: '[PRE23]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After the function call is completed, the memory that was previously associated
    with our functions is then freed by `ResourceTracker`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数调用完成后，之前与我们的函数关联的内存随后通过`ResourceTracker`释放：
- en: '[PRE24]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Code generation changes to support JIT compilation via LLJIT
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码生成更改以支持通过LLJIT进行JIT编译
- en: 'Now, let’s take a brief look at some of the changes we have made within `CodeGen.cpp`
    to support our JIT-based calculator:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要地看一下我们在`CodeGen.cpp`中做出的某些更改，以支持我们的基于JIT的计算器：
- en: 'As previously mentioned, the code generation class has two important methods:
    one to compile the user-defined function into LLVM IR and print the IR to the
    console, and another to prepare the calculation evaluation function, `calc_expr_func`,
    which contains a call to the original user-defined function for evaluation. This
    second function also prints the resulting IR to the user:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，代码生成类有两个重要方法：一个是将用户定义的函数编译成LLVM IR并将IR打印到控制台，另一个是准备计算评估函数`calc_expr_func`，它包含对原始用户定义函数的评估调用。第二个函数也将生成的IR打印给用户：
- en: '[PRE25]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As noted in the preceding source, these code generation functions define a
    `ToIRVisitor` instance that takes in our module and a `JITtedFunctions` map to
    be used in its constructor upon initialization:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述的源代码所示，这些代码生成函数定义了一个`ToIRVisitor`实例，它接受我们的模块和一个`JITtedFunctions`映射，在初始化时用于其构造函数：
- en: '[PRE26]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Ultimately, this information is used to either generate IR or evaluate the
    function that the IR was previously generated for. When generating the IR, the
    code generator expects to see a `DefDecl` node, which represents defining a new
    function. The function name, along with the number of arguments it is defined
    with, is stored within the function definitions map:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，这些信息被用来生成IR或评估之前为IR生成的函数。当生成IR时，代码生成器期望看到一个`DefDecl`节点，它代表定义一个新函数。函数名称及其定义的参数数量存储在函数定义映射中：
- en: '[PRE27]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Afterward, the actual function definition is created by the `genUserDefinedFunction()`
    call:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，通过`genUserDefinedFunction()`调用创建实际函数定义：
- en: '[PRE28]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Within `genUserDefinedFunction()`, the first step is to check if the function
    exists within the module. If it does not, we ensure that the function prototype
    exists within our map data structure. Then, we use the name and the number of
    arguments to construct a function that has the number of arguments that were defined
    by the user, and make the function return a single integer value:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`genUserDefinedFunction()`中，第一步是检查函数是否在模块中存在。如果不存在，我们确保函数原型存在于我们的映射数据结构中。然后，我们使用名称和参数数量来构建一个具有用户定义的参数数量的函数，并使该函数返回一个单一整数值：
- en: '[PRE29]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After generating the user-defined function, a new basic block is created, and
    we insert our function into the basic block. Each function argument is also associated
    with a name that is defined by the user, so we also set the names for all function
    arguments accordingly, as well as generate mathematical operations that operate
    on the arguments within the function:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成用户定义的函数之后，创建一个新的基本块，并将我们的函数插入到基本块中。每个函数参数也与用户定义的名称相关联，因此我们也为所有函数参数设置了相应的名称，以及生成在函数内部操作的数学运算：
- en: '[PRE30]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When evaluating the user-defined function, the AST that is expected in our
    example is called a `FuncCallFromDef` node. First, we define the evaluation function
    and name it `calc_expr_func` (taking in zero arguments and returning one result):'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当评估用户定义的函数时，在我们的示例中期望的AST被称为`FuncCallFromDef`节点。首先，我们定义评估函数并将其命名为`calc_expr_func`（接受零个参数并返回一个结果）：
- en: '[PRE31]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we create a new basic block to insert `calc_expr_func` into:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的基本块以插入`calc_expr_func`：
- en: '[PRE32]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Similar to before, the user-defined function is retrieved by `genUserDefinedFunction()`,
    and we pass the numerical parameters of the function call into the original function
    that we have just regenerated:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前类似，用户定义的函数是通过`genUserDefinedFunction()`检索的，我们将函数调用的数值参数传递给刚刚重新生成的原始函数：
- en: '[PRE33]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once we have the actual `llvm::Function` instance available, we utilize `IRBuilder`
    to create a call to the defined function and also return the result so that it
    is accessible when the result is printed to the user in the end:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了实际的`llvm::Function`实例，我们就利用`IRBuilder`创建对定义的函数的调用，并返回结果，以便在最终将结果打印给用户时可以访问：
- en: '[PRE34]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Building an LLJIT-based calculator
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建基于LLJIT的计算器
- en: 'Finally, to compile our JIT calculator source, we also need to create a `CMakeLists.txt`
    file with the build description, saved beside `Calc.cpp` and our other source
    files:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了编译我们的JIT计算器源代码，我们还需要创建一个包含构建描述的`CMakeLists.txt`文件，并将其保存到`Calc.cpp`和我们的其他源文件旁边：
- en: 'We set the minimal required CMake version to the number required by LLVM and
    give the project a name:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将所需的最低CMake版本设置为LLVM所需的版本，并为项目命名：
- en: '[PRE35]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The LLVM package needs to be loaded, and we add the directory of the CMake
    modules provided by LLVM to the search path. Then, we include the `DetermineGCCCompatible`
    and `ChooseMSVCCRT` modules, which check if the compiler has GCC-compatible command-line
    syntax and ensure that the same C runtime is used as by LLVM, respectively:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要加载LLVM包，并将LLVM提供的CMake模块目录添加到搜索路径中。然后，我们包含`DetermineGCCCompatible`和`ChooseMSVCCRT`模块，这些模块检查编译器是否具有GCC兼容的命令行语法，并确保使用与LLVM相同的C运行时：
- en: '[PRE36]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We also need to add definitions and the `include` path from LLVM. The used
    LLVM components are mapped to the library names with a function call:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加来自LLVM的定义和`include`路径。使用的LLVM组件通过函数调用映射到库名称：
- en: '[PRE37]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Afterward, if it is determined that the compiler has GCC-compatible command-line
    syntax, we also check if runtime type information and exception handling are enabled.
    If they are not enabled, C++ flags to turn off these features are added to our
    compilation accordingly:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，如果确定编译器具有GCC兼容的命令行语法，我们还会检查是否启用了运行时类型信息和异常处理。如果没有启用，则相应地添加C++标志以关闭这些功能：
- en: '[PRE38]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Lastly, we define the name of the executable, the source files to compile,
    and the library to link against:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义了可执行文件名称、要编译的源文件以及要链接的库：
- en: '[PRE39]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding steps are all that is required for our JIT-based interactive
    calculator tool. Next, create and change into a build directory, and then run
    the following command to create and compile the application:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤就是我们的基于JIT的交互式计算器工具所需的所有步骤。接下来，创建并切换到构建目录，然后运行以下命令以创建和编译应用程序：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This compiles the `calc` tool. We can then launch the calculator, start defining
    functions, and see how our calculator is able to evaluate the functions that we
    define.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这会编译`calc`工具。然后我们可以启动计算器，开始定义函数，并查看我们的计算器如何评估我们定义的函数。
- en: 'The following example invocations show the IR of the function that is first
    defined, and then the `calc_expr_func` function that is created to generate a
    call to our originally defined function in order to evaluate the function with
    whichever parameter passed into it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例调用显示了首先定义的函数的IR，然后是创建的`calc_expr_func`函数，该函数用于生成对最初定义的函数的调用，以便使用传递给它的任何参数评估该函数：
- en: '[PRE41]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That’s it! We have just created a JIT-based calculator application!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们刚刚创建了一个基于JIT的计算器应用程序！
- en: 'As our JIT calculator is meant to be a simple example that describes how to
    incorporate `LLJIT` into our projects, it is worth noting that there are some
    limitations:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的JIT计算器旨在作为一个简单的示例，说明如何将`LLJIT`集成到我们的项目中，因此值得注意的是存在一些限制：
- en: This calculator does not accept negatives of decimal values
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此计算器不接受十进制值的负数
- en: We cannot redefine the same function more than once
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能重新定义同一个函数超过一次
- en: 'For the second limitation, this occurs by design, and so is expected and enforced
    by the ORC API itself:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个限制，这是按设计进行的，因此由ORC API本身预期并强制执行：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Keep in mind that there are numerous other possibilities to expose names, besides
    exposing the symbols for the current process or from a shared library. For example,
    the `StaticLibraryDefinitionGenerator` class exposes the symbols found in a static
    archive and can be used in the `DynamicLibrarySearchGenerator` class.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the `LLJIT` class has also an `addObjectFile()` method to expose
    the symbols of an object file. You can also provide your own `DefinitionGenerator`
    implementation if the existing implementations do not fit your needs.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, using the predefined `LLJIT` class is convenient, but it can
    limit our flexibility. In the next section, we’ll look at how to implement a JIT
    compiler using the layers provided by the ORC API.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Building a JIT compiler class from scratch
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the layered approach of ORC, it is very easy to build a JIT compiler customized
    for the requirements. There is no one-size-fits-all JIT compiler, and the first
    section of this chapter gave some examples. Let’s have a look at how to set up
    a JIT compiler from scratch.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: The ORC API uses layers that are stacked together. The lowest level is the object-linking
    layer, represented by the `llvm::orc::RTDyldObjectLinkingLayer` class. It is responsible
    for linking in-memory objects and turning them into executable code. The memory
    required for this task is managed by an instance of the `MemoryManager` interface.
    There is a default implementation, but we can also use a custom version if we
    need.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Above the object-linking layer is the compile layer, which is responsible for
    creating an in-memory object file. The `llvm::orc::IRCompileLayer` class takes
    an IR module as input and compiles it to an object file. The `IRCompileLayer`
    class is a subclass of the `IRLayer` class, which is a generic class for layer
    implementations accepting LLVM IR.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of these layers already form the core of a JIT compiler: they add an LLVM
    IR module as input, which is compiled and linked in memory. To add extra functionality,
    we can incorporate more layers on top of both layers.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `CompileOnDemandLayer` class splits a module so that only the
    requested functions are compiled. This can be used to implement lazy compilation.
    Moreover, the `CompileOnDemandLayer` class is also a subclass of the `IRLayer`
    class. In a very generic way, the `IRTransformLayer` class, also a subclass of
    the `IRLayer` class, allows us to apply a transformation to the module.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Another important class is the `ExecutionSession` class. This class represents
    a running JIT program. Essentially, this means that the class manages `JITDylib`
    symbol tables, provides lookup functionality for symbols, and keeps track of used
    resource managers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'The generic recipe for a JIT compiler is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Initialize an instance of the `ExecutionSession` class.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the layer, at least consisting of an `RTDyldObjectLinkingLayer` class
    and an `IRCompileLayer` class.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the first `JITDylib` symbol table, usually with `main` or a similar name.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第一个`JITDylib`符号表，通常使用`main`或类似名称。
- en: 'The general usage of the JIT compiler is also very straightforward:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: JIT编译器的一般用法也非常简单：
- en: Add an IR module to the symbol table.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将IR模块添加到符号表中。
- en: Look up a symbol, triggering the compilation of the associated function, and
    possibly the whole module.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找符号，触发相关函数的编译，以及可能整个模块的编译。
- en: Execute the function.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行函数。
- en: In the next subsection, we implement a JIT compiler class following the generic
    recipe.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将按照通用配方实现一个JIT编译器类。
- en: Creating a JIT compiler class
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建JIT编译器类
- en: 'To keep the implementation of the JIT compiler class simple, everything is
    placed in `JIT.h`, within a source directory we can create called `jit`. However,
    the initialization of the class is a bit more complex compared to using `LLJIT`.
    Due to handling possible errors, we need a factory method to create some objects
    upfront before we can call the constructor. The steps to create the class are
    as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持JIT编译器类的实现简单，所有内容都放置在`JIT.h`中，在一个可以创建的源目录`jit`内。然而，与使用`LLJIT`相比，类的初始化要复杂一些。由于处理可能的错误，我们需要一个工厂方法在调用构造函数之前预先创建一些对象。创建类的步骤如下：
- en: 'We begin with guarding the header file against multiple inclusion with the
    `JIT_H` preprocessor definition:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先使用`JIT_H`预处理器定义来保护头文件，防止多次包含：
- en: '[PRE43]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Firstly, a number of `include` files are required. Most of them provide a class
    with the same name as the header file. The `Core.h` header provides a couple of
    basic classes, including the `ExecutionSession` class. Additionally, the `ExecutionUtils.h`
    header provides the `DynamicLibrarySearchGenerator` class to search libraries
    for symbols. Furthermore, the `CompileUtils.h` header provides the `ConcurrentIRCompiler`
    class:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，需要一些`include`文件。其中大部分提供与头文件同名的类。`Core.h`头文件提供了一些基本类，包括`ExecutionSession`类。此外，`ExecutionUtils.h`头文件提供了`DynamicLibrarySearchGenerator`类来搜索库中的符号。此外，`CompileUtils.h`头文件提供了`ConcurrentIRCompiler`类：
- en: '[PRE44]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Declare a new class. Our new class will be called `JIT`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新的类。我们的新类将被称为`JIT`：
- en: '[PRE45]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The private data members reflect the ORC layers and some helper classes. The
    `ExecutionSession`, `ObjectLinkingLayer`, `CompileLayer`, `OptIRLayer`, and `MainJITDylib`
    instances represent the running JIT program, the layers, and the symbol table,
    as already described. Moreover, the `TargetProcessControl` instance is used for
    interaction with the JIT target process. This can be the same process, another
    process on the same machine, or a remote process on a different machine, possibly
    with a different architecture. The `DataLayout` and `MangleAndInterner` classes
    are required to mangle symbols’ names in the correct way. Additionally, the symbol
    names are internalized, which means that all equal names have the same address.
    This means that to check if two symbol names are equal, it is then sufficient
    to compare the addresses, which is a very fast operation:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私有数据成员反映了ORC层和一些辅助类。`ExecutionSession`、`ObjectLinkingLayer`、`CompileLayer`、`OptIRLayer`和`MainJITDylib`实例代表正在运行的JIT程序、层和符号表，如前所述。此外，`TargetProcessControl`实例用于与JIT目标进程交互。这可以是同一个进程，同一台机器上的另一个进程，或者不同机器上的远程进程，可能具有不同的架构。`DataLayout`和`MangleAndInterner`类用于以正确的方式混淆符号名称。此外，符号名称被内部化，这意味着所有相同名称的地址相同。这意味着要检查两个符号名称是否相等，只需比较地址即可，这是一个非常快速的操作：
- en: '[PRE46]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The initialization is split into three parts. In C++, a constructor cannot return
    an error. The simple and recommended solution is to create a static factory method
    that can do the error handling before constructing an object. The initialization
    of the layers is more complex, so we introduce factory methods for them, too.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化被分为三个部分。在C++中，构造函数不能返回错误。简单且推荐的方法是创建一个静态工厂方法，在构造对象之前进行错误处理。层的初始化更为复杂，因此我们也为它们引入了工厂方法。
- en: In the `create()` factory method, we first create a `SymbolStringPool` instance,
    which is used to implement string internalization and is shared by several classes.
    To take control of the current process, we create a `SelfTargetProcessControl`
    instance. If we want to target a different process, then we need to change this
    instance.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`create()`工厂方法中，我们首先创建一个`SymbolStringPool`实例，该实例用于实现字符串国际化，并被多个类共享。为了控制当前进程，我们创建一个`SelfTargetProcessControl`实例。如果我们想针对不同的进程，则需要更改这个实例。
- en: 'Next, we construct a `JITTargetMachineBuilder` instance, for which we need
    to know the target triple of the JIT process. Afterward, we query the target machine
    builder for the data layout. This step can fail if the builder is not able to
    instantiate the target machine based on the provided triple – for example, because
    support for this target is not compiled into the LLVM libraries:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们构建一个`JITTargetMachineBuilder`实例，我们需要知道JIT进程的目标三元组。之后，我们查询目标机器构建器以获取数据布局。如果构建器无法根据提供的三元组实例化目标机器，则此步骤可能会失败——例如，因为对该目标的支持没有编译到LLVM库中：
- en: '[PRE47]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'At this point, we have handled all calls that could potentially fail. We are
    now able to initialize the `ExecutionSession` instance. Finally, the constructor
    of the `JIT` class is called with all instantiated objects, and the result is
    returned to the caller:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经处理了所有可能失败的调用。现在我们可以初始化`ExecutionSession`实例。最后，调用`JIT`类的构造函数，传入所有实例化的对象，并将结果返回给调用者：
- en: '[PRE48]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The constructor of the `JIT` class moves the passed parameters to the private
    data members. Layer objects are constructed with a call to static factory names
    with the `create` prefix. Furthermore, each layer factory method requires a reference
    to the `ExecutionSession` instance, which connects the layer to the running JIT
    session. Except for the object-linking layer, which is at the bottom of the layer
    stack, each layer requires a reference to the previous layer, illustrating the
    stacking order:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JIT`类的构造函数将传入的参数移动到私有数据成员中。层对象通过调用具有`create`前缀的静态工厂名称来构建。此外，每个层工厂方法都需要对`ExecutionSession`实例的引用，这将层连接到正在运行的JIT会话。除了位于层堆栈底部的对象链接层之外，每个层都需要对前一个层的引用，说明了堆叠顺序：'
- en: '[PRE49]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the body of the constructor, we add a generator to search the current process
    for symbols. The `GetForCurrentProcess()` method is special, as the return value
    is wrapped in an `Expected<>` template, indicating that an `Error` object can
    also be returned. However, since we know that no error can occur, the current
    process will eventually run! Thus, we unwrap the result with the `cantFail()`
    function, which terminates the application if an error occurred anyway:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数的主体中，我们添加了一个生成器来搜索当前进程中的符号。`GetForCurrentProcess()`方法很特殊，因为返回值被包裹在一个`Expected<>`模板中，表示也可以返回一个`Error`对象。然而，由于我们知道不会发生错误，当前进程最终会运行！因此，我们使用`cantFail()`函数解包结果，如果确实发生了错误，则终止应用程序：
- en: '[PRE50]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To create an object-linking layer, we need to provide a memory manager. Here,
    we stick to the default `SectionMemoryManager` class, but we could also provide
    a different implementation if needed:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个对象链接层，我们需要提供一个内存管理器。在这里，我们坚持使用默认的`SectionMemoryManager`类，但如果需要，我们也可以提供不同的实现：
- en: '[PRE51]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'A slight complication exists for the **Common Object File Format** (**COFF**)
    object file format, which is used on Windows. This file format does not allow
    functions to be marked as exported. This subsequently leads to failures in checks
    inside the object-linking layer: flags stored in the symbol are compared with
    the flags from IR, which leads to a mismatch because of the missing export marker.
    The solution is to override the flags only for this file format. This finishes
    the construction of the object layer, and the object is returned to the caller:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于在Windows上使用的**通用对象文件格式**（**COFF**）对象文件格式，存在一个轻微的复杂性。此文件格式不允许将函数标记为导出。这随后导致对象链接层内部的检查失败：存储在符号中的标志与IR中的标志进行比较，由于缺少导出标记，导致不匹配。解决方案是为此文件格式覆盖标志。这完成了对象层的构建，并将对象返回给调用者：
- en: '[PRE52]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To initialize the compiler layer, an `IRCompiler` instance is required. The
    `IRCompiler` instance is responsible for compiling an IR module into an object
    file. If our JIT compiler does not use threads, then we can use the `SimpleCompiler`
    class, which compiles the IR module using a given target machine. The `TargetMachine`
    class is not threadsafe, and therefore the `SimpleCompiler` class is not, either.
    To support compilation with multiple threads, we use the `ConcurrentIRCompiler`
    class, which creates a new `TargetMachine` instance for each module to compile.
    This approach solves the problem with multiple threads:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要初始化编译器层，需要一个`IRCompiler`实例。`IRCompiler`实例负责将IR模块编译成对象文件。如果我们的JIT编译器不使用线程，则可以使用`SimpleCompiler`类，该类使用给定的目标机器编译IR模块。`TargetMachine`类不是线程安全的，因此`SimpleCompiler`类也不是。为了支持多线程编译，我们使用`ConcurrentIRCompiler`类，为每个要编译的模块创建一个新的`TargetMachine`实例。这种方法解决了多线程的问题：
- en: '[PRE53]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Instead of compiling the IR module directly to machine code, we install a layer
    that optimizes the IR first. This is a deliberate design decision: we turn our
    JIT compiler into an optimizing JIT compiler, which produces faster code that
    takes longer to produce, meaning a delay for the user. We do not add lazy compilation,
    so whole modules are compiled when just a symbol is looked up. This can add up
    to a significant amount of time before the user sees the code executing.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不是直接将 IR 模块编译成机器代码，而是安装一个先优化 IR 的层。这是一个故意的决策：我们将我们的 JIT 编译器转变为一个优化 JIT 编译器，它产生的代码更快，但生成代码所需的时间更长，这意味着对用户来说会有延迟。我们没有添加懒编译，所以当查找符号时，整个模块都会被编译。这可能会在用户看到代码执行之前增加相当长的时间。
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Introducing lazy compilation is not a proper solution in all circumstances.
    Lazy compilation is realized by moving each function into a module of its own,
    which is compiled when the function name is looked up. This prevents inter-procedural
    optimizations such as *inlining* because the inliner pass needs access to the
    body of called functions to inline them. As a result, users see a faster startup
    with lazy compilation, but the produced code is not as optimal as it can be. These
    design decisions depend on the intended use. Here, we decide on fast code, accepting
    a slower startup time. Furthermore, this means that the optimization layer is
    essentially a transformation layer.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下引入懒编译都不是一个合适的解决方案。懒编译是通过将每个函数移动到它自己的模块中实现的，当查找函数名时进行编译。这防止了诸如 *内联* 这样的跨程序优化，因为内联器需要访问被调用函数的体来内联它们。因此，用户会看到懒编译时的启动速度更快，但产生的代码并不像可能的那样优化。这些设计决策取决于预期的用途。在这里，我们决定要快速代码，接受较慢的启动时间。此外，这意味着优化层本质上是一个转换层。
- en: 'The `IRTransformLayer` class delegates the transformation to a function – in
    our case, to the `optimizeModule` function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`IRTransformLayer` 类将转换委托给一个函数——在我们的例子中，是 `optimizeModule` 函数：'
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `optimizeModule()` function is an example of a transformation on an IR
    module. The function gets the module to transform as a parameter and returns the
    transformed version of the IR module. Since the JIT compiler can potentially run
    with multiple threads, the IR module is wrapped in a `ThreadSafeModule` instance:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`optimizeModule()` 函数是一个对 IR 模块进行转换的例子。该函数获取一个模块作为参数，并返回 IR 模块的转换版本。由于 JIT
    编译器可能以多线程方式运行，IR 模块被包装在一个 `ThreadSafeModule` 实例中：'
- en: '[PRE55]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To optimize the IR, we recall some information from [*Chapter 7*](B19561_07.xhtml#_idTextAnchor117),
    *Optimizing IR*, in the *Adding an optimization pipeline to your compiler* section.
    We need a `PassBuilder` instance to create an optimization pipeline. First, we
    define a couple of analysis managers and register them afterward at the pass builder.
    Afterward, we populate a `ModulePassManager` instance with the default optimization
    pipeline for the `O2` level. This is again a design decision: the `O2` level produces
    already fast machine code, but it produces even faster code at the `O3` level.
    Next, we run the pipeline on the module, and finally, the optimized module is
    returned to the caller:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了优化 IR，我们回顾了在 *添加优化管道到您的编译器* 部分的 *第 7 章* 中的一些信息，*优化 IR*。我们需要一个 `PassBuilder`
    实例来创建一个优化管道。首先，我们定义了一对分析管理器，并在之后在管道构建器中注册它们。之后，我们使用 `O2` 级别的默认优化管道填充一个 `ModulePassManager`
    实例。这又是一个设计决策：`O2` 级别已经产生了快速的机器代码，但在 `O3` 级别会产生更快代码。接下来，我们在模块上运行管道，最后，将优化后的模块返回给调用者：
- en: '[PRE56]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The client of the `JIT` class needs a way to add an IR module, which we provide
    with the `addIRModule()` function. Recall the layer stack we created: we must
    add the IR module to the top layer; otherwise, we would accidentally bypass some
    of the layers. This would be a programming error that is not easily spotted: if
    the `OptIRLayer` member is replaced by the `CompileLayer` member, then our `JIT`
    class still works, but not as an optimizing JIT because we have bypassed this
    layer. This is no concern for this small implementation, but in a large JIT optimization,
    we would introduce a function to return the top-level layer:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JIT` 类的客户端需要一个方法来添加一个 IR 模块，我们通过 `addIRModule()` 函数提供这个功能。回想一下我们创建的层栈：我们必须将
    IR 模块添加到顶层；否则，我们可能会意外地跳过一些层。这将是一个不易发现的编程错误：如果将 `OptIRLayer` 成员替换为 `CompileLayer`
    成员，那么我们的 `JIT` 类仍然可以工作，但不再是一个优化 JIT，因为我们跳过了这个层。对于这个小实现来说，这不是一个问题，但在大型 JIT 优化中，我们会引入一个函数来返回顶层层：'
- en: '[PRE57]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Likewise, a client of our JIT class needs a way to look up a symbol. We delegate
    this to the `ExecutionSession` instance, passing in a reference to the main symbol
    table and the mangled and internalized name of the requested symbol:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们的 JIT 类的客户端需要一个查找符号的方法。我们将此委托给 `ExecutionSession` 实例，传递对主符号表的引用以及请求的符号的混淆和内部化名称：
- en: '[PRE58]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As we can see, the initialization of this JIT class can be tricky, as it involves
    a factory method and a constructor call for the `JIT` class, and factory methods
    for each layer. Although this distribution is caused by limitations in C++, the
    code itself is straightforward.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，此 JIT 类的初始化可能很棘手，因为它涉及 `JIT` 类的工厂方法和构造函数调用，以及每一层的工厂方法。尽管这种分布是由 C++ 的限制造成的，但代码本身是直接的。
- en: Next, we are going to use the new JIT compiler class to implement a simple command-line
    utility that takes an LLVM IR file as input.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用新的 JIT 编译器类来实现一个简单的命令行实用程序，该实用程序接受 LLVM IR 文件作为输入。
- en: Using our new JIT compiler class
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用我们新的 JIT 编译器类
- en: 'We start off by creating a file called `JIT.cpp`, in the same directory as
    the `JIT.h` file, and add the following to this source file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为 `JIT.cpp` 的文件，与 `JIT.h` 文件位于同一目录下，并将以下内容添加到这个源文件中：
- en: 'Firstly, several header files are included. We must include `JIT.h` to use
    our new class, and the `IRReader.h` header because it defines a function to read
    LLVM IR files. The `CommandLine.h` header allows us to parse the command-line
    options in the LLVM style. Next, `InitLLVM.h` is needed for the basic initialization
    of the tool. Finally, `TargetSelect.h` is needed for the initialization of the
    native target:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，包含几个头文件。我们必须包含 `JIT.h` 以使用我们的新类，以及 `IRReader.h` 头文件，因为它定义了一个用于读取 LLVM IR
    文件的功能。`CommandLine.h` 头文件允许我们以 LLVM 风格解析命令行选项。接下来，需要 `InitLLVM.h` 以进行工具的基本初始化。最后，需要
    `TargetSelect.h` 以进行本地目标的初始化：
- en: '[PRE59]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, we add the `llvm` namespace to the current scope:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将 `llvm` 命名空间添加到当前作用域中：
- en: '[PRE60]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Our JIT tool expects exactly one input file on the command line, which we declare
    with the `cl::opt<>` class:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 JIT 工具期望命令行上恰好有一个输入文件，我们使用 `cl::opt<>` 类声明它：
- en: '[PRE61]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To read the IR file, we call the `parseIRFile()` function. The file can be
    a textual IR representation or a bitcode file. The function returns a pointer
    to the created module. Additionally, the error handling is a bit different, because
    a textual IR file can be parsed, which is not necessarily syntactically correct.
    Finally, the `SMDiagnostic` instance holds the error information in case of a
    syntax error. In the event of an error, an error message is printed, and the application
    is exited:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要读取 IR 文件，我们调用 `parseIRFile()` 函数。文件可以是文本 IR 表示或位代码文件。该函数返回创建的模块的指针。此外，错误处理略有不同，因为文本
    IR 文件可以解析，这并不一定是语法正确的。最后，`SMDiagnostic` 实例在出现语法错误时持有错误信息。在发生错误的情况下，将打印错误信息，并退出应用程序：
- en: '[PRE62]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `jitmain()` function is placed after the `loadModule()` method. This function
    sets up our JIT engine and compiles an LLVM IR module. The function needs the
    LLVM module with the IR to execute. The LLVM context class is also required for
    this module because the context class contains important type information. The
    goal is to call the `main()` function, so we also pass the usual `argc` and `argv`
    parameters:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`jitmain()` 函数放置在 `loadModule()` 方法之后。此函数设置我们的 JIT 引擎并编译一个 LLVM IR 模块。该函数需要执行所需的
    LLVM 模块和 IR。此模块还需要 LLVM 上下文类，因为上下文类包含重要的类型信息。目标是调用 `main()` 函数，因此我们还传递了常用的 `argc`
    和 `argv` 参数：'
- en: '[PRE63]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, we create an instance of our JIT class that we constructed earlier. If
    an error occurs, then we return an error message accordingly:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们之前构建的 JIT 类的实例。如果发生错误，则相应地返回错误信息：
- en: '[PRE64]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, we add the module to the main `JITDylib` instance, wrapping the module
    and a context in a `ThreadSafeModule` instance yet again. If an error occurs,
    then we return an error message:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将模块添加到主 `JITDylib` 实例中，再次将模块和上下文包装在 `ThreadSafeModule` 实例中。如果发生错误，则返回错误信息：
- en: '[PRE65]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Following this, we look up the `main` symbol. This symbol must be in the IR
    module given on the command line. The lookup triggers the compilation of that
    IR module. If other symbols are referenced inside the IR module, then they are
    resolved using the generator added in the previous step. The result is of the
    `ExecutorAddr` class, where it represents the address of the executor process:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此后，我们查找 `main` 符号。此符号必须在命令行上给出的 IR 模块中。查找触发该 IR 模块的编译。如果 IR 模块内部引用了其他符号，则它们将使用之前步骤中添加的生成器进行解析。结果是
    `ExecutorAddr` 类，它表示执行进程的地址：
- en: '[PRE66]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, we can call the `main()` function in the IR module, and pass the `argc`
    and `argv` parameters that the function expects. We ignore the return value:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 IR 模块中调用 `main()` 函数，并传递函数期望的 `argc` 和 `argv` 参数。我们忽略返回值：
- en: '[PRE67]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We report success after the execution of the function:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数执行后，我们报告成功：
- en: '[PRE68]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'After implementing a `jitmain()` function, we add a `main()` function, which
    initializes the tool and the native target and parses the command line:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现了一个 `jitmain()` 函数之后，我们添加一个 `main()` 函数，该函数初始化工具和本地目标，并解析命令行：
- en: '[PRE69]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Afterward, the LLVM context class is initialized, and we load the IR module
    named on the command line:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，初始化了 LLVM 上下文类，并加载了命令行上指定的 IR 模块：
- en: '[PRE70]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'After loading the IR module, we can call the `jitmain()` function. To handle
    errors, we use the `ExitOnError` utility class to print an error message and exit
    the application when an error is encountered. We also set a banner with the name
    of the application, which is printed before the error message:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载 IR 模块后，我们可以调用 `jitmain()` 函数。为了处理错误，我们使用 `ExitOnError` 实用类在遇到错误时打印错误消息并退出应用程序。我们还设置了一个带有应用程序名称的横幅，该横幅在错误消息之前打印：
- en: '[PRE71]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If the control flow reaches this point, then the IR was successfully executed.
    We return `0` to indicate success:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果控制流到达这一点，则表示 IR 已成功执行。我们返回 `0` 以指示成功：
- en: '[PRE72]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We can now test our newly implemented JIT compiler by compiling a simple example
    that prints `Hello World!` to the console. Under the hood, the new class uses
    a fixed optimization level, so with large enough modules, we can note differences
    in the startup and runtime.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过编译一个简单的示例来测试我们新实现的 JIT 编译器，该示例将 `Hello World!` 打印到控制台。在底层，新类使用固定的优化级别，因此对于足够大的模块，我们可以注意到启动和运行时的差异。
- en: 'To build our JIT compiler, we can follow the same CMake steps as we did near
    the end of the *Implementing our own JIT compiler with LLJIT* section, and we
    just need to ensure that the `JIT.cpp` source file is being compiled with the
    correct libraries to link against:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们的 JIT 编译器，我们可以遵循与在 *使用 LLJIT 实现自己的 JIT 编译器* 部分接近结尾时相同的 CMake 步骤，我们只需确保
    `JIT.cpp` 源文件正在使用正确的库进行编译以进行链接：
- en: '[PRE73]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We then change into the `build` directory and compile the application:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们切换到 `build` 目录并编译应用程序：
- en: '[PRE74]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Our `JIT` tool is now ready to be used. A simple `Hello World!` program can
    be written in C, like the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `JIT` 工具现在可以使用了。可以像以下这样用 C 编写一个简单的 `Hello World!` 程序：
- en: '[PRE75]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, we can compile the Hello World C source into LLVM IR with the following
    command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用以下命令将 Hello World C 源代码编译成 LLVM IR：
- en: '[PRE76]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Remember – we compile the C source into LLVM IR because our JIT compiler accepts
    an IR file as input. Finally, we can invoke our JIT compiler with our IR example,
    as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 – 我们将 C 源代码编译成 LLVM IR，因为我们的 JIT 编译器接受 IR 文件作为输入。最后，我们可以使用以下方式调用我们的 JIT 编译器：
- en: '[PRE77]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to develop a JIT compiler. You began with learning
    about the possible applications of JIT compilers, and you explored `lli`, the
    LLVM dynamic compiler and interpreter. Using the predefined `LLJIT` class, you
    built an interactive JIT-based calculator tool and learned about looking up symbols
    and adding IR modules to `LLJIT`. To be able to take advantage of the layered
    structure of the ORC API, you also implemented an optimizing `JIT` class.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何开发 JIT 编译器。你从了解 JIT 编译器的可能应用开始，并探索了 `lli`，LLVM 的动态编译器和解释器。使用预定义的
    `LLJIT` 类，你构建了一个基于 JIT 的交互式计算器工具，并学习了查找符号和将 IR 模块添加到 `LLJIT` 中。为了能够利用 ORC API
    的分层结构，你还实现了一个优化的 `JIT` 类。
- en: In the next chapter, you will learn how to utilize LLVM tools for debugging
    purposes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何利用 LLVM 工具进行调试。
