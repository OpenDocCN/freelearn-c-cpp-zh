- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes – Building Blocks of C++ Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Classes** in C++ are means of organizing code into logical units. They allow
    us to structure data and functions that perform operations on that data in blueprints.
    These blueprints can be used to build instances of the classes, known as **objects**.
    We can initialize objects with data, manipulate them by calling functions or methods
    on them, store them in containers, or pass their references to objects of other
    classes to make the interaction between different parts of a system.'
  prefs: []
  type: TYPE_NORMAL
- en: Classes are the basic building blocks of C++ applications. They help us organize
    code in units with isolated responsibility reflecting dependencies and interactions
    with other parts of the system. They can be combined or extended, allowing us
    to reuse their functionality and add additional capabilities. We use them to make
    abstractions of different parts of an embedded system, including low-level components
    such as **Universal Asynchronous Receiver/Transmitter** (**UART**) drivers and
    libraries or business logic components such as a cellular modem library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this chapter is to delve into C++ classes and learn how we can
    use them to write better code. In this chapter, we’re going to cover the following
    main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage duration and initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance and dynamic polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler and target x86 architecture. This will allow you to
    see standard output (stdio) results and better observe the code’s behavior. As
    we are using a lot of modern C++ features make sure to select C++23 standard,
    by adding `-std=c++23` in compiler options box.
  prefs: []
  type: TYPE_NORMAL
- en: The examples from this chapter are available on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter05)](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter05)).
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Encapsulation** is a programming concept that organizes code into units that
    contain both data and functions that operate on that data. It is not strictly
    related to **Object-Oriented Programming** (**OOP**) and is often used in other
    programming paradigms. Encapsulation allows us to decouple code into units with
    single responsibilities, making the code easier to reason about, improving readability,
    and facilitating maintenance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of OOP, encapsulation can also refer to hiding an object’s members
    or restricting access to these members from the outside. In C++, this can be achieved
    using access specifiers. C++ has the following specifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: Public
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public** and **private** are the most commonly used specifiers. They give
    us the ability to control the interface of the class, that is, to control which
    class members are available to the users of a class. The following example demonstrates
    how to define a class with public and private access sections, demonstrating the
    concept of encapsulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `uart` class has public and private access sections. Let’s
    go through the code step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: The `public` section includes a constructor that initializes the `baudrate_`
    private member variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also have an `init` method in the public section, in which we write a value
    to a **Bit Rate Register** (**BRR**), which is specific to the STM32 platform,
    using the `write_brr` private method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value written to the BRR register is calculated in the `calculate_uartdiv`
    private method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, methods with a public access specifier within the `uart` class
    can use private member variables and methods. However, if we tried to use `write_brr`
    on the `uart1` object, as in `uart1.write_brr(5)`, the compilation of the program
    would fail.
  prefs: []
  type: TYPE_NORMAL
- en: The private access specifier allows us to hide methods and data from the user
    of our class (in this case, the `main` function). This helps us define a clear
    interface for our classes in C++. By controlling which methods a user of the class
    can use, we are not only protecting the class but also the user from unwanted
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: This example serves the purpose of explaining access specifiers in C++, but
    let’s also use it to explain the `init` method. Why do we need it if we have a
    constructor?
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of `init` is to allow us to fully control the initialization of
    hardware. The object may also be constructed as a global or static variable. The
    initialization of static and global objects is done before reaching the `main`
    function and initializing hardware. That is why some kind of `init` method is
    common in classes in embedded projects. Using it, we can ensure that all hardware
    peripherals are initialized in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default access specifier for classes in C++ is private, so we could write
    the definition of the `uart` class from the previous example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We chose to explicitly define the private access section. We put it after the
    `public` section, as publicly accessible members are the interface for our class,
    and when you read code and a class definition, the first thing you want to see
    is the interface. You want to see how to interact with the class and which methods
    are part of the public interface that you can use.
  prefs: []
  type: TYPE_NORMAL
- en: The only data member we have in this example is `baudrate_`. It is private,
    and the only option for a user of the `uart` class to set it up is through the
    constructor. It is a common practice for data members that we want to expose to
    the public to define setter and getter methods.
  prefs: []
  type: TYPE_NORMAL
- en: Setters and getters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `uart` class, we could define setters and getters for `baudrate_` members
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this would allow us to set and get the `baudrate` value from the public
    interface, but these trivial setters and getters do not add any value to our interface.
    They are just exposing the `baudrate_` member. It would be the same as if we put
    it under the public access specifier. Setters and getters should serve a clear
    purpose. For example, a setter can include validation logic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the modified setter, we are making a sanity check of the value to be set
    and setting the private member only if it makes sense to do so, else setting it
    to the maximum baudrate (`c_max_baudrate`) supported in our system. This is just
    an example; it probably doesn’t make sense to change the baudrate after the UART
    initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing data members through setters and getters in some sense breaks encapsulation.
    The idea of encapsulation is to hide the implementation details, and data members
    are implementation details. Therefore, setters and especially getters should be
    used sparingly and only when they serve a meaningful purpose.
  prefs: []
  type: TYPE_NORMAL
- en: We can use classes in C++ to encapsulate only functionality, without data, or
    data that is commonly shared with all users of a class. For that, we can use static
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Static methods** are C++ methods declared with static keywords, and they
    are accessible without object instantiation. In the `uart` class example, besides
    the constructor, we have the `init` method, which is part of the public interface.
    We use it by calling this method on an object we previously created using a single
    argument constructor by providing it with the baudrate. We could also design the
    `uart` class as a type that has all static methods and use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we removed the single argument constructor and declared all
    methods as static. We also removed the `baudrate_` private data member and passed
    it directly from the `init` method to the `calculate_uartdiv` method. We now have
    a type that we can use without object instantiation. We call the `init` method
    by using the class name followed by a double colon and the method name, as shown
    in the `main` function. It is worth noting that static methods can only use static
    data members and other static functions from a class as non-static members require
    the instantiation of an object.
  prefs: []
  type: TYPE_NORMAL
- en: We can group functions in C++ in a common *unit* by using namespaces. However,
    grouping them into a type is useful as we can pass types as template arguments.
    We will discuss namespaces and templates later in this book to better understand
    the benefits of this approach. Namespaces will be discussed in [*Chapter 6*](Chapter_06.xhtml)
    and templates in [*Chapter 8*](Chapter_08.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: In C++, we can also use the struct keyword to define a type. The default access
    for struct members is public. Historically, structs were used for compatibility
    with C, so one could write a header file for a library that is used in both C
    and C++ programs. In this case, the struct we would share between C and C++ programs
    could only have common data types and couldn’t have methods as members.
  prefs: []
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Structs** are commonly used in C++ for types that only have data members
    that we want to make publicly available to users. They are mostly identical to
    classes, with a difference being in the default access level, which is public
    for structs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a struct that only has data members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`accelerometer_data` could be produced by a `sensor` class, stored in a `ring_buffer`
    class, and consumed by a `sensor_fusion` class. The members of the `accelerometer_data`
    class are values from the `x`, `y`, and `z` axes, and they are publicly available
    to users of this class.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we use the `accelerometer_data` struct only as a data holder,
    and we implement the behavior related to this data in other places. This is just
    an example. Structuring data in simple structs versus using classes with data
    and complex behavior is a design choice and it depends on the exact application.
  prefs: []
  type: TYPE_NORMAL
- en: Structs are also used to group functions into types. They are usually all declared
    as static and made publicly available to users. Using a struct instead of a class
    is convenient in this use case as the default access specifier is public and it
    also reflects our intent as a struct is usually used when all members are made
    public.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the public and private access specifiers, there is also the **protected
    specifier** in C++. The protected specifier is related to inheritance and will
    be explained later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now move on to constructors and the initialization of variables and objects
    in C++. Object initialization is an important task and failing to do it properly
    can cause problems in programs. We will discuss different options for object initialization
    and analyze potential pitfalls and how to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Storage duration and initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ objects with automatic storage duration are initialized upon declaration
    and destroyed when exiting the variable scope. Objects can also have a static
    storage duration. Data members of objects can also have static storage specifiers,
    and there are rules for the initialization of such members. We will first go through
    non-static member initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Non-static member initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different ways to initialize non-static class members. The first thing
    that comes to mind when we discuss initialization and C++ is constructors. While
    constructors are powerful C++ features that allow us to have great control over
    the initialization, let us start with **default member initializers**.
  prefs: []
  type: TYPE_NORMAL
- en: Default member initializers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As of C++11, it is possible to set a default value for a member directly in
    a class definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This simple code snippet would fail to compile if we were to compile it with
    any pre-C++11 standard. The default member initializers allow us to set a default
    value for class members in a class definition, which improves readability and
    saves us from setting the same member variable if we have multiple constructors.
    This is particularly useful for setting default values for pointers.
  prefs: []
  type: TYPE_NORMAL
- en: If we didn’t use the default initializer for `ptr`, it would be loaded with
    some random value from memory. Dereferencing such a pointer would result in reading
    from or writing to a random location, potentially leading to a serious fault.
    This hypothetical situation would be detected by a compiler or a static analyzer
    as they would report the usage of an uninitialized value, which is undefined behavior.
    Still, this shows the importance of initializing member variables with default
    values, and a default member initializer is an option for this task.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and member initializer lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Constructors are nameless methods in class definition that can’t be called
    explicitly. They are invoked upon the object initialization. A constructor that
    can be invoked with no arguments is called the default constructor. We already
    saw one in the `uart` class example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Even though this constructor has a parameter, we used the default argument that
    will be provided to the constructor if it is called with no arguments. If no argument
    is provided at the call site, the default value of `9600` will be used for the
    `baud` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the following syntax when we want to use the default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is also called **default initialization**, and it is performed when the
    object is declared with no initializer. Please note that there are no parentheses
    as this would cause syntax ambiguity and would be interpreted by the compiler
    as a function declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line would be interpreted by the compiler as the declaration of
    a function named `uart1` that returns the object of the `uart` class and accepts
    no arguments. This is the reason we are not using parentheses when using the default
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'As our `uart` class constructor can also accept an argument, we can use direct
    initialization syntax and provide the constructor with an argument, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will call the `uart` class constructor and provide it with a value of
    `115200` for the `baud` argument. While we have explained nuances related to the
    syntax of the default constructor, we still need to explain the initialization
    of the `baudrate_` member variable. In this case, we are using the member initializer
    list. It is specified after the colon character and before the opening brace of
    the compound statement as `baudrate_(baud)`. In our case, we have only one item
    in the member initializer list; if there are more, they are delimited with a comma,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are initializing a reference to `uart` and the `read_interval_`
    unsigned integer in the member initializer list in the `sensor` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to notice is the reference to an object of the `uart` class.
    References in C++ are similar to pointers in C; that is, they point to an already-created
    object. However, they need to be initialized when declared and they can’t be reassigned
    to point to another object. References and `const`-qualified members must be initialized
    using a member initializer list.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors can have no or many parameters. If a constructor has one parameter
    and is declared without the **explicit specifier**, it is called a converting
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Converting constructors and explicit specifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Converting constructors** allow the compiler to make an implicit conversion
    from the type of its argument to the type of its class. To better understand this,
    let’s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting part of this example is the call to the `uart_consumer` function
    with the `115200` argument. The `uart_consumer` function expects the object of
    the `uart` class as an argument, but due to rules of implicit conversion and the
    existing converting constructor, the compiler constructs an object of the `uart`
    class using `115200` as an argument, resulting in the following output of the
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Implicit conversion can be unsafe, and it is often unwanted. To prevent it,
    we can declare a constructor using an explicit specifier, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling the preceding example with an explicit constructor will result in
    a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: By declaring a constructor as explicit, we can be sure that no user of our class
    will create a situation with potential implicit conversion, which may lead to
    unwanted behavior in our program. But what if we want to prevent calls to our
    constructor using the float type? It may not be a good example, but you can imagine
    a constructor expecting a `uint8_t` type and someone calling it with a `uint32_t`
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can delete specific constructors, which will result in failed compilation.
    We can do it using the following syntax in the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the constructor with a float type will result in the following compile
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use brace list initialization, which narrows down the conversion
    and prevents the float-to-integer conversion. We can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This call would result in the following compile error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The list initialization limits the implicit conversion and helps with detecting
    problems at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Class data members can be declared using the `static` keyword, and there are
    special rules for initializing them.
  prefs: []
  type: TYPE_NORMAL
- en: Static member initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Static members are not tied to the objects of a class or struct. They are variables
    with static storage duration, and they can be accessed by any object of a class.
    Let’s go through a simple example to better understand static members and how
    we initialize them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a simple `object_counter` struct. The struct has one
    static data member, the `cnt` integer. In the constructor, we are incrementing
    this counter variable, and in the destructor, we are decrementing it. In the `main`
    function, we are creating three `object_counter` objects in an unnamed scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the program flow exits the unnamed scope, destructors will be called.
    We are printing the number of existing objects both inside the scope and after
    leaving it. Inside the unnamed scope, the `cnt` value should be equal to `3`,
    as we created three objects, and when we exit it, and destructors decrement the
    `cnt` variable, it should be `0`. The following is the output of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that the behavior of the `cnt` static variable is as we predicted.
    In this case, we declared a static variable in the class declaration, but we defined
    it using the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With the C++17 standard, it is possible to declare a static variable using
    an `inline` specifier inside the struct (or class) definition and provide it with
    the initializer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This makes the code more concise, easier to use as we don’t need to define the
    variable outside the class definition, and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: We covered the basics of classes in C++, including access specifiers, initializing
    methods, and constructors. Now, we will see how we can reuse classes using inheritance
    and dynamic polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and dynamic polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++, we can expand the functionality of a class without modifying it with
    inheritance. Inheritance is an example of establishing a hierarchical relationship
    between classes; for example, `ADXL345` is an accelerometer. Let us go through
    a trivial example that demonstrates inheritance in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `class B` inherits private and protected members from `class
    A`. `class A` is the base class, and `class B` is derived from it. The derived
    class has access to public and protected members of the base class. In the `main`
    function, we create an object of `class B`, and we call the `method_1`, `method_2`,
    and `method_3` methods. The output of this part of the code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the first line of the `main` function, we see that the call to the `method_1`
    function on object `b` executes `method_1` defined in `class B` even though it
    is derived from `class A`, and `class A` has also defined `method_1`. This is
    called **static binding** as the decision to call `method_1` is defined in `class
    A` and is made by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: An object of the derived `class B` contains an object of the base `class A`.
    If we call `method_2` on object `b`, the compiler will find no definition in `class
    B`, but as class `B` inherits from class `A`, the compiler will call `method_2`
    on object `a`, which is a part of object `b`.
  prefs: []
  type: TYPE_NORMAL
- en: In `method_3`, we see that we can call methods of the base class from the derived
    class. We can also see that we can call protected methods of the base class. This
    is one of the use cases of private access specifiers; it allows access to derived
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can assign the object of the derived class to a reference of the base class.
    We could also do the same for a pointer. Here is the result of calls of methods
    made on the reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Calling `method_1` on a reference of the base class will result in a call to
    `method_1` defined in `class A`. This is another instance of static binding in
    action. But what if we wanted that a call on a base class reference or pointer
    to result in executing a function on the derived class? And why would we want
    this? Let’s first address the *how*. C++ provides a mechanism of dynamic binding
    through virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our example, we assign a reference of type `A&` to an object of `class B`.
    If we want calls to `method_1` on this reference (`A& a`) to execute the `method_1`
    function defined in `class B`, we can declare `method_1` as a virtual function
    in `class A`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the call to `method_1` on the reference of `class A`, bound to the object
    of `class B`, will result in a call to `method_1` defined in `class B`, as we
    can see in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see the output of the `method_1` call matches the definition of this
    method from `class B`. We say that `class B` is overriding `method_1` from `class
    A`, and there is a special notion for this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The **override** keyword makes the compiler aware of our intention of overriding
    a virtual method from the base class. If the method we are overriding is not declared
    virtual, the compiler will raise an error.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual functions in C++ are usually implemented using virtual tables. This
    is the work that a compiler does for us. It creates a virtual table that stores
    pointers for every virtual function, which points to the overridden implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual function implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every class that overrides a virtual function has a virtual table. You can
    think of it as a hidden table of function pointers. Every object of a class has
    a pointer to this table. This pointer is used at runtime to access a table and
    find the correct function to be called on the object. Let us slightly modify our
    `class A` and `class B` to better understand this. The following is the code of
    the modified `class A` and `class B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We modified `class A` and `class B` so that `class A` has two virtual methods,
    `method_1` and `method_2`. `class B` only overrides `method_2`. The compiler will
    generate a virtual table for `class B` and a pointer that every object of `class
    B` will hold. The virtual pointer points to the generated virtual table.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be visualized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Virtual table](img/B22402_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Virtual table
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.1* depicts a possible implementation of virtual functions in C++
    using virtual tables and virtual pointers. If we call `method_2` on a reference
    to an object of `class B`, it will follow the virtual pointer to the virtual table
    and select the function pointer that points to the implementation of `method_2`
    in `class B`, that is, the overridden virtual function. This mechanism happens
    at runtime. There is a layer of indirection to get to the overridden function,
    which results in space and time overhead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++, we can define a virtual function to be a pure virtual function. If
    a class has a pure virtual function, it is called an **abstract class**, and it
    can’t be instantiated. Derived classes must override pure virtual functions, or
    they are also abstract classes. Let’s go through the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This program will fail to compile as `class B` didn’t override the `method_1`
    virtual method from `class A`. Abstract classes shift the responsibility of the
    implementation of certain behaviors (methods) to derived classes. Classes that
    have all virtual methods are called interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance defines a hierarchical relationship between classes, and we can
    say that `class B` is `class A,` just as a cat is an animal. We can represent
    this relationship in a **Unified Modeling Language** (**UML**) diagram.
  prefs: []
  type: TYPE_NORMAL
- en: UML class diagrams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'UML diagrams are used to describe software components. If they describe the
    relationship between classes, they are called UML class diagrams. One such diagram
    is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – UML diagram of class A and class B’s relationship](img/B22402_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – UML diagram of class A and class B’s relationship
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.2* depicts a UML class diagram visualizing the hierarchical relationship
    between `A` and `B`. The line connecting `B` and `A` with a hollow, unfilled triangular
    arrowhead pointing to `A` means `B` is `A`. This UML diagram also shows methods
    available in both classes.'
  prefs: []
  type: TYPE_NORMAL
- en: UML diagrams are useful for describing design patterns, and we will use them
    in this book to help us visualize the relationship between software components
    in code examples.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned what inheritance is and how we can use it with virtual functions
    to achieve dynamic binding. Let’s get back to the question of why we need these
    mechanisms and how we can use them to create better software. The mechanisms we
    learned in this chapter provide the means for dynamic (runtime) polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Polymorphism** is a mechanism that enables a single interface for different
    types. It can be static or dynamic. Dynamic polymorphism in C++ is achieved through
    inheritance and virtual functions. This type of polymorphism is also called **subtyping**,
    as it treats subtypes or derived classes through the interface based on the base
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism allows us to use a single interface for different implementations.
    Let us go through an example of the library for GSM modems. GSM modems usually
    communicate with the host microcontroller through the UART interface. A microcontroller
    may have multiple UART peripherals, such as UART and **Low-Power Universal Asynchronous
    Receiver/Transmitter** (**LPUART**) on STM32\. We may also want to use the library
    on different microcontrollers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a common interface for different UART implementations on different
    platforms and use this interface in our GSM library. An implementation of UART
    will be provided by the platform on which we use the GSM library, and it will
    implement the common UART interface. We can use a UML class diagram to visualize
    our library design, as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – UML diagram of GSM library and UART interface](img/B22402_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – UML diagram of GSM library and UART interface
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5**.3*, we see the relationship between the `gsm_lib`, `uart`, and
    `uart_stm32` classes. GSM library functionality is implemented in the `gsm_lib`
    class, which uses the `uart` interface. The `uart` interface is implemented by
    the `uart_stm32` class. The functionality of the GSM library is complex, but let’s
    go through a very simplified code example just to demonstrate the relationship
    between these three classes and how they work together. The following is a simplified
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, we see that the `uart` class has two pure virtual functions,
    which makes it an interface class. This interface is inherited and implemented
    by the `uart_stm32` class. In the `main` function, we create an object of the
    `uart_stm32` class, whose reference is passed to the constructor of the `gsm_lib`
    class, where it is used to initialize a private member reference to the `uart`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this program in a simulator environment, which we covered in
    the previous chapter. It is available in the `Chapter05/gsm_lib` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The design of the GSM library using the UART interface allows us to have a flexible
    library that we can use on different platforms. This design also allows us to
    debug the communication between the library and GSM modem by providing it with
    a UART implementation that will serve as a tap, redirecting reads and writes and
    simultaneously logging them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of classes in C++. We learned about member
    access specifiers, different ways of initializing objects, and inheritance. We
    also got to know virtual functions in more detail and learned how to use them
    for dynamic polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk more about other basic concepts in C++, such
    as namespaces, function overloading, and the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_code_Discord1.png)'
  prefs: []
  type: TYPE_IMG
