["```cpp\n    auto quickSprite = Sprite::create(\"blank.png\");\n    quickSprite->setTextureRect(Rect(0, 0, 100, 100));\n    quickSprite->setColor(Color3B(255,255,255));\n\n    quickSprite->setPosition(Vec2(_screenSize.width * 0.5, _screenSize.height * 0.5));\n    this->addChild(quickSprite);\n    ```", "```cpp\n    _gameBatchNode = SpriteBatchNode::create(\"blank.png\", 200);\n    this->addChild(_gameBatchNode, kMiddleground);\n    ```", "```cpp\n    _terrain = Terrain::create();\n    _gameBatchNode->addChild(_terrain, kMiddleground);\n\n    _player = Player::create();\n    _gameBatchNode->addChild(_player, kBackground);\n    ```", "```cpp\n    void Player::initPlayer () {\n        this->setAnchorPoint(Vec2(0.5f, 1.0f));\n        this->setPosition(Vec2(_screenSize.width * 0.2f, _nextPosition.y));\n\n        _height = 228;\n        _width = 180;\n        this->setTextureRect(Rect(0, 0, _width, _height));\n        this->setColor(Color3B(255,255,255));\n    }\n    ```", "```cpp\n    void Player::setFloating (bool value) {\n\n        if (_floating == value) return;\n\n        if (value && _hasFloated) return;\n\n        _floating = value;\n\n        if (value) {\n            _hasFloated = true;\n            _vector.y += PLAYER_JUMP * 0.5f;\n        }\n    }\n    ```", "```cpp\n    void Player::update (float dt) {\n        if (_speed + P_ACCELERATION <= _maxSpeed) {\n            _speed += P_ACCELERATION;\n        } else {\n            _speed = _maxSpeed;\n        }\n\n        _vector.x = _speed;\n    ```", "```cpp\n    switch (_state) {\n\n        case kPlayerMoving:\n            _vector.y -= FORCE_GRAVITY;\n            if (_hasFloated) _hasFloated = false;\n            break;\n\n       case kPlayerFalling:\n          if (_floating ) {\n             _vector.y -= FLOATNG_GRAVITY;\n             _vector.x *= FLOATING_FRICTION;\n\n          } else {\n             _vector.y -= FORCE_GRAVITY;\n             _vector.x *= AIR_FRICTION;\n             _floatingTimer = 0;\n          }\n          break;\n\n       case kPlayerDying:\n          _vector.y -= FORCE_GRAVITY;\n          _vector.x = -_speed;\n          this->setPositionX(this->getPositionX() + _vector.x);\n          break;\n\n    }\n    ```", "```cpp\n        if (_jumping) {\n            _state = kPlayerFalling;\n            _vector.y += PLAYER_JUMP * 0.25f;\n            if (_vector.y > PLAYER_JUMP ) _jumping = false;\n        }\n\n        if (_vector.y < -TERMINAL_VELOCITY) \n            _vector.y = -TERMINAL_VELOCITY;\n\n        _nextPosition.y = this->getPositionY() + _vector.y;\n\n        if (_floating) {\n            _floatingTimer += dt;\n            if (_floatingTimer > _floatingTimerMax) {\n                _floatingTimer = 0;\n                this->setFloating(false);\n            }\n        }\n    }\n    ```", "```cpp\n    void Block::setupBlock (int width, int height, int type) {\n\n        _type = type;\n\n        _width = width * _tileWidth;\n        _height = height * _tileHeight;\n\n        this->setAnchorPoint(Vec2(0,0));\n        this->setTextureRect(Rect(0, 0, _width, _height));\n    ```", "```cpp\n        switch (type) {\n\n            case kBlockGap:\n                this->setVisible(false);\n                return;\n\n            case kBlock1:\n\n                this->setColor(Color3B(200,200,200));\n                break;\n            case kBlock2:\n\n                this->setColor(Color3B(150,150,150));\n                break;\n            case kBlock3:\n\n                this->setColor(Color3B(100,100,100));\n                break;\n            case kBlock4:\n\n                this->setColor(Color3B(50,50,50));\n            break;\n        }\n\n        this->setVisible(true);\n\n    }\n    ```", "```cpp\nint patterns[] = {1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,3,3,3};\n```", "```cpp\nint widths[] = {2,2,2,2,2,3,3,3,3,3,3,4,4,4,4,4,4};\nint heights[] =  {0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,2,3,3,3,3,3,3,4};\n```", "```cpp\nint types[] =  {1,2,3,4,1,3,2,4,3,2,1,4,2,3,1,4,2,3,1,2,3,2,3,4,1,2,4,3,1,3,1,4,2,4,2,1,2,3};\n```", "```cpp\n    void Terrain::initTerrain () {\n\n        _increaseGapInterval = 5000;\n        _increaseGapTimer = 0;\n        _gapSize = 2;\n\n        //init object pools\n        for (int i = 0; i < 20; i++) {\n              auto block = Block::create();\n              this->addChild(block);\n              _blockPool.pushBack(block);\n        }\n\n       _minTerrainWidth = _screenSize.width * 1.5f;\n\n        random_shuffle(_blockPattern.begin(), _blockPattern.end());\n        random_shuffle(_blockWidths.begin(), _blockWidths.end());\n        random_shuffle(_blockHeights.begin(), _blockHeights.end());\n\n       this->addBlocks(0);\n    }\n    ```", "```cpp\n    void Terrain::addBlocks(int currentWidth) {\n\n        while (currentWidth < _minTerrainWidth)\n       {   \n          auto block = _blockPool.at(_blockPoolIndex);\n          _blockPoolIndex++;\n          if (_blockPoolIndex == _blockPool.size()) {\n            _blockPoolIndex = 0;\n          }\n          this->initBlock(block);\n          currentWidth +=  block->getWidth();\n          _blocks.pushBack(block);\n       }\n       this->distributeBlocks();\n    }\n    ```", "```cpp\n    void Terrain::distributeBlocks() {\n        int count = (int) _blocks.size();\n        int i;\n\n       for (i = 0; i < count; i++) {\n          auto block =  _blocks.at(i);\n          if (i != 0) {\n            auto prev_block = _blocks.at(i - 1);\n            block->setPositionX( prev_block->getPositionX() + prev_block->getWidth());\n          }\n          else\n          {\n            block->setPositionX ( 0 ); \n          }\n       }\n    }\n    ```", "```cpp\n    void Terrain::initBlock(Block * block) {\n\n        int blockWidth;\n        int blockHeight;\n\n        int type = _blockTypes[_currentTypeIndex];\n        _currentTypeIndex++;\n\n        if (_currentTypeIndex == _blockTypes.size()) {\n            _currentTypeIndex = 0;\n        }\n    ```", "```cpp\n    if (_startTerrain) {\n       //...\n    } else {\n        _lastBlockHeight = 2;\n        _lastBlockWidth = rand() % 2 + 2;\n        block->setupBlock (_lastBlockWidth, _lastBlockHeight, type);\n    }\n    ```", "```cpp\n    if (_startTerrain) {\n        if (_showGap) {\n            int gap = rand() % _gapSize;\n            if (gap < 2) gap = 2;\n\n            block->setupBlock (gap, 0, kBlockGap);\n            _showGap = false;\n        } else {\n            //...\n    ```", "```cpp\n    } else {\n\n        blockWidth = _blockWidths[_currentWidthIndex];\n\n        _currentWidthIndex++;\n        if (_currentWidthIndex == _blockWidths.size()) {\n            random_shuffle(_blockWidths.begin(),  _blockWidths.end());\n            _currentWidthIndex = 0;\n        }\n\n        if (_blockHeights[_currentHeightIndex] != 0) {\n\n            //change height of next block\n            blockHeight = _blockHeights[_currentHeightIndex];\n            //if difference too high, decrease it\n            if (blockHeight - _lastBlockHeight > 2 && _gapSize ==  2)  \n            {\n                blockHeight = 1;\n            }\n\n        } else {\n            blockHeight = _lastBlockHeight;\n        }\n        _currentHeightIndex++;\n        if (_currentHeightIndex == _blockHeights.size()) {\n            _currentHeightIndex = 0;\n            random_shuffle(_blockHeights.begin(),  _blockHeights.end());\n        }\n\n        block->setupBlock (blockWidth, blockHeight, type);\n        _lastBlockWidth = blockWidth;\n        _lastBlockHeight = blockHeight;\n    ```", "```cpp\n    //select next block series pattern\n    _currentPatternCnt++;\n\n    if (_currentPatternCnt > _blockPattern[_currentPatternIndex]) {\n        _showGap = true;\n        //start new pattern\n        _currentPatternIndex++;\n        if (_currentPatternIndex == _blockPattern.size()) {\n            random_shuffle(_blockPattern.begin(),  _blockPattern.end());\n            _currentPatternIndex = 0;\n        }\n        _currentPatternCnt = 1;\n        }\n    }\n    ```", "```cpp\n    void Terrain::move (float xMove) {\n        if (xMove < 0) return;\n\n        if (_startTerrain) {\n\n            if (xMove > 0 && _gapSize < 5) â€©            _increaseGapTimer += xMove;\n\n            if (_increaseGapTimer > _increaseGapInterval) {\n                _increaseGapTimer = 0;\n                _gapSize += 1;\n            }\n        }\n\n        this->setPositionX(this->getPositionX() - xMove);\n\n       auto  block = _blocks.at(0);  \n       if (_position.x + block->getWidth() < 0) {\n          auto firstBlock = _blocks.at(0);\n          _blocks.erase(0);\n          _blocks.pushBack(firstBlock);\n          _position.x +=  block->getWidth();\n\n          float width_cnt = this->getWidth() - block->getWidth() - ( _blocks.at(0))->getWidth();\n          this->initBlock(block);\n          this->addBlocks(width_cnt);\n        }\n    }\n    ```", "```cpp\n    void Terrain::reset() {\n\n        this->setPosition(Vec2(0,0));\n        _startTerrain = false;\n\n        int currentWidth = 0;\n        for (auto block : _blocks) {\n           this->initBlock(block);\n           currentWidth +=  block->getWidth();\n        }\n\n       while (currentWidth < _minTerrainWidth) {\n            auto block = _blockPool.at(_blockPoolIndex);\n            _blockPoolIndex++;\n            if (_blockPoolIndex == _blockPool.size()) {\n                _blockPoolIndex = 0;\n            }\n            _blocks.pushBack(block);\n            this->initBlock(block);\n            currentWidth +=  block->getWidth();\n       }\n\n       this->distributeBlocks();\n        _increaseGapTimer = 0;\n        _gapSize = 2;\n    }\n    ```", "```cpp\n    void Terrain::checkCollision (Player * player) {\n\n       if (player->getState() == kPlayerDying) return;\n       bool inAir = true;\n       for (auto block : _blocks) {\n          if (block->getType() == kBlockGap) continue;\n\n          //if within x, check y (bottom collision)\n          if (player->right() >= this->getPositionX() + block->left() && player->left() <= this->getPositionX() + block->right()) {\n\n            if (player->bottom() >= block->top() && player->next_bottom() <= block->top() && player->top() > block->top()) {\n               player->setNextPosition(Vec2(player->getNextPosition().x, block->top() + player->getHeight()));\n               player->setVector ( Vec2(player->getVector().x, 0) );\n               player->setRotation(0.0);\n               inAir = false;\n               break;\n             }       \n          }\n       }\n    ```", "```cpp\n    for (auto block : _blocks) {\n      if (block->getType() == kBlockGap) continue;\n      //now if within y, check x (side collision)\n      if ((player->bottom() < block->top() && player->top() >  block->bottom()) || (player->next_bottom() < block->top() &&  player->next_top() > block->bottom())) {\n       if (player->right() >= this->getPositionX() + block->getPositionX()  && player->left() < this->getPositionX() + block->getPositionX()) {\n          player->setPositionX( this->getPositionX() +  block->getPositionX() - player->getWidth() * 0.5f );\n          player->setNextPosition(Vec2(this->getPositionX() +  block->getPositionX() - player->getWidth() * 0.5f,  player->getNextPosition().y));\n          player->setVector ( Vec2(player->getVector().x * -0.5f,  player->getVector().y) );\n          if (player->bottom() + player->getHeight() * 0.2f <  block->top()) {\n             player->setState(kPlayerDying);\n             return;\n          }\n          break;\n         }\n      }\n    }\n    ```", "```cpp\n        if (inAir) {\n            player->setState(kPlayerFalling);\n        } else {\n            player->setState(kPlayerMoving);\n            player->setFloating (false);\n        }\n    }\n    ```", "```cpp\n    bool GameLayer::onTouchBegan(Touch* touch, Event* event) {\n\n        if (!_running) {\n\n            if (_player->getState() == kPlayerDying) {\n                _terrain->reset();\n                _player->reset();\n                resetGame();\n            }\n            return true;\n        }\n    ```", "```cpp\n        if (!_terrain->getStartTerrain()) {\n            _terrain->setStartTerrain ( true );\n            return true;\n        }\n    ```", "```cpp\n        if (touch) {\n          if (_player->getState() == kPlayerFalling) {\n                _player->setFloating ( _player->getFloating() ? false : true );\n\n           } else {\n\n              if (_player->getState() !=  kPlayerDying) _player->setJumping(true);\n           }\n           return true;\n        }\n        return false;\n    }\n    ```", "```cpp\n    void GameLayer::onTouchEnded(Touch* touch, Event* event) {\n        _player->setJumping(false);\n    }\n    ```", "```cpp\n    void GameLayer::update(float dt) {\n\n        if (!_running) return;\n\n        if (_player->getPositionY() < -_player->getHeight() ||\n            _player->getPositionX() < -_player->getWidth() * 0.5f)  {\n\n                _running = false;\n\n        }\n    ```", "```cpp\n    _player->update(dt);\n\n        _terrain->move(_player->getVector().x);\n\n        if (_player->getState() != kPlayerDying) \n            _terrain->checkCollision(_player);\n\n        _player->place();\n    ```", "```cpp\n    if (_player->getNextPosition().y > _screenSize.height * 0.6f) {\n            _gameBatchNode->setPositionY( (_screenSize.height *  0.6f - _player->getNextPosition().y) * 0.8f);\n\n        } else {\n            _gameBatchNode->setPositionY  ( 0 );\n        }\n    ```", "```cpp\n    if (_terrain->getStartTerrain() && _player->getVector().x > 0) {\n\n            _speedIncreaseTimer += dt;\n            if (_speedIncreaseTimer > _speedIncreaseInterval) {\n                _speedIncreaseTimer = 0;\n                _player->setMaxSpeed (_player->getMaxSpeed() + 4);\n            }\n        }\n\n    }\n    ```"]