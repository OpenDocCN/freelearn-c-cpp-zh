# 第3章。C基础——让你变得更强大

C语言编程并不那么难。但需要在开始时投入足够的工作。幸运的是，我和你在一起，我们有一个非常好的朋友，从第三章开始——我们的Arduino板。现在，我们将深入探讨C语言，我会尽我所能使其更加具体，而不是抽象。

本章和下一章真正是C语言导向的，因为Arduino程序设计需要编程逻辑语句的知识。在这两章之后，你将能够阅读这本书中的任何代码；这些坚实的基础也将帮助你进行进一步的项目，甚至那些与Arduino无关的项目。

我还将逐步介绍我们以后会用到的新概念，例如函数。如果你不太理解，不要害怕，我有时喜欢我的学生逐步听到一些单词，甚至在没有适当定义的情况下，因为这有助于进一步的解释。

所以，如果我没有定义它但提到了它，请放心，解释将在后面进行。让我们深入探讨。

# 接近变量和数据类型

我们已经在之前的章节示例中使用了变量。现在，让我们更好地理解这个概念。

## 什么是变量？

**变量** 是一个与符号名称相关的内存存储位置。这个预留的内存区域可以被填充或留空。基本上，它用于存储不同类型的值。我们在之前的例子中使用了变量 `ledPin`，使用了关键字 `int`。

变量非常有用的一点是我们可以在运行时更改它们的内容（值）；这也是为什么它们被称为变量，与常量相比，常量也存储值，但在程序运行时不能更改。

## 什么是类型？

变量（和常量）与类型相关联。类型，也称为 **数据类型**，定义了数据的可能性质。它还提供了一种直接在内存中预留定义大小的空间的好方法。C大约有10种主要的数据类型，我们可以像下面将要看到的那样进行扩展。

我故意只解释我们在Arduino编程中会大量使用的类型。这大约符合80%的其他常用C数据类型，在这里将绰绰有余。

基本上，当我们像这里所示那样声明变量时，我们正在使用一个类型：

[PRE0]

为特定大小（与 `int` 类型相关的大小）的内存空间被预留，正如你所见，如果你只写这一行，该变量中仍然没有存储任何数据。但请记住，已经预留了内存空间，准备用来存储值。

| 类型 | 定义 | 内存大小 |
| --- | --- | --- |
| `void` | 这种特定类型仅在 *函数* 声明和定义未知类型的指针时使用。我们将在下一章中看到这一点。 |   |
| `boolean` | 它存储 `false` 或 `true`。 | 1 字节（8 位） |
| `char` | 它以 *数字* 存储单引号字符，如 `'a'`，遵循 ASCII 表（[http://en.wikipedia.org/wiki/ASCII_chart](http://en.wikipedia.org/wiki/ASCII_chart)）。它是一个 *有符号* 类型，存储从 -128 到 127 的数字；它可以是无符号的，然后存储从 0 到 255 的数字。 | 1 字节 |
| `byte` | 它以 *8 位无符号* 数据存储数字，这意味着从 0 到 255。 | 8 位 |
| `int` | 它以 *2 字节有符号* 数据存储数字，这意味着从 -32,768 到 32,767。它也可以是无符号的，然后存储从 0 到 65,535 的数字。 | 2 字节 (16 位) |
| `word` | 它以 *2 字节无符号* 数据存储数字，这与 *无符号* `int` 相同。 | 2 字节 (16 位) |
| `long` | 它以 *4 字节有符号* 数据存储数字，这意味着从 -2,147,483,648 到 2,147,483,647，并且可以是无符号的，然后存储从 0 到 4,294,967,295 的数字。 | 4 字节 (32 位) |
| `float` | 它基本上以 *4 字节有符号* 数据存储带有小数点的数字，范围从 -3.4028235E + 38 到 3.4028235E + 38。请注意所需的精度；它们只有六到七位小数，有时可能会给出奇怪的舍入结果。 | 4 字节 (32 位) |
| `double` | 它通常存储比 `float` 值精度高两倍的 `float` 值。请注意，在 Arduino IDE 和板上，`double` 的实现与 `float` 完全相同；这意味着只有六到七位小数的精度。 | 4 字节 (32 位) |
| 数组 | 数组是有序的连续元素结构，这些元素类型相同，可以通过索引号访问。 | 元素数量 x 元素类型大小 |
| `string` | 它在 `char` 数组中存储文本字符串，其中最后一个元素是 `null`，即一个特定的字符（ASCII 码 0）。请注意 `string` 开头的 "s" 小写字母。 | 元素数量 * 1 字节 |
| `String` | 它是一种特定的数据结构，即类，提供了一种方便的方式来使用和操作文本字符串。它带有方法/函数，可以轻松地连接字符串、分割字符串等。请注意 `String` 开头的 "S" 大写字母。 | 每次都可以使用 `length()` 方法获取 |

### 滚动/包装概念

如果您超出类型的可能范围，变量将滚动到边界另一侧。

以下是一个示例：

[PRE1]

这在两个方向上都可能发生，从存储 `-32768` 的 `int` 变量中减去 `1` 会得到 `32767`。请记住这一点。

## 声明和定义变量

我们将描述如何声明和定义变量，并学习如何同时进行这两者。

### 声明变量

变量的声明是一个语句，其中您指定一个 *标识符*、一个 *类型*，以及最终变量的维度。

标识符是我们所说的 *变量名*。您也知道类型是什么。维度对于数组很有用，例如，但对于 `String`（它们在内部作为数组处理）也是如此。

在 C 和所有其他强类型语言，如 Java 和 Python 中，我们 *必须* 在使用变量之前声明它们。无论如何，如果你忘记了声明，编译器会报错。

### 定义变量

下表包含了一些变量定义的示例：

| 类型 | 示例 |
| --- | --- |
| `boolean` |

[PRE2]

|

| `char` |
| --- |

[PRE3]

|

| `byte` |
| --- |

[PRE4]

|

| `int` |
| --- |

[PRE5]

|

| `word` |
| --- |

[PRE6]

|

| `long` |
| --- |

[PRE7]

|

| `float` |
| --- |

[PRE8]

|

| `double` |
| --- |

[PRE9]

|

| 数组 |
| --- |

[PRE10]

|

| `string` |
| --- |

[PRE11]

|

定义一个变量是将值赋给之前为该变量预留的内存区域的行为。

让我们声明并定义每种类型的变量。我在代码注释中添加了一些解释。

这里有一些你可以使用的示例，但你会在本书给出的每一块代码中看到，使用了不同类型的声明和定义。一旦我们连接了电路板，你就可以接受这一点。

让我们更深入地了解 `String` 类型。

# String

`String` 类型值得一个单独的小节，因为它不仅仅是一个类型。实际上，它是一个对象（在面向对象编程的意义上）。

对象具有特殊的属性和函数。属性和函数是原生可用的，因为 `String` 现在是 Arduino 核心的一部分，即使你的 IDE 中没有一行代码，也可以将其视为一个预存在的实体。

再次强调，框架会为你处理这些事情，提供一个具有强大且已编码函数的类型/对象，这些函数可以直接使用。

在 Arduino 网站上查看 [http://arduino.cc/en/Reference/StringObject](http://arduino.cc/en/Reference/StringObject)。

## String 定义是一种构造

我们讨论了变量的定义，但对象有一个类似的概念，称为 **构造**。

对于 `String` 对象，我在这里谈论的是 *构造* 而不是 *定义*，但你可以将这两个术语视为等同。在 Arduino 核心中声明 `String` 类型涉及对象构造函数，这是一个面向对象编程的概念；幸运的是，我们在这个阶段不必处理它。

[PRE12]

## 使用索引和字符串内的搜索

`String` 是 `char` 元素的数组。这意味着我们可以通过它们的索引访问 `String` 类型的任何元素。

请记住，索引从 `0` 开始，而不是从 `1` 开始。`String` 对象实现了针对此特定目的的一些函数。

### charAt()

考虑到 `String` 类型如下声明和定义：

[PRE13]

语句 `myString.charAt(3)` 返回字符串中的第四个元素，即：`l`。注意这里使用的特定记法：我们有 `String` 变量的名称，然后是一个点，接着是函数的名称（这是 `String` 对象的方法），然后是传递给函数的参数 `3`。

### 注意

`charAt()` 函数返回字符串中特定位置的字符。

**语法**：`string.charAt(int);`

`int` 是表示 `String` 值索引的整数。

**返回类型**：`char`

让我们了解其他类似的功能。你会非常频繁地使用它们，因为我们已经看到，在非常低级别的观点中，通信包括解析和处理数据，这通常可以是字符串。

### `indexOf()` 和 `lastIndexOf()`

让我们考虑相同的声明/定义：

[PRE14]

`myString.indexOf('r')` 等于 `8`。确实，`r` 在字符串 `myString` 的值中的第九位。`indexOf(val)` 和 `lastIndexOf(val)` 都是在查找值 `val` 的第一个出现位置。

如果你想要从特定的点开始搜索，你可以指定一个起点，例如：`indexOf(val,start)`，其中 `start` 是函数开始搜索字符串中字符 `val` 的索引。正如你可能已经理解的，这个函数的第二个参数（`start`）可以省略，默认情况下搜索从字符串的第一个元素开始，即 `0`。

### 注意

`indexOf()` 函数返回字符串中字符串或字符的第一个出现位置。

**语法**: `string.indexOf(val, from);`

`val` 是要搜索的值，可以是字符串或字符。`from` 是搜索的起始索引，它是一个 `int` 类型。此参数可以省略。搜索是向前的。

**返回类型**: `int`

类似地，`lastIndexOf(val,start)` 从 `start` 或从最后一个元素（如果你省略 `start`）开始向后查找 `val` 的最后一个出现位置。

`lastIndexOf()` 函数返回字符串中字符串或字符的最后一个出现位置。

### 注意

**语法**: `string.lastIndexOf(val, from);`

`val` 是要搜索的值，它是一个字符串或字符。`from` 是搜索的起始索引，它是一个 `int` 类型。此参数可以省略。搜索是向后的。

**返回类型**: `int`

### `startsWith()` 和 `endsWith()`

`startsWith()` 和 `endsWith()` 函数分别检查字符串是否以作为函数参数传递的另一个字符串开始或结束。

[PRE15]

### 注意

如果一个字符串以与另一个字符串相同的字符开始，则 `startsWith()` 函数返回 `true`。

**语法**: `string.startsWith(string2);`

`string2` 是你想要测试的字符串的模式。

**返回类型**: `boolean`

我想，你现在已经开始理解了。`endsWith()` 也是这样工作的，但它比较字符串模式与测试字符串的末尾。

### 注意

`endsWith()` 函数如果字符串以与另一个字符串相同的字符结尾，则返回 `true`。

**语法**: `string.endsWith(string2);`

`string2` 是你想要测试的字符串的模式。

**返回类型**: `boolean`

## 连接、提取和替换

前面的操作也引入了新的C运算符。我在这里用字符串来使用它们，但你将在更广泛的环境中了解更多关于它们的信息。

### 连接

字符串连接是一种操作，你取两个字符串并将它们粘合在一起。它产生一个新的字符串，由前两个字符串组成。顺序很重要；你必须管理你想要附加到另一个字符串末尾的字符串。

#### Concat()

Arduino 核心提供了 `string.concat()` 函数，它专门为此目的设计。

[PRE16]

### 注意

`concat()` 函数将一个字符串附加到另一个字符串（即按定义的顺序连接）。

**语法**：`string.concat(string2);`

`string2` 是一个字符串，并将其附加到字符串的末尾。记住，由于连接，字符串的先前内容被覆盖。

**返回类型**：`int`（如果连接发生正确，函数返回 `1`）。

#### 在字符串上使用 + 操作符

另一种连接两个字符串的方法。这不是使用函数，而是使用操作符：`+`。

[PRE17]

这段代码与之前的一样。`+` 是一个稍后我会更好地描述的操作符。我在这里给你提供了一些东西：`+` 操作符的缩写表示法：

[PRE18]

这也可以写成：

[PRE19]

尝试一下。你会理解的。

### 提取和替换

可以使用一些非常有用的函数进行字符串操作和修改，提取和替换字符串中的元素。

#### `substring()` 是提取器

你想提取字符串的一部分。想象一下，如果Arduino板通过特定的和定义良好的通信协议发送消息：

`<output number>.<value>`

输出数字每次用两个字符编码，值用三个字符（45必须写成045）。我经常这样工作，并在需要时从我的电脑的串行端口通过USB弹出这类消息；例如，发送一个命令以特定强度点亮特定的LED。如果我想在第四个输出上以100/127的强度点亮LED，我会发送：

[PRE20]

Arduino *需要* 理解这条消息。在不进一步讨论通信协议设计的情况下，因为这将涵盖在[第7章](ch07.html "第7章。通过串行通信")——*通过串行通信*，我想向你介绍一个新功能——拆分字符串。

[PRE21]

这段代码将Arduino接收到的消息分成两部分。

### 注意

`substring()` 函数从起始索引（包含）到另一个索引（不包含）提取字符串的一部分。

**语法**：`string.substring(from, to);`

`from` 是起始索引。结果包括 `from` 字符串元素的内容。`to` 是结束索引。结果不包括 `end` 字符串元素的内容，它可以省略。

**返回类型**：`String`

让我们进一步探讨字符串提取的概念并对其进行拆分。

#### 使用分隔符拆分字符串

让我们稍微挑战一下自己。想象一下，我不知道或者我不确定消息格式（两个字符，一个点，然后是三个字符，这是我们刚刚看到的）。这是一个真实生活中的案例；在学习制作东西的过程中，我们经常会遇到那些*东西*没有按预期表现的情况。

假设我想使用点作为分隔符，因为我非常确定。我该如何使用我们已经学过的东西来实现这一点？我需要提取字符。好吧，我现在知道了`substring()`函数！

但我还需要一个索引来提取特定位置的内容。我也知道如何使用`indexOf()`在字符串中找到一个字符的索引。

我们就是这样做的：

[PRE22]

首先，我找到分割点索引（字符串中点所在的位置）。其次，我将这个结果用作提取子字符串的最后一个元素。别担心，最后一个元素不包括在内，这意味着`currentOutputNumber`不包含点。

最后，我再次使用`splitPointIndex`作为需要提取的字符串第二部分的起始位置。然后呢？我将整数`1`加到它上面，因为，正如你现在掌握的`substring()`函数所知，与起始索引对应的元素总是被`substring()`操作包括。我们不想那个点，因为它只是一个分隔符。对吧？

如果你现在有点困惑，别担心。在下一章和特别是当我们开始用Arduino处理事情时，事情会变得更加清晰，这在书中稍后会出现。

#### 替换

当我们想要将通信协议转换为另一个协议时，通常会使用替换操作。例如，我们需要替换字符串的一部分，以便为后续处理做准备。

让我们以之前的例子为例。现在我们想要将点替换为另一个字符，因为我们想将结果发送到另一个只理解空格字符作为分隔符的进程。

[PRE23]

首先，我将`receivedMessage`变量的内容放入另一个名为`originalMessage`的变量中，因为我知道`replace()`函数肯定会修改处理后的字符串。然后我用`replace()`函数处理`receivedMessage`。

### 注意

`replace()`函数用另一个字符串替换字符串的一部分。

**语法**：`string.replace(substringToReplace, replacingSubstring);`

`from`是起始索引。结果包括`from`字符串元素的内容。`to`是结束索引。结果不包括`end`字符串元素的内容，它可以省略。记住，替换操作会覆盖字符串的先前内容（如果你想要保留它，请将其复制到另一个字符串变量中）。

**返回类型**：`int`（如果连接操作正确发生，函数返回`1`）。

这个函数显然可以替换一个字符为另一个字符。字符串是字符数组。一个字符可以作为一个只有一个元素的字符串进行处理并不奇怪。让我们稍微思考一下。

## 其他字符串函数

我还想快速引用一些其他字符串处理函数。

### `toCharArray()`

此函数将字符串的所有字符复制到一个名为“缓冲区”的“真实”字符数组中，出于内部原因，也被称为缓冲区。您可以查看[http://arduino.cc/en/Reference/StringToCharArray](http://arduino.cc/en/Reference/StringToCharArray)。

### `toLowerCase()` 和 `toUpperCase()`

这些函数将它们处理的字符串替换为相同但所有字符均为小写和大写的字符串。您可以查看[http://arduino.cc/en/Reference/StringToLower](http://arduino.cc/en/Reference/StringToLower) 和 [http://arduino.cc/en/Reference/StringToUpperCase](http://arduino.cc/en/Reference/StringToUpperCase)。请注意，因为它会覆盖经过此过程处理的字符串。

### `trim()`

此函数会移除字符串中的所有空白字符。您可以查看[http://arduino.cc/en/Reference/StringTrim](http://arduino.cc/en/Reference/StringTrim)。再次提醒，请注意，因为它会覆盖经过此过程处理的字符串。

### `length()`

我想以这个函数结束。这是您将大量使用的函数。它以整数形式提供字符串的长度。您可以查看[http://arduino.cc/en/Reference/StringLength](http://arduino.cc/en/Reference/StringLength)。

## 在板上测试变量

以下是一段您也可以在文件夹 `Chapter03/VariablesVariations/` 中找到的代码：

[PRE24]

将此代码上传到您的板子，然后打开串行监视器。最后，通过按下复位按钮来复位板子并观察。板子会直接将内容写入您的串行监视器，如下面的截图所示：

![在板上测试变量](img/7584_03_002.jpg)

显示您板子所说内容的串行监视器

### 一些解释

所有解释将逐步进行，但这里是对当前发生情况的小结。

我首先声明了我的变量，然后在 `setup()` 中定义了一些。我本可以在同一时间声明和定义它们。

通过刷新记忆，`setup()` 只在板子启动时执行一次。然后，`loop()` 函数无限次地执行，依次运行每一行语句。

在 `loop()` 中，我首先测试 `myBoolean`，引入 `if()` 条件语句。我们将在本章学习这一点。

然后，我会对 `char`、`int` 和 `String` 类型进行一些操作，打印一些变量，然后修改它们并重新打印。

这里需要注意的主要点是 `if()` 和 `else` 结构。看看它，然后放松，答案很快就会到来。

# 范围概念

范围可以定义为变量的特定属性（以及函数，正如我们将看到的）。考虑到源代码，变量的范围是代码中该变量可见和可用的部分。

一个变量可以是*全局*的，然后在整个源代码中可见并可使用。但变量也可以是*局部*的，例如在函数内部声明，那么它只在这个特定函数内部可见。

作用域属性是通过变量声明在代码中的位置隐式设置的。你可能刚刚了解到每个变量都可以全局声明。通常，我遵循自己的*数字俳句*。

### 注意

让代码的每一部分只知道它必须知道的变量，不再多。

尽量缩小变量的作用域绝对是一个获胜的方法。查看以下示例：

[PRE25]

我们可以将代码的作用域表示为一个或多或少嵌套的框。

![作用域概念](img/7584_03_03.jpg)

代码的作用域被视为框

外部框代表源代码的最高作用域级别。在这个级别声明的所有声明都可以被所有函数看到和使用；它是全局级别。

每个其他框代表一个特定的作用域。在一个作用域中声明的每个变量都不能在更高作用域中看到和使用，也不能在同一级别的其他作用域中。

这种表示对我那些总是需要更多视觉的学生非常有用。当我们谈论*库*时，我们也会使用这个隐喻，特别是。库中声明的声明可以在我们的代码中使用，如果我们当然在代码开头包含一些特定的头文件。

# 静态、易变和const限定符

**限定符**是用于根据*限定*变量改变处理器行为的关键字。实际上，编译器将使用这些限定符来改变生成的二进制固件中考虑的变量的特性。我们将学习三个限定符：`static`、`volatile`和`const`。

## 静态

当你在函数内部使用`static`限定符时，这会使变量在两次函数调用之间保持持久。在函数内部声明变量使变量隐式地成为函数的局部变量，正如我们刚刚学到的。这意味着只有函数才能知道和使用该变量。例如：

[PRE26]

这个变量仅在`myFunction`函数中可见。但是第一次循环之后会发生什么？之前的值丢失了，一旦执行了`int aLocalVariable;`，就会设置一个新的变量，其值为零。查看以下新代码块：

[PRE27]

这个变量仅在`myFunction`函数中可见，并且在添加参数后修改了它，我们可以玩弄其新值。

在这种情况下，变量被限定为`static`。这意味着变量仅在第一次声明时存在。这提供了一种跟踪事物的有用方式，同时使包含此跟踪的变量局部化。

## 易变的

当你在变量声明语句中使用`volatile`修饰符时，此变量将从RAM中加载，而不是从板上的存储寄存器内存空间中加载。这种差异很微妙，并且此修饰符在特定情况下使用，在这些情况下，你的代码本身无法控制处理器上执行的其他操作。其中一个例子，在其他例子中，是使用中断。我们稍后会看到这一点。

基本上，你的代码正常运行，一些指令不是由这段代码触发的，而是由另一个过程，如外部事件触发的。确实，我们的代码不知道何时以及**中断服务例程**（**ISR**）做什么，但它在发生类似情况时停止，让CPU运行ISR，然后继续。从RAM中加载变量可以防止变量值的一些可能的不一致性。

## const

`const`修饰符表示常量。使用`const`修饰变量使其不可变，这听起来可能有些奇怪。

如果你在声明/定义语句之后尝试向`const`变量写入值，编译器会给出错误。作用域的概念也适用于这里；我们可以在函数内部或全局范围内修饰变量。此语句定义并声明了`masterMidiChannel`变量为常量：

[PRE28]

这相当于：

[PRE29]

### 注意

在`#define`语句之后没有分号。

`#define`似乎比`const`用得少一些，可能是因为它不能用于常量数组。无论情况如何，`const`总是可以使用的。现在，让我们继续学习一些新的运算符。

# 运算符、运算符结构和优先级

我们已经遇到了很多运算符。让我们首先检查一下算术运算符。

## 算术运算符和类型

算术运算符包括：

+   `+` (加号)

+   `-` (减法)

+   `*` (星号)

+   `/` (斜杠)

+   `%` (百分号)

+   `=` (等于)

我从最后一个开始讲：`=` **.** 它是**赋值**运算符。我们已经多次使用它来定义变量，这仅仅意味着给它赋值。例如：

[PRE30]

对于其他运算符，我将在以下内容中区分两种不同的情况：字符类型，包括`char`和`String`，以及数值类型。运算符可以根据变量的类型改变其效果。

### 字符类型

`char`和`String`只能通过`+`来处理。正如你可能已经猜到的，`+`是连接运算符：

[PRE31]

在此代码中，`myResultString`和`myString`的连接生成了`Hello World`字符串。

### 数值类型

对于所有数值类型（`int`、`word`、`long`、`float`、`double`），你可以使用以下运算符：

+   `+` (加法)

+   `-` (减号)

+   `*` (乘法)

+   `/` (除法)

+   `%` (取模)

以下是一个乘法的基本示例：

[PRE32]

### 注意

一旦你使用`float`或`double`类型作为操作数之一，就会使用浮点计算过程。

在之前的代码中，`OutputOscillatorAmplitude * multiplier` 的结果是 `float` 类型的值。当然，除以零是 *禁止的*；原因在于数学而不是C或Arduino。

**取模**是简单地将一个整数除以另一个整数的余数。我们将大量使用它来保持变量在受控和选择的范围内。如果您让一个变量无限增长，但通过例如7来操作它的模，结果将始终在0（当增长变量是7的倍数时）和6之间，从而约束增长变量。

## 简化表示和优先级

如您所注意到的，使用之前解释过的运算符有一种简化的写法。让我们看看两种等价的表达式并解释这一点。

示例 1：

[PRE33]

示例 2：

[PRE34]

这两段代码是等价的。第一段向您介绍了运算符的优先级。在 *附录B，C和C++运算符优先级* 中给出了所有优先级。让我们现在学习一些。

`+`, `-`, `*`, `/`, 和 `%` 的优先级高于 `=`。这意味着 `myInt1 + myInt2` 在赋值运算符之前计算，然后，结果被赋值给 `myInt1`。

第二个是简化版本。它与第一个版本等价，因此这里也适用优先级。以下是一个有点棘手的示例：

[PRE35]

您需要知道`+`的优先级高于`+=`。这意味着运算顺序是：首先，`myInt2 + myInt2`，然后是`myInt1 +`刚刚计算出的结果`myInt2 + myInt2`。然后，第二个运算的结果被赋值给`myInt1`。这意味着它等价于：

[PRE36]

## 增量和减量运算符

我想提醒您注意您经常会遇到的另一种简化表示：双重运算符。

[PRE37]

`++` 等价于 `+=1`，`--` 等价于 `-=1`。这些被称为 *后缀增量* (`++`) 和 *后缀减量* (`--`)。它们也可以用作 *前缀*。作为前缀的 `++` 和 `--` 的优先级低于它们作为后缀使用时的等效运算符，但在两种情况下，优先级都远高于 `+`, `-`, `/`, `*`，甚至 `=` 和 `+=`。

以下是一个我可以为您提供的最常用情况的简化表格。在每组中，运算符具有相同的优先级。它使得表达式 `myInt++ + 3` 变得模糊不清。在这里，括号的使用有助于确定哪个计算将首先进行。

| 优先级组 | 运算符 | 名称 |
| --- | --- | --- |
| 2 | `++``--``()``[]` | 后缀增量后缀减量函数调用数组元素访问 |
| 3 | `++``--` | 前缀增量前缀减量 |
| 5 | `*``/``%` | 乘法除法取模 |
| 6 | `+``-` | 加法减法 |
| 16 | `=``+=``-=``*=``/=``%=` | 赋值加法赋值减法赋值乘法赋值除法赋值取模 |

我想您现在对运算符的感觉好一些了吧？让我们继续进行一个非常重要的步骤：类型转换。

# 类型操作

当你设计一个程序时，有一个重要的步骤，就是为每个变量选择正确的类型。

## 选择正确的类型

有时候，选择会受到外部因素的影响。例如，当你使用Arduino与一个能够以10位整数编码数据的外部传感器时，这种情况就会发生（2^10 = 1024个分辨率步骤）。你知道`byte`类型只能存储从0到255的数字吗？你可能不会选择它！你会选择`int`。

有时候你必须自己做出选择。想象一下，你从电脑上的Max 6框架补丁通过串行连接（使用USB）将数据发送到板上。因为这是最方便的，既然你设计了它这样，补丁就会弹出封装在字符串消息中的`float`数字到板上。在解析后，将这些消息切割成片段以提取你需要的信息（即`float`部分），你会选择将其存储到`int`中吗？

这个问题有点难以回答。它涉及到一个*转换*过程。

## 隐式和显式类型转换

类型转换是将实体数据类型转换为另一个的过程。请注意，我没有提到变量，而是提到实体。

这是C语言设计的结果，我们只能转换存储在变量中的值，其他值会保持它们的类型直到它们的生命周期结束，也就是程序执行结束的时候。

类型转换可以是*隐式地*执行或*显式地*进行。为了确保每个人都跟我在一起，我会声明*隐式地意味着不是明显和有意识地写出来的*，与*显式地意味着在代码中明确写出来的*相对。

### 隐式类型转换

有时候，这也被称为*强制转换*。这发生在你没有为编译器指定任何内容，编译器必须根据它自己的基本（但通常足够智能）规则自动进行转换时。一个经典的例子是将`float`值转换为`int`值。

[PRE38]

我使用赋值运算符（`=`）将`myFloat`的内容放入`myInt`。这会导致`float`值的**截断**，即*去除小数部分*。如果你继续只使用`myInt`变量而不是`myFloat`，你肯定已经丢失了一些东西。这可能没问题，但你必须记住这一点。

另一个不太经典的例子是`int`类型到`float`类型的隐式转换。`int`没有小数部分。隐式转换为`float`不会产生除了等于零的小数部分之外的其他东西。这是简单的一部分。

但要小心，你可能会对`int`到`float`的隐式转换感到惊讶。整数是使用32位编码的，但即使`float`也是32位，它们的*尾数*（也称为尾数）是使用23位编码的。如果你没有精确地记住这一点，没关系。但我希望你能记住这个例子：

[PRE39]

代码的输出如下所示：

![隐式类型转换](img/7584_03_004.jpg)

从`int`到`float`隐式转换的奇怪结果

我将`123456789`存储到`long int`类型中，这是完全合法的（`long int`是32位有符号整数，能够存储从`-2147483648`到`2147483647`的整数）。赋值后，我显示的结果是：**123456792.00**。我们当然期望的是`123456789.00`。

### 注意

隐式类型转换规则：

+   `long int`到`float`可能会导致错误的结果

+   `float`到`int`会移除小数部分

+   `double`到`float`会四舍五入`double`的数字

+   `long int`到`int`会丢弃编码的高位比特

### 显式类型转换

如果你想要有可预测的结果，每次你都可以显式地转换类型。Arduino核心包含了六个转换函数：

+   char()

+   int()

+   float()

+   word()

+   byte()

+   long()

我们可以通过将你想转换的变量作为函数的参数来使用它们。例如，`myFloat = float(myInt)`；其中`myFloat`是`float`类型，`myInt`是`int`类型。不用担心使用，我们会在我们的固件中稍后使用它们。

### 注意

我的转换规则：注意你进行的每一个类型转换。对于你来说，它们都不应该是显而易见的，并且即使语法完全正确，它们也可能导致你的逻辑错误。

# 比较值和布尔运算符

我们现在知道了如何将实体存储到变量中，转换值，并选择正确的转换方法。我们现在将学习如何比较变量的值。

## 比较表达式

有六个比较运算符：

+   `==` (等于)

+   `!=` (不等于)

+   `<` (小于)

+   `>` (大于)

+   `<=` (小于或等于)

+   `>=` (大于或等于)

以下是一个代码中的比较表达式：

[PRE40]

这样的表达式没有任何作用，但它合法。比较两个元素会产生一个结果，在这个小例子中，它没有被用来触发或执行任何操作。`myInt1 > myFloat`是一个比较表达式。结果显然是`true`或`false`，我的意思是它是一个`boolean`值。这里它是`false`，因为`4`不大于`5.76`。我们也可以将比较表达式组合起来，以创建更复杂的表达式。

## 使用布尔运算符组合比较

有三个布尔运算符：

+   `&&` (和)

+   `||` (或)

+   `!` (非)

是时候回忆一些使用三个小表的逻辑运算了。你可以像阅读列元素 + 比较运算符 + 行元素那样阅读这些表；运算的结果位于列和行的交叉点。

二元运算符AND，也写作`&&`:

| `&&` | true | false |
| --- | --- | --- |
| true | true | false |
| false | false | false |

然后是二元运算符OR，也写作`||`:

| `&#124;&#124;` | true | false |
| --- | --- | --- |
| true | true | true |
| false | true | false |

最后，一元运算符NOT，也写作`!`:

|   | true | false |
| --- | --- | --- |
| `!` | false | true |

例如，true `&&` false = false，false `||` true = true。`&&`和`||`是*二元运算符*，它们可以*比较*两个表达式。

`!` 是一个 *一元运算符*，只能与一个表达式一起使用，逻辑上取反。`&&` 是逻辑与。当比较的两个表达式都为真时为真，在其他所有情况下为假。`||` 是逻辑或。当至少有一个表达式为真时为真，当它们都为假时为假。它是包含性或。`!` 是否定运算符，即 NOT。它基本上将假和真反转成真和假。

当你想要在代码中执行一些测试时，这些不同的操作非常有用且必要。例如，如果你想比较一个变量与特定值。

### 结合否定和比较

考虑两个表达式 A 和 B：

+   NOT(A `&&` B) = (NOT A `||` NOT B)

+   NOT (A `||` B) = (NOT A `&&` NOT B)

这在你创建代码中的条件时可能非常有用。例如，让我们考虑两个包含四个变量 a、b、c 和 d 的表达式：

+   a `<` b

+   c `>=` d

`!`(a `<` b) 的意义是什么？它是表达式的否定，其中：

`!`(a `<` b) 等于 (a `>=` b)

*a严格小于b* 的相反面是 *a大于或等于b*。同样地：

`!`(c `>=` d) 等于 (c `<` d)

现在，让我们结合一下。让我们取全局表达式的反：

(a `<` b) `&&` (c `>=` d) 和 `!`((a `<` b) `&&` (c `>=` d)) 等于 (`!`(a `<` b) `||` `!`(c `>=` d)) 等于 (a `>=` b) `||` (c `<` d)

这里是另一个组合示例，引入了 *运算符优先级* 的概念：

[PRE41]

我的两个陈述是等价的。这里发生优先级，我们现在可以将这些运算符添加到之前的优先级表中（检查 *附录B，C和C++中的运算符优先级*）。我添加了比较运算符：

| 优先级组 | 运算符 | 名称 |
| --- | --- | --- |
| 2 | `++``--``()``[]` | 后缀增量后缀减量函数调用数组元素访问 |
| 3 | `++``--` | 前缀增量前缀减量 |
| 5 | `*``/``%` | 乘除取模 |
| 6 | `+``-` | 加减 |
| 8 | `<``<=``>``>=` | 小于小于等于大于大于等于 |
| 9 | `==``!=` | 等于不等于 |
| 13 | `&&` | 逻辑与 |
| 14 | `&#124;&#124;` | 逻辑或 |
| 15 | `?:` | 三元条件运算符 |
| 16 | `=``+=``-=``*=``/=``%=` | 赋值赋值加赋值减赋值乘赋值除赋值取余 |

如同往常，我稍微作弊了一下，添加了包含唯一运算符的优先级组 15，即稍后我们将看到的三元条件运算符。让我们转到条件结构。

# 在代码中添加条件

因为我在生物学方面有研究，并且有硕士学位，所以我熟悉有机和生物行为。我喜欢告诉我的学生，代码，尤其是在交互设计领域的工作中，必须是有生命的。使用Arduino，我们经常构建能够“感受”真实世界并通过*行动*与之交互的机器。没有*条件*语句是无法做到这一点的。这种语句被称为控制结构。当我们测试包括变量显示等的大代码时，我们使用了一个条件结构。

## if和else条件结构

这是我们没有解释的一个例子。你已经学会了耐心和禅。事情开始出现，对吧？现在，让我们来解释它。这个结构非常直观，因为它非常类似于任何条件伪代码。这里有一个：

如果变量`a`的值小于变量`b`的值，则打开LED。否则关闭它。

现在是真正的C代码，我在其中通过给出1或0的状态来简化LED的部分，这取决于我想要在代码中进一步做什么：

[PRE42]

我认为这已经很清楚了。以下是这种结构的通用语法：

[PRE43]

表达式评估通常会产生布尔值。但在这个结构中，表达式的数值结果也可以是正确的，即使它不太明确，我个人不喜欢。在Arduino核心中，表达式的数值结果为`0`等于`false`，而对于任何其他值，都等于`true`。

### 注意

隐式通常意味着使你的代码更短更简洁。根据我个人的看法，这也意味着几个月后当你不得不支持和维护包含大量隐式内容的代码时，你会非常不高兴。

我鼓励我的学生要明确和详细。我们不是在这里为了将代码压缩到极小的内存中，相信我。我们不是在谈论将3兆字节的代码减少到500千字节，而是更多地减少到198千字节。

### 将if…else结构链接到另一个if…else结构

以下是一个修改后的示例：

[PRE44]

第一个`if`测试是：如果`a`小于`b`。如果是`true`，我们将值`1`放入变量`ledState`中。如果是`false`，我们进入下一个语句`else`。

这个`else`包含对`b`的另一个测试：`b`是否大于`0`？如果是，我们将值`0`放入变量`ledState`中。如果是`false`，我们可以进入最后一个情况，最后一个`else`，并将值`1`放入变量`ledState`中。

### 小贴士

**一个常见的错误 - 缺少一些情况**

有时，`if`…`else`链非常复杂和长，我们可能会错过一些情况，并且没有任何情况被验证。要明确，并尝试检查整个情况宇宙，并根据它编写条件。

一个不错的建议是尝试将所有情况都写在纸上，并尝试找到*漏洞*。我的意思是，变量的值部分没有通过测试。

### 带有组合比较表达式的if…else结构

以下是我之前例子中注释更多的一些代码：

[PRE45]

我们也可以按照我之前在代码中写的注释来这样写：

[PRE46]

这可以被认为是一个更紧凑的版本，其中所有关于LED开关的语句都在一个地方，同样适用于关闭它。

### 寻找条件结构的所有情况

假设你想测试一个温度值。你有两个特定的限制/点，你希望Arduino做出反应，例如通过点亮LED或任何与真实世界交互的事件。例如，这两个限制是：15摄氏度和30摄氏度。如何确保我涵盖了所有情况？最好的方法是拿一支笔，一张纸，画一画。

![寻找条件结构的所有情况](img/7584_03_05.jpg)

检查所有可能的 T 值

我们有三个部分：

+   T < 15

+   T > 15 但 T < 30

+   T > 30

因此，我们有三个情况：

+   T < 15

+   T > 15 且 T < 30

+   T > 30

当 T = 30 或 T = 15 时会发生什么？这些都是我们逻辑中的漏洞。根据我们如何设计我们的代码，这可能会发生。匹配所有情况意味着：包括 T = 15 和 T = 30 的情况。我们可以这样做：

[PRE47]

我将这两个情况包含在我的比较中。15摄氏度包含在第二个温度区间内，30摄氏度在最后一个区间内。这是一个我们如何做到的例子。

我希望你在这种情况下记得使用笔和纸。这有助于你设计和特别是在设计步骤中从IDE中跳出，这实际上是非常好的。现在让我们探索一个新的条件结构。

## switch…case…break 条件结构

在这里，我们将看到一个新的条件结构。标准语法如下所示：

[PRE48]

`var` 与每个情况标签进行比较。如果 `var` 等于特定的 `label` 值，则执行此情况中的语句，直到下一个 `break`。如果没有匹配，并且你使用了可选的 `default:` 情况，则执行此情况的语句。如果没有 `default:` 情况，则不执行任何操作。`label` 必须是一个值，而不是一个字符或字符串。让我们举一个更具体的例子：

[PRE49]

这段代码等同于：

[PRE50]

你好吗？

### 注意

我想要说的是，当你想要将一个变量与许多唯一值进行比较时，使用 `switch`…`case`…`break`，否则使用 `if`…`else`。

当你有比较区间时，`if`…`else` 更方便，因为你可以使用 `<` 和 `>`，而在 `switch`…`case`…`break` 中则不能。当然，我们可以结合两者。但请记住，尽量保持你的代码尽可能简单。

## 三元运算符

这种奇怪的符号通常对我的学生来说完全陌生。我过去常说，“嘿！这比Arduino更像是C语言”当他们回答“这就是我们忘记它的原因”时。淘气的学生！这个三元运算符接受三个输入元素。语法是 `(expression) ? val1 : val2`。

表达式被测试。如果是 `true`，则整个语句返回（或等于）`val1`，如果是 `false`，则等于 `val2`。

再次想象我们的Arduino、温度传感器和唯一的限制是20摄氏度。我想如果`T`小于限制，就使LED变蓝，如果`T`大于或等于20摄氏度，就变红。以下是我们会如何使用两个三元运算符：

[PRE51]

这可以是一种很好的表示法，特别是如果你不需要在每个情况下执行语句，而只需要变量赋值的话。

# 为重复性任务创建智能循环

**循环**是一系列在时间上重复的事件。基本上，计算机最初被设计出来是为了进行大量的重复计算以节省人类的时间。设计一个循环来重复必须重复的任务似乎是一个自然的想法。C语言原生实现了一些设计循环的方法。Arduino核心自然包括三种循环结构：

+   `for`

+   `while`

+   `do`…`while`

## `for`循环结构

`for`循环语句相当容易使用。它基于至少一个从你定义的特定值开始的计数器，并增加或减少它，直到另一个定义的值。其语法如下：

[PRE52]

计数器也被称为`index`。我在这里给你一个真实示例：

[PRE53]

这个基本示例定义了一个循环，它打印从`0`到`99`的所有整数。整数类型变量`i`的声明/定义是`for`结构的第一个元素。然后，条件描述了在哪种情况下必须执行此循环中包含的语句。最后，执行`i++`增量。

注意增量元素。它是以增量作为后缀定义的。这意味着在这里，增量发生在考虑的`i`值执行语句之后。

让我们中断前两个和最后两个`i`值的循环，看看会发生什么。第一个和第二次迭代的整数变量`i`的声明如下所示：

+   `i = 0`，`i`小于`100`吗？是的，`println(0)`，增加`i`

+   `i = 1`，`i`小于`100`吗？是的，`println(1)`，增加`i`

对于最后两次迭代，`i`的值如下所示：

+   `i = 99`，`i`小于`100`吗？是的，`println(99)`，增加`i`

+   `i = 100`，`i`小于`100`吗？不，停止循环

当然，索引可以在`for`结构之前声明，并在`for`结构内部定义。我们也可以在声明和定义变量之前进行，我们会有：

[PRE54]

这看起来有点奇怪，但在C语言和Arduino核心中都是合法的。

### 小贴士

**索引的作用域**

如果索引已经在`for`循环括号内声明，其作用域仅限于`for`循环。这意味着这个变量在循环外部是*不可知*或*不可用*的。

对于在`for`循环语句中声明的任何变量，通常都是这样工作的。这并不是什么需要做的事情，即使在C语言中这是完全合法的。为什么不是呢？因为这意味着你每次循环运行时都会声明一个变量，这并不真的聪明。最好是在循环外部声明一次，然后在循环内部使用它，无论目的（索引或要在语句内部使用的变量）是什么。

### 玩转增量

增量可以比仅使用增量运算符更复杂。

#### 更复杂的增量

首先，我们可以在不写`i++`的情况下写`i = i + 1`。我们还可以使用其他类型的操作，如减法、乘法、除法、取模，或者它们的组合。想象一下，你只想打印奇数。奇数都是形如`2n + 1`的形式，其中`n`是整数。以下是打印从`1`到`99`的奇数的代码：

[PRE55]

`i`的初始值是：`1`、`3`、`5`，依此类推。

#### 减量是负的增量

我只是想将之前的代码重新组合成其他的东西，以激发你对增量和减量的思考。下面是另一段代码，做同样的事情，但打印从`99`到`1`的奇数：

[PRE56]

好吧？让我们稍微复杂化一下。

### 使用嵌套`for`循环或两个索引

在`for`结构中也可以使用多个索引。想象一下，我们想要计算一个10 x 10的乘法表。我们必须定义两个从`1`到`10`的整数变量（0是平凡的）。这两个索引必须从`1`到`10`变化。我们可以从一个带有索引`x`的循环开始：

[PRE57]

这是第一个索引的情况。第二个索引完全相同：

[PRE58]

我该如何混合这些？答案是和回答“乘法表是什么？”一样：我必须保持一个索引不变，然后将其与另一个从`1`到`10`的索引相乘。然后，我必须增加第一个索引，并继续用另一个索引重复同样的操作，依此类推。下面是如何做到这一点：

[PRE59]

这段代码打印了所有`x*y`的结果，其中`x`和`y`是从`1`到`10`的整数，每个结果占一行。以下是前几个步骤：

+   `x = 1`，`y = 1`… 打印结果

+   `x = 1`，`y = 2`… 打印结果

+   `x = 1`，`y = 3`… 打印结果

`x`每次内部`for`循环（带有`y`的那个）结束时都会增加至`2`，然后`x`固定为`2`，而`y`会增长直到`x = 10`和`y = 10`，此时`for`循环结束。

让我们稍微改进一下，只是为了美观。这也是一个调整和玩弄代码的理由，让你更熟悉它。通常，乘法表是这样绘制的：

![使用嵌套`for`循环或两个索引](img/7584_03_006.jpg)

乘法表的经典视图

每当其中一个索引（只有一个）达到限制值`10`时，我们需要转到下一行。

[PRE60]

检查代码，每次`y`达到`10`时，就会创建一个新的行。`for`循环是一个强大的重复任务的结构。让我们检查另一个结构。

## `while`循环结构

`while`循环结构稍微简单一些。以下是语法：

[PRE61]

表达式被评估为布尔值，`true`或`false`。当表达式为`true`时，执行语句，然后一旦它变为`false`，循环就会结束。显然，通常需要在`while`结构之外声明和定义。以下是一个例子，它产生了与我们的第一个`for`循环相同的结果，打印从0到99的所有整数：

[PRE62]

事实上，你*必须*在你的语句中明确处理增量或减量；我稍后会谈谈无限循环。我们可以通过这样做来进一步压缩代码：

[PRE63]

`while`循环结构在执行第一条语句之前测试表达式。让我们检查一个以不同方式执行类似结构的例子。

## do…while循环结构

`do…while`循环结构与`while`结构非常相似，但它在循环的末尾评估表达式，这意味着在执行语句之后。以下是语法：

[PRE64]

这里是一个相同模型的例子：

[PRE65]

这意味着即使表达式评估的第一个结果是`false`，语句也会按时执行。这与`while`结构不同。

## 打破循环

我们学习了如何创建由索引驱动的循环，这些索引精确地定义了这些循环将如何存在。但当我们遇到一个*外部*事件时，我们如何停止循环？外部是指循环本身及其索引之外。在这种情况下，循环的条件本身不会包含外部元素。

想象一下，我们在正常条件下运行一个过程100次。但我们要中断它，或者根据另一个具有更大作用域的变量（至少在循环外部声明）来修改它。

多亏了`break`语句，才使得这一点对我们来说成为可能。`break;`是基本语法。当执行`break`时，它会根据`do`、`for`和`while`退出当前循环。当我们在讨论`switch`条件结构时，你已经看到了`break`。让我们来举例说明。

想象一个LED。我们希望它的强度从0增长到100%，然后回到0，每次都这样。但我们还希望使用一个很好的距离传感器，每次用户与传感器之间的距离大于某个值时，都会重置这个循环。

### 注意

这基于我为一个博物馆安装的真实系统，该系统必须使用户远离时LED平滑闪烁，当用户靠近时关闭LED，就像一个活生生的系统在召唤用户来见面。

我设计得非常简单，如下所示：

[PRE66]

整个循环都包含在Arduino板上的全局`loop()`函数中，并且每次`loop()`函数执行时，都会执行关于距离的完整测试，等待用户。

## 无限循环不是你的朋友

注意无限循环。问题其实不在于循环的无限状态，而在于一个系统，无论它是Arduino还是其他什么，如果运行了无限循环，就只能做那件事！循环之后的任何代码都无法执行，因为程序不会跳出循环。

如果你正确理解了我的意思，`loop()`——这是Arduino核心的基本函数——是一个无限循环。但它是一个设计良好的、基于Arduino核心的受控循环。当调用函数或发生其他特殊事件时，它可以（并且确实可以）被中断，让我们用户在这个循环内部设计我们需要的功能。我过去把它称为“事件驱动器和监听器”，因为这是我们的主程序运行的地方。

有很多方法可以创建无限循环的过程。你可以在 `setup()` 中定义一个变量，使其在 `loop()` 中增长，并在每次 `loop()` 运行时测试它，以便将其重置到初始值，例如。它利用了已经存在的 `loop()` 循环。以下是一个Arduino的C语言示例：

[PRE67]

这个 `i` 从 `0` 增长到 `threshold – 1`，然后回到 `0`，再次增长，无限循环，利用了 `loop()` 函数。

也有其他方法可以在受控方式下无限运行循环，我们将在本书的更高级部分稍后看到，但你要注意：小心那些无限循环。

# 摘要

在这个重要的章节中，我们学到了很多抽象的概念。从类型到运算符的优先级，再到条件结构，现在我们将学习新的结构和语法，这将帮助我们编写更高效的代码块，尤其是更可重用的代码块。我们现在可以学习函数了。让我们深入下一章C/C++知识，然后我们将在之后测试我们的Arduino。
