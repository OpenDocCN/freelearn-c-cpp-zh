- en: Making a C++ Project for a First-person Shooter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为第一人称射击游戏创建 C++ 项目
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Welcome to Mastering Unreal Engine 4! The goal of this book is to take individuals
    who are familiar with UE4 and C++ development to the next level in a holistic
    way. While some chapters will focus on specific system implementations and best
    practices in depth, others may give a more broad view of the large UE4 systems
    that are often used by content creation team members. By the end, you should have
    a solid foundation on which to make the best decisions concerning the use of UE4's
    technology with any scope or platform of project, and you will be able to guide
    a whole team towards seeing the project through to the end. There will be many
    areas in which you can directly implement these systems into game projects, but
    the overall goal of this book is to be able to address any needs from a technical
    direction side, giving you a base of knowledge that's a step above that of those
    who simply write code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到精通 Unreal Engine 4！本书的目标是将熟悉 UE4 和 C++ 开发的个人全面提升到下一个层次。虽然一些章节将深入探讨特定系统实现和最佳实践，但其他章节可能会提供一个更广泛的视角，了解内容创作团队成员经常使用的庞大
    UE4 系统。到那时，你应该有一个坚实的基础，可以就使用 UE4 技术的任何范围或平台的项目做出最佳决策，并且你将能够引导整个团队将项目进行到底。你可以在许多领域直接将这些系统应用于游戏项目，但本书的整体目标是能够从技术方向解决任何需求，为你提供一个高于单纯编写代码的人的知识基础。
- en: In this chapter, we will start a project for a basic combat game so that we
    have a basis for adding and working on more advanced features when we go forward.
    While some of this is automatically managed from UE4's game templates, we will
    go through all the necessary steps to make sure that the core setup referenced
    through the rest of the book is added, built, and tested, and that some new gameplay
    systems are implemented and demonstrated.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将启动一个基本战斗游戏项目，这样我们就有了一个基础，在前进时可以添加和开发更高级的功能。虽然其中一些是自动从 UE4 的游戏模板中管理的，但我们将通过所有必要的步骤来确保本书中引用的核心设置被添加、构建和测试，并且一些新的游戏玩法系统被实现和展示。
- en: 'The major topics to be covered through the rest of this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余部分将涵盖的主要主题如下：
- en: Setting up and creating a new first-person shooter project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和创建新的第一人称射击游戏项目
- en: Overriding existing UE4 classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖现有的 UE4 类
- en: Adding and implementing simple C++ functions for them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为它们添加和实现简单的 C++ 函数
- en: Quick review of build and running options
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速回顾构建和运行选项
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following components:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下组件：
- en: Visual Studio 2015 or 2017 (any edition)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2015 或 2017（任何版本）
- en: Unreal Engine 4.18.3 or higher built from source code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源代码构建的 Unreal Engine 4.18.3 或更高版本
- en: 'Some quick notes on platforms and installations: the aforementioned components
    assume that you will be using a Windows 10 PC, but there is no reason that a Mac
    running a current version of Xcode cannot benefit from and perform all the same
    work explored in this book. As the work presented will be from VS and reference
    some of its features, this is the recommended working environment as we progress
    through the chapters, but it is not specifically required. Samples will be tested from
    time to time and built on Mac mainly for iOS purposes in later chapters, but this
    book will not focus on IDE specifics other than giving steps (typically in Visual
    Studio terms) and tips. Code samples may reflect formatting that comes from [wholeTomato.com](http://wholeTomato.com)''s
    Visual Assist tool, which I highly recommend for Visual Studio users, but their
    tool does not affect building or results.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于平台和安装的一些快速说明：上述组件假设你将使用 Windows 10 PC，但没有任何理由表明运行当前版本 Xcode 的 Mac 不能从本书中探索的所有相同工作中受益并执行所有相同的工作。由于展示的工作将来自
    VS 并引用其一些功能，这是我们推荐的工作环境，随着我们进入章节，但这不是具体要求。样本将不时进行测试，并在后面的章节中主要在 Mac 上构建，以 iOS
    为目的，但本书不会专注于 IDE 的具体细节，除了提供步骤（通常以 Visual Studio 术语）和提示。代码示例可能反映了来自 [wholeTomato.com](http://wholeTomato.com)
    的 Visual Assist 工具的格式，我强烈推荐 Visual Studio 用户使用该工具，但他们的工具不会影响构建或结果。
- en: You can find all the sources referenced in all of this book's chapters at [https://github.com/mattedmonds404/Mastering](https://github.com/mattedmonds404/Mastering),
    with revision history for the work presented in each chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书所有章节中找到引用的所有源代码，请访问 [https://github.com/mattedmonds404/Mastering](https://github.com/mattedmonds404/Mastering)，其中包含每个章节中展示的工作的修订历史。
- en: For this chapter and its work, be sure to select the branch named `Chapter1`,
    the branch's dropdown on the top left of GitHub's web interface, or use the direct
    link for this chapter's branch at [https://github.com/mattedmonds404/Mastering/tree/Chapter1](https://github.com/mattedmonds404/Mastering/tree/Chapter1).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章及其工作，请务必选择名为`Chapter1`的分支，位于GitHub网页界面上方的左侧分支下拉菜单，或者使用本章分支的直接链接[https://github.com/mattedmonds404/Mastering/tree/Chapter1](https://github.com/mattedmonds404/Mastering/tree/Chapter1)。
- en: 'Two notes on using the project directly from GitHub: You still need to have
    the engine installed from source locally so you can right-click the project (`Mastering`/`Mastering.uproject`)
    and click Select Unreal Engine Version, and you will need to choose your installation
    file, which will also build the proper project files. Upon launching the `Mastering.sln`
    file in VS, please go through the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关于直接从GitHub使用项目的两个注意事项：您仍然需要从源代码本地安装引擎，以便您可以右键单击项目（`Mastering`/`Mastering.uproject`）并点击选择虚幻引擎版本，您还需要选择您的安装文件，这将也会构建适当的项目文件。在VS中启动`Mastering.sln`文件后，请按照以下步骤操作：
- en: Right-click the `Mastering` game project in the solution explorer and select
    Set as Startup Project so when running from VS, you launch directly into the editor
    for this project.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中右键单击`Mastering`游戏项目，并选择设置为启动项目，这样当从VS运行时，您将直接进入该项目的编辑器。
- en: Set the configuration to Development Editor, with the platform set as Win64.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将配置设置为开发编辑器，平台设置为Win64。
- en: It may be necessary to right-click directly on the UE4 Project in the solution
    explorer and click Build. Sometimes, when building a game project, it will not
    pick up the full dependencies needed for building the engine, if this was not
    already done separately.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能需要在解决方案资源管理器中直接右键单击UE4项目并点击构建。有时，在构建游戏项目时，它可能不会获取构建引擎所需的全部依赖项，如果这些依赖项尚未单独完成。
- en: The engine version that we will be using is 4.19.0.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的是4.19.0版本的引擎。
- en: Building the FPS C++ project
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建FPS C++项目
- en: 'In this section, we will go through the steps of creating a new project from
    scratch using the Unreal Project Browser. For those familiar with these steps
    already, the process should be relatively quick and straightforward. For anyone
    new to this setup, which can be typical of team members joining projects that
    are already in full development, there are some necessary steps to getting started.
    Since we will be working in C++ and using Visual Studio, I will make a quick aside
    here for users of the engine without the source code: Since this book will endeavor
    not to modify the engine source directly, it is still necessary for you to build
    C++ projects, as this is what this book will focus on. A blueprint-only project
    can be made without building source, and some pros and cons of this are explored in
    [Chapter 3](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml), *Blueprint Review and
    When to Use BP Scripting*, but again, this is not the way this book''s information
    is presented in most implementation cases. It is also worth noting that Epic Games
    are quite receptive to users of their technology finding issues or improvements
    that they can help resolve, and if given proper debugging information, they typically
    respond to these raised issues much more readily on their answer hub forums, such
    as [http://answers.unrealengine.com](http://answers.unrealengine.com). Additionally,
    if your project needs a fix or change to engine code immediately before Epic Games
    can help, you will need to be comfortable debugging and building the engine. Lastly,
    if you would like to make pull requests of the types of changes or fixes that
    are to be integrated by Epic Games, you will also want to bind it to their GitHub
    project in Git. So, going forward, we will proceed as if we are installing the
    engine and project on a fresh computer with the full ability to rebuild from source
    code.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过 Unreal 项目浏览器从头开始创建新项目的步骤。对于那些已经熟悉这些步骤的人来说，这个过程应该相对快速且直接。对于任何新加入这个设置的人来说，这可能是团队成员加入已经全面开发的项目时的典型情况，有一些必要的步骤来开始。由于我们将使用
    C++ 和 Visual Studio 进行工作，我将在这里快速说明没有源代码的引擎用户：由于本书将努力不直接修改引擎源代码，因此您仍然需要构建 C++ 项目，因为本书将专注于这一点。可以不构建源代码就创建仅蓝图的项目，这在[第
    3 章](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml)，“蓝图审查和何时使用 BP 脚本”，中探讨了其优缺点，但再次强调，这并不是本书在大多数实现案例中呈现信息的方式。还值得注意的是，Epic
    Games 对其技术用户发现的问题或改进非常开放，如果提供适当的调试信息，他们通常会在他们的答案论坛上更迅速地回应这些提出的问题，例如[http://answers.unrealengine.com](http://answers.unrealengine.com)。此外，如果您的项目需要在
    Epic Games 提供帮助之前立即修复或更改引擎代码，您需要熟悉调试和构建引擎。最后，如果您想提交 Epic Games 将要集成的更改或修复类型的拉取请求，您还希望将其绑定到他们的
    GitHub 项目上。因此，我们将继续前进，就像我们在一个全新的计算机上安装引擎和项目，并具有从源代码完全重建的能力一样。
- en: In the following section, we will do some modifications to the game mode and
    player, recompile these, and see the results in-game. For those wishing to skip
    ahead, all of the work that will be presented is available on the GitHub repository in
    the `Chapter1` branch, as noted previously.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将对游戏模式和玩家进行一些修改，重新编译这些修改，并在游戏中查看结果。对于那些希望跳过的人来说，所有将要展示的工作都可以在 GitHub
    仓库的`Chapter1`分支中找到，如前所述。
- en: 'There are three major steps to getting a brand new project up and running:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个全新的项目，有三个主要步骤：
- en: Download and install the UE4 source and compile it.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装 UE4 源代码并编译它。
- en: Run the editor to the project browser for the first time and pick a template.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首次运行编辑器到项目浏览器并选择一个模板。
- en: Build and run that project.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行该项目。
- en: Installing and building UE4
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和构建 UE4
- en: Our first step is to download the UE4 source code and build it. This can be
    done in a number of ways. If this is your first time doing this, the simplest
    way is to go to their GitHub site to acquire the engine, at [https://github.com/EpicGames/UnrealEngine](https://github.com/EpicGames/UnrealEngine).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是下载 UE4 源代码并构建它。这可以通过多种方式完成。如果您是第一次这样做，最简单的方法是访问他们的 GitHub 网站，在[https://github.com/EpicGames/UnrealEngine](https://github.com/EpicGames/UnrealEngine)获取引擎。
- en: For the link above to work, you must be signed in to GitHub, and have applied
    as an Unreal Developer.  See: [https://wiki.unrealengine.com/GitHub_Setup](https://wiki.unrealengine.com/GitHub_Setup)
    for details.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要使上面的链接正常工作，您必须登录到 GitHub，并已申请成为 Unreal 开发者。有关详细信息，请参阅[https://wiki.unrealengine.com/GitHub_Setup](https://wiki.unrealengine.com/GitHub_Setup)。
- en: 'Click the Clone or download button to see your options. From here, the simplest
    solution is simply to select the option to download the project as a ZIP file
    and unzip it wherever you like on your hard drive, as shown in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“克隆或下载”按钮以查看你的选项。从这里，最简单的解决方案是选择下载项目作为ZIP文件，并在你的硬盘上任何你喜欢的地方解压缩，如下面的截图所示：
- en: '![](img/9d62c4ed-2456-4326-9b71-a478b8e79bd3.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d62c4ed-2456-4326-9b71-a478b8e79bd3.png)'
- en: Using the website is always a viable option with Git. While I am not personally
    a fan of the GitHub Desktop app, it is also a possibility that you can explore
    at this point in the process. And while I would say there are some user-experience
    issues with SourceTree, it is a free app that I do recommend for managing GitHub
    projects. For those comfortable with command-line work, there are a number of
    options, as well as a terminal that you can open in order to use these commands
    in SourceTree. The important part, for now, is to get the UE4 tree installed so
    that we can get to building!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Git网站始终是一个可行的选项。虽然我个人不是GitHub桌面应用程序的粉丝，但它也是在这个过程中可以探索的可能性之一。虽然我会说SourceTree有一些用户体验问题，但它是一个免费的应用程序，我推荐用于管理GitHub项目。对于那些习惯于命令行工作的人来说，有许多选项，以及一个可以打开的终端，以便在SourceTree中使用这些命令。目前的重要部分是安装UE4树，这样我们就可以开始构建了！
- en: The first thing to do when downloading a new version of the engine, be it an
    update or fresh install, is to always run `Setup.bat` (or the `setup` command
    on Mac) in the main installation folder before doing any other steps. Make sure
    that the pop-up window is getting all the platforms you use, ensuring that it
    pulls the required files for the platform that are described in the `README.md`
    file in the same folder.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当下载新版本的引擎时，无论是更新还是全新安装，首先始终在主安装文件夹中运行`Setup.bat`（或在Mac上的`setup`命令）进行其他任何步骤之前。确保弹出窗口正在获取你使用的所有平台，确保它拉取了与同一文件夹中的`README.md`文件中描述的平台所需的文件。
- en: 'Once the `Setup.bat`/`setup` command has completed, run the `GenerateProjectFiles.bat`
    file, and a `UE4.sln` file will appear in the same folder. A quick note on the
    state of UE4-generated solutions and VS 2015 and VS 2017: UE4 generates VS 2015
    project files by default. It is possible to specify `-2017` as a batch file argument.
    It is currently not necessary to build for 2017, and the 2015 project files open,
    build, and run perfectly well in both VS 2015 and VS 2017\. However, if you have
    both versions of VS installed, then by default it will try to open them in VS
    2015, which can be very annoying. As of writing this book, using either version
    of Visual Studio should grant the same results, and this was tested here, but
    going forward, what is in GitHub will force you to use VS 2017 for building in
    the editor. There is a discussion about why and how this is set later in this
    chapter in the *Overriding the Character Class* portion of the *Modifying Our
    Game with C++* section.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Setup.bat`/`setup`命令完成，运行`GenerateProjectFiles.bat`文件，一个`UE4.sln`文件将出现在同一文件夹中。关于UE4生成的解决方案和VS
    2015以及VS 2017的状态的快速说明：UE4默认生成VS 2015项目文件。你可以指定`-2017`作为批处理文件参数。目前不需要为2017年构建，2015年的项目文件在VS
    2015和VS 2017中打开、构建和运行都非常完美。然而，如果你安装了这两个版本的VS，那么默认情况下它将尝试在VS 2015中打开它们，这可能会非常令人烦恼。截至撰写本书时，使用任何版本的Visual
    Studio都应该提供相同的结果，这一点在这里已经得到了测试，但向前看，GitHub上的内容将迫使你使用VS 2017在编辑器中构建。关于为什么以及如何设置这一点的讨论将在本章的“修改我们的游戏以C++”部分的“覆盖角色类”部分中稍后进行。
- en: 'The steps that we need to go through to have the engine built are now very
    straightforward:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行的步骤来构建引擎现在非常直接：
- en: Double click the `.sln` and open it in VS.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`.sln`文件，在VS中打开它。
- en: For now, right-click the UE4 project in the solution explorer and select Set
    as Startup Project.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在解决方案资源管理器中右键单击UE4项目，并选择“设置为启动项目”。
- en: Select Development Editor as the Configuration (or DebugGame; more on this later),
    and Win64 as the Platform.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“开发编辑器”作为配置（或“调试游戏”；关于这一点稍后会有更多说明），以及“Win64”作为平台。
- en: Build the project. This can take an hour, depending on your hardware setup.
    Some build recommendations are listed at the end of this section.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目。这取决于你的硬件配置，可能需要一个小时。本节末尾列出了一些构建建议。
- en: Running the editor and picking a template
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行编辑器并选择模板
- en: 'Our next step is running the editor. Launch the engine in VS by pressing *F5*.
    Without a game or app project in the solution, this will take you directly to
    the Unreal project browser. You can also easily do this any time later by right-clicking
    the UE4 project in the solution explorer and debugging or running it directly.
    I also recommend simply creating a shortcut to your UE4 install folder''s `/Engine/Binaries/Win64/UE4Editor.exe`
    file, as sometimes it can be beneficial to quickly launch this outside of your
    programming IDE. From the Project Browser, go through the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是运行编辑器。通过按 *F5* 在 VS 中启动引擎。如果没有在解决方案中添加游戏或应用程序项目，这将直接带您到虚幻项目浏览器。您也可以在任何时候通过在解决方案资源管理器中右键单击
    UE4 项目并直接调试或运行它来轻松完成此操作。我还建议简单地创建一个快捷方式到您的 UE4 安装文件夹的 `/Engine/Binaries/Win64/UE4Editor.exe`
    文件，因为有时在编程 IDE 之外快速启动它可能有益。从项目浏览器中，按照以下步骤操作：
- en: Click the New Project tab, and under it, the C++ tab.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击新建项目选项卡，然后在其下方点击 C++ 选项卡。
- en: Pick the First Person icon as our type to make our **first-person shooter**
    (**FPS**) base.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第一人称图标作为我们的类型，以创建我们的**第一人称射击**（**FPS**）基础。
- en: Pick a destination folder and a project name, and click Create Project.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个目标文件夹和一个项目名称，然后点击创建项目。
- en: If you choose a project name other than Mastering, please read the following
    information box.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您选择的项目名称不是 Mastering，请阅读以下信息框。
- en: The choices for Desktop/Console, Quality, and Starter Content can be left as
    their defaults, but feel free to hover over them and click their drop-down arrows
    to see the options for each, as well as the brief descriptions of what they do.
    Starter Content is actually an Unreal content pack, and we will be adding it manually in
    a later chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于桌面/控制台、质量和起始内容的选择，可以保留它们的默认设置，但请随意将鼠标悬停在其上方并点击下拉箭头，以查看每个选项的选项以及它们的功能简要描述。起始内容实际上是一个虚幻内容包，我们将在后面的章节中手动添加它。
- en: As the project presented here is set on GitHub as Mastering, that will be the
    name used throughout this book to refer to the project name. Unreal's templates
    use this for making several of the basic files added to the project, too. So,
    for example, when referring to `MasteringCharacter.h`, if you chose another name,
    please reference `(Your Project's Name)Character.h` from what the template built.
    For simplicity, it is recommended that you simply name it the same.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这里展示的项目在 GitHub 上设置为 Mastering，因此本书中将使用该名称来引用项目名称。虚幻的模板也使用它来创建添加到项目中的几个基本文件。例如，当提到
    `MasteringCharacter.h` 时，如果您选择了另一个名称，请从模板构建的 `(您的项目名称)Character.h` 中引用。为了简单起见，建议您直接使用相同的名称。
- en: At this point, UE4 will close the project browser, generate the game's project
    files, and attempt to open it in VS. Naturally, at this point, it is a good idea
    to simply close the engine-only IDE session, as the engine project is also opened
    in the project solution. As you can see, the project you named should now be the
    startup project, and should contain several source files for the C++ template.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，UE4 将关闭项目浏览器，生成游戏的项目文件，并尝试在 VS 中打开它。自然地，在这个时候，简单地关闭仅引擎的 IDE 会话是个好主意，因为引擎项目也在项目解决方案中打开。正如您所看到的，您命名的项目现在应该是启动项目，并且应该包含几个用于
    C++ 模板的源文件。
- en: Building and running the game project
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行游戏项目
- en: Now, we can finally build and run our game. Building the FPS sample project
    should go very quickly, and unless you change to another configuration or platform,
    it will not require the building of any of the engine code again. As a general
    rule, it is a good idea to build DebugGame versions for testing. Using this, you
    will get some extra runtime information and safety checks for your project's code,
    but typically without a significant change to performance when testing. So in
    our case, I recommend using DebugGame Editor, even though we built the engine
    in development. DebugGame Editor, as a standalone configuration (DebugGame) running
    on you PC, will build only the game project's code in debug, but will continue
    using the engine in its faster-running development configuration. Changing the
    configuration to Debug Editor, for example, would force the engine to fully build
    in debug as well. The engine also runs rather slowly in areas in debug builds,
    and maintaining both debug and development builds of the engine is time-consuming
    and usually unnecessary, unless it is actually debugging engine code directly.
    Once the project finishes building, simply run it using *F5*, like we did with
    the engine-only solution session. This will launch the editor with your game as
    the game project. The editor in UE4 is where all developers, including programmers,
    will do a huge amount of work and testing while building a game or app. **Play
    In Editor** (**PIE**) is one of Unreal's greatest strengths, as is the hot-reload
    of the game library while working in the editor. As projects grow in complexity,
    and the game flow may change from the simple starting of a level, hot-reloads
    and PIE itself may not always be a viable option for testing, but for our work
    in this section, it is perfect for showing off some of its advantages. Generally,
    when working on gameplay systems or debugging new code, PIE will be your best
    friend.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以构建并运行我们的游戏了。构建FPS示例项目应该会非常快，除非你更改到另一个配置或平台，否则它不会再次需要构建任何引擎代码。一般来说，构建用于测试的DebugGame版本是个好主意。使用它，你将获得一些额外的运行时信息和项目代码的安全检查，但通常在测试时不会对性能产生重大影响。所以在这种情况下，我建议使用DebugGame编辑器，即使我们是在开发中构建的引擎。DebugGame编辑器作为一个独立配置（DebugGame），在你的PC上运行，将仅在调试模式下构建游戏项目代码，但将继续使用引擎的更快运行的开发配置。例如，将配置更改为Debug
    Editor，将迫使引擎完全在调试模式下构建。在调试构建中，引擎在某些区域运行得相当慢，同时维护引擎的调试和开发版本既耗时又通常不必要，除非你实际上正在直接调试引擎代码。一旦项目构建完成，只需使用*F5*运行它，就像我们之前在仅引擎解决方案会话中做的那样。这将启动编辑器，并将你的游戏作为游戏项目运行。在UE4中，所有开发者，包括程序员，在构建游戏或应用时都会在编辑器中进行大量的工作和测试。"在编辑器中播放"（**PIE**）是Unreal的强大功能之一，同样，在编辑器中工作时的游戏库的热重载也是。随着项目的复杂性增加，游戏流程可能从简单的关卡开始，热重载和PIE本身可能并不总是测试的有效选项，但在这个部分的我们的工作中，它完美地展示了其优势。一般来说，当你在游戏玩法系统或调试新代码时，PIE将是你的最佳伙伴。
- en: So, "sounds great!", you say. Feel free to give it a shot with the Play button
    near the right side of the top bar of the editor's default layout. Immediately,
    you'll notice that you can move around with the traditional WASD FPS keyboard
    controls, fire a weapon (with some physics impact on its projectile when it hits
    the cubes in the level), and even jump with the spacebar.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你说，“听起来很棒！”你可以自由地尝试编辑器默认布局顶部右侧的播放按钮。立即，你会注意到你可以使用传统的WASD FPS键盘控制移动，发射武器（当它在关卡中的方块上击中时，会有一些物理影响），甚至可以用空格键跳跃。
- en: At this early stage, it is always a good idea to consider your controls. It
    is always recommended that you maintain viable PC controls for any game type for
    any team to use while working in the editor and PIE. Even if a game or app will
    not use a PC as its native platform, such as those using a mobile or VR, the speed
    and ease of testing in PIE makes maintaining parallel PC controls very valuable.
    In fact, if you go to the game project and open the `MasteringCharacter.cpp` file and
    browse through some of the input code, you will notice that it specifically supports
    two methods of turning in order to correspond to a control stick or virtual control
    stick on mobile, as well as direct axis input, such as a mouse. There is also
    commented-out code to support one-touch movement and turning on a touch-screen
    device, such as a phone or tablet. In the next section, we will add a new input.
    You are welcome to browse the existing inputs to see what was already set up and
    bound across the various platforms. Just keep in mind that at a time like this,
    it is typically much easier to begin maintaining controls across multiple platforms
    earlier than it is to add controls for a whole platform later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个早期阶段，考虑你的控制方式总是一个好主意。始终建议为任何游戏类型维护可行的PC控制，以便任何团队在编辑器和PIE中工作时使用。即使游戏或应用不会使用PC作为其原生平台，例如使用移动或VR的，PIE中测试的速度和便捷性使得维护并行PC控制非常有价值。实际上，如果你访问游戏项目并打开`MasteringCharacter.cpp`文件，浏览一些输入代码，你会注意到它专门支持两种转向方法，以对应控制杆或移动设备上的虚拟控制杆，以及直接轴输入，例如鼠标。此外，还有一些注释掉的代码，用于支持在触摸屏设备上的一触移动和转向，例如手机或平板电脑。在下一节中，我们将添加一个新的输入。欢迎你浏览现有的输入，看看已经为各种平台设置和绑定的是什么。只需记住，在这种情况下，通常在稍后为整个平台添加控制比在早期开始维护跨平台控制要容易得多。
- en: Modifying our game with C++
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++修改我们的游戏
- en: 'In this section, we will look at some quick ways to add new features and gameplay
    to a project by adding a new mechanic to this FPS game: stealth. We will do this
    by overriding some of the existing supplied classes in the template, and adding
    a new input and some new code. At the end of this section, we will run the game,
    test that our code is definitely doing what we want, and see those results in
    game as the character crouches when the input is down. We will go through the
    following steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些快速添加新功能和游戏玩法的方法，通过为这款FPS游戏添加一个新的机制：潜行。我们将通过覆盖模板中的一些现有类，并添加新的输入和一些新代码来实现这一点。在本节的结尾，我们将运行游戏，测试我们的代码是否确实按照我们的意愿执行，并看到当输入按下时角色蹲下的游戏结果。我们将按照以下步骤进行：
- en: Add a new C++ class from the editor.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从编辑器添加一个新的C++类。
- en: Modify this class and let it hot-reload back into the running editor.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改此类并让它热重载回运行中的编辑器。
- en: Add a new input and gameplay mechanic and see it in action.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的输入和游戏玩法机制，并观察其效果。
- en: Overriding the character class
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖角色类
- en: To facilitate our future work and start some good practices, we will add a bit
    of specialized game code here by subclassing the existing `MasteringCharacter`
    native (implemented in C++) class that supplied. This can be done directly in
    Visual Studio by hand, but Epic Games have once again supplied us with some shortcuts
    in Unreal that we will use from the editor. So, let's begin with the editor opened
    to our project, as we left it in the previous section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便我们未来的工作并开始一些良好的实践，我们将通过子类化提供的现有`MasteringCharacter`本地（用C++实现）类来在此处添加一些专门的游戏代码。这可以直接在Visual
    Studio中手动完成，但Epic Games再次为我们提供了Unreal中的快捷方式，我们将从编辑器中使用。因此，让我们从打开到我们的项目，就像我们在上一节中留下的一样开始编辑器。
- en: We will begin in the content browser window, which is typically docked to the
    bottom section of the editor by default. If it is not already open for you, or
    was closed for some reason, just reopen it by clicking on the Window at the top
    and scroll to Content Browser, then Content Browser 1, and it will reopen as a
    free-standing window. I would dock this wherever you are comfortable in the editor,
    or, of course, it can be a free-standing window. What is important, however, is
    on the left-hand side. Just under the Add New dropdown is a small icon with three
    lines and a little arrow. Click this to open the Sources panel, which I find extremely
    helpful for navigating content in the editor. In there, under Content, is a folder
    called `FirstPersonCPP`, and in that is a `Blueprints` folder. Click on that folder
    and you should see a `FirstPersonCharacter` item on the right panel. This is the
    blueprint representation of the character we currently play when the game is started,
    and it is required to have an instance in the map for the game to function properly,
    given the way this C++ FPS template is made. This is one of the only blueprints
    used in the C++ FPS template, but let's open it and take a look at what is available
    from our native class in C++ code in the `MasteringCharacter.h/.cpp `file, which
    shows up here in a blueprint representation in the editor. Right now, it just
    looks like a collection of variables, with a line at the top starting with NOTE: and
    ending with a blue link to Open Full Blueprint Editor. A much more in-depth discussion
    of blueprints and their classes and interaction with C++ will be made in [Chapter
    3](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml), *Blueprint Review and When to
    Use BP Scripting*. For now, just click the blue link so that we can see a bit
    of how these variables define our character in the game. The strict C++ style
    of the template makes very little use of this blueprint; it really is just a collection
    of some variables for the use of the template. But if you now click the Viewport
    tab at the top, you can see just what some of these variables do. For example,
    on the right in the Details tab, there should be an open flyout labeled Camera. Under
    this, the first variable is Base Turn Rate with a greyed-out value of 45.0\. In
    code, this is used to determine how fast our character can turn, but it can't
    be edited. Let's go see why.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将从内容浏览器窗口开始，该窗口默认情况下通常停靠在编辑器的底部区域。如果您还没有打开，或者由于某些原因已经关闭，只需点击顶部的“窗口”并滚动到内容浏览器，然后是内容浏览器
    1，它将作为一个独立窗口重新打开。我会将它停靠在编辑器中您感到舒适的位置，或者，当然，它也可以是一个独立窗口。然而，重要的是左侧的内容。就在“添加新内容”下拉菜单下方，有一个带有三条线和一个小箭头的图标。点击这个图标以打开资源面板，我发现这对于在编辑器中导航内容非常有帮助。在那里，在“内容”下，有一个名为
    `FirstPersonCPP` 的文件夹，在该文件夹中有一个 `Blueprints` 文件夹。点击该文件夹，您应该在右侧面板中看到一个 `FirstPersonCharacter`
    项。这是当游戏开始时我们正在扮演的角色蓝图表示，由于这个 C++ FPS 模板的方式，游戏要正常运行，必须在地图中有一个实例。这是在 C++ FPS 模板中使用的唯一蓝图之一，但让我们打开它，看看从我们的本地
    C++ 代码中的 `MasteringCharacter.h/.cpp` 文件可以获取哪些内容，这些内容在这里以蓝图表示的形式出现在编辑器中。目前，它看起来就像是一系列变量，顶部有一行以
    NOTE: 开头，以一个蓝色链接到“打开完整蓝图编辑器”结尾。关于蓝图及其类以及与 C++ 的交互的更深入讨论将在[第 3 章](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml)中进行，*蓝图回顾和何时使用
    BP 脚本*。现在，只需点击蓝色链接，这样我们就可以看到这些变量是如何定义我们在游戏中的角色的。模板的严格 C++ 风格几乎不使用这个蓝图；它实际上只是一系列用于模板的变量。但如果你现在点击顶部的“视图”选项卡，你就可以看到其中一些变量是如何工作的。例如，在右侧的“详细信息”选项卡中，应该有一个名为“相机”的展开菜单。在这个下面，第一个变量是
    Base Turn Rate，其值为 45.0，灰色显示。在代码中，这个值用于确定我们的角色可以旋转多快，但它不能被编辑。让我们去看看为什么。'
- en: 'Switch back a moment and look in Visual Studio at `MasteringCharacter.h`. Down
    in one of the class'' public sections, you should see the following lines:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微切换回 Visual Studio 查看 `MasteringCharacter.h`。在类的公共部分之一，您应该看到以下行：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `UPROPERTY` macro is the method in which a C++ variable is bound into a
    blueprint class, where it can be seen and/or edited. In this case, the flags specified
    in the `VisibleAnywhere` `BlueprintReadOnly `macro are why we can view it in the
    blueprint, but not edit it, and the `Category=Camera` is why it is under the Camera
    flyout. Variables are automatically displayed in blueprints based on their camel
    case from C++, so each capital letter makes a word in the blueprint representation,
    such as `BaseTurnRate`, in our case. In the `MasteringCharacter.cpp` file, you
    can see in the constructor that `BaseTurnRate = 45.f` is specified, hence its
    value is shown in the editor. Again, this will all be used more and more, but
    a quick overview is needed for the changes that we will make shortly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPROPERTY`宏是将C++变量绑定到蓝图类中的方法，在那里它可以被看到和/或编辑。在这种情况下，`VisibleAnywhere` `BlueprintReadOnly`宏中指定的标志是我们可以在蓝图中查看但无法编辑它的原因，而`Category=Camera`是它位于Camera展开菜单下的原因。变量会根据其从C++中的驼峰命名自动在蓝图上显示，所以每个大写字母在蓝图表示中都是一个单词，例如我们的`BaseTurnRate`。在`MasteringCharacter.cpp`文件中，你可以在构造函数中看到`BaseTurnRate
    = 45.f`被指定，因此它的值在编辑器中显示。再次强调，所有这些都会越来越多地被使用，但我们需要对即将进行的更改进行快速概述。'
- en: Our next steps are going to create a build of our game in the editor, so we
    will mention again the issues that will arise from having both VS 2015 and VS
    2017\. If you do not have VS 2015 installed and only use VS 2017, feel free to
    skip to the steps past this paragraph.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的步骤将在编辑器中创建我们的游戏构建，因此我们将再次提到同时拥有VS 2015和VS 2017可能引起的问题。如果你没有安装VS 2015并且只使用VS
    2017，请自由跳过本段之后的步骤。
- en: 'To force everything to open in Visual Studio 2017, follow two steps. First,
    in the project''s `readme.md` file from GitHub, you will see instructions on how
    to make a batch file, or use the same line by copy-pasting in a command prompt,
    to generate your project files in VS 2017 from Explorer. In addition, when the
    editor generates these files, as noted, it will also default to VS 2015, which
    can be very annoying if you have both IDEs installed, as you may be working in
    VS 2017 and then the editor will make a build and try to open your project in
    VS 2015! You will want to go to the Settings tab at the top of the editor, open
    Project Settings, then scroll down under Platforms to the Windows flyout, as shown
    in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制所有内容都在Visual Studio 2017中打开，请遵循两个步骤。首先，在GitHub的项目`readme.md`文件中，你会看到如何制作批处理文件的说明，或者使用相同的行通过在命令提示符中复制粘贴来生成你的VS
    2017项目文件。此外，当编辑器生成这些文件时，如前所述，它将默认为VS 2015，如果你安装了这两个IDE，这可能会非常令人烦恼，因为你可能在VS 2017中工作，然后编辑器会进行构建并尝试在VS
    2015中打开你的项目！你将想要转到编辑器顶部的设置选项卡，打开项目设置，然后在平台下滚动到Windows展开菜单，如下面的截图所示：
- en: '![](img/f879c0c2-72f7-42f6-b430-1c2f2aa17e1d.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f879c0c2-72f7-42f6-b430-1c2f2aa17e1d.png)'
- en: Select Visual Studio 2017 as the compiler, as shown in the preceding screenshot.
    This should fix the problem of unwanted VS 2015 project files once and for all.
    This is what is checked in to GitHub, and if you are using only VS 2015 or don't
    want this behavior, just go to that same Compiler Version line and set it to Default
    or explicitly back to 2015.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Visual Studio 2017作为编译器，如前一个截图所示。这应该可以一次性解决不想要的VS 2015项目文件问题。这是提交到GitHub的内容，如果你只使用VS
    2015或不想有这种行为，只需转到相同的Compiler Version行，将其设置为默认或明确地设置为2015。
- en: 'So, back in the main editor window, we will add our new class, derived from
    `MasteringCharacter`, by going through the following steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到主编辑窗口，我们将通过以下步骤添加我们的新类，该类是从`MasteringCharacter`派生出来的：
- en: From the top menu bar, click File and select New C++ Class.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部菜单栏中，点击文件并选择新建C++类。
- en: In the Choose Parent Class window, click the Show All Classes box on the top
    right.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择父类窗口中，点击右上角的Show All Classes框。
- en: In the Search field, start typing MasteringCh until it shows only MasteringCharacter,
    and then click on this option.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中，开始输入`MasteringCh`，直到它只显示MasteringCharacter，然后点击此选项。
- en: Make sure that the Selected Class field reads Mastering Character and click
    Next.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Selected Class字段显示为Mastering Character，然后点击下一步。
- en: Change its name from MyMasteringCharacter to StealthCharacter and click Create
    Class.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其名称从MyMasteringCharacter更改为StealthCharacter，然后点击创建类。
- en: In step 1, note that you can also access the New C++ Class option from the popup
    by simply right-clicking in a normal content browser window. Also, in step 2,
    over time it will just become a habit for you to always immediately click the
    Show All Classes box. It is nice that Epic Games filters it to some useful classes
    by default for new users, but as projects grow, you are typically using your own
    custom classes far more than these.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 中，请注意，你也可以通过在正常内容浏览器窗口中右键单击来从弹出菜单访问“新 C++ 类”选项。此外，在步骤 2 中，随着时间的推移，你将养成立即点击显示所有类框的习惯。Epic
    Games 默认为新手过滤了一些有用的类，但项目增长后，你通常使用自己的自定义类比这些类多得多。
- en: The editor should then tell you that it is compiling the new C++ code, and notify
    you when it has finished successfully on the bottom right. One very important
    note to bear in mind with this hot-reload concept is that if you now return to
    Visual Studio, it will want to reload the game project solution. This will prompt
    you to stop debugging, and if you say yes, it will close the editor! A technique
    I frequently use is just to attach and detach the debugger to the editor as needed.
    In VS, under the Debug menu is the Detach All command (I like this bound to *Ctrl *+ *D*).
    This allows the editor to continue, and you can reload the solution safely as
    many times as needed. Once you want to debug some code, just reattach it to the
    running editor. To do this, go back to Debug and Attach it to Process (I like
    this bound to *Alt* + *D*). Click in the big field of Processes, and just tap
    the *U* key, and look for `UE4Editor.exe`. Double click this, and you are right
    back to debugging.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编辑器应该会告诉你它正在编译新的 C++ 代码，并在底部右端通知你编译成功。关于这个热重载概念的一个重要注意事项是，如果你现在返回 Visual
    Studio，它将想要重新加载游戏项目解决方案。这将提示你停止调试，如果你选择是，它将关闭编辑器！我经常使用的一种技术是，根据需要将调试器附加到或从编辑器断开连接。在
    VS 中，在调试菜单下是断开所有命令（我喜欢将其绑定到 *Ctrl* + *D*）。这允许编辑器继续，你可以安全地根据需要多次重新加载解决方案。一旦你想调试一些代码，只需将其重新附加到正在运行的编辑器即可。要做到这一点，回到调试并选择附加到进程（我喜欢将其绑定到
    *Alt* + *D*）。点击进程的大字段，轻按 *U* 键，查找 `UE4Editor.exe`。双击此进程，你就可以立即回到调试状态。
- en: Editing our class in VS and hot-reloading the editor
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 VS 中编辑我们的类并热重载编辑器
- en: 'So, now that our class is added with the MasteringCharacter as its parent,
    let''s edit it in C++ and see our changes over in the editor. I suggest detaching
    the debugger as described in the last paragraph, but stopping debugging and restarting
    the editor is not a problem if you decide to do that. If you do detach, note that
    you need to right-click on the Mastering project in the solution explorer, select
    Unload Project, and then right-click it again and click on Reload Project to make
    sure that everything matches the current state (this is much faster than closing
    and reopening VS). In the solution explorer, you can now find the `StealthCharacter.h`
    and `.cpp` files under Source/Mastering. Open these. There''s not much to them
    yet, but let''s quickly add a new variable so that we can go look at it in the
    editor later. Add the following lines in the `StealthCharacter.h` file after the
    `GENERATED_BODY()` line:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们的类已经添加了 `MasteringCharacter` 作为其父类，让我们用 C++ 编辑它，并在编辑器中查看我们的更改。我建议按照上一段描述的方式断开调试器，但如果你决定这样做，停止调试并重新启动编辑器也没有问题。如果你断开了连接，请注意，你需要在解决方案资源管理器中右键单击
    `Mastering` 项目，选择卸载项目，然后再次右键单击它并点击重新加载项目，以确保一切与当前状态匹配（这比关闭和重新打开 VS 快得多）。在解决方案资源管理器中，你现在可以在
    Source/Mastering 下找到 `StealthCharacter.h` 和 `.cpp` 文件。打开这些文件。目前它们的内容不多，但让我们快速添加一个新变量，这样我们就可以在编辑器中稍后查看它。在
    `StealthCharacter.h` 文件中 `GENERATED_BODY()` 行之后添加以下行：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Back in Visual Studio, we will add the following to `StealthCharacter.h` after
    the `StealthPitchYawScale` variable that we added earlier:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 Visual Studio，我们将在之前添加的 `StealthPitchYawScale` 变量之后添加以下内容到 `StealthCharacter.h`
    文件中：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we are following the patterns from `MasteringCharacter`, which you can
    study further, but the short version is that we will bind a new input to two functions
    (`Stealth` and `UnStealth`), then override a base class''s functions for using
    yaw and pitch input to slow these down by our scale. We will do this by adding
    the following code to `StealthCharacter.cpp`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遵循了来自 `MasteringCharacter` 的模式，你可以进一步学习，但简而言之，我们将一个新的输入绑定到两个函数（`Stealth`
    和 `UnStealth`），然后覆盖基类的函数，使用偏航和俯仰输入来通过我们的比例减慢这些动作。我们将通过在 `StealthCharacter.cpp`
    中添加以下代码来实现这一点：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Most of this should be clear to experienced UE4 C++ programmers, but do note
    that our overridden functions for `Stealth` and `UnStealth` call existing functions
    in the `ACharacter` class that we distantly derive from. This uses existing mechanics
    to crouch and uncrouch our character, saving us the trouble of making these ourselves.
    You can build the project now, or after adding the following input, which causes
    an editor restart anyway, so make sure you did indeed save the editor changes
    that we made!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有经验的UE4 C++程序员来说，这些内容应该都很清楚，但请注意，我们为`Stealth`和`UnStealth`重写的函数调用了我们从其间接派生的`ACharacter`类中的现有函数。这使用了现有的机制来蹲下和站起我们的角色，从而节省了我们自己制作这些功能的麻烦。你现在可以构建项目，或者添加以下输入后，这会导致编辑器重启，所以请确保你确实保存了我们所做的编辑器更改！
- en: 'There are two ways to add our new input binding. The best way is to once again
    open Project Settings in the Settings tab in the main editor window. From here,
    scroll to Engine and Input in the flyouts, and you will see a section for Bindings on
    the right, and under it, Action Mappings. Click the small plus symbol to the right
    of Action Mappings and it will display a new line under it. We will rename the
    NewActionMapping that it added to Stealth, and then we will click the small plus
    symbol to the right of our new Stealth line. Click the None drop-down menu and
    scroll down to Left Shift, as shown in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 添加我们的新输入绑定有两种方法。最好的方法是再次在主编辑器窗口的设置选项卡中打开项目设置。从这里，滚动到展开菜单中的引擎和输入，你将在右侧看到一个绑定部分，其下是动作映射。点击动作映射右侧的小加号符号，它将在其下方显示一行新内容。我们将将其添加的`NewActionMapping`重命名为Stealth，然后点击我们新Stealth行右侧的小加号符号。点击无下拉菜单并向下滚动到以下截图所示的左Shift：
- en: '![](img/7e9055f3-072d-4d63-a767-9399dac74adb.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/7e9055f3-072d-4d63-a767-9399dac74adb.png)'
- en: We have now bound the action named Stealth to the left *Shift* key of the keyboard.
    This will add a line to the game's `/Config/DefaultInput.ini` file and update
    the running editor version at the same time. If you were to instead manually add
    this line right at the top after `[/Script/Engine.InputSettings] `(that is, +ActionMappings=(ActionName="Stealth",
    Key= Left Shift)) and then save that file, the engine will not automatically reload
    the `.ini` files, which requires the relaunching of the editor to pick up the
    changes, if you were to modify it this way! So, always remember to try to edit
    settings from the Settings window, and if you do modify things in a `.ini` file,
    always remember to restart any running editor or standalone versions of the game
    on your PC to pick those up.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将名为Stealth的操作绑定到键盘的左*Shift*键。这将向游戏的`/Config/DefaultInput.ini`文件中添加一行，并同时更新正在运行的编辑器版本。如果你要手动添加此行，直接在`[/Script/Engine.InputSettings]`之后（即，+ActionMappings=(ActionName="Stealth",
    Key= Left Shift)）并保存该文件，则引擎不会自动重新加载`.ini`文件，这需要重新启动编辑器以获取更改，如果你以这种方式修改它！所以，始终记得尝试从设置窗口编辑设置，如果你确实在`.ini`文件中修改了东西，始终记得重新启动任何正在运行的编辑器或PC上的独立游戏版本以获取这些更改。
- en: We need one last change in our `FirstPersonCharacter` blueprint to bring things
    all together, so open it in the full blueprint editor window again. At the bottom
    left, under its Components tab, is `CharacterMovement` (`Inherited`). Click on
    this. There are now many properties on the right, but scroll down until you see
    the Nav Movement flyout and open it. At the top, there is the Movement Capabilities
    flyout, and in that we need to check the Can Crouch checkbox so that it is true.
    Note that the Compile button near the top left went from having a green checkmark
    to having an orange question mark. Click the Compile button to update the blueprint
    with this change and press *Ctrl* + *S* again to save.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的`FirstPersonCharacter`蓝图中进行最后一次修改，以便将所有内容整合在一起，因此再次在完整的蓝图编辑器窗口中打开它。在左下角，在其组件选项卡下，是`CharacterMovement`（`继承的`）。点击它。现在右侧有许多属性，但向下滚动直到你看到导航移动展开菜单并打开它。在顶部，有移动能力展开菜单，在那里我们需要勾选`Can
    Crouch`复选框，使其为真。注意，靠近左上角的编译按钮从带有绿色勾选标记变为带有橙色问号。点击编译按钮以更新蓝图中的此更改，并再次按*Ctrl* + *S*保存。
- en: Now, when running the game, note that when you press and hold *Shift*, the player's
    perspective moves down a small distance, which is set by a couple of other existing
    blueprint parent class variables, and our turn and pitch speed is slow down by
    our `StealthPitchYawScale`. Success! Now, feel free to modify the pitch and yaw
    scale value, even as the game is running, and see how much we speed up and slowed
    down while stealthed. This is also a great time to set some breakpoints in our
    functions and just step through how things are working on the C++ side, but at
    this stage, our mechanic is in and proven.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当运行游戏时，请注意当你按住*Shift*键时，玩家的视角会向下移动一小段距离，这是由几个其他现有的蓝图父类变量设置的，并且我们的转向和俯仰速度会通过我们的`StealthPitchYawScale`减慢。成功了！现在，你可以自由地修改俯仰和偏航比例值，即使游戏正在运行，看看我们在潜行时速度提高了多少，减慢了多少。这也是在函数中设置一些断点的好时机，并逐步了解C++侧的工作方式，但在这个阶段，我们的机制已经到位并得到了验证。
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have gone from having potentially no engine, zero source
    code, and no projects to having a local build of the UE4 engine and an FPS project
    of our own, and added code and overriding functions to add new gameplay to it.
    This is a great start, and gets us past many of the hurdles in making games and
    gives us a great foundation to build upon in subsequent chapters.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从可能没有引擎、没有源代码和没有项目，发展到拥有本地构建的UE4引擎和我们的FPS项目，并添加了代码和覆盖函数来添加新的游戏玩法。这是一个很好的开始，帮助我们克服了许多制作游戏的障碍，并为后续章节提供了坚实的基础。
- en: Next, we'll be looking much more in-depth at controls and improvements we can
    make on the basics that we mentioned in this chapter. We will also learn how to
    add some more game features, including inventory and weapon pickups. After that,
    there will be a much more in-depth discussion of blueprints and what they do for
    us, why they are so valuable, and when they can be a problem. Rounding out our
    initial efforts in this section, we will look at the UI, loading and saving, and
    adding an AI creature, before we quickly accelerate into several more advanced
    and varied topics in the following chapters!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更深入地探讨控制和改进，我们将在这个章节中提到的基本内容上实现。我们还将学习如何添加更多游戏功能，包括库存和武器拾取。之后，将更深入地讨论蓝图及其为我们做什么，为什么它们如此有价值，以及它们何时可能成为问题。在本节初步工作的最后，我们将查看UI、加载和保存，以及添加一个AI生物，然后在接下来的章节中快速进入几个更高级和多样化的主题！
- en: Questions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Work through the following questions to test what you have learned:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下问题来测试你所学到的内容：
- en: What are some advantages to building the engine from source code?
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从源代码构建引擎有哪些优点？
- en: Where is the source code for UE4 found?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UE4的源代码在哪里可以找到？
- en: What step always needs to be done after getting any updated version of UE4 before
    building anything?
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建任何内容之前，获取任何UE4更新版本后，总是需要执行哪个步骤？
- en: How are variables exposed in the blueprint declared in C++?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C++中声明的蓝图变量是如何暴露的？
- en: How do we quickly add and test our functionality without needing to create a
    new blueprint in the editor?
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何快速添加和测试我们的功能，而无需在编辑器中创建新的蓝图？
- en: Why is DebugGame a good choice to use as your configuration during development?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在开发期间使用DebugGame作为配置是一个好的选择？
- en: Why is requiring changes to `.ini` files in order to add new features a poor
    choice?
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要求修改`.ini`文件以添加新功能是一个不好的选择？
- en: When changing a blueprint property, what step do you have to perform before
    saving it?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更改蓝图属性之前，你必须在保存之前执行什么步骤？
- en: Further reading
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://docs.unrealengine.com/en-us/Programming/Introduction](https://docs.unrealengine.com/en-us/Programming/Introduction)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.unrealengine.com/en-us/Programming/Introduction](https://docs.unrealengine.com/en-us/Programming/Introduction)'
