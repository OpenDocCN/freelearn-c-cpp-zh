- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Premade Patterns in UE5 – Component, Update Method, and Behavior Tree
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UE5中的预制图案 – 组件、更新方法和行为树
- en: This chapter will focus on the three main patterns widely used in game development
    that Unreal Engine 5 offers robust support and tools for, including pre-built
    implementations and editors – namely the **component**, **update method**, and
    **behavior tree** patterns. We will discuss the theory of why they exist and explore
    how you can implement them with guided exercises in our custom framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍在游戏开发中广泛使用且虚幻引擎5提供强大支持和工具的三个主要模式，包括预构建实现和编辑器——即**组件**、**更新方法**和**行为树**模式。我们将讨论它们存在的原因，并探讨如何在我们自定义框架中通过指导练习来实现它们。
- en: Understanding the tools at your disposal will improve your development speed,
    saving you from reinventing the proverbial wheel. Even if these are tools you
    are familiar with in Blueprint, some insight into the C++ workings will hopefully
    improve your effectiveness wherever you use them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你手头的工具将提高你的开发速度，让你免于重新发明轮子。即使这些工具你在蓝图（Blueprint）中已经很熟悉，对C++工作原理的一些了解也许能提高你在任何地方使用它们的效率。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding and creating components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和创建组件
- en: Applying the update method for prototyping gameplay
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用更新方法进行游戏原型设计
- en: Working with behavior trees
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用行为树
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need to download the starter RTS framework from the
    [*Chapter 4*](B18297_04.xhtml#_idTextAnchor057) branch of the GitHub repository,
    which can be downloaded from [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter04](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter04)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要从GitHub仓库的[*第4章*](B18297_04.xhtml#_idTextAnchor057)分支下载起始RTS框架，该框架可以从[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter04](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter04)下载。
- en: We will be building elements for this framework in the following chapters, building
    up a series of gameplay features using patterns as we explore them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将构建此框架的元素，在探索它们的同时，使用模式构建一系列游戏功能。
- en: Understanding and creating components
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和创建组件
- en: One of the first things you learn when programming is to try to never repeat
    yourself. In fact, every technique you learn, from loops to functions to class
    encapsulation, is focused on reusing code with less typing. Building up the analogy,
    a loop reuses lines of code in one area so that you don’t need to repeat them
    next to each other. A function reuses blocks of code so that you don’t need to
    repeat them across your class. Then a class lets you reuse sets of functions and
    data in instances, so you don’t need to repeat logic across your program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编程时，你首先学到的事情之一是尽量避免重复。实际上，你学到的每一种技术，从循环到函数到类封装，都专注于以更少的输入重复使用代码。建立这个类比，一个循环在某个区域重复使用代码行，这样你就不需要重复它们。一个函数重复使用代码块，这样你就不需要在你的类中重复它们。然后一个类让你可以在实例中重复使用函数和数据集，这样你就不需要在你的程序中重复逻辑。
- en: How does this help? Well, in games, any object that can be seen probably has
    some rendering element allowing it to be drawn to the screen. The code for rendering
    your object in your chosen graphics pipeline follows a standardized structure
    and is likely to be the same across every object that needs to be rendered. Even
    thinking about this possible repetition should be ringing alarm bells. Initially,
    it is a waste of your time to write out the same lines multiple times in different
    places. Then, if you need to make a structural change later down the line, you
    suddenly have a scavenger hunt trying to find all the places it needs to be changed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何帮助？在游戏中，任何可见的对象可能都有一些渲染元素，允许它被绘制到屏幕上。你在所选图形管线中渲染对象的代码遵循标准化的结构，并且可能在每个需要渲染的对象中都是相同的。甚至仅仅考虑这种可能的重复都应该让你警钟长鸣。最初，在多个地方多次写出相同的行是浪费时间。然后，如果你稍后需要做出结构性的更改，你突然会发现自己在寻找所有需要更改的地方，这就像一场寻宝游戏。
- en: There is a better way.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有更好的方法。
- en: Enter, the component pattern. Essentially, we utilize the reusable aspect of
    classes as described previously to encapsulate all logic around a repeatable behavior.
    This forms a sort of building block template that we can instance and reference
    in many places. When the time comes to update the logic, it exists in only one
    place and will affect all areas that reference it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 进入，组件模式。本质上，我们利用之前描述的类的可重用性来封装围绕可重复行为的所有逻辑。这形成了一种构建块模板，我们可以在许多地方实例化和引用。当需要更新逻辑时，它只存在于一个地方，并将影响所有引用它的区域。
- en: Practically, this also makes our code around this functionality cleaner. Components
    are generally designed to be completely self-contained, which means that our collision
    code will deal with context for us and the rendering component will deal with
    linking model and texture assets together with materials. This leads to fewer
    checks needed before calling functions on these components and reduces unintended
    behavior.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这也使得围绕此功能周围的代码更简洁。组件通常设计为完全自包含的，这意味着我们的碰撞代码将为我们处理上下文，渲染组件将处理将模型和纹理资产与材质一起链接。这导致在调用这些组件上的函数之前需要的检查更少，并减少了意外行为。
- en: For instance, when dealing with collision checks between two objects, you don’t
    need to find out what shape collider objects A and B have before checking if they
    can collide; the code for deciphering that is contained in the collider component
    itself. You also only get collision signals from the collider component; it doesn’t
    make your model flash when it collides with something. Using components effectively
    can lead to a modular code architecture that will be key to getting the most out
    of a large engine such as Unreal with a team of developers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当处理两个对象之间的碰撞检查时，您不需要在检查它们是否可以碰撞之前找出对象A和B的形状碰撞器；解析这个的代码包含在碰撞组件本身中。您也只从碰撞组件获得碰撞信号；它不会在模型与某物碰撞时使您的模型闪烁。有效地使用组件可以导致模块化代码架构，这对于充分利用像Unreal这样的大型引擎以及开发者团队至关重要。
- en: Important note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Notice how this links back to the single responsibility principle from our SOLID
    principles of code back in [*Chapter 2*](B18297_02.xhtml#_idTextAnchor031). Good
    patterns almost always reflect these principles. In this case, our components
    do one thing each that makes our code modular, and therefore, more useful.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个链接是如何回到我们SOLID原则中的单一职责原则的[*第2章*](B18297_02.xhtml#_idTextAnchor031)。好的模式几乎总是反映这些原则。在这种情况下，我们的组件各自完成一项任务，使我们的代码模块化，因此更有用。
- en: 'Unreal Engine 5 is based on what is called an `BP_TopDownCharacter3` has the
    following components:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 5基于所谓的`BP_TopDownCharacter3`，具有以下组件：
- en: '**Capsule** – set as the root; it describes the shape of the object for the
    physics engine'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**胶囊** – 设置为根组件；它描述了物体在物理引擎中的形状'
- en: '**Mesh** – holds all the data for how to render the object to the screen'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格** – 存储了将对象渲染到屏幕上的所有数据'
- en: '**Spring arm** – dynamic component for holding objects at a distance'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹簧臂** – 用于在距离处保持物体的动态组件'
- en: '**Camera** – attached to the spring arm, this describes the position and settings
    of the camera to render the screen'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相机** – 附着到弹簧臂上，描述了相机的位置和设置以渲染屏幕'
- en: Components vary in importance and size. The preceding list shows how a spring
    arm component, which is relatively small and unimportant, can be used with a larger,
    more important component such as the camera within the same actor. Size doesn’t
    dictate importance though, so let’s have a look at the first component you may
    create to make your development a touch easier – a `health` component. Our aim
    is to make a simple-to-use tool for designers to drop onto any actor, giving them
    the ability to track a health value, which is attached to the built-in damage
    system. The component should also provide hooks for notifying when damage has
    been taken and when the health value hits zero.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 组件在重要性和大小上有所不同。前面的列表显示了如何使用弹簧臂组件，这是一个相对较小且不重要的组件，可以与较大的、更重要的组件（如同一演员中的相机）一起使用。大小并不决定重要性，所以让我们看看您可能创建的第一个组件，以使您的开发变得更容易——一个`健康`组件。我们的目标是创建一个简单易用的工具，让设计师可以将其放置在任何演员上，使他们能够跟踪一个健康值，该值附加到内置的损伤系统。该组件还应提供挂钩，用于在受到伤害和健康值达到零时通知。
- en: With the example framework open, click on **Tools** | **New** **C++ Class…**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开示例框架后，点击**工具** | **新建** **C++类…**。
- en: 'You will be presented with the following window, showing all the parent classes
    you can extend:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个窗口，显示您可以扩展的所有父类：
- en: '![Figure 4.1 – Window for choosing a class to inherit from](img/Figure_04.01_B18297.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Window for choosing a class to inherit from
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: We are interested in **Actor, Component** so select that and click on **Next**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following window, we will name the component something sensible such
    as `HealthComponent`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Window for naming and scoping a new C++ class](img/Figure_04.02_B18297.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Window for naming and scoping a new C++ class
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the settings don’t matter for this example, but they do impact the
    scope of our component. This is only something you need to be concerned with if
    you are building large projects with multiple sub-systems that may need to cross-reference
    classes. For now, let the settings be as is and click on **Create Class**. This
    will launch the IDE Unreal is linked to, which by default is Microsoft Visual
    Studio.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: While tools such as Visual Studio are great IDEs, at the time of writing, there
    is none better than JetBrains Rider for Unreal development. As of the 2022 version,
    Unreal-specific structures are built into their code auto-completer and error
    checker. However, this software is not free, so if you are using Visual Studio,
    then note that some of your code may display errors, but it will build and run
    fine.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'With the class open, you should have a header (`.h`) and a body (`.cpp`) file.
    We will start by discussing requirements drawn from our task aim and building
    our header. Our component needs to do the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Contain a value for health
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to receive a damage signal
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notify when taking damage and when dead
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tackling our value for health is easy: we only need to define a float variable
    to track the current value and another to allow setting of the maximum value from
    the editor. With that in mind, setting the property specifiers in the `UPROPERTY`
    block is the most important part. Taking damage is also quite simple as Unreal
    Engine 5 has a damage interface system that proliferates every `AActor`. To hook
    into this, all you need is a function that shares a signature with the `OnTakeAnyDamage`
    event, as shown in the following `HealthComponent.h` code snippet. Lastly, to
    notify the owning `AActor` that the component has taken damage or is out of health,
    we will use some dynamic multicast delegates. These will be covered more in [*Chapter
    6*](B18297_06.xhtml#_idTextAnchor076) when we look into clean communication, but
    for now, think of them as smoke signals coming from the component that the owning
    `AActor` can watch for.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s write the code in the header file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: HealthComponent.h
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we need to fill out the function definitions for the constructor, `BeginPlay`
    and `DamageTaken`. The constructor is simple enough as it just sets advised values
    for designers. Here, we only set the max health. `BeginPlay` is a little more
    interesting. Shown in the following code block, `BeginPlay` is where we link our
    damage function to the event in the owning `AActor`. `DamageTaken` does all the
    work in this component, but it is equally simple, with two lines being taken for
    ‘‘Broadcast’’-ing the delegates.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要填写构造函数、`BeginPlay`和`DamageTaken`的函数定义。构造函数很简单，因为它只是为设计师设置建议值。在这里，我们只设置了最大生命值。"BeginPlay"稍微有趣一些。在下面的代码块中显示的"BeginPlay"是我们将伤害函数链接到拥有`AActor`的事件的地方。"DamageTaken"在这个组件中做所有的工作，但它同样简单，只用了两行代码来“广播”代表。
- en: Important note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We will be looking in more depth at what events do and what some of the terminology
    means later, in [*Chapter 6*](B18297_06.xhtml#_idTextAnchor076). For now, the
    important aspect is that this component does function the way we need it to.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](B18297_06.xhtml#_idTextAnchor076)中更深入地探讨事件的功能以及一些术语的含义。目前，重要的是这个组件确实以我们需要的功能运行。
- en: 'Let''s add those to the body file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这些添加到主体文件中：
- en: HealthComponent.cpp
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: HealthComponent.cpp
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To use this component, head into a Blueprint class and click the `Component`
    should find it. Then, after adding it, you can link logic into it by clicking
    the green plus buttons next to the events we made in C++:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个组件，进入蓝图类，点击`Component`应该能找到它。然后，在添加它之后，你可以通过点击旁边的事件的绿色加号按钮将逻辑链接到它：
- en: '![Figure 4.3 – Delegates created in C++ showing in the Blueprint editor window](img/Figure_04.03_B18297.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 在C++中创建的委托在蓝图编辑器窗口中显示](img/Figure_04.03_B18297.jpg)'
- en: Figure 4.3 – Delegates created in C++ showing in the Blueprint editor window
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 在C++中创建的委托在蓝图编辑器窗口中显示
- en: As a final note on this pattern, you may also have heard the term ECS bandied
    around with games such as *Doom Eternal* and *Overwatch*, but this is slightly
    different from Unreal’s implementation. The ECS being spoken about there is what
    we call *data-oriented* ECS. This means that components store only data. The systems
    are the functions and are stored separately. Then the systems run on archetypes
    of components we call entities. Entities are stored contiguously in memory, which
    makes processing systems across large arrays of entities much faster and even
    possible to easily multi-thread.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个模式的最后一点，你可能也听说过ECS这个术语，尤其是在像《Doom Eternal》和《Overwatch》这样的游戏中，但它在Unreal的实现中略有不同。那里所说的ECS就是我们所说的*面向数据*的ECS。这意味着组件只存储数据。系统是函数，并且单独存储。然后系统在被称为实体的组件的原型上运行。实体在内存中连续存储，这使得处理大量实体的系统变得更快，甚至可以轻松地多线程处理。
- en: The trade-off with this is that, while in principle it sounds simple, in practice
    it is a paradigm shift in how to approach programming as large as the jump from
    the linear *hello world* style programs with everything in one file to object-oriented
    projects with many classes and complex internal structures. This, combined with
    the infancy of the approach, means it is not practical to develop a large game
    and expect the entire programming team to hit the ground running with this system.
    If you would like to learn more about full data-oriented ECS, then there are plenty
    of resources on the topic. The keywords for proper research into the topic would
    be data-oriented, archetypes, and ECS, in some order, but due to the low adoption
    rate of the technique, resources are generally either terse or surface-level.
    The concept is best learned practically by pulling the ENTT C++ library apart
    to see how it implements the pattern. This is best for practical learners as it
    is a raw implementation with no other distractions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相对应的是，虽然从原则上听起来很简单，但在实践中，它是在编程方法上的一个范式转变，就像从线性*hello world*风格程序（所有内容都在一个文件中）到具有许多类和复杂内部结构的面向对象项目一样。这一点加上这个方法的初级阶段意味着，开发大型游戏并期望整个编程团队能够立即使用这个系统是不切实际的。如果你想了解更多关于完整数据导向ECS的信息，那么关于这个主题的资源很多。进行适当研究的关键词应该是数据导向、原型和ECS，顺序可以有所不同，但由于这种技术的采用率较低，资源通常要么简短，要么只是表面上的。这个概念最好通过实际操作，拆解ENTT
    C++库来学习它是如何实现这个模式的。这对于实际学习者来说是最好的，因为它是一个原始实现，没有任何其他干扰。
- en: Components are everywhere in modern game design, and now you should have some
    understanding of how to structure your code with them. Another ubiquitous tool
    in your developer belt is the update method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代游戏设计中，组件无处不在，现在你应该对如何使用它们来结构化你的代码有一些了解。你开发者工具包中的另一个通用工具是更新方法。
- en: Applying the update method for prototyping gameplay
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用更新方法进行游戏原型设计
- en: 'The update method is all about abstraction. Let’s learn through an example.
    Imagine building a *Pong* clone with only rudimentary knowledge of C++. It might
    look something like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 更新方法完全是关于抽象。让我们通过一个例子来学习。想象一下，仅用基本的C++知识构建一个 *Pong* 克隆。它可能看起来像这样：
- en: Naïve Pong code
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 天真的Pong代码
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code may work for *Pong* but the problem is pretty clear. As you add more
    and more types of objects to your game, the ways you have to deal with every frame
    balloons your code. This is not sustainable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能适用于 *Pong*，但问题很清楚。随着你向游戏中添加更多类型的对象，处理每一帧的方法数量也在增加，这使得代码变得不可持续。
- en: 'The solution can be found in the minds of every person with an overbearing
    micro-managing boss: “*Just let me do my job.*” In this situation, the main loop
    is the manager, and the entities are sitting on the sidelines. They exist but
    are largely having logic run at them rather than on them. Why not trust these
    experts and make each entity responsible for the logic under its namesake? We
    keep a list of references in the main loop, but we forget who each of them are
    and resort to referencing them as numbers, or indexes in an array.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案可以在每个有过度微观管理老板的人的头脑中找到：“*只让我做我的工作.*”在这种情况下，主循环是经理，实体们坐在一旁。它们存在，但主要是逻辑在它们身上运行，而不是它们自己运行。为什么不信任这些专家，让每个实体对其名称下的逻辑负责呢？我们在主循环中保留一个引用列表，但我们忘记了它们是谁，并退而求其次，用数字或数组中的索引来引用它们。
- en: 'This new impersonal approach frees up the main loop to go through all entities
    and call a shared `Update()` method on them all. Each entity can now deal with
    its own world within its own override of the `Update` function. The following
    code snippet is an example of how you might manage this new approach:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的非个人化方法让主循环能够遍历所有实体，并对它们调用共享的 `Update()` 方法。现在，每个实体都可以在其自己的 `Update` 函数重写中处理其自己的世界。以下代码片段是展示如何管理这种新方法的示例：
- en: Better Pong code
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的Pong代码
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unreal Engine’s implementation of `Update` is called “`Tick`.” It fires once
    every rendered frame and allows developers to provide each actor they make with
    a different behavior. There is, however, a big issue with the update method pattern,
    which is why we will be exploring it in more depth in [*Chapter 5*](B18297_05.xhtml#_idTextAnchor068).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 对 `Update` 的实现被称为 “`Tick`”。它会在每一帧渲染时触发一次，允许开发者为每个创建的actor提供不同的行为。然而，更新方法模式存在一个重大问题，这就是为什么我们将更深入地探讨它，见[*第5章*](B18297_05.xhtml#_idTextAnchor068)。
- en: Now that we’ve covered the update method pattern, we are going to move on to
    the implementation of the behavior tree pattern in Unreal Engine 5 by exploring
    the behavior tree system inside the Unreal Engine editor.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了更新方法模式，我们将继续探讨在Unreal Engine 5中实现行为树模式，通过探索Unreal Engine编辑器中的行为树系统。
- en: Working with behavior trees
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与行为树一起工作
- en: The last pattern for this chapter is a little specific but no less useful than
    the others. Behavior trees define decision trees for AI brains to run. These trees
    define how information stored about the situation the AI thinks it is in will
    affect the actions it takes. Instead of compartmentalizing code into discrete
    blocks like other AI brain solutions, the behavior tree favors fragmentation with
    the aim of reuse. This flows back to the idea from the beginning of the chapter
    about the reuse of code for efficiency. A tree may look complex with many branches
    and leaves (yes, that is what we call the composites and tasks that make up a
    behavior tree), but on closer inspection, you will see that there are only a few
    building blocks and their arrangement is what creates the illusion of complex
    decision making.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一种模式可能有点具体，但并不比其他模式少用。行为树为AI大脑运行定义决策树。这些树定义了关于AI认为它所处的情境存储的信息将如何影响它采取的行动。与其他AI大脑解决方案将代码分割成离散块不同，行为树倾向于碎片化，目的是为了重用。这回到了本章开头关于代码重用以提高效率的想法。一棵树可能看起来很复杂，有很多分支和叶子（是的，这就是我们称呼组成行为树的复合体和任务），但仔细观察后，你会发现只有几个构建块，它们的排列创造了复杂决策的错觉。
- en: 'The flow through a simple tree starts at the root and evaluates each node in
    the layer below in ascending order from 0 (order matters here) until it gets a
    success response. At this point, the tree knows it has found the correct task
    for its situation and can reset. As mentioned before, there are two types of simple
    nodes: composite and task. Composite nodes direct the flow of logic with their
    own sets of rules, whilst tasks are the actions and can succeed or fail depending
    on the logic contained within them (either in Blueprint or C++ code), and can
    never have a layer below them. The behavior tree executes each node in order until
    they reach the end of the list, or a node fails. They succeed when all their children
    succeed.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: We will be using selector and sequence nodes, both of which are types of composite
    nodes. A selector node executes all of its children from left to right; it stops
    executing when one of its children succeeds. A sequence node also executes all
    of its children from left to right; however, unlike the selector node, it stops
    executing when one of its children fails. There are other more specialized nodes,
    but these two composite nodes are the foundations for any system you could wish
    to design.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'The other composite node type, which we won’t be using, is the **simple parallel**
    node type. The simple parallel node allows you to run two child nodes at the same
    time: one must be a task, and the other can contain a complete sub-tree or branch
    of the behavior tree.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The three types of composite nodes: Selector, Sequence, and
    Simple Parallel](img/Figure_04.04_B18297.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4 – The three types of composite nodes: Selector, Sequence, and Simple
    Parallel'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: A notable use of behavior trees in games is *Halo 2*. As mentioned above, the
    order of the nodes in the tree matters and can radically change how AI behaves
    as it will tend to favor branches higher in the order. To differentiate the varied
    enemy types, Microsoft designed different behavior trees for each one. *Grunts*
    have a higher-order branch for fleeing so they tend to seem more scared, whereas
    *Elites* can re-order their own trees based on what the player is doing to make
    them seem adaptable. Notably, if you get in a vehicle enemy, *Elites* will raise
    the priority of them getting in a vehicle as vehicle-to-vehicle combat is more
    fun than the alternative and vice versa. There are many more tricks going on in
    that game, but this is not the place to continue, so back to UE5.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at building a behavior tree for a simple **real-time strategy** (**RTS**)
    AI in the RTS framework. We will introduce the various building blocks of behavior
    trees, including selectors, sequences, decorators, services, and tasks.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: For this implementation, we are going to use Blueprint to create the service
    (a collection of functions called by a behavior tree node) and tasks as opposed
    to using C++, as the main focus is on the implementation of the behavior tree
    pattern in Unreal Engine 5.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'The framework contains a series of assets that have already been set up for
    you. Any Blueprint logic that we’ve created has been commented, if you would like
    to explore them further. Inside the `Content/RTS/Blueprints` folder, you will
    find a series of unreal assets used to create the basic elements of our RTS example
    game:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 框架包含了一系列已经为您设置好的资产。我们创建的任何蓝图逻辑都已注释，如果您想进一步探索它们。在 `Content/RTS/Blueprints` 文件夹中，您将找到一系列用于创建我们
    RTS 示例游戏基本元素的 Unreal 资产：
- en: '**GM_RTS**: This is the game mode. It contains references to the various classes
    for the framework to work.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GM_RTS**: 这是游戏模式。它包含框架工作所需的各种类的引用。'
- en: '**PC_RTS**: This is the player controller. It contains the functionality to
    left-click selectable units and right-click on the world in order to tell the
    unit where to go.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PC_RTS**: 这是玩家控制器。它包含左键点击可选单位并在世界中右键点击以告诉单位去哪里的功能。'
- en: '**BP_CameraPawn**: This is our pawn. It is a simple pawn blueprint with a camera
    that is set up to be placed directly in the center of the map.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BP_CameraPawn**: 这是我们的小兵。它是一个简单的带有摄像头的兵蓝图，摄像头被设置为直接放置在地图的中心。'
- en: '**BPI_Units:** This is our Blueprint interface. It contains three functions:
    **SetMoveLocation**, **Stop**, and **AttackTarget**:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BPI_Units:** 这是我们的大纲界面。它包含三个功能：**SetMoveLocation**、**Stop** 和 **AttackTarget**：'
- en: '**SetMoveLocation** has a vector input, **Target Location**'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SetMoveLocation** 有一个矢量输入，**目标位置**'
- en: '**AttackTarget** has an object input, **TargetToAttack**'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AttackTarget** 有一个对象输入，**TargetToAttack**'
- en: '**Stop** is just a function name and does not have any inputs or outputs'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stop** 只是一个函数名，没有输入或输出'
- en: '`BPI_Units` Blueprint interface.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BPI_Units` 蓝图界面。'
- en: The skeletal mesh component has been set up to use a green-tinted material instance
    placed on the default mesh, which is inherited from the base character class.
    We are making use of the standard mannequin character mesh here.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 骨骼网格组件已设置为一个放置在默认网格上的绿色色调材料实例，该默认网格是从基础角色类继承的。我们在这里使用的是标准的人形角色网格。
- en: This Blueprint currently contains no functionality.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此蓝图目前没有任何功能。
- en: '**BP_EnemyUnit**: This is a second character blueprint. This is a simple character
    blueprint with no functionality.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BP_EnemyUnit**: 这是一个第二个角色蓝图。这是一个没有功能的简单角色蓝图。'
- en: The skeletal mesh component has been set up with a red-tinted material instance
    so that it is clearly identifiable.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 骨骼网格组件已设置为一个带有红色色调的材料实例，以便清晰识别。
- en: So, we are going to build an AI unit that the player will be able to control.
    The player will only be able to tell the unit where to move. They will do this
    by first selecting the unit using a left-click and then selecting a desired location
    for the unit to move to by right-clicking on the floor.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将构建一个玩家可以控制的 AI 单位。玩家只能告诉单位去哪里移动。他们将通过首先使用左键选择单位，然后通过在地板上右键点击选择单位要移动到的位置来完成此操作。
- en: The unit will then move to the location. When not moving, the unit will search
    to see if any enemy units are within a radius of its current location. If it finds
    an enemy, the unit will then turn to face the enemy and shoot at it (using a simple
    line trace for now).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，单位将移动到该位置。当不移动时，单位将搜索查看是否有敌对单位在其当前位置的半径内。如果它发现敌对单位，单位将转向面对敌对单位并对其射击（目前使用简单的线迹）。
- en: To achieve this, we need to create a series of assets. We are going to create
    an AI controller asset, for which we will create a Blackboard asset that contains
    the variables used inside the behavior tree.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要创建一系列资产。我们将创建一个 AI 控制器资产，为此我们将创建一个包含行为树内部使用的变量的黑板资产。
- en: Creating the AI controller
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 AI 控制器
- en: 'The first thing we need to create is an AI controller Blueprint asset. This
    asset allows us to replace the human controller for a pawn with an AI solution
    using a behavior tree. For this, we need to do the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先创建的是 AI 控制器蓝图资产。此资产允许我们使用行为树用 AI 解决方案替换兵的人类控制器。为此，我们需要执行以下操作：
- en: Inside the Unreal Engine Editor, open the `Content/RTS/Blueprints` folder.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unreal Engine 编辑器内部，打开 `Content/RTS/Blueprints` 文件夹。
- en: Right-click within the folder in the **Content Browser** and create a new **Blueprint
    Class**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **内容浏览器** 中的文件夹内右键单击并创建一个新的 **蓝图类**。
- en: Expand the `AIController`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开 `AIController`。
- en: Select the **AIController** entry from the list and click **Select**.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择 **AIController** 项并点击 **Select**。
- en: '![Figure 4.5 – The Pick Parent Class dialog with the AIController parent class
    selected as the chosen parent class for the new Blueprint](img/Figure_04.05_B18297.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 选择父类对话框，已选择AIController作为新蓝图的选择父类](img/Figure_04.05_B18297.jpg)'
- en: Figure 4.5 – The Pick Parent Class dialog with the AIController parent class
    selected as the chosen parent class for the new Blueprint
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 选择父类对话框，已选择AIController作为新蓝图的选择父类
- en: Name the new Blueprint `AIC_EliteUnit`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的蓝图命名为`AIC_EliteUnit`。
- en: 'Now we have our new AI controller, we now need to set it as the default AI
    controller for the *Elite* unit. This will ensure that whenever an Elite unit
    is spawned or placed within the game, it will have a controller. To assign the
    default AI controller, we need to do the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了新的AI控制器，我们需要将其设置为*精英*单位的默认AI控制器。这将确保每当精英单位被生成或放置在游戏中时，它都将有一个控制器。要分配默认AI控制器，我们需要执行以下操作：
- en: From the `Blueprints` folder, open the **BP_EliteUnit** Blueprint asset.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Blueprints`文件夹中，打开**BP_EliteUnit**蓝图资产。
- en: Click the **Class Defaults** button in the top menu.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部菜单中点击**类默认值**按钮。
- en: In the `AIC_EliteUnit`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AIC_EliteUnit`中。
- en: Now we have an AI controller, we can start building our AI system. Before we
    can create the behavior tree, we first need to set up a **Blackboard** asset.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了AI控制器，我们可以开始构建我们的AI系统。在我们可以创建行为树之前，我们首先需要设置一个**黑板**资产。
- en: Creating the Blackboard asset
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建黑板资产
- en: Blackboards are used to define variables (known as keys) and store their values,
    which will allow our behavior tree to make decisions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 黑板用于定义变量（称为键）并存储它们的值，这将允许我们的行为树做出决策。
- en: 'To create the Blackboard asset, we need to do the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建黑板资产，我们需要执行以下操作：
- en: In the **Content Browser** window, right-click and select **Artificial Intelligence**
    | **Blackboard**.![Figure 4.6 – The Artificial Intelligence options when creating
    a new asset](img/Figure_04.06_B18297.jpg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容浏览器**窗口中，右键单击并选择**人工智能** | **黑板**。![图4.6 – 创建新资产时的人工智能选项](img/Figure_04.06_B18297.jpg)
- en: Figure 4.6 – The Artificial Intelligence options when creating a new asset
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 创建新资产时的人工智能选项
- en: Name the new `BB_EliteUnit`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`BB_EliteUnit`命名。
- en: Open the `BB_EliteUnit` Blackboard asset.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BB_EliteUnit`黑板资产。
- en: 'Add two new keys and set the `MoveToLocation`: `Vector`'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '添加两个新键并设置`MoveToLocation`: `Vector`'
- en: '`TargetEntity`: `Object`'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TargetEntity`: `Object`'
- en: '![Figure 4.7 – The Blackboard asset with two keys](img/Figure_04.07_B18297.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 带有两个键的黑板资产](img/Figure_04.07_B18297.jpg)'
- en: Figure 4.7 – The Blackboard asset with two keys
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 带有两个键的黑板资产
- en: Now that we have our Blackboard setup with our variables (keys), we can go ahead
    and create the behavior tree asset and get building our AI system.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了我们的黑板，并添加了变量（键），我们可以继续创建行为树资产并开始构建我们的AI系统。
- en: Building the behavior tree
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建行为树
- en: 'Now we have our Blackboard, we can create our behavior tree asset and link
    the main assets together:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了黑板，我们可以创建我们的行为树资产并将主要资产链接在一起：
- en: In the **Content Browser** window, right-click and select **Artificial Intelligence**
    | **Behavior Tree**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容浏览器**窗口中，右键单击并选择**人工智能** | **行为树**。
- en: Name the new `BT_EliteUnit`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`BT_EliteUnit`命名。
- en: Open the `BT_EliteUnit` asset.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BT_EliteUnit`资产。
- en: Set the **Blackboard Asset** setting in the **Details** panel to **BB_EliteUnit**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详情**面板中将**黑板资产**设置设置为**BB_EliteUnit**。
- en: '![Figure 4.8 – The Blackboard Asset setting in the Details panel of a Behavior
    Tree](img/Figure_04.08_B18297.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – 行为树详情面板中的黑板资产设置](img/Figure_04.08_B18297.jpg)'
- en: Figure 4.8 – The Blackboard Asset setting in the Details panel of a Behavior
    Tree
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 行为树详情面板中的黑板资产设置
- en: 'Open the `AIC_EliteUnit` Blueprint asset (the AI controller) and activate the
    behavior tree when the unit is possessed using **Event** **On Possess**:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AIC_EliteUnit`蓝图资产（AI控制器），当单位被控制时激活行为树，使用**事件** **On Possess**：
- en: '![Figure 4.9 – Blueprint nodes to run the Behavior Tree when the unit is possessed](img/Figure_04.09_B18297.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9 – 当单位被控制时运行行为树的蓝图节点](img/Figure_04.09_B18297.jpg)'
- en: Figure 4.9 – Blueprint nodes to run the Behavior Tree when the unit is possessed
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – 当单位被控制时运行行为树的蓝图节点
- en: With that done, we now have created the behavior tree asset; we can start building
    the AI system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们现在已经创建了行为树资产；我们可以开始构建AI系统。
- en: Basic movement branch
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本移动分支
- en: 'To start building the brains of our system, we are going to set up the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建我们系统的“大脑”，我们将设置以下内容：
- en: A selector node, which is used to branch out into other sections of the tree
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个选择节点，用于分支到树的其它部分
- en: A sequence node, which allows us to move through multiple tasks, in order, from
    left to right
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个序列节点，它允许我们按顺序从左到右移动多个任务
- en: Our first task, which will use the existing **Move** **To** task
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的第一个任务，将使用现有的**移动到**任务
- en: This will enable our character to be moved around the world. This part of the
    system requires no additional logic, just setting up within the behavior tree
    itself.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的角色能够在世界中移动。这个系统部分不需要额外的逻辑，只需在行为树内部进行设置。
- en: 'So, let’s start building:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始构建：
- en: Open the `BT_EliteUnit` behavior tree.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BT_EliteUnit`行为树。
- en: Drag from the dark gray section at the bottom of the root node and create a
    `RootSelector`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从根节点底部的深灰色部分拖动，创建一个`RootSelector`。
- en: '![Figure 4.10 – Options available when dragging from the root node in the behavior
    tree](img/Figure_04.10_B18297.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10 – 从行为树的根节点拖动时可选的选项](img/Figure_04.10_B18297.jpg)'
- en: Figure 4.10 – Options available when dragging from the root node in the behavior
    tree
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – 从行为树的根节点拖动时可选的选项
- en: From the bottom of the new `MoveToTargetLocation`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的“移动到目标位置”底部。
- en: 'For one final time, drag from the bottom of the new **Sequence** node and add
    **Move To** from the **Tasks** section of the selection popup:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一次，从新的**序列**节点底部拖动，并从选择弹出窗口的**任务**部分添加**移动到**。
- en: '![Figure 4.11 – Behavior tree creation popup with Move To highlighted](img/Figure_04.11_B18297.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11 – 高亮显示“移动到”的行为树创建弹出窗口](img/Figure_04.11_B18297.jpg)'
- en: Figure 4.11 – Behavior tree creation popup with Move To highlighted
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – 高亮显示“移动到”的行为树创建弹出窗口
- en: Set the Blackboard key to `MoveToLocation` – this is the vector key in the Blackboard
    asset.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将黑板键设置为`MoveToLocation` – 这是黑板资产中的向量键。
- en: At the moment, this behavior tree will run; however, the task (*Move To*) will
    try to move the character to `0`,`0`,`0` because we have yet to set a value for
    the **MoveToLocation** key on the Blackboard.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，此行为树将运行；然而，任务（*移动到*）将尝试将角色移动到`0`,`0`,`0`，因为我们还没有在黑板上设置**移动到位置**键的值。
- en: The Blackboard keys can be set from multiple places if you can provide a reference
    to the owner of the Blackboard.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能提供黑板的拥有者引用，黑板的键可以从多个地方设置。
- en: 'We’ve already provided the connection between the player controller Blueprint
    and the `BP_EliteUnit` character. Now we can set up the character to do something
    with those values:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提供了玩家控制器蓝图和`BP_EliteUnit`角色之间的连接。现在我们可以设置角色使用这些值来做一些事情：
- en: Open the `BP_EliteUnit` character Blueprint.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_EliteUnit`角色蓝图。
- en: 'Create a new `Event Possessed` logic chain that casts `AIC_EliteUnit` and then
    stores the reference as a variable called `AIController`. Do this by creating
    the Blueprint nodes as shown (to create the `AIController`):'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的“事件拥有”逻辑链，将“AIC_EliteUnit”进行转换，并将引用存储为名为“AIController”的变量。通过创建蓝图节点来完成此操作（以创建“AIController”）：
- en: '![Figure 4.12 – Event Possessed logic on the BP_EliteUnit character blueprint](img/Figure_04.12_B18297.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12 – BP_EliteUnit角色蓝图上的事件拥有逻辑](img/Figure_04.12_B18297.jpg)'
- en: Figure 4.12 – Event Possessed logic on the BP_EliteUnit character blueprint
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 – BP_EliteUnit角色蓝图上的事件拥有逻辑
- en: From the **Interfaces** section of the **My Blueprint** tab, double-click the
    **Set Move Location** label. This will create an **Event Set Move** **Location**
    node.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“**接口**”部分的双击“**设置移动位置**”标签，位于“**我的蓝图**”选项卡中。这将创建一个**事件设置移动位置**节点。
- en: From the `MoveToLocation`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“移动到位置”。
- en: Drag the`Get Blackboard` node, and from that, add a `Set Value as` `Vector`
    node.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动“获取黑板”节点，然后从该节点添加一个“设置值作为”**向量**节点。
- en: From the `Make Literal Name` node. Set `MoveToLocation` – this is the key name
    on the Blackboard.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“制作文字名称”节点。设置`MoveToLocation` – 这是黑板上的键名。
- en: Use the **MoveToLocation** vector variable as the **Vector** **Value** input.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**移动到位置**向量变量作为**向量值**输入。
- en: '![Figure 4.13 – Event Set Move Location logic on the BP_EliteUnit character
    Blueprint](img/Figure_04.13_B18297.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13 – BP_EliteUnit角色蓝图上的事件设置移动位置逻辑](img/Figure_04.13_B18297.jpg)'
- en: Figure 4.13 – Event Set Move Location logic on the BP_EliteUnit character Blueprint
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 – BP_EliteUnit角色蓝图上的事件设置移动位置逻辑
- en: This logic will, when the event is called, pass `MoveToLocation` key value.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件被调用时，此逻辑将传递“移动到位置”键值。
- en: Repeat this process for the **Stop** interface function from the **Interfaces**
    section of the **My Blueprint** tab, except instead of using a pin on the event
    to set the **MoveToLocation** vector, use a **Get Actor** **Location** node.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程，对于**停止**接口功能，从**我的蓝图**选项卡的**接口**部分，除了使用事件上的引脚设置**MoveToLocation**向量外，使用**获取演员****位置**节点。
- en: '![Figure 4.14 – Event Stop logic on the BP_EliteUnit character Blueprint](img/Figure_04.14_B18297.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – BP_EliteUnit 角色蓝图上的事件停止逻辑](img/Figure_04.14_B18297.jpg)'
- en: Figure 4.14 – Event Stop logic on the BP_EliteUnit character Blueprint
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – BP_EliteUnit 角色蓝图上的事件停止逻辑
- en: 'The last thing left to do is tell the `MoveToLocation` key on the Blackboard:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的最后一件事是告诉黑板上的`MoveToLocation`键：
- en: Select the **Move To** node on the behavior tree.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在行为树上选择**移动到**节点。
- en: In the **Details** panel, check the **Observe Blackboard** **Value** box.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，勾选**观察黑板****值**框。
- en: '![Figure 4.15 – Observe Blackboard Value checked on Move To task node](img/Figure_04.15_B18297.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15 – 在移动到任务节点上勾选观察黑板值](img/Figure_04.15_B18297.jpg)'
- en: Figure 4.15 – Observe Blackboard Value checked on Move To task node
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 在移动到任务节点上勾选观察黑板值
- en: Now that the basic movement is set up, the character can be instructed to move
    around the world. Next, we are going to add a branch to our tree that will focus
    on the shooting part of our system.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本移动已经设置好了，我们可以指示角色在世界中移动。接下来，我们将在我们的树中添加一个分支，专注于我们系统的射击部分。
- en: Shooting branch and task
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 射击分支和任务
- en: 'The next element of the system we are going to build is a means to enable the
    character to shoot enemies. For this, we are going to need to create a new task
    to build into the tree:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的系统中的下一个元素是使角色能够射击敌人的方法。为此，我们需要创建一个新的任务并将其构建到树中：
- en: To start with, click the **New Task** button at the top of the **Behavior Tree**
    editor and select **BTTask_BlueprintBase** from the list.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，点击**行为树**编辑器顶部的**新建任务**按钮，从列表中选择**BTTask_BlueprintBase**。
- en: '![Figure 4.16 – New Task dropdown with BTTask_BlueprintBase selected](img/Figure_04.16_B18297.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16 – 选择 BTTask_BlueprintBase 的新任务下拉菜单](img/Figure_04.16_B18297.jpg)'
- en: Figure 4.16 – New Task dropdown with BTTask_BlueprintBase selected
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – 选择 BTTask_BlueprintBase 的新任务下拉菜单
- en: From the `Blueprints` folder is selected and set the name as `BTT_ShootTarget`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`蓝图`文件夹中选择，并将名称设置为`BTT_ShootTarget`。
- en: '![Figure 4.17 – Save Asset As window for behavior tree tasks](img/Figure_04.17_B18297.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.17 – 为行为树任务保存资产为窗口](img/Figure_04.17_B18297.jpg)'
- en: Figure 4.17 – Save Asset As window for behavior tree tasks
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – 为行为树任务保存资产为窗口
- en: This has now created a behavior tree task asset, which should open automatically.
    If it doesn’t, you will find it as a Blueprint asset in the **Content Browser**.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个行为树任务资产，它应该会自动打开。如果它没有打开，你可以在**内容浏览器**中找到它作为蓝图资产。
- en: With the task created, we now need to add some logic for what the task will
    do.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 任务创建后，我们现在需要添加一些逻辑来定义任务将执行的操作。
- en: A task works by utilizing the `AttackTarget`, which we will set up to just print
    a `Shoot` message for now.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个任务通过利用`AttackTarget`来工作，我们将设置它现在只打印一个`Shoot`消息。
- en: Behavior tree tasks need any logic chains to end with a `Success`. If the logic
    has completed the task, then this should be set to **True**, if it hasn’t, it
    should be set to **False**. For this example, we will only have a **True** result
    as all we are doing is calling an event on the character Blueprint.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树任务需要任何逻辑链以`成功`结束。如果逻辑完成了任务，则应将其设置为**True**，如果没有，则应将其设置为**False**。对于这个例子，我们将只有一个**True**结果，因为我们只是在角色蓝图上调用一个事件。
- en: In the `BTT_ShootTarget` Blueprint, add an **Event Receive Execute AI** node
    either by right-clicking in the viewport and searching for it or by clicking the
    **Override** dropdown that appears on the **Functions** rollout title when you
    hover over it.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BTT_ShootTarget`蓝图中，通过在视图中右键单击并搜索它，或者通过在悬停时点击**函数**展开标题上出现的**覆盖**下拉菜单，添加一个**事件接收执行AI**节点。
- en: Drag from the `AttackTarget` interface event.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`AttackTarget`接口事件拖动。
- en: From the `Get Blackboard Value as Object` node. This will allow us to get the
    value of an object key.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`获取黑板值作为对象`节点。这将允许我们获取对象键的值。
- en: Right-click the `TargetEntity` – it is vital that this matches the name of the
    key on the Blackboard.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`TargetEntity` – 确保这个名字与黑板上的键名匹配至关重要。
- en: Set the `TargetEntity` variable to be **Instance Editable** by clicking the
    eye to the right of the variable type in the **Variables** list.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**变量**列表中变量类型右侧的眼睛将`TargetEntity`变量设置为**实例可编辑**。
- en: '![Figure 4.18 – Instance Editable set to True on the TargetEntity variable](img/Figure_04.18_B18297.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图4.18 – 将TargetEntity变量的Instance Editable设置为True](img/Figure_04.18_B18297.jpg)'
- en: Figure 4.18 – Instance Editable set to True on the TargetEntity variable
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18 – 将TargetEntity变量的Instance Editable设置为True
- en: Add a `Finish Execute` node after **Attack Target** and set **Success** to **True**.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**攻击目标**之后添加一个`Finish Execute`节点，并将**成功**设置为**True**。
- en: '![Figure 4.19 – Complete BTT_ShootTarget Blueprint logic](img/Figure_04.19_B18297.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图4.19 – 完整的BTT_ShootTarget蓝图逻辑](img/Figure_04.19_B18297.jpg)'
- en: Figure 4.19 – Complete BTT_ShootTarget Blueprint logic
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 – 完整的BTT_ShootTarget蓝图逻辑
- en: 'The task is now created. Before we add it to the tree, we need to add a response
    to the interface call on the character. For now, we will just add a `Shoot`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 任务现在已经创建。在我们将其添加到树之前，我们需要在角色的界面调用上添加一个响应。目前，我们只是添加一个`Shoot`：
- en: Open the `BP_EliteUnit` character Blueprint.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_EliteUnit`角色蓝图。
- en: Double-click **AttackTarget** from the **Interfaces** rollout in **My Blueprint**.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**我的蓝图**的**接口**展开中双击**AttackTarget**。
- en: Add a `Print String` node to the new `Hello` with `Shoot`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的`Hello`中添加一个`Print String`节点，并带有`Shoot`。
- en: '![Figure 4.20 – Temporary attack target logic](img/Figure_04.20_B18297.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图4.20 – 临时攻击目标逻辑](img/Figure_04.20_B18297.jpg)'
- en: Figure 4.20 – Temporary attack target logic
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20 – 临时攻击目标逻辑
- en: We will replace this with a proper solution later. For now, this will serve
    the purpose of confirming that the event is being called by the task in the behavior
    tree.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后用合适的解决方案替换它。目前，这将用于确认事件是否由行为树中的任务调用。
- en: 'Now that we have our task and interface event set up, we can add the task to
    the behavior tree:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了任务和界面事件，我们可以将任务添加到行为树中：
- en: Open the `BT_EliteUnit` behavior tree.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BT_EliteUnit`行为树。
- en: Drag from the bottom of the `ShootNearbyTargets`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ShootNearbyTargets`的底部拖动。
- en: Place this new node to the left of the **MoveToTargetLocation** node. This ensures
    that this node is considered first (i.e., it has a higher priority).
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新节点放置在**MoveToTargetLocation**节点的左侧。这确保了这个节点首先被考虑（即，它有更高的优先级）。
- en: Drag from the bottom of the `Rotate to face BB` entry task – this will cause
    the character to face its target.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Rotate to face BB`任务条目的底部拖动，这将使角色面向其目标。
- en: Set the `TargetEntity`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`TargetEntity`。
- en: Drag from the bottom of the `BTT_ShootTarget` task.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`BTT_ShootTarget`任务的底部拖动。
- en: Set the `TargetEntity` if not set automatically.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有自动设置，则设置`TargetEntity`。
- en: '![Figure 4.21 – The behavior tree so far with a new sequence and tasks added](img/Figure_04.21_B18297.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图4.21 – 添加了新序列和任务后的行为树](img/Figure_04.21_B18297.jpg)'
- en: Figure 4.21 – The behavior tree so far with a new sequence and tasks added
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21 – 添加了新序列和任务后的行为树
- en: The main structure of the branches is now complete; what we don’t have, however,
    is any way of identifying and setting the target identity. We are going to use
    a service to find our nearest target and a decorator to identify when the `TargetEntity`
    key has changed in order to choose when to complete the tasks in the `ShootNearbyTargets`
    sequence.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 分支的主要结构现在已经完成；然而，我们还没有任何方法来识别和设置目标身份。我们将使用一个服务来找到最近的目标，并使用一个装饰器来识别当`TargetEntity`键发生变化时，以便选择何时完成`ShootNearbyTargets`序列中的任务。
- en: Identifying enemy targets with a service
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用服务识别敌人目标
- en: To identify the enemies around the character, we are going to place a sphere
    trace within a service on the **RootSelector** selector node. This will provide
    the required information to the decision-making processes below as to what part
    of the tree will run, reducing the need to do tasks that don’t return successes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别角色周围的敌人，我们将在**RootSelector**选择节点上的服务中放置一个球体追踪。这将向下面的决策过程提供所需的信息，以确定树的哪个部分将运行，减少执行不返回成功的任务的需求。
- en: 'So, let’s start by creating a service:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们先创建一个服务：
- en: Click the **New Service** button at the top of the **Behavior** **Tree** editor.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**行为树**编辑器顶部的**新服务**按钮。
- en: Ensure the asset is being saved in the `Blueprint` folder and set `BTS_Find``NearestTarget`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保资产被保存在`Blueprint`文件夹中，并设置`BTS_FindNearestTarget`。
- en: Open the new asset (if it doesn’t open automatically).
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的资产（如果它没有自动打开）。
- en: Create a new float variable called `SearchRadius`, set its default as `500`,
    and make it**Instance Editable**.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的浮点变量名为`SearchRadius`，将其默认值设置为`500`，并使其**Instance Editable**。
- en: Create a new Blackboard key selector variable called `TargetEntity` and make
    it **Instance Editable**. Just like when creating the *Shoot Target* task, it
    is vital this is spelled correctly, matching the Blackboard key name.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的黑板键选择器变量名为`TargetEntity`，并使其**Instance Editable**。就像创建*射击目标*任务时一样，确保拼写正确，与黑板键名称匹配。
- en: Override the **Receive Tick AI** function by either right-clicking on the graph
    and searching for the node or using the override dropdown.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击图表并搜索节点或使用覆盖下拉菜单来覆盖**Receive Tick AI**函数。
- en: 'Add a `Sphere Trace For Objects` node and set it up as shown:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Sphere Trace For Objects`节点，并按照以下设置进行配置：
- en: '![Figure 4.22 – Sphere trace for pawns other than the unit doing the search](img/Figure_04.22_B18297.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图4.22 – 除了搜索单位以外的其他单位的球面追踪](img/Figure_04.22_B18297.jpg)'
- en: Figure 4.22 – Sphere trace for pawns other than the unit doing the search
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22 – 除了搜索单位以外的其他单位的球面追踪
- en: 'Check the `Break Hit Result` node, as shown:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`Break Hit Result`节点，如图所示：
- en: '![Figure 4.23 – Setting Blackboard key for Target Entity to Hit Actor](img/Figure_04.23_B18297.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图4.23 – 为要击中的目标实体设置黑板键](img/Figure_04.23_B18297.jpg)'
- en: Figure 4.23 – Setting Blackboard key for Target Entity to Hit Actor
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23 – 为要击中的目标实体设置黑板键
- en: If the `TargetEntity` key using a **Clear Blackboard Value** node. This can
    be created by dragging from the **TargetEntity** variable node.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用**Clear Blackboard Value**节点来清除`TargetEntity`键。这可以通过从**TargetEntity**变量节点拖动来创建。
- en: The service Blueprint is now complete and looks as shown in the following screenshot.
    If you would like to visualize the sphere trace in order to determine whether
    the **Search Radius** variable is suitable, set the **Draw Debug Type** dropdown
    in the **Sphere Trace For Objects** node to **For** **One Frame**.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 服务蓝图现在已完成，如下截图所示。如果您想可视化球面追踪以确定**搜索半径**变量是否合适，请将**Sphere Trace For Objects**节点中的**Draw
    Debug Type**下拉菜单设置为**For** **One Frame**。
- en: '![Figure 4.24 – Completed service logic](img/Figure_04.24_B18297.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图4.24 – 完成的服务逻辑](img/Figure_04.24_B18297.jpg)'
- en: Figure 4.24 – Completed service logic
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24 – 完成的服务逻辑
- en: 'With the service created, we can now add it to the `Root` selector:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务后，我们现在可以将其添加到`Root`选择器：
- en: In the `BT_EliteUnit` behavior tree, right-click the **RootSelector** node,
    navigate to **Add Service…** and select **BTS Find** **Nearest Target**.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BT_EliteUnit`行为树中，右键点击**RootSelector**节点，导航到**Add Service…**并选择**BTS Find**
    **Nearest Target**。
- en: Make sure the `TargetEntity` and that the search radius is showing as `500`.
    The search variable can be changed depending on the needs of the behavior tree
    it is being added to.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保显示`TargetEntity`和搜索半径为`500`。搜索变量可以根据添加到行为树的需求进行更改。
- en: '![Figure 4.25 – RootSelector with service added](img/Figure_04.25_B18297.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图4.25 – 添加服务后的RootSelector](img/Figure_04.25_B18297.jpg)'
- en: Figure 4.25 – RootSelector with service added
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.25 – 添加服务后的RootSelector
- en: With the service added, the **RootSelector** should now look as shown in the
    preceding screenshot. You may need to rearrange your nodes to accommodate its
    increased size.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 添加服务后，**RootSelector**现在应该看起来与前面的截图所示相同。您可能需要重新排列您的节点以适应其增加的大小。
- en: Now that we have the selector set up to find the nearest target, we can use
    the result of that service to define whether the shooting part of our behavior
    tree can be executed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了选择器以查找最近的目标，我们可以使用该服务的输出结果来定义我们的行为树中的射击部分是否可以执行。
- en: Adding a decorator to activate the shooting sequence
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加装饰器以激活射击序列
- en: 'In order to ensure that the character only tries to rotate and shoot at a target
    that exists, we need to make sure we only run those tasks when `TargetEntity`
    has a valid value (this is why we clear the value when the sphere trace returns
    no hit results). We are going to add a decorator to `ShootNearbyTargets`. A decorator
    (known as a conditional in other behavior tree systems) defines whether a branch
    or node can be executed. We will use the decorator to monitor the `TargetEntity`
    Blackboard key value to see if we have anything to shoot; when we do, the `ShootNearbyTargets`
    sequence can be executed:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保角色只尝试旋转并射击存在的目标，我们需要确保只有在“TargetEntity”具有有效值时才运行这些任务（这就是为什么当球体追踪没有命中结果时我们会清除值）。我们将向“ShootNearbyTargets”添加一个装饰器。装饰器（在其他行为树系统中称为条件）定义了分支或节点是否可以执行。我们将使用装饰器来监控“TargetEntity”黑板键值，看看我们是否有射击的对象；当我们有对象时，可以执行“ShootNearbyTargets”序列：
- en: Right-click the **ShootNearbyTargets** sequence node, navigate to **Add Decorator…**,
    and choose **Blackboard**.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击“ShootNearbyTargets”序列节点，导航到**添加装饰器…**，并选择**黑板**。
- en: Select the decorator (the blue box that has now appeared) and rename the node
    `TargetFound`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择装饰器（现在出现的蓝色框）并重命名节点为“TargetFound”。
- en: Ensure that **Blackboard Key** = **TargetEntity** and **Key Query** = **Is Set**.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保黑板键**Blackboard Key**等于**TargetEntity**，并且**Key Query**等于**Is Set**。
- en: '![Figure 4.26 – The final behavior tree](img/Figure_04.26_B18297.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.26 – 最终的行为树](img/Figure_04.26_B18297.jpg)'
- en: Figure 4.26 – The final behavior tree
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.26 – 最终的行为树
- en: If you now test the system by playing in the viewport, you should be able to
    select and move the green character near either of the red characters. When the
    green character stops, it will find the nearest target, turn, and should create
    a print string of `Shoot`. It will continue to do so until the target is no longer
    valid, which, at this point, will be an eternity as we are not dealing any damage
    to the unit. You also won’t be able to move the character once it finds a target
    because there is currently no way of getting the AI to move away from the `BTT_ShootTarget`
    task.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你现在通过视口播放系统进行测试，你应该能够选择并移动绿色角色靠近红色角色中的任何一个。当绿色角色停止时，它会找到最近的目标，转向，并应该创建一个打印字符串“射击”。它将继续这样做，直到目标不再有效，此时，由于我们不对单位造成伤害，这将是永恒的。你也不会在找到目标后移动角色，因为目前没有方法让AI从“BTT_ShootTarget”任务中移动开。 '
- en: 'To damage the enemy unit, making use of the `Health` component we created earlier,
    we need to replace the `BP_EliteUnit` **Attack Target** event with some logic
    to confirm the line of sight and then apply damage:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要伤害敌方单位，利用我们之前创建的“健康”组件，我们需要将“BP_EliteUnit”的**攻击目标**事件替换为一些逻辑来确认视线，然后应用伤害：
- en: Open the `BP_EliteUnit` character Blueprint.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“BP_EliteUnit”角色蓝图。
- en: Delete the **Print String** node from the **Event Attack Target** logic chain.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“事件攻击目标”逻辑链中删除**打印字符串**节点。
- en: Cast the **TargetToAttack** object to **Actor** in order to get the actor’s
    location and use that as part of a **Line Trace By Channel**, as shown in the
    following screenshot. The line trace has been set up to draw onscreen for 5 seconds
    so we can confirm the trace is happening correctly.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**TargetToAttack**对象投射到**Actor**上，以获取演员的位置，并将其作为**通道追踪**的一部分使用，如图下所示。通道追踪已被设置为在屏幕上绘制5秒钟，以便我们可以确认追踪是否正确发生。
- en: '![Figure 4.27 – Line Trace By Channel setup from shooting actor to target actor](img/Figure_04.27_B18297.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.27 – 从射击演员到目标演员的通道追踪设置](img/Figure_04.27_B18297.jpg)'
- en: Figure 4.27 – Line Trace By Channel setup from shooting actor to target actor
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.27 – 从射击演员到目标演员的通道追踪设置
- en: Create a `Break Hit Result` node from the `Apply Damage` node with `100` `Print
    String` node for `No Line` `of Sight`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“应用伤害”节点创建一个“断点命中结果”节点，并使用“100”个“打印字符串”节点来表示“无视线”。
- en: '![Figure 4.28 – Apply damage to target actor if confirmed. The reroute nodes
    at the bottom left are routed from the As Actor pin of the Cast to Actor node](img/Figure_04.28_B18297.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.28 – 如果确认，则对目标演员应用伤害。底部左边的重定向节点来自“Cast to Actor”节点的“作为演员”引脚](img/Figure_04.28_B18297.jpg)'
- en: Figure 4.28 – Apply damage to target actor if confirmed. The reroute nodes at
    the bottom left are routed from the As Actor pin of the Cast to Actor node
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.28 – 如果确认，则对目标演员应用伤害。底部左边的重定向节点来自“Cast to Actor”节点的“作为演员”引脚
- en: 'Lastly, to enable the enemy unit to be destroyed, we need to utilize the **OnComponentDead**
    event from the **Health** component by linking it to a **Destroy** **Actor** node:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了使敌人单位可以被销毁，我们需要通过将其链接到 **销毁** **演员** 节点来利用 **Health** 组件的 **OnComponentDead**
    事件：
- en: '![Figure 4.29 – Health component death event linked to a Destroy Actor node](img/Figure_04.29_B18297.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.29 – 健康组件死亡事件链接到销毁演员节点](img/Figure_04.29_B18297.jpg)'
- en: Figure 4.29 – Health component death event linked to a Destroy Actor node
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.29 – 健康组件死亡事件链接到销毁演员节点
- en: Next, we will look at the final thoughts.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨最后的想法。
- en: Testing and final thoughts
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试和最后想法
- en: Testing the game now should remove the enemy instead of continually printing
    `Shoot`. This will result in the target entity being cleared, which in turn will
    allow you to move the character again.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试游戏应该会移除敌人而不是持续打印 `Shoot`。这将导致目标实体被清除，从而允许你再次移动角色。
- en: 'While we now have a successful AI-controlled unit that moves and shoots, there
    is one other thing that is worth exploring, which is the `TargetFound` decorator.
    We originally left this set as `None`, which means the unit will complete its
    `shoot` as soon as it detects an enemy with a simple change of this value:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在有一个成功的 AI 控制单位可以移动和射击，但还有另一件事值得探索，那就是 `TargetFound` 装饰器。我们最初将其设置为 `None`，这意味着单位一旦检测到敌人，就会立即完成
    `shoot`，只需简单改变这个值：
- en: Select the `TargetFound` decorator.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `TargetFound` 装饰器。
- en: In the **Details** panel, set the **Notify Observer** to **On** **Result Change**.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **详细信息** 面板中，将 **通知观察者** 设置为 **结果更改**。
- en: Change the **Observer aborts** to **Lower Priority**.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **观察者中止** 更改为 **低优先级**。
- en: Test the game again. You should now see that if you tell the unit to move past
    one of the enemies, it will stop en route to engage with the target. This is because
    the decorator has identified a change in the value of `TargetEntity` from the
    `BTS_FindNearestTarget` service and can now interrupt any lower-priority branch
    of the behavior tree, so any node which is to the right of it in the selector,
    which in this case includes the `MoveToTargetLocation` sequence, which holds the
    **Move** **To** task.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 再次测试游戏。你现在应该能看到，如果你告诉单位移动到敌人之后，它将在前往目标的途中停止，以与目标交战。这是因为装饰器已经识别出 `TargetEntity`
    的值从 `BTS_FindNearestTarget` 服务中的变化，现在可以中断任何行为树中的低优先级分支，因此任何位于选择器右侧的节点，在这个例子中包括
    `MoveToTargetLocation` 序列，它包含 **Move** **To** 任务。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed the game development patterns that are present
    as premade tools and systems inside Unreal Engine. Namely, the component, update,
    and behavior tree patterns.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在虚幻引擎内部作为预制工具和系统存在的游戏开发模式。具体来说，是组件、更新和行为树模式。
- en: We made a `Health` component that will hopefully prove useful in your future
    projects, along with a simple behavior tree showing each major piece of the system.
    Armed with this knowledge, you should be able to make a functional AI system for
    any of your future Unreal projects.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `Health` 组件，希望它在你的未来项目中会很有用，以及一个简单的行为树，展示了系统的每个主要部分。有了这些知识，你应该能够为你的未来虚幻项目制作一个功能性的
    AI 系统。
- en: The next chapter will take what we have learned about the update method and
    explain how we can do better. What is the impact of using `Tick` within the engine
    and how can you measure that impact?
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将解释我们关于更新方法所学的内容，并说明我们如何做得更好。使用引擎中的 `Tick` 的影响是什么？你如何衡量这种影响？
- en: 'Part 2: Anonymous Modular Design'
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：匿名模块化设计
- en: In this part, we will begin creating more efficient code to build modular solutions
    that communicate with each other efficiently and cleanly, without the use of direct
    references and casts.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将开始创建更高效的代码来构建模块化解决方案，这些解决方案可以高效且干净地相互通信，而不使用直接引用和转换。
- en: We will start by reducing the need for gated polling in our code by replacing
    it with cleaner communication methods, and we will explore interfaces and event
    delegates to allow our code to be decoupled. This will culminate in a coding design
    paradigm we call Anonymous Modular Design, which should make our object-oriented
    code the most maintainable and expandable it can be.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过用更干净的通信方法替换代码中的门控轮询来减少对门控轮询的需求，并探索接口和事件委托以允许我们的代码解耦。这将最终形成一个我们称之为匿名模块化设计的编码设计范式，这将使我们的面向对象代码尽可能易于维护和扩展。
- en: 'This part has the following chapters:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分包含以下章节：
- en: '[*Chapter 5*](B18297_05.xhtml#_idTextAnchor068), *Forgetting Tick*'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第五章*](B18297_05.xhtml#_idTextAnchor068)，*遗忘 Tick*'
- en: '[*Chapter 6*](B18297_06.xhtml#_idTextAnchor076), *Clean Communication – Interface
    and Event Observer Patterns*'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18297_06.xhtml#_idTextAnchor076), *清洁沟通 – 接口和事件观察者模式*'
- en: '[*Chapter 7*](B18297_07.xhtml#_idTextAnchor090), *A Perfectly Decoupled System*'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18297_07.xhtml#_idTextAnchor090), *一个完美解耦的系统*'
