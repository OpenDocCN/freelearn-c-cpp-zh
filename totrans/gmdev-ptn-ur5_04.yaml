- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Premade Patterns in UE5 – Component, Update Method, and Behavior Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on the three main patterns widely used in game development
    that Unreal Engine 5 offers robust support and tools for, including pre-built
    implementations and editors – namely the **component**, **update method**, and
    **behavior tree** patterns. We will discuss the theory of why they exist and explore
    how you can implement them with guided exercises in our custom framework.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the tools at your disposal will improve your development speed,
    saving you from reinventing the proverbial wheel. Even if these are tools you
    are familiar with in Blueprint, some insight into the C++ workings will hopefully
    improve your effectiveness wherever you use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and creating components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the update method for prototyping gameplay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with behavior trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need to download the starter RTS framework from the
    [*Chapter 4*](B18297_04.xhtml#_idTextAnchor057) branch of the GitHub repository,
    which can be downloaded from [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter04](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter04)
  prefs: []
  type: TYPE_NORMAL
- en: We will be building elements for this framework in the following chapters, building
    up a series of gameplay features using patterns as we explore them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and creating components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first things you learn when programming is to try to never repeat
    yourself. In fact, every technique you learn, from loops to functions to class
    encapsulation, is focused on reusing code with less typing. Building up the analogy,
    a loop reuses lines of code in one area so that you don’t need to repeat them
    next to each other. A function reuses blocks of code so that you don’t need to
    repeat them across your class. Then a class lets you reuse sets of functions and
    data in instances, so you don’t need to repeat logic across your program.
  prefs: []
  type: TYPE_NORMAL
- en: How does this help? Well, in games, any object that can be seen probably has
    some rendering element allowing it to be drawn to the screen. The code for rendering
    your object in your chosen graphics pipeline follows a standardized structure
    and is likely to be the same across every object that needs to be rendered. Even
    thinking about this possible repetition should be ringing alarm bells. Initially,
    it is a waste of your time to write out the same lines multiple times in different
    places. Then, if you need to make a structural change later down the line, you
    suddenly have a scavenger hunt trying to find all the places it needs to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: There is a better way.
  prefs: []
  type: TYPE_NORMAL
- en: Enter, the component pattern. Essentially, we utilize the reusable aspect of
    classes as described previously to encapsulate all logic around a repeatable behavior.
    This forms a sort of building block template that we can instance and reference
    in many places. When the time comes to update the logic, it exists in only one
    place and will affect all areas that reference it.
  prefs: []
  type: TYPE_NORMAL
- en: Practically, this also makes our code around this functionality cleaner. Components
    are generally designed to be completely self-contained, which means that our collision
    code will deal with context for us and the rendering component will deal with
    linking model and texture assets together with materials. This leads to fewer
    checks needed before calling functions on these components and reduces unintended
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, when dealing with collision checks between two objects, you don’t
    need to find out what shape collider objects A and B have before checking if they
    can collide; the code for deciphering that is contained in the collider component
    itself. You also only get collision signals from the collider component; it doesn’t
    make your model flash when it collides with something. Using components effectively
    can lead to a modular code architecture that will be key to getting the most out
    of a large engine such as Unreal with a team of developers.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Notice how this links back to the single responsibility principle from our SOLID
    principles of code back in [*Chapter 2*](B18297_02.xhtml#_idTextAnchor031). Good
    patterns almost always reflect these principles. In this case, our components
    do one thing each that makes our code modular, and therefore, more useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unreal Engine 5 is based on what is called an `BP_TopDownCharacter3` has the
    following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Capsule** – set as the root; it describes the shape of the object for the
    physics engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mesh** – holds all the data for how to render the object to the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring arm** – dynamic component for holding objects at a distance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Camera** – attached to the spring arm, this describes the position and settings
    of the camera to render the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components vary in importance and size. The preceding list shows how a spring
    arm component, which is relatively small and unimportant, can be used with a larger,
    more important component such as the camera within the same actor. Size doesn’t
    dictate importance though, so let’s have a look at the first component you may
    create to make your development a touch easier – a `health` component. Our aim
    is to make a simple-to-use tool for designers to drop onto any actor, giving them
    the ability to track a health value, which is attached to the built-in damage
    system. The component should also provide hooks for notifying when damage has
    been taken and when the health value hits zero.
  prefs: []
  type: TYPE_NORMAL
- en: With the example framework open, click on **Tools** | **New** **C++ Class…**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be presented with the following window, showing all the parent classes
    you can extend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Window for choosing a class to inherit from](img/Figure_04.01_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Window for choosing a class to inherit from
  prefs: []
  type: TYPE_NORMAL
- en: We are interested in **Actor, Component** so select that and click on **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following window, we will name the component something sensible such
    as `HealthComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Window for naming and scoping a new C++ class](img/Figure_04.02_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Window for naming and scoping a new C++ class
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the settings don’t matter for this example, but they do impact the
    scope of our component. This is only something you need to be concerned with if
    you are building large projects with multiple sub-systems that may need to cross-reference
    classes. For now, let the settings be as is and click on **Create Class**. This
    will launch the IDE Unreal is linked to, which by default is Microsoft Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: While tools such as Visual Studio are great IDEs, at the time of writing, there
    is none better than JetBrains Rider for Unreal development. As of the 2022 version,
    Unreal-specific structures are built into their code auto-completer and error
    checker. However, this software is not free, so if you are using Visual Studio,
    then note that some of your code may display errors, but it will build and run
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the class open, you should have a header (`.h`) and a body (`.cpp`) file.
    We will start by discussing requirements drawn from our task aim and building
    our header. Our component needs to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Contain a value for health
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to receive a damage signal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notify when taking damage and when dead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tackling our value for health is easy: we only need to define a float variable
    to track the current value and another to allow setting of the maximum value from
    the editor. With that in mind, setting the property specifiers in the `UPROPERTY`
    block is the most important part. Taking damage is also quite simple as Unreal
    Engine 5 has a damage interface system that proliferates every `AActor`. To hook
    into this, all you need is a function that shares a signature with the `OnTakeAnyDamage`
    event, as shown in the following `HealthComponent.h` code snippet. Lastly, to
    notify the owning `AActor` that the component has taken damage or is out of health,
    we will use some dynamic multicast delegates. These will be covered more in [*Chapter
    6*](B18297_06.xhtml#_idTextAnchor076) when we look into clean communication, but
    for now, think of them as smoke signals coming from the component that the owning
    `AActor` can watch for.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s write the code in the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: HealthComponent.h
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to fill out the function definitions for the constructor, `BeginPlay`
    and `DamageTaken`. The constructor is simple enough as it just sets advised values
    for designers. Here, we only set the max health. `BeginPlay` is a little more
    interesting. Shown in the following code block, `BeginPlay` is where we link our
    damage function to the event in the owning `AActor`. `DamageTaken` does all the
    work in this component, but it is equally simple, with two lines being taken for
    ‘‘Broadcast’’-ing the delegates.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We will be looking in more depth at what events do and what some of the terminology
    means later, in [*Chapter 6*](B18297_06.xhtml#_idTextAnchor076). For now, the
    important aspect is that this component does function the way we need it to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add those to the body file:'
  prefs: []
  type: TYPE_NORMAL
- en: HealthComponent.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this component, head into a Blueprint class and click the `Component`
    should find it. Then, after adding it, you can link logic into it by clicking
    the green plus buttons next to the events we made in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Delegates created in C++ showing in the Blueprint editor window](img/Figure_04.03_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Delegates created in C++ showing in the Blueprint editor window
  prefs: []
  type: TYPE_NORMAL
- en: As a final note on this pattern, you may also have heard the term ECS bandied
    around with games such as *Doom Eternal* and *Overwatch*, but this is slightly
    different from Unreal’s implementation. The ECS being spoken about there is what
    we call *data-oriented* ECS. This means that components store only data. The systems
    are the functions and are stored separately. Then the systems run on archetypes
    of components we call entities. Entities are stored contiguously in memory, which
    makes processing systems across large arrays of entities much faster and even
    possible to easily multi-thread.
  prefs: []
  type: TYPE_NORMAL
- en: The trade-off with this is that, while in principle it sounds simple, in practice
    it is a paradigm shift in how to approach programming as large as the jump from
    the linear *hello world* style programs with everything in one file to object-oriented
    projects with many classes and complex internal structures. This, combined with
    the infancy of the approach, means it is not practical to develop a large game
    and expect the entire programming team to hit the ground running with this system.
    If you would like to learn more about full data-oriented ECS, then there are plenty
    of resources on the topic. The keywords for proper research into the topic would
    be data-oriented, archetypes, and ECS, in some order, but due to the low adoption
    rate of the technique, resources are generally either terse or surface-level.
    The concept is best learned practically by pulling the ENTT C++ library apart
    to see how it implements the pattern. This is best for practical learners as it
    is a raw implementation with no other distractions.
  prefs: []
  type: TYPE_NORMAL
- en: Components are everywhere in modern game design, and now you should have some
    understanding of how to structure your code with them. Another ubiquitous tool
    in your developer belt is the update method.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the update method for prototyping gameplay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The update method is all about abstraction. Let’s learn through an example.
    Imagine building a *Pong* clone with only rudimentary knowledge of C++. It might
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Naïve Pong code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code may work for *Pong* but the problem is pretty clear. As you add more
    and more types of objects to your game, the ways you have to deal with every frame
    balloons your code. This is not sustainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution can be found in the minds of every person with an overbearing
    micro-managing boss: “*Just let me do my job.*” In this situation, the main loop
    is the manager, and the entities are sitting on the sidelines. They exist but
    are largely having logic run at them rather than on them. Why not trust these
    experts and make each entity responsible for the logic under its namesake? We
    keep a list of references in the main loop, but we forget who each of them are
    and resort to referencing them as numbers, or indexes in an array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This new impersonal approach frees up the main loop to go through all entities
    and call a shared `Update()` method on them all. Each entity can now deal with
    its own world within its own override of the `Update` function. The following
    code snippet is an example of how you might manage this new approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Better Pong code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Unreal Engine’s implementation of `Update` is called “`Tick`.” It fires once
    every rendered frame and allows developers to provide each actor they make with
    a different behavior. There is, however, a big issue with the update method pattern,
    which is why we will be exploring it in more depth in [*Chapter 5*](B18297_05.xhtml#_idTextAnchor068).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the update method pattern, we are going to move on to
    the implementation of the behavior tree pattern in Unreal Engine 5 by exploring
    the behavior tree system inside the Unreal Engine editor.
  prefs: []
  type: TYPE_NORMAL
- en: Working with behavior trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last pattern for this chapter is a little specific but no less useful than
    the others. Behavior trees define decision trees for AI brains to run. These trees
    define how information stored about the situation the AI thinks it is in will
    affect the actions it takes. Instead of compartmentalizing code into discrete
    blocks like other AI brain solutions, the behavior tree favors fragmentation with
    the aim of reuse. This flows back to the idea from the beginning of the chapter
    about the reuse of code for efficiency. A tree may look complex with many branches
    and leaves (yes, that is what we call the composites and tasks that make up a
    behavior tree), but on closer inspection, you will see that there are only a few
    building blocks and their arrangement is what creates the illusion of complex
    decision making.
  prefs: []
  type: TYPE_NORMAL
- en: 'The flow through a simple tree starts at the root and evaluates each node in
    the layer below in ascending order from 0 (order matters here) until it gets a
    success response. At this point, the tree knows it has found the correct task
    for its situation and can reset. As mentioned before, there are two types of simple
    nodes: composite and task. Composite nodes direct the flow of logic with their
    own sets of rules, whilst tasks are the actions and can succeed or fail depending
    on the logic contained within them (either in Blueprint or C++ code), and can
    never have a layer below them. The behavior tree executes each node in order until
    they reach the end of the list, or a node fails. They succeed when all their children
    succeed.'
  prefs: []
  type: TYPE_NORMAL
- en: We will be using selector and sequence nodes, both of which are types of composite
    nodes. A selector node executes all of its children from left to right; it stops
    executing when one of its children succeeds. A sequence node also executes all
    of its children from left to right; however, unlike the selector node, it stops
    executing when one of its children fails. There are other more specialized nodes,
    but these two composite nodes are the foundations for any system you could wish
    to design.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other composite node type, which we won’t be using, is the **simple parallel**
    node type. The simple parallel node allows you to run two child nodes at the same
    time: one must be a task, and the other can contain a complete sub-tree or branch
    of the behavior tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The three types of composite nodes: Selector, Sequence, and
    Simple Parallel](img/Figure_04.04_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4 – The three types of composite nodes: Selector, Sequence, and Simple
    Parallel'
  prefs: []
  type: TYPE_NORMAL
- en: A notable use of behavior trees in games is *Halo 2*. As mentioned above, the
    order of the nodes in the tree matters and can radically change how AI behaves
    as it will tend to favor branches higher in the order. To differentiate the varied
    enemy types, Microsoft designed different behavior trees for each one. *Grunts*
    have a higher-order branch for fleeing so they tend to seem more scared, whereas
    *Elites* can re-order their own trees based on what the player is doing to make
    them seem adaptable. Notably, if you get in a vehicle enemy, *Elites* will raise
    the priority of them getting in a vehicle as vehicle-to-vehicle combat is more
    fun than the alternative and vice versa. There are many more tricks going on in
    that game, but this is not the place to continue, so back to UE5.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at building a behavior tree for a simple **real-time strategy** (**RTS**)
    AI in the RTS framework. We will introduce the various building blocks of behavior
    trees, including selectors, sequences, decorators, services, and tasks.
  prefs: []
  type: TYPE_NORMAL
- en: For this implementation, we are going to use Blueprint to create the service
    (a collection of functions called by a behavior tree node) and tasks as opposed
    to using C++, as the main focus is on the implementation of the behavior tree
    pattern in Unreal Engine 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'The framework contains a series of assets that have already been set up for
    you. Any Blueprint logic that we’ve created has been commented, if you would like
    to explore them further. Inside the `Content/RTS/Blueprints` folder, you will
    find a series of unreal assets used to create the basic elements of our RTS example
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GM_RTS**: This is the game mode. It contains references to the various classes
    for the framework to work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PC_RTS**: This is the player controller. It contains the functionality to
    left-click selectable units and right-click on the world in order to tell the
    unit where to go.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BP_CameraPawn**: This is our pawn. It is a simple pawn blueprint with a camera
    that is set up to be placed directly in the center of the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BPI_Units:** This is our Blueprint interface. It contains three functions:
    **SetMoveLocation**, **Stop**, and **AttackTarget**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SetMoveLocation** has a vector input, **Target Location**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AttackTarget** has an object input, **TargetToAttack**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop** is just a function name and does not have any inputs or outputs'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BPI_Units` Blueprint interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The skeletal mesh component has been set up to use a green-tinted material instance
    placed on the default mesh, which is inherited from the base character class.
    We are making use of the standard mannequin character mesh here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This Blueprint currently contains no functionality.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**BP_EnemyUnit**: This is a second character blueprint. This is a simple character
    blueprint with no functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The skeletal mesh component has been set up with a red-tinted material instance
    so that it is clearly identifiable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, we are going to build an AI unit that the player will be able to control.
    The player will only be able to tell the unit where to move. They will do this
    by first selecting the unit using a left-click and then selecting a desired location
    for the unit to move to by right-clicking on the floor.
  prefs: []
  type: TYPE_NORMAL
- en: The unit will then move to the location. When not moving, the unit will search
    to see if any enemy units are within a radius of its current location. If it finds
    an enemy, the unit will then turn to face the enemy and shoot at it (using a simple
    line trace for now).
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we need to create a series of assets. We are going to create
    an AI controller asset, for which we will create a Blackboard asset that contains
    the variables used inside the behavior tree.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AI controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to create is an AI controller Blueprint asset. This
    asset allows us to replace the human controller for a pawn with an AI solution
    using a behavior tree. For this, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the Unreal Engine Editor, open the `Content/RTS/Blueprints` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click within the folder in the **Content Browser** and create a new **Blueprint
    Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `AIController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **AIController** entry from the list and click **Select**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The Pick Parent Class dialog with the AIController parent class
    selected as the chosen parent class for the new Blueprint](img/Figure_04.05_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – The Pick Parent Class dialog with the AIController parent class
    selected as the chosen parent class for the new Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: Name the new Blueprint `AIC_EliteUnit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we have our new AI controller, we now need to set it as the default AI
    controller for the *Elite* unit. This will ensure that whenever an Elite unit
    is spawned or placed within the game, it will have a controller. To assign the
    default AI controller, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: From the `Blueprints` folder, open the **BP_EliteUnit** Blueprint asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Class Defaults** button in the top menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `AIC_EliteUnit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have an AI controller, we can start building our AI system. Before we
    can create the behavior tree, we first need to set up a **Blackboard** asset.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Blackboard asset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blackboards are used to define variables (known as keys) and store their values,
    which will allow our behavior tree to make decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the Blackboard asset, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Content Browser** window, right-click and select **Artificial Intelligence**
    | **Blackboard**.![Figure 4.6 – The Artificial Intelligence options when creating
    a new asset](img/Figure_04.06_B18297.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.6 – The Artificial Intelligence options when creating a new asset
  prefs: []
  type: TYPE_NORMAL
- en: Name the new `BB_EliteUnit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `BB_EliteUnit` Blackboard asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two new keys and set the `MoveToLocation`: `Vector`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TargetEntity`: `Object`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.7 – The Blackboard asset with two keys](img/Figure_04.07_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – The Blackboard asset with two keys
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our Blackboard setup with our variables (keys), we can go ahead
    and create the behavior tree asset and get building our AI system.
  prefs: []
  type: TYPE_NORMAL
- en: Building the behavior tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we have our Blackboard, we can create our behavior tree asset and link
    the main assets together:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Content Browser** window, right-click and select **Artificial Intelligence**
    | **Behavior Tree**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new `BT_EliteUnit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `BT_EliteUnit` asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Blackboard Asset** setting in the **Details** panel to **BB_EliteUnit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The Blackboard Asset setting in the Details panel of a Behavior
    Tree](img/Figure_04.08_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The Blackboard Asset setting in the Details panel of a Behavior
    Tree
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `AIC_EliteUnit` Blueprint asset (the AI controller) and activate the
    behavior tree when the unit is possessed using **Event** **On Possess**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Blueprint nodes to run the Behavior Tree when the unit is possessed](img/Figure_04.09_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Blueprint nodes to run the Behavior Tree when the unit is possessed
  prefs: []
  type: TYPE_NORMAL
- en: With that done, we now have created the behavior tree asset; we can start building
    the AI system.
  prefs: []
  type: TYPE_NORMAL
- en: Basic movement branch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To start building the brains of our system, we are going to set up the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A selector node, which is used to branch out into other sections of the tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sequence node, which allows us to move through multiple tasks, in order, from
    left to right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our first task, which will use the existing **Move** **To** task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will enable our character to be moved around the world. This part of the
    system requires no additional logic, just setting up within the behavior tree
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s start building:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BT_EliteUnit` behavior tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the dark gray section at the bottom of the root node and create a
    `RootSelector`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Options available when dragging from the root node in the behavior
    tree](img/Figure_04.10_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Options available when dragging from the root node in the behavior
    tree
  prefs: []
  type: TYPE_NORMAL
- en: From the bottom of the new `MoveToTargetLocation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For one final time, drag from the bottom of the new **Sequence** node and add
    **Move To** from the **Tasks** section of the selection popup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Behavior tree creation popup with Move To highlighted](img/Figure_04.11_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Behavior tree creation popup with Move To highlighted
  prefs: []
  type: TYPE_NORMAL
- en: Set the Blackboard key to `MoveToLocation` – this is the vector key in the Blackboard
    asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the moment, this behavior tree will run; however, the task (*Move To*) will
    try to move the character to `0`,`0`,`0` because we have yet to set a value for
    the **MoveToLocation** key on the Blackboard.
  prefs: []
  type: TYPE_NORMAL
- en: The Blackboard keys can be set from multiple places if you can provide a reference
    to the owner of the Blackboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already provided the connection between the player controller Blueprint
    and the `BP_EliteUnit` character. Now we can set up the character to do something
    with those values:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BP_EliteUnit` character Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new `Event Possessed` logic chain that casts `AIC_EliteUnit` and then
    stores the reference as a variable called `AIController`. Do this by creating
    the Blueprint nodes as shown (to create the `AIController`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Event Possessed logic on the BP_EliteUnit character blueprint](img/Figure_04.12_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Event Possessed logic on the BP_EliteUnit character blueprint
  prefs: []
  type: TYPE_NORMAL
- en: From the **Interfaces** section of the **My Blueprint** tab, double-click the
    **Set Move Location** label. This will create an **Event Set Move** **Location**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `MoveToLocation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the`Get Blackboard` node, and from that, add a `Set Value as` `Vector`
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Make Literal Name` node. Set `MoveToLocation` – this is the key name
    on the Blackboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **MoveToLocation** vector variable as the **Vector** **Value** input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Event Set Move Location logic on the BP_EliteUnit character
    Blueprint](img/Figure_04.13_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Event Set Move Location logic on the BP_EliteUnit character Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: This logic will, when the event is called, pass `MoveToLocation` key value.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this process for the **Stop** interface function from the **Interfaces**
    section of the **My Blueprint** tab, except instead of using a pin on the event
    to set the **MoveToLocation** vector, use a **Get Actor** **Location** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Event Stop logic on the BP_EliteUnit character Blueprint](img/Figure_04.14_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Event Stop logic on the BP_EliteUnit character Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing left to do is tell the `MoveToLocation` key on the Blackboard:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Move To** node on the behavior tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, check the **Observe Blackboard** **Value** box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Observe Blackboard Value checked on Move To task node](img/Figure_04.15_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Observe Blackboard Value checked on Move To task node
  prefs: []
  type: TYPE_NORMAL
- en: Now that the basic movement is set up, the character can be instructed to move
    around the world. Next, we are going to add a branch to our tree that will focus
    on the shooting part of our system.
  prefs: []
  type: TYPE_NORMAL
- en: Shooting branch and task
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next element of the system we are going to build is a means to enable the
    character to shoot enemies. For this, we are going to need to create a new task
    to build into the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: To start with, click the **New Task** button at the top of the **Behavior Tree**
    editor and select **BTTask_BlueprintBase** from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.16 – New Task dropdown with BTTask_BlueprintBase selected](img/Figure_04.16_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – New Task dropdown with BTTask_BlueprintBase selected
  prefs: []
  type: TYPE_NORMAL
- en: From the `Blueprints` folder is selected and set the name as `BTT_ShootTarget`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Save Asset As window for behavior tree tasks](img/Figure_04.17_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – Save Asset As window for behavior tree tasks
  prefs: []
  type: TYPE_NORMAL
- en: This has now created a behavior tree task asset, which should open automatically.
    If it doesn’t, you will find it as a Blueprint asset in the **Content Browser**.
  prefs: []
  type: TYPE_NORMAL
- en: With the task created, we now need to add some logic for what the task will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: A task works by utilizing the `AttackTarget`, which we will set up to just print
    a `Shoot` message for now.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior tree tasks need any logic chains to end with a `Success`. If the logic
    has completed the task, then this should be set to **True**, if it hasn’t, it
    should be set to **False**. For this example, we will only have a **True** result
    as all we are doing is calling an event on the character Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: In the `BTT_ShootTarget` Blueprint, add an **Event Receive Execute AI** node
    either by right-clicking in the viewport and searching for it or by clicking the
    **Override** dropdown that appears on the **Functions** rollout title when you
    hover over it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the `AttackTarget` interface event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Get Blackboard Value as Object` node. This will allow us to get the
    value of an object key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `TargetEntity` – it is vital that this matches the name of the
    key on the Blackboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `TargetEntity` variable to be **Instance Editable** by clicking the
    eye to the right of the variable type in the **Variables** list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Instance Editable set to True on the TargetEntity variable](img/Figure_04.18_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – Instance Editable set to True on the TargetEntity variable
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Finish Execute` node after **Attack Target** and set **Success** to **True**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Complete BTT_ShootTarget Blueprint logic](img/Figure_04.19_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – Complete BTT_ShootTarget Blueprint logic
  prefs: []
  type: TYPE_NORMAL
- en: 'The task is now created. Before we add it to the tree, we need to add a response
    to the interface call on the character. For now, we will just add a `Shoot`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BP_EliteUnit` character Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click **AttackTarget** from the **Interfaces** rollout in **My Blueprint**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Print String` node to the new `Hello` with `Shoot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Temporary attack target logic](img/Figure_04.20_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 – Temporary attack target logic
  prefs: []
  type: TYPE_NORMAL
- en: We will replace this with a proper solution later. For now, this will serve
    the purpose of confirming that the event is being called by the task in the behavior
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our task and interface event set up, we can add the task to
    the behavior tree:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BT_EliteUnit` behavior tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the bottom of the `ShootNearbyTargets`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place this new node to the left of the **MoveToTargetLocation** node. This ensures
    that this node is considered first (i.e., it has a higher priority).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the bottom of the `Rotate to face BB` entry task – this will cause
    the character to face its target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `TargetEntity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the bottom of the `BTT_ShootTarget` task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `TargetEntity` if not set automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.21 – The behavior tree so far with a new sequence and tasks added](img/Figure_04.21_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 – The behavior tree so far with a new sequence and tasks added
  prefs: []
  type: TYPE_NORMAL
- en: The main structure of the branches is now complete; what we don’t have, however,
    is any way of identifying and setting the target identity. We are going to use
    a service to find our nearest target and a decorator to identify when the `TargetEntity`
    key has changed in order to choose when to complete the tasks in the `ShootNearbyTargets`
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying enemy targets with a service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To identify the enemies around the character, we are going to place a sphere
    trace within a service on the **RootSelector** selector node. This will provide
    the required information to the decision-making processes below as to what part
    of the tree will run, reducing the need to do tasks that don’t return successes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s start by creating a service:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **New Service** button at the top of the **Behavior** **Tree** editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the asset is being saved in the `Blueprint` folder and set `BTS_Find``NearestTarget`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the new asset (if it doesn’t open automatically).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new float variable called `SearchRadius`, set its default as `500`,
    and make it**Instance Editable**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Blackboard key selector variable called `TargetEntity` and make
    it **Instance Editable**. Just like when creating the *Shoot Target* task, it
    is vital this is spelled correctly, matching the Blackboard key name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the **Receive Tick AI** function by either right-clicking on the graph
    and searching for the node or using the override dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `Sphere Trace For Objects` node and set it up as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.22 – Sphere trace for pawns other than the unit doing the search](img/Figure_04.22_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22 – Sphere trace for pawns other than the unit doing the search
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the `Break Hit Result` node, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.23 – Setting Blackboard key for Target Entity to Hit Actor](img/Figure_04.23_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.23 – Setting Blackboard key for Target Entity to Hit Actor
  prefs: []
  type: TYPE_NORMAL
- en: If the `TargetEntity` key using a **Clear Blackboard Value** node. This can
    be created by dragging from the **TargetEntity** variable node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service Blueprint is now complete and looks as shown in the following screenshot.
    If you would like to visualize the sphere trace in order to determine whether
    the **Search Radius** variable is suitable, set the **Draw Debug Type** dropdown
    in the **Sphere Trace For Objects** node to **For** **One Frame**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24 – Completed service logic](img/Figure_04.24_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.24 – Completed service logic
  prefs: []
  type: TYPE_NORMAL
- en: 'With the service created, we can now add it to the `Root` selector:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `BT_EliteUnit` behavior tree, right-click the **RootSelector** node,
    navigate to **Add Service…** and select **BTS Find** **Nearest Target**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the `TargetEntity` and that the search radius is showing as `500`.
    The search variable can be changed depending on the needs of the behavior tree
    it is being added to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.25 – RootSelector with service added](img/Figure_04.25_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.25 – RootSelector with service added
  prefs: []
  type: TYPE_NORMAL
- en: With the service added, the **RootSelector** should now look as shown in the
    preceding screenshot. You may need to rearrange your nodes to accommodate its
    increased size.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the selector set up to find the nearest target, we can use
    the result of that service to define whether the shooting part of our behavior
    tree can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a decorator to activate the shooting sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to ensure that the character only tries to rotate and shoot at a target
    that exists, we need to make sure we only run those tasks when `TargetEntity`
    has a valid value (this is why we clear the value when the sphere trace returns
    no hit results). We are going to add a decorator to `ShootNearbyTargets`. A decorator
    (known as a conditional in other behavior tree systems) defines whether a branch
    or node can be executed. We will use the decorator to monitor the `TargetEntity`
    Blackboard key value to see if we have anything to shoot; when we do, the `ShootNearbyTargets`
    sequence can be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the **ShootNearbyTargets** sequence node, navigate to **Add Decorator…**,
    and choose **Blackboard**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the decorator (the blue box that has now appeared) and rename the node
    `TargetFound`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that **Blackboard Key** = **TargetEntity** and **Key Query** = **Is Set**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.26 – The final behavior tree](img/Figure_04.26_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.26 – The final behavior tree
  prefs: []
  type: TYPE_NORMAL
- en: If you now test the system by playing in the viewport, you should be able to
    select and move the green character near either of the red characters. When the
    green character stops, it will find the nearest target, turn, and should create
    a print string of `Shoot`. It will continue to do so until the target is no longer
    valid, which, at this point, will be an eternity as we are not dealing any damage
    to the unit. You also won’t be able to move the character once it finds a target
    because there is currently no way of getting the AI to move away from the `BTT_ShootTarget`
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'To damage the enemy unit, making use of the `Health` component we created earlier,
    we need to replace the `BP_EliteUnit` **Attack Target** event with some logic
    to confirm the line of sight and then apply damage:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `BP_EliteUnit` character Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the **Print String** node from the **Event Attack Target** logic chain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cast the **TargetToAttack** object to **Actor** in order to get the actor’s
    location and use that as part of a **Line Trace By Channel**, as shown in the
    following screenshot. The line trace has been set up to draw onscreen for 5 seconds
    so we can confirm the trace is happening correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.27 – Line Trace By Channel setup from shooting actor to target actor](img/Figure_04.27_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.27 – Line Trace By Channel setup from shooting actor to target actor
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Break Hit Result` node from the `Apply Damage` node with `100` `Print
    String` node for `No Line` `of Sight`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.28 – Apply damage to target actor if confirmed. The reroute nodes
    at the bottom left are routed from the As Actor pin of the Cast to Actor node](img/Figure_04.28_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.28 – Apply damage to target actor if confirmed. The reroute nodes at
    the bottom left are routed from the As Actor pin of the Cast to Actor node
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, to enable the enemy unit to be destroyed, we need to utilize the **OnComponentDead**
    event from the **Health** component by linking it to a **Destroy** **Actor** node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.29 – Health component death event linked to a Destroy Actor node](img/Figure_04.29_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.29 – Health component death event linked to a Destroy Actor node
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the final thoughts.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and final thoughts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testing the game now should remove the enemy instead of continually printing
    `Shoot`. This will result in the target entity being cleared, which in turn will
    allow you to move the character again.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we now have a successful AI-controlled unit that moves and shoots, there
    is one other thing that is worth exploring, which is the `TargetFound` decorator.
    We originally left this set as `None`, which means the unit will complete its
    `shoot` as soon as it detects an enemy with a simple change of this value:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `TargetFound` decorator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, set the **Notify Observer** to **On** **Result Change**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **Observer aborts** to **Lower Priority**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the game again. You should now see that if you tell the unit to move past
    one of the enemies, it will stop en route to engage with the target. This is because
    the decorator has identified a change in the value of `TargetEntity` from the
    `BTS_FindNearestTarget` service and can now interrupt any lower-priority branch
    of the behavior tree, so any node which is to the right of it in the selector,
    which in this case includes the `MoveToTargetLocation` sequence, which holds the
    **Move** **To** task.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed the game development patterns that are present
    as premade tools and systems inside Unreal Engine. Namely, the component, update,
    and behavior tree patterns.
  prefs: []
  type: TYPE_NORMAL
- en: We made a `Health` component that will hopefully prove useful in your future
    projects, along with a simple behavior tree showing each major piece of the system.
    Armed with this knowledge, you should be able to make a functional AI system for
    any of your future Unreal projects.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will take what we have learned about the update method and
    explain how we can do better. What is the impact of using `Tick` within the engine
    and how can you measure that impact?
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Anonymous Modular Design'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will begin creating more efficient code to build modular solutions
    that communicate with each other efficiently and cleanly, without the use of direct
    references and casts.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by reducing the need for gated polling in our code by replacing
    it with cleaner communication methods, and we will explore interfaces and event
    delegates to allow our code to be decoupled. This will culminate in a coding design
    paradigm we call Anonymous Modular Design, which should make our object-oriented
    code the most maintainable and expandable it can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18297_05.xhtml#_idTextAnchor068), *Forgetting Tick*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18297_06.xhtml#_idTextAnchor076), *Clean Communication – Interface
    and Event Observer Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18297_07.xhtml#_idTextAnchor090), *A Perfectly Decoupled System*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
