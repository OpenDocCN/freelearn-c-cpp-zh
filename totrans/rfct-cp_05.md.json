["```cpp\nclass SoftwareEngineer {\npublic:\n    void assign_task(std::string task_name) {\n        current_task_ = std::move(task_name);\n    }\nprivate:\n    std::string current_task_;\n};\n```", "```cpp\nclass Document {\npublic:\n    void process();\n};\n```", "```cpp\nclass Document {\npublic:\n    void parse(const std::string& content);\n    void render();\n    void save(const std::string& file_path);\n};\n```", "```cpp\n// Global variable\nconstexpr double GRAVITATIONAL_ACCELERATION = 9.8; // Clear and descriptive\n```", "```cpp\nclass PhysicsObject {\n    double mass_;  // Descriptive and follows naming convention\n    // ...\n};\n```", "```cpp\ndouble compute_force(double mass, double acceleration) {\n    double force = mass * acceleration;  // 'force' is clear in this context\n    return force;\n}\n```", "```cpp\nfor (int i = 0; i < num; ++i) {  // 'i' is clear in this context\n    // ...\n}\n```", "```cpp\n#include <vector>\n#include <string>\nint main() {\n    std::vector<int> integers;\n    std::string sentence;\n    // The following will cause a compile-time error because\n    // the type of 'sentence' is string, not vector<int>.\n    integers = sentence;\n    return 0;\n}\n```", "```cpp\n// Define new types for User and Product IDs.\nstruct UserId {\n    explicit UserId(int id): value(id) {}\n    int value;\n};\nstruct ProductId {\n    explicit ProductId(int id): value(id) {}\n    int value;\n};\nvoid process_user(UserId id) {\n    // Processing user...\n}\nvoid process_product(ProductId id) {\n    // Processing product...\n}\nint main() {\n    UserId user_id(1);\n    ProductId product_id(2);\n    // The following line would cause a compile-time error because\n    // a ProductId is being passed to process_user.\n    process_user(product_id);\n    return 0;\n}\n```", "```cpp\nclass Document {\npublic:\n    void print();\n};\nDocument report;\nreport.print();  // \"report, print!\"\n```", "```cpp\nclass MessageSender {\npublic:\n    void send_message(const std::string& message) {\n        if (message.size() > 1024) {\n            // Split the message into chunks and send\n        } else {\n            // Send the message\n        }\n    }\n};\n```", "```cpp\nclass MessageSender {\n    constexpr size_t MAX_MESSAGE_SIZE = 1024;\npublic:\n    void send_message(const std::string& message) {\n        if (message.size() > MAX_MESSAGE_SIZE) {\n            // Split the message into chunks and send\n        } else {\n            // Send the message\n        }\n    }\n};\n```", "```cpp\nnamespace product_name {\n    class Router {\n        // class implementation\n    };\n}\n// To use it elsewhere in the code\nproduct_name::Router myRouter;\n```", "```cpp\nnamespace product_name {\n    namespace networking {\n        class Router {\n            // class implementation\n        };\n    }\n}\n```", "```cpp\n// communication/client.hpp\nnamespace communication {\nclass Client {\npublic:\n    // public high-level methods\nprivate:\n    using HttpClient = communication::advanced::HttpClient;\n    HttpClient inner_client_;\n};\n} // namespace communication\n// communication/http/client.hpp\nnamespace communication::advanced::http {\nclass Client {\n    // Lower-level implementation\n};\n} // namespace communication::advanced\n```", "```cpp\nclass Portfolio {\npublic:\n    void add_asset(std::unique_ptr<Asset> asset) {\n        // add the asset to the portfolio\n    }\n    double total_dividend() const {\n        // calculate the total dividends of the portfolio\n    }\nprivate:\n    std::vector<std::unique_ptr<Asset>> assets_;\n};\nusing Ticker = std::string;\nclass Asset {\npublic:\n    Asset(const Ticker& ticker, int64_t quantity) :\n        ticker_{ticker},\n        quantity_{quantity} {}\n    virtual Asset() = default;\n    virtual double total_dividend() const = 0;\n    auto& ticker() const { return ticker_; }\n    int64_t quantity() const { return quantity_; }\nprivate:\n    Ticker ticker_;\n    int64_t quantity_;\n};\nclass Bond : public Asset {\npublic:\n    Bond(const Ticker& ticker, int64_t quantity) :\n        Asset{ticker, quantity} {}\n    double total_dividend() const override {\n        // calculate bond dividend\n    }\n};\nclass Equity : public Asset {\npublic:\n    Equity(const Ticker& ticker, int64_t quantity) :\n        Asset{ticker, quantity} {}\n    double total_dividend() const override {\n        // calculate equity dividend\n    }\n};\n```", "```cpp\nclass Router {\npublic:\n    void route(const Message& message, Id receiver) {\n        auto message_content = message.get_content();\n        // Code to route the 'message_content' to the appropriate 'receiver'\n    }\nprivate:\n    // Router's private members\n};\n```", "```cpp\nvoid route(const Message& message, Id receiver) {\n    auto message_content = message.get_content();\n    // Note: The routing_library has an idiosyncratic behavior where\n    // it treats receiver id as one-indexed. Hence we need to increment by 1.\n    receiver++;\n    // Code to route the 'message_content' to the appropriate 'receiver'\n}\n```"]