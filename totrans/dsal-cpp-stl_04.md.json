["```cpp\nstd::vector<int> numbers = {5, 1, 2, 4, 3};\nstd::sort(std::begin(numbers), std::end(numbers));\n```", "```cpp\nstd::sort(numbers.begin(), numbers.end(), std::greater<>());\n```", "```cpp\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\nstruct Person {\n  std::string name;\n  int age{0};\n  Person(std::string n, int a) : name(n), age(a) {}\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const Person &p) {\n    os << p.name << \" (\" << p.age << \")\";\n    return os;\n  }\n};\nint main() {\n  std::vector<Person> people = {Person(\"Regan\", 30),\n                                Person(\"Lisa\", 40),\n                                Person(\"Corbin\", 45)};\n  auto compareByName = [](const Person &a,\n                          const Person &b) {\n    return a.name < b.name;\n  };\n  std::sort(people.begin(), people.end(), compareByName);\n  std::cout << \"Sorted by name:\\n\";\n  for (const auto &p : people) { std::cout << p << \"\\n\"; }\n  std::sort(people.begin(), people.end(),\n            [](const Person &a, const Person &b) {\n              return a.age < b.age;\n            });\n  std::cout << \"\\nSorted by age:\\n\";\n  for (const auto &p : people) { std::cout << p << \"\\n\"; }\n  return 0;\n}\n```", "```cpp\nSorted by name:\nCorbin (45)\nLisa (40)\nRegan (30)\nSorted by age:\nRegan (30)\nLisa (40)\nCorbin (45)\n```", "```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nint main() {\n  std::vector<int> numbers = {3, 1, 4, 1, 5, 9};\n  // Let's mistakenly provide an end iterator beyond the\n  // actual end of the vector.\n  std::vector<int>::iterator invalid = numbers.end() + 1;\n  // Uncommenting the following line can lead to undefined\n  // behavior due to the invalid range.\n  // std::sort(numbers.begin(), invalidEnd);\n  // This comparator will return true even when both\n  // elements are equal. This violates the strict weak\n  // ordering.\n  auto badComparator = [](int a, int b) { return a <= b; };\n  // Using such a comparator can lead to unexpected\n  // results.\n  std::sort(numbers.begin(), numbers.end(), badComparator);\n  // Displaying the sorted array (might be unexpectedly\n  // sorted or cause other issues)\n  for (int num : numbers) { std::cout << num << \" \"; }\n  std::cout << \"\\n\";\n  return 0;\n}\n```", "```cpp\nauto it = std::find(numbers.begin(), numbers.end(), 46);\n```", "```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nint main() {\n  std::vector<int> numbers = {1, 3, 3, 5, 7};\n  int val1 = 3;\n  auto low1 = std::lower_bound(numbers.begin(),\n                               numbers.end(), val1);\n  std::cout << \"std::lower_bound for value \" << val1\n            << \": \" << (low1 - numbers.begin()) << \"\\n\";\n  int val2 = 4;\n  auto low2 = std::lower_bound(numbers.begin(),\n                               numbers.end(), val2);\n  std::cout << \"std::lower_bound for value \" << val2\n            << \": \" << (low2 - numbers.begin()) << \"\\n\";\n  int val3 = 3;\n  auto up1 = std::upper_bound(numbers.begin(),\n                              numbers.end(), val3);\n  std::cout << \"std::upper_bound for value \" << val3\n            << \": \" << (up1 - numbers.begin()) << \"\\n\";\n  return 0;\n}\n```", "```cpp\nstd::lower_bound for value 3: 1\nstd::lower_bound for value 4: 3\nstd::upper_bound for value 3: 3\n```", "```cpp\nstd::vector<int> source = {1, 2, 3, 4, 5};\nstd::vector<int> destination(5);\n```", "```cpp\nstd::copy(source.begin(), source.end(), destination.begin());\n```", "```cpp\nstd::vector<int> x = {1, 2, 3, 4, 5};\nstd::reverse(x.begin(), x.end());\n```", "```cpp\nstd::vector<int> values = {1, 2, 3, 4, 5};\n```", "```cpp\nstd::rotate(values.begin(), values.begin() + 2, values.end());\n```", "```cpp\nstd::vector<int> data(5);\nstd::fill(data.begin(), data.end(), 42);\n```", "```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nint main() {\n  std::vector<std::string> playlist = {\n      \"Song A\", \"Song B\", \"Song C\", \"Song D\",\n      \"Song E\", \"Song F\", \"Song G\", \"Song H\",\n      \"Song I\", \"Song J\", \"Song K\", \"Song L\"};\n  std::rotate(playlist.rbegin(), playlist.rbegin() + 10,\n              playlist.rend());\n  std::cout << \"Year in Review playlist: \";\n  for (const auto &song : playlist) {\n    std::cout << song << \", \";\n  }\n  std::cout << \"\\n\";\n  std::reverse(playlist.begin(), playlist.end());\n  std::cout << \"Rediscovery playlist: \";\n  for (const auto &song : playlist) {\n    std::cout << song << \", \";\n  }\n  std::cout << \"\\n\";\n  std::vector<std::string> newAlbum = {\n      \"New Song 1\", \"New Song 2\", \"New Song 3\"};\n  playlist.insert(playlist.begin() + playlist.size() / 2,\n                  newAlbum.begin(), newAlbum.end());\n  std::rotate(playlist.begin() + playlist.size() / 2,\n              playlist.end() - newAlbum.size(),\n              playlist.end());\n  std::cout << \"After new album purchase: \";\n  for (const auto &song : playlist) {\n    std::cout << song << \", \";\n  }\n  std::cout << \"\\n\";\n  std::vector<std::string> springSongs = {\n      \"Spring 1\", \"Spring 2\", \"Spring 3\", \"Spring 4\"};\n  if (playlist.size() < springSongs.size()) {\n    playlist.resize(springSongs.size());\n  }\n  std::fill(playlist.begin(),\n            playlist.begin() + springSongs.size(),\n            \"Spring Song\");\n  std::cout << \"Spring Refresh: \";\n  for (const auto &song : playlist) {\n    std::cout << song << \", \";\n  }\n  std::cout << \"\\n\";\n  return 0;\n}\n```", "```cpp\nYear in Review playlist: Song C, Song D, Song E, Song F, Song G, Song H, [...]\nRediscovery playlist: Song B, Song A, Song L, Song K, Song J, Song I, [...]\nAfter new album purchase: Song B, Song A, Song L, Song K, Song J, Song I, [...]\nSpring Refresh: Spring Song, Spring Song, Spring Song, Spring Song, Song J, [...]\n```", "```cpp\nstd::vector<int> numbers = {1, 3, 2, 5, 4};\nstd::sort(numbers.begin(), numbers.end(), [](int a, int b){\n    return a > b;\n});\n```", "```cpp\nstd::vector<int> x = {1, 2, 3, 4, 5};\nint evens = std::count_if(x.begin(), x.end(), [](int n){\n    return n % 2 == 0;\n});\n```", "```cpp\nstruct Student {\n    std::string name;\n    int grade;\n};\nstd::vector<Student> students = { ... };\nstd::sort(students.begin(), students.end(), [](const Student& a, const Student& b) {\n    if(a.grade == b.grade){ return (a.name < b.name); }\n    return (a.grade > b.grade);\n});\n```", "```cpp\nstruct SortByGradeThenName {\n  bool operator()(const Student &first,\n                  const Student &second) const {\n    if (first.grade == second.grade) {\n      return (first.name < second.name);\n    }\n    return (first.grade > second.grade);\n  }\n};\nstd::sort(students.begin(), students.end(), SortByGradeThenName());\n```", "```cpp\n#include <iostream>\n#include <vector>\nint main() {\n  std::vector<int> numbers = {1, 2, 3, 4, 5};\n  std::vector<int>::iterator it = numbers.begin() + 2;\n  std::cout << \"The element at the iterator before\"\n               \"push_back: \"\n            << *it << \"\\n\";\n  for (int i = 6; i <= 1000; i++) { numbers.push_back(i); }\n  std::cout << \"The element at the iterator after\"\n               \"push_back: \"\n            << *it << \"\\n\";\n  it = numbers.begin() + 2;\n  numbers.insert(it, 99);\n  it = numbers.begin() + 3;\n  numbers.erase(it);\n  return 0;\n}\n```", "```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nint main() {\n  std::vector<int> numbers;\n  numbers.reserve(1000);\n  for (int i = 1; i <= 10; ++i) { numbers.push_back(i); }\n  // 0-based index for number 5 in our vector \n  size_t positionOfFive = 4;\n  std::cout << \"Fifth element: \" << numbers[positionOfFive]\n            << \"\\n\";\n  numbers.insert(numbers.begin() + 5, 99);\n  std::vector<int>::iterator it =\n      numbers.begin() + positionOfFive;\n  std::cout << \"Element at the earlier fifth position \"\n               \"after insertion: \"\n            << *it << \"\\n\";\n  // After inserting, refresh the iterator\n  it = numbers.begin() + 6;\n  std::sort(numbers.begin(), numbers.end());\n  // Caution with Custom Comparators and Predicates:\n  auto isOdd = [](int num) { return num % 2 != 0; };\n  auto countOdd =\n      std::count_if(numbers.begin(), numbers.end(), isOdd);\n  std::cout << \"Number of odd values: \" << countOdd\n            << \"\\n\";\n  // Note: The lambda function 'isOdd' is just a read-only\n  // operation and doesn't modify the vector, ensuring we\n  // don't have to worry about invalidation.\n  return 0;\n}\n```", "```cpp\nFifth element: 5\nElement at the earlier fifth position after insertion: 5\nNumber of odd values: 6\n```", "```cpp\n#include <chrono>\n#include <iostream>\n#include <mutex>\n#include <thread>\n#include <vector>\nstd::mutex vecMutex;\nvoid add_to_vector(std::vector<int> &numbers, int value) {\n  std::lock_guard<std::mutex> guard(vecMutex);\n  numbers.push_back(value);\n}\nvoid print_vector(const std::vector<int> &numbers) {\n  std::lock_guard<std::mutex> guard(vecMutex);\n  for (int num : numbers) { std::cout << num << \" \"; }\n  std::cout << \"\\n\";\n}\nint main() {\n  std::vector<int> numbers;\n  std::thread t1(add_to_vector, std::ref(numbers), 1);\n  std::thread t2(add_to_vector, std::ref(numbers), 2);\n  t1.join();\n  t2.join();\n  std::thread t3(print_vector, std::ref(numbers));\n  t3.join();\n  return 0;\n}\n```", "```cpp\n2 1\n```"]