- en: Chapter 9. Adding Animation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。添加动画
- en: In this chapter, we will learn the techniques of animating 2D and 3D objects.
    We will introduce Cinder's features in this field, such as timeline `and math`
    functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习动画化 2D 和 3D 对象的技术。我们将介绍 Cinder 在此领域的功能，例如时间轴和数学函数。
- en: 'The recipes in this chapter will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的食谱将涵盖以下内容：
- en: Animating with the timeline
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用时间轴动画化
- en: Creating animation sequences with the timeline
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用时间轴创建动画序列
- en: Animating along a path
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿路径动画化
- en: Aligning camera motion to a path
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相机运动与路径对齐
- en: Animating text – text as a mask for a movie
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画化文本 - 文本作为电影的遮罩
- en: Animating text – scrolling text lines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画化文本 - 滚动文本行
- en: Creating a flow field with Perlin noise
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Perlin 噪声创建流场
- en: Creating an image gallery in 3D
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 3D 中创建图像库
- en: Creating a spherical flow field with Perlin noise
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Perlin 噪声创建球形流场
- en: Animating with the timeline
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用时间轴动画化
- en: In this recipe, we will learn how we can animate values using Cinder's new feature;
    the timeline.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用 Cinder 的新功能；时间轴来动画化值。
- en: We animate the background color and a circle's position and radius whenever
    the user presses the mouse button.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下鼠标按钮时，我们动画化背景颜色、圆的位置和半径。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Include the necessary files to use the timeline, generate random numbers, and
    draw using OpenGL. Add the following code snippet at the top of the source file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 包含必要的文件以使用时间轴、生成随机数和使用 OpenGL 绘制。在源文件顶部添加以下代码片段：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Also, add the following useful `using` statements:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，添加以下有用的 `using` 语句：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will create several parameters that will be animated with the timeline.
    Perform the following steps to do so:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建几个参数，这些参数将使用时间轴进行动画化。执行以下步骤来完成此操作：
- en: 'Declare the following members to be animated:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明以下成员以进行动画化：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Initialize the parameters in the `setup` method.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中初始化参数。
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the `draw` method, we need to clear the background using the color defined
    in `mBackgroundColor` and draw a circle at `mCenter` with `mRadius` as the radius.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `draw` 方法中，我们需要使用在 `mBackgroundColor` 中定义的颜色清除背景，并在 `mCenter` 位置使用 `mRadius`
    作为半径绘制一个圆。
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To animate the values whenever the user presses the mouse button, we need to
    declare the `mouseDown` event handler.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在用户按下鼠标按钮时动画化值，我们需要声明 `mouseDown` 事件处理器。
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's implement the `mouseDown` event handler and add the animations to the
    main timeline. We will animate `mBackgroundColor` to a new random color, set `mCenter`
    to the mouse cursor's position, and set `mRadius` to a new random value.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现 `mouseDown` 事件处理器并将动画添加到主时间轴。我们将动画化 `mBackgroundColor` 到一个新的随机颜色，将 `mCenter`
    设置为鼠标光标的当前位置，并将 `mRadius` 设置为一个新的随机值。
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The timeline is a new feature of Cinder introduced in version 0.8.4\. It permits
    the user to animate parameters by adding them to the timeline once, and everything
    gets updated behind the scenes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴是 Cinder 在 0.8.4 版本中引入的新功能。它允许用户通过将参数添加到时间轴一次来动画化参数，所有更新都在幕后进行。
- en: Animations must be objects of the template class `ci::Anim`. This class can
    be created using any template type that supports the `+` operator.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 动画必须是模板类 `ci::Anim` 的对象。此类可以使用支持 `+` 操作符的任何模板类型创建。
- en: The main `ci::Timeline` object can be accessed by calling the `ci::app::App::timeline()`
    method. There is always a main timeline and the user can also create other `ci::Timeline`
    objects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 主 `ci::Timeline` 对象可以通过调用 `ci::app::App::timeline()` 方法访问。始终有一个主时间轴，用户也可以创建其他
    `ci::Timeline` 对象。
- en: The fourth parameter in the `ci::Timeline::apply` method is a `functor` object
    that represents a Tween method. Cinder has several Tweens available that can be
    passed as a parameter to define the type of animation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`ci::Timeline::apply` 方法中的第四个参数是一个表示 Tween 方法的 `functor` 对象。Cinder 有几个可用的 Tweens
    可以作为参数传递，以定义动画的类型。'
- en: There's more…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `ci::Timeline::apply` method used in the preceding example uses the initial
    value of the `ci::Anim` object, but it is also possible to create an animation
    where both the begining and end values are passed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的示例中使用的 `ci::Timeline::apply` 方法使用了 `ci::Anim` 对象的初始值，但也可以创建一个动画，其中开始和结束值都传递。
- en: 'For example, if we wanted to animate `mRadius` from a starting value of 10.0
    to the end value of 100.0 seconds, we would call the following method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想将 `mRadius` 从起始值 10.0 动画到结束值 100.0 秒，我们将调用以下方法：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To see all the available easing functions, please refer to the Cinder documentation,
    located at [http://libcinder.org/docs/v0.8.4/_easing_8h.html](http://libcinder.org/docs/v0.8.4/_easing_8h.html).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看所有可用的缓动函数，请参阅 Cinder 文档，位于 [http://libcinder.org/docs/v0.8.4/_easing_8h.html](http://libcinder.org/docs/v0.8.4/_easing_8h.html)。
- en: Creating animation sequences with the timeline
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用时间轴创建动画序列
- en: In this recipe, we will learn how to use the powerful timeline features of Cinder
    to create sequences of animations. We will draw a circle and animate the radius
    and color in a sequenced manner.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将学习如何使用 Cinder 强大的时间轴功能来创建动画序列。我们将绘制一个圆，并按顺序动画化半径和颜色。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Include the necessary files to use the timeline, draw in OpenGL, and generate
    random numbers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 包含必要的文件以使用时间轴、在 OpenGL 中绘制以及生成随机数。
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, add the following useful `using` statements:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 还要添加以下有用的 `using` 语句：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'We will animate several parameters sequentially using the timeline. Perform
    the following steps to do so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用时间轴依次动画化几个参数。执行以下步骤来完成：
- en: 'Declare the following members to define the circle''s position, radius, and
    color:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明以下成员以定义圆的位置、半径和颜色：
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `setup` method, initialize the members. Set the position to be at the
    center of the window, the radius as 30, and a random color using the HSV color
    mode.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中，初始化成员。将位置设置为窗口中心，半径为 30，并使用 HSV 颜色模式生成一个随机颜色。
- en: '[PRE11]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `draw` method, we will clear the background with black and draw the circle
    using the previously defined members.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `draw` 方法中，我们将使用黑色清除背景，并使用之前定义的成员来绘制圆圈。
- en: '[PRE12]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Declare the `mouseDown` event handler.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `mouseDown` 事件处理器。
- en: '[PRE13]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the implementation of `mouseDown`, we will apply the animations to the main
    timeline.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `mouseDown` 的实现中，我们将应用动画到主时间轴上。
- en: We will first animate `mRadius` from 30 to 200 and append another animation
    to `mRadius` from 200 to 30.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将首先将 `mRadius` 从 30 动画到 200，然后向 `mRadius` 附加另一个从 200 到 30 的动画。
- en: 'Add the following code snippet to the `mouseDown` method:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到 `mouseDown` 方法中：
- en: '[PRE14]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's create a random color using the HSV color mode and use it as the target
    color to animate `mColor` and then append this animation to `mRadius`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 HSV 颜色模式创建一个随机颜色，并将其用作动画 `mColor` 的目标颜色，然后将此动画附加到 `mRadius`。
- en: 'Add the following code snippet inside the `mouseDown` method:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `mouseDown` 方法内添加以下代码片段：
- en: '[PRE15]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Appending animations is a powerful and easy way to create complex animation
    sequences.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 附加动画是创建复杂动画序列的强大且简单的方法。
- en: 'In step 5 we append an animation to `mRadius` using the following line of code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 步中，我们使用以下代码行将动画添加到 `mRadius`：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This means this animation will only occur after the previous `mRadius` animation
    has finished.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着此动画将在之前的 `mRadius` 动画完成后发生。
- en: 'In step 6 we append the `mColor` animation to `mRadius` using the following
    line of code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 步中，我们使用以下代码行将 `mColor` 动画附加到 `mRadius`：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This means the `mColor` animation will only occur when the previous `mRadius`
    animation has finished.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `mColor` 动画仅在之前的 `mRadius` 动画完成后才会发生。
- en: There's more…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: When appending two different animations, it is possible to offset the start
    time by defining the offset seconds as a second parameter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当附加两个不同的动画时，可以通过定义偏移秒数作为第二个参数来偏移起始时间。
- en: 'So, for example, change the line in step 6 to read the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，将第 6 步中的行更改为以下内容：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This would mean that the `mColor` animation would begin 0.5 seconds before `mRadius`
    has finished.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `mColor` 动画将在 `mRadius` 完成后 0.5 秒开始。
- en: Animating along a path
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沿路径动画化
- en: In this recipe, we will learn how to draw a smooth B-spline in the 3D space
    and animate the position of an object along the calculated B-spline.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将学习如何在 3D 空间中绘制平滑的 B 样条，并动画化对象沿计算出的 B 样条的位置。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To navigate in the 3D space, we will use `MayaCamUI` covered in the *Using MayaCamUI*
    recipe in [Chapter 2](ch02.html "Chapter 2. Preparing for Development"), *Preparing
    for Development*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 3D 空间中导航，我们将使用在 [第 2 章](ch02.html "第 2 章。为开发做准备") 中介绍的 *使用 MayaCamUI* 菜单的
    `MayaCamUI`，*为开发做准备*。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'We will create an example animation of an object moving along the spline. Perform
    the following steps to do so:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个示例动画，展示一个对象沿着样条曲线移动。执行以下步骤来完成：
- en: Include necessary header files.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件。
- en: '[PRE19]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Begin with the declaration of member variables to keep the B-spline and current
    object's position.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从声明成员变量开始，以保留 B 样条和当前对象的位置。
- en: '[PRE20]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inside the `setup` method prepare a random spline:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法内部准备一个随机的样条曲线：
- en: '[PRE21]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Inside the `update` method, retrieve the position of the object moving along
    the spline.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法内部，检索沿着样条移动的物体的位置。
- en: '[PRE22]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The code snippet drawing our scene will look like the following:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制场景的代码片段看起来如下：
- en: '[PRE23]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, have a look at step 3 where we are calculating a B-spline through points
    with coordinates based on the sine and cosine functions and some random points
    on the x axis. The path is stored in the `spline` class member.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看看第3步，我们在该步骤中通过基于正弦和余弦函数以及x轴上的一些随机点计算B样条。路径存储在`spline`类成员中。
- en: Then we can easily retrieve the position in 3D space at any distance of our
    path. We are doing this in step 4; using the `getPosition` method on the `spline`
    member. The distance on the path is been passed as a `float` value in the range
    of 0.0 to 1.0 where 0.0 means the beginning of the path and 1.0 means the end.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以轻松地检索路径上任何距离的3D空间中的位置。我们在第4步中这样做；使用`spline`成员上的`getPosition`方法。路径上的距离作为0.0到1.0范围内的`float`值传递，其中0.0表示路径的开始，1.0表示路径的结束。
- en: 'Finally, in step 5 we are drawing an animation as a red sphere traveling along
    our path, represented as a black dashed line, as shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第5步中，我们绘制了一个动画，一个红色球体沿着我们的路径（用黑色虚线表示）移动，如下面的截图所示：
- en: '![How it works…](img/8703OS_09_01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/8703OS_09_01.jpg)'
- en: See also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Aligning camera motion to path* recipe
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将相机运动与路径对齐*配方'
- en: The *Animating text around curves* recipe in [Chapter 7](ch07.html "Chapter 7. Using
    2D Graphics"), *Using 2D Graphics*
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章. 使用2D图形")中的*在曲线上动画文本*配方，*使用2D图形*'
- en: Aligning camera motion to a path
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将相机运动与路径对齐
- en: In this recipe we will learn how we can animate the camera position on our path,
    calculated as a B-spline.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习如何动画化沿着路径（计算为B样条）的相机位置。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we will use `MayaCamUI`, so please refer to the *Using MayaCamUI*
    recipe in [Chapter 2](ch02.html "Chapter 2. Preparing for Development"), *Preparing
    for Development*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用`MayaCamUI`，因此请参阅[第2章](ch02.html "第2章. 准备开发")中的*使用MayaCamUI*配方，*准备开发*。
- en: How to do it…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will create an application illustrating the mechanism. Perform the following
    steps to do so:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个演示该机制的程序。执行以下步骤：
- en: Include necessary header files.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件。
- en: '[PRE24]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Begin with the declaration of member variables.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从成员变量的声明开始。
- en: '[PRE25]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Set up the initial values of members.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置成员的初始值。
- en: '[PRE26]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Inside the `update` method update the camera properties.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法内部更新相机属性。
- en: '[PRE27]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The whole `draw` method now looks like the following code snippet:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在的整个`draw`方法看起来如下代码片段：
- en: '[PRE28]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we have to implement the `drawScene` method, which actually draws our 3D
    scene.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须实现`drawScene`方法，它实际上绘制我们的3D场景。
- en: '[PRE29]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The last thing we need is the `drawGrid` method, the implementation of which
    can be found in the *Using 3D space guides* recipe in [Chapter 2](ch02.html "Chapter 2. Preparing
    for Development"), *Preparing for Development*.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后需要的是`drawGrid`方法，其实现可以在[第2章](ch02.html "第2章. 准备开发")中的*使用3D空间指南*配方中找到，*准备开发*。
- en: How it works…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this example we are using a B-spline as a path that our camera is moving
    along. Please refer to the *Animating along a path* recipe to see the basic implementation
    of an object animating on a path. As you can see in step 4 we are setting the
    camera position by invoking the `setEyePosition` method on the `mMovingCam` member,
    and we have to set the camera view direction. To do that we are taking the position
    of the next point on the path and passing it to the `lookAt` method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用B样条作为路径，我们的相机沿着该路径移动。请参阅*沿着路径动画*配方，以查看对象在路径上动画化的基本实现。如您在第4步中看到的，我们通过在`mMovingCam`成员上调用`setEyePosition`方法来设置相机位置，我们必须设置相机视图方向。为此，我们获取路径上的下一个点的位置并将其传递给`lookAt`方法。
- en: We are drawing a split screen, where on the left-hand side is a preview of our
    scene, and on the right-hand side we can see what is in a frustum of the camera
    moving along the path.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在绘制一个分割屏幕，其中左侧是我们的场景预览，右侧我们可以看到沿着路径移动的相机视锥体内的内容。
- en: '![How it works…](img/8703OS_09_02.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/8703OS_09_02.jpg)'
- en: See also
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Animating along a path* recipe
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*沿着路径动画*配方'
- en: The *Using 3D space guides* recipe in [Chapter 2](ch02.html "Chapter 2. Preparing
    for Development"), *Preparing for Development*
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。准备开发")中的*使用3D空间指南*食谱，*准备开发*'
- en: The *Using MayaCamUI* recipe in [Chapter 2](ch02.html "Chapter 2. Preparing
    for Development"), *Preparing for Development*
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章。准备开发")中的*使用MayaCamUI*食谱，*准备开发*'
- en: Animating text – text as a mask for a movie
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画文本 – 文本作为电影的遮罩
- en: In this recipe, we will learn how we can use text as a mask for a movie using
    a simple shader program.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何使用简单的着色器程序将文本用作电影的遮罩。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example, we are using one of the amazing videos provided by NASA taken
    by an ISS crew that you can find at [http://eol.jsc.nasa.gov/](http://eol.jsc.nasa.gov/).
    Please download oneand save it as `video.mov` inside the `assets` folder.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一部由NASA提供的令人惊叹的视频，由国际空间站（ISS）机组人员拍摄，你可以在[http://eol.jsc.nasa.gov/](http://eol.jsc.nasa.gov/)找到它。请下载一个并将其保存为`assets`文件夹内的`video.mov`。
- en: How to do it…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will create a sample Cinder application to illustrate the mechanism. Perform
    the following steps to do so:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个示例 Cinder 应用程序来展示该机制。按照以下步骤进行操作：
- en: Include the necessary header files.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件。
- en: '[PRE30]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Declare the member variables.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明成员变量。
- en: '[PRE31]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement the `setup` method, as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下`setup`方法：
- en: '[PRE32]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Inside the `update` method we have to update our `mFrameTexture` where we are
    keeping the current movie frame.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法内部，我们必须更新我们的`mFrameTexture`，其中我们保存当前的电影帧。
- en: '[PRE33]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `draw` method will look like the following code snippet:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`draw`方法将类似于以下代码片段：'
- en: '[PRE34]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see in the `setup` method we are loading a shader to do the masking.
    We have to pass through vertex shader inside the `assets` folder in a file named
    `passThru_vert.glsl`. You can find this in the *Implementing 2D metaballs* recipe
    in [Chapter 7](ch07.html "Chapter 7. Using 2D Graphics"), *Using 2D Graphics*.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你在`setup`方法中看到的，我们正在加载一个用于遮罩的着色器。我们必须通过`assets`文件夹内的一个名为`passThru_vert.glsl`的顶点着色器传递。你可以在[第7章](ch07.html
    "第7章。使用2D图形")的*实现2D元球*食谱中找到它，*使用2D图形*。
- en: Finally, the fragment shader program code will look like the following code
    snippet, and should also be inside the `assets` folder under the name `masking_frag.glsl`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，片段着色器程序代码将类似于以下代码片段，并且也应该位于`assets`文件夹下，命名为`masking_frag.glsl`。
- en: '[PRE35]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Inside the `setup` method in step 3 we are rendering our text as `Surface` and
    then converting it to `gl::Texture` that we will use later as a masking texture.
    It is important here to set a rectangle format for masking texture while we are
    using it as a mask for a movie, because `qtime::MovieGl` is creating a texture
    with a frame that is rectangular. To do that we are defining the `gl::Texture::Format`
    object named `format` and invoking the `setTargetRect` method on it. While creating
    `gl::Texture` we have to pass `format` to the constructor as a second parameter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步的`setup`方法内部，我们将文本渲染为`Surface`，然后将其转换为`gl::Texture`，我们稍后将其用作遮罩纹理。当我们将其用作电影的遮罩时，设置遮罩纹理的矩形格式非常重要，因为`qtime::MovieGl`正在创建一个具有矩形帧的纹理。为此，我们定义了一个名为`format`的`gl::Texture::Format`对象，并在其上调用`setTargetRect`方法。在创建`gl::Texture`时，我们必须将`format`作为第二个参数传递给构造函数。
- en: To draw a movie frame we are using our masking shader program applied on the
    rectangle in step 5\. We have to pass three parameters, which are the movie frame
    as `sourceTexture`, mask texture with text as `maskTexture`, and the position
    of the mask as `maskOffset`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制电影帧，我们使用在第5步中应用的遮罩着色器程序。我们必须传递三个参数，分别是电影帧作为`sourceTexture`、带有文本的遮罩纹理作为`maskTexture`以及遮罩的位置作为`maskOffset`。
- en: In step 7 you can see the fragment shader code, which simply multiplies the
    colors of the corresponding pixels from `sourceTexture` and `maskTexture`. Please
    notice that we are using `sampler2DRect` and `texture2DRect` to handle rectangular
    textures.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7步中，你可以看到片段着色器代码，它简单地乘以`sourceTexture`和`maskTexture`中相应像素的颜色。请注意，我们正在使用`sampler2DRect`和`texture2DRect`来处理矩形纹理。
- en: '![How it works…](img/8703OS_09_03.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/8703OS_09_03.jpg)'
- en: Animating text – scrolling text lines
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画文本 – 滚动文本行
- en: In this recipe we will learn how we can create text scrolling line-by-line.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何逐行创建文本滚动。
- en: How to do it…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will now create an animation with scrolling text. Perform the following
    steps to do so:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个带有滚动文本的动画。按照以下步骤进行操作：
- en: Include the necessary header files.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件。
- en: '[PRE36]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Add the member values.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加成员值。
- en: '[PRE37]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Inside the `setup` method we need to generate textures for each line of text.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法内部，我们需要为每行文本生成纹理。
- en: '[PRE38]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `draw` method for this example looks as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此示例的`draw`方法如下所示：
- en: '[PRE39]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: What we are doing first inside the `setup` method in step 3 is generating a
    texture with rendered text for each line and pushing it to the vector structure
    `mTextTextures`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤3中，我们在`setup`方法内部首先执行的操作是生成带有渲染文本的纹理，并将其推送到向量结构`mTextTextures`中。
- en: In step 4 you can find the code for drawing current and previous text to build
    a continuous looped animation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤4中，你可以找到绘制当前和先前文本的代码，以构建连续循环动画。
- en: '![How it works…](img/8703OS_09_04.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/8703OS_09_04.jpg)'
- en: Creating a flow field with Perlin noise
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Perlin噪声创建流动场
- en: In this recipe we will learn how we can animate objects using a flow field.
    Our flow field will be a two-dimensional grid of velocity vectors that will influence
    how objects move.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用流动场来动画化对象。我们的流动场将是一个二维速度向量网格，它将影响对象的移动方式。
- en: We will also animate the flow field using vectors calculated with Perlin noise.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用Perlin噪声计算出的向量来动画化流动场。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Include the necessary files to work with OpenGL graphics, Perlin noise, random
    numbers, and Cinder's math utilities.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 包含必要的文件以使用OpenGL图形、Perlin噪声、随机数和Cinder的数学工具。
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Also, add the following useful `using` statements:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 还要添加以下有用的`using`语句：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How to do it…
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will create an animation using the flow field. Perform the following steps
    to do so:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用流动场创建一个动画。执行以下步骤以实现此目的：
- en: We will begin by creating a `Follower` class to define the objects that will
    be influenced by the flow field.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个`Follower`类来定义将受流动场影响的对象。
- en: 'Declare the following class before the main application class:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在主应用程序类之前声明以下类：
- en: '[PRE42]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Let's create the flow field. Declare a two-dimensional `std::vector` to define
    the flow field, and variables to define the gap between vectors and the number
    of rows and columns.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建流动场。声明一个二维`std::vector`来定义流动场，以及定义向量间隔和行数列数的变量。
- en: '[PRE43]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the `setup` method we will define the number of rows and columns, and calculate
    the gap between each vector.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，我们将定义行数和列数，并计算每个向量之间的间隔。
- en: '[PRE44]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Based on the number of rows and columns we can initialize `mFlowField`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据行数和列数，我们可以初始化`mFlowField`。
- en: '[PRE45]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s animate the flow field using Perlin noise. To do so declare the following
    members:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用Perlin噪声来动画化流动场。为此，声明以下成员：
- en: '[PRE46]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the `setup` method initialize `mCounter` to zero.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，将`mCounter`初始化为零。
- en: '[PRE47]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the `update` method we will increment `mCounter` and iterate `mFlowField`
    using a nested `for` loop, and use `mPerlin` to animate the vectors.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们将增加`mCounter`并使用嵌套的`for`循环遍历`mFlowField`，并使用`mPerlin`来动画化向量。
- en: '[PRE48]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now iterate over `mFlowField` and draw a line indicating the direction of the
    vectors.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，遍历`mFlowField`并绘制表示向量方向的线条。
- en: 'Add the following code snippet inside the `draw` method:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`draw`方法内部添加以下代码片段：
- en: '[PRE49]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s add some `Followers`. Declare the following member:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一些`Followers`。声明以下成员：
- en: '[PRE50]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the `setup` method we will initialize some followers and add them at random
    positions in the window.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，我们将初始化一些跟随者并将它们随机添加到窗口中的位置。
- en: '[PRE51]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the update we will iterate `mFollowers` and calculate the corresponding vector
    in `mFlowField` based on its position.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新中，我们将遍历`mFollowers`并根据其位置在`mFlowField`中计算相应的向量。
- en: We will then update the `Follower` class using that vector.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们将使用该向量更新`Follower`类。
- en: '[PRE52]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Finally, we just need to draw each `Follower` class.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需要绘制每个`Follower`类。
- en: 'Add the following code snippet inside the `draw` method:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`draw`方法内部添加以下代码片段：
- en: '[PRE53]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following is the result:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '![How to do it…](img/8703OS_09_05.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/8703OS_09_05.jpg)'
- en: How it works…
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: The `Follower` class represents an agent that will follow the flow field. In
    the `Follower::update` method a new velocity vector is passed as a parameter.
    The `follower` object will interpolate its velocity into the passed value and
    use it to animate. The `Follower::update` method is also responsible for keeping
    each agent inside the window by warping its position whenever it is outside the
    window.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`Follower`类代表一个将跟随流动场的代理。在`Follower::update`方法中，将一个新的速度向量作为参数传递。`follower`对象将将其速度插值到传递的值中，并使用它进行动画。`Follower::update`方法还负责通过在对象位于窗口外部时扭曲其位置来保持每个代理在窗口内。'
- en: In step 11 we calculated the vector in the flow field that will influence the
    `Follower` object using it's position.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤11中，我们计算了流场中影响`Follower`对象的向量，使用其位置。
- en: Creating an image gallery in 3D
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个3D图片库
- en: In this recipe we will learn how we can create an image gallery in 3D. The images
    will be loaded from a folder selected by the user and displayed in a three-dimensional
    circular fashion. Using the keyboard, the user will be able to change the selected
    image.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建一个3D图片库。图片将从用户选择的文件夹中加载，并以三维圆形方式显示。使用键盘，用户可以更改选定的图片。
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: When starting the application you will be asked to select a folder with images,
    so make sure you have one.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动应用程序时，您将被要求选择一个包含图片的文件夹，所以请确保您有一个。
- en: Also, in your code include the necessary files to use OpenGL drawing calls,
    textures, the timeline, and loading images.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在您的代码中包含使用OpenGL绘图调用、纹理、时间轴和加载图片所需的必要文件。
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Also, add the following useful `using` statements:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，添加以下有用的`using`语句：
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How to do it…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will display and animate images in 3D space. Perform the following steps
    to do so:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在3D空间中显示和动画图片。执行以下步骤以实现此目的：
- en: 'We will start by creating an `Image` class. Add the following code snippet
    before the main application class:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个`Image`类。在主应用程序类之前添加以下代码片段：
- en: '[PRE56]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the main application''s class we will declare the following members:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主应用程序类中，我们将声明以下成员：
- en: '[PRE57]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the `setup` method we will ask the user to select a folder and then try to
    create a texture from each file in the folder. If a texture is successfully created,
    we will use it to create an `Image` object and add it to `mImages`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，我们将要求用户选择一个文件夹，然后尝试从文件夹中的每个文件创建一个纹理。如果纹理成功创建，我们将使用它来创建一个`Image`对象并将其添加到`mImages`中。
- en: '[PRE58]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We need to iterate over `mImages` and define the angle and distance that each
    image will have from the center.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要遍历`mImages`并定义每个图片与中心的角度和距离。
- en: '[PRE59]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now we can initialize the remaining members.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以初始化剩余的成员。
- en: '[PRE60]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the `draw` method, we will start by clearing the window, setting the window''s
    matrices to support 3D, and enabling reading and writing in the depth buffer:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法中，我们首先清除窗口，将窗口的矩阵设置为支持3D，并启用深度缓冲区的读写：
- en: '[PRE61]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Next we will draw the images. Since all our images have been displayed around
    the origin, we must translate them to the center of the window. We will also rotate
    them around the y axis using the value in `mRotationOffset`. Everything will go
    in an `if` statement that will check if `mImages` contains any image, in case
    no image was generated during the setup.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将绘制图片。由于所有图片都已围绕原点显示，我们必须将它们平移到窗口的中心。我们还将使用`mRotationOffset`中的值围绕y轴旋转它们。所有这些都将放在一个`if`语句中，该语句将检查`mImages`是否包含任何图片，以防在设置过程中没有生成图片。
- en: 'Add the following code snippet inside the `draw` method:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法内部添加以下代码片段：
- en: '[PRE62]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Since the user will be able to switch images using the keyboard, we must declare
    the `keyUp` event handler.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于用户可以使用键盘切换图片，我们必须声明`keyUp`事件处理程序。
- en: '[PRE63]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the implementation of `keyUp` we will move the images on to the left or right-hand
    side depending on whether the left or right key was released.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`keyUp`的实现中，我们将根据左键或右键是否释放将图片移动到左侧或右侧。
- en: If the selected image was changed, we animate `mRotationOffset` to the correspondent
    value, so that the correct image is now facing the user.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果选定的图片已更改，我们将`mRotationOffset`动画到相应的值，以便正确的图片现在面向用户。
- en: 'Add the following code snippet inside the `keyUp` method:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`keyUp`方法内部添加以下代码片段：
- en: '[PRE64]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Build and run the application. You will be prompted to select a folder containing
    images that will then be displayed in a circular fashion. Press the left or right
    key on the keyboard to change the selected image.![How to do it…](img/8703OS_09_06.jpg)
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。您将被提示选择一个包含图片的文件夹，然后图片将以圆形方式显示。按键盘上的左键或右键更改选定的图片。![如何操作…](img/8703OS_09_06.jpg)
- en: How it works…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `draw` method of the `Image` class rotates the coordinate system around
    the y axis and then translates the image drawing on the z axis. This will extrude
    the image from the center facing outwards on the given angle. It is an easy and
    convenient way of achieving the desired effect without dealing with coordinate
    transformations.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image`类的`draw`方法将围绕y轴旋转坐标系，然后在z轴上平移图像绘制。这将根据给定的角度从中心向外扩展图像。这是一个简单且方便的方法，无需处理坐标变换即可实现所需效果。'
- en: The `Image::rect` member is used to draw the texture and is calculated to fit
    inside the rectangle passed in the constructor.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image::rect`成员用于绘制纹理，并计算以适应在构造函数中传入的矩形内。'
- en: When selecting the image to be displayed in front, the value of `mRotationOffset`
    will be the opposite of the image's angle, making it the image being drawn in
    front of the view.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择要显示在前面图像时，`mRotationOffset`的值将是图像角度的相反数，使其成为在视图中绘制的图像。
- en: In the `keyUp` event we check whether the left or right key was pressed and
    animate `mRotationOffset` to the desired value. We also take into account if the
    angle wraps around, as to avoid glitches in the animation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在`keyUp`事件中，我们检查是否按下了左键或右键，并将`mRotationOffset`动画化到所需值。我们还考虑到角度是否绕过，以避免动画中的故障。
- en: Creating a spherical flow field with Perlin noise
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Perlin噪声创建球形流场
- en: In this recipe we will learn how to use Perlin noise with a spherical flow field
    and animate objects in an organic way around a sphere.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用球形流场与Perlin噪声，并以有机的方式在球体周围动画化对象。
- en: We will animate our objects using spherical coordinates and then transform them
    into Cartesian coordinates in order to draw them.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用球形坐标来动画化我们的对象，然后将其转换为笛卡尔坐标以绘制它们。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Add the necessary files to use Perlin noise and draw with OpenGL:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 添加必要的文件以使用Perlin噪声和用OpenGL绘制：
- en: '[PRE65]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Add the following useful `using` statements:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下有用的`using`语句：
- en: '[PRE66]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How to do it…
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will create the `Follower` objects that move organically in a spherical
    flow field. Perform the following steps to do so:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建在球形流场中有机移动的`Follower`对象。执行以下步骤来完成此操作：
- en: We will start by creating a `Follower` class representing an object that will
    follow the spherical flow field.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个表示将跟随球形流场的对象的`Follower`类。
- en: 'Add the following code snippet before the application''s class declaration:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在应用程序类的声明之前添加以下代码片段：
- en: '[PRE67]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We will be using spherical to Cartesian coordinates, so declare the following
    method in the application''s class:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用球形到笛卡尔坐标，因此在应用程序的类中声明以下方法：
- en: '[PRE68]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The implementation of this method is as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法的实现如下：
- en: '[PRE69]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Declare the following members in the application''s class:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的类中声明以下成员：
- en: '[PRE70]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the `setup` method we will begin by initializing `mRadius` and `mCounter`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，我们首先初始化`mRadius`和`mCounter`：
- en: '[PRE71]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now let''s create 100 followers and add them to `mFollowers`. We will also
    attribute random values to the `phi` and `theta` variables of the `Follower` objects
    and set their initial positions:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建100个跟随者并将它们添加到`mFollowers`中。我们还将为`Follower`对象的`phi`和`theta`变量分配随机值，并设置它们的初始位置：
- en: '[PRE72]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the `update` method we will animate our objects. Let's start by incrementing
    `mCounter`.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们将动画化我们的对象。让我们首先增加`mCounter`。
- en: '[PRE73]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now we will iterate over all the objects in `mFollowers` and use Perlin noise,
    based on the follower's position, to calculate how much it should move on spherical
    coordinates. We will then calculate the correspondent Cartesian coordinates and
    move the object.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将遍历`mFollowers`中的所有对象，并根据跟随者的位置使用Perlin噪声来计算它在球形坐标上应该移动多少。然后我们将计算相应的笛卡尔坐标，并移动对象。
- en: 'Add the following code snippet inside the `update` method:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`update`方法内部添加以下代码片段：
- en: '[PRE74]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Let's move to the `draw` method and begin by clearing the background, setting
    the windows matrices, and enabling reading and writing in the depth buffer.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到`draw`方法，首先清除背景，设置窗口矩阵，并启用深度缓冲区的读写。
- en: '[PRE75]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Since the followers are moving around the origin, we will draw them translated
    to the origin using a dark gray color. We will also draw a white sphere to get
    a better understanding of the movement.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于跟随者正在围绕原点移动，我们将使用深灰色将它们平移到原点进行绘制。我们还将绘制一个白色球体，以便更好地理解运动。
- en: '[PRE76]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How it works...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We use Perlin noise to calculate the change in the `theta` and `phi` members
    of the `Follower` objects. We use these, together with `mRadius`, to calculate
    the position of the objects using the standard spherical to Cartesian coordinate
    transformation. Since Perlin noise gives coherent values based on coordinates
    by using the current position of the `Follower` objects, we get the equivalent
    of a flow field. The `mCounter` variable is used to animate the flow field in
    the third dimension.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Perlin噪声来计算`Follower`对象中`theta`和`phi`成员的变化。我们使用这些值，再加上`mRadius`，通过标准的球坐标到笛卡尔坐标的转换来计算对象的位置。由于Perlin噪声根据`Follower`对象的当前位置使用坐标来给出连贯的值，我们得到了相当于一个流场的等效效果。`mCounter`变量用于在第三维度中动画化流场。
- en: '![How it works...](img/8703OS_09_07.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/8703OS_09_07.jpg)'
- en: See also
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more about the Cartesian coordinate system, please refer to [http://en.wikipedia.org/wiki/Cartesian_coordinate_system](http://en.wikipedia.org/wiki/Cartesian_coordinate_system)
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想了解更多关于笛卡尔坐标系的信息，请参阅[http://en.wikipedia.org/wiki/Cartesian_coordinate_system](http://en.wikipedia.org/wiki/Cartesian_coordinate_system)
- en: To learn more about the spherical coordinate system, please refer to [http://en.wikipedia.org/wiki/Spherical_coordinate_system](http://en.wikipedia.org/wiki/Spherical_coordinate_system)
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想了解更多关于球坐标系统，请参阅[http://en.wikipedia.org/wiki/Spherical_coordinate_system](http://en.wikipedia.org/wiki/Spherical_coordinate_system)
- en: To learn more about spherical to Cartesian coordinate transformations, please
    refer to [http://en.wikipedia.org/wiki/List_of_common_coordinate_transformations#From_spherical_coordinate](http://en.wikipedia.org/wiki/List_of_common_coordinate_transformations#From_spherical_coordinate)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想了解更多关于球坐标到笛卡尔坐标转换的信息，请参阅[http://en.wikipedia.org/wiki/List_of_common_coordinate_transformations#From_spherical_coordinate](http://en.wikipedia.org/wiki/List_of_common_coordinate_transformations#From_spherical_coordinate)
