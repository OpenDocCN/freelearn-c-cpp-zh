["```cpp\n$ git clone https://github.com/PacktPublishing/Extreme-C\nCloning into 'Extreme-C'...\n...\nResolving deltas: 100% (458/458), done.\n$ cd Extreme-C/ch20-socket-programming\n$ tree\n.\n├── CMakeLists.txt\n├── calcser\n...\n├── calcsvc\n...\n├── client\n│   ├── CMakeLists.txt\n│   ├── clicore\n...\n│   ├── tcp\n│   │   ├── CMakeLists.txt\n│   │   └── main.c\n│   ├── udp\n│   │   ├── CMakeLists.txt\n│   │   └── main.c\n│   └── Unix\n│       ├── CMakeLists.txt\n│       ├── datagram\n│       │   ├── CMakeLists.txt\n│       │   └── main.c\n│       └── stream\n│           ├── CMakeLists.txt\n│           └── main.c\n├── server\n│   ├── CMakeLists.txt\n│   ├── srvcore\n...\n│   ├── tcp\n│   │   ├── CMakeLists.txt\n│   │   └── main.c\n│   ├── udp\n│   │   ├── CMakeLists.txt\n│   │   └── main.c\n│   └── Unix\n│       ├── CMakeLists.txt\n│       ├── datagram\n│       │   ├── CMakeLists.txt\n│       │   └── main.c\n│       └── stream\n│           ├── CMakeLists.txt\n│           └── main.c\n└── types.h\n18 directories, 49 files\n$\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n...\n$ make\n...\n$\n```", "```cpp\n$ ./server/unix/stream/unix_stream_calc_server\n```", "```cpp\n$ ./client/unix/stream/unix_stream_calc_client\n? (type quit to exit) 3++4\nThe req(0) is sent.\nreq(0) > status: OK, result: 7.000000\n? (type quit to exit) mem\nThe req(1) is sent.\nreq(1) > status: OK, result: 7.000000\n? (type quit to exit) 5++4\nThe req(2) is sent.\nreq(2) > status: OK, result: 16.000000\n? (type quit to exit) quit\nBye.\n$\n```", "```cpp\n#ifndef CALC_PROTO_REQ_H\n#define CALC_PROTO_REQ_H\n#include <stdint.h>\ntypedef enum {\n  NONE,\n  GETMEM, RESMEM,\n  ADD, ADDM,\n  SUB, SUBM,\n  MUL, MULM,\n  DIV\n} method_t;\nstruct calc_proto_req_t {\n  int32_t id;\n  method_t method;\n  double operand1;\n  double operand2;\n};\nmethod_t str_to_method(const char*);\nconst char* method_to_str(method_t);\n#endif\n```", "```cpp\nstruct calc_proto_req_t req;\nreq.id = 1000;\nreq.method = ADD;\nreq.operand1 = 1.5;\nreq.operand2 = 5.6;\n```", "```cpp\n1000#ADD#1.5#5.6$\n```", "```cpp\n#ifndef CALC_PROTO_RESP_H\n#define CALC_PROTO_RESP_H\n#include <stdint.h>\n#define STATUS_OK              0\n#define STATUS_INVALID_REQUEST 1\n#define STATUS_INVALID_METHOD  2\n#define STATUS_INVALID_OPERAND 3\n#define STATUS_DIV_BY_ZERO     4\n#define STATUS_INTERNAL_ERROR  20\ntypedef int status_t;\nstruct calc_proto_resp_t {\n  int32_t req_id;\n  status_t status;\n  double result;\n};\n#endif\n```", "```cpp\nstruct calc_proto_resp_t resp;\nresp.req_id = 1000;\nresp.status = STATUS_OK;\nresp.result = 7.1;\n```", "```cpp\n1000#0#7.1$\n```", "```cpp\n#ifndef CALC_PROTO_SER_H\n#define CALC_PROTO_SER_H\n#include <types.h>\n#include \"calc_proto_req.h\"\n#include \"calc_proto_resp.h\"\n#define ERROR_INVALID_REQUEST          101\n#define ERROR_INVALID_REQUEST_ID       102\n#define ERROR_INVALID_REQUEST_METHOD   103\n#define ERROR_INVALID_REQUEST_OPERAND1 104\n#define ERROR_INVALID_REQUEST_OPERAND2 105\n#define ERROR_INVALID_RESPONSE         201\n#define ERROR_INVALID_RESPONSE_REQ_ID  202\n#define ERROR_INVALID_RESPONSE_STATUS  203\n#define ERROR_INVALID_RESPONSE_RESULT  204\n#define ERROR_UNKNOWN  220\nstruct buffer_t {\n  char* data;\n  int len;\n};\nstruct calc_proto_ser_t;\ntypedef void (*req_cb_t)(\n        void* owner_obj,\n        struct calc_proto_req_t);\ntypedef void (*resp_cb_t)(\n        void* owner_obj,\n        struct calc_proto_resp_t);\ntypedef void (*error_cb_t)(\n        void* owner_obj,\n        const int req_id,\n        const int error_code);\nstruct calc_proto_ser_t* calc_proto_ser_new();\nvoid calc_proto_ser_delete(\n        struct calc_proto_ser_t* ser);\nvoid calc_proto_ser_ctor(\n        struct calc_proto_ser_t* ser,\n        void* owner_obj,\n        int ring_buffer_size);\nvoid calc_proto_ser_dtor(\n        struct calc_proto_ser_t* ser);\nvoid* calc_proto_ser_get_context(\n        struct calc_proto_ser_t* ser);\nvoid calc_proto_ser_set_req_callback(\n        struct calc_proto_ser_t* ser,\n        req_cb_t cb);\nvoid calc_proto_ser_set_resp_callback(\n        struct calc_proto_ser_t* ser,\n        resp_cb_t cb);\nvoid calc_proto_ser_set_error_callback(\n        struct calc_proto_ser_t* ser,\n        error_cb_t cb);\nvoid calc_proto_ser_server_deserialize(\n        struct calc_proto_ser_t* ser,\n        struct buffer_t buffer,\n        bool_t* req_found);\nstruct buffer_t calc_proto_ser_server_serialize(\n        struct calc_proto_ser_t* ser,\n        const struct calc_proto_resp_t* resp);\nvoid calc_proto_ser_client_deserialize(\n        struct calc_proto_ser_t* ser,\n        struct buffer_t buffer,\n        bool_t* resp_found);\nstruct buffer_t calc_proto_ser_client_serialize(\n        struct calc_proto_ser_t* ser,\n        const struct calc_proto_req_t* req);\n#endif\n```", "```cpp\nstruct buffer_t calc_proto_ser_server_serialize(\n    struct calc_proto_ser_t* ser,\n    const struct calc_proto_resp_t* resp) {\n  struct buffer_t buff;\n  char resp_result_str[64];\n  _serialize_double(resp_result_str, resp->result);\n  buff.data = (char*)malloc(64 * sizeof(char));\n  sprintf(buff.data, \"%d%c%d%c%s%c\", resp->req_id,\n          FIELD_DELIMITER, (int)resp->status, FIELD_DELIMITER,\n      resp_result_str, MESSAGE_DELIMITER);\n  buff.len = strlen(buff.data);\n  return buff;\n}\n```", "```cpp\nstruct buffer_t {\n  char* data;\n  int len;\n};\n```", "```cpp\nvoid calc_proto_ser_server_deserialize(\n    struct calc_proto_ser_t* ser,\n    struct buffer_t buff,\n    bool_t* req_found) {\n  if (req_found) {\n    *req_found = FALSE;\n  }\n  _deserialize(ser, buff, _parse_req_and_notify,\n          ERROR_INVALID_REQUEST, req_found);\n}\n```", "```cpp\nstruct buffer_t calc_proto_ser_client_serialize(\n    struct calc_proto_ser_t* ser,\n    const struct calc_proto_req_t* req) {\n  struct buffer_t buff;\n  char req_op1_str[64];\n  char req_op2_str[64];\n  _serialize_double(req_op1_str, req->operand1);\n  _serialize_double(req_op2_str, req->operand2);\n  buff.data = (char*)malloc(64 * sizeof(char));\n  sprintf(buff.data, \"%d%c%s%c%s%c%s%c\", req->id, FIELD_DELIMITER,\n          method_to_str(req->method), FIELD_DELIMITER,\n          req_op1_str, FIELD_DELIMITER, req_op2_str,\n          MESSAGE_DELIMITER);\n  buff.len = strlen(buff.data);\n  return buff;\n}\n```", "```cpp\nvoid calc_proto_ser_client_deserialize(\n    struct calc_proto_ser_t* ser,\n    struct buffer_t buff, bool_t* resp_found) {\n  if (resp_found) {\n    *resp_found = FALSE;\n  }\n  _deserialize(ser, buff, _parse_resp_and_notify,\n          ERROR_INVALID_RESPONSE, resp_found);\n}\n```", "```cpp\n#ifndef CALC_SERVICE_H\n#define CALC_SERVICE_H\n#include <types.h>\nstatic const int CALC_SVC_OK = 0;\nstatic const int CALC_SVC_ERROR_DIV_BY_ZERO = -1;\nstruct calc_service_t;\nstruct calc_service_t* calc_service_new();\nvoid calc_service_delete(struct calc_service_t*);\nvoid calc_service_ctor(struct calc_service_t*);\nvoid calc_service_dtor(struct calc_service_t*);\nvoid calc_service_reset_mem(struct calc_service_t*);\ndouble calc_service_get_mem(struct calc_service_t*);\ndouble calc_service_add(struct calc_service_t*, double, double b,\n    bool_t mem);\ndouble calc_service_sub(struct calc_service_t*, double, double b,\n    bool_t mem);\ndouble calc_service_mul(struct calc_service_t*, double, double b,\n    bool_t mem);\nint calc_service_div(struct calc_service_t*, double,\n        double, double*);\n#endif\n```", "```cpp\nint server_sd = socket(AF_UNIX, SOCK_STREAM, 0);\nif (server_sd == -1) {\n  fprintf(stderr, \"Could not create socket: %s\\n\", strerror(errno));\n  exit(1);\n}\n```", "```cpp\nstruct sockaddr_un addr;\nmemset(&addr, 0, sizeof(addr));\naddr.sun_family = AF_UNIX;\nstrncpy(addr.sun_path, sock_file, sizeof(addr.sun_path) - 1);\nint result = bind(server_sd, (struct sockaddr*)&addr, sizeof(addr));\nif (result == -1) {\n  close(server_sd);\n  fprintf(stderr, \"Could not bind the address: %s\\n\", strerror(errno));\n  exit(1);\n}\n```", "```cpp\nresult = listen(server_sd, 10);\nif (result == -1) {\n  close(server_sd);\n  fprintf(stderr, \"Could not set the backlog: %s\\n\", strerror(errno));\n  exit(1);\n}\n```", "```cpp\nwhile (1) {\n  int client_sd = accept(server_sd, NULL, NULL);\n  if (client_sd == -1) {\n    close(server_sd);\n    fprintf(stderr, \"Could not accept the client: %s\\n\",\n        strerror(errno));\n    exit(1);\n  }\n  ...\n}\n```", "```cpp\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <stream_server_core.h>\nint main(int argc, char** argv) {\n  char sock_file[] = \"/tmp/calc_svc.sock\";\n  // ----------- 1\\. Create socket object ------------------\n  int server_sd = socket(AF_UNIX, SOCK_STREAM, 0);\n  if (server_sd == -1) {\n    fprintf(stderr, \"Could not create socket: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  // ----------- 2\\. Bind the socket file ------------------\n  // Delete the previously created socket file if it exists.\n  unlink(sock_file);\n  // Prepare the address\n  struct sockaddr_un addr;\n  memset(&addr, 0, sizeof(addr));\n  addr.sun_family = AF_UNIX;\n  strncpy(addr.sun_path, sock_file, sizeof(addr.sun_path) - 1);\n  int result = bind(server_sd,\n (struct sockaddr*)&addr, sizeof(addr));\n  if (result == -1) {\n    close(server_sd);\n    fprintf(stderr, \"Could not bind the address: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  // ----------- 3\\. Prepare backlog ------------------\n  result = listen(server_sd, 10);\n  if (result == -1) {\n    close(server_sd);\n    fprintf(stderr, \"Could not set the backlog: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  // ----------- 4\\. Start accepting clients ---------\n  accept_forever(server_sd);\n  return 0;\n}\n```", "```cpp\nvoid accept_forever(int server_sd) {\n  while (1) {\n    int client_sd = accept(server_sd, NULL, NULL);\n    if (client_sd == -1) {\n      close(server_sd);\n      fprintf(stderr, \"Could not accept the client: %s\\n\",\n              strerror(errno));\n      exit(1);\n    }\n    pthread_t client_handler_thread;\n    int* arg = (int *)malloc(sizeof(int));\n    *arg = client_sd;\n    int result = pthread_create(&client_handler_thread, NULL,\n            &client_handler, arg);\n    if (result) {\n      close(client_sd);\n      close(server_sd);\n      free(arg);\n      fprintf(stderr, \"Could not start the client handler thread.\\n\");\n      exit(1);\n    }\n  }\n}\n```", "```cpp\nvoid* client_handler(void *arg) {\n  struct client_context_t context;\n  context.addr = (struct client_addr_t*)\n      malloc(sizeof(struct client_addr_t));\n  context.addr->sd = *((int*)arg);\n  free((int*)arg);\n context.ser = calc_proto_ser_new();\n  calc_proto_ser_ctor(context.ser, &context, 256);\n  calc_proto_ser_set_req_callback(context.ser, request_callback);\n  calc_proto_ser_set_error_callback(context.ser, error_callback);\n  context.svc = calc_service_new();\n  calc_service_ctor(context.svc);\n  context.write_resp = &stream_write_resp;\n  int ret;\n  char buffer[128];\n  while (1) {\n    int ret = read(context.addr->sd, buffer, 128);\n    if (ret == 0 || ret == -1) {\n      break;\n    }\n    struct buffer_t buf;\n    buf.data = buffer; buf.len = ret;\n    calc_proto_ser_server_deserialize(context.ser, buf, NULL);\n  }\n  calc_service_dtor(context.svc);\n  calc_service_delete(context.svc);\n  calc_proto_ser_dtor(context.ser);\n  calc_proto_ser_delete(context.ser);\n  free(context.addr);\n  return NULL;\n}\n```", "```cpp\nvoid stream_write_resp(\n        struct client_context_t* context,\n        struct calc_proto_resp_t* resp) {\n  struct buffer_t buf =\n      calc_proto_ser_server_serialize(context->ser, resp);\n  if (buf.len == 0) {\n    close(context->addr->sd);\n    fprintf(stderr, \"Internal error while serializing response\\n\");\n    exit(1);\n  }\n  int ret = write(context->addr->sd, buf.data, buf.len);\n  free(buf.data);\n  if (ret == -1) {\n    fprintf(stderr, \"Could not write to client: %s\\n\",\n            strerror(errno));\n    close(context->addr->sd);\n    exit(1);\n  } else if (ret < buf.len) {\n    fprintf(stderr, \"WARN: Less bytes were written!\\n\");\n    exit(1);\n  }\n}\n```", "```cpp\nint main(int argc, char** argv) {\n  char sock_file[] = \"/tmp/calc_svc.sock\";\n  // ----------- 1\\. Create socket object ------------------\n  int conn_sd = socket(AF_UNIX, SOCK_STREAM, 0);\n  if (conn_sd == -1) {\n    fprintf(stderr, \"Could not create socket: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  // ----------- 2\\. Connect to server ---------------------\n  // Prepare the address\n  struct sockaddr_un addr;\n  memset(&addr, 0, sizeof(addr));\n  addr.sun_family = AF_UNIX;\n  strncpy(addr.sun_path, sock_file, sizeof(addr.sun_path) - 1);\n  int result = connect(conn_sd,\n (struct sockaddr*)&addr, sizeof(addr));\n  if (result == -1) {\n    close(conn_sd);\n    fprintf(stderr, \"Could no connect: %s\\n\", strerror(errno));\n    exit(1);\n  }\n stream_client_loop(conn_sd);\n  return 0;\n}\n```", "```cpp\nvoid stream_client_loop(int conn_sd) {\n  struct context_t context;\n  context.sd = conn_sd;\n  context.ser = calc_proto_ser_new();\n  calc_proto_ser_ctor(context.ser, &context, 128);\n  calc_proto_ser_set_resp_callback(context.ser, on_response);\n  calc_proto_ser_set_error_callback(context.ser, on_error);\n  pthread_t reader_thread;\n pthread_create(&reader_thread, NULL,\nstream_response_reader, &context);\n  char buf[128];\n  printf(\"? (type quit to exit) \");\n  while (1) {\n    scanf(\"%s\", buf);\n    int brk = 0, cnt = 0;\n    struct calc_proto_req_t req;\n    parse_client_input(buf, &req, &brk, &cnt);\n    if (brk) {\n      break;\n    }\n    if (cnt) {\n      continue;\n    }\n    struct buffer_t ser_req =\n        calc_proto_ser_client_serialize(context.ser, &req);\n    int ret = write(context.sd, ser_req.data, ser_req.len);\n    if (ret == -1) {\n      fprintf(stderr, \"Error while writing! %s\\n\",\n              strerror(errno));\n      break;\n    }\n    if (ret < ser_req.len) {\n      fprintf(stderr, \"Wrote less than anticipated!\\n\");\n      break;\n    }\n    printf(\"The req(%d) is sent.\\n\", req.id);\n  }\n  shutdown(conn_sd, SHUT_RD);\n  calc_proto_ser_dtor(context.ser);\n  calc_proto_ser_delete(context.ser);\n  pthread_join(reader_thread, NULL);\n  printf(\"Bye.\\n\");\n}\n```", "```cpp\nint server_sd = socket(AF_UNIX, SOCK_DGRAM, 0);\nif (server_sd == -1) {\n  fprintf(stderr, \"Could not create socket: %s\\n\",\n          strerror(errno));\n  exit(1);\n}\n```", "```cpp\nint main(int argc, char** argv) {\n  char sock_file[] = \"/tmp/calc_svc.sock\";\n  // ----------- 1\\. Create socket object ------------------\n  int server_sd = socket(AF_UNIX, SOCK_DGRAM, 0);\n  if (server_sd == -1) {\n    fprintf(stderr, \"Could not create socket: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  // ----------- 2\\. Bind the socket file ------------------\n  // Delete the previously created socket file if it exists.\n  unlink(sock_file);\n  // Prepare the address\n  struct sockaddr_un addr;\n  memset(&addr, 0, sizeof(addr));\n  addr.sun_family = AF_UNIX;\n  strncpy(addr.sun_path, sock_file, sizeof(addr.sun_path) - 1);\n  int result = bind(server_sd,\n          (struct sockaddr*)&addr, sizeof(addr));\n  if (result == -1) {\n    close(server_sd);\n    fprintf(stderr, \"Could not bind the address: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  // ----------- 3\\. Start serving requests ---------\n  serve_forever(server_sd);\n  return 0;\n}\n```", "```cpp\nvoid serve_forever(int server_sd) {\n  char buffer[64];\n  while (1) {\n    struct sockaddr* sockaddr = sockaddr_new();\n    socklen_t socklen = sockaddr_sizeof();\n    int read_nr_bytes = recvfrom(server_sd, buffer,\n sizeof(buffer), 0, sockaddr, &socklen);\n    if (read_nr_bytes == -1) {\n      close(server_sd);\n      fprintf(stderr, \"Could not read from datagram socket: %s\\n\",\n              strerror(errno));\n      exit(1);\n    }\n    struct client_context_t context;\n    context.addr = (struct client_addr_t*)\n malloc(sizeof(struct client_addr_t));\n    context.addr->server_sd = server_sd;\n    context.addr->sockaddr = sockaddr;\n    context.addr->socklen = socklen;\n    context.ser = calc_proto_ser_new();\n    calc_proto_ser_ctor(context.ser, &context, 256);\n    calc_proto_ser_set_req_callback(context.ser, request_callback);\n    calc_proto_ser_set_error_callback(context.ser, error_callback);\n    context.svc = calc_service_new();\n    calc_service_ctor(context.svc);\n    context.write_resp = &datagram_write_resp;\n    bool_t req_found = FALSE;\n    struct buffer_t buf;\n    buf.data = buffer;\n    buf.len = read_nr_bytes;\n    calc_proto_ser_server_deserialize(context.ser, buf, &req_found);\n    if (!req_found) {\n      struct calc_proto_resp_t resp;\n      resp.req_id = -1;\n      resp.status = ERROR_INVALID_RESPONSE;\n      resp.result = 0.0;\n      context.write_resp(&context, &resp);\n    }\n    calc_service_dtor(context.svc);\n    calc_service_delete(context.svc);\n    calc_proto_ser_dtor(context.ser);\n    calc_proto_ser_delete(context.ser);\n    free(context.addr->sockaddr);\n    free(context.addr);\n  }\n}\n```", "```cpp\nvoid datagram_write_resp(struct client_context_t* context,\n        struct calc_proto_resp_t* resp) {\n  struct buffer_t buf =\n      calc_proto_ser_server_serialize(context->ser, resp);\n  if (buf.len == 0) {\n    close(context->addr->server_sd);\n    fprintf(stderr, \"Internal error while serializing object.\\n\");\n    exit(1);\n  }\n  int ret = sendto(context->addr->server_sd, buf.data, buf.len,\n 0, context->addr->sockaddr, context->addr->socklen);\n  free(buf.data);\n  if (ret == -1) {\n    fprintf(stderr, \"Could not write to client: %s\\n\",\n            strerror(errno));\n    close(context->addr->server_sd);\n    exit(1);\n  } else if (ret < buf.len) {\n    fprintf(stderr, \"WARN: Less bytes were written!\\n\");\n    close(context->addr->server_sd);\n    exit(1);\n  }\n}\n```", "```cpp\nint main(int argc, char** argv) {\n  char server_sock_file[] = \"/tmp/calc_svc.sock\";\n  char client_sock_file[] = \"/tmp/calc_cli.sock\";\n  // ----------- 1\\. Create socket object ------------------\n  int conn_sd = socket(AF_UNIX, SOCK_DGRAM, 0);\n  if (conn_sd == -1) {\n    fprintf(stderr, \"Could not create socket: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  // ----------- 2\\. Bind the client socket file ------------\n  // Delete the previously created socket file if it exists.\n  unlink(client_sock_file);\n  // Prepare the client address\n  struct sockaddr_un addr;\n  memset(&addr, 0, sizeof(addr));\n  addr.sun_family = AF_UNIX;\n  strncpy(addr.sun_path, client_sock_file,\n          sizeof(addr.sun_path) - 1);\n  int result = bind(conn_sd,\n          (struct sockaddr*)&addr, sizeof(addr));\n  if (result == -1) {\n    close(conn_sd);\n    fprintf(stderr, \"Could not bind the client address: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  // ----------- 3\\. Connect to server --------------------\n  // Prepare the server address\n  memset(&addr, 0, sizeof(addr));\n  addr.sun_family = AF_UNIX;\n  strncpy(addr.sun_path, server_sock_file,\n          sizeof(addr.sun_path) - 1);\n  result = connect(conn_sd,\n          (struct sockaddr*)&addr, sizeof(addr));\n  if (result == -1) {\n    close(conn_sd);\n    fprintf(stderr, \"Could no connect: %s\\n\", strerror(errno));\n    exit(1);\n  }\n  datagram_client_loop(conn_sd);\n  return 0;\n}\n```", "```cpp\nint main(int argc, char** argv) {\n  // ----------- 1\\. Create socket object ------------------\n  int server_sd = socket(AF_INET, SOCK_STREAM, 0);\n  if (server_sd == -1) {\n    fprintf(stderr, \"Could not create socket: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  // ----------- 2\\. Bind the socket file ------------------\n  // Prepare the address\n  struct sockaddr_in addr;\n  memset(&addr, 0, sizeof(addr));\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = INADDR_ANY;\n  addr.sin_port = htons(6666);\n  ...\n  // ----------- 3\\. Prepare backlog ------------------\n  ...\n  // ----------- 4\\. Start accepting clients ---------\n  accept_forever(server_sd);\n  return 0;\n}\n```", "```cpp\nint main(int argc, char** argv) {\n  // ----------- 1\\. Create socket object ------------------\n  int conn_sd = socket(AF_INET, SOCK_STREAM, 0);\n  if (conn_sd == -1) {\n    fprintf(stderr, \"Could not create socket: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  // ------------ 2\\. Connect to server-- ------------------\n  // Find the IP address behind the hostname\n  ...\n  // Prepare the address\n  struct sockaddr_in addr;\n  memset(&addr, 0, sizeof(addr));\n  addr.sin_family = AF_INET;\n  addr.sin_addr = *((struct in_addr*)host_entry->h_addr);\n  addr.sin_port = htons(6666);\n  ...\n  stream_client_loop(conn_sd);\n  return 0;\n}\n```", "```cpp\nint main(int argc, char** argv) {\n  // ----------- 1\\. Create socket object ------------------\n  int server_sd = socket(AF_INET, SOCK_DGRAM, 0);\n  if (server_sd == -1) {\n    fprintf(stderr, \"Could not create socket: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  // ----------- 2\\. Bind the socket file ------------------\n  // Prepare the address\n  struct sockaddr_in addr;\n  memset(&addr, 0, sizeof(addr));\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = INADDR_ANY;\n  addr.sin_port = htons(9999);\n  ...\n  // ----------- 3\\. Start serving requests ---------\n  serve_forever(server_sd);\n  return 0;\n}\n```", "```cpp\nint main(int argc, char** argv) {\n  // ----------- 1\\. Create socket object ------------------\n  int conn_sd = socket(AF_INET, SOCK_DGRAM, 0);\n  if (conn_sd == -1) {\n    fprintf(stderr, \"Could not create socket: %s\\n\",\n            strerror(errno));\n    exit(1);\n  }\n  // ------------ 2\\. Connect to server-- ------------------\n  ...\n  // Prepare the address\n  ...\n  datagram_client_loop(conn_sd);\n  return 0;\n}\n```"]