<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-56"><a id="_idTextAnchor056"/>3</h1>
<h1 id="_idParaDest-57"><a id="_idTextAnchor057"/>Insights into the Arduino IoT Cloud Platform and Web Editor</h1>
<p>Before getting started with any development or cloud platform, it’s important to get a broad idea about the platform’s functionality, including its functions, controls, widgets, and so on. These platforms are like a kitchen full of spices, vegetables, meat, and other ingredients. To cook a good meal in a new kitchen, you need to get an idea about what’s in the kitchen – what types of tools, ingredients, spices, and other stuff are available. Product development is just like cooking a meal – if you have a good idea about what the platform provides, then you will be able to develop an awesome project. Another benefit of getting an overview of a platform is that it will save your time in the long run and give you confidence in your product design, because you already have a good understanding of the platform and can combine different things logically to develop something new according to your requirements.</p>
<p>So, in this chapter, we will first cover the main ingredients of the <strong class="bold">Arduino IoT Cloud</strong> in detail, namely <strong class="bold">Things</strong>, <strong class="bold">devices</strong>, <strong class="bold">dashboards</strong>, <strong class="bold">integrations</strong>, and <strong class="bold">templates</strong>. In the next part, we will take a look at all the <strong class="bold">dashboard input</strong>/<strong class="bold">output widgets</strong> and will see in detail what their purposes are, where to use them, and what type of variables they support. We will also have a brief comparison between some different control widgets that resemble each other.</p>
<p>In the last part, we will cover the complete <strong class="bold">Arduino Web Editor</strong> functionality, learning how to import new libraries, what the Web Editor storage and memory limits are, how to share your code with others, and how to debug code with the <strong class="bold">cloud-based </strong><strong class="bold">Serial Monitor</strong>.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Introducing the Arduino IoT Cloud interface</li>
<li>Input controls</li>
<li>Output controls</li>
<li>The Arduino Web Editor</li>
<li>An assignment</li>
</ul>
<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/>Technical requirements</h1>
<p>For this chapter only, Arduino IoT Cloud access is required to explore the different functionalities and dashboard control widgets we’ll cover in this chapter.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor059"/>Introducing the Arduino IoT Cloud interface</h1>
<p>The <a id="_idIndexMarker201"/>Arduino IoT Cloud’s main interface is composed of five primary components – Things, devices, dashboards, integrations, and templates, as shown in <em class="italic">Figure 3</em><em class="italic">.1</em>. Each component has its own properties, which will be discussed in detail in this section.</p>
<div><div><img alt="Figure 3.1 – Arduino IoT Cloud components" src="img/B19752_03_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Arduino IoT Cloud components</p>
<p>Things, devices, and <a id="_idIndexMarker202"/>dashboards are highly coupled with each other in every project. For example, for even a small project, we require a Thing and a device to get onboard the cloud platform. Is it enough to just configure a Thing and a device? No – a dashboard is also mandatory, from which the user can give input to the Thing and over which the system can show Thing data for user visualization.</p>
<p>However, integrations are a more optional component, with use cases varying from project to project and only being used by developers when they want to connect any non-compatible device to the Arduino IoT Cloud, build a custom interface to fetch data from the Arduino IoT Cloud, or integrate<a id="_idIndexMarker203"/> with third-party services <a id="_idIndexMarker204"/>such as <strong class="bold">Zapier</strong> and <strong class="bold">AWS services</strong>.</p>
<p>Templates<a id="_idIndexMarker205"/> are good for beginners as well as geeks, providing ready-made generic projects, including documentation, code, cloud templates, and a list of the hardware used in a given project. By using these templates, you can expose yourself to new things, which is good for learning purposes.</p>
<p>Here, we have discussed the Arduino IoT Cloud’s key interface components. In the following section, we will discuss all the components in detail step by step. This chapter is very important with respect to all Arduino IoT Cloud features.</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor060"/>Devices and things</h2>
<p>In <em class="italic">Chapter 2</em>, we <a id="_idIndexMarker206"/>explored a <em class="italic">hello world</em> example, where we used devices, Things, and other stuff to complete the example. In this section, we will discuss in more detail about devices and Things.</p>
<p>A <a id="_idIndexMarker207"/>device is a <strong class="bold">Wi-Fi</strong>/<strong class="bold">LoRa-enabled microcontroller</strong> that acts as a bridge between the Arduino IoT Cloud and sensors. The Arduino IoT Cloud has a very specific list of compatible development boards. Follow <a href="https://support.arduino.cc/hc/en-us/articles/360016077320-What-devices-can-be-used-with-Arduino-IoT-Cloud">https://support.arduino.cc/hc/en-us/articles/360016077320-What-devices-can-be-used-with-Arduino-IoT-Cloud</a> to see the complete list of compatible boards. Besides these <a id="_idIndexMarker208"/>official boards, the <strong class="bold">ESP8266</strong> and <strong class="bold">ESP32</strong> boards <a id="_idIndexMarker209"/>are also compatible with the IoT Cloud and are very low-cost and widely used development boards. There is good news <a id="_idIndexMarker210"/>for <strong class="bold">LoRaWAN</strong> geeks – any brand of LoRaWAN node is compatible with the Arduino IoT Cloud.</p>
<p>Now, it’s time to look at the device page. Click on the <strong class="bold">Device</strong> menu in the dashboard. On this page, we have three main things. The first is the search bar, where we can search for devices by name as well as using the four device filters available – <strong class="bold">Device Type</strong>, <strong class="bold">Serial Number</strong>, <strong class="bold">Device Status</strong>, or <strong class="bold">Thing</strong>. The search filters offer awesome functionality for those scenarios where we have dozens of devices connected to the platform. The second notable thing on this page is the <strong class="bold">ADD</strong> button, with which we will attach new devices to the Arduino IoT Cloud. The third is the device list table, which shows a complete list of the devices connected to the Arduino IoT Cloud along with their statuses, either online or offline.</p>
<p>From the device list table, we can see the relationship between a given device and a Thing. The device is either attached to a Thing or is still available to join with another Thing. One device is only able to connect with one Thing at a time. Besides all of this, the device list shows other important properties that can be shown/hidden via the <strong class="bold">Table Settings</strong> icon, according to your requirements. When set to be shown, you can see a lot of new properties under the table <a id="_idIndexMarker211"/>settings, such as the ID, type, <strong class="bold">Fully Qualified Board Name</strong> (<strong class="bold">FQBN</strong>), serial number, connectivity module firmware, last activity, and device addition date.</p>
<p>You can also<a id="_idIndexMarker212"/> get all the device properties by clicking on the device. Of all the aforementioned device properties, <strong class="bold">Last Activity</strong> is one of the most important, as it helps to measure device downtime. You can delete devices one by one, or you can use the checkbox option to bulk-delete devices. There is another <strong class="bold">Update</strong> icon below the <strong class="bold">Table Settings</strong> icon, which is used to refresh the device table list.</p>
<p class="callout-heading">Important note</p>
<p class="callout">A device is only attachable to one Thing in a one-to-one relationship. If you want to use a device associated with any other Thing, then it’s mandatory to detach the device from the previously associated Thing before associating it with a new Thing.</p>
<p>The concept<a id="_idIndexMarker213"/> of a <a id="_idIndexMarker214"/>Thing is a bit like a dish containing pieces of steak, veggies, mashed potato, and so on. A Thing holds cloud variables, network connectivity, and the device, and is it responsible for managing code and metadata, such as the device time zone and the <strong class="bold">meta tags</strong> for <a id="_idIndexMarker215"/>the Thing.</p>
<p>Now, it’s time to explore Things more closely in the Arduino IoT Cloud. The following diagram summarizes the whole Thing interface:</p>
<div><div><img alt="" role="presentation" src="img/B19752_03_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – The Thing interface</p>
<p>Let’s <a id="_idIndexMarker216"/>start<a id="_idIndexMarker217"/> by exploring the Thing main page (shown in <em class="italic">Figure 2</em><em class="italic">.4</em> in <a href="B19752_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>) by clicking on <strong class="bold">Thing</strong> menu, which is very similar to the menu for devices but with a few differences in the <strong class="bold">Search</strong> and <strong class="bold">Thing</strong> table list. We can see a <strong class="bold">CREATE</strong> button for Thing creation, instead of <strong class="bold">ADD</strong> as there is for devices. The search functionality for Things has totally different filters compared to those for devices, allowing us to filter Things by <strong class="bold">Device</strong>, <strong class="bold">Device Type</strong>, and <strong class="bold">Time Zone</strong>.</p>
<p>As the relationship between devices and Things is a one-to-one relationship, it will show you only one Thing, but <strong class="bold">Device Type</strong> is a good feature to show a whole bunch of Things with a particular device type. For example, let’s say we have deployed two different projects, and each project contains 25 nodes. One project was developed by <strong class="bold">MKR Wi-Fi 1010</strong>, while<a id="_idIndexMarker218"/> the other was <a id="_idIndexMarker219"/>developed by <strong class="bold">ESP32</strong>. The <strong class="bold">Device Type</strong> filter provides you with the option to filter down the Things to just those using the ESP32 board type. The third filter is <strong class="bold">Time Zone</strong>, which is very beneficial if you have projects deployed in different regions across the world. To return the devices in specific regions, you can simply use this <strong class="bold">Time </strong><strong class="bold">Zone</strong> filter.</p>
<p>By default, the Thing list table provides us with a list of Things with their <strong class="bold">Device</strong>, <strong class="bold">Variables</strong>, and <strong class="bold">Last Modified</strong> properties. We can rearrange the list by any property in ascending or descending order by clicking on the property column. The Thing <strong class="bold">option</strong> menu provides us options to delete the Thing. In the device property, it shows either the associated device or gives you the option to associate a device. The <strong class="bold">Last modified</strong> property is good for auditing purposes and indicates the last time your Thing was modified.</p>
<p>Besides all of these properties, we have some hidden properties, <strong class="bold">Creation Date</strong> and <strong class="bold">Time Zone</strong>, that can be enabled via the <strong class="bold">Table Settings</strong> icon, located on the right side of the page. If we add meta tags to the Thing, then this will also appear under <strong class="bold">Table Settings</strong>. Meta tags will be covered in more detail in the following few paragraphs.</p>
<p>It’s time to explore the internal options for Things (<em class="italic">Figure 2</em><em class="italic">.5</em> from <a href="B19752_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>). Click on the <strong class="bold">CREATE</strong> button or click on any Thing from the table. On the page that appears, you will see three different tabs, <strong class="bold">Setup</strong>, <strong class="bold">Sketch</strong>, and <strong class="bold">Metadata</strong>, along with the Thing name in bold font. You can also modify the Thing name by clicking on it.</p>
<p>The <strong class="bold">Setup</strong> tab is used for cloud variable creation and associating devices with Things (if not already linked). The <strong class="bold">Change/Detach Device</strong> option is available for devices associated with the Thing. Finally, there is the option to configure the Wi-Fi network settings for the development board.</p>
<p>The <a id="_idIndexMarker220"/>second tab is <strong class="bold">Sketch</strong>, which provides a mini version of the Arduino Web Editor, from where we can write/modify code as well as verify and upload it to the associated device. I like the <strong class="bold">Sketch</strong> option for Things, as it helps us to maintain the code for each device within a separate Thing container, with no need for local backups or code management. The mini cloud editor also provides the option to open the full editor. Beside that is the search icon, which opens the web-based Serial Monitor to verify whether your device is working.</p>
<p>The third tab <a id="_idIndexMarker221"/>is for Thing metadata. Normally, people don’t concern themselves with these settings, but they are used to classify and provide ease of management when you have dozens of Things. Here, we can add tags to classify our Things. <strong class="bold">Tags</strong> also<a id="_idIndexMarker222"/> appear in the Thing table list, as well as in the search bar as a filter option. So, let’s see how tags work. A tag consists of two parts – one is the key and the other is a value. The key is used in search filters. For example, if you have dozens of devices for different organizations and each organization contains multiple devices, then how you can filter the specific organization devices? The answer is by tag; you create a tag, where the key will be the organization name and the value will be the type of device. When you type the organization name in the search bar, you will see all the devices that are associated with these meta tags. The next option is the time zone, which is the perfect option to get Thing data according to the time zone of its native region. By default, it shows the time zone according to your location, but you can manually override the time zone. Resetting it will show some details regarding the Thing, such as <strong class="bold">Thing ID</strong>, <strong class="bold">Last Modified</strong>, <strong class="bold">Last Sync</strong>, and <strong class="bold">Created At</strong>.</p>
<p>At this point, the<a id="_idIndexMarker223"/> following question arises: <em class="italic">What is the difference between Last Modified and </em><em class="italic">Last Sync?</em></p>
<p>I recommend that you have a think and find a solution to it before you proceed.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Let’s imagine you have written the code for a Thing and it is associated with an MKR Wi-Fi 1010 device, but you have changed the association of the device to <strong class="bold">Arduino Nano RP2040</strong> or<a id="_idIndexMarker224"/> any other development board. In this scenario, you will get the prewritten code for the RP2040. You will get this code, as the code belongs to the Thing, not the device. However, it may require some minor modifications in code, as pins and libraries vary from development board to development board.</p>
<p>In this section, we discussed the device and Thing pages in detail, regarding search options, creations, and other options on the pages. Now, we will discuss <em class="italic">dashboards</em>, which will help us to create beautiful graphical user interfaces to control and display device data.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor061"/>Dashboards</h2>
<p>The <a id="_idIndexMarker225"/>Arduino IoT Cloud offers very versatile dashboards with lots of options, providing an awesome experience for users. <strong class="bold">Dashboards</strong> consist of different features, including widgets, which are categorized into input and output, responsive design options for mobile and web, and lots of other features. The following figure summarizes all the features of a dashboard, which will be discussed in detail step by step in the following sections:</p>
<div><div><img alt="Figure 3.3 – A﻿n Arduino IoT Cloud dashboard" src="img/B19752_03_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – An Arduino IoT Cloud dashboard</p>
<p>The<a id="_idIndexMarker226"/> dashboard interface is very similar to Thing and device interfaces, but it’s simpler in terms of search and tables. Let’s now examine input/output widgets in the context of the IoT Cloud but not in terms of devices (although devices are relevant, as if we provide input to the IoT cloud, it will, in turn, provide input to the Thing, and if a device sends output data to the IoT cloud, it will be displayed on the dashboard).</p>
<p>Arduino IoT dashboards provide a wide variety of widget controls for input/output. We will examine all of the widgets in detail later, while here, we will discuss some other major features, such as <em class="italic">responsive design</em> and <em class="italic">sharing and </em><em class="italic">downloading data</em>.</p>
<p>Dashboards provide a responsive grid design system for both mobile/web. To enter into editing mode, firstly click on the <strong class="bold">Edit</strong> icon on the <strong class="bold">Dashboard</strong> page (<em class="italic">Figure 2</em><em class="italic">.15</em> in <a href="B19752_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>) and then on the <strong class="bold">Navigation</strong> icon, which is also known as <em class="italic">Arrange Widgets</em>. You can modify the design by making widgets larger or smaller, or by dragging them to any location on the canvas. You should see the <strong class="bold">Lock</strong> icon on every widget control as well, which lets you fix their locations. After placing the widget at the appropriate location, click on that lock to fix the position. In the top menu near the <strong class="bold">Add</strong> button, there is an icon for mobile/desktop mode to align the widgets.</p>
<p>There will come a time when you need to share these dashboards with your stakeholders so that they can monitor their systems easily. The Arduino IoT Cloud provides a secure way to share your dashboard with others. Just click on the <strong class="bold">Sharing</strong> icon – from there, we can share our dashboard with other users (although note that it’s mandatory that all users’ emails need to be registered with the Arduino IoT Cloud to take part in sharing).</p>
<p>Getting sensor data from the cloud is an essential element of IoT cloud platforms, as researchers use data in a variety of applications, including training <strong class="bold">Machine Learning</strong>/<strong class="bold">Artificial Intelligence</strong> (<strong class="bold">ML</strong>/<strong class="bold">AI</strong>) models<a id="_idIndexMarker227"/> or visualizing data on different platforms, such as <strong class="bold">Google Looker</strong> and <strong class="bold">Tableau</strong>. Arduino <a id="_idIndexMarker228"/>provides a vast functionality wizard to download<a id="_idIndexMarker229"/> all data or the specific data of a given cloud variable. Click on the <strong class="bold">Download</strong> icon, and<a id="_idIndexMarker230"/> you will get a lot of options. From there, you can select the variables (either single, multiple, or all, according to your requirements) and provide the date range. Arduino will then process the data according to your query and share it with you in the CSV format at your registered email.</p>
<p>Here, we have talked about different features of dashboards, such as the alignment of widgets, responsive design for mobile and web dashboards, and how to download sensor data. In the following section, we will cover integrations and templates.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor062"/>Integrations and templates</h2>
<p><strong class="bold">Templates</strong> page<a id="_idIndexMarker231"/> contains example projects for <a id="_idIndexMarker232"/>learning and practice purpose and are great for beginners to try different projects, from the beginner’s level all the way up to advanced level. Each project is properly documented with a project description, hardware list, code, and imported cloud template. On the <strong class="bold">Templates</strong> page, you will initially see a very small list of projects, but more can be found at <a href="https://projecthub.arduino.cc/">https://projecthub.arduino.cc/</a>, where makers/professionals around the globe upload the projects they’ve created with full documentation.</p>
<p><strong class="bold">Integrations</strong> provide<a id="_idIndexMarker233"/> interoperability to link the <a id="_idIndexMarker234"/>Arduino IoT Cloud with other third-party services, as well as custom-developed applications. Arduino <a id="_idIndexMarker235"/>provides three ways <a id="_idIndexMarker236"/>to <a id="_idIndexMarker237"/>interact with different platforms, <strong class="bold">Application Programming Interface</strong> (<strong class="bold">APIs</strong>), <strong class="bold">Webhooks</strong>, and <strong class="bold">Software Development Kits</strong> (<strong class="bold">SDKs</strong>), as shown in the following figure:</p>
<div><div><img alt="Figure 3.4 – Arduino IoT cloud integrations" src="img/B19752_03_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Arduino IoT cloud integrations</p>
<p>First, let’s talk <a id="_idIndexMarker238"/>about APIs, as this technique is widely used by developers to interact with different platforms. In the Arduino IoT Cloud, APIs are used for two purposes – the first purpose is to set up a non-compatible device with the<a id="_idIndexMarker239"/> IoT Cloud, including <strong class="bold">Raspberry Pi</strong> and <strong class="bold">Beagle Bone</strong>, while<a id="_idIndexMarker240"/> the second purpose is to fetch data from the IoT Cloud using different predefined APIs. These APIs will be discussed in detail in <a href="B19752_08.xhtml#_idTextAnchor158"><em class="italic">Chapter 8</em></a>.</p>
<p>Webhooks are used as triggers when a specified event happens in a Thing, such as an update in the cloud variables. To set up a Webhook, you need to visit the specific Thing’s page, click on <code>JSON</code> format with lots of details, which will be discussed further in <a href="B19752_12.xhtml#_idTextAnchor251"><em class="italic">Chapter 12</em></a>.</p>
<p>It’s very important to understand the concepts behind APIs and Webhooks. Third-party applications use an API’s interface to request data from the cloud, but with Webhooks, the Arduino IoT Cloud sends the data to a specific platform when any predetermined event happens within the Thing. So, if you develop an alert system, then Webhooks are the preferred choice, as they send data instantly when any change is detected within the Thing. Conversely, if you develop an application where you only need data periodically, then APIs are the best solution. To put it simply, Webhooks <a id="_idIndexMarker242"/>work like <strong class="bold">push requests</strong> and APIs work<a id="_idIndexMarker243"/> like <strong class="bold">pull requests</strong>.</p>
<p>The Arduino IoT Cloud team<a id="_idIndexMarker244"/> has also released official SDKs for different programming<a id="_idIndexMarker245"/> languages, such as <strong class="bold">JavaScript</strong> (<strong class="bold">Node.js</strong>), <strong class="bold">Python</strong>, and <strong class="bold">GoLang</strong>. SDKs <a id="_idIndexMarker246"/>make development easy for developers by <a id="_idIndexMarker247"/>allowing them to use predefined functions to get data from the cloud, instead of playing with raw APIs. For authentication purposes, SDKs use API keys for access and authentication. The Node.js SDK will be discussed in detail in <a href="B19752_08.xhtml#_idTextAnchor158"><em class="italic">Chapter 8</em></a>.</p>
<p>In this section, we discussed APIs, SDKs, and Webhooks. Now, we will explore a dashboard’s widget controls. We have divided Arduino Dashboard widget controls into two categories, <em class="italic">input</em> and <em class="italic">output</em>. In the following section, we will first explore the complete range of input controls, and in the subsequent section, we will explore the complete range of output controls.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor063"/>Exploring input controls</h1>
<p><strong class="bold">Input controls</strong> are <a id="_idIndexMarker248"/>very important in IoT product development, where users control the flow of operations according to metrics. The latest trends and technologies in <a id="_idIndexMarker249"/>the <strong class="bold">User Interface</strong>/<strong class="bold">User Experience</strong> (<strong class="bold">UI</strong>/<strong class="bold">UX</strong>) field bring lots of different input controls that vary in size, shape, and design, providing a better end user experience.</p>
<p>The Arduino IoT Cloud team has taken account of the latest trends in the market and provided nine different, stunning input widgets, each of which provides users the ability to give input to Things in various ways. Each widget is linked to a single cloud variable; you can link multiple widgets to a single cloud variable, but the data type must be the one specified by the widget control. In the following subsections, I have categorized the input widgets into various groups, based on their resemblance with each other.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor064"/>Switch, push button, slider, and stepper</h2>
<p>Let’s start with the very basic input control widgets – <strong class="bold">switch</strong>, <strong class="bold">push button</strong>, <strong class="bold">slider</strong>, and <strong class="bold">stepper</strong>. These<a id="_idIndexMarker250"/> widgets allow users to control their Things in an <a id="_idIndexMarker251"/>effective<a id="_idIndexMarker252"/> and efficient <a id="_idIndexMarker253"/>manner. All the widgets are shown in <em class="italic">Figure 3</em><em class="italic">.5</em>:</p>
<div><div><img alt="" role="presentation" src="img/B19752_03_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Switch, Push Button, Slider, and Stepper</p>
<p><code>on</code>/<code>off</code>) and consume<a id="_idIndexMarker255"/> the <code>Boolean</code> type cloud variable. The only difference between these two controls is the UI/UX design. When the user clicks the switch control, it slides on/off and stays in the same state until clicked again. <strong class="bold">Push Button</strong> also retains its state but is <em class="italic">pressed</em> in or out to change between on/off states.</p>
<p class="callout-heading">Important note</p>
<p class="callout">To understand the proper working of <strong class="bold">Switch</strong> and <strong class="bold">Push Button</strong>, just place both controls on a dashboard and link them to the same cloud variable. Afterward, click on <strong class="bold">Push Button</strong> and release it, and then try clicking on the switch.</p>
<p>The <code>integer</code> or <code>float</code>-type cloud variables. These controls are useful to control stepper motor angles, the speed of motors, and light intensity, or even to set the threshold for an alert system for temperature and humidity monitoring. For example, say you want to set an alarm threshold for temperature and humidity values, and also the weather. These controls will help you to get values from the stakeholder via the dashboard and process them in the Thing, without needing to modify the Thing code.</p>
<p>Here, we explored four different input widget controls, <strong class="bold">Switch</strong>, <strong class="bold">Push Button</strong>, <strong class="bold">Slider</strong>, and <strong class="bold">Stepper</strong>, and their uses in detail. Now, we are going to cover input widget controls related to light control.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/>Color, dimmed light, and colored light</h2>
<p>Arduino has <a id="_idIndexMarker258"/>introduced three new widgets specific to light color and intensity control, which developers can use when building real-world products for smart homes. <em class="italic">Figure 3</em><em class="italic">.6</em> shows these three widgets, which help you to control your smart bulb/light solutions:</p>
<div><div><img alt="Figure 3.6 – Color and light widgets" src="img/B19752_03_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Color and light widgets</p>
<p>Here, we have seen all the widget controls regarding light/bulb control; now, we will discuss all the widgets, step by step, in the upcoming subsections. First, we will start with the <strong class="bold">Color</strong> widget control.</p>
<h3>Color</h3>
<p>Our first<a id="_idIndexMarker259"/> widget here is the <code>Color</code> type<a id="_idIndexMarker260"/> cloud variable, for which we fetch the <strong class="bold">Red Green Blue</strong> (<strong class="bold">RGB</strong>) color<a id="_idIndexMarker261"/> values with Arduino code for the final device input. The color widget provides an RGB slider to adjust the color, or the desired value can be directly entered in the RGB or hex formats. This widget is very useful to control RGB LED colors, RGB lamps, and <a id="_idIndexMarker262"/>the <strong class="bold">WS18B20</strong> module.</p>
<p>The following<a id="_idIndexMarker263"/> code <a id="_idIndexMarker264"/>snippet for the Arduino IDE or the Web Editor shows how to convert the color type cloud variable into RGB variables:</p>
<pre class="source-code">
int red, green, blue;
RGBVariable.getValue().getRGB(red, green, blue);</pre> <p><code>RGBVariable</code> is a cloud variable of the <code>Color</code> type. We have to use the RGB format to input our color codes into RGB LEDs, and for that reason, we will declare three integer type variables, <code>red</code>, <code>green</code>, and <code>blue</code>, and use <code>RGBVariable.getValue().getRGB(red, green, blue);</code> to convert our single cloud variable value into the <code>RGB</code> format.</p>
<h3>Dimmed light</h3>
<p>The <code>Dimmed Light</code> cloud variable, which contains the switch status and brightness values.</p>
<p>Before moving to the code, we first need to understand what values are required by the development board. Two values are required here – the on/off status and the light brightness level. The following code shows how we get the brightness level and on/off status from the <code>Dimmed Light</code> cloud variable:</p>
<pre class="source-code">
//retrieve and map brightness value from cloud variable
  int brightness = map(dimmedLightVariable.getBrightness(), 0, 100, 0, 255);
  //then check if switch is on/off
  if (dimmedLightVariable.getSwitch()) {
    analogWrite(5, brightness); //write brightness value to pin 5
  }
  else{
    analogWrite(5, LOW); //turn off lamp
  }</pre> <p>To get the<a id="_idIndexMarker267"/> brightness, we need to transform the <code>dimmedLightVariable</code> brightness property value into the <code>0</code>–<code>255</code> range, using the <code>map</code> function. Then, we <a id="_idIndexMarker268"/>need to get the on/off status by calling the <code>getSwitch</code> property of that cloud variable. If it’s on, then we will use the <code>analogWrite</code> function on <em class="italic">Pin #5</em> to adjust the brightness; if the switch is off, the LED/lamp will be turned off.</p>
<h3>Colored light</h3>
<p>Finally, it’s time<a id="_idIndexMarker269"/> to play with colorful strips with the <code>Colored Light</code> cloud variable type.</p>
<p>The following code for the Arduino IDE/Web Editor fetches values from the <code>Colored Light</code> variable type. Before diving into the code, note that we need to get three values from that cloud variable – the RGB color, brightness level, and on/off status:</p>
<pre class="source-code">
//retrieve RGB color values from cloud variable
int red, green, blue;
ColoredLightVariable.getValue().getRGB(red, green, blue);
//retrieve and map brightness value from cloud variable
int brightness = map(ColoredLightVariable.getBrightness(), 0, 100, 0, 255);
//then check if switch is on/off
bool switch= ColoredLightVariable.getSwitch();</pre> <p>Firstly, we fetch<a id="_idIndexMarker271"/> the RGB color value in the <code>int</code> format by using the <code>ColoredLightVariable.getValue().getRGB</code> method. Second, we fetch the brightness using the <code>ColoredLightVariable.getBrightness()</code> method and transform the values with the <code>map</code> method. Finally, we fetch the on/off status with the <code>ColoredLightVariable.getSwitch()</code> method. All the values are stored in three different variables <a id="_idIndexMarker272"/>that could be used to control LED/lamp or RGB strip functionality.</p>
<p>Here, we discussed in detail smart light/bulb controls, which contain <strong class="bold">Color</strong>, <strong class="bold">Dimmed</strong> <strong class="bold">light</strong>, and <strong class="bold">Colored light</strong> widget controls, including their code to fetch and set the values from them. Now, we will discuss another important input control, time picker, which is used for configuration.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/>Time picker (configuration)</h2>
<p>The <strong class="bold">time picker</strong> widget<a id="_idIndexMarker273"/> is a very important configuration widget <a id="_idIndexMarker274"/>control used to set/get the time on a device without modifying the code on the device. With this feature, it’s easy to maintain the device time<a id="_idIndexMarker275"/> without a <strong class="bold">Real-Time Clock</strong> (<strong class="bold">RTC</strong>) module. Whenever a Thing is turned on, it will automatically sync the device time with the time cloud variable.</p>
<p>The following screenshot shows the <strong class="bold">Time Picker</strong> widget with the date and time, and you have the option to set the date, the time, or both. The widget also gives you the ability to change the date and time format according to your region.</p>
<div><div><img alt="Figure 3.7 – The Time Picker widget" src="img/B19752_03_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – The Time Picker widget</p>
<p>The<a id="_idIndexMarker276"/> time picker widget is linked to the <code>Time</code> type cloud variable and stores all date and time data in the seconds format. The following code takes the local time from Arduino Cloud and stores it in a variable:</p>
<pre class="source-code">
CloudTimeVariable = ArduinoCloud.getLocalTime();</pre> <p>After fetching<a id="_idIndexMarker277"/> the local time, you can use <code>CloudTimeVariable</code> to sync your Thing operations. Use the preceding code in the <code>setup</code> method.</p>
<p>In this section, we discussed the time picker widget, including how to set the time for this widget control by using the <code>Time</code> cloud variable type. Now, we will discuss another configuration widget control, the Scheduler Widget control, which helps you set the time to automate your operations on IoT devices.</p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor067"/>Scheduler (configuration)</h2>
<p><strong class="bold">Scheduler</strong> is another <a id="_idIndexMarker278"/>important utility in Arduino IoT Cloud <a id="_idIndexMarker279"/>to automate a process. With this widget, we can automate lots of operations without human intervention, just <a id="_idIndexMarker280"/>like a <strong class="bold">cron job</strong> that executes processes/methods at a specific time.</p>
<p>So, where we can use this Scheduler feature in our IoT solutions? There are many use cases, including outdoor light automation, watering systems in agriculture, and animal feeders for poultry farms.</p>
<p>The following screenshot of the <strong class="bold">Scheduler</strong> widget shows the many options to schedule our processes/methods:</p>
<div><div><img alt="Figure 3.8 – The Scheduler Widget" src="img/B19752_03_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – The Scheduler Widget</p>
<p>The <a id="_idIndexMarker281"/>Scheduler Widget uses the <code>Schedule</code> cloud variable type. When <a id="_idIndexMarker282"/>configuring it, we specify at what time and on which day we want the process to start and end.</p>
<p>The following code snippet is very simple, using a <code>true</code>/<code>false</code> interface to start/stop operations, respectively, instead of going into complex stuff:</p>
<pre class="source-code">
  if (scheduleVariable.isActive()) {
    digitalWrite(LED, HIGH); // whenever the job is "active", turn on the LED
  }
  else{
    digitalWrite(LED, LOW); // whenever the job is "not active", turn off the LED
}</pre> <p>We can get the active/not active status of every <code>Schedule</code> cloud variable by accessing its <code>isActive()</code> method. Use the aforementioned code in a device loop – if the <code>Schedule</code> cloud variable is active, then execute the given processes/methods; otherwise, stop<a id="_idIndexMarker283"/> them. Why do we need to execute the preceding code snippet in a loop? Because the <code>loop()</code> method is the main method in Arduino, which always executes.</p>
<p>In this section, we <a id="_idIndexMarker284"/>discussed Scheduler in detail, what type of cloud variable is used by this widget, and how to access the Scheduler status to perform a specific job. This is the last control in input widgets. Now, we will look at the output control widgets. In the following section, all the output controls will be discussed in detail to give you a better understanding of how to implement these controls in your professional projects.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor068"/>Delving into output controls</h1>
<p>In the previous <a id="_idIndexMarker285"/>sections, we discussed input widget controls. Arduino IoT Cloud dashboards also feature stunning output controls. There are nine widgets here (although two are <strong class="bold">non-device widgets</strong> – <strong class="bold">messenger</strong> and <strong class="bold">sticky note</strong>).</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor069"/>Value, status, gauge, percentage, and LED</h2>
<p>Let’s start with the basic output widgets commonly used by developers in almost every solution. These output widgets are used to display a single value either in numerical or graphical format. <em class="italic">Figure 3</em><em class="italic">.9</em> shows all the main and basic output control widgets:</p>
<div><div><img alt="Figure 3.9 – The Value, Status, LED, Gauge, and Percentage widgets" src="img/B19752_03_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – The Value, Status, LED, Gauge, and Percentage widgets</p>
<p>In this section, we <a id="_idIndexMarker286"/>will discuss in detail five different output widget controls in separate sections. First, we will start with the value widget control.</p>
<h3>Value</h3>
<p>The <code>integer</code> type variables, but I also tested it with the <code>time</code> variable, and it worked fine, as the <code>time</code> variable stores all information in seconds. You can also use the value widget control to set thresholds for sensors, automating the process flow.</p>
<p>The following simple code snippet takes the value from analog pin #0 and stores it in <code>valueCloudVariable</code>:</p>
<pre class="source-code">
valueCloudVariable = analogRead(A0);</pre> <p>Here, we discussed the value widget control, which is used for both input and output purposes. Now, we will explore the status and LED control widgets.</p>
<h3>Status and LED</h3>
<p>Our next widgets<a id="_idIndexMarker290"/> are <code>true</code> or <code>false</code>. These <a id="_idIndexMarker292"/>widgets only display the state; they don’t provide any option to control them, and they both work with the <code>bool</code> type cloud variable. Use cases for these widgets include indicating the Thing status (on/off) – for example, a water pump’s status in smart agriculture, or whether a door is open or closed in a smart home. Just assign <code>true</code>/<code>false</code> to the <code>bool</code> cloud variable type, which is linked to the status widget after performing a specific task.</p>
<p>The following example code demonstrates how we can change the value of <code>statusCloudVariable</code> to change the status/LED widgets’ appearance:</p>
<pre class="source-code">
Void loop(){
digitalWrite(1,HIGH);
statusCloudVariable=true; //Assign true to Status Widget
delay(5000);
digitalWrite(1,LOW);
statusCloudVariable=false;//Assign false to Status Widget
delay(500);
}</pre> <p>The preceding code shows how, after performing the <code>digitalWrite</code> operation, we change the value of <code>statusCloudVariable</code> according to the current condition to update the status widget.</p>
<h3>Gauge and percentage</h3>
<p>Finally, we<a id="_idIndexMarker293"/> have the <code>integer</code> or <code>float</code> cloud variable types. Comparing the gauge and percentage widgets, we can see a clear difference in UI/UX design – gauge uses a half-circle to display a sensor reading, while the percentage widget uses a full circle featuring icons, for which you can specify the color if a <a id="_idIndexMarker295"/>value goes below or above a given threshold. However, the working of both widgets is essentially the same. Gauge can be used to <a id="_idIndexMarker296"/>display gas-related readings, such as air quality, carbon dioxide levels, and <a id="_idIndexMarker297"/>temperature, while the percentage widget is best for displaying humidity, battery level, <strong class="bold">Light-Dependent Resistor</strong> (<strong class="bold">LDR</strong>) values, and so on.</p>
<p>Here, I haven’t provided the sample code for the gauge and percentage widgets, as it’s very similar to the preceding example – just assign the values of the sensors to the gauge- and percentage-linked cloud variables.</p>
<p class="callout-heading">Important note</p>
<p class="callout">As a little exercise, create an integer type variable named <code>MultiDimmVariable</code>, and drop a gauge, percentage, and slider widget on the dashboard. Link these three widgets with the same <code>MultiDimmVariable</code> cloud variable you created. Now, you can have a bit of fun; just change the slider position and see how the gauge and percentage widgets react.</p>
<p>In this section, we discussed all the major output controls, which include value, status, gauge, percentage, and LED, step by step, and their usage and code. Now, we will look at maps and charts widgets, which are the most important widgets to display for location and time-series data.</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor070"/>Maps and charts</h2>
<p>Our next two <a id="_idIndexMarker298"/>widgets are very interesting – one is used to display maps with specific coordinates, and the other is used to display the <code>integer</code>/<code>float</code> type <a id="_idIndexMarker299"/>sensor readings in graph format. <em class="italic">Figure 3</em><em class="italic">.10</em> shows the <strong class="bold">Map</strong> and <strong class="bold">Chart</strong> widget controls. The map widget is used to display the location of a device using coordinates, and the chart widget is used to display the values in a time-series manner.</p>
<div><div><img alt="Figure 3.10 – The Map and Chart widgets" src="img/B19752_03_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – The Map and Chart widgets</p>
<p>First, we will start with the map widget, where we will discuss how we can display the location, and then, we will explore the chart widget to display the historical data of a sensor.</p>
<h3>Map</h3>
<p>There are many <a id="_idIndexMarker300"/>use cases where we need to display the current location of an object on a map, which is much easier to understand visually than simple coordinate values. The Arduino IoT Cloud <a id="_idIndexMarker301"/>provides us with a <code>location</code> cloud variable type, which consists of latitude and longitude values. The object could be anything from a child or animal to a delivery bike, a courier truck, or even food/vegetable parcels.</p>
<p>The following code demonstrates how you can assign the latitude and longitude values to the <code>location</code> cloud variable:</p>
<pre class="source-code">
location=Location(32.045948421308715, 72.72505696868048);</pre> <p>The preceding code is used to assign a location whenever your device receives data from a <strong class="bold">GPS module</strong>. This<a id="_idIndexMarker302"/> map widget is only capable of showing one location at a time. If you have multiple objects for which you want to display tracking, then each object will need its own map widget.</p>
<h3>Chart</h3>
<p>So, we can <a id="_idIndexMarker303"/>use the gauge or percentage widgets to display the current value of a sensor, but what if we want to display the current value as well as historical data? For this, <strong class="bold">chart</strong> is<a id="_idIndexMarker304"/> your best option, which is used to display current readings alongside historical readings for better visualization and comparison.</p>
<p>The <code>integer</code> or <code>float</code> cloud variable types, which as discussed previously are appropriate to monitor temperature, humidity, air quality, and so on. Just link any cloud variable with the chart widget for data visualization. Other use cases include light levels, energy consumption, and levels of different gases in industry.</p>
<p class="callout-heading">Important note</p>
<p class="callout">For quick testing, just drop the slider and chart widgets on a dashboard and link both of them with the same <code>integer</code> cloud variable type. After that, just change the value of the slider, and you can observe how charts work.</p>
<p>Here, we discussed both the map and chart widget controls in detail. Now, we will explore messenger and sticky note controls.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/>Messenger and sticky notes</h2>
<p>Our last <a id="_idIndexMarker305"/>two widgets are <strong class="bold">messenger</strong> and <strong class="bold">sticky notes</strong>. Both<a id="_idIndexMarker306"/> widgets are non-essential elements but do help you to make your dashboard interactive. <em class="italic">Figure 3</em><em class="italic">.11</em> shows both the widget controls:</p>
<div><div><img alt="Figure 3.11 – The Messenger and sticky note widgets" src="img/B19752_03_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – The Messenger and sticky note widgets</p>
<p>In the figure, the first widget is <strong class="bold">Messenger</strong>, and the second widget is sticky notes. Both widgets will be discussed in the following sections.</p>
<h3>Messenger</h3>
<p>The <strong class="bold">messenger</strong> widget <a id="_idIndexMarker307"/>works like any traditional <a id="_idIndexMarker308"/>messenger app. But the question arises, why would we need this widget on a dashboard? In my opinion, it’s simply not essential on any dashboard currently, but in the future, it could become an awesome widget and inspire people to develop products where you communicate textually with Things, just as we already have<a id="_idIndexMarker309"/> the <strong class="bold">Amazon Echo Dot</strong> and <strong class="bold">Google Assistant</strong> devices <a id="_idIndexMarker310"/>that users interact with verbally, where you ask questions to the device and it responds audibly.</p>
<p>In the future, you may see many messenger applications linked to your Things, where you ask questions such as, <em class="italic">where is my child?</em>, and the Thing connected to your child will respond to you with their exact location. Alternatively, you could ask a question about the temperature/humidity conditions in your room, and the Thing would respond with the required answer.</p>
<p>You could also use the messenger widget to create some sort of small search engine for your Thing that understands some keywords and responds to users’ queries. Remember, the early bird catches the worm.</p>
<p>The <a id="_idIndexMarker311"/>messenger widget works with the <code>string</code> cloud variable type. The following simple code snippet demonstrates how you can write to the messenger widget from the device end:</p>
<pre class="source-code">
stringMessengerVariable = "Hello Sir, My name is Arduino MKR1010 and I will be your host. How may I help you Sir?";</pre> <p>When you<a id="_idIndexMarker312"/> assign a new value to the string variable, messenger will append the new content to the widget. The following code is used to clear the whole widget at the device end:</p>
<pre class="source-code">
stringMessengerVariable = PropertyActions::CLEAR;</pre> <p>You can also integrate the messenger widget with <a id="_idIndexMarker313"/>third-party tools such as <strong class="bold">Slack</strong> and <strong class="bold">Discord</strong>, via<a id="_idIndexMarker314"/> either an API or Zapier integration.</p>
<h3>Sticky notes</h3>
<p>The<a id="_idIndexMarker315"/> sticky note widget<a id="_idIndexMarker316"/> works just like simple Windows OS Sticky Notes. It helps you to write down your project progress, or you can write anything on a sticky note to maintain your dashboards. It helps you in a situation where you have dozens of dashboards and you want to add some comments about specific dashboards.</p>
<p>For the latest <a id="_idIndexMarker317"/>updates and details about dashboard widget controls, please visit <a href="https://docs.arduino.cc/arduino-cloud/getting-started/dashboard-widgets">https://docs.arduino.cc/arduino-cloud/getting-started/dashboard-widgets</a>.</p>
<p>In this section, we discussed both the messenger and sticky note widgets. Sticky notes make it easy to maintain projects and write down comments about project progress or maintenance, while messenger has a broader use. We also discussed how sensor data is related to AI. We have now completed all of our input and output widget controls, Now, we will dive deep into the Arduino Web Editor, where we will explore all the options step by step.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/>Understanding the Arduino Web Editor</h1>
<p>Arduino has also launched a web-based editor that is independent of Arduino IoT Cloud and the desktop IDE. It works with any board compatible with the Arduino IDE without needing to install boards via the board manager. The Web Editor is compatible with a majority of web browsers, including Chrome, Firefox, Microsoft Edge, and Safari. To work with the Web Editor, your machine should have <a id="_idIndexMarker318"/>the <strong class="bold">Arduino Create Agent</strong>, which acts as a bridge between the device and the Web Editor. All code is stored on the cloud, so there is no risk of losing code or any need to make backups.</p>
<p>To visit the <a id="_idIndexMarker319"/>Arduino Web Editor, go to <a href="https://create.arduino.cc/editor">https://create.arduino.cc/editor</a>, where you will see something like the following:</p>
<div><div><img alt="Figure 3.12 – The Arduino Web Editor" src="img/B19752_03_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – The Arduino Web Editor</p>
<p>The numbers in the<a id="_idIndexMarker320"/> preceding screenshot correspond to the following elements of the Web Editor:</p>
<ol>
<li>This is the main menu of the Web Editor, where you will find all the navigation links, such as <strong class="bold">Sketchbook</strong>, <strong class="bold">Examples</strong>, <strong class="bold">Libraries</strong>, and <strong class="bold">Monitor</strong>.</li>
<li>This tab is a sub-menu, displaying options/content according to the current main menu selection. In the screenshot, this tab shows content related to the sketchbook.</li>
<li>This area is the coding/sketch area, where you can find all the options to work with code, such as code verification/uploads, board selection, and the code editor.</li>
<li>This tab<a id="_idIndexMarker321"/> is the output terminal, which provides you with information regarding code upload status, any errors found in your code, and so on.</li>
</ol>
<p>Here, we discussed the Arduino Web Editor interface. Now, we will discuss <strong class="bold">Sketchbook</strong>, <strong class="bold">Examples</strong>, <strong class="bold">Libraries</strong>, <strong class="bold">Monitor</strong>, <strong class="bold">References</strong>, and <strong class="bold">Help</strong>, as well as the <strong class="bold">Preferences</strong> and <strong class="bold">Features</strong> menus in detail. We will discuss all the options in depth so you will get a broader overview of the Arduino Web Editor, allowing you to utilize its features fully during your development.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor073"/>Sketchbook</h2>
<p>This menu option <a id="_idIndexMarker322"/>is responsible for sketch organization, creation, code download and upload, and so on.</p>
<div><div><img alt="Figure 3.13 – The Arduino Web Editor sketchbook" src="img/B19752_03_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – The Arduino Web Editor sketchbook</p>
<p>The <a id="_idIndexMarker323"/>numbers in the preceding screenshot correspond to the following elements of the sketchbook screen:</p>
<ol>
<li>The <strong class="bold">NEW SKETCH</strong> button is used to initialize a new set of files for a new project. To the right of this button are two icons – the first is used to create a folder for project organization, and the second is used to import any existing Arduino IDE code/libraries into the Web Editor if required.</li>
<li>Here is where you will find all of your sketches/folders, and you can also search your sketchbooks with the help of the search bar.</li>
<li>The tick icon is used to verify the code, while the arrow icon is used to upload the code to the development board. From the dropdown to the right of these icons, you can select the development board and port. Finally, the ellipses<strong class="bold"> </strong>button contains a range of options regarding sketches, such as <strong class="bold">Save</strong>, <strong class="bold">Save as</strong>, <strong class="bold">Rename Sketch</strong>, and <strong class="bold">Download Sketch</strong>.</li>
<li>This <a id="_idIndexMarker324"/>area is a playground for developers to write code for their devices. Here, you will find two icons to the right of the screen, the first of which is used to make the code editor full-screen, while the second is used for code indentation.</li>
<li>This is the output terminal where you can get all the information about code compilation progress and any errors found in your code.</li>
</ol>
<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/>Examples</h2>
<p>One of <a id="_idIndexMarker325"/>the top features of Arduino IDE is <strong class="bold">Examples</strong>, which is a great resource for beginners, who can benefit from examples provided by library and sensor developers. This is presented as a separate menu in the Arduino Web Editor. <em class="italic">Figure 3</em><em class="italic">.14</em> shows the <strong class="bold">Example</strong> menu with two different tabs. The first tab shows the <strong class="bold">BUILT IN</strong> examples, while the second tab shows the <strong class="bold">FROM </strong><strong class="bold">LIBRARIES</strong> examples.</p>
<div><div><img alt="Figure 3.14 – The Arduino Web Editor examples" src="img/B19752_03_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – The Arduino Web Editor examples</p>
<p>When you click on the <strong class="bold">Examples</strong> menu, the next tab will be displayed, showing options for examples either built-in or from libraries. All the examples are organized in different<a id="_idIndexMarker326"/> categories, just as in the Arduino IDE. You can also use the search bar to find examples from a specific library. By default, the Arduino Web Editor only displays development board-specific examples and libraries. The preceding screenshot only shows examples compatible with MKR Wi-Fi 1010, but you can click on the <strong class="bold">MKR WIFI 1010</strong> link and shift to <strong class="bold">ALL Boards</strong>, and vice versa.</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/>Libraries and the Library Manager</h2>
<p>There are<a id="_idIndexMarker327"/> thousands of libraries for the Arduino platform, developed by developers and sensor and module manufacturers around the world. Libraries <a id="_idIndexMarker328"/>provide vast integration possibilities for sensors/modules in the Arduino IDE as well as, by default, example code. Libraries are the main source of learning for beginners and professional developers. <em class="italic">Figure 3</em><em class="italic">.15</em> shows the <strong class="bold">Libraries</strong> menu with different options, such as <strong class="bold">LIBRARY MANAGER</strong>, which helps us to install the libraries, and the <strong class="bold">DEFAULT</strong>, <strong class="bold">FAVORITES</strong>, and <strong class="bold">CUSTOM</strong> tabs are also shown, which will be discussed in detail step by step:</p>
<div><div><img alt="Figure 3.15 – The Arduino Web Editor libraries" src="img/B19752_03_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – The Arduino Web Editor libraries</p>
<p>In the Arduino Web Editor, we <a id="_idIndexMarker329"/>have access to a vast collection of pre-installed libraries, and we can mark libraries as favorites and include them in our code. When we open the <strong class="bold">Libraries</strong> menu option, we will see the aforementioned three main tabs – <strong class="bold">DEFAULT</strong>, <strong class="bold">FAVORITES</strong>, and <strong class="bold">CUSTOM</strong>. The <strong class="bold">DEFAULT</strong> tab displays all the libraries developed by the Arduino team and verified partners. The <strong class="bold">FAVORITES</strong> tab contains the libraries that you have favorited in the Library Manager. If you can’t find a library specific to your work, then you can import your own library into the Arduino Web Editor by clicking on the <strong class="bold">CUSTOM</strong> tab.</p>
<p>The Library Manager contains a complete list of libraries from all around the world. To add a library to your project <a id="_idIndexMarker330"/>that you can’t find in the <strong class="bold">DEFAULT</strong> tab, just click on <strong class="bold">LIBRARY MANAGER</strong>, and a new popup will appear, where you can search for a library by its name or company name. When found, mark it as a favorite by clicking on the star icon.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>Monitor AKA the Serial Monitor</h2>
<p>The <strong class="bold">Serial Monitor</strong> plays a <a id="_idIndexMarker331"/>vital role in the verification<a id="_idIndexMarker332"/> of <strong class="bold">process execution</strong>, <strong class="bold">sensor testing</strong>, and <strong class="bold">code debugging</strong>. It <a id="_idIndexMarker333"/>works similarly to a console in <a id="_idIndexMarker334"/>a web browser, where developers print messages for process verification according to their requirements. In the Arduino Web Editor, it has been renamed <strong class="bold">Monitor</strong>.</p>
<div><div><img alt="Figure 3.16 – The Arduino Web Editor | Monitor" src="img/B19752_03_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – The Arduino Web Editor | Monitor</p>
<p>Clicking on the <strong class="bold">Monitor</strong> link will only activate the Monitor when there is a board connected to the system. Make sure your Arduino Create Agent is running in the background as <a id="_idIndexMarker335"/>well. At the top of the <strong class="bold">Monitor</strong> screen, you will see the name of the development board and the port name/number to which it’s connected.</p>
<p>Next, set the <code>Serial.begin()</code> method. Developers mostly use 9,600 baud rates for serial communication. The large text area in the bottom half of the Monitor shows all communication between the device and the developer. By default, <strong class="bold">AUTOSCROLL</strong> is enabled in this window, so new messages will automatically be shown.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/>Reference, help, and preferences</h2>
<p>The <code>Delay</code> function; just find and click on the <code>Delay()</code> method, and it will show you a description, with example syntax and code for better understanding.</p>
<p>The <strong class="bold">Help</strong> menu <a id="_idIndexMarker338"/>provides lots of new information about product updates and much more. Information is divided into three tabs, <strong class="bold">INFO</strong>, <strong class="bold">TUTORIALS</strong>, and <strong class="bold">GLOSSARY</strong>. The <strong class="bold">INFO</strong> tab provides all the latest updates regarding versions, compatibility, and bug fixes. The <strong class="bold">TUTORIALS</strong> tab contains links to small projects that help beginners to learn new stuff. <strong class="bold">GLOSSARY</strong> is just like a glossary in a book, but here, you will get a specific list related to Arduino, electronics, sensors, and so on.</p>
<p>Finally, we <a id="_idIndexMarker339"/>arrive at the <strong class="bold">Preferences</strong> menu, from where we can modify the Web Editor’s theme and font size, show/hide the output panel, and set code to auto-save or be manually saved.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor078"/>Arduino IoT Web Editor features</h2>
<p>In the <a id="_idIndexMarker340"/>Arduino IDE, we don’t have any restrictions regarding sketch creation, compilation, or storage, but in the Arduino Web Editor, we do encounter some restrictions. This is because, with Arduino IDE on desktop machines, we use our own resources, but everything involved with the Web Editor is hosted on the cloud. On the cloud, everything has to be paid for, including storage, processor, and memory usage for code verification and compilation.</p>
<p>For that reason, the Arduino Web Editor has some restrictions and limitations on storage size, sketches, and compilations. Arduino has different resource allowances for different types of subscribers, which should be compared with other plans before purchase. Visit <a href="https://cloud.arduino.cc/plans">https://cloud.arduino.cc/plans</a> for complete details and a comparison of the plans.</p>
<div><div><img alt="Figure 3.17 – The Arduino Web Editor limits and usage" src="img/B19752_03_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17 – The Arduino Web Editor limits and usage</p>
<p>The preceding screenshot displays stats regarding the Web Editor features. Firstly, we can see how much storage space has been used from the total made available as part of the subscription plan. I have 1,000 MB of storage in total with my Maker Pro plan. The screenshot <a id="_idIndexMarker341"/>also shows how many sketches can be created, and finally, how many compilations are allowed. In my case, I have unlimited, but the Free plan only had 100 MB of space allowed for sketch storage and limits of 25 compilations per day.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The Arduino Web Editor features are subject to change over time, so please visit the official page for up-to-date information: <a href="https://cloud.arduino.cc/plans">https://cloud.arduino.cc/plans</a>.</p>
<p>Here, we successfully discussed the different options in the new Arduino Web Editor in depth, which will help you to use the Editor effectively and efficiently in your development projects, helping you to boost your productivity. The following section, <em class="italic">Assignments</em>, cover different questions for you, which will help to test out what you have learned in this chapter and through internet searches, helping you to utilize your new skills effectively.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor079"/>Assignments</h1>
<p>This chapter is longer in length than the previous ones, as we want to give you an in-depth overview of Arduino IoT Cloud and its main pillars, which include Things, devices, dashboards, integrations and templates, progressing to further chapters. In this chapter, we have discussed dashboards, input and output widget controls, as well as the Arduino Web Editor in detail. To consolidate what you have learned in this chapter, we have created three different assignments for you. These assignments will help you to understand the core concepts necessary to proceed with the book, as well as in your professional projects.</p>
<p>Make sure to attempt all the assignments given ahead.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor080"/>Assignment 1</h2>
<p>ASNA Group is a leading ISO-certified salt supplier organization in Pakistan. The organization processes salt according to international standards, but they are facing issues in warehouse monitoring, where they want to maintain the temperature/humidity in line with the standards, to avoid issues with the finished product. Right now, they have five warehouses to monitor. They want multiple views for data monitoring and analysis. You need to keep the following questions in mind while developing a solution for ASNA Group:</p>
<ol>
<li>Firstly, identify what type of industrial-grade sensors/development boards are required for this monitoring scenario.</li>
<li>Is there any calibration required for the sensors? If so, how will you calibrate the sensors? If not, provide a reason why it’s not mandatory.</li>
<li>What type of widgets are required to visualize the information on a dashboard?</li>
<li>How you could visualize readings from five warehouses on one dashboard?</li>
<li>What type of widgets will be used on the dashboard to allow users to analyze readings covering a long period of time?</li>
<li>By what means will you give the company access to the dashboard?</li>
</ol>
<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/>Assignment 2</h2>
<p>Imzlab Technologies Private Limited is a leading smart agriculture solution provider. The company has deployed custom-designed sensors in the field, using ESP32 and the Arduino IoT Cloud, to measure soil moisture, soil temperature, and outdoor temperature/humidity. On the dashboard, they have different widgets for data visualization. They now have a new requirement from a customer to integrate a water pump control and display its status history (on/off). The customer also requires that on Monday and Thursday, the water pump will run from 5:00 p.m. to 7:00 p.m., and on Sunday, from 4:00 a.m. to 6:00 a.m., in the GMT+5 time zone. On other days, the pump status will be controlled manually. You need to keep the following questions in mind while developing a solution for Imzlab Technologies Private Limited:</p>
<ol>
<li>What type of control widgets are required to display and control the water pump status?</li>
<li>How can you provide a solution for automatic pump control on specific days and at specific times?</li>
<li>Is it possible to visualize the water pump on/off status history using charts? If so, how? If it’s not possible, provide an alternative solution to meet the customer’s requirements.</li>
</ol>
<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>Assignment 3</h2>
<p>A group of researchers at Imzlab Technologies Private Limited is working on a monitoring system to monitor carbon dioxide levels. They are using MKR 1010 and the Arduino IoT Cloud, but they are trying to use a custom sensor developed by Tingstack LLC. In the Arduino Web Editor, there is no library for this sensor, but Tingstack LLC has developed an in-house library for the Arduino platform. The researchers also want to share their code with the Tingstack LLC team for review.</p>
<p>Identify the problems from the preceding paragraph, and write down their solutions.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor083"/>Summary</h1>
<p>This chapter was just like understanding the ingredients and kitchen tools we have before we start cooking. Firstly, we learned about how the Arduino IoT Cloud components work, including Things, devices, dashboards, integrations, and templates. Then, we studied all the input/output widget controls to get a proper idea of their potential usage, including some example code and the cloud variable types. In the following section, we examined what the Arduino Web Editor is and how its different features work, including examples, libraries, and the Serial Monitor. You should now have a good understanding of all the different ingredients of the Arduino IoT Cloud and the Web Editor and how to employ them appropriately.</p>
<p>This chapter was most important before starting the next chapters, as it gives you an in-depth overview of all the main pillars of the Arduino IoT Cloud and how they work in real time, which will help you to understand how the Arduino IoT Cloud works. Arduino dashboard widgets are also very important to us, as we will use different widgets in different projects throughout the book, so giving you an overview here has prepared you for upcoming chapters, helping you to understand what types of things are mandatory for professional projects and what type of controls make your project more robust and professional.</p>
<p>In the following chapter, we will start work on our first project, where we will build an air-quality monitoring system from scratch to deployment. You will learn why air-quality monitoring is necessary and what types of development boards/sensors are required. We will also use a <strong class="bold">Printed Circuit Board</strong> (<strong class="bold">PCB</strong>) for proper deployment, which will be explained in depth. After a section on the necessary hardware, we will set up Things, cloud variables, devices, and network configurations and coding for a device, as well as a dashboard for proper data visualization. So, gear up for the upcoming chapter, which will be fun for all of you.</p>
</div>


<div><h1 id="_idParaDest-84" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor084"/>Part 2: Getting Hands-On with Different Communication Technologies</h1>
<p>The second part of the book describes the different communication technologies involved in IoT projects and provides four different practical projects to demonstrate their usage and how third-party components can be adopted in combination with the Arduino IoT Cloud.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B19752_04.xhtml#_idTextAnchor085"><em class="italic">Chapter 4</em></a>, <em class="italic">Project #1 – A Smarter Setup for Sensing the Environment</em></li>
<li><a href="B19752_05.xhtml#_idTextAnchor101"><em class="italic">Chapter 5</em></a>, <em class="italic">Project #2 – Creating a Portable Thing Tracker Using MKR GSM 1400</em></li>
<li><a href="B19752_06.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Project #3 – A Remote Alarming Application with LoRaWAN</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>