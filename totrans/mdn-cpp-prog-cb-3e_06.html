<html><head></head><body>
<div><h1 class="chapterNumber">6</h1>
<h1 class="chapterTitle" id="_idParaDest-325">General-Purpose Utilities</h1>
<p class="normal">The standard library contains many general-purpose utilities and libraries beyond the containers, algorithms, and iterators discussed in the previous chapter. This chapter is focused on three areas: the <code class="inlineCode">chrono</code> library for working with dates, times, calendars, and time zones; type traits, which provide meta-information about other types; and utility types in newer versions of the standard, <code class="inlineCode">std::any</code>, <code class="inlineCode">std::optional</code>, and <code class="inlineCode">std::variant</code> in C++17, <code class="inlineCode">std::span</code> and <code class="inlineCode">std::source_location</code> in C++20, and <code class="inlineCode">std::mdspan</code> and <code class="inlineCode">std::expected</code> in C++23.</p>
<p class="normal">The recipes included in this chapter are as follows:</p>
<ul>
<li class="bulletList">Expressing time intervals with <code class="inlineCode">chrono::duration</code></li>
<li class="bulletList">Working with calendars</li>
<li class="bulletList">Converting times between time zones</li>
<li class="bulletList">Measuring function execution time with a standard clock</li>
<li class="bulletList">Generating hash values for custom types</li>
<li class="bulletList">Using <code class="inlineCode">std::any</code> to store any value</li>
<li class="bulletList">Using <code class="inlineCode">std::optional</code> to store optional values</li>
<li class="bulletList">Chaining together computations that may or may not produce a value</li>
<li class="bulletList">Using <code class="inlineCode">std::variant</code> as a type-safe union</li>
<li class="bulletList">Visiting a <code class="inlineCode">std::variant</code></li>
<li class="bulletList">Using <code class="inlineCode">std::expected</code> to return a value or an error</li>
<li class="bulletList">Using <code class="inlineCode">std::span</code> for contiguous sequences of objects</li>
<li class="bulletList">Using <code class="inlineCode">std::mdspan</code> for multi-dimensional views of sequences of objects</li>
<li class="bulletList">Registering a function to be called when a program exits normally</li>
<li class="bulletList">Using type traits to query properties of types</li>
<li class="bulletList">Writing your own type traits</li>
<li class="bulletList">Using <code class="inlineCode">std::conditional</code> to choose between types</li>
<li class="bulletList">Providing logging details with <code class="inlineCode">source_location</code></li>
<li class="bulletList">Using the <code class="inlineCode">stacktrace</code> library to print the call sequence</li>
</ul>
<p class="normal">The first part of the chapter focuses on the <code class="inlineCode">chrono</code> library, which provides time and date utilities.</p>
<h1 class="heading-1" id="_idParaDest-326">Expressing time intervals with chrono::duration</h1>
<p class="normal">Working <a id="_idIndexMarker678"/>with times and dates is a common operation, regardless of the programming language. C++11 provides a flexible <a id="_idIndexMarker679"/>date and time library as part of the standard library that enables us to define time points and time intervals. This<a id="_idIndexMarker680"/> library, called <code class="inlineCode">chrono</code>, is a general-purpose utility library designed to work with a timer and clocks that can be different on different systems and, therefore, precision-neutral. The library is available in the <code class="inlineCode">&lt;chrono&gt;</code> header in the <code class="inlineCode">std::chrono</code> namespace and defines and implements several components, as follows:</p>
<ul>
<li class="bulletList"><em class="italic">Durations</em>, which represent time intervals</li>
<li class="bulletList"><em class="italic">Time points</em>, which present a duration of time since the epoch of a clock</li>
<li class="bulletList"><em class="italic">Clocks</em>, which define an epoch (that is, the start of time) and a tick</li>
</ul>
<p class="normal">In this recipe, we will learn how to work with durations.</p>
<h2 class="heading-2" id="_idParaDest-327">Getting ready</h2>
<p class="normal">This recipe is not intended as a complete reference to the <code class="inlineCode">duration</code> class. It is recommended that you consult additional resources for that purpose (the library reference documentation is available at <a href="http://en.cppreference.com/w/cpp/chrono">http://en.cppreference.com/w/cpp/chrono</a>).</p>
<p class="normal">In the <code class="inlineCode">chrono</code> library, a time interval is represented by the <code class="inlineCode">std::chrono::duration</code> class.</p>
<h2 class="heading-2" id="_idParaDest-328">How to do it...</h2>
<p class="normal">To work with time intervals, use the following:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::chrono::duration</code> typedefs for hours, minutes, seconds, milliseconds, microseconds, and nanoseconds:
        <pre class="programlisting code"><code class="hljs-code">std::chrono::hours        half_day(12);
std::chrono::minutes      half_hour(30);
std::chrono::seconds      half_minute(30);
std::chrono::milliseconds half_second(500);
std::chrono::microseconds half_millisecond(500);
std::chrono::nanoseconds  half_microsecond(500);
</code></pre>
</li>
<li class="bulletList">Use<a id="_idIndexMarker681"/> the standard user-defined literal operators from C++14, available in the namespace <code class="inlineCode">std::chrono_literals</code>, to create durations of hours, minutes, seconds, milliseconds, microseconds, and nanoseconds:
        <pre class="programlisting code"><code class="hljs-code">using namespace std::chrono_literals;
auto half_day         = 12h;
auto half_hour        = 30min;
auto half_minute      = 30s;
auto half_second      = 500ms;
auto half_millisecond = 500us;
auto half_microsecond = 500ns;
</code></pre>
</li>
<li class="bulletList">Use <a id="_idIndexMarker682"/>direct conversion from a lower precision duration to a higher precision duration:
        <pre class="programlisting code"><code class="hljs-code">std::chrono::hours half_day_in_h(12);
std::chrono::minutes half_day_in_min(half_day_in_h);
std::cout &lt;&lt; half_day_in_h.count() &lt;&lt; "h" &lt;&lt; '\n';    //12h
std::cout &lt;&lt; half_day_in_min.count() &lt;&lt; "min" &lt;&lt; '\n';//720min
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">std::chrono::duration_cast</code> to convert from a higher precision to a lower precision duration:
        <pre class="programlisting code"><code class="hljs-code">using namespace std::chrono_literals;
auto total_seconds = 12345s;
auto hours =
  std::chrono::duration_cast&lt;std::chrono::hours&gt;(total_seconds);
auto minutes =
  std::chrono::duration_cast&lt;std::chrono::minutes&gt;(total_seconds % 1h);
auto seconds =
  std::chrono::duration_cast&lt;std::chrono::seconds&gt;(total_seconds % 1min);
std::cout &lt;&lt; hours.count()   &lt;&lt; ':'
          &lt;&lt; minutes.count() &lt;&lt; ':'
          &lt;&lt; seconds.count() &lt;&lt; '\n'; // 3:25:45
</code></pre>
</li>
<li class="bulletList">Use <a id="_idIndexMarker683"/>the chrono conversion functions <code class="inlineCode">floor()</code>, <code class="inlineCode">round()</code>, and <code class="inlineCode">ceil()</code> available in the <code class="inlineCode">std::chrono</code> namespace in C++17 when rounding is necessary (not to be confused with the <code class="inlineCode">std::floor()</code>, <code class="inlineCode">std::round()</code>, and <code class="inlineCode">std::ceil()</code> functions from the <code class="inlineCode">&lt;cmath&gt;</code> header):
        <pre class="programlisting code"><code class="hljs-code">using namespace std::chrono_literals;
auto total_seconds = 12345s;
auto m1 = std::chrono::floor&lt;std::chrono::minutes&gt;(total_seconds); 
// 205 min
auto m2 = std::chrono::round&lt;std::chrono::minutes&gt;(total_seconds); 
// 206 min
auto m3 = std::chrono::ceil&lt;std::chrono::minutes&gt;(total_seconds); 
// 206 min
auto sa = std::chrono::abs(total_seconds);
</code></pre>
</li>
<li class="bulletList">Use<a id="_idIndexMarker684"/> arithmetic operations, compound assignments, and comparison operations to modify and compare time intervals:
        <pre class="programlisting code"><code class="hljs-code">using namespace std::chrono_literals;
auto d1 = 1h + 23min + 45s; // d1 = 5025s
auto d2 = 3h + 12min + 50s; // d2 = 11570s
if (d1 &lt; d2) { /* do something */ }
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-329">How it works...</h2>
<p class="normal">The <code class="inlineCode">std::chrono::duration</code> class defines a number of ticks (the increment between two moments in time) over a unit of time. The default unit is the second, and for expressing other units, such as minutes or milliseconds, we need to use a ratio. For units greater than a second, the ratio is greater than one, such as <code class="inlineCode">ratio&lt;60&gt;</code> for minutes. For units smaller than a second, the ratio is smaller than one, such as <code class="inlineCode">ratio&lt;1, 1000&gt;</code> for milliseconds. The number of ticks can be retrieved with the <code class="inlineCode">count()</code> member function.</p>
<p class="normal">The standard library defines several type synonyms for durations of nanoseconds, microseconds, milliseconds, seconds, minutes, and hours, which we used in the first example in the <a id="_idIndexMarker685"/>previous section. The following code shows how these durations are defined in the <code class="inlineCode">chrono</code> namespace:</p>
<pre class="programlisting code"><code class="hljs-code">namespace std {
  namespace chrono {
    typedef duration&lt;long long, ratio&lt;1, 1000000000&gt;&gt; nanoseconds;
    typedef duration&lt;long long, ratio&lt;1, 1000000&gt;&gt; microseconds;
    typedef duration&lt;long long, ratio&lt;1, 1000&gt;&gt; milliseconds;
    typedef duration&lt;long long&gt; seconds;
    typedef duration&lt;int, ratio&lt;60&gt; &gt; minutes;
    typedef duration&lt;int, ratio&lt;3600&gt; &gt; hours;
  }
}
</code></pre>
<p class="normal">However, with<a id="_idIndexMarker686"/> this flexible definition, we can express time intervals such as <em class="italic">1.2 sixths of a minute</em> (which means 12 seconds), where 1.2 is the number of ticks of the duration and <code class="inlineCode">ratio&lt;10&gt;</code> (as in 60/6) is the time unit:</p>
<pre class="programlisting code"><code class="hljs-code">std::chrono::duration&lt;double, std::ratio&lt;10&gt;&gt; d(1.2); // 12 sec
</code></pre>
<p class="normal">In C++14, several standard user-defined literal operators have been added to the namespace <code class="inlineCode">std::chrono_literals</code>. This makes it easier to define durations, but you must include the namespace in the scope where you want to use the literal operators.</p>
<div><p class="normal">You should only include namespaces for user-defined literal operators in the scope where you want to use them, and not in larger scopes, in order to avoid conflict with other operators with the same name from different libraries and namespaces.</p>
</div>
<p class="normal">All arithmetic operations are available for the <code class="inlineCode">duration</code> class. It is possible to add and subtract durations, multiply or divide them by a value, or apply the <code class="inlineCode">modulo</code> operation. However, it is important to note that when two durations of different time units are added or subtracted, the result is a duration of the greatest common divisor of the two time units. This means that if you add a duration representing seconds and a duration representing minutes, the result is a duration representing seconds.</p>
<p class="normal">Conversion from a duration with a less precise time unit to a duration with a more precise time unit is done implicitly. On the other hand, conversion from a more precise to a less precise time unit requires an explicit cast. This is done with the non-member function <code class="inlineCode">std::chrono::duration_cast()</code>. In the <em class="italic">How to do it...</em> section, you saw an example for <a id="_idIndexMarker687"/>determining the number of hours, minutes, and seconds of a given duration expressed in seconds.</p>
<p class="normal">C++17 has added <a id="_idIndexMarker688"/>several more non-member conversion functions that perform duration casting with rounding: <code class="inlineCode">floor()</code> to round down, <code class="inlineCode">ceil()</code> to round up, and <code class="inlineCode">round()</code> to round to the nearest. Also, C++17 added a non-member function called <code class="inlineCode">abs()</code> to retain the absolute value of a duration.</p>
<h2 class="heading-2" id="_idParaDest-330">There’s more...</h2>
<p class="normal"><code class="inlineCode">chrono</code> is a general-purpose library that, before C++20, lacked many useful features, such as expressing a date with the year, month, and day parts, working with time zones and calendars, and others. The C++20 standard added support for calendars and time zones, which we will see in the following recipes. If you use a compiler that doesn’t support these C++20 additions, then third-party libraries can implement these features, and a recommended one is Howard Hinnant’s <code class="inlineCode">date</code> library, available under the MIT license at <a href="https://github.com/HowardHinnant/date">https://github.com/HowardHinnant/date</a>. This library was the foundation for the C++20 <code class="inlineCode">chrono</code> additions.</p>
<h2 class="heading-2" id="_idParaDest-331">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Measuring function execution time with a standard clock</em>, to see how you can determine the execution time of a function</li>
<li class="bulletList"><em class="italic">Working with calendars</em>, to discover the C++20 additions to the <code class="inlineCode">chrono</code> library for working with dates and calendars</li>
<li class="bulletList"><em class="italic">Converting times between time zones</em>, to learn how you can convert time points between different time zones in C++20</li>
</ul>
<h1 class="heading-1" id="_idParaDest-332">Working with calendars</h1>
<p class="normal">The <code class="inlineCode">chrono</code> library, available in C++11, offered support for clocks, time points, and durations <a id="_idIndexMarker689"/>but did not make it easy to express times and dates, especially with respect to calendars and time zones. The new C++20 standard corrects this by extending the existing <code class="inlineCode">chrono</code> library with:</p>
<ul>
<li class="bulletList">More clocks, such as a UTC clock, an International Atomic Time clock, a GPS clock, a file time clock, and a pseudo-clock representing local time.</li>
<li class="bulletList">Time of day, representing the time elapsed since midnight split into hours, minutes, and seconds.</li>
<li class="bulletList">Calendars, which enable us to express dates with year, month, and day parts.</li>
<li class="bulletList">Time zones, which enable us to express time points with respect to a time zone and make it possible to convert times between different time zones.</li>
<li class="bulletList">I/O support for parsing chrono objects from a stream.</li>
</ul>
<p class="normal">In this recipe, we will learn about working with calendar objects.</p>
<h2 class="heading-2" id="_idParaDest-333">Getting ready</h2>
<p class="normal">All the new <a id="_idIndexMarker690"/>chrono functionalities are available in the same <code class="inlineCode">std::chrono</code> and <code class="inlineCode">std::chrono_literals</code> namespaces in the <code class="inlineCode">&lt;chrono&gt;</code> header.</p>
<h2 class="heading-2" id="_idParaDest-334">How to do it…</h2>
<p class="normal">You can use the C++20 chrono calendar functionalities to:</p>
<ul>
<li class="bulletList">Represent Gregorian calendar dates with year, month, and day, as instances of the <code class="inlineCode">year_month_day</code> type. Use the standard user-defined literals, constants, and the overloaded operator <code class="inlineCode">/</code> to construct such objects:
        <pre class="programlisting code"><code class="hljs-code">// format: year / month /day
year_month_day d1 = 2024y / 1 / 15;
year_month_day d2 = 2024y / January / 15;
// format: day / month / year
year_month_day d3 = 15d / 1 / 2024;
year_month_day d4 = 15d / January / 2024
// format: month / day / year
year_month_day d5 = 1 / 15d / 2024;
year_month_day d6 = January / 15 / 2024;
</code></pre>
</li>
<li class="bulletList">Represent the <em class="italic">n</em>th weekday of a specific year and month as instances of the <code class="inlineCode">year_month_weekday</code> type:
        <pre class="programlisting code"><code class="hljs-code">// format: year / month / weekday
year_month_weekday d1 = 2024y / January / Monday[1];
// format: weekday / month / year
year_month_weekday d2 = Monday[1] / January / 2024;
// format: month / weekday / year
year_month_weekday d3 = January / Monday[1] / 2024;
</code></pre>
</li>
<li class="bulletList">Determine the current date, as well as compute other dates from it, such as the dates for tomorrow and yesterday:
        <pre class="programlisting code"><code class="hljs-code">auto today = floor&lt;days&gt;(std::chrono::system_clock::now());
auto tomorrow = today + days{ 1 };
auto yesterday = today - days{ 1 };
</code></pre>
</li>
<li class="bulletList">Determine<a id="_idIndexMarker691"/> the first and last day of a specific month and year:
        <pre class="programlisting code"><code class="hljs-code">year_month_day today = floor&lt;days&gt;(std::chrono::system_clock::now());
year_month_day first_day_this_month = today.year() / today.month() / 1;
year_month_day last_day_this_month = today.year() / today.month() / last; // std::chrono::last
year_month_day last_day_feb_2024 = 2024y / February / last;
year_month_day_last ymdl {today.year(), month_day_last{ month{ 2 } }};
year_month_day last_day_feb { ymdl };
</code></pre>
</li>
<li class="bulletList">Compute the number of days between two dates:
        <pre class="programlisting code"><code class="hljs-code">inline int number_of_days(std::chrono::sys_days const&amp; first,
                          std::chrono::sys_days const&amp; last)
{
  return (last - first).count();
}
auto days = number_of_days(2024y / April / 1,
  2024y / December / 25);
</code></pre>
</li>
<li class="bulletList">Check whether a date is valid:
        <pre class="programlisting code"><code class="hljs-code">auto day = 2024y / January / 33;
auto is_valid = day.ok();
</code></pre>
</li>
<li class="bulletList">Represent the time of day with hour, minutes, and seconds using the <code class="inlineCode">hh_mm_ss&lt;Duration&gt;</code> class template, where <code class="inlineCode">Duration</code> determines the precision used to split a time interval. In the next example, <code class="inlineCode">std::chrono::seconds</code> defines a split precision of 1 second:
        <pre class="programlisting code"><code class="hljs-code">chrono::hh_mm_ss&lt;chrono::seconds&gt; td(13h+12min+11s);
std::cout &lt;&lt; td &lt;&lt; '\n';  // 13:12:11
</code></pre>
</li>
<li class="bulletList">Create time points with date and time parts:
        <pre class="programlisting code"><code class="hljs-code">auto tp = chrono::sys_days{ 2024y / April / 1 } + 12h + 30min + 45s;
std::cout &lt;&lt; tp &lt;&lt; '\n';  // 2024-04-01 12:30:45
</code></pre>
</li>
<li class="bulletList">Determine <a id="_idIndexMarker692"/>the current time of day and express it with various precisions:
        <pre class="programlisting code"><code class="hljs-code">auto tp = std::chrono::system_clock::now();
auto dp = floor&lt;days&gt;(tp);
chrono::hh_mm_ss&lt;chrono::milliseconds&gt; time1 {
  chrono::duration_cast&lt;chrono::milliseconds&gt;(tp - dp) };
std::cout &lt;&lt; time1 &lt;&lt; '\n';  // 13:12:11.625
chrono::hh_mm_ss&lt;chrono::minutes&gt; time2 {
  chrono::duration_cast&lt;chrono::minutes&gt;(tp - dp) };
std::cout &lt;&lt; time2 &lt;&lt; '\n';  // 13:12
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-335">How it works…</h2>
<p class="normal">The <code class="inlineCode">year_month_day</code> and <code class="inlineCode">year_month_weekday</code> types we have seen in the examples here are only some of the many new types added to the <code class="inlineCode">chrono</code> library for calendar support. The following table lists all these types in the <code class="inlineCode">std::chrono</code> namespace and what they represent:</p>
<table class="table-container" id="table001-3">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Type</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Represents</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">day</code></p>
</td>
<td class="table-cell">
<p class="normal">A day of a month</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">month</code></p>
</td>
<td class="table-cell">
<p class="normal">A month of a year</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">year</code></p>
</td>
<td class="table-cell">
<p class="normal">A year in the Gregorian calendar</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">weekday</code></p>
</td>
<td class="table-cell">
<p class="normal">A day of the week in the Gregorian calendar</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">weekday_indexed</code></p>
</td>
<td class="table-cell">
<p class="normal">The <em class="italic">n</em>th weekday of a month, where <em class="italic">n</em> is in the range [1, 5] (1 is the 1st weekday of the month and 5 is the 5th—if it exists—weekday of the month)</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">weekday_last</code></p>
</td>
<td class="table-cell">
<p class="normal">The last weekday of a month</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">month_day</code></p>
</td>
<td class="table-cell">
<p class="normal">A specific day of a specific month</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">month_day_last</code></p>
</td>
<td class="table-cell">
<p class="normal">The last day of a specific month</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">month_weekday</code></p>
</td>
<td class="table-cell">
<p class="normal">The <em class="italic">n</em>th weekday of a specific month</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">month_weekday_last</code></p>
</td>
<td class="table-cell">
<p class="normal">The last weekday of a specific month</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">year_month</code></p>
</td>
<td class="table-cell">
<p class="normal">A specific month of a specific year</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">year_month_day</code></p>
</td>
<td class="table-cell">
<p class="normal">A specific year, month, and day</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">year_month_day_last</code></p>
</td>
<td class="table-cell">
<p class="normal">The last day of a specific year and month</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">year_month_weekday</code></p>
</td>
<td class="table-cell">
<p class="normal">The <em class="italic">n</em>th weekday of a specific year and month</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">year_month_weekday_last</code></p>
</td>
<td class="table-cell">
<p class="normal">The last weekday of a specific year and month</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 6.1: C++20 chrono types for working with dates</p>
<p class="normal">All the types<a id="_idIndexMarker693"/> listed in this table have:</p>
<ul>
<li class="bulletList">A default constructor that leaves the member fields uninitialized</li>
<li class="bulletList">Member functions to access the parts of the entity</li>
<li class="bulletList">A member function called <code class="inlineCode">ok()</code> that checks if the stored value is valid</li>
<li class="bulletList">Non-member comparison operators to compare values of the type</li>
<li class="bulletList">An overloaded <code class="inlineCode">operator&lt;&lt;</code> to output a value of the type to a stream</li>
<li class="bulletList">An overloaded function template called <code class="inlineCode">from_stream()</code> that parses a value from a stream according to the provided format</li>
<li class="bulletList">A specialization of the <code class="inlineCode">std::formatter&lt;T, CharT&gt;</code> class template for the text formatting library</li>
</ul>
<p class="normal">In <a id="_idIndexMarker694"/>addition, the <code class="inlineCode">operator/</code> is overloaded for many of these types to enable us to easily create Gregorian calendar dates. When you create a date (with year, month, and day), you can choose between three different formats:</p>
<ul>
<li class="bulletList"><strong class="keyWord">year/month/day</strong> (used in countries such as China, Japan, Korea, and Canada, but others too, sometimes together with the day/month/year format)</li>
<li class="bulletList"><strong class="keyWord">month/day/year</strong> (used in the USA)</li>
<li class="bulletList"><strong class="keyWord">day/month/year</strong> (used in most parts of the world)</li>
</ul>
<p class="normal">In these cases, <strong class="keyWord">day</strong> can be either:</p>
<ul>
<li class="bulletList">An actual day of the month (values from 1 to 31)</li>
<li class="bulletList"><code class="inlineCode">std:chrono::last</code> to indicate the last day of the month</li>
<li class="bulletList"><code class="inlineCode">weekday[n]</code>, to indicate the <em class="italic">n</em>th weekday of the month (where <em class="italic">n</em> can take values from 1 to 5)</li>
<li class="bulletList"><code class="inlineCode">weekday[std::chrono::last]</code>, to indicate the last weekday of the month</li>
</ul>
<p class="normal">In order to disambiguate between integers that represent the day, month, and year, the library provides two user-defined literals: <code class="inlineCode">""y</code> to construct a literal of the type <code class="inlineCode">std::chrono::year</code>, and <code class="inlineCode">""d</code> to construct a literal of the type <code class="inlineCode">std::chrono::day</code>.</p>
<p class="normal">In addition, there are constants that represent:</p>
<ul>
<li class="bulletList">A <code class="inlineCode">std::chrono::month</code>, named <code class="inlineCode">January</code>, <code class="inlineCode">February</code>, up to <code class="inlineCode">December</code>.</li>
<li class="bulletList">A <code class="inlineCode">std::chrono::weekday</code>, named <code class="inlineCode">Sunday</code>, <code class="inlineCode">Monday</code>, <code class="inlineCode">Tuesday</code>, <code class="inlineCode">Wednesday</code>, <code class="inlineCode">Thursday</code>, <code class="inlineCode">Friday</code>, or <code class="inlineCode">Saturday</code>.</li>
</ul>
<p class="normal">You can use all these to construct dates such as <code class="inlineCode">2025y/April/1</code>, <code class="inlineCode">25d/December/2025</code>, or <code class="inlineCode">Sunday[last]/May/2025</code>.</p>
<p class="normal">The <code class="inlineCode">year_month_day</code> type provides implicit conversion to and from <code class="inlineCode">std::chrono::sys_days</code>. This type is a <code class="inlineCode">std::chrono::time_point</code> with the precision of a day (24 hours). There is a companion type called <code class="inlineCode">std::chrono::sys_seconds</code>, which is a <code class="inlineCode">time_point</code> with a precision of one second. Explicit conversion between <code class="inlineCode">time_point</code> and <code class="inlineCode">sys_days</code> / <code class="inlineCode">sys_seconds</code> can be performed using <code class="inlineCode">std::chrono::time_point_cast()</code> or <code class="inlineCode">std::chrono::floor()</code>.</p>
<p class="normal">To represent a <a id="_idIndexMarker695"/>moment of time during a day, we can use the <code class="inlineCode">std::chrono::hh_mm_ss</code> type. This class represents the time elapsed since midnight, broken down into hours, minutes, seconds, and sub-seconds. This type is mostly intended as a formatting tool.</p>
<p class="normal">There are also several utility functions for translating between 12h/24h formats. These functions are:</p>
<ul>
<li class="bulletList"><code class="inlineCode">is_am()</code> and <code class="inlineCode">is_pm()</code> that check whether a 24-hour formatted time (provided as a <code class="inlineCode">std::chrono::hours</code> value) is A.M. (before midday) or, respectively, P.M. (before midnight):
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; is_am(0h)  &lt;&lt; '\n'; // true
std::cout &lt;&lt; is_am(1h)  &lt;&lt; '\n'; // true
std::cout &lt;&lt; is_am(12h) &lt;&lt; '\n'; // false
std::cout &lt;&lt; is_pm(0h)  &lt;&lt; '\n'; // false
std::cout &lt;&lt; is_pm(12h) &lt;&lt; '\n'; // true
std::cout &lt;&lt; is_pm(23h) &lt;&lt; '\n'; // true
std::cout &lt;&lt; is_pm(24h) &lt;&lt; '\n'; // false
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">make12()</code> and <code class="inlineCode">make24()</code> that return the 12-hour equivalent of a 24-hour format time and, respectively, vice versa. They both take the input time as a <code class="inlineCode">std::chrono::hours</code> value, but <code class="inlineCode">make24()</code> has an additional parameter, a Boolean indicating whether the time is P.M.:
        <pre class="programlisting code"><code class="hljs-code">for (auto h : { 0h, 1h, 12h, 23h, 24h })
{
   std::cout &lt;&lt; make12(h).count() &lt;&lt; '\n';
   // prints 12, 1, 12, 11, 12
}
for (auto [h, pm] : { 
   std::pair&lt;hours, bool&gt;{ 0h, false},
   std::pair&lt;hours, bool&gt;{ 1h, false}, 
   std::pair&lt;hours, bool&gt;{ 1h, true}, 
   std::pair&lt;hours, bool&gt;{12h, false}, 
   std::pair&lt;hours, bool&gt;{12h, true}, })
{
   std::cout &lt;&lt; make24(h, pm).count() &lt;&lt; '\n';
   // prints 0, 1, 13, 0, 12
}
</code></pre>
</li>
</ul>
<p class="normal">As you can<a id="_idIndexMarker696"/> see from these examples, these four functions only work with an hour value, since only the hour part of a moment of time determines its format as 12h or 24h or whether it’s an A.M. or P.M. time.</p>
<div><p class="normal">At the time of publishing the second edition of this book, the chrono changes were not completed. The <code class="inlineCode">hh_mm_ss</code> type was called <code class="inlineCode">time_of_day</code>, and the <code class="inlineCode">make12()</code>/<code class="inlineCode">make_24()</code> functions were members of it. This edition reflects the changes and utilizes the standardized API.</p>
</div>
<h2 class="heading-2" id="_idParaDest-336">There’s more…</h2>
<p class="normal">The date and time facilities described here are all based on the <code class="inlineCode">std::chrono::system_clock</code>. Since C++20, this clock is defined to measure the Unix time, which is the time since 00:00:00 UTC on 1 January 1970. This means the implicit time zone is UTC. However, in most cases, you might be interested in the local time of a specific time zone. To help with that, the <code class="inlineCode">chrono</code> library added support for time zones, which is what we will learn about in the next recipe.</p>
<h2 class="heading-2" id="_idParaDest-337">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Expressing time intervals with chrono::duration</em>, to familiarize yourself with the fundamentals of the C++11 <code class="inlineCode">chrono</code> library and to work with durations, time points, and points</li>
<li class="bulletList"><em class="italic">Converting times between time zones</em>, to learn how you can convert time points between different time zones in C++20</li>
</ul>
<h1 class="heading-1" id="_idParaDest-338">Converting times between time zones</h1>
<p class="normal">In the <a id="_idIndexMarker697"/>previous recipe, we talked about C++20 support for working with calendars and expressing dates in the Gregorian calendar with the <code class="inlineCode">year_month_day</code> type and others from the <code class="inlineCode">chrono</code> library.</p>
<p class="normal">We also saw how to represent times of day with the <code class="inlineCode">hh_mm_ss</code> type. However, in all these examples, we worked with the time points using the system clock, which measures Unix time and, therefore, uses UTC as the default time zone. However, we are usually interested in the local time and, sometimes, in the time in some other time zone. This is possible with the facilities added to the <code class="inlineCode">chrono</code> library to support time zones. In this recipe, you will learn about the most important functionalities of chrono’s time zones.</p>
<h2 class="heading-2" id="_idParaDest-339">Getting ready</h2>
<p class="normal">Before<a id="_idIndexMarker698"/> continuing with this recipe, it is recommended that you read the previous one, <em class="italic">Working with calendars</em>, if you have not done so already.</p>
<h2 class="heading-2" id="_idParaDest-340">How to do it…</h2>
<p class="normal">You can do the following using the C++20 <code class="inlineCode">chrono</code> library:</p>
<ul>
<li class="bulletList">Use the <code class="inlineCode">std::chrono::current_zone()</code> to retrieve the local time zone from the time zone database.</li>
<li class="bulletList">Use <code class="inlineCode">std::chrono::locate_zone()</code> to retrieve a particular time zone, using its name, from the time zone database.</li>
<li class="bulletList">Represent a time point in a particular time zone using the <code class="inlineCode">std::chrono::zoned_time</code> class template.</li>
<li class="bulletList">Retrieve and display the current local time:
        <pre class="programlisting code"><code class="hljs-code">auto time = zoned_time{ current_zone(), system_clock::now() };
std::cout &lt;&lt; time &lt;&lt; '\n'; // 2024-01-16 22:10:30.9274320 EET
</code></pre>
</li>
<li class="bulletList">Retrieve and display the current time in another time zone. In the following example, we use the time in Italy:
        <pre class="programlisting code"><code class="hljs-code">auto time = zoned_time{ locate_zone("Europe/Rome"),
                        system_clock::now() };
std::cout &lt;&lt; time &lt;&lt; '\n'; // 2024-01-16 21:10:30.9291091 CET
</code></pre>
</li>
<li class="bulletList">Display the current local time with proper locale formatting. In this example, the current time is Romanian time, and the locale being used is for Romania:
        <pre class="programlisting code"><code class="hljs-code">auto time = zoned_time{ current_zone(), system_clock::now() };
std::cout &lt;&lt; std::format(std::locale{"ro_RO"}, "%c", time)
          &lt;&lt; '\n'; // 16.01.2024 22:12:57
</code></pre>
</li>
<li class="bulletList">Represent a time point in a particular time zone and display it. In the following example, this is New York’s time:
        <pre class="programlisting code"><code class="hljs-code">auto time = local_days{ 2024y / June / 1 } + 12h + 30min + 45s + 256ms;
auto ny_time = zoned_time&lt;std::chrono::milliseconds&gt;{
                  locate_zone("America/New_York"), time};
std::cout &lt;&lt; ny_time &lt;&lt; '\n';
// 2024-06-01 12:30:45.256 EDT
</code></pre>
</li>
<li class="bulletList">Convert<a id="_idIndexMarker699"/> a time point in a particular time zone into a time point in another time zone. In the following example, we convert the time from New York into the time in Los Angeles:
        <pre class="programlisting code"><code class="hljs-code">auto la_time = zoned_time&lt;std::chrono::milliseconds&gt;(
                  locate_zone("America/Los_Angeles"),
                  ny_time);
std::cout &lt;&lt; la_time &lt;&lt; '\n'; // 2024-06-01 09:30:45.256 PDT
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-341">How it works…</h2>
<p class="normal">The system maintains a copy of the IANA Time Zone (TZ) database (which is available online at <a href="https://www.iana.org/time-zones">https://www.iana.org/time-zones</a>). As a user, you cannot create or alter the database but only retrieve a read-only copy of it with functions such as <code class="inlineCode">std::chrono::tzdb()</code> or <code class="inlineCode">std::chrono::get_tzdb_list()</code>. Information about a time zone is stored in a <code class="inlineCode">std::chrono::time_zone</code> object. Instances of this class cannot be created directly; they are only created by the library when initializing the time zone database. However, it is possible to obtain constant access to these instances, using two functions:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::chrono::current_zone()</code> retrieves the <code class="inlineCode">time_zone</code> object representing the local time zone.</li>
<li class="bulletList"><code class="inlineCode">std::chrono::locate_zone()</code>retrieves the <code class="inlineCode">time_zone</code> object representing the specified time zone.</li>
</ul>
<p class="normal">Examples of time zone names include Europe/Berlin, Asia/Dubai, and America/Los_Angeles. When the name of the location contains multiple words, spaces are replaced by an underscore (<code class="inlineCode">_</code>), such as in the preceding example where Los Angeles is written as Los_Angeles. </p>
<p class="normal">A list of all the time zones from the IANA TZ database can be found at <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a>.</p>
<p class="normal">There<a id="_idIndexMarker700"/> are two sets of types in the C++20 <code class="inlineCode">chrono</code> library to represent time points:</p>
<ul>
<li class="bulletList"><code class="inlineCode">sys_days</code> and <code class="inlineCode">sys_seconds</code> (having day and second precision) represent a time point in the system’s time zone, which is UTC. These are type aliases for <code class="inlineCode">std::chrono::sys_time</code>, which, in turn, is an alias for <code class="inlineCode">std::chrono::time_point</code>, which is using the <code class="inlineCode">std::chrono::system_clock</code>.</li>
<li class="bulletList"><code class="inlineCode">local_days</code> and <code class="inlineCode">local_seconds</code> (having also day and second precision) represent a time point with respect to a time zone that has not yet been specified. These are type aliases for <code class="inlineCode">std::chrono::local_time</code>, which is, in turn, a type alias for a <code class="inlineCode">std::chrono::time_point</code> using the <code class="inlineCode">std::chrono::local_t</code> pseudo-clock. The sole purpose of this clock is to indicate a not-yet-specified time zone.</li>
</ul>
<p class="normal">The <code class="inlineCode">std::chrono::zoned_time</code> class template represents a pairing of a time zone with a time point. It can be created from either a <code class="inlineCode">sys_time</code>, a <code class="inlineCode">local_time</code>, or another <code class="inlineCode">zoned_time</code> object. Examples of all these cases are shown here:</p>
<pre class="programlisting code"><code class="hljs-code">auto zst = zoned_time&lt;std::chrono::seconds&gt;(
  current_zone(),
  sys_days{ 2024y / May / 10 } +14h + 20min + 30s);
std::cout &lt;&lt; zst &lt;&lt; '\n'; // 2024-05-10 17:20:30 EEST (or GMT+3)
auto zlt = zoned_time&lt;std::chrono::seconds&gt;(
  current_zone(),
  local_days{ 2024y / May / 10 } +14h + 20min + 30s);
std::cout &lt;&lt; zlt &lt;&lt; '\n'; // 2024-05-10 14:20:30 EEST (or GMT+3)
auto zpt = zoned_time&lt;std::chrono::seconds&gt;(
  locate_zone("Europe/Paris"),
  zlt);
std::cout &lt;&lt; zpt &lt;&lt; '\n'; //2024-05-10 13:20:30 CEST (or GMT+2)
</code></pre>
<p class="normal">In this sample code, the times in the comments are based on the Romanian time zone. Notice that, in the first example, the time is expressed with <code class="inlineCode">sys_days</code>, which uses the UTC time zone. Since Romanian time is UTC+3 on 10 May 2024 (because of Daylight Saving Time), the local time is 17:20:30. In the second example, the time is specified with <code class="inlineCode">local_days</code>, which is time zone-agnostic. For this reason, when pairing with the current time <a id="_idIndexMarker701"/>zone, the time is actually 14:20:30. In the third and last example, the local Romanian time is converted to the time in Paris, which is 13:20:30 (because on that day, the time in Paris was UTC+2).</p>
<h2 class="heading-2" id="_idParaDest-342">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Expressing time intervals with chrono::duration</em>, to familiarize yourself with the fundamentals of the C++11 <code class="inlineCode">chrono</code> library and to work with durations, time points, and points</li>
<li class="bulletList"><em class="italic">Working with calendars</em>, to discover the C++20 additions to the <code class="inlineCode">chrono</code> library for working with dates and calendars</li>
</ul>
<h1 class="heading-1" id="_idParaDest-343">Measuring function execution time with a standard clock</h1>
<p class="normal">In the previous <a id="_idIndexMarker702"/>recipe, we saw how to work with time intervals using the <code class="inlineCode">chrono</code> standard library. However, we also often need to handle time points. The <code class="inlineCode">chrono</code> library provides such a component, representing a duration of time since the epoch of a clock (that is, the beginning of time as defined by a clock). In this recipe, we will learn how to use the <code class="inlineCode">chrono</code> library and time points to measure the execution of a function.</p>
<h2 class="heading-2" id="_idParaDest-344">Getting ready</h2>
<p class="normal">This recipe is tightly related to a preceding one, <em class="italic">Expressing time intervals with chrono::duration</em>. If you did not go through that recipe previously, you should do that before continuing with this one.</p>
<p class="normal">For the examples in this recipe, we will consider the following function, which does nothing but pause the execution of the current thread for a given interval:</p>
<pre class="programlisting code"><code class="hljs-code">void func(int const interval = 1000)
{
  std::this_thread::sleep_for(std::chrono::milliseconds(interval));
}
</code></pre>
<p class="normal">It should go without saying that this function is only meant for testing purposes and does nothing valuable. In practice, you will use the counting utility provided here to test your own functions.</p>
<h2 class="heading-2" id="_idParaDest-345">How to do it...</h2>
<p class="normal">To measure<a id="_idIndexMarker703"/> the execution of a function, you must perform the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Retrieve the current moment of time using a standard clock:
        <pre class="programlisting code"><code class="hljs-code">auto start = std::chrono::high_resolution_clock::now();
</code></pre>
</li>
<li class="numberedList">Call the function you want to measure:
        <pre class="programlisting code"><code class="hljs-code">func();
</code></pre>
</li>
<li class="numberedList">Retrieve the current moment of time again; the difference between the two is the execution time of the function:
        <pre class="programlisting code"><code class="hljs-code">auto diff = std::chrono::high_resolution_clock::now() - start;
</code></pre>
</li>
<li class="numberedList">Convert the difference (which is expressed in nanoseconds) to the actual resolution you are interested in:
        <pre class="programlisting code"><code class="hljs-code">std::cout
  &lt;&lt; std::chrono::duration&lt;double, std::milli&gt;(diff).count()
  &lt;&lt; "ms" &lt;&lt; '\n';
std::cout
  &lt;&lt; std::chrono::duration&lt;double, std::nano&gt;(diff).count()
  &lt;&lt; "ns" &lt;&lt; '\n';
</code></pre>
</li>
</ol>
<p class="normal">To implement this pattern in a reusable component, perform the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Create a class template parameterized with the resolution and the clock.</li>
<li class="numberedList">Create a static variadic function template that takes a function and its arguments.</li>
<li class="numberedList">Implement the pattern shown previously, invoking the function with its arguments.</li>
<li class="numberedList">Return a duration, not the number of ticks.</li>
</ol>
<p class="normal">This is exemplified in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename Time = std::chrono::microseconds,
          typename Clock = std::chrono::high_resolution_clock&gt;
struct perf_timer
{
  template &lt;typename F, typename... Args&gt;
  static Time duration(F&amp;&amp; f, Args... args)
  {
    auto start = Clock::now();
    std::invoke(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);
    auto end = Clock::now();
    return std::chrono::duration_cast&lt;Time&gt;(end - start);
  }
};
</code></pre>
<h2 class="heading-2" id="_idParaDest-346">How it works...</h2>
<p class="normal">A clock is a<a id="_idIndexMarker704"/> component that defines two things:</p>
<ul>
<li class="bulletList">A beginning of time called an <em class="italic">epoch</em>; there is no constraint regarding what the epoch is, but typical implementations use January 1, 1970.</li>
<li class="bulletList">A <em class="italic">tick rate</em> that defines the increment between two time points (such as a millisecond or nanosecond).</li>
</ul>
<p class="normal">A time point is a duration of time since the epoch of a clock. There are several time points that are of particular importance:</p>
<ul>
<li class="bulletList">The current time, returned by the clock’s static member <code class="inlineCode">now()</code>.</li>
<li class="bulletList">The epoch, or the beginning of time; this is the time point created by the default constructor of <code class="inlineCode">time_point</code> for a particular clock.</li>
<li class="bulletList">The minimum time that can be represented by a clock, returned by the static member <code class="inlineCode">min()</code> of <code class="inlineCode">time_point</code>.</li>
<li class="bulletList">The maximum time that can be represented with a clock, returned by the static member <code class="inlineCode">max()</code> of a <code class="inlineCode">time point</code>.</li>
</ul>
<p class="normal">The standard defines several clocks:</p>
<ul>
<li class="bulletList"><code class="inlineCode">system_clock</code>: This uses the real-time clock of the current system to represent time points.</li>
<li class="bulletList"><code class="inlineCode">high_resolution_clock</code>: This represents a clock that uses the shortest possible tick period on the current system.</li>
<li class="bulletList"><code class="inlineCode">steady_clock</code>: This indicates a clock that is never adjusted. This means that, unlike the other clocks, as time advances, the difference between two time points is always positive.</li>
<li class="bulletList"><code class="inlineCode">utc_clock</code>: This is a C++20 clock for Coordinated Universal Time.</li>
<li class="bulletList"><code class="inlineCode">tai_clock</code>: This is a C++20 clock for International Atomic Time.</li>
<li class="bulletList"><code class="inlineCode">gps_clock</code>: This is a C++20 clock for GPS time.</li>
<li class="bulletList"><code class="inlineCode">file_clock</code>: This is a C++20 clock used for expressing file times.</li>
</ul>
<p class="normal">The <a id="_idIndexMarker705"/>following example prints the precision of the first three clocks in this list (the ones available in C++11), regardless of whether it is steady (or monotone) or not:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
void print_clock()
{
  std::cout &lt;&lt; "precision: "
            &lt;&lt; (1000000.0 * double(T::period::num)) / 
               (T::period::den)
            &lt;&lt; '\n';
  std::cout &lt;&lt; "steady: " &lt;&lt; T::is_steady &lt;&lt; '\n';
}
print_clock&lt;std::chrono::system_clock&gt;();
print_clock&lt;std::chrono::high_resolution_clock&gt;();
print_clock&lt;std::chrono::steady_clock&gt;();
</code></pre>
<p class="normal">A possible output is the following:</p>
<pre class="programlisting con"><code class="hljs-con">precision: 0.1
steady: 0
precision: 0.001
steady: 1
precision: 0.001
steady: 1
</code></pre>
<p class="normal">This means that the <code class="inlineCode">system_clock</code> has a resolution of 0.1 microseconds and is not a monotone clock. On the other hand, the other two clocks, <code class="inlineCode">high_resolution_clock</code> and <code class="inlineCode">steady_clock</code>, both have a resolution of 1 nanosecond and are monotone clocks.</p>
<p class="normal">The steadiness of a clock is important when measuring the execution time of a function because, if the clock is adjusted while the function runs, the result will not yield the actual execution time, and values can even be negative. You should rely on a steady clock to measure the function execution time. The typical choice for that is the <code class="inlineCode">high_resolution_clock</code>, and that was the clock we used in the examples in the <em class="italic">How to do it...</em> section.</p>
<p class="normal">When we <a id="_idIndexMarker706"/>measure the execution time, we need to retrieve the current time before making the call and after the call returns. For that, we use the clock’s <code class="inlineCode">now()</code> static method. The result is a <code class="inlineCode">time_point</code>; when we subtract two time points, the result is a <code class="inlineCode">duration</code>, defined by the duration of the clock.</p>
<p class="normal">In order to create a reusable component that can be used to measure the execution time of any function, we have defined a class template called <code class="inlineCode">perf_timer</code>. This class template is parameterized with the resolution we are interested in (which, by default, is microseconds) and the clock we want to use (which, by default, is <code class="inlineCode">high_resolution_clock</code>). The class template has a single static member called <code class="inlineCode">duration()</code>—a variadic function template—that takes a function to execute and its variable number of arguments. The implementation is relatively simple: we retrieve the current time, invoke the function using <code class="inlineCode">std::invoke</code> (so that it handles the different mechanisms for invoking anything callable), and then retrieve the current time again. The return value is a <code class="inlineCode">duration</code> (with the defined resolution). The following snippet shows an example of this:</p>
<pre class="programlisting code"><code class="hljs-code">auto t = perf_timer&lt;&gt;::duration(func, 1500);
std::cout &lt;&lt; std::chrono::duration&lt;double, std::milli&gt;(t).count()
          &lt;&lt; "ms" &lt;&lt; '\n';
std::cout &lt;&lt; std::chrono::duration&lt;double, std::nano&gt;(t).count()
          &lt;&lt; "ns" &lt;&lt; '\n';
</code></pre>
<p class="normal">It is important to note that we are not returning a number of ticks from the <code class="inlineCode">duration()</code> function, but an actual <code class="inlineCode">duration</code> value. The reason is that by returning a number of ticks, we lose the resolution and won’t know what they actually represent. It is better to call <code class="inlineCode">count()</code> only when the actual count of ticks is necessary. This is exemplified here:</p>
<pre class="programlisting code"><code class="hljs-code">auto t1 = perf_timer&lt;std::chrono::nanoseconds&gt;::duration(func, 150);
auto t2 = perf_timer&lt;std::chrono::microseconds&gt;::duration(func, 150);
auto t3 = perf_timer&lt;std::chrono::milliseconds&gt;::duration(func, 150);
std::cout
  &lt;&lt; std::chrono::duration&lt;double, std::micro&gt;(t1 + t2 + t3).count()
  &lt;&lt; "us" &lt;&lt; '\n';
</code></pre>
<p class="normal">In this <a id="_idIndexMarker707"/>example, we measure the execution of three different functions, using three different resolutions (nanoseconds, microseconds, and milliseconds). The values <code class="inlineCode">t1</code>, <code class="inlineCode">t2</code>, and <code class="inlineCode">t3</code> represent durations. These make it possible to easily add them together and convert the result to microseconds.</p>
<h2 class="heading-2" id="_idParaDest-347">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Expressing time intervals with chrono::duration</em>, to familiarize yourself with the fundamentals of the C++11 <code class="inlineCode">chrono</code> library and how to work with durations, time points, and points</li>
<li class="bulletList"><em class="chapterRef">Chapter 3</em>, <em class="italic">Uniformly invoking anything callable</em>, to learn how to use <code class="inlineCode">std::invoke()</code> to call functions and any callable object</li>
</ul>
<h1 class="heading-1" id="_idParaDest-348">Generating hash values for custom types</h1>
<p class="normal">The <a id="_idIndexMarker708"/>standard library provides several unordered associative containers: <code class="inlineCode">std::unordered_set</code>, <code class="inlineCode">std::unordered_multiset</code>, <code class="inlineCode">std::unordered_map</code>, and <code class="inlineCode">std::unordered_map</code>. These containers do not store their elements in a particular order; instead, they are grouped in buckets. The bucket an element belongs to depends on the hash value of the element. These standard containers use, by default, the <code class="inlineCode">std::hash</code> class template to compute the hash value. The specialization for all basic types and also some library types is available. However, for custom types, you must specialize the class template yourself. This recipe will show you how to do that and also explain how a good hash value can be computed. A good hash value can be computed fast and is uniformly dispersed across the value domain, therefore minimizing the chances of duplicate values (collisions) existing.</p>
<h2 class="heading-2" id="_idParaDest-349">Getting ready</h2>
<p class="normal">For the examples in this recipe, we will use the following class:</p>
<pre class="programlisting code"><code class="hljs-code">struct Item
{
  int         id;
  std::string name;
  double      value;
  Item(int const id, std::string const &amp; name, double const value)
    :id(id), name(name), value(value)
  {}
  bool operator==(Item const &amp; other) const
  {
    return id == other.id &amp;&amp; name == other.name &amp;&amp;
           value == other.value;
  }
};
</code></pre>
<p class="normal">This<a id="_idIndexMarker709"/> recipe covers hashing functionalities from the standard library. You should be familiar with the concepts of hashes and hash functions.</p>
<h2 class="heading-2" id="_idParaDest-350">How to do it...</h2>
<p class="normal">In order to use your custom types with the unordered associative containers, you must perform the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Specialize the <code class="inlineCode">std::hash</code> class template for your custom type; the specialization must be done in the <code class="inlineCode">std</code> namespace.</li>
<li class="numberedList">Define synonyms for the argument and result type.</li>
<li class="numberedList">Implement the call operator so that it takes a constant reference to your type and returns a hash value.</li>
</ol>
<p class="normal">To compute a good hash value, you should do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Start with an initial value, which should be a prime number (for example, 17).</li>
<li class="numberedList">For each field that is used to determine whether two instances of the class are equal, adjust the hash value according to the following formula:
        <pre class="programlisting code"><code class="hljs-code">hashValue = hashValue * prime + hashFunc(field);
</code></pre>
</li>
<li class="numberedList">You can use the same prime number for all fields with the preceding formula, but it is recommended to have a different value than the initial value (for instance, 31).</li>
<li class="numberedList">Use a specialization of <code class="inlineCode">std::hash</code> to determine the hash value for class data members.</li>
</ol>
<p class="normal">Based on <a id="_idIndexMarker710"/>the steps described here, the <code class="inlineCode">std::hash</code> specialization for the <code class="inlineCode">Item</code> class looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">namespace std
{
  template&lt;&gt;
  struct hash&lt;Item&gt;
  {
    typedef Item argument_type;
    typedef size_t result_type;
    result_type operator()(argument_type const &amp; item) const
 {
      result_type hashValue = 17;
      hashValue = 31 * hashValue + std::hash&lt;int&gt;{}(item.id);
      hashValue = 31 * hashValue + std::hash&lt;std::string&gt;{}(item.name);
      hashValue = 31 * hashValue + std::hash&lt;double&gt;{}(item.value);
      return hashValue;
    }
  };
}
</code></pre>
<p class="normal">This specialization makes it possible to use the <code class="inlineCode">Item</code> class with unordered associative containers, such as <code class="inlineCode">std::unordered_set</code>. An example is provided here:</p>
<pre class="programlisting code"><code class="hljs-code">std::unordered_set&lt;Item&gt; set2
{
  { 1, "one"s, 1.0 },
  { 2, "two"s, 2.0 },
  { 3, "three"s, 3.0 },
};
</code></pre>
<h2 class="heading-2" id="_idParaDest-351">How it works...</h2>
<p class="normal">The class template <code class="inlineCode">std::hash</code> is a function object template whose call operator defines a hash function with the following properties:</p>
<ul>
<li class="bulletList">Takes an argument of the template parameter type and returns a <code class="inlineCode">size_t</code> value.</li>
<li class="bulletList">Does not throw any exceptions.</li>
<li class="bulletList">For two arguments that are equal, it returns the same hash value.</li>
<li class="bulletList">For two arguments that are not equal, the probability of returning the same value is very small (should be close to <code class="inlineCode">1.0/std::numeric_limits&lt;size_t&gt;::max()</code>).</li>
</ul>
<p class="normal">The <a id="_idIndexMarker711"/>standard provides specialization for all basic types, such as <code class="inlineCode">bool</code>, <code class="inlineCode">char</code>, <code class="inlineCode">int</code>, <code class="inlineCode">long</code>, <code class="inlineCode">float</code>, <code class="inlineCode">double</code> (along with all the possible <code class="inlineCode">unsigned</code> and <code class="inlineCode">long</code> variations), and the pointer type, but also library types including the <code class="inlineCode">basic_string</code> and <code class="inlineCode">basic_string_view</code> types, <code class="inlineCode">unique_ptr</code> and <code class="inlineCode">shared_ptr</code>, <code class="inlineCode">bitset</code> and <code class="inlineCode">vector&lt;bool&gt;</code>, <code class="inlineCode">optional</code> and <code class="inlineCode">variant</code> (in C++17), and several other types. However, for custom types, you have to provide your own specialization. This specialization must be in the namespace <code class="inlineCode">std</code> (because that is the namespace where the class template <code class="inlineCode">hash</code> is defined) and must meet the requirements enumerated earlier.</p>
<p class="normal">The standard does not specify how hash values should be computed. You can use any function you want as long as it returns the same value for equal objects, and also has a very small chance of returning the same value for non-equal objects. The algorithm described in this recipe was presented in the book <em class="italic">Effective Java, Second Edition</em> by Joshua Bloch.</p>
<p class="normal">When computing the hash value, consider only the fields that participate in determining whether two instances of the class are equal (in other words, fields that are used in <code class="inlineCode">operator==</code>). However, you must use all these fields that are used with <code class="inlineCode">operator==</code>. In our example, all three fields of the <code class="inlineCode">Item</code> class are used to determine the equality of two objects; therefore, we must use them all to compute the hash. The initial hash value should be nonzero, and in our example, we picked the prime number 17. </p>
<p class="normal">The important thing is that these values should not be zero; otherwise, the initial fields (that is, the first in the order of processing) that produce the hash value zero will not alter the hash (which remains zero since <code class="inlineCode">x * 0 + 0 = 0</code>). For every field used to compute the hash, we alter the current hash by multiplying its previous value with a prime number and adding the hash of the current field. For this purpose, we use specializations of the class template <code class="inlineCode">std::hash</code>. </p>
<p class="normal">The use of the prime number 31 is advantageous for performance optimizations because <code class="inlineCode">31 * x</code> can be replaced by the compiler with <code class="inlineCode">(x &lt;&lt; 5) - x</code>, which is faster. Similarly, you can use 127 because <code class="inlineCode">127 * x</code> is equal to <code class="inlineCode">(x &lt;&lt; 7) - x</code> or 8191, because <code class="inlineCode">8191 * x</code> is equal to <code class="inlineCode">(x &lt;&lt; 13) - x</code>.</p>
<p class="normal">If your custom type contains an array and is used to determine the equality of two objects and, therefore, needs to be used to compute the hash, then treat the array as if its elements <a id="_idIndexMarker712"/>were data members of the class. In other words, apply the same algorithm described earlier to all elements of the array.</p>
<h2 class="heading-2" id="_idParaDest-352">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 2</em>, <em class="italic">Limits and other properties of numeric types</em>, to learn about the minimum and maximum values, as well as the other properties of numerical types</li>
</ul>
<h1 class="heading-1" id="_idParaDest-353">Using std::any to store any value</h1>
<p class="normal">C++ does not<a id="_idIndexMarker713"/> have a hierarchical type system like other languages (such as C# or Java) and, therefore, it can’t store multiple types of a value in a single variable like it is possible to with the type <code class="inlineCode">Object</code> in .NET and Java or natively in JavaScript. Developers have long used <code class="inlineCode">void*</code> for that purpose, but this only helps us store pointers to anything and is not type-safe. Depending on the end goal, alternatives can include templates or overloaded functions. However, C++17 has introduced a standard type-safe container, called <code class="inlineCode">std::any</code>, that can hold a single value of any type.</p>
<h2 class="heading-2" id="_idParaDest-354">Getting ready</h2>
<p class="normal"><code class="inlineCode">std::any</code> has been designed based on <code class="inlineCode">boost::any</code> and is available in the <code class="inlineCode">&lt;any&gt;</code> header. If you are familiar with <code class="inlineCode">boost::any</code> and have used it in your code, you can migrate it seamlessly to <code class="inlineCode">std::any</code>.</p>
<h2 class="heading-2" id="_idParaDest-355">How to do it...</h2>
<p class="normal">Use the following operations to work with <code class="inlineCode">std::any</code>:</p>
<ul>
<li class="bulletList">To store values, use the constructor or assign them directly to a <code class="inlineCode">std::any</code> variable:
        <pre class="programlisting code"><code class="hljs-code">std::any value(42); // integer 42
value = 42.0;       // double 42.0
value = "42"s;      // std::string "42"
</code></pre>
</li>
<li class="bulletList">To read values, use the non-member function <code class="inlineCode">std::any_cast()</code>:
        <pre class="programlisting code"><code class="hljs-code">std::any value = 42.0;
try
{
  auto d = std::any_cast&lt;double&gt;(value);
  std::cout &lt;&lt; d &lt;&lt; '\n'; // prints 42
}
catch (std::bad_any_cast const &amp; e)
{
  std::cout &lt;&lt; e.what() &lt;&lt; '\n';
}
</code></pre>
</li>
<li class="bulletList">To <a id="_idIndexMarker714"/>check the type of the stored value, use the member function <code class="inlineCode">type()</code>:
        <pre class="programlisting code"><code class="hljs-code">inline bool is_integer(std::any const &amp; a)
{
  return a.type() == typeid(int);
}
</code></pre>
</li>
<li class="bulletList">To check whether the container stores a value, use the <code class="inlineCode">has_value()</code> member function:
        <pre class="programlisting code"><code class="hljs-code">auto ltest = [](std::any const &amp; a) {
  if (a.has_value())
    std::cout &lt;&lt; "has value" &lt;&lt; '\n';
  else
    std::cout &lt;&lt; "no value" &lt;&lt; '\n';
};
std::any value;
ltest(value); // no value
value = 42;
ltest(value); // has value
</code></pre>
</li>
<li class="bulletList">To modify the stored value, use the member functions <code class="inlineCode">emplace()</code>, <code class="inlineCode">reset()</code>, or <code class="inlineCode">swap()</code>:
        <pre class="programlisting code"><code class="hljs-code">std::any value = 42;
ltest(value); // has value
value.reset();
ltest(value); // no value
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-356">How it works...</h2>
<p class="normal"><code class="inlineCode">std::any</code> is a <a id="_idIndexMarker715"/>type-safe container that can hold values of any type that is (or rather, whose decayed type is) copy constructible. Storing values in the container is very simple—you can either use one of the available constructors (the default constructor creates a container that stores no value) or the assignment operator. However, reading values is not directly possible, and you need to use the non-member function <code class="inlineCode">std::any_cast()</code>, which casts the stored value to the specified type. This function throws <code class="inlineCode">std::bad_any_cast</code> if the stored value has a different type than the one you are casting to. Casting between implicitly convertible types, such as <code class="inlineCode">int</code> and <code class="inlineCode">long</code>, is not possible either. <code class="inlineCode">std::bad_any_cast</code> is derived from <code class="inlineCode">std::bad_cast</code>; therefore, you can catch any of these two exception types.</p>
<p class="normal">It is possible to check the type of the stored value using the <code class="inlineCode">type()</code> member function, which returns a <code class="inlineCode">type_info</code> constant reference. If the container is empty, this function returns <code class="inlineCode">typeid(void)</code>. To check whether the container stores a value, you can use the member function <code class="inlineCode">has_value()</code>, which returns <code class="inlineCode">true</code> if there is a value or <code class="inlineCode">false</code> if the container is empty.</p>
<p class="normal">The following example shows how to check whether the container has any value, how to check the type of the stored value, and how to read the value from the container:</p>
<pre class="programlisting code"><code class="hljs-code">void log(std::any const &amp; value)
{
  if (value.has_value())
  {
    auto const &amp; tv = value.type();
    if (tv == typeid(int))
    {
      std::cout &lt;&lt; std::any_cast&lt;int&gt;(value) &lt;&lt; '\n';
    }
    else if (tv == typeid(std::string))
    {
      std::cout &lt;&lt; std::any_cast&lt;std::string&gt;(value) &lt;&lt; '\n';
    }
    else if (tv == typeid(
      std::chrono::time_point&lt;std::chrono::system_clock&gt;))
    {
      auto t = std::any_cast&lt;std::chrono::time_point&lt;
        std::chrono::system_clock&gt;&gt;(value);
      auto now = std::chrono::system_clock::to_time_t(t);
      std::cout &lt;&lt; std::put_time(std::localtime(&amp;now), "%F %T")
                &lt;&lt; '\n';
    }
    else
    {
      std::cout &lt;&lt; "unexpected value type" &lt;&lt; '\n';
    }
  }
  else
  {
    std::cout &lt;&lt; "(empty)" &lt;&lt; '\n';
  }
}
log(std::any{});                       // (empty)
log(42);                               // 42
log("42"s);                            // 42
log(42.0);                             // unexpected value type
log(std::chrono::system_clock::now()); // 2016-10-30 22:42:57
</code></pre>
<p class="normal">If you <a id="_idIndexMarker716"/>want to store multiple values of any type, use a standard container such as <code class="inlineCode">std::vector</code> to hold values of the type <code class="inlineCode">std::any</code>. An example is presented here:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;std::any&gt; values;
values.push_back(std::any{});
values.push_back(42);
values.push_back("42"s);
values.push_back(42.0);
values.push_back(std::chrono::system_clock::now());
for (auto const &amp; v : values)
  log(v);
</code>
values</code> contains elements of the <code class="inlineCode">std::any</code> type, which, in turn, contains an <code class="inlineCode">int</code>, <code class="inlineCode">std::string</code>, <code class="inlineCode">double</code>, and <code class="inlineCode">std::chrono::time_point</code> value.</pre>
<h2 class="heading-2" id="_idParaDest-357">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using std::optional to store optional values</em>, to learn about the C++17 class template <code class="inlineCode">std::optional</code>, which manages a value that may or may not exist</li>
<li class="bulletList"><em class="italic">Using std::variant as a type-safe union</em>, to learn how to use the C++17 <code class="inlineCode">std::variant</code> class to represent type-safe unions</li>
</ul>
<h1 class="heading-1" id="_idParaDest-358">Using std::optional to store optional values</h1>
<p class="normal">Sometimes, it is<a id="_idIndexMarker717"/> useful to be able to store either a value or a null pointer if a specific value is not available. A typical example of such a case is the return value of a function that may fail to produce a return value, but this failure is not an error. For instance, think of a function that finds and returns values from a dictionary by specifying a key. Not finding a value is a probable case and, therefore, the function would either return a Boolean (or an integer value, if more error codes are necessary) and have a reference argument to hold the return value or return a pointer (raw or smart pointer). In C++17, <code class="inlineCode">std::optional</code> is a better alternative to these solutions. The class template <code class="inlineCode">std::optional</code> is a template container for storing a value that may or may not exist. In this recipe, we will see how to use this container and its typical use cases.</p>
<h2 class="heading-2" id="_idParaDest-359">Getting ready</h2>
<p class="normal">The class template <code class="inlineCode">std::optional&lt;T&gt;</code> was designed based on <code class="inlineCode">boost::optional</code> and is available in the <code class="inlineCode">&lt;optional&gt;</code> header. If you are familiar with <code class="inlineCode">boost::optional</code> and have used it in your code, you can migrate it seamlessly to <code class="inlineCode">std::optional</code>.</p>
<p class="normal">In the following snippets, we will refer to the following <code class="inlineCode">foo</code> class:</p>
<pre class="programlisting code"><code class="hljs-code">struct foo
{
  int    a;
  double b;
};
</code></pre>
<h2 class="heading-2" id="_idParaDest-360">How to do it...</h2>
<p class="normal">Use the following operations to work with <code class="inlineCode">std::optional</code>:</p>
<ul>
<li class="bulletList">To store a value, use the constructor or assign the value directly to a <code class="inlineCode">std::optional</code> object:
        <pre class="programlisting code"><code class="hljs-code">std::optional&lt;int&gt; v1;      // v1 is empty
std::optional&lt;int&gt; v2(42);  // v2 contains 42
v1 = 42;                    // v1 contains 42
std::optional&lt;int&gt; v3 = v2; // v3 contains 42
</code></pre>
</li>
<li class="bulletList">To read the stored value, use <code class="inlineCode">operator*</code> or <code class="inlineCode">operator-&gt;</code>:
        <pre class="programlisting code"><code class="hljs-code">std::optional&lt;int&gt; v1{ 42 };
std::cout &lt;&lt; *v1 &lt;&lt; '\n';   // 42
std::optional&lt;foo&gt; v2{ foo{ 42, 10.5 } };
std::cout &lt;&lt; v2-&gt;a &lt;&lt; ", "
          &lt;&lt; v2-&gt;b &lt;&lt; '\n'; // 42, 10.5
</code></pre>
</li>
<li class="bulletList">Alternatively, use the member functions <code class="inlineCode">value()</code> and <code class="inlineCode">value_or()</code> to read the stored value:
        <pre class="programlisting code"><code class="hljs-code">std::optional&lt;std::string&gt; v1{ "text"s };
std::cout &lt;&lt; v1.value() &lt;&lt; '\n'; // text
std::optional&lt;std::string&gt; v2;
std::cout &lt;&lt; v2.value_or("default"s) &lt;&lt; '\n'; // default
</code></pre>
</li>
<li class="bulletList">To <a id="_idIndexMarker718"/>check whether the container stores a value, use a conversion operator to <code class="inlineCode">bool</code> or the member function <code class="inlineCode">has_value()</code>:
        <pre class="programlisting code"><code class="hljs-code">std::optional&lt;int&gt; v1{ 42 };
if (v1) std::cout &lt;&lt; *v1 &lt;&lt; '\n';
std::optional&lt;foo&gt; v2{ foo{ 42, 10.5 } };
if (v2.has_value())
  std::cout &lt;&lt; v2-&gt;a &lt;&lt; ", " &lt;&lt; v2-&gt;b &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To modify the stored value, use the member functions <code class="inlineCode">emplace()</code>, <code class="inlineCode">reset()</code>, or <code class="inlineCode">swap()</code>:
        <pre class="programlisting code"><code class="hljs-code">std::optional&lt;int&gt; v{ 42 }; // v contains 42
v.reset();                  // v is empty
</code></pre>
</li>
</ul>
<p class="normal">Use <code class="inlineCode">std::optional</code> to model any of the following:</p>
<ul>
<li class="bulletList">Return values from functions that may fail to produce a value:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename K, typename V&gt;
std::optional&lt;V&gt; find(K const key,
                      std::map&lt;K, V&gt; const &amp; m)
{
  auto pos = m.find(key);
  if (pos != m.end())
    return pos-&gt;second;
  return {};
}
std::map&lt;int, std::string&gt; m{
  { 1, "one"s },{ 2, "two"s },{ 3, "three"s } };
auto value = find(2, m);
if (value) std::cout &lt;&lt; *value &lt;&lt; '\n'; // two
value = find(4, m);
if (value) std::cout &lt;&lt; *value &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Parameters<a id="_idIndexMarker719"/> to functions that are optional:
        <pre class="programlisting code"><code class="hljs-code">std::string extract(std::string const &amp; text,
                    std::optional&lt;int&gt; start,
                    std::optional&lt;int&gt; end)
{
  auto s = start.value_or(0);
  auto e = end.value_or(text.length());
  return text.substr(s, e - s);
}
auto v1 = extract("sample"s, {}, {});
std::cout &lt;&lt; v1 &lt;&lt; '\n'; // sample
auto v2 = extract("sample"s, 1, {});
std::cout &lt;&lt; v2 &lt;&lt; '\n'; // ample
auto v3 = extract("sample"s, 1, 4);
std::cout &lt;&lt; v3 &lt;&lt; '\n'; // amp
</code></pre>
</li>
<li class="bulletList">Class data members that are optional:
        <pre class="programlisting code"><code class="hljs-code">struct book
{
  std::string                title;
  std::optional&lt;std::string&gt; subtitle;
  std::vector&lt;std::string&gt;   authors;
  std::string                publisher;
  std::string                isbn;
  std::optional&lt;int&gt;         pages;
  std::optional&lt;int&gt;         year;
};
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-361">How it works...</h2>
<p class="normal">The class<a id="_idIndexMarker720"/> template <code class="inlineCode">std::optional</code> is a class template that represents a container for an optional value. If the container does have a value, that value is stored as part of the <code class="inlineCode">optional</code> object; no heap allocations and pointers are involved. The <code class="inlineCode">std::optional</code> class template is conceptually implemented like this:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
class optional
{
  bool _initialized;
  std::aligned_storage_t&lt;sizeof(t), alignof(T)&gt; _storage;
};
</code></pre>
<p class="normal">The <code class="inlineCode">std::aligned_storage_t</code> alias template allows us to create uninitialized chunks of memory that can hold objects of a given type. The class template <code class="inlineCode">std::optional</code> does not contain a value if it was default constructed, or if it was copy constructed or copy assigned from another empty optional object or from a <code class="inlineCode">std::nullopt_t</code> value. Such a value is <code class="inlineCode">std::nullopt</code>, a <code class="inlineCode">constexpr</code> value used to indicate an optional object with an uninitialized state. This is a helper type, implemented as an empty class, that indicates an optional object with an uninitialized state.</p>
<p class="normal">The typical use for an <code class="inlineCode">optional</code> type (called <em class="italic">nullable</em> in other programming languages) is the return type from a function that may fail. Possible solutions for this situation include the following:</p>
<ul>
<li class="bulletList">Return a <code class="inlineCode">std::pair&lt;T, bool&gt;</code>, where <code class="inlineCode">T</code> is the type of the return value; the second element of the pair is a Boolean flag that indicates whether the value of the first element is valid or not.</li>
<li class="bulletList">Return a <code class="inlineCode">bool</code>, take an extra parameter of the type <code class="inlineCode">T&amp;</code>, and assign a value to this parameter only if the function succeeds.</li>
<li class="bulletList">Return a raw or smart pointer type, and use <code class="inlineCode">nullptr</code> to indicate a failure.</li>
</ul>
<p class="normal">The class template <code class="inlineCode">std::optional</code> is a better approach because, on the one hand, it does not involve output parameters to the function (which, outside of C and C++, is not the canonical form for returning values) and does not require working with pointers, and on the other hand, it better encapsulates the details of a <code class="inlineCode">std::pair&lt;T, bool&gt;</code>. </p>
<p class="normal">However, optional objects can also be used for class data members, and compilers are able to optimize the memory layout for efficient storage.</p>
<div><p class="normal">The class template <code class="inlineCode">std::optional</code> cannot be used to return polymorphic types. If you write, for instance, a factory method that needs to return different types from a hierarchy of types, you cannot rely on <code class="inlineCode">std::optional</code> and need to return a pointer, preferably a <code class="inlineCode">std::unique_ptr</code> or <code class="inlineCode">std::shared_ptr</code> (depending on whether ownership of the object needs to be shared or not).</p>
</div>
<p class="normal">When you<a id="_idIndexMarker721"/> use <code class="inlineCode">std::optional</code> to pass optional arguments to a function, you need to understand that it may incur creating copies, which can be a performance issue if large objects are involved. Let’s consider the following example of a function that has a constant reference to the <code class="inlineCode">std::optional</code> parameter:</p>
<pre class="programlisting code"><code class="hljs-code">struct bar { /* details */ };
void process(std::optional&lt;bar&gt; const &amp; arg)
{
  /* do something with arg */
}
std::optional&lt;bar&gt; b1{ bar{} };
bar b2{};
process(b1); // no copy
process(b2); // copy construction
</code></pre>
<p class="normal">The first call to <code class="inlineCode">process()</code> does not involve any additional object construction because we pass a <code class="inlineCode">std::optional&lt;bar&gt;</code> object. The second call, however, will involve the copy construction of a <code class="inlineCode">bar</code> object, because <code class="inlineCode">b2</code> is a <code class="inlineCode">bar</code> and needs to be copied to a <code class="inlineCode">std::optional&lt;bar&gt;</code>; a copy is made even if <code class="inlineCode">bar</code> has move semantics implemented. If <code class="inlineCode">bar</code> is a small object, this shouldn’t be of great concern, but for large objects, it can prove to be a performance issue. The solution to avoid this depends on the context and can involve creating a second overload that takes a constant reference to <code class="inlineCode">bar</code>, or entirely avoiding using <code class="inlineCode">std::optional</code>.</p>
<h2 class="heading-2" id="_idParaDest-362">There’s more…</h2>
<p class="normal">Although <code class="inlineCode">std::optional</code> makes it easier to return a value from a function that may also fail, chaining together multiple such functions produces code that can be cumbersome or at least too repetitive. To ease this scenario, in C++23, <code class="inlineCode">std::optional</code> has several additional members (<code class="inlineCode">transform()</code>, <code class="inlineCode">and_then()</code>, and <code class="inlineCode">or_else()</code>) called monadic operations. We will learn about these in the next recipe.</p>
<h2 class="heading-2" id="_idParaDest-363">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using std::any to store any value</em>, to learn how to use the C++17 class <code class="inlineCode">std::any</code>, which represents a type-safe container for single values of any type</li>
<li class="bulletList"><em class="italic">Using std::variant as a type-safe union</em>, to learn how to use the C++17 <code class="inlineCode">std::variant</code> class to represent type-safe unions</li>
<li class="bulletList"><em class="italic">Chaining together computations that may or may not produce a value</em>, to see how the new C++23 monadic operations of <code class="inlineCode">std::optional</code> simplify scenarios where multiple functions returning <code class="inlineCode">std::optional</code> are called sequentially</li>
</ul>
<h1 class="heading-1" id="_idParaDest-364">Chaining together computations that may or may not produce a value</h1>
<p class="normal">In the <a id="_idIndexMarker722"/>previous recipe, we have seen how to use the <code class="inlineCode">std::optional</code> class for storing a value that may or may not exist. Its use cases include optional parameters to functions and return values from functions that may fail to produce a result. When multiple such functions need to be chained together, the code can become cumbersome and verbose. For this reason, the C++23 standard has added several new methods to the <code class="inlineCode">std::optional</code> class. They are referred to by the term <strong class="keyWord">monadic operations</strong>. These methods are <code class="inlineCode">transform()</code>, <code class="inlineCode">and_then()</code>, and <code class="inlineCode">or_else()</code>. In this recipe, we’ll see what they are useful for.</p>
<div><p class="normal">In simple terms, in functional programming, a <strong class="keyWord">monad</strong> is a container that encapsulates some functionality on top of a value that it wraps. Such an example is <code class="inlineCode">std::optional</code> in C++. On the other hand, a <strong class="keyWord">monadic operation</strong> is a function from a domain <em class="italic">D</em> into <em class="italic">D</em> itself. For instance, the <strong class="keyWord">identity function</strong> (a function that returns its argument) is a monadic operation. The newly added functions <code class="inlineCode">transform()</code>, <code class="inlineCode">and_then()</code>, and <code class="inlineCode">or_else()</code> are monadic because they take a <code class="inlineCode">std::optional</code> and return a <code class="inlineCode">std::optional</code>.</p>
</div>
<h2 class="heading-2" id="_idParaDest-365">Getting ready</h2>
<p class="normal">In the<a id="_idIndexMarker723"/> following sections, we will refer to the definitions shown here:</p>
<pre class="programlisting code"><code class="hljs-code">struct booking
{
   int                        id;
   int                        nights;
   double                     rate;
   std::string                description;
   std::vector&lt;std::string&gt;   extras;
};
std::optional&lt;booking&gt; make_booking(std::string_view description, 
 int nights, double rate);
std::optional&lt;booking&gt; add_rental(std::optional&lt;booking&gt; b);
std::optional&lt;booking&gt; add_insurance(std::optional&lt;booking&gt; b);
double calculate_price(std::optional&lt;booking&gt; b);
double apply_discount(std::optional&lt;double&gt; p);
</code></pre>
<h2 class="heading-2" id="_idParaDest-366">How to do it…</h2>
<p class="normal">You can use the following monadic operations as per your use case:</p>
<ul>
<li class="bulletList">If you have an <code class="inlineCode">optional</code> value and want to apply a function <code class="inlineCode">f</code> and return the value of that invocation, then use <code class="inlineCode">transform()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto b = make_booking("Hotel California", 3, 300);
auto p = b.transform(calculate_price);
</code></pre>
</li>
<li class="bulletList">If you have an <code class="inlineCode">optional</code> value and want to apply a function <code class="inlineCode">f</code> that returns an <code class="inlineCode">optional</code> and then return the value of that invocation, then use <code class="inlineCode">and_then()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto b = make_booking("Hotel California", 3, 300);
     b = b.and_then(add_insurance);
auto p = b.transform(calculate_price);
</code></pre>
</li>
<li class="bulletList">If you have an <code class="inlineCode">optional</code> value that could be empty, in which case you want to invoke a function to handle the situation (such as to log or throw an exception) and return another <code class="inlineCode">optional</code> (either an alternative value or an empty <code class="inlineCode">optional</code>), then use <code class="inlineCode">or_else()</code>:
        <pre class="programlisting code"><code class="hljs-code">auto b = make_booking("Hotel California", 3, 300)
         .or_else([]() -&gt; std::optional&lt;booking&gt; {
            std::cout &lt;&lt; "creating the booking failed!\n";  
            return std::nullopt; 
         });
</code></pre>
</li>
</ul>
<p class="normal">A larger<a id="_idIndexMarker724"/> example is shown in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">auto p =
    make_booking("Hotel California", 3, 300)
   .and_then(add_rental)
   .and_then(add_insurance)
   .or_else([]() -&gt; std::optional&lt;booking&gt; {
      std::cout &lt;&lt; "creating the booking failed!\n";  
      return std::nullopt; })
   .transform(calculate_price)
   .transform(apply_discount)
   .or_else([]() -&gt; std::optional&lt;double&gt; {
      std::cout &lt;&lt; "computing price failed!\n"; return -1; });
</code></pre>
<h2 class="heading-2" id="_idParaDest-367">How it works…</h2>
<p class="normal">The <code class="inlineCode">and_then()</code> and <code class="inlineCode">transform()</code> member functions are very similar. They actually have the same number of overloads with the same signature. They take a single argument that is a function or callable object and they both return an <code class="inlineCode">optional</code>. If the <code class="inlineCode">optional</code> does not hold a value, then both <code class="inlineCode">and_then()</code> and <code class="inlineCode">transform()</code> return an empty <code class="inlineCode">optional</code>. </p>
<p class="normal">Otherwise, if the <code class="inlineCode">optional</code> does hold a value, then it invokes the function or callable with the stored value. Here is where they differ:</p>
<ul>
<li class="bulletList">The function/callable passed to <code class="inlineCode">and_then()</code> must itself return a value of a type that is a specialization of <code class="inlineCode">std::optional</code>. This will be the value returned by <code class="inlineCode">and_then()</code>.</li>
<li class="bulletList">The function/callable passed to <code class="inlineCode">transform()</code> may have any return type that is not a reference type. However, the value it returns will itself be wrapped in a <code class="inlineCode">std::optional</code> before being returned from <code class="inlineCode">transform()</code>.</li>
</ul>
<p class="normal">To exemplify this better, let’s consider the following function again:</p>
<pre class="programlisting code"><code class="hljs-code">double calculate_price(std::optional&lt;booking&gt; b);
</code></pre>
<p class="normal">Previously, we have seen this snippet:</p>
<pre class="programlisting code"><code class="hljs-code">auto b = make_booking("Hotel California", 3, 300);
auto p = b.transform(calculate_price);
</code></pre>
<p class="normal">Here, <code class="inlineCode">p</code> has<a id="_idIndexMarker725"/> the type <code class="inlineCode">std::optional&lt;double&gt;</code>. This is because <code class="inlineCode">calculate_price()</code> returns a <code class="inlineCode">double</code>, and, therefore, <code class="inlineCode">transform()</code> will return a <code class="inlineCode">std::optional&lt;double&gt;</code>. Let’s change the signature of <code class="inlineCode">calculate_price()</code> to return a <code class="inlineCode">std::optional&lt;double&gt;</code> instead:</p>
<pre class="programlisting code"><code class="hljs-code">std::optional&lt;double&gt; calculate_price(std::optional&lt;booking&gt; b);
</code></pre>
<p class="normal">The variable <code class="inlineCode">p</code> will now have the type <code class="inlineCode">std::optional&lt;std::optional&lt;double&gt;&gt;</code>.</p>
<p class="normal">The third monadic function, <code class="inlineCode">or_else()</code>, is the opposite of <code class="inlineCode">and_then()</code>/<code class="inlineCode">transform()</code>: if the <code class="inlineCode">optional</code> object contains a value, it returns the <code class="inlineCode">optional</code> without doing anything. Otherwise, it invokes its single argument, which is a function or callable without any argument, and returns the value from this invocation. The return type of the function/callable must be <code class="inlineCode">std::optional&lt;T&gt;</code>.</p>
<p class="normal">The <code class="inlineCode">or_else()</code> function is typically used for handling erroneous situations when an expected value is missing. The supplied function could perhaps add an entry to a log, throw an exception, or do something else. Unless this callable throws an exception, it must return a value. This can be an empty <code class="inlineCode">optional</code> or an <code class="inlineCode">optional</code> holding a default value or some alternative to the missing value.</p>
<h2 class="heading-2" id="_idParaDest-368">There’s more…</h2>
<p class="normal">One of the most important use cases for <code class="inlineCode">std::optional</code> is to return a value from a function that may or may not produce one. However, when a value is missing, we probably need to know the reason for the failure. This is not directly possible with optional, unless the stored type is a compound of a value and an error, or if we use additional parameters to the function to retrieve the error. For this reason, the C++23 standard includes an alternative for these use cases for <code class="inlineCode">std::optional</code>, the <code class="inlineCode">std::expected</code> type.</p>
<h2 class="heading-2" id="_idParaDest-369">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using std::expected to return a value or an error</em>, to see how this C++23 type allows us to return a value or an error code from a function</li>
</ul>
<h1 class="heading-1" id="_idParaDest-370">Using std::variant as a type-safe union</h1>
<p class="normal">In C++, a<a id="_idIndexMarker726"/> union type is a special class type that, at any point, holds a value of one of its data members. Unlike regular classes, unions <a id="_idIndexMarker727"/>cannot have base classes, nor can they be derived, and they cannot contain virtual functions (that would not make sense anyway). Unions are mostly used to define different representations of the same data. However, unions only work for types that are <strong class="keyWord">Plain Old Data</strong> (<strong class="keyWord">POD</strong>). If a<a id="_idIndexMarker728"/> union contains values of non-POD types, then these members require explicit construction with a placement <code class="inlineCode">new</code> and explicit destruction, which is cumbersome and error-prone. In C++17, a type-safe union is available in the form of a standard library class template called <code class="inlineCode">std::variant</code>. In this recipe, you will learn how to use it to model alternative values.</p>
<h2 class="heading-2" id="_idParaDest-371">Getting ready</h2>
<p class="normal">The <code class="inlineCode">std::variant</code> type implements<a id="_idIndexMarker729"/> a type-safe <strong class="keyWord">discriminated union</strong>. Although discussing these in detail is beyond the scope of this recipe, we will introduce them briefly here. Being familiar with discriminated unions will help us better understand the design of <code class="inlineCode">variant</code> and the way it works.</p>
<p class="normal">Discriminated unions <a id="_idIndexMarker730"/>are also <a id="_idIndexMarker731"/>called <strong class="keyWord">tagged unions</strong> or <strong class="keyWord">disjoint unions</strong>. A <a id="_idIndexMarker732"/>discriminated union is a data type that is able to store one value of a collection of types and offer type-safe access for that value. In C++, this is typically implemented as follows:</p>
<pre class="programlisting code"><code class="hljs-code">enum VARTAG {VT_int, VT_double, VT_pint, TP_pdouble /* more */ };
struct variant_t
{
  VARTAG tag;
  union Value 
  {
    int     i;
    int*    pi;
    double  d;
    double* pd;
    /* more */
  } value;
};
</code></pre>
<p class="normal">For Windows programmers, a well-known discriminated union is the <code class="inlineCode">VARIANT</code> structure used<a id="_idIndexMarker733"/> in <strong class="keyWord">Component Object Model</strong> (<strong class="keyWord">COM)</strong> programming.</p>
<p class="normal">The class template <code class="inlineCode">std::variant</code> was designed based on <code class="inlineCode">boost::variant</code>, and is available in the <code class="inlineCode">&lt;variant&gt;</code> header. If you are familiar with <code class="inlineCode">boost::variant</code> and have used it in your code, you can migrate your code with little effort to use the standard <code class="inlineCode">variant</code> class template.</p>
<h2 class="heading-2" id="_idParaDest-372">How to do it...</h2>
<p class="normal">Use<a id="_idIndexMarker734"/> the <a id="_idIndexMarker735"/>following operations to work with <code class="inlineCode">std::variant</code>:</p>
<ul>
<li class="bulletList">To modify the stored value, use the member functions <code class="inlineCode">emplace()</code> or <code class="inlineCode">swap()</code>:
        <pre class="programlisting code"><code class="hljs-code">struct foo
{
  int value;
  explicit foo(int const i) : value(i) {}
};
std::variant&lt;int, std::string, foo&gt; v = 42; // holds int
v.emplace&lt;foo&gt;(42);                         // holds foo
</code></pre>
</li>
<li class="bulletList">To read the stored values, use the non-member functions <code class="inlineCode">std::get</code> or <code class="inlineCode">std::get_if</code>:
        <pre class="programlisting code"><code class="hljs-code">std::variant&lt;int, double, std::string&gt; v = 42;
auto i1 = std::get&lt;int&gt;(v);
auto i2 = std::get&lt;0&gt;(v);
try
{
  auto f = std::get&lt;double&gt;(v);
}
catch (std::bad_variant_access const &amp; e)
{
  std::cout &lt;&lt; e.what() &lt;&lt; '\n'; // Unexpected index
}
</code></pre>
</li>
<li class="bulletList">To store a value, use the constructor or assign a value directly to a <code class="inlineCode">variant</code> object:
        <pre class="programlisting code"><code class="hljs-code">std::variant&lt;int, double, std::string&gt; v;
v = 42;   // v contains int 42
v = 42.0; // v contains double 42.0
v = "42"; // v contains string "42"
</code></pre>
</li>
<li class="bulletList">To<a id="_idIndexMarker736"/> check what is the stored alternative, use the member function <code class="inlineCode">index()</code>:
        <pre class="programlisting code"><code class="hljs-code">std::variant&lt;int, double, std::string&gt; v = 42;
static_assert(std::variant_size_v&lt;decltype(v)&gt; == 3);
std::cout &lt;&lt; "index = " &lt;&lt; v.index() &lt;&lt; '\n';
v = 42.0;
std::cout &lt;&lt; "index = " &lt;&lt; v.index() &lt;&lt; '\n';
v = "42";
std::cout &lt;&lt; "index = " &lt;&lt; v.index() &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To <a id="_idIndexMarker737"/>check whether a variant holds an alternative, use the non-member function <code class="inlineCode">std::holds_alternative()</code>:
        <pre class="programlisting code"><code class="hljs-code">std::variant&lt;int, double, std::string&gt; v = 42;
std::cout &lt;&lt; "int? " &lt;&lt; std::boolalpha
          &lt;&lt; std::holds_alternative&lt;int&gt;(v)
          &lt;&lt; '\n'; // int? true
v = "42";
std::cout &lt;&lt; "int? " &lt;&lt; std::boolalpha
          &lt;&lt; std::holds_alternative&lt;int&gt;(v)
          &lt;&lt; '\n'; // int? false
</code></pre>
</li>
<li class="bulletList">To define a variant whose first alternative is not default constructible, use <code class="inlineCode">std::monostate</code> as the first alternative (in this example, <code class="inlineCode">foo</code> is the same class we used earlier):
        <pre class="programlisting code"><code class="hljs-code">std::variant&lt;std::monostate, foo, int&gt; v;
v = 42;        // v contains int 42
std::cout &lt;&lt; std::get&lt;int&gt;(v) &lt;&lt; '\n';
v = foo{ 42 }; // v contains foo{42}
std::cout &lt;&lt; std::get&lt;foo&gt;(v).value &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To<a id="_idIndexMarker738"/> process the stored value of a variant and do something depending on the type of the alternative, use <code class="inlineCode">std::visit()</code>:
        <pre class="programlisting code"><code class="hljs-code">std::variant&lt;int, double, std::string&gt; v = 42;
std::visit(
  [](auto&amp;&amp; arg) {std::cout &lt;&lt; arg &lt;&lt; '\n'; },
  v);
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-373">How it works...</h2>
<p class="normal"><code class="inlineCode">std::variant</code> is a<a id="_idIndexMarker739"/> class template that models a type-safe union, holding a value of one of its possible alternatives at any given time. In some rare cases, though, it is possible that a variant object does not store any value. <code class="inlineCode">std::variant</code> has a member function called <code class="inlineCode">valueless_by_exception()</code> that returns <code class="inlineCode">true</code> if the variant does not hold a value, which is possible only in case of an exception during initialization—therefore, the name of the function.</p>
<p class="normal">The size of a <code class="inlineCode">std::variant</code> object is as large as its largest alternative. A variant does not store additional data. The value stored by the variant is allocated within the memory representation of the object itself.</p>
<p class="normal">A variant can hold multiple alternatives of the same type and also hold different constant- and volatile-qualified versions at the same time. In this case, you cannot assign a value of the type used multiple types, but use the <code class="inlineCode">emplace()</code> member function instead, as shown in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">std::variant&lt;int, int, double&gt; v = 33.0;
v = 42;                               // error
v.emplace&lt;1&gt;(42);                     // OK
std::cout &lt;&lt; std::get&lt;1&gt;(v) &lt;&lt; '\n';  // prints 42
std::holds_alternative&lt;int&gt;(v);       // error
</code></pre>
<p class="normal">The <code class="inlineCode">std::holds_alternative()</code> function mentioned earlier, which checks whether a variant holds an alternative type <code class="inlineCode">T</code>, cannot be used in this case. You should avoid defining variants holding multiple alternatives of the same type. </p>
<p class="normal">On the other hand, a variant cannot hold an alternative of the type <code class="inlineCode">void</code>, or alternatives of array and reference types. Moreover, the first alternative must always be default constructible. The reason for this is that, just like discriminated unions, a variant is default initialized <a id="_idIndexMarker740"/>with the value of its first alternative. If the first alternative type is not default constructible, then the variant must use <code class="inlineCode">std::monostate</code> as the first alternative. This is an empty type indented for making variants default constructible.</p>
<p class="normal">It is <a id="_idIndexMarker741"/>possible to query a <code class="inlineCode">variant</code> at compile time for its size (that is, the number of alternatives it defines) and for the type of an alternative specified by its zero-based index. On the other hand, you can query the index of the currently held alternative at runtime using the member function <code class="inlineCode">index()</code>.</p>
<h2 class="heading-2" id="_idParaDest-374">There’s more...</h2>
<p class="normal">A typical way of manipulating the content of a variant is through visitation. This is basically the execution of an action based on the alternative held by the variant. Since it is a larger topic, it is addressed separately in the next recipe.</p>
<h2 class="heading-2" id="_idParaDest-375">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using std::any to store any value</em>, to learn how to use the C++17 class <code class="inlineCode">std::any</code>, which represents a type-safe container for single values of any type</li>
<li class="bulletList"><em class="italic">Using std::optional to store optional values</em>, to learn about the C++17 class template <code class="inlineCode">std::optional</code>, which manages a value that may or may not exist</li>
<li class="bulletList"><em class="italic">Visiting a std::variant</em>, to understand how to perform type matching and execute different actions based on the type of a variant’s alternatives</li>
</ul>
<h1 class="heading-1" id="_idParaDest-376">Visiting a std::variant</h1>
<p class="normal"><code class="inlineCode">std::variant</code> is a <a id="_idIndexMarker742"/>new standard container that was added to C++17 based on the <code class="inlineCode">boost.variant</code> library. A variant is a type-safe union that holds the value of one of its alternative types. Although, in the previous recipe, we have seen various operations with variants, the variants we used were rather simple, with POD types mostly, which is not the actual purpose for which <code class="inlineCode">std::variant</code> was created. Variants are intended to be used for holding alternatives of similar non-polymorphic and non-POD types. In this recipe, we will see a more real-world example of using variants and will learn how to visit variants.</p>
<h2 class="heading-2" id="_idParaDest-377">Getting ready</h2>
<p class="normal">For this recipe, you should be familiar with the <code class="inlineCode">std::variant</code> type. It is recommended that you first read the previous recipe, <em class="italic">Using std::variant as a type-safe union</em>.</p>
<p class="normal">To explain <a id="_idIndexMarker743"/>how variant visitation can be done, we will consider a variant for representing a media DVD. Let’s suppose we want to model a store or library that has DVDs that could contain either music, a movie, or software. However, these options are not modeled as a hierarchy with common data and virtual functions, but rather as non-related types that may have similar properties, such as a title. For simplicity, we’ll consider the following properties:</p>
<ul>
<li class="bulletList">For a movie: Title and length (in minutes)</li>
<li class="bulletList">For an album: Title, artist name, and a list of tracks (each track having a title and length in seconds)</li>
<li class="bulletList">For software: Title and manufacturer</li>
</ul>
<p class="normal">The following code shows a simple implementation of these types, without any functions, because that is not relevant to the visitation of a variant holding alternatives of these types:</p>
<pre class="programlisting code"><code class="hljs-code">enum class Genre { Drama, Action, SF, Comedy };
struct Movie
{
  std::string title;
  std::chrono::minutes length;
  std::vector&lt;Genre&gt; genre;
};
struct Track
{
  std::string title;
  std::chrono::seconds length;
};
struct Music
{
  std::string title;
  std::string artist;
  std::vector&lt;Track&gt; tracks;
};
struct Software
{
  std::string title;
  std::string vendor;
};
using dvd = std::variant&lt;Movie, Music, Software&gt;;
std::vector&lt;dvd&gt; dvds
{
  Movie{ "The Matrix"s, 2h + 16min,{ Genre::Action, Genre::SF } },
  Music{ "The Wall"s, "Pink Floyd"s,
       { { "Mother"s, 5min + 32s },
         { "Another Brick in the Wall"s, 9min + 8s } } },
  Software{ "Windows"s, "Microsoft"s },
};
</code></pre>
<p class="normal">On the <a id="_idIndexMarker744"/>other hand, we will utilize the following function to convert text to uppercase:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename CharT&gt;
using tstring = std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;, 
                                         std::allocator&lt;CharT&gt;&gt;;
template&lt;typename CharT&gt;
inline tstring&lt;CharT&gt; to_upper(tstring&lt;CharT&gt; text)
{
   std::transform(std::begin(text), std::end(text), 
                  std::begin(text), toupper);
   return text;
}
</code></pre>
<p class="normal">With these defined, let’s start looking at how visiting variants should be performed.</p>
<h2 class="heading-2" id="_idParaDest-378">How to do it...</h2>
<p class="normal">To visit a variant, you must provide one or more actions for the possible alternatives of the variant. There are several types of visitors, which are used for different purposes:</p>
<ul>
<li class="bulletList">A void visitor that does not return anything but has side effects. The following example prints the title of each DVD to the console:
        <pre class="programlisting code"><code class="hljs-code">for (auto const &amp; d : dvds)
{
  std::visit([](auto&amp;&amp; arg) {
               std::cout &lt;&lt; arg.title &lt;&lt; '\n'; },
             d);
}
</code></pre>
</li>
<li class="bulletList">A visitor<a id="_idIndexMarker745"/> that returns a value; the value should have the same type, regardless of the current alternative of the variant, or can itself be a variant. In the following example, we visit a variant and return a new variant of the same type that has the <code class="inlineCode">title</code> property from any of its alternatives transformed to uppercase letters:
        <pre class="programlisting code"><code class="hljs-code">for (auto const &amp; d : dvds)
{
  dvd result = std::visit(
    [](auto&amp;&amp; arg) -&gt; dvd
    {
      auto cpy { arg };
      cpy.title = to_upper(cpy.title);
      return cpy;
    },
  d);
  std::visit(
    [](auto&amp;&amp; arg) {
      std::cout &lt;&lt; arg.title &lt;&lt; '\n'; },
    result);
}
</code></pre>
</li>
<li class="bulletList">A visitor that does type matching (which can either be a void or a value-returning visitor) implemented by providing a function object that has an overloaded call operator for each alternative type of the variant:
        <pre class="programlisting code"><code class="hljs-code">struct visitor_functor
{
  void operator()(Movie const &amp; arg) const
 {
    std::cout &lt;&lt; "Movie" &lt;&lt; '\n';
    std::cout &lt;&lt; " Title: " &lt;&lt; arg.title &lt;&lt; '\n';
    std::cout &lt;&lt; " Length: " &lt;&lt; arg.length.count()
              &lt;&lt; "min" &lt;&lt; '\n';
  }
  void operator()(Music const &amp; arg) const
 {
    std::cout &lt;&lt; "Music" &lt;&lt; '\n';
    std::cout &lt;&lt; " Title: " &lt;&lt; arg.title &lt;&lt; '\n';
    std::cout &lt;&lt; " Artist: " &lt;&lt; arg.artist &lt;&lt; '\n';
    for (auto const &amp; t : arg.tracks)
      std::cout &lt;&lt; " Track: " &lt;&lt; t.title
                &lt;&lt; ", " &lt;&lt; t.length.count()
                &lt;&lt; "sec" &lt;&lt; '\n';
  }
  void operator()(Software const &amp; arg) const
 {
    std::cout &lt;&lt; "Software" &lt;&lt; '\n';
    std::cout &lt;&lt; " Title: " &lt;&lt; arg.title &lt;&lt; '\n';
    std::cout &lt;&lt; " Vendor: " &lt;&lt; arg.vendor &lt;&lt; '\n';
  }
};
for (auto const &amp; d : dvds)
{
  std::visit(visitor_functor(), d);
}
</code></pre>
</li>
<li class="bulletList">A <a id="_idIndexMarker746"/>visitor that does type matching that is implemented by providing a lambda expression that performs an action based on the type of the alternative:
        <pre class="programlisting code"><code class="hljs-code">for (auto const &amp; d : dvds)
{
  std::visit([](auto&amp;&amp; arg) {
    using T = std::decay_t&lt;decltype(arg)&gt;;
    if constexpr (std::is_same_v&lt;T, Movie&gt;)
    {
      std::cout &lt;&lt; "Movie" &lt;&lt; '\n';
      std::cout &lt;&lt; " Title: " &lt;&lt; arg.title &lt;&lt; '\n';
      std::cout &lt;&lt; " Length: " &lt;&lt; arg.length.count()
                &lt;&lt; "min" &lt;&lt; '\n';
    }
    else if constexpr (std::is_same_v&lt;T, Music&gt;)
    {
      std::cout &lt;&lt; "Music" &lt;&lt; '\n';
      std::cout &lt;&lt; " Title: " &lt;&lt; arg.title &lt;&lt; '\n';
      std::cout &lt;&lt; " Artist: " &lt;&lt; arg.artist &lt;&lt; '\n';
      for (auto const &amp; t : arg.tracks)
        std::cout &lt;&lt; " Track: " &lt;&lt; t.title
                  &lt;&lt; ", " &lt;&lt; t.length.count()
                  &lt;&lt; "sec" &lt;&lt; '\n';
    }
    else if constexpr (std::is_same_v&lt;T, Software&gt;)
    {
      std::cout &lt;&lt; "Software" &lt;&lt; '\n';
      std::cout &lt;&lt; " Title: " &lt;&lt; arg.title &lt;&lt; '\n';
      std::cout &lt;&lt; " Vendor: " &lt;&lt; arg.vendor &lt;&lt; '\n';
    }
  },
  d);
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-379">How it works...</h2>
<p class="normal">A <a id="_idIndexMarker747"/>visitor is a callable object (a function, a lambda expression, or a function object) that accepts every possible alternative from a variant. Visitation is done by invoking <code class="inlineCode">std::visit()</code> with the visitor and one or more variant objects. The variants do not have to be of the same type, but the visitor must be able to accept every possible alternative from all the variants it is invoked for. In the examples earlier, we visited a single variant object, but visiting multiple variants does not imply anything more than passing them as arguments to <code class="inlineCode">std::visit()</code>.</p>
<p class="normal">When you visit a variant, the callable object is invoked with the value currently stored in the variant. If the visitor does not accept an argument of the type stored in the variant, the program is ill-formed. If the visitor is a function object, then it must overload its call operator for all the possible alternative types of the variant. If the visitor is a lambda expression, it should be a generic lambda, which is basically a function object with a call operator template, instantiated by the compiler with the actual type that it is invoked with.</p>
<p class="normal">Examples of both approaches were shown in the previous section for a type-matching visitor. The function object in the first example is straightforward and should not require additional explanations. On the other hand, the generic lambda expression uses <em class="italic">constexpr if</em> to select a particular <code class="inlineCode">if</code> branch based on the type of the argument at compile time. The result is that the compiler will create a function object with an operator call template and a body that contains <em class="italic">constexpr if</em> statements; when it instantiates that function template, it will produce an overload for each possible alternative type of the variant and, in each of these overloads, it will select only the <em class="italic">constexpr if</em> branch that matches the type of the call operator argument. The result is conceptually equivalent <a id="_idIndexMarker748"/>to the implementation of the <code class="inlineCode">visitor_functor</code> class.</p>
<h2 class="heading-2" id="_idParaDest-380">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using std::any to store any value</em>, to learn how to use the C++17 class <code class="inlineCode">std::any</code>, which represents a type-safe container for single values of any type</li>
<li class="bulletList"><em class="italic">Using std::optional to store optional values</em>, to learn about the C++17 class template <code class="inlineCode">std::optional</code>, which manages a value that may or may not exist</li>
<li class="bulletList"><em class="italic">Using std::variant as a type-safe union</em>, to see how to use the C++17 <code class="inlineCode">std::variant</code> class to represent type-safe unions</li>
</ul>
<h1 class="heading-1" id="_idParaDest-381">Using std::expected to return a value or an error</h1>
<p class="normal">We <a id="_idIndexMarker749"/>often need to write a function that returns both some data and an indication of success or failure (either as a <code class="inlineCode">bool</code> for the simplest case or an error code for more complex cases). Typically, this can be solved either by returning a status code and using a parameter passed by reference for returning the data or by returning the actual data but throwing exceptions in the case of failure. In recent times, the availability of <code class="inlineCode">std::optional</code> and <code class="inlineCode">std::variant</code> gave way to new solutions for this problem. However, the C++23 standard provides a new approach with the <code class="inlineCode">std::expected</code> type, a sort of combination of the two types previously mentioned. Such a type is present in other programming languages, such as <code class="inlineCode">Result</code> in Rust and <code class="inlineCode">Either</code> in Haskell. In this recipe, we will learn how to use this new <code class="inlineCode">std::expected</code> class.</p>
<h2 class="heading-2" id="_idParaDest-382">Getting ready</h2>
<p class="normal">In the examples shown in this recipe, we will use the data types defined here:</p>
<pre class="programlisting code"><code class="hljs-code">enum class Status
{
   Success, InvalidFormat, InvalidLength, FilterError,
};
enum class Filter
{
   Pixelize, Sepia, Blur
};
using Image = std::vector&lt;char&gt;;
</code></pre>
<h2 class="heading-2" id="_idParaDest-383">How to do it…</h2>
<p class="normal">You can use the <code class="inlineCode">std::expected&lt;T, E&gt;</code> type from the new <code class="inlineCode">&lt;expected&gt;</code> header, as shown in the<a id="_idIndexMarker750"/> following examples:</p>
<ul>
<li class="bulletList">When returning data from a function, return either <code class="inlineCode">std::unexpected&lt;E&gt;</code> to indicate an error, or the data (a value of <code class="inlineCode">T</code>) when everything is executed successfully:
        <pre class="programlisting code"><code class="hljs-code">bool IsValidFormat(Image const&amp; img) { return true; }
bool IsValidLength(Image const&amp; img) { return true; }
bool Transform(Image&amp; img, Filter const filter)
{ 
   switch(filter)
   {
   case Filter::Pixelize:
      img.push_back('P');
      std::cout &lt;&lt; "Applying pixelize\n";
   break;
   case Filter::Sepia:
      img.push_back('S');
      std::cout &lt;&lt; "Applying sepia\n";
   break;
   case Filter::Blur:
      img.push_back('B');
      std::cout &lt;&lt; "Applying blur\n";
   break;
   }
   return true; 
}
std::expected&lt;Image, Status&gt; ApplyFilter(Image img, 
                                         Filter const filter)
{
   if (!IsValidFormat(img))
      return std::unexpected&lt;Status&gt; {Status::InvalidFormat};
   if (!IsValidLength(img))
      return std::unexpected&lt;Status&gt; {Status::InvalidLength};
   if (!Transform(img, filter))
      return std::unexpected&lt;Status&gt; {Status::FilterError};
   return img;
}
std::expected&lt;Image, Status&gt; FlipHorizontally(Image img)
{
    return Image{img.rbegin(), img.rend()};
}
</code></pre>
</li>
<li class="bulletList">When <a id="_idIndexMarker751"/>checking the result of a function that returns <code class="inlineCode">std::expected&lt;T, E&gt;</code>, use the <code class="inlineCode">bool</code> operator (or the <code class="inlineCode">has_value()</code> method) to check if the object holds the expected value, and the <code class="inlineCode">value()</code> and <code class="inlineCode">error()</code> methods to return the expected value or the unexpected error, respectively:
        <pre class="programlisting code"><code class="hljs-code">void ShowImage(Image const&amp; img)
{
   std::cout &lt;&lt; "[img]:";
   for(auto const &amp; e : img) std::cout &lt;&lt; e;
   std::cout &lt;&lt; '\n';
}
void ShowError(Status const status)
{
   std::cout &lt;&lt; "Error code: " 
             &lt;&lt; static_cast&lt;int&gt;(status) &lt;&lt; '\n'; 
}
int main()
{
   Image img{'I','M','G'};
   
   auto result = ApplyFilter(img, Filter::Sepia);
   if (result)
   {
      ShowImage(result.value());
   }
   else
   {
      ShowError(result.error());
   }
}
</code></pre>
</li>
<li class="bulletList">You<a id="_idIndexMarker752"/> can compose a chain of operations from functions that return a <code class="inlineCode">std::expected</code> value using the monadic operations <code class="inlineCode">and_then()</code>, <code class="inlineCode">or_else()</code>, <code class="inlineCode">transform()</code>, and <code class="inlineCode">transform_error()</code>:
        <pre class="programlisting code"><code class="hljs-code">int main()
{
   Image img{'I','M','G'};
   
   ApplyFilter(img, Filter::Sepia)                
      .and_then([](Image result){
          return ApplyFilter(result, Filter::Pixelize);
      })
      .and_then([](Image result){
          return ApplyFilter(result, Filter::Blur);
      })
      .and_then([](Image result){
          ShowImage(result);
          return std::expected&lt;Image, Status&gt;{result};
      })
      .or_else([](Status status){
          ShowError(status);
          return std::expected&lt;Image, Status&gt;{std::unexpect, 
                                              status};
      });
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-384">How it works…</h2>
<p class="normal">The <code class="inlineCode">std::expected&lt;T, E&gt;</code> class template is available in the new C++23 header called <code class="inlineCode">&lt;expected&gt;</code>. This class is a mixture of the <code class="inlineCode">std::variant</code> and the <code class="inlineCode">std::optional</code> types (introduced in C++17) but designed for the purpose of returning data or an unexpected value from a function. It has the logical structure of a discriminated union since it either holds the value of an expected type <code class="inlineCode">T</code>, or the value of an unexpected type (error) <code class="inlineCode">E</code>. However, its <a id="_idIndexMarker753"/>interface is very similar to the <code class="inlineCode">std::optional</code> class, as it features the following members:</p>
<table class="table-container" id="table002-2">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Function</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">has_value()</code></p>
</td>
<td class="table-cell">
<p class="normal">Returns a Boolean value that indicates whether the object contains the expected value or not.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">operator bool</code></p>
</td>
<td class="table-cell">
<p class="normal">Same as <code class="inlineCode">has_value()</code>. Provided for simpler usage in <code class="inlineCode">if</code> statements (<code class="inlineCode">if(result)</code> as opposed to <code class="inlineCode">if(result.has_value()</code>).</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">value()</code></p>
</td>
<td class="table-cell">
<p class="normal">Returns the expected value, unless the object contains an unexpected value. In this case, it throws a <code class="inlineCode">std::bad_expected_access&lt;E&gt;</code> exception, containing the unexpected value.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">value_or()</code></p>
</td>
<td class="table-cell">
<p class="normal">Similar to <code class="inlineCode">value()</code> but, instead of throwing an exception if an unexpected value is stored in the object, it returns the supplied, alternative value.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">error()</code></p>
</td>
<td class="table-cell">
<p class="normal">Returns the unexpected value. If the object holds an expected value, then the behavior is undefined.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">operator-&gt;</code> and <code class="inlineCode">operator*</code></p>
</td>
<td class="table-cell">
<p class="normal">Accesses the expected value. If the object holds an unexpected value, then the behavior is undefined.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 6.2: A listing of the most important members of std::expected</p>
<p class="normal">Although it was previously mentioned that the <code class="inlineCode">std::expected</code> type is a discriminated union of two <code class="inlineCode">T</code> (expected) and <code class="inlineCode">E</code> (error) types, it is not entirely correct. The actual types it holds are either <code class="inlineCode">T</code> or <code class="inlineCode">std::unexpected&lt;E&gt;</code>. This latter type is a helper class that holds an object of type <code class="inlineCode">E</code>. There are some restrictions on the possible types used for <code class="inlineCode">T</code> and <code class="inlineCode">E</code>:</p>
<ul>
<li class="bulletList"><code class="inlineCode">T</code> can be either <code class="inlineCode">void</code> or a destructible type (a type for which a destructor can be invoked). Arrays and reference types cannot be substituted for <code class="inlineCode">T</code>. If the type <code class="inlineCode">T</code> is the <code class="inlineCode">void</code> type, then the <code class="inlineCode">value_or()</code> method is not available.</li>
<li class="bulletList"><code class="inlineCode">E</code> must be a destructible type. Arrays, reference types, and <code class="inlineCode">const</code> and <code class="inlineCode">volatile</code> qualified types cannot be substituted for <code class="inlineCode">E</code>.</li>
</ul>
<p class="normal">There are cases when you want to apply multiple operations to a value. In our example, this could be applying different filters in a row to an image. But it could be other things such as resizing the image, changing the format/type, flipping in different directions, and so on. Each <a id="_idIndexMarker754"/>of these operations could return a <code class="inlineCode">std::expected</code> value. In this case, we can write code as follows:</p>
<pre class="programlisting code"><code class="hljs-code">int main()
{
   Image img{'I','M','G'};
   
   auto result = ApplyFilter(img, Filter::Sepia);
   result = ApplyFilter(result.value(), Filter::Pixelize);
   result = ApplyFilter(result.value(), Filter::Blur);
   result = FlipHorizontally(result.value());
   if (result)
   {
      ShowImage(result.value());
   }
   else
   {
      ShowError(result.error());
   }
}
</code></pre>
<p class="normal">If no error occurs, then the result of running this program is the following:</p>
<pre class="programlisting con"><code class="hljs-con">Applying sepia
Applying pixelize
Applying blur
[img]:BPSGMI
</code></pre>
<p class="normal">However, if an error occurs in the <code class="inlineCode">ApplyFilter()</code> function, invoking the <code class="inlineCode">value()</code> method in the subsequent call would result in a <code class="inlineCode">std::bad_expected_access</code> exception. We actually have to check the result after each operation. This can be improved using monadic operations.</p>
<p class="normal">Since the <code class="inlineCode">std::expected</code> type is very similar to the <code class="inlineCode">std::optional</code> type, the monadic operations available in C++23 for <code class="inlineCode">std::optional</code> are also available to <code class="inlineCode">std::expected</code>. These are the following:</p>
<table class="table-container" id="table003-2">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Function</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">and_then()</code></p>
</td>
<td class="table-cell">
<p class="normal">If the <code class="inlineCode">std::expected</code> object contains an expected value (of type <code class="inlineCode">T</code>), then it applies a given function on it and returns the result. Otherwise, it returns the <code class="inlineCode">std::expected</code> value.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">or_else()</code></p>
</td>
<td class="table-cell">
<p class="normal">If the <code class="inlineCode">std::expected</code> object contains an unexpected value (of type <code class="inlineCode">E</code>), then it applies a given function on the unexpected value and returns the result. Otherwise, it returns the <code class="inlineCode">std::expected</code> value.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">transform()</code></p>
</td>
<td class="table-cell">
<p class="normal">This is similar to <code class="inlineCode">and_then()</code>, except that the returned value is also wrapped in a <code class="inlineCode">std::expected</code> value.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">transform_error()</code></p>
</td>
<td class="table-cell">
<p class="normal">This is similar to <code class="inlineCode">or_else()</code>, except that the returned value is also wrapped in a <code class="inlineCode">std::expected</code> value.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 6.3: Monadic operations of std::expected</p>
<p class="normal">We<a id="_idIndexMarker755"/> can rewrite the code from the last snippet using monadic operations as follows:</p>
<pre class="programlisting code"><code class="hljs-code">int main()
{
   Image img{'I','M','G'};
   
   ApplyFilter(img, Filter::Sepia)                
      .and_then([](Image result){
          return ApplyFilter(result, Filter::Pixelize);
      })
      .and_then([](Image result){
          return ApplyFilter(result, Filter::Blur);
      })
      .and_then(FlipHorizontally)       
      .and_then([](Image result){
          ShowImage(result);
          return std::expected&lt;Image, Status&gt;{result};
      })
      .or_else([](Status status){
          ShowError(status);
          return std::expected&lt;Image, Status&gt;{std::unexpect, status};
      });
}
</code></pre>
<p class="normal">If no error occurs, then the output is the one we already saw. However, if an error occurs, let’s say when applying the sepia filter, then the output changes to the following:</p>
<pre class="programlisting con"><code class="hljs-con">Applying sepia
Error code: 3
</code></pre>
<p class="normal">This<a id="_idIndexMarker756"/> example shows only two of the available monadic operations, <code class="inlineCode">and_then()</code> and <code class="inlineCode">or_else()</code>. The other two, <code class="inlineCode">transform()</code> and <code class="inlineCode">transform_or()</code>, are similar but they are intended to transform (as the name implies) either the expected or the unexpected value into another value. In the following snippet (a modification of the previous one), we chain a transform operation for both the expected and unexpected value, in either case returning a string:</p>
<pre class="programlisting code"><code class="hljs-code">int main()
{
   Image img{'I','M','G'};
   
   auto obj = ApplyFilter(img, Filter::Sepia)                
      .and_then([](Image result){
          return ApplyFilter(result, Filter::Pixelize);
      })
      .and_then([](Image result){
          return ApplyFilter(result, Filter::Blur);
      })
      .and_then(FlipHorizontally)       
      .and_then([](Image result){
          ShowImage(result);
          return std::expected&lt;Image, Status&gt;{result};
      })
      .or_else([](Status status){
          ShowError(status);
          return std::expected&lt;Image, Status&gt;{std::unexpect, status};
      })       
      .transform([](Image result){
          std::stringstream s;
          s &lt;&lt; std::quoted(std::string(result.begin(), 
                                       result.end()));
          return s.str();
      })
      .transform_error([](Status status){
          return status == Status::Success ? "success" : "fail";
      });
    if(obj)
       std::cout &lt;&lt; obj.value() &lt;&lt; '\n';
    else
       std::cout &lt;&lt; obj.error() &lt;&lt; '\n';
}
</code></pre>
<p class="normal">If no <a id="_idIndexMarker757"/>error occurs during the execution of this program, then the following output will be printed:</p>
<pre class="programlisting con"><code class="hljs-con">Applying sepia
Applying pixelize
Applying blur
[img]:BPSGMI
"BPSGMI"
</code></pre>
<p class="normal">However, if an error occurs during the execution, such as when applying the sepia filter, then the output becomes the following:</p>
<pre class="programlisting con"><code class="hljs-con">Applying sepia
Error code: 3
fail
</code></pre>
<p class="normal">In the <code class="inlineCode">or_else()</code> function above, you’ll have noticed the use of <code class="inlineCode">std::unexpected</code>. This is a helper class that acts as a tag for the constructor of <code class="inlineCode">std::expected</code> in order to indicate the construction of an unexpected value. As a result, the argument is perfectly forwarded to the constructor of the <code class="inlineCode">E</code> type (the unexpected type). The <code class="inlineCode">has_value()</code> method will return <code class="inlineCode">false</code> for the newly created <code class="inlineCode">std::expected</code> value, indicating that it holds an unexpected value.</p>
<h2 class="heading-2" id="_idParaDest-385">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using std::optional to store optional values</em>, to learn about the C++17 class template <code class="inlineCode">std::optional</code>, which manages a value that may or may not exist</li>
<li class="bulletList"><em class="italic">Using std::variant as a type-safe union</em>, to learn how to use the C++17 <code class="inlineCode">std::variant</code> class to represent type-safe unions</li>
</ul>
<h1 class="heading-1" id="_idParaDest-386">Using std::span for contiguous sequences of objects</h1>
<p class="normal">In C++17, the <code class="inlineCode">std::string_view</code> type <a id="_idIndexMarker758"/>was added to the standard library. This is an object<a id="_idIndexMarker759"/> that represents a view over a constant contiguous sequence of characters. The view is typically implemented with a pointer to the first element of the sequence and a length. Strings are one of <a id="_idIndexMarker760"/>the most used data types in any programming language. They have a non-owning view that does not allocate memory, avoids copies, and performs some operations<a id="_idIndexMarker761"/> faster than <code class="inlineCode">std::string</code>, which is an important benefit. However, a string is just a special vector of characters with operations specific to text. Therefore, it makes sense to have a type that is a view of a contiguous sequence of objects, regardless of their type. This is what the <code class="inlineCode">std::span</code> class template in C++20 represents. We could say that <code class="inlineCode">std::span</code> is to <code class="inlineCode">std::vector</code> and array types what <code class="inlineCode">std::string_view</code> is to <code class="inlineCode">std::string</code>.</p>
<h2 class="heading-2" id="_idParaDest-387">Getting ready</h2>
<p class="normal">The <code class="inlineCode">std::span</code> class template is available in the header <code class="inlineCode">&lt;span&gt;</code>.</p>
<h2 class="heading-2" id="_idParaDest-388">How to do it…</h2>
<p class="normal">Use <code class="inlineCode">std::span&lt;T&gt;</code> instead of a pointer and size pair as you typically would with C-like interfaces. In other words, replace functions like this:</p>
<pre class="programlisting code"><code class="hljs-code">void func(int* buffer, size_t length) { /* ... */ }
</code></pre>
<p class="normal">with this:</p>
<pre class="programlisting code"><code class="hljs-code">void func(std::span&lt;int&gt; buffer) { /* ... */ }
</code></pre>
<p class="normal">When working with <code class="inlineCode">std::span</code>, you can do the following:</p>
<ul>
<li class="bulletList">Create a span with a compile-time length (called <em class="italic">static extent</em>) by specifying the number of elements in the span:
        <pre class="programlisting code"><code class="hljs-code">int arr[] = {1, 1, 2, 3, 5, 8, 13};
std::span&lt;int, 7&gt; s {arr};
</code></pre>
</li>
<li class="bulletList">Create a span with a runtime length (called <em class="italic">dynamic extent</em>) by not specifying the number of elements in the span:
        <pre class="programlisting code"><code class="hljs-code">int arr[] = {1, 1, 2, 3, 5, 8, 13};
std::span&lt;int&gt; s {arr};
</code></pre>
</li>
<li class="bulletList">You can use a span in a range-based for loop:
        <pre class="programlisting code"><code class="hljs-code">void func(std::span&lt;int&gt; buffer)
{
   for(auto const e : buffer)
      std::cout &lt;&lt; e &lt;&lt; ' ';
   std::cout &lt;&lt; '\n';
}
</code></pre>
</li>
<li class="bulletList">You<a id="_idIndexMarker762"/> can access the elements of a span using the methods <code class="inlineCode">front()</code>, <code class="inlineCode">back()</code>, and <code class="inlineCode">data()</code>, and the <code class="inlineCode">operator[]</code>:
        <pre class="programlisting code"><code class="hljs-code">int arr[] = {1, 1, 2, 3, 5, 8, 13};
std::span&lt;int, 7&gt; s {arr};
std::cout &lt;&lt; s.front() &lt;&lt; " == " &lt;&lt; s[0] &lt;&lt; '\n';    
// prints 1 == 1
std::cout &lt;&lt; s.back() &lt;&lt; " == " &lt;&lt; s[s.size() - 1] &lt;&lt; '\n'; 
// prints 13 == 13
std::cout &lt;&lt; *s.data() &lt;&lt; '\n';
// prints 1
</code></pre>
</li>
<li class="bulletList">You <a id="_idIndexMarker763"/>can obtain sub-spans of a span with the methods <code class="inlineCode">first()</code>, <code class="inlineCode">last()</code>, and <code class="inlineCode">subspan()</code>:
        <pre class="programlisting code"><code class="hljs-code">std::span&lt;int&gt; first_3 = s.first(3);
func(first_3);  // 1 1 2.
std::span&lt;int&gt; last_3 = s.last(3);
func(last_3);   // 5 8 13
std::span&lt;int&gt; mid_3 = s.subspan(2, 3);
func(mid_3);    // 2 3 5
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-389">How it works…</h2>
<p class="normal">The <code class="inlineCode">std::span</code> class template is not a container of objects but a lightweight wrapper that defines a view of a contiguous sequence of objects. Initially, the span was called <code class="inlineCode">array_view</code>, which some argue was a better name, both because it clearly indicates that the type is a non-owning view of a sequence and because it would be consistent with the name of <code class="inlineCode">string_view</code>. However, the type was adopted in the standard library under the name <em class="italic">span</em>.</p>
<p class="normal">Although the standard does not specify the implementation details, the span is typically implemented by storing a pointer to the first element of the sequence and a length, representing the number of elements in the view. Therefore, a span can be used to define a non-owning view over (but not only) a <code class="inlineCode">std::vector</code>, <code class="inlineCode">std::array</code>, <code class="inlineCode">T[]</code>, or <code class="inlineCode">T*</code>. However, it cannot be used with lists or associative containers (for instance, <code class="inlineCode">std::list</code>, <code class="inlineCode">std::map</code>, or <code class="inlineCode">std::set</code>) because these are not containers for a contiguous sequence of elements.</p>
<p class="normal">The span<a id="_idIndexMarker764"/> can have either a compile-time size <a id="_idIndexMarker765"/>or a runtime size. When the number of elements in the span is specified at compile-time, we have a span with a static extent (compile-time size). If the number of elements is not specified but determined at runtime, we have a dynamic extent.</p>
<p class="normal">The <code class="inlineCode">std::span</code> class has a simple interface, mainly consisting of the following members:</p>
<table class="table-container" id="table004-2">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Member function</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">begin()</code>, <code class="inlineCode">end()</code></p>
<p class="normal"><code class="inlineCode">cbegin()</code>, <code class="inlineCode">cend()</code></p>
</td>
<td class="table-cell">
<p class="normal">Mutable and constant iterators to the first and the one-past-last element of the sequence.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">rbegin()</code>, <code class="inlineCode">rend()</code></p>
<p class="normal"><code class="inlineCode">cbegin()</code>, <code class="inlineCode">crend()</code></p>
</td>
<td class="table-cell">
<p class="normal">Mutable and constant reverse iterators to the beginning and end of the sequence.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">front()</code>, <code class="inlineCode">back()</code></p>
</td>
<td class="table-cell">
<p class="normal">Accesses the first and last element of the sequence.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">data()</code></p>
</td>
<td class="table-cell">
<p class="normal">Returns a pointer to the beginning of the sequence of elements.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">operator[]</code></p>
</td>
<td class="table-cell">
<p class="normal">Accesses an element of the sequence specified by its index.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">size()</code></p>
</td>
<td class="table-cell">
<p class="normal">Retrieves the number of elements in the sequence.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">size_bytes()</code></p>
</td>
<td class="table-cell">
<p class="normal">Retrieves the size of the sequence in bytes.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">empty()</code></p>
</td>
<td class="table-cell">
<p class="normal">Checks whether the sequence is empty.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">first()</code></p>
</td>
<td class="table-cell">
<p class="normal">Retrieves a sub-span with the first <em class="italic">N</em> elements of the sequence.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">last()</code></p>
</td>
<td class="table-cell">
<p class="normal">Retrieves a sub-span with the last <em class="italic">N</em> elements of the sequence.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">subspan()</code></p>
</td>
<td class="table-cell">
<p class="normal">Retrieves a sub-span with <em class="italic">N</em> elements starting from a specified offset. If the count <em class="italic">N</em> is not specified, it returns a span with all the elements from offset until the end of the sequence.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 6.4: A listing of the most important member functions of std::span</p>
<p class="normal">A span is <a id="_idIndexMarker766"/>not intended to be used with general-purpose algorithms that work with a pair of iterators to the beginning and the end of a range (such as <code class="inlineCode">sort</code>, <code class="inlineCode">copy</code>, <code class="inlineCode">find_if</code>, and so on), nor as a replacement for standard containers. Its main purpose is to build better interfaces than the C-like ones where a pointer and a size are passed to a function. The user may pass a wrong value<a id="_idIndexMarker767"/> for the size, which could end in accessing memory beyond the bounds of the sequence. The span provides safety and bounds checking. It is also a good alternative to passing a constant reference as an argument to a function to <code class="inlineCode">std::vector&lt;T&gt;</code> (<code class="inlineCode">std::vector&lt;T&gt; const &amp;</code>). The span does not own its elements and is small enough to be passed by value (you should not pass spans by reference or constant reference).</p>
<p class="normal">Unlike <code class="inlineCode">std::string_view</code>, which does not support changing the value of the elements in the sequence, <code class="inlineCode">std::span</code> defines a mutable view and supports modifying its elements. For this purpose, functions such as <code class="inlineCode">front()</code>, <code class="inlineCode">back()</code>, and <code class="inlineCode">operator[]</code> return a reference.</p>
<h2 class="heading-2" id="_idParaDest-390">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 2</em>, <em class="italic">Using string_view instead of constant string references</em>, to learn how to use <code class="inlineCode">std::string_view</code> to improve performance in some scenarios when working with strings</li>
<li class="bulletList"><em class="italic">Using std::mdspan for multidimensional views of sequences of objects</em>, to learn about the C++23 span class for multi-dimensional sequences</li>
</ul>
<h1 class="heading-1" id="_idParaDest-391">Using std::mdspan for multi-dimensional views of sequences of objects</h1>
<p class="normal">In the<a id="_idIndexMarker768"/> previous recipe, <em class="italic">Using std::span for contiguous sequences of objects</em>, we learned about the C++20 class called <code class="inlineCode">std::span</code>, which represents a view (a non-owning wrapper) over a contiguous sequence of elements. This is similar to the C++17 <code class="inlineCode">std::string_view</code> class, which <a id="_idIndexMarker769"/>does the same but for a sequence of characters. Both of these are views of one-dimensional sequences. However, sometimes we need to work with multi-dimensional sequences. These could be implemented in many ways, such as C-like arrays (<code class="inlineCode">int[2][3][4]</code>), pointer-of-pointers (<code class="inlineCode">int**</code> or <code class="inlineCode">int***</code>), arrays of arrays (or vectors of vectors, such as <code class="inlineCode">vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;</code>). A different approach is to use a one-dimensional sequence of objects but define operations that present it as a logical multi-dimensional sequence. This is what the C++23 <code class="inlineCode">std::mdspan</code> class does: it represents a non-owning view of a contiguous sequence of objects presented as a multi-dimensional sequence. We could say that <code class="inlineCode">std::mdspan</code> is an extension of the <code class="inlineCode">std::span</code> class for multi-dimensional views.</p>
<h2 class="heading-2" id="_idParaDest-392">Getting ready</h2>
<p class="normal">In this recipe, we will refer to the following simple implementation of a two-dimensional matrix (whose size is known at compile time):</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T, std::size_t ROWS, std::size_t COLS&gt;
struct matrix
{
   T&amp; 
#ifdef __cpp_multidimensional_subscript
operator[] // C++23
#else
operator() // previously
#endif
   (std::size_t const r, std::size_t const c)
   {
      if (r &gt;= ROWS || c &gt;= COLS)
         throw std::runtime_error("Invalid index");
      return data[r * COLS + c];
   }
   T const &amp; 
#ifdef __cpp_multidimensional_subscript
operator[] // C++23
#else
operator() // previously
#endif
   (std::size_t const r, std::size_t const c) const
   {
      if (r &gt;= ROWS || c &gt;= COLS)
         throw std::runtime_error("Invalid index");
      return data[r * COLS + c];
   }
   std::size_t size() const { return data.size(); }
   std::size_t empty() const { return data.empty(); }
   template &lt;std::size_t dimension&gt;
   std::size_t extent() const
 {
      static_assert(dimension &lt;= 1, 
                    "The matrix only has two dimensions.");
      if constexpr (dimension == 0) return ROWS;
      else if constexpr(dimension == 1) return COLS;
   }
private:
   std::array&lt;T, ROWS* COLS&gt; data;
};
</code></pre>
<div><p class="normal">In C++23, you should prefer to use <code class="inlineCode">operator[]</code> instead of <code class="inlineCode">operator()</code> to access elements of a multi-dimensional data structure.</p>
</div>
<h2 class="heading-2" id="_idParaDest-393">How to do it…</h2>
<p class="normal">Prefer<a id="_idIndexMarker770"/> to use <code class="inlineCode">std::mdspan</code> over<a id="_idIndexMarker771"/> multi-dimensional C-like arrays, pointer-of-pointers, or vector-of-vector/array-of-array implementations. In other words, replace functions like this:</p>
<pre class="programlisting code"><code class="hljs-code">void f(int data[2][3]) { /* … */ }
void g(int** data, size_t row, size_t cols) { /* … */ }
void h(std::vector&lt;std::vector&lt;int&gt;&gt; dat, size_t row, size_t cols)
{ /* … */ }
</code></pre>
<p class="normal">with this:</p>
<pre class="programlisting code"><code class="hljs-code">void f(std::mdspan&lt;int,std::extents&lt;size_t, 2, 3&gt;&gt; data) 
{ /* … */ }
</code></pre>
<p class="normal">When<a id="_idIndexMarker772"/> working <a id="_idIndexMarker773"/>with <code class="inlineCode">std::mdspan</code>, you can do the following:</p>
<ul>
<li class="bulletList">Create an <code class="inlineCode">mdspan</code> with a compile-time <a id="_idIndexMarker774"/>length (called <strong class="keyWord">static extent</strong>) by specifying the number of elements of each dimension of the span:
        <pre class="programlisting code"><code class="hljs-code">int* data = get_data();
std::mdspan&lt;int, std::extents&lt;size_t, 2, 3&gt;&gt; m(data);
</code></pre>
</li>
<li class="bulletList">Create an <code class="inlineCode">mdspan</code> with a<a id="_idIndexMarker775"/> runtime length (called <strong class="keyWord">dynamic extent</strong>) by not specifying the number of elements of a dimension of the span at compile-time, and instead providing it at runtime:
        <pre class="programlisting code"><code class="hljs-code">int* data = get_data();
std::mdspan&lt;int, std::extents&lt;size_t, 
                              2, 
                              std::dynamic_extent&gt;&gt; mv{v.data(), 3};
</code></pre>
<p class="normal">or</p>
<pre class="programlisting code"><code class="hljs-code">int* data = get_data();
std::mdspan&lt;int, std::extents&lt;size_t, 
                              std::dynamic_extent,
                              std::dynamic_extent&gt;&gt; 
m(data, 2, 3);
</code></pre>
<p class="normal">or</p>
<pre class="programlisting code"><code class="hljs-code">int* data = get_data();
std::mdspan m(data, 2, 3);
</code></pre> </li>
</ul>
<ul>
<li class="bulletList">To control the mapping of the multi-dimensional indexes of an <code class="inlineCode">mdspan</code> to the one-dimensional index of the underlying (contiguous) sequence of data, use a layout policy, which is the third template argument:
        <pre class="programlisting code"><code class="hljs-code">std::mdspan&lt;int, 
            std::extents&lt;size_t, 2, 3&gt;,
            std::layout_right&gt; mv{ data };
</code></pre>
<p class="normal">or</p>
<pre class="programlisting code"><code class="hljs-code">std::mdspan&lt;int, 
            std::extents&lt;size_t, 2, 3&gt;,
            std::layout_left&gt; mv{ data };
</code></pre>
<p class="normal">or</p>
<pre class="programlisting code"><code class="hljs-code">std::mdspan&lt;int, 
            std::extents&lt;size_t, 2, 3&gt;,
            std::layout_stride&gt; mv{ data };
</code></pre> </li>
</ul>
<h2 class="heading-2" id="_idParaDest-394">How it works…</h2>
<p class="normal">As the name<a id="_idIndexMarker776"/> implies, <code class="inlineCode">mdspan</code> is a multi-dimensional span. That is a non-owning view of a one-dimensional<a id="_idIndexMarker777"/> sequence of values that is projected as a logical multi-dimensional structure. This is what we saw in the <em class="italic">Getting ready</em> section, where we defined a class called <code class="inlineCode">matrix</code> that represents a two-dimensional matrix. The operations it defines (such as <code class="inlineCode">operator()</code> and/or <code class="inlineCode">operator[]</code> in C++23) are specific to a 2D data structure. However, internally, the data is laid out in a contiguous sequence, a <code class="inlineCode">std::array</code> in our implementation. We can use this class as follows:</p>
<pre class="programlisting code"><code class="hljs-code">matrix&lt;int, 2, 3&gt; m;
for (std::size_t r = 0; r &lt; m.extent&lt;0&gt;(); r++)
{
   for (std::size_t c = 0; c &lt; m.extent&lt;1&gt;(); c++)
   {
      m[r, c] = r * m.extent&lt;1&gt;() + c + 1; // m[r,c] in C++23
// m(r, c) previously
   }
}
</code></pre>
<p class="normal">This for-in-for sequence sets the values of the matrix elements to the following:</p>
<pre class="programlisting code"><code class="hljs-code">1 2 3
4 5 6
</code></pre>
<p class="normal">In C++23, we can simply replace this entire class with the <code class="inlineCode">std::mdspan</code> class: </p>
<pre class="programlisting code"><code class="hljs-code">std::array&lt;int, 6&gt; arr;
std::mdspan m{arr.data(), std::extents{2, 3}};
for (std::size_t r = 0; r &lt; m.extent(0); r++)
{
   for (std::size_t c = 0; c &lt; m.extent(1); c++)
   {
      m[r, c] = r * m.extent(1) + c + 1;
   }
}
</code></pre>
<p class="normal">The<a id="_idIndexMarker778"/> only thing <a id="_idIndexMarker779"/>that changes here is the use of the <code class="inlineCode">extent()</code> method, which previously was a function template member of the <code class="inlineCode">matrix</code> class. However, this is simply a minor detail. We can actually define <code class="inlineCode">matrix</code> as an alias template for <code class="inlineCode">std::mdspan</code>, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T, std::size_t ROWS, std::size_t COLS&gt;
using matrix = std::mdspan&lt;T, std::extents&lt;std::size_t, ROWS, COLS&gt;&gt;;
std::array&lt;int, 6&gt; arr;
matrix&lt;int, 2, 3&gt; ma {arr.data()};
</code></pre>
<p class="normal">In this example, the <code class="inlineCode">mdspan</code> is two-dimensional, but it can be defined on any number of dimensions. The interface of the <code class="inlineCode">mdspan</code> type includes the following members:</p>
<table class="table-container" id="table005-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Name</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">operator[]</code></p>
</td>
<td class="table-cell">
<p class="normal">Provides access to the elements of the underlying data.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">size()</code></p>
</td>
<td class="table-cell">
<p class="normal">Returns the number of elements.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">empty()</code></p>
</td>
<td class="table-cell">
<p class="normal">Indicates whether the number of elements is zero.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">stride()</code></p>
</td>
<td class="table-cell">
<p class="normal">Returns the stride of the specified dimension. Unless explicitly customized, this is implicitly 1.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">extents()</code></p>
</td>
<td class="table-cell">
<p class="normal">Returns the size (extent) of the specified dimension.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 6.5: A listing of some member functions of mdspan</p>
<p class="normal">If you look at the definition of the <code class="inlineCode">std::mdspan</code> class, you will see the following:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;class T,
         class Extents,
         class LayoutPolicy = std::layout_right,
         class AccessorPolicy = std::default_accessor&lt;T&gt;&gt;
class mdspan;
</code></pre>
<p class="normal">The first two<a id="_idIndexMarker780"/> template arguments are the type of the elements and the extents (size) of each dimension. We<a id="_idIndexMarker781"/> saw these in the previous examples. The last two, however, are customization points:</p>
<ul>
<li class="bulletList">The layout policies control how the multi-dimensional index of an <code class="inlineCode">mdspan</code> maps to the offset in the one-dimensional underlying data. There are several options available: <code class="inlineCode">layout_right</code> (the default) where the rightmost index gives stride-one access to the underlying memory (this is the C/C++ style); <code class="inlineCode">layout_left</code> where the leftmost index gives stride-one access to the underlying memory (this is the Fortran and Matlab style); and <code class="inlineCode">layout_stride</code>, which generalizes the previous two and allows customizing the stride on each extent. The reasons for having layout policies are interoperability with other languages and to change an algorithm’s data access pattern without changing the structure of its loop.</li>
<li class="bulletList">The accessor policy defines how the underlying sequence stores its elements and how to use the offset from the layout policy to get a reference to a stored element. These are mostly intended for third-party libraries. It’s unlikely you need to implement an accessor policy for <code class="inlineCode">std::mdspan</code>, just as it is unlikely you need to define an allocator for <code class="inlineCode">std::vector</code>.</li>
</ul>
<p class="normal">Let’s exemplify the layout policies to understand how they work. The default one is <code class="inlineCode">std::layout_right</code>. We can consider this example, which explicitly specifies the policy:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector v {1,2,3,4,5,6,7,8,9};
std::mdspan&lt;int, 
            std::extents&lt;size_t, 2, 3&gt;,
            std::layout_right&gt; mv{v.data()};
</code></pre>
<p class="normal">The two-dimensional matrix defined here has the following content:</p>
<pre class="programlisting code"><code class="hljs-code">1 2 3
4 5 6
</code></pre>
<p class="normal">However, if we change the layout policy to <code class="inlineCode">std::layout_left</code>, then the content also changes to the following:</p>
<pre class="programlisting code"><code class="hljs-code">1 3 5
2 4 6
</code>
defines a stride equivalent to the <code class="inlineCode">std::layout_right</code>, for the 2x3 matrix we have seen so far:</pre>
<pre class="programlisting code"><code class="hljs-code">std::mdspan&lt;int, 
            std::extents&lt;size_t, 
                         std::dynamic_extent, 
                         std::dynamic_extent&gt;, 
            std::layout_stride&gt; 
mv{ v.data(), { std::dextents&lt;size_t,2&gt;{2, 3}, 
                std::array&lt;std::size_t, 2&gt;{3, 1}}};
</code></pre>
<p class="normal">However, different strides provide different results. Several examples are shown in the following table:</p>
<table class="table-container" id="table006-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Strides</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Matrix</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">{0, 0}</p>
</td>
<td class="table-cell">
<p class="normal">1 1 1</p>
<p class="normal">1 1 1</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">{0, 1}</p>
</td>
<td class="table-cell">
<p class="normal">1 2 3</p>
<p class="normal">1 2 3</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">{1, 0}</p>
</td>
<td class="table-cell">
<p class="normal">1 1 1</p>
<p class="normal">2 2 2</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">{1, 1}</p>
</td>
<td class="table-cell">
<p class="normal">1 2 3</p>
<p class="normal">2 3 4</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">{2, 1}</p>
</td>
<td class="table-cell">
<p class="normal">1 2 3</p>
<p class="normal">3 4 5</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">{1, 2}</p>
</td>
<td class="table-cell">
<p class="normal">1 3 5</p>
<p class="normal">2 4 6</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">{2, 3}</p>
</td>
<td class="table-cell">
<p class="normal">1 4 7</p>
<p class="normal">3 6 9</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 6.6: Examples of custom strides and the content of resulting views</p>
<p class="normal">Let’s discuss<a id="_idIndexMarker784"/> the last example, which is perhaps a bit more general. The stride of the first extent represents the offset increment for rows. The first element is at index 0 in the underlying sequence. Therefore, a stride of 2, as in this case, indicates that rows are read from indexes 0, 2, 4, and so on. The stride of the second extent represents the offset<a id="_idIndexMarker785"/> increment for columns. The first element is at the index of the corresponding row. In this example, the index for the first row is 0, so a stride of 3 for columns means that the elements of the first row will be read from the index 0, 3, and 6. The second row starts at index 2. Therefore, the elements of the second row will be read from the indexes 2, 5, and 8. This is the last example shown in the previous table.</p>
<h2 class="heading-2" id="_idParaDest-395">There’s more…</h2>
<p class="normal">The original proposal for <code class="inlineCode">mdspan</code> included a free function called <code class="inlineCode">submdspan()</code>. This function creates a slice of an <code class="inlineCode">mdspan</code>, or, in other words, a view of a subset of an <code class="inlineCode">mdspan</code>. In order to make it possible for <code class="inlineCode">mdspan</code> to be included in C++23, this function was removed and moved to C++26. At the time of writing this book, it has already been included in C++26, although no compiler supports it yet.</p>
<h2 class="heading-2" id="_idParaDest-396">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using std::span for contiguous sequences of objects</em>, to learn how to use non-owning views over contiguous sequences of elements</li>
</ul>
<h1 class="heading-1" id="_idParaDest-397">Registering a function to be called when a program exits normally</h1>
<p class="normal">It is <a id="_idIndexMarker786"/>common that a program, upon exit, must clean up code to release resources, write something to a log, or do some other end operation. The standard library provides two utility functions that enable us to register functions to be called when a program terminates normally, either by returning from <code class="inlineCode">main()</code> or through a call to <code class="inlineCode">std::exit()</code> or <code class="inlineCode">std::quick_exit()</code>. This is particularly useful for libraries that need to perform an action before the program is terminated, without relying on the user to explicitly call an end function. In this recipe, you will learn how to install exit handlers and how they work.</p>
<h2 class="heading-2" id="_idParaDest-398">Getting ready</h2>
<p class="normal">All the functions discussed in this recipe, <code class="inlineCode">exit()</code>, <code class="inlineCode">quick_exit()</code>, <code class="inlineCode">atexit()</code>, and <code class="inlineCode">at_quick_exit()</code>, are available in the namespace <code class="inlineCode">std</code> in the header <code class="inlineCode">&lt;cstdlib&gt;</code>.</p>
<h2 class="heading-2" id="_idParaDest-399">How to do it...</h2>
<p class="normal">To register functions to be called upon termination of a program, you should use the following:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::atexit()</code> to register functions to be invoked when they return from <code class="inlineCode">main()</code> or when a call to <code class="inlineCode">std::exit()</code> is made:
        <pre class="programlisting code"><code class="hljs-code">void exit_handler_1()
{
  std::cout &lt;&lt; "exit handler 1" &lt;&lt; '\n';
}
void exit_handler_2()
{
  std::cout &lt;&lt; "exit handler 2" &lt;&lt; '\n';
}
std::atexit(exit_handler_1);
std::atexit(exit_handler_2);
std::atexit([]() {std::cout &lt;&lt; "exit handler 3" &lt;&lt; '\n'; });
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">std::at_quick_exit()</code> to register functions to be invoked when a call to <code class="inlineCode">std::quick_exit()</code> is made:
        <pre class="programlisting code"><code class="hljs-code">void quick_exit_handler_1()
{
  std::cout &lt;&lt; "quick exit handler 1" &lt;&lt; '\n';
}
void quick_exit_handler_2()
{
  std::cout &lt;&lt; "quick exit handler 2" &lt;&lt; '\n';
}
std::at_quick_exit(quick_exit_handler_1);
std::at_quick_exit(quick_exit_handler_2);
std::at_quick_exit([]() {
  std::cout &lt;&lt; "quick exit handler 3" &lt;&lt; '\n'; });
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-400">How it works...</h2>
<p class="normal">The<a id="_idIndexMarker787"/> exit handlers, regardless of the method they are registered with, are called only when the program terminates normally or quickly. If termination is done in an abnormal way, via a call to <code class="inlineCode">std::terminate()</code> or <code class="inlineCode">std::abort()</code>, none of them are called. If any of these handlers exits via an exception, then <code class="inlineCode">std::terminate()</code> is called. Exit handlers must not have any parameters and must return <code class="inlineCode">void</code>. Once registered, an exit handler cannot be unregistered.</p>
<p class="normal">A program can install multiple handlers. The standard guarantees that at least 32 handlers can be registered with each method, although actual implementations can support any higher number. Both <code class="inlineCode">std::atexit()</code> and <code class="inlineCode">std::at_quick_exit()</code> are thread-safe and, therefore, can be called simultaneously from different threads without incurring race conditions.</p>
<p class="normal">If multiple handlers are registered, then they are called in the reverse order of their registration. The following table shows the output of a program that registered the exit handlers, as shown in the previous section, when the program terminates via a <code class="inlineCode">std::exit()</code> call and a <code class="inlineCode">std::quick_exit()</code> call:</p>
<table class="table-container" id="table007-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::exit(0);</code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode">std::quick_exit(0);</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<pre class="programlisting con"><code class="hljs-con">exit handler 3
exit handler 2
exit handler 1
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting con"><code class="hljs-con">quick exit handler 3
quick exit handler 2
quick exit handler 1
</code></pre>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 6.7: Output of the previous snippet when exiting because of a call to exit() and quick_exit()</p>
<p class="normal">On the <a id="_idIndexMarker788"/>other hand, on normal termination of the program, destruction of objects with local storage duration, destruction of objects with static storage duration, and calls to registered exit handlers are done concurrently. However, it is guaranteed that exit handlers registered before the construction of a static object are called after the destruction of that static object, and exit handlers registered after the construction of a static object are called before the destruction of that static object. </p>
<p class="normal">To better exemplify this, let’s consider the following class:</p>
<pre class="programlisting code"><code class="hljs-code">struct static_foo
{
  ~static_foo() { std::cout &lt;&lt; "static foo destroyed!" &lt;&lt; '\n'; }
  static static_foo* instance()
 {
    static static_foo obj;
    return &amp;obj;
  }
};
</code></pre>
<p class="normal">In this context, we will refer to the following code snippet:</p>
<pre class="programlisting code"><code class="hljs-code">std::atexit(exit_handler_1);
static_foo::instance();
std::atexit(exit_handler_2);
std::atexit([]() {std::cout &lt;&lt; "exit handler 3" &lt;&lt; '\n'; });
std::exit(42);
</code>
exit_handler_1</code> is registered before the creation of the static object <code class="inlineCode">static_foo</code>. On the other hand, <code class="inlineCode">exit_handler_2</code> and the lambda expression are both registered, in that order, after the static object was constructed. As a result, the order of calls at normal termination is as follows:</pre>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Lambda expression</li>
<li class="numberedList"><code class="inlineCode">exit_handler_2</code></li>
<li class="numberedList">Destructor of <code class="inlineCode">static_foo</code></li>
<li class="numberedList"><code class="inlineCode">exit_handler_1</code></li>
</ol>
<p class="normal">The<a id="_idIndexMarker789"/> output for the preceding program is listed here:</p>
<pre class="programlisting con"><code class="hljs-con">exit handler 3
exit handler 2
static foo destroyed!
exit handler 1
</code></pre>
<p class="normal">When <code class="inlineCode">std::at_quick_exit()</code> is used, the registered functions are not called in the case of normal program termination. If a function needs to be called in that case, you must register it with <code class="inlineCode">std::atexit()</code>.</p>
<h2 class="heading-2" id="_idParaDest-401">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 3</em>, <em class="italic">Using lambdas with standard algorithms</em>, to explore the basics of lambda expressions and how you can utilize them with the standard algorithms</li>
</ul>
<h1 class="heading-1" id="_idParaDest-402">Using type traits to query properties of types</h1>
<p class="normal">Template <a id="_idIndexMarker790"/>metaprogramming is a powerful feature of the language that enables us to write and reuse generic code that works with all types. In practice, however, it is often necessary that generic code should work differently, or not at all, with different types, either through intent or for semantic correctness, performance, or other reasons. For example, you may want a generic algorithm to be implemented differently for POD and non-POD types or a function template to be instantiated only with integral types. C++11 provides a set of type traits to help with this.</p>
<p class="normal">Type traits are basically meta-types that provide information about other types. The type traits library contains a long list of traits for querying type properties (such as checking whether a type is an integral type or whether two types are the same), but also for performing type transformation (such as removing the <code class="inlineCode">const</code> and <code class="inlineCode">volatile</code> qualifiers or adding a pointer to a type). We have used type traits in several recipes earlier in this book; however, in this recipe, we will look into what the type traits are and how they work.</p>
<h2 class="heading-2" id="_idParaDest-403">Getting ready</h2>
<p class="normal">All type traits introduced in C++11 are available in the namespace <code class="inlineCode">std</code> in the <code class="inlineCode">&lt;type_traits&gt;</code> header.</p>
<p class="normal">Type traits <a id="_idIndexMarker791"/>can be used in many metaprogramming contexts, and throughout this book, we have seen them used in various situations. In this recipe, we will summarize some of these use cases and see how type traits work.</p>
<p class="normal">In this recipe, we will discuss full and partial template specialization. Familiarity with these concepts will help you better understand the way type traits work.</p>
<h2 class="heading-2" id="_idParaDest-404">How to do it...</h2>
<p class="normal">The following list shows various situations where type traits are used to achieve various design goals:</p>
<ul>
<li class="bulletList">With <code class="inlineCode">enable_if</code> to define preconditions for the types a function template can be instantiated with:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T,
          typename = typename std::enable_if_t&lt;
                std::is_arithmetic_v&lt;T&gt; &gt; &gt;
T multiply(T const t1, T const t2)
{
  return t1 * t2;
}
auto v1 = multiply(42.0, 1.5);     // OK
auto v2 = multiply("42"s, "1.5"s); // error
</code></pre>
</li>
<li class="bulletList">With <code class="inlineCode">static_assert</code> to ensure that invariants are met:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
struct pod_wrapper
{
  static_assert(std::is_standard_layout_v&lt;T&gt; &amp;&amp;
                std::is_trivial_v&lt;T&gt;,
                "Type is not a POD!");
  T value;
};
pod_wrapper&lt;int&gt; i{ 42 };            // OK
pod_wrapper&lt;std::string&gt; s{ "42"s }; // error
</code></pre>
</li>
<li class="bulletList">With <code class="inlineCode">std::conditional</code> to select between types:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
struct const_wrapper
{
  typedef typename std::conditional_t&lt;
            std::is_const_v&lt;T&gt;,
            T,
            typename std::add_const_t&lt;T&gt;&gt; const_type;
};
static_assert(
  std::is_const_v&lt;const_wrapper&lt;int&gt;::const_type&gt;);
static_assert(
  std::is_const_v&lt;const_wrapper&lt;int const&gt;::const_type&gt;);
</code></pre>
</li>
<li class="bulletList">With <code class="inlineCode">constexpr if</code> to enable the compiler to generate different code based on the <a id="_idIndexMarker792"/>type the template is instantiated with:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
auto process(T arg)
{
  if constexpr (std::is_same_v&lt;T, bool&gt;)
 return !arg;
  else if constexpr (std::is_integral_v&lt;T&gt;)
    return -arg;
  else if constexpr (std::is_floating_point_v&lt;T&gt;)
    return std::abs(arg);
  else
return arg;
}
auto v1 = process(false); // v1 = true
auto v2 = process(42);    // v2 = -42
auto v3 = process(-42.0); // v3 = 42.0
auto v4 = process("42"s); // v4 = "42"
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-405">How it works...</h2>
<p class="normal">Type traits are classes that provide meta-information about types or can be used to modify types. There are actually two categories of type traits:</p>
<ul>
<li class="bulletList">Traits that provide information about types, their properties, or their relations (such as <code class="inlineCode">is_integer</code>, <code class="inlineCode">is_arithmetic</code>, <code class="inlineCode">is_array</code>, <code class="inlineCode">is_enum</code>, <code class="inlineCode">is_class</code>, <code class="inlineCode">is_const</code>, <code class="inlineCode">is_trivial</code>, <code class="inlineCode">is_standard_layout</code>, <code class="inlineCode">is_constructible</code>, <code class="inlineCode">is_same</code>, and so on). These traits provide a constant <code class="inlineCode">bool</code> member called <code class="inlineCode">value</code>.</li>
<li class="bulletList">Traits that modify properties of types (such as <code class="inlineCode">add_const</code>, <code class="inlineCode">remove_const</code>, <code class="inlineCode">add_pointer</code>, <code class="inlineCode">remove_pointer</code>, <code class="inlineCode">make_signed</code>, <code class="inlineCode">make_unsigned</code>, and so on). These traits provide a member typedef called <code class="inlineCode">type</code> that represents the transformed type.</li>
</ul>
<p class="normal">Both of these<a id="_idIndexMarker793"/> categories of types have been shown in the <em class="italic">How to do it...</em> section; examples have been discussed and explained in detail in other recipes. For convenience, a short summary is provided here:</p>
<ul>
<li class="bulletList">In the first example, the function template <code class="inlineCode">multiply()</code> is allowed to be instantiated only with arithmetic types (that is, integral or floating point); when instantiated with a different kind of type, <code class="inlineCode">enable_if</code> does not define a typedef member called <code class="inlineCode">type</code>, which produces a compilation error.</li>
<li class="bulletList">In the second example, <code class="inlineCode">pod_wrapper</code> is a class template that is supposed to be instantiated only with POD types. A <code class="inlineCode">static_assert</code> declaration produces a compilation error if a non-POD type is used (it is either not trivial or not in the standard layout).</li>
<li class="bulletList">In the third example, <code class="inlineCode">const_wrapper</code> is a class template that provides a typedef member called <code class="inlineCode">const_type</code> that represents a constant-qualified type.</li>
<li class="bulletList">In this example, we used <code class="inlineCode">std::conditional</code> to select between two types at compile time: if the type parameter <code class="inlineCode">T</code> is already a const type, then we just select <code class="inlineCode">T</code>. Otherwise, we use the <code class="inlineCode">add_const</code> type trait to qualify the type with the <code class="inlineCode">const</code> specifier.</li>
<li class="bulletList">If the fourth example, <code class="inlineCode">process()</code> is a function template that contains a series of <code class="inlineCode">if constexpr</code> branches. Based on the category of type, queried at compile time with various type traits (<code class="inlineCode">is_same</code>, <code class="inlineCode">is_integer</code>, <code class="inlineCode">is_floating_point</code>), the compiler selects one branch only to be put into the generated code and discards the rest. Therefore, a call such as <code class="inlineCode">process(42)</code> will produce the following instantiation of the function template:
        <pre class="programlisting code"><code class="hljs-code">int process(int arg)
{
  return -arg;
}
</code></pre>
</li>
</ul>
<p class="normal">Type traits<a id="_idIndexMarker794"/> are implemented by providing a class template and a partial or full specialization for it. The following represent conceptual implementations for some type traits:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">is_void()</code> method indicates whether a type is <code class="inlineCode">void</code>; this uses full specialization:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
struct is_void
{ static const bool value = false; };
template &lt;&gt;
struct is_void&lt;void&gt;
{ static const bool value = true; };
</code></pre>
</li>
<li class="bulletList">The <code class="inlineCode">is_pointer()</code> method indicates whether a type is a pointer to an object or a pointer to a function; this uses partial specialization:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
struct is_pointer
{ static const bool value = false; };
template &lt;typename T&gt;
struct is_pointer&lt;T*&gt;
{ static const bool value = true; };
</code></pre>
</li>
<li class="bulletList">The <code class="inlineCode">enable_if()</code> type trait defines a type alias for its type template parameter if and only if its non-type template parameter is an expression that evaluates to <code class="inlineCode">true</code>:
        <pre class="programlisting code"><code class="hljs-code">template&lt;bool B, typename T = void&gt;
struct enable_if {};
template&lt;typename T&gt;
struct enable_if&lt;true, T&gt; { using type = T; };
</code></pre>
</li>
</ul>
<p class="normal">Because the use of the <code class="inlineCode">bool</code> member <code class="inlineCode">value</code> for the traits of query properties (such as <code class="inlineCode">std::is_integer&lt;int&gt;::value</code>), or for the member types alias called <code class="inlineCode">type</code> for traits that modify type properties (such as <code class="inlineCode">std::enable_if&lt;true, T&gt;::type</code>) is too verbose (and long), the C++14 and C++17 standards have introduced some helpers to simplify the use:</p>
<ul>
<li class="bulletList">A variable template of the form <code class="inlineCode">std::trait_v&lt;T&gt;</code> for <code class="inlineCode">std::trait&lt;T&gt;::value</code>. An example is <code class="inlineCode">std::is_integer_v&lt;T&gt;</code>, which is defined as follows:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
inline constexpr bool is_integral_v = is_integral&lt;T&gt;::value;
</code></pre>
</li>
<li class="bulletList">An alias template of the form <code class="inlineCode">std::trait_t&lt;T&gt;</code> for <code class="inlineCode">std::trait&lt;T&gt;::type</code>. An example is <code class="inlineCode">std::enable_if_t&lt;B, T&gt;</code>, which is defined as follows:
        <pre class="programlisting code"><code class="hljs-code">template &lt;bool B, typename T = void&gt;
using enable_if_t = typename enable_if&lt;B,T&gt;::type;
</code></pre>
</li>
</ul>
<p class="normal">Note <a id="_idIndexMarker795"/>that, in C++20, the concept of the POD type has been deprecated. This also includes the deprecation of the <code class="inlineCode">std::is_pod</code> type trait. A POD type is a type that is both <em class="italic">trivial</em> (has special members that are compiler-provided or explicitly defaulted and occupy a contiguous memory area) and has a <em class="italic">standard layout</em> (a class that does not contain language features, such as virtual functions, which are incompatible with the C language, and all members have the same access control). Therefore, as of C++20, the more fine-grained concepts of trivial and standard layout types are preferred. This also implies that you should no longer use <code class="inlineCode">std::is_pod</code>, but <code class="inlineCode">std::is_trivial</code> and, respectively, <code class="inlineCode">std::is_standard_layout</code>.</p>
<h2 class="heading-2" id="_idParaDest-406">There’s more...</h2>
<p class="normal">Type traits are not limited to what the standard library provides. Using similar techniques, you can define your own type traits to achieve various goals. In the next recipe, <em class="italic">Writing your own type traits</em>, we will learn how to define and use our own type traits.</p>
<h2 class="heading-2" id="_idParaDest-407">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 4</em>, <em class="italic">Selecting branches at compile time with constexpr if</em>, to learn how to compile only parts of your code with <em class="italic">constexpr if</em> statements</li>
<li class="bulletList"><em class="chapterRef">Chapter 4</em>, <em class="italic">Conditionally compiling classes and functions with enable_if</em>, to learn about SFINAE and how to use it to specify type constraints for templates</li>
<li class="bulletList"><em class="chapterRef">Chapter 4</em>, <em class="italic">Performing compile-time assertion checks with static_assert</em>, to see how to define assertions that are verified at compile time</li>
<li class="bulletList"><em class="italic">Writing your own type traits</em>, to learn how to define your own type traits</li>
<li class="bulletList"><em class="italic">Using std::conditional to choose between types</em>, to understand how to perform a compile-time selection of types on a compile-time Boolean expression</li>
</ul>
<h1 class="heading-1" id="_idParaDest-408">Writing your own type traits</h1>
<p class="normal">In the <a id="_idIndexMarker796"/>previous recipe, we learned what type traits are, what traits the standard provides, and how they can be used for various purposes. In this recipe, we’ll go a step further and take a look at how to define our own custom traits.</p>
<h2 class="heading-2" id="_idParaDest-409">Getting ready</h2>
<p class="normal">In this recipe, we will learn how to solve the following problem: we have several classes that support serialization. Without getting into any details, let’s suppose some provide a “plain” serialization to a string (regardless of what that can mean), whereas others do it based on a specified encoding. The end goal is to create a single, uniform API for serializing the objects of any of these types. For this, we will consider the following two classes: <code class="inlineCode">foo</code>, which provides a simple serialization, and <code class="inlineCode">bar</code>, which provides serialization with encoding. </p>
<p class="normal">Let’s look at the code:</p>
<pre class="programlisting code"><code class="hljs-code">struct foo
{
  std::string serialize()
 {
    return "plain"s;
  }
};
struct bar
{
  std::string serialize_with_encoding()
 {
    return "encoded"s;
  }
};
</code></pre>
<p class="normal">It is recommended<a id="_idIndexMarker797"/> that you read the preceding <em class="italic">Using type traits to query properties of types</em> recipe first before you continue with this one.</p>
<h2 class="heading-2" id="_idParaDest-410">How to do it...</h2>
<p class="normal">Implement the following class and function templates:</p>
<ul>
<li class="bulletList">A class template called <code class="inlineCode">is_serializable_with_encoding</code> containing a <code class="inlineCode">static</code> <code class="inlineCode">const</code> <code class="inlineCode">bool</code> variable set to <code class="inlineCode">false</code>:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
struct is_serializable_with_encoding
{
  static const bool value = false;
};
</code></pre>
</li>
<li class="bulletList">A full specialization of the <code class="inlineCode">is_serializable_with_encoding</code> template for the class <code class="inlineCode">bar</code> that has the <code class="inlineCode">static</code> <code class="inlineCode">const</code> <code class="inlineCode">bool</code> variable set to <code class="inlineCode">true</code>:
        <pre class="programlisting code"><code class="hljs-code">template &lt;&gt;
struct is_serializable_with_encoding&lt;bar&gt;
{
  static const bool value = true;
};
</code></pre>
</li>
<li class="bulletList">A class template called <code class="inlineCode">serializer</code> containing a static template method called <code class="inlineCode">serialize</code>, which takes an argument of the template type <code class="inlineCode">T</code> and calls <code class="inlineCode">serialize()</code> for that object:
        <pre class="programlisting code"><code class="hljs-code">template &lt;bool b&gt;
struct serializer
{
  template &lt;typename T&gt;
  static auto serialize(T&amp; v)
 {
    return v.serialize();
  }
};
</code></pre>
</li>
<li class="bulletList">A full<a id="_idIndexMarker798"/> specialization class template for <code class="inlineCode">true</code>, whose <code class="inlineCode">serialize()</code> static method calls <code class="inlineCode">serialize_with_encoding()</code> for the argument:
        <pre class="programlisting code"><code class="hljs-code">template &lt;&gt;
struct serializer&lt;true&gt;
{
  template &lt;typename T&gt;
  static auto serialize(T&amp; v)
 {
    return v.serialize_with_encoding();
  }
};
</code></pre>
</li>
<li class="bulletList">A function template called <code class="inlineCode">serialize()</code>, which uses the <code class="inlineCode">serializer</code> class templates defined previously and the <code class="inlineCode">is_serializable_with_encoding</code> type trait, to select which of the actual serialization methods (plain or with encoding) should be called:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
auto serialize(T&amp; v)
{
  return serializer&lt;is_serializable_with_encoding&lt;T&gt;::value&gt;::
    serialize(v);
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-411">How it works...</h2>
<p class="normal"><code class="inlineCode">is_serializable_with_encoding</code> is a type trait that checks whether a type <code class="inlineCode">T</code> is serializable with (a specified) encoding. It provides a static member of the type <code class="inlineCode">bool</code> called <code class="inlineCode">value</code> that is equal to <code class="inlineCode">true</code> if <code class="inlineCode">T</code> supports serialization with encoding, or <code class="inlineCode">false</code> otherwise. It is implemented as a class template with a single type template parameter <code class="inlineCode">T</code>; this class template is fully specialized for the types that support encoded serialization—in this particular example—for the class <code class="inlineCode">bar</code>:</p>
<pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::boolalpha;
std::cout &lt;&lt;
  is_serializable_with_encoding&lt;foo&gt;::value &lt;&lt; '\n';        // false
std::cout &lt;&lt;
  is_serializable_with_encoding&lt;bar&gt;::value &lt;&lt; '\n';        // true
std::cout &lt;&lt;
  is_serializable_with_encoding&lt;int&gt;::value &lt;&lt; '\n';        // false
std::cout &lt;&lt;
  is_serializable_with_encoding&lt;std::string&gt;::value &lt;&lt; '\n';// false
std::cout &lt;&lt; std::boolalpha;
</code></pre>
<p class="normal">The <code class="inlineCode">serialize()</code> method is a function template that represents a common API for serializing objects that support either type of serialization. It takes a single argument of the type template parameter <code class="inlineCode">T</code> and uses a helper class template <code class="inlineCode">serializer</code> to call either the <code class="inlineCode">serialize()</code> or <code class="inlineCode">serialize_with_encoding()</code> method of its argument.</p>
<p class="normal">The <code class="inlineCode">serializer</code> type is a<a id="_idIndexMarker799"/> class template with a single, non-type template parameter of the type <code class="inlineCode">bool</code>. This class template contains a static function template called <code class="inlineCode">serialize()</code>. This function template takes a single parameter of the type template parameter <code class="inlineCode">T</code>, calls <code class="inlineCode">serialize()</code> on the argument, and returns the value returned from that call. The <code class="inlineCode">serializer</code> class template has a full specialization for the value <code class="inlineCode">true</code> of its non-type template parameter. In this specialization, the function template <code class="inlineCode">serialize()</code> has an unchanged signature, but calls <code class="inlineCode">serialize_with_encoding()</code> instead of <code class="inlineCode">serialize()</code>.</p>
<p class="normal">The selection between using the generic or the fully specialized class template is done in the <code class="inlineCode">serialize()</code> function template using the <code class="inlineCode">is_serializable_with_encoding</code> type trait. The static member <code class="inlineCode">value</code> of the type trait is used as the argument for the non-type template parameter of <code class="inlineCode">serializer</code>.</p>
<p class="normal">With all that defined, we can write the following code:</p>
<pre class="programlisting code"><code class="hljs-code">foo f;
bar b;
std::cout &lt;&lt; serialize(f) &lt;&lt; '\n'; // plain
std::cout &lt;&lt; serialize(b) &lt;&lt; '\n'; // encoded
</code>
serialize()</code> with a <code class="inlineCode">foo</code> argument will return the string <em class="italic">plain</em>, while calling <code class="inlineCode">serialize()</code> with a <code class="inlineCode">bar</code> argument will return the string <em class="italic">encoded</em>.</pre>
<h2 class="heading-2" id="_idParaDest-412">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using type traits to query properties of types</em>, to explore a C++ meta-programming technique that allows us to inspect and transform properties of types</li>
<li class="bulletList"><em class="italic">Using std::conditional to choose between types</em>, to understand how to perform a compile-time selection of types on a compile-time Boolean expression</li>
</ul>
<h1 class="heading-1" id="_idParaDest-413">Using std::conditional to choose between types</h1>
<p class="normal">In the <a id="_idIndexMarker800"/>previous recipes, we looked at some of the features from the type support library, and type traits in particular. Related topics have been discussed in other parts of this book, such as using <code class="inlineCode">std::enable_if</code> to hide function overloads in <em class="chapterRef">Chapter 4</em>, <em class="italic">Preprocessing and Compilation</em>, and <code class="inlineCode">std::decay</code> to remove <code class="inlineCode">const</code> and <code class="inlineCode">volatile</code> qualifiers when we discussed visiting variants, also in this chapter. Another type transformation feature worth discussing to a larger extent is <code class="inlineCode">std::conditional</code>, which enables us to choose between two types at compile time, based on a compile-time Boolean expression. In this recipe, you will learn how it works and how to use it through several examples.</p>
<h2 class="heading-2" id="_idParaDest-414">Getting ready</h2>
<p class="normal">It is recommended that you first read the <em class="italic">Using type traits to query properties of types</em> recipe, earlier in this chapter.</p>
<h2 class="heading-2" id="_idParaDest-415">How to do it...</h2>
<p class="normal">The following is a list of examples that show you how to use <code class="inlineCode">std::conditional</code> (and <code class="inlineCode">std::conditional_t</code>), available in the <code class="inlineCode">&lt;type_traits&gt;</code> header, to choose between two types at compile time:</p>
<ul>
<li class="bulletList">In a type alias or typedef to select between a 32-bit and 64-bit integer type, based on the platform (the pointer size is 4 bytes on 32-bit platforms and 8 bytes on 64-bit platforms):
        <pre class="programlisting code"><code class="hljs-code">using long_type = std::conditional_t&lt;
    sizeof(void*) &lt;= 4, long, long long&gt;;
auto n = long_type{ 42 };
</code></pre>
</li>
<li class="bulletList">In an alias template to select between an 8-, 16-, 32-, or 64-bit integer type, based on the user specification (as a non-type template parameter):
        <pre class="programlisting code"><code class="hljs-code">template &lt;int size&gt;
using number_type =
  typename std::conditional_t&lt;
    size&lt;=1,
    std::int8_t,
    typename std::conditional_t&lt;
      size&lt;=2,
      std::int16_t,
      typename std::conditional_t&lt;
        size&lt;=4,
        std::int32_t,
        std::int64_t
      &gt;
    &gt;
  &gt;;
auto n = number_type&lt;2&gt;{ 42 };
static_assert(sizeof(number_type&lt;1&gt;) == 1);
static_assert(sizeof(number_type&lt;2&gt;) == 2);
static_assert(sizeof(number_type&lt;3&gt;) == 4);
static_assert(sizeof(number_type&lt;4&gt;) == 4);
static_assert(sizeof(number_type&lt;5&gt;) == 8);
static_assert(sizeof(number_type&lt;6&gt;) == 8);
static_assert(sizeof(number_type&lt;7&gt;) == 8);
static_assert(sizeof(number_type&lt;8&gt;) == 8);
static_assert(sizeof(number_type&lt;9&gt;) == 8);
</code></pre>
</li>
<li class="bulletList">In a type<a id="_idIndexMarker801"/> template parameter to select between an integer and real uniform distribution, depending on whether the type template parameter is of an integral or floating-point type:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T,
          typename D = std::conditional_t&lt;
                         std::is_integral_v&lt;T&gt;,
                         std::uniform_int_distribution&lt;T&gt;,
                         std::uniform_real_distribution&lt;T&gt;&gt;,
          typename = typename std::enable_if_t&lt;
                         std::is_arithmetic_v&lt;T&gt;&gt;&gt;
std::vector&lt;T&gt; GenerateRandom(T const min, T const max,
                              size_t const size)
{
  std::vector&lt;T&gt; v(size);
  std::random_device rd{};
  std::mt19937 mt{ rd() };
  D dist{ min, max };
  std::generate(std::begin(v), std::end(v),
    [&amp;dist, &amp;mt] {return dist(mt); });
  return v;
}
auto v1 = GenerateRandom(1, 10, 10);     // integers
auto v2 = GenerateRandom(1.0, 10.0, 10); // doubles
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-416">How it works...</h2>
<p class="normal"><code class="inlineCode">std::conditional</code> is a class template that defines a member called <code class="inlineCode">type</code> as either one or the other<a id="_idIndexMarker802"/> of its two type template parameters. This selection is done based on a compile-time constant Boolean expression provided as an argument for a non-type template parameter. Its implementation looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;bool Test, class T1, class T2&gt;
struct conditional
{
  typedef T2 type;
};
template&lt;class T1, class T2&gt;
struct conditional&lt;true, T1, T2&gt;
{
  typedef T1 type;
};
</code></pre>
<p class="normal">Let’s summarize the examples from the previous section:</p>
<ul>
<li class="bulletList">In the first example, if the platform is 32-bit, then the size of the pointer type is 4 bytes and, therefore, the compile-time expression <code class="inlineCode">sizeof(void*) &lt;= 4</code> is <code class="inlineCode">true</code>; as a result, <code class="inlineCode">std::conditional</code> defines its member type as <code class="inlineCode">long</code>. If the platform is 64-bit, then the condition evaluates to <code class="inlineCode">false</code> because the size of the pointer type is 8 bytes; therefore, the member type is defined as <code class="inlineCode">long long</code>.</li>
<li class="bulletList">A similar situation is encountered in the second example, where <code class="inlineCode">std::conditional</code> is used multiple times to emulate a series of <code class="inlineCode">if...else</code> statements to select an appropriate type.</li>
<li class="bulletList">In the third example, we used the alias template <code class="inlineCode">std::conditional_t</code> to simplify the declaration of the function template <code class="inlineCode">GenerateRandom</code>. Here, <code class="inlineCode">std::conditional</code> is used to define the default value for a type template parameter representing a statistical distribution. Depending on whether the first type template parameter <code class="inlineCode">T</code> is an integral or floating-point type, the default distribution type is chosen between <code class="inlineCode">std::uniform_int_distribution&lt;T&gt;</code> and <code class="inlineCode">std::uniform_real_distribution&lt;T&gt;</code>. The use of other types is disabled by employing <code class="inlineCode">std::enable_if</code> with a third template parameter, as we have seen in other recipes already.</li>
</ul>
<p class="normal">To help <a id="_idIndexMarker803"/>simplify the use of <code class="inlineCode">std::conditional</code>, C++14 provides an alias template called <code class="inlineCode">std::conditional_t</code>, which we have seen in the examples here, and which is defined as follows:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;bool Test, class T1, class T2&gt;
using conditional_t = typename conditional_t&lt;Test,T1,T2&gt;;
</code></pre>
<p class="normal">The use of this helper class (and the many others that are similar and from the standard library) is optional but helps with writing more concise code.</p>
<h2 class="heading-2" id="_idParaDest-417">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using type traits to query properties of types</em>, to explore a C++ metaprogramming technique that allows us to inspect and transform properties of types</li>
<li class="bulletList"><em class="italic">Writing your own type traits</em>, to learn how to define your own type traits</li>
<li class="bulletList"><em class="chapterRef">Chapter 4</em>, <em class="italic">Conditionally compiling classes and functions with enable_if</em>, to learn about SFINAE and how to use it to specify type constraints for templates</li>
</ul>
<h1 class="heading-1" id="_idParaDest-418">Providing logging details with source_location</h1>
<p class="normal">Debugging is an <a id="_idIndexMarker804"/>essential part of software development. No matter how simple or complex it is, no program works as intended from the first shot. Therefore, developers spend a considerable amount of time debugging their code, employing various tools and techniques from debuggers to messages<a id="_idIndexMarker805"/> printed to a console or a text file. Sometimes, we want to provide detailed information about the source of a message in a log, including the file, the line, and maybe the function name. Although this was possible with some standard macros, in C++20, a new utility type called <code class="inlineCode">std::source_location</code> allows us to do it in a modern way. In this recipe, we will learn how.</p>
<h2 class="heading-2" id="_idParaDest-419">How to do it…</h2>
<p class="normal">To log information including the file name, line number, and function name, do the following:</p>
<ul>
<li class="bulletList">Define a logging function with parameters for all information that you need to provide (such as message, severity, etc.).</li>
<li class="bulletList">Add one additional parameter of the type <code class="inlineCode">std::source_location</code> (for which you have to include the <code class="inlineCode">&lt;source_location&gt;</code> header) with the default value <code class="inlineCode">std::source_location::current()</code>.</li>
<li class="bulletList">Use member functions <code class="inlineCode">file_name()</code>, <code class="inlineCode">line()</code>, <code class="inlineCode">column()</code>, and <code class="inlineCode">function_name()</code> to retrieve information about the source of the invocation.</li>
</ul>
<p class="normal">An example of such a logging function is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">void log(std::string_view message, 
         std::source_location const location = std::source_location::current())
{
   std::cout   &lt;&lt; location.file_name() &lt;&lt; '('
               &lt;&lt; location.line() &lt;&lt; ':'
               &lt;&lt; location.column() &lt;&lt; ") '"
               &lt;&lt; location.function_name() &lt;&lt; "': "
               &lt;&lt; message &lt;&lt; '\n';
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-420">How it works…</h2>
<p class="normal">Before C++20, logging information <a id="_idIndexMarker806"/>such as source file, line, and function name was only possible with the help of several macros:</p>
<ul>
<li class="bulletList"><code class="inlineCode">__FILE__</code>, which expands to the name of the current file</li>
<li class="bulletList"><code class="inlineCode">__LINE__</code>, which expands to the source file line number</li>
</ul>
<p class="normal">In<a id="_idIndexMarker807"/> addition, all compilers supported non-standard macros including <code class="inlineCode">__func__</code> / <code class="inlineCode">__FUNCTION__</code>, which provide the name of the current function.</p>
<p class="normal">Using these macros, one could write the following logging function:</p>
<pre class="programlisting code"><code class="hljs-code">void log(std::string_view message, 
         std::string_view file, 
 int line, 
         std::string_view function)
{
   std::cout &lt;&lt; file &lt;&lt; '('
             &lt;&lt; line &lt;&lt; ") '"
             &lt;&lt; function &lt;&lt; "': "
             &lt;&lt; message &lt;&lt; '\n';
}
</code></pre>
<p class="normal">The macros, however, must be used from the context of the function execution, as shown in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">int main()
{
   log("This is a log entry!", __FILE__, __LINE__, __FUNCTION__);
}
</code></pre>
<p class="normal">The result of running this function would look as follows on the console:</p>
<pre class="programlisting con"><code class="hljs-con">[...]\source.cpp(23) 'main': This is a log entry!
</code></pre>
<p class="normal">The C++20 <code class="inlineCode">std::source_line</code> is a better alternative for several reasons:</p>
<ul>
<li class="bulletList">You no longer have to rely on macros.</li>
<li class="bulletList">It includes information about the column, not just the line.</li>
<li class="bulletList">It can be used in the logging function signature, simplifying the invocation of the call.</li>
</ul>
<p class="normal">The <code class="inlineCode">log()</code> function defined in the <em class="italic">How to do it…</em> section can be invoked as follows:</p>
<pre class="programlisting code"><code class="hljs-code">int main()
{
   log("This is a log entry!");
}
</code></pre>
<p class="normal">This results in the following output:</p>
<pre class="programlisting con"><code class="hljs-con">[...]\source.cpp(23:4) 'int __cdecl main(void)': This is a log entry!
</code></pre>
<p class="normal">Although<a id="_idIndexMarker808"/> a default constructor exists, it initializes the data with default values. To get the correct values, you must invoke <a id="_idIndexMarker809"/>the static member function <code class="inlineCode">current()</code>. This function works as follows:</p>
<ul>
<li class="bulletList">When invoked directly in a function call, it initializes the data with information about the location of the call.</li>
<li class="bulletList">When used in a default member initializer, it initializes the data with information about the location of the constructor aggregate initialization that initializes the data member.</li>
<li class="bulletList">When used in a default argument (such as in the example shown here), it initializes the data with the location of the call site (function invocation).</li>
<li class="bulletList">When used in another context, the behavior is undefined.</li>
</ul>
<p class="normal">It must be noted that the preprocessor directive <code class="inlineCode">#line</code> changes the source code line number and the file name. This affects the value returned by the macros <code class="inlineCode">__FILE__</code> and <code class="inlineCode">__LINE__</code>. The <code class="inlineCode">std::source_location</code> is affected in the same manner as the standard macros by the <code class="inlineCode">#line</code> directive.</p>
<h2 class="heading-2" id="_idParaDest-421">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using the stacktrace library to print the call stack</em>, to learn how to walk or print the content of the current stack trace</li>
</ul>
<h1 class="heading-1" id="_idParaDest-422">Using the stacktrace library to print the call sequence</h1>
<p class="normal">In the <a id="_idIndexMarker810"/>previous recipe, we saw how to <a id="_idIndexMarker811"/>use the C++20 <code class="inlineCode">std::source_location</code> to provide information about a source location for logging, testing, and debugging purposes. Another mechanism for debugging is represented by asserts but these are not always enough because we often need to know the sequence of calls that led to a point of execution. This is called the stack trace. The C++23 standard contains a new library with diagnostics utilities. This allows us to print the stack trace. In this recipe, you will learn how to use these diagnostics utilities.</p>
<h2 class="heading-2" id="_idParaDest-423">How to do it…</h2>
<p class="normal">You<a id="_idIndexMarker812"/> can use the C++23 stacktrace library to:</p>
<ul>
<li class="bulletList">Print the<a id="_idIndexMarker813"/> entire content of the stack trace:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::stacktrace::current() &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Iterate over each frame in the stack trace and print it:
        <pre class="programlisting code"><code class="hljs-code">for (auto const &amp; frame : std::stacktrace::current())
{
   std::cout &lt;&lt; frame &lt;&lt; '\n';
}
</code></pre>
</li>
<li class="bulletList">Iterate over each frame in the stack trace and retrieve information about it:
        <pre class="programlisting code"><code class="hljs-code">for (auto const&amp; frame : std::stacktrace::current())
{
   std::cout &lt;&lt; frame.source_file()
             &lt;&lt; "("&lt;&lt; frame.source_line() &lt;&lt; ")"
             &lt;&lt; ": " &lt;&lt; frame.description()
             &lt;&lt; '\n';
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-424">How it works…</h2>
<p class="normal">The new diagnostic utilities are available in a separate header called <code class="inlineCode">&lt;stacktrace&gt;</code>. This header contains the following two classes:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::basic_stacktrace</code>, which is a class template that represents a sequence container of stack trace entries. A type alias called <code class="inlineCode">std::stacktrace</code> is defined as <code class="inlineCode">std::basic_stacktrace&lt;std::allocator&lt;std::stacktrace_entry&gt;&gt;</code>.</li>
<li class="bulletList"><code class="inlineCode">std::stacktrace_entry</code>, which represents an evaluation in a stack trace.</li>
</ul>
<div><p class="normal">When discussing the call sequence, there are two terms that need to be correctly understood: <strong class="keyWord">call stack</strong> and <strong class="keyWord">stack trace</strong>. A call stack is the data structure used to store information about the active frames (calls) in a running program. A stack trace is a snapshot, at some moment in time, of the call stack.</p>
</div>
<p class="normal">Although <code class="inlineCode">std::basic_stacktrace</code> is a container, it is not meant to be instantiated and filled <a id="_idIndexMarker814"/>with stack entries by the user. There are <a id="_idIndexMarker815"/>no member functions for adding or removing elements to the stack trace sequence; however, there are member functions for element access (<code class="inlineCode">at()</code> and <code class="inlineCode">operator[]</code>) and checking the size (<code class="inlineCode">capacity()</code>, <code class="inlineCode">size()</code>, and <code class="inlineCode">max_size()</code>). In order to get a snapshot of the call stack, you must invoke the static member function <code class="inlineCode">current()</code>:</p>
<pre class="programlisting code"><code class="hljs-code">std::stacktrace trace = std::stacktrace::current();
</code></pre>
<p class="normal">The current trace can be printed in several ways:</p>
<ul>
<li class="bulletList">To an output stream using the overloaded <code class="inlineCode">operator&lt;&lt;</code>:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::stacktrace::current() &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">To a <code class="inlineCode">std::string</code> using the <code class="inlineCode">to_string()</code> member function:
        <pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; std::to_string(std::stacktrace::current()) 
          &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">Using a formatting function such as <code class="inlineCode">std::format()</code>. Keep in mind that no formatting specifier is allowed:
        <pre class="programlisting code"><code class="hljs-code">auto str = std::format("{}\n", std::stacktrace::current());
std::cout &lt;&lt; str;
</code></pre>
</li>
</ul>
<p class="normal">The following snippet shows an example of how a stack trace can be printed to the standard output:</p>
<pre class="programlisting code"><code class="hljs-code">int plus_one(int n)
{
   std::cout &lt;&lt; std::stacktrace::current() &lt;&lt; '\n';
   return n + 1;
}
int double_n_plus_one(int n)
{
   return plus_one(2 * n);
}
int main()
{
   std::cout &lt;&lt; double_n_plus_one(42) &lt;&lt; '\n';
}
</code></pre>
<p class="normal">The result of<a id="_idIndexMarker816"/> running this program would look different based on the compiler and target system, but the following is an example of possible output:</p>
<pre class="programlisting con"><code class="hljs-con">0&gt; [...]\main.cpp(24): chapter06!plus_one+0x4F
1&gt; [...]\main.cpp(37): chapter06!double_n_plus_one+0xE
2&gt; [...]\main.cpp(61): chapter06!main+0x5F
3&gt; D:\a\_work\1\s\src\vctools\crt\vcstartup\src\startup\exe_common.inl(78): chapter06!invoke_main+0x33
4&gt; D:\a\_work\1\s\src\vctools\crt\vcstartup\src\startup\exe_common.inl(288): chapter06!__scrt_common_main_seh+0x157
5&gt; D:\a\_work\1\s\src\vctools\crt\vcstartup\src\startup\exe_common.inl(331): chapter06!__scrt_common_main+0xD
6&gt; D:\a\_work\1\s\src\vctools\crt\vcstartup\src\startup\exe_main.cpp(17): chapter06!mainCRTStartup+0x8
7&gt; KERNEL32+0x17D59
8&gt; ntdll!RtlInitializeExceptionChain+0x6B
9&gt; ntdll!RtlClearBits+0xBF
</code></pre>
<p class="normal">For an <a id="_idIndexMarker817"/>entry in the trace, as seen above, we can identify three parts: the source file, the line number, and a description of the evaluation. These are highlighted below:</p>
<pre class="programlisting code"><code class="hljs-code">[...]\main.cpp(24): chapter06!main+0x5F
-------------- --   -------------------
source         line description
</code></pre>
<p class="normal">These parts can be obtained independently, using the member functions <code class="inlineCode">source_file()</code>, <code class="inlineCode">source_line()</code>, and <code class="inlineCode">description()</code> of <code class="inlineCode">std::stacktrace_entry</code>. The sequence of stack trace entries from a <code class="inlineCode">stacktrace</code> container can be iterated using iterators or<a id="_idIndexMarker818"/> accessed <a id="_idIndexMarker819"/>with the member functions <code class="inlineCode">at()</code> and <code class="inlineCode">operator[]</code>.</p>
<h2 class="heading-2" id="_idParaDest-425">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Providing logging details with source_location</em>, to learn how to use the C++20 <code class="inlineCode">source_location</code> class to display information about the source file, line, and function name</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="Chapter_06.xhtml">https://discord.gg/7xRaTCeEhx</a></p>
<p class="normal"><img alt="" src="img/QR_Code2659294082093549796.png"/></p>
</div>
</body></html>