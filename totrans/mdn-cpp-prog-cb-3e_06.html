<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer092">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 class="chapterTitle" id="_idParaDest-325"><span class="koboSpan" id="kobo.2.1">General-Purpose Utilities</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">The standard library contains many general-purpose utilities and libraries beyond the containers, algorithms, and iterators discussed in the previous chapter. </span><span class="koboSpan" id="kobo.3.2">This chapter is focused on three areas: the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4.1">chrono</span></code><span class="koboSpan" id="kobo.5.1"> library for working with dates, times, calendars, and time zones; type traits, which provide meta-information about other types; and utility types in newer versions of the standard, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6.1">std::any</span></code><span class="koboSpan" id="kobo.7.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.8.1">std::optional</span></code><span class="koboSpan" id="kobo.9.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.10.1">std::variant</span></code><span class="koboSpan" id="kobo.11.1"> in C++17, </span><code class="inlineCode"><span class="koboSpan" id="kobo.12.1">std::span</span></code><span class="koboSpan" id="kobo.13.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.14.1">std::source_location</span></code><span class="koboSpan" id="kobo.15.1"> in C++20, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.16.1">std::mdspan</span></code><span class="koboSpan" id="kobo.17.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.18.1">std::expected</span></code><span class="koboSpan" id="kobo.19.1"> in C++23.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.20.1">The recipes included in this chapter are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Expressing time intervals with </span><code class="inlineCode"><span class="koboSpan" id="kobo.22.1">chrono::duration</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.23.1">Working with calendars</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.24.1">Converting times between time zones</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.25.1">Measuring function execution time with a standard clock</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.26.1">Generating hash values for custom types</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.27.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.28.1">std::any</span></code><span class="koboSpan" id="kobo.29.1"> to store any value</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.30.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.31.1">std::optional</span></code><span class="koboSpan" id="kobo.32.1"> to store optional values</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.33.1">Chaining together computations that may or may not produce a value</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.34.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.35.1">std::variant</span></code><span class="koboSpan" id="kobo.36.1"> as a type-safe union</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.37.1">Visiting a </span><code class="inlineCode"><span class="koboSpan" id="kobo.38.1">std::variant</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.39.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.40.1">std::expected</span></code><span class="koboSpan" id="kobo.41.1"> to return a value or an error</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.42.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.43.1">std::span</span></code><span class="koboSpan" id="kobo.44.1"> for contiguous sequences of objects</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.45.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.46.1">std::mdspan</span></code><span class="koboSpan" id="kobo.47.1"> for multi-dimensional views of sequences of objects</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.48.1">Registering a function to be called when a program exits normally</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.49.1">Using type traits to query properties of types</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.50.1">Writing your own type traits</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.51.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.52.1">std::conditional</span></code><span class="koboSpan" id="kobo.53.1"> to choose between types</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.54.1">Providing logging details with </span><code class="inlineCode"><span class="koboSpan" id="kobo.55.1">source_location</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.56.1">Using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.57.1">stacktrace</span></code><span class="koboSpan" id="kobo.58.1"> library to print the call sequence</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.59.1">The first part of the chapter focuses on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.60.1">chrono</span></code><span class="koboSpan" id="kobo.61.1"> library, which provides time and date utilities.</span></p>
<h1 class="heading-1" id="_idParaDest-326"><span class="koboSpan" id="kobo.62.1">Expressing time intervals with chrono::duration</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.63.1">Working </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.64.1">with times and dates is a common operation, regardless of the programming language. </span><span class="koboSpan" id="kobo.64.2">C++11 provides a flexible </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.65.1">date and time library as part of the standard library that enables us to define time points and time intervals. </span><span class="koboSpan" id="kobo.65.2">This</span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.66.1"> library, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.67.1">chrono</span></code><span class="koboSpan" id="kobo.68.1">, is a general-purpose utility library designed to work with a timer and clocks that can be different on different systems and, therefore, precision-neutral. </span><span class="koboSpan" id="kobo.68.2">The library is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.69.1">&lt;chrono&gt;</span></code><span class="koboSpan" id="kobo.70.1"> header in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.71.1">std::chrono</span></code><span class="koboSpan" id="kobo.72.1"> namespace and defines and implements several components, as follows:</span></p>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.73.1">Durations</span></em><span class="koboSpan" id="kobo.74.1">, which represent time intervals</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.75.1">Time points</span></em><span class="koboSpan" id="kobo.76.1">, which present a duration of time since the epoch of a clock</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.77.1">Clocks</span></em><span class="koboSpan" id="kobo.78.1">, which define an epoch (that is, the start of time) and a tick</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.79.1">In this recipe, we will learn how to work with durations.</span></p>
<h2 class="heading-2" id="_idParaDest-327"><span class="koboSpan" id="kobo.80.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.81.1">This recipe is not intended as a complete reference to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.82.1">duration</span></code><span class="koboSpan" id="kobo.83.1"> class. </span><span class="koboSpan" id="kobo.83.2">It is recommended that you consult additional resources for that purpose (the library reference documentation is available at </span><a href="http://en.cppreference.com/w/cpp/chrono"><span class="url"><span class="koboSpan" id="kobo.84.1">http://en.cppreference.com/w/cpp/chrono</span></span></a><span class="koboSpan" id="kobo.85.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.86.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.87.1">chrono</span></code><span class="koboSpan" id="kobo.88.1"> library, a time interval is represented by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.89.1">std::chrono::duration</span></code><span class="koboSpan" id="kobo.90.1"> class.</span></p>
<h2 class="heading-2" id="_idParaDest-328"><span class="koboSpan" id="kobo.91.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.92.1">To work with time intervals, use the following:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.93.1">std::chrono::duration</span></code><span class="koboSpan" id="kobo.94.1"> typedefs for hours, minutes, seconds, milliseconds, microseconds, and nanoseconds:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.95.1">std::</span><span class="hljs-function"><span class="koboSpan" id="kobo.96.1">chrono::hours        </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.97.1">half_day</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.98.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.99.1">12</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.100.1">)</span></span><span class="koboSpan" id="kobo.101.1">;
std::</span><span class="hljs-function"><span class="koboSpan" id="kobo.102.1">chrono::minutes      </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.103.1">half_hour</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.104.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.105.1">30</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.106.1">)</span></span><span class="koboSpan" id="kobo.107.1">;
std::</span><span class="hljs-function"><span class="koboSpan" id="kobo.108.1">chrono::seconds      </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.109.1">half_minute</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.110.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.111.1">30</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.112.1">)</span></span><span class="koboSpan" id="kobo.113.1">;
std::</span><span class="hljs-function"><span class="koboSpan" id="kobo.114.1">chrono::milliseconds </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.115.1">half_second</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.116.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.117.1">500</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.118.1">)</span></span><span class="koboSpan" id="kobo.119.1">;
std::</span><span class="hljs-function"><span class="koboSpan" id="kobo.120.1">chrono::microseconds </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.121.1">half_millisecond</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.122.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.123.1">500</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.124.1">)</span></span><span class="koboSpan" id="kobo.125.1">;
std::</span><span class="hljs-function"><span class="koboSpan" id="kobo.126.1">chrono::nanoseconds  </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.127.1">half_microsecond</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.128.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.129.1">500</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.130.1">)</span></span><span class="koboSpan" id="kobo.131.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.132.1">Use</span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.133.1"> the standard user-defined literal operators from C++14, available in the namespace </span><code class="inlineCode"><span class="koboSpan" id="kobo.134.1">std::chrono_literals</span></code><span class="koboSpan" id="kobo.135.1">, to create durations of hours, minutes, seconds, milliseconds, microseconds, and nanoseconds:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.136.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.137.1">namespace</span></span><span class="koboSpan" id="kobo.138.1"> std::chrono_literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.139.1">auto</span></span><span class="koboSpan" id="kobo.140.1"> half_day         = </span><span class="hljs-number"><span class="koboSpan" id="kobo.141.1">12</span></span><span class="koboSpan" id="kobo.142.1">h;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.143.1">auto</span></span><span class="koboSpan" id="kobo.144.1"> half_hour        = </span><span class="hljs-number"><span class="koboSpan" id="kobo.145.1">30</span></span><span class="koboSpan" id="kobo.146.1">min;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.147.1">auto</span></span><span class="koboSpan" id="kobo.148.1"> half_minute      = </span><span class="hljs-number"><span class="koboSpan" id="kobo.149.1">30</span></span><span class="koboSpan" id="kobo.150.1">s;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.151.1">auto</span></span><span class="koboSpan" id="kobo.152.1"> half_second      = </span><span class="hljs-number"><span class="koboSpan" id="kobo.153.1">500</span></span><span class="koboSpan" id="kobo.154.1">ms;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.155.1">auto</span></span><span class="koboSpan" id="kobo.156.1"> half_millisecond = </span><span class="hljs-number"><span class="koboSpan" id="kobo.157.1">500u</span></span><span class="koboSpan" id="kobo.158.1">s;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.159.1">auto</span></span><span class="koboSpan" id="kobo.160.1"> half_microsecond = </span><span class="hljs-number"><span class="koboSpan" id="kobo.161.1">500</span></span><span class="koboSpan" id="kobo.162.1">ns;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.163.1">Use </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.164.1">direct conversion from a lower precision duration to a higher precision duration:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.165.1">std::</span><span class="hljs-function"><span class="koboSpan" id="kobo.166.1">chrono::hours </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.167.1">half_day_in_h</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.168.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.169.1">12</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.170.1">)</span></span><span class="koboSpan" id="kobo.171.1">;
std::</span><span class="hljs-function"><span class="koboSpan" id="kobo.172.1">chrono::minutes </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.173.1">half_day_in_min</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.174.1">(half_day_in_h)</span></span><span class="koboSpan" id="kobo.175.1">;
std::cout &lt;&lt; half_day_in_h.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.176.1">count</span></span><span class="koboSpan" id="kobo.177.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.178.1">"h"</span></span><span class="koboSpan" id="kobo.179.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.180.1">'\n'</span></span><span class="koboSpan" id="kobo.181.1">;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.182.1">//12h</span></span><span class="koboSpan" id="kobo.183.1">
std::cout &lt;&lt; half_day_in_min.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.184.1">count</span></span><span class="koboSpan" id="kobo.185.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.186.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.187.1">min"</span></span><span class="koboSpan" id="kobo.188.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.189.1">'\n'</span></span><span class="koboSpan" id="kobo.190.1">;</span><span class="hljs-comment"><span class="koboSpan" id="kobo.191.1">//720min</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.192.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">std::chrono::duration_cast</span></code><span class="koboSpan" id="kobo.194.1"> to convert from a higher precision to a lower precision duration:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.195.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.196.1">namespace</span></span><span class="koboSpan" id="kobo.197.1"> std::chrono_literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.198.1">auto</span></span><span class="koboSpan" id="kobo.199.1"> total_seconds = </span><span class="hljs-number"><span class="koboSpan" id="kobo.200.1">12345</span></span><span class="koboSpan" id="kobo.201.1">s;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.202.1">auto</span></span><span class="koboSpan" id="kobo.203.1"> hours =
  std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.204.1">duration_cast</span></span><span class="koboSpan" id="kobo.205.1">&lt;std::chrono::hours&gt;(total_seconds);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.206.1">auto</span></span><span class="koboSpan" id="kobo.207.1"> minutes =
  std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.208.1">duration_cast</span></span><span class="koboSpan" id="kobo.209.1">&lt;std::chrono::minutes&gt;(total_seconds % </span><span class="hljs-number"><span class="koboSpan" id="kobo.210.1">1</span></span><span class="koboSpan" id="kobo.211.1">h);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.212.1">auto</span></span><span class="koboSpan" id="kobo.213.1"> seconds =
  std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.214.1">duration_cast</span></span><span class="koboSpan" id="kobo.215.1">&lt;std::chrono::seconds&gt;(total_seconds % </span><span class="hljs-number"><span class="koboSpan" id="kobo.216.1">1</span></span><span class="koboSpan" id="kobo.217.1">min);
std::cout &lt;&lt; hours.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.218.1">count</span></span><span class="koboSpan" id="kobo.219.1">()   &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.220.1">':'</span></span><span class="koboSpan" id="kobo.221.1">
          &lt;&lt; minutes.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.222.1">count</span></span><span class="koboSpan" id="kobo.223.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.224.1">':'</span></span><span class="koboSpan" id="kobo.225.1">
          &lt;&lt; seconds.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.226.1">count</span></span><span class="koboSpan" id="kobo.227.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.228.1">'\n'</span></span><span class="koboSpan" id="kobo.229.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.230.1">// 3:25:45</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.231.1">Use </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.232.1">the chrono conversion functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.233.1">floor()</span></code><span class="koboSpan" id="kobo.234.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.235.1">round()</span></code><span class="koboSpan" id="kobo.236.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.237.1">ceil()</span></code><span class="koboSpan" id="kobo.238.1"> available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.239.1">std::chrono</span></code><span class="koboSpan" id="kobo.240.1"> namespace in C++17 when rounding is necessary (not to be confused with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.241.1">std::floor()</span></code><span class="koboSpan" id="kobo.242.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.243.1">std::round()</span></code><span class="koboSpan" id="kobo.244.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.245.1">std::ceil()</span></code><span class="koboSpan" id="kobo.246.1"> functions from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">&lt;cmath&gt;</span></code><span class="koboSpan" id="kobo.248.1"> header):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.249.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.250.1">namespace</span></span><span class="koboSpan" id="kobo.251.1"> std::chrono_literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.252.1">auto</span></span><span class="koboSpan" id="kobo.253.1"> total_seconds = </span><span class="hljs-number"><span class="koboSpan" id="kobo.254.1">12345</span></span><span class="koboSpan" id="kobo.255.1">s;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.256.1">auto</span></span><span class="koboSpan" id="kobo.257.1"> m1 = std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.258.1">floor</span></span><span class="koboSpan" id="kobo.259.1">&lt;std::chrono::minutes&gt;(total_seconds); 
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.260.1">// 205 min</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.261.1">auto</span></span><span class="koboSpan" id="kobo.262.1"> m2 = std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.263.1">round</span></span><span class="koboSpan" id="kobo.264.1">&lt;std::chrono::minutes&gt;(total_seconds); 
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.265.1">// 206 min</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.266.1">auto</span></span><span class="koboSpan" id="kobo.267.1"> m3 = std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.268.1">ceil</span></span><span class="koboSpan" id="kobo.269.1">&lt;std::chrono::minutes&gt;(total_seconds); 
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.270.1">// 206 min</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.271.1">auto</span></span><span class="koboSpan" id="kobo.272.1"> sa = std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.273.1">abs</span></span><span class="koboSpan" id="kobo.274.1">(total_seconds);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.275.1">Use</span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.276.1"> arithmetic operations, compound assignments, and comparison operations to modify and compare time intervals:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.277.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.278.1">namespace</span></span><span class="koboSpan" id="kobo.279.1"> std::chrono_literals;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.280.1">auto</span></span><span class="koboSpan" id="kobo.281.1"> d1 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.282.1">1</span></span><span class="koboSpan" id="kobo.283.1">h + </span><span class="hljs-number"><span class="koboSpan" id="kobo.284.1">23</span></span><span class="koboSpan" id="kobo.285.1">min + </span><span class="hljs-number"><span class="koboSpan" id="kobo.286.1">45</span></span><span class="koboSpan" id="kobo.287.1">s; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.288.1">// d1 = 5025s</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.289.1">auto</span></span><span class="koboSpan" id="kobo.290.1"> d2 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.291.1">3</span></span><span class="koboSpan" id="kobo.292.1">h + </span><span class="hljs-number"><span class="koboSpan" id="kobo.293.1">12</span></span><span class="koboSpan" id="kobo.294.1">min + </span><span class="hljs-number"><span class="koboSpan" id="kobo.295.1">50</span></span><span class="koboSpan" id="kobo.296.1">s; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.297.1">// d2 = 11570s</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.298.1">if</span></span><span class="koboSpan" id="kobo.299.1"> (d1 &lt; d2) { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.300.1">/* do something */</span></span><span class="koboSpan" id="kobo.301.1"> }
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-329"><span class="koboSpan" id="kobo.302.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.303.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.304.1">std::chrono::duration</span></code><span class="koboSpan" id="kobo.305.1"> class defines a number of ticks (the increment between two moments in time) over a unit of time. </span><span class="koboSpan" id="kobo.305.2">The default unit is the second, and for expressing other units, such as minutes or milliseconds, we need to use a ratio. </span><span class="koboSpan" id="kobo.305.3">For units greater than a second, the ratio is greater than one, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.306.1">ratio&lt;60&gt;</span></code><span class="koboSpan" id="kobo.307.1"> for minutes. </span><span class="koboSpan" id="kobo.307.2">For units smaller than a second, the ratio is smaller than one, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.308.1">ratio&lt;1, 1000&gt;</span></code><span class="koboSpan" id="kobo.309.1"> for milliseconds. </span><span class="koboSpan" id="kobo.309.2">The number of ticks can be retrieved with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.310.1">count()</span></code><span class="koboSpan" id="kobo.311.1"> member function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.312.1">The standard library defines several type synonyms for durations of nanoseconds, microseconds, milliseconds, seconds, minutes, and hours, which we used in the first example in the </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.313.1">previous section. </span><span class="koboSpan" id="kobo.313.2">The following code shows how these durations are defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.314.1">chrono</span></code><span class="koboSpan" id="kobo.315.1"> namespace:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.316.1">namespace</span></span><span class="koboSpan" id="kobo.317.1"> std {
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.318.1">namespace</span></span><span class="koboSpan" id="kobo.319.1"> chrono {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.320.1">typedef</span></span><span class="koboSpan" id="kobo.321.1"> duration&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.322.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.323.1">long</span></span><span class="koboSpan" id="kobo.324.1">, ratio&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.325.1">1</span></span><span class="koboSpan" id="kobo.326.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.327.1">1000000000</span></span><span class="koboSpan" id="kobo.328.1">&gt;&gt; nanoseconds;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.329.1">typedef</span></span><span class="koboSpan" id="kobo.330.1"> duration&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.331.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.332.1">long</span></span><span class="koboSpan" id="kobo.333.1">, ratio&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.334.1">1</span></span><span class="koboSpan" id="kobo.335.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.336.1">1000000</span></span><span class="koboSpan" id="kobo.337.1">&gt;&gt; microseconds;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.338.1">typedef</span></span><span class="koboSpan" id="kobo.339.1"> duration&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.340.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.341.1">long</span></span><span class="koboSpan" id="kobo.342.1">, ratio&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.343.1">1</span></span><span class="koboSpan" id="kobo.344.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.345.1">1000</span></span><span class="koboSpan" id="kobo.346.1">&gt;&gt; milliseconds;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.347.1">typedef</span></span><span class="koboSpan" id="kobo.348.1"> duration&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.349.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.350.1">long</span></span><span class="koboSpan" id="kobo.351.1">&gt; seconds;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.352.1">typedef</span></span><span class="koboSpan" id="kobo.353.1"> duration&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.354.1">int</span></span><span class="koboSpan" id="kobo.355.1">, ratio&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.356.1">60</span></span><span class="koboSpan" id="kobo.357.1">&gt; &gt; minutes;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.358.1">typedef</span></span><span class="koboSpan" id="kobo.359.1"> duration&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.360.1">int</span></span><span class="koboSpan" id="kobo.361.1">, ratio&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.362.1">3600</span></span><span class="koboSpan" id="kobo.363.1">&gt; &gt; hours;
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.364.1">However, with</span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.365.1"> this flexible definition, we can express time intervals such as </span><em class="italic"><span class="koboSpan" id="kobo.366.1">1.2 sixths of a minute</span></em><span class="koboSpan" id="kobo.367.1"> (which means 12 seconds), where 1.2 is the number of ticks of the duration and </span><code class="inlineCode"><span class="koboSpan" id="kobo.368.1">ratio&lt;10&gt;</span></code><span class="koboSpan" id="kobo.369.1"> (as in 60/6) is the time unit:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.370.1">std::chrono::duration&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.371.1">double</span></span><span class="koboSpan" id="kobo.372.1">, std::ratio&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.373.1">10</span></span><span class="koboSpan" id="kobo.374.1">&gt;&gt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.375.1">d</span></span><span class="koboSpan" id="kobo.376.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.377.1">1.2</span></span><span class="koboSpan" id="kobo.378.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.379.1">// 12 sec</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.380.1">In C++14, several standard user-defined literal operators have been added to the namespace </span><code class="inlineCode"><span class="koboSpan" id="kobo.381.1">std::chrono_literals</span></code><span class="koboSpan" id="kobo.382.1">. </span><span class="koboSpan" id="kobo.382.2">This makes it easier to define durations, but you must include the namespace in the scope where you want to use the literal operators.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.383.1">You should only include namespaces for user-defined literal operators in the scope where you want to use them, and not in larger scopes, in order to avoid conflict with other operators with the same name from different libraries and namespaces.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.384.1">All arithmetic operations are available for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.385.1">duration</span></code><span class="koboSpan" id="kobo.386.1"> class. </span><span class="koboSpan" id="kobo.386.2">It is possible to add and subtract durations, multiply or divide them by a value, or apply the </span><code class="inlineCode"><span class="koboSpan" id="kobo.387.1">modulo</span></code><span class="koboSpan" id="kobo.388.1"> operation. </span><span class="koboSpan" id="kobo.388.2">However, it is important to note that when two durations of different time units are added or subtracted, the result is a duration of the greatest common divisor of the two time units. </span><span class="koboSpan" id="kobo.388.3">This means that if you add a duration representing seconds and a duration representing minutes, the result is a duration representing seconds.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.389.1">Conversion from a duration with a less precise time unit to a duration with a more precise time unit is done implicitly. </span><span class="koboSpan" id="kobo.389.2">On the other hand, conversion from a more precise to a less precise time unit requires an explicit cast. </span><span class="koboSpan" id="kobo.389.3">This is done with the non-member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.390.1">std::chrono::duration_cast()</span></code><span class="koboSpan" id="kobo.391.1">. </span><span class="koboSpan" id="kobo.391.2">In the </span><em class="italic"><span class="koboSpan" id="kobo.392.1">How to do it...</span></em><span class="koboSpan" id="kobo.393.1"> section, you saw an example for </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.394.1">determining the number of hours, minutes, and seconds of a given duration expressed in seconds.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.395.1">C++17 has added </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.396.1">several more non-member conversion functions that perform duration casting with rounding: </span><code class="inlineCode"><span class="koboSpan" id="kobo.397.1">floor()</span></code><span class="koboSpan" id="kobo.398.1"> to round down, </span><code class="inlineCode"><span class="koboSpan" id="kobo.399.1">ceil()</span></code><span class="koboSpan" id="kobo.400.1"> to round up, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.401.1">round()</span></code><span class="koboSpan" id="kobo.402.1"> to round to the nearest. </span><span class="koboSpan" id="kobo.402.2">Also, C++17 added a non-member function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.403.1">abs()</span></code><span class="koboSpan" id="kobo.404.1"> to retain the absolute value of a duration.</span></p>
<h2 class="heading-2" id="_idParaDest-330"><span class="koboSpan" id="kobo.405.1">There’s more...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.406.1">chrono</span></code><span class="koboSpan" id="kobo.407.1"> is a general-purpose library that, before C++20, lacked many useful features, such as expressing a date with the year, month, and day parts, working with time zones and calendars, and others. </span><span class="koboSpan" id="kobo.407.2">The C++20 standard added support for calendars and time zones, which we will see in the following recipes. </span><span class="koboSpan" id="kobo.407.3">If you use a compiler that doesn’t support these C++20 additions, then third-party libraries can implement these features, and a recommended one is Howard Hinnant’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.408.1">date</span></code><span class="koboSpan" id="kobo.409.1"> library, available under the MIT license at </span><a href="https://github.com/HowardHinnant/date"><span class="url"><span class="koboSpan" id="kobo.410.1">https://github.com/HowardHinnant/date</span></span></a><span class="koboSpan" id="kobo.411.1">. </span><span class="koboSpan" id="kobo.411.2">This library was the foundation for the C++20 </span><code class="inlineCode"><span class="koboSpan" id="kobo.412.1">chrono</span></code><span class="koboSpan" id="kobo.413.1"> additions.</span></p>
<h2 class="heading-2" id="_idParaDest-331"><span class="koboSpan" id="kobo.414.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.415.1">Measuring function execution time with a standard clock</span></em><span class="koboSpan" id="kobo.416.1">, to see how you can determine the execution time of a function</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.417.1">Working with calendars</span></em><span class="koboSpan" id="kobo.418.1">, to discover the C++20 additions to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.419.1">chrono</span></code><span class="koboSpan" id="kobo.420.1"> library for working with dates and calendars</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.421.1">Converting times between time zones</span></em><span class="koboSpan" id="kobo.422.1">, to learn how you can convert time points between different time zones in C++20</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-332"><span class="koboSpan" id="kobo.423.1">Working with calendars</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.424.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.425.1">chrono</span></code><span class="koboSpan" id="kobo.426.1"> library, available in C++11, offered support for clocks, time points, and durations </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.427.1">but did not make it easy to express times and dates, especially with respect to calendars and time zones. </span><span class="koboSpan" id="kobo.427.2">The new C++20 standard corrects this by extending the existing </span><code class="inlineCode"><span class="koboSpan" id="kobo.428.1">chrono</span></code><span class="koboSpan" id="kobo.429.1"> library with:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.430.1">More clocks, such as a UTC clock, an International Atomic Time clock, a GPS clock, a file time clock, and a pseudo-clock representing local time.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.431.1">Time of day, representing the time elapsed since midnight split into hours, minutes, and seconds.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.432.1">Calendars, which enable us to express dates with year, month, and day parts.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.433.1">Time zones, which enable us to express time points with respect to a time zone and make it possible to convert times between different time zones.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.434.1">I/O support for parsing chrono objects from a stream.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.435.1">In this recipe, we will learn about working with calendar objects.</span></p>
<h2 class="heading-2" id="_idParaDest-333"><span class="koboSpan" id="kobo.436.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.437.1">All the new </span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.438.1">chrono functionalities are available in the same </span><code class="inlineCode"><span class="koboSpan" id="kobo.439.1">std::chrono</span></code><span class="koboSpan" id="kobo.440.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.441.1">std::chrono_literals</span></code><span class="koboSpan" id="kobo.442.1"> namespaces in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.443.1">&lt;chrono&gt;</span></code><span class="koboSpan" id="kobo.444.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-334"><span class="koboSpan" id="kobo.445.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.446.1">You can use the C++20 chrono calendar functionalities to:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.447.1">Represent Gregorian calendar dates with year, month, and day, as instances of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.448.1">year_month_day</span></code><span class="koboSpan" id="kobo.449.1"> type. </span><span class="koboSpan" id="kobo.449.2">Use the standard user-defined literals, constants, and the overloaded operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.450.1">/</span></code><span class="koboSpan" id="kobo.451.1"> to construct such objects:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.452.1">// format: year / month /day</span></span><span class="koboSpan" id="kobo.453.1">
year_month_day d1 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.454.1">2024</span></span><span class="koboSpan" id="kobo.455.1">y / </span><span class="hljs-number"><span class="koboSpan" id="kobo.456.1">1</span></span><span class="koboSpan" id="kobo.457.1"> / </span><span class="hljs-number"><span class="koboSpan" id="kobo.458.1">15</span></span><span class="koboSpan" id="kobo.459.1">;
year_month_day d2 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.460.1">2024</span></span><span class="koboSpan" id="kobo.461.1">y / January / </span><span class="hljs-number"><span class="koboSpan" id="kobo.462.1">15</span></span><span class="koboSpan" id="kobo.463.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.464.1">// format: day / month / year</span></span><span class="koboSpan" id="kobo.465.1">
year_month_day d3 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.466.1">15</span></span><span class="koboSpan" id="kobo.467.1">d / </span><span class="hljs-number"><span class="koboSpan" id="kobo.468.1">1</span></span><span class="koboSpan" id="kobo.469.1"> / </span><span class="hljs-number"><span class="koboSpan" id="kobo.470.1">2024</span></span><span class="koboSpan" id="kobo.471.1">;
year_month_day d4 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.472.1">15</span></span><span class="koboSpan" id="kobo.473.1">d / January / </span><span class="hljs-number"><span class="koboSpan" id="kobo.474.1">2024</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.475.1">// format: month / day / year</span></span><span class="koboSpan" id="kobo.476.1">
year_month_day d5 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.477.1">1</span></span><span class="koboSpan" id="kobo.478.1"> / </span><span class="hljs-number"><span class="koboSpan" id="kobo.479.1">15</span></span><span class="koboSpan" id="kobo.480.1">d / </span><span class="hljs-number"><span class="koboSpan" id="kobo.481.1">2024</span></span><span class="koboSpan" id="kobo.482.1">;
year_month_day d6 = January / </span><span class="hljs-number"><span class="koboSpan" id="kobo.483.1">15</span></span><span class="koboSpan" id="kobo.484.1"> / </span><span class="hljs-number"><span class="koboSpan" id="kobo.485.1">2024</span></span><span class="koboSpan" id="kobo.486.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.487.1">Represent the </span><em class="italic"><span class="koboSpan" id="kobo.488.1">n</span></em><span class="koboSpan" id="kobo.489.1">th weekday of a specific year and month as instances of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.490.1">year_month_weekday</span></code><span class="koboSpan" id="kobo.491.1"> type:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.492.1">// format: year / month / weekday</span></span><span class="koboSpan" id="kobo.493.1">
year_month_weekday d1 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.494.1">2024</span></span><span class="koboSpan" id="kobo.495.1">y / January / Monday[</span><span class="hljs-number"><span class="koboSpan" id="kobo.496.1">1</span></span><span class="koboSpan" id="kobo.497.1">];
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.498.1">// format: weekday / month / year</span></span><span class="koboSpan" id="kobo.499.1">
year_month_weekday d2 = Monday[</span><span class="hljs-number"><span class="koboSpan" id="kobo.500.1">1</span></span><span class="koboSpan" id="kobo.501.1">] / January / </span><span class="hljs-number"><span class="koboSpan" id="kobo.502.1">2024</span></span><span class="koboSpan" id="kobo.503.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.504.1">// format: month / weekday / year</span></span><span class="koboSpan" id="kobo.505.1">
year_month_weekday d3 = January / Monday[</span><span class="hljs-number"><span class="koboSpan" id="kobo.506.1">1</span></span><span class="koboSpan" id="kobo.507.1">] / </span><span class="hljs-number"><span class="koboSpan" id="kobo.508.1">2024</span></span><span class="koboSpan" id="kobo.509.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.510.1">Determine the current date, as well as compute other dates from it, such as the dates for tomorrow and yesterday:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.511.1">auto</span></span><span class="koboSpan" id="kobo.512.1"> today = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.513.1">floor</span></span><span class="koboSpan" id="kobo.514.1">&lt;days&gt;(std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.515.1">now</span></span><span class="koboSpan" id="kobo.516.1">());
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.517.1">auto</span></span><span class="koboSpan" id="kobo.518.1"> tomorrow = today + days{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.519.1">1</span></span><span class="koboSpan" id="kobo.520.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.521.1">auto</span></span><span class="koboSpan" id="kobo.522.1"> yesterday = today - days{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.523.1">1</span></span><span class="koboSpan" id="kobo.524.1"> };
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.525.1">Determine</span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.526.1"> the first and last day of a specific month and year:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.527.1">year_month_day today = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.528.1">floor</span></span><span class="koboSpan" id="kobo.529.1">&lt;days&gt;(std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.530.1">now</span></span><span class="koboSpan" id="kobo.531.1">());
year_month_day first_day_this_month = today.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.532.1">year</span></span><span class="koboSpan" id="kobo.533.1">() / today.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.534.1">month</span></span><span class="koboSpan" id="kobo.535.1">() / </span><span class="hljs-number"><span class="koboSpan" id="kobo.536.1">1</span></span><span class="koboSpan" id="kobo.537.1">;
year_month_day last_day_this_month = today.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.538.1">year</span></span><span class="koboSpan" id="kobo.539.1">() / today.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.540.1">month</span></span><span class="koboSpan" id="kobo.541.1">() / last; // std::chrono::last
year_month_day last_day_feb_2024 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.542.1">2024</span></span><span class="koboSpan" id="kobo.543.1">y / February / last;
year_month_day_last ymdl {today.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.544.1">year</span></span><span class="koboSpan" id="kobo.545.1">(), month_day_last{ month{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.546.1">2</span></span><span class="koboSpan" id="kobo.547.1"> } }};
year_month_day last_day_feb { ymdl };
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.548.1">Compute the number of days between two dates:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.549.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.550.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.551.1">number_of_days</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.552.1">(std::chrono::sys_days </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.553.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.554.1">&amp; first,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.555.1">                          std::chrono::sys_days </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.556.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.557.1">&amp; last)</span></span><span class="koboSpan" id="kobo.558.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.559.1">return</span></span><span class="koboSpan" id="kobo.560.1"> (last - first).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.561.1">count</span></span><span class="koboSpan" id="kobo.562.1">();
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.563.1">auto</span></span><span class="koboSpan" id="kobo.564.1"> days = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.565.1">number_of_days</span></span><span class="koboSpan" id="kobo.566.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.567.1">2024</span></span><span class="koboSpan" id="kobo.568.1">y / April / </span><span class="hljs-number"><span class="koboSpan" id="kobo.569.1">1</span></span><span class="koboSpan" id="kobo.570.1">,
</span><span class="hljs-keyword"> </span> <span class="hljs-number"><span class="koboSpan" id="kobo.571.1">2024</span></span><span class="koboSpan" id="kobo.572.1">y / December / </span><span class="hljs-number"><span class="koboSpan" id="kobo.573.1">25</span></span><span class="koboSpan" id="kobo.574.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.575.1">Check whether a date is valid:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.576.1">auto</span></span><span class="koboSpan" id="kobo.577.1"> day = </span><span class="hljs-number"><span class="koboSpan" id="kobo.578.1">2024</span></span><span class="koboSpan" id="kobo.579.1">y / January / </span><span class="hljs-number"><span class="koboSpan" id="kobo.580.1">33</span></span><span class="koboSpan" id="kobo.581.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.582.1">auto</span></span><span class="koboSpan" id="kobo.583.1"> is_valid = day.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.584.1">ok</span></span><span class="koboSpan" id="kobo.585.1">();
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.586.1">Represent the time of day with hour, minutes, and seconds using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.587.1">hh_mm_ss&lt;Duration&gt;</span></code><span class="koboSpan" id="kobo.588.1"> class template, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.589.1">Duration</span></code><span class="koboSpan" id="kobo.590.1"> determines the precision used to split a time interval. </span><span class="koboSpan" id="kobo.590.2">In the next example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.591.1">std::chrono::seconds</span></code><span class="koboSpan" id="kobo.592.1"> defines a split precision of 1 second:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.593.1">chrono::hh_mm_ss&lt;chrono::seconds&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.594.1">td</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.595.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.596.1">13</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.597.1">h+</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.598.1">12</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.599.1">min+</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.600.1">11</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.601.1">s)</span></span><span class="koboSpan" id="kobo.602.1">;
std::cout &lt;&lt; td &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.603.1">'\n'</span></span><span class="koboSpan" id="kobo.604.1">;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.605.1">// 13:12:11</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.606.1">Create time points with date and time parts:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.607.1">auto</span></span><span class="koboSpan" id="kobo.608.1"> tp = chrono::sys_days{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.609.1">2024</span></span><span class="koboSpan" id="kobo.610.1">y / April / </span><span class="hljs-number"><span class="koboSpan" id="kobo.611.1">1</span></span><span class="koboSpan" id="kobo.612.1"> } + </span><span class="hljs-number"><span class="koboSpan" id="kobo.613.1">12</span></span><span class="koboSpan" id="kobo.614.1">h + </span><span class="hljs-number"><span class="koboSpan" id="kobo.615.1">30</span></span><span class="koboSpan" id="kobo.616.1">min + </span><span class="hljs-number"><span class="koboSpan" id="kobo.617.1">45</span></span><span class="koboSpan" id="kobo.618.1">s;
std::cout &lt;&lt; tp &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.619.1">'\n'</span></span><span class="koboSpan" id="kobo.620.1">;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.621.1">// 2024-04-01 12:30:45</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.622.1">Determine </span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.623.1">the current time of day and express it with various precisions:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.624.1">auto</span></span><span class="koboSpan" id="kobo.625.1"> tp = std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.626.1">now</span></span><span class="koboSpan" id="kobo.627.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.628.1">auto</span></span><span class="koboSpan" id="kobo.629.1"> dp = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.630.1">floor</span></span><span class="koboSpan" id="kobo.631.1">&lt;days&gt;(tp);
chrono::hh_mm_ss&lt;chrono::milliseconds&gt; time1 {
  chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.632.1">duration_cast</span></span><span class="koboSpan" id="kobo.633.1">&lt;chrono::milliseconds&gt;(tp - dp) };
std::cout &lt;&lt; time1 &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.634.1">'\n'</span></span><span class="koboSpan" id="kobo.635.1">;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.636.1">// 13:12:11.625</span></span><span class="koboSpan" id="kobo.637.1">
chrono::hh_mm_ss&lt;chrono::minutes&gt; time2 {
  chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.638.1">duration_cast</span></span><span class="koboSpan" id="kobo.639.1">&lt;chrono::minutes&gt;(tp - dp) };
std::cout &lt;&lt; time2 &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.640.1">'\n'</span></span><span class="koboSpan" id="kobo.641.1">;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.642.1">// 13:12</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-335"><span class="koboSpan" id="kobo.643.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.644.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.645.1">year_month_day</span></code><span class="koboSpan" id="kobo.646.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.647.1">year_month_weekday</span></code><span class="koboSpan" id="kobo.648.1"> types we have seen in the examples here are only some of the many new types added to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.649.1">chrono</span></code><span class="koboSpan" id="kobo.650.1"> library for calendar support. </span><span class="koboSpan" id="kobo.650.2">The following table lists all these types in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.651.1">std::chrono</span></code><span class="koboSpan" id="kobo.652.1"> namespace and what they represent:</span></p>
<table class="table-container" id="table001-3">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.653.1">Type</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.654.1">Represents</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.655.1">day</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.656.1">A day of a month</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.657.1">month</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.658.1">A month of a year</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.659.1">year</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.660.1">A year in the Gregorian calendar</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.661.1">weekday</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.662.1">A day of the week in the Gregorian calendar</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.663.1">weekday_indexed</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.664.1">The </span><em class="italic"><span class="koboSpan" id="kobo.665.1">n</span></em><span class="koboSpan" id="kobo.666.1">th weekday of a month, where </span><em class="italic"><span class="koboSpan" id="kobo.667.1">n</span></em><span class="koboSpan" id="kobo.668.1"> is in the range [1, 5] (1 is the 1st weekday of the month and 5 is the 5th—if it exists—weekday of the month)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.669.1">weekday_last</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.670.1">The last weekday of a month</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.671.1">month_day</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.672.1">A specific day of a specific month</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.673.1">month_day_last</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.674.1">The last day of a specific month</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.675.1">month_weekday</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.676.1">The </span><em class="italic"><span class="koboSpan" id="kobo.677.1">n</span></em><span class="koboSpan" id="kobo.678.1">th weekday of a specific month</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.679.1">month_weekday_last</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.680.1">The last weekday of a specific month</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.681.1">year_month</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.682.1">A specific month of a specific year</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.683.1">year_month_day</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.684.1">A specific year, month, and day</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.685.1">year_month_day_last</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.686.1">The last day of a specific year and month</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.687.1">year_month_weekday</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.688.1">The </span><em class="italic"><span class="koboSpan" id="kobo.689.1">n</span></em><span class="koboSpan" id="kobo.690.1">th weekday of a specific year and month</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.691.1">year_month_weekday_last</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.692.1">The last weekday of a specific year and month</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.693.1">Table 6.1: C++20 chrono types for working with dates</span></p>
<p class="normal"><span class="koboSpan" id="kobo.694.1">All the types</span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.695.1"> listed in this table have:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.696.1">A default constructor that leaves the member fields uninitialized</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.697.1">Member functions to access the parts of the entity</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.698.1">A member function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.699.1">ok()</span></code><span class="koboSpan" id="kobo.700.1"> that checks if the stored value is valid</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.701.1">Non-member comparison operators to compare values of the type</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.702.1">An overloaded </span><code class="inlineCode"><span class="koboSpan" id="kobo.703.1">operator&lt;&lt;</span></code><span class="koboSpan" id="kobo.704.1"> to output a value of the type to a stream</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.705.1">An overloaded function template called </span><code class="inlineCode"><span class="koboSpan" id="kobo.706.1">from_stream()</span></code><span class="koboSpan" id="kobo.707.1"> that parses a value from a stream according to the provided format</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.708.1">A specialization of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.709.1">std::formatter&lt;T, CharT&gt;</span></code><span class="koboSpan" id="kobo.710.1"> class template for the text formatting library</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.711.1">In </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.712.1">addition, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.713.1">operator/</span></code><span class="koboSpan" id="kobo.714.1"> is overloaded for many of these types to enable us to easily create Gregorian calendar dates. </span><span class="koboSpan" id="kobo.714.2">When you create a date (with year, month, and day), you can choose between three different formats:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.715.1">year/month/day</span></strong><span class="koboSpan" id="kobo.716.1"> (used in countries such as China, Japan, Korea, and Canada, but others too, sometimes together with the day/month/year format)</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.717.1">month/day/year</span></strong><span class="koboSpan" id="kobo.718.1"> (used in the USA)</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.719.1">day/month/year</span></strong><span class="koboSpan" id="kobo.720.1"> (used in most parts of the world)</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.721.1">In these cases, </span><strong class="keyWord"><span class="koboSpan" id="kobo.722.1">day</span></strong><span class="koboSpan" id="kobo.723.1"> can be either:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.724.1">An actual day of the month (values from 1 to 31)</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.725.1">std:chrono::last</span></code><span class="koboSpan" id="kobo.726.1"> to indicate the last day of the month</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.727.1">weekday[n]</span></code><span class="koboSpan" id="kobo.728.1">, to indicate the </span><em class="italic"><span class="koboSpan" id="kobo.729.1">n</span></em><span class="koboSpan" id="kobo.730.1">th weekday of the month (where </span><em class="italic"><span class="koboSpan" id="kobo.731.1">n</span></em><span class="koboSpan" id="kobo.732.1"> can take values from 1 to 5)</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.733.1">weekday[std::chrono::last]</span></code><span class="koboSpan" id="kobo.734.1">, to indicate the last weekday of the month</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.735.1">In order to disambiguate between integers that represent the day, month, and year, the library provides two user-defined literals: </span><code class="inlineCode"><span class="koboSpan" id="kobo.736.1">""y</span></code><span class="koboSpan" id="kobo.737.1"> to construct a literal of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.738.1">std::chrono::year</span></code><span class="koboSpan" id="kobo.739.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.740.1">""d</span></code><span class="koboSpan" id="kobo.741.1"> to construct a literal of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.742.1">std::chrono::day</span></code><span class="koboSpan" id="kobo.743.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.744.1">In addition, there are constants that represent:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.745.1">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.746.1">std::chrono::month</span></code><span class="koboSpan" id="kobo.747.1">, named </span><code class="inlineCode"><span class="koboSpan" id="kobo.748.1">January</span></code><span class="koboSpan" id="kobo.749.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.750.1">February</span></code><span class="koboSpan" id="kobo.751.1">, up to </span><code class="inlineCode"><span class="koboSpan" id="kobo.752.1">December</span></code><span class="koboSpan" id="kobo.753.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.754.1">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.755.1">std::chrono::weekday</span></code><span class="koboSpan" id="kobo.756.1">, named </span><code class="inlineCode"><span class="koboSpan" id="kobo.757.1">Sunday</span></code><span class="koboSpan" id="kobo.758.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.759.1">Monday</span></code><span class="koboSpan" id="kobo.760.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.761.1">Tuesday</span></code><span class="koboSpan" id="kobo.762.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.763.1">Wednesday</span></code><span class="koboSpan" id="kobo.764.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.765.1">Thursday</span></code><span class="koboSpan" id="kobo.766.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.767.1">Friday</span></code><span class="koboSpan" id="kobo.768.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.769.1">Saturday</span></code><span class="koboSpan" id="kobo.770.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.771.1">You can use all these to construct dates such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.772.1">2025y/April/1</span></code><span class="koboSpan" id="kobo.773.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.774.1">25d/December/2025</span></code><span class="koboSpan" id="kobo.775.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.776.1">Sunday[last]/May/2025</span></code><span class="koboSpan" id="kobo.777.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.778.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.779.1">year_month_day</span></code><span class="koboSpan" id="kobo.780.1"> type provides implicit conversion to and from </span><code class="inlineCode"><span class="koboSpan" id="kobo.781.1">std::chrono::sys_days</span></code><span class="koboSpan" id="kobo.782.1">. </span><span class="koboSpan" id="kobo.782.2">This type is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.783.1">std::chrono::time_point</span></code><span class="koboSpan" id="kobo.784.1"> with the precision of a day (24 hours). </span><span class="koboSpan" id="kobo.784.2">There is a companion type called </span><code class="inlineCode"><span class="koboSpan" id="kobo.785.1">std::chrono::sys_seconds</span></code><span class="koboSpan" id="kobo.786.1">, which is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.787.1">time_point</span></code><span class="koboSpan" id="kobo.788.1"> with a precision of one second. </span><span class="koboSpan" id="kobo.788.2">Explicit conversion between </span><code class="inlineCode"><span class="koboSpan" id="kobo.789.1">time_point</span></code><span class="koboSpan" id="kobo.790.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.791.1">sys_days</span></code><span class="koboSpan" id="kobo.792.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.793.1">sys_seconds</span></code><span class="koboSpan" id="kobo.794.1"> can be performed using </span><code class="inlineCode"><span class="koboSpan" id="kobo.795.1">std::chrono::time_point_cast()</span></code><span class="koboSpan" id="kobo.796.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.797.1">std::chrono::floor()</span></code><span class="koboSpan" id="kobo.798.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.799.1">To represent a </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.800.1">moment of time during a day, we can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.801.1">std::chrono::hh_mm_ss</span></code><span class="koboSpan" id="kobo.802.1"> type. </span><span class="koboSpan" id="kobo.802.2">This class represents the time elapsed since midnight, broken down into hours, minutes, seconds, and sub-seconds. </span><span class="koboSpan" id="kobo.802.3">This type is mostly intended as a formatting tool.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.803.1">There are also several utility functions for translating between 12h/24h formats. </span><span class="koboSpan" id="kobo.803.2">These functions are:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.804.1">is_am()</span></code><span class="koboSpan" id="kobo.805.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.806.1">is_pm()</span></code><span class="koboSpan" id="kobo.807.1"> that check whether a 24-hour formatted time (provided as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.808.1">std::chrono::hours</span></code><span class="koboSpan" id="kobo.809.1"> value) is A.M. </span><span class="koboSpan" id="kobo.809.2">(before midday) or, respectively, P.M. </span><span class="koboSpan" id="kobo.809.3">(before midnight):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.810.1">std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.811.1">is_am</span></span><span class="koboSpan" id="kobo.812.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.813.1">0</span></span><span class="koboSpan" id="kobo.814.1">h)  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.815.1">'\n'</span></span><span class="koboSpan" id="kobo.816.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.817.1">// true</span></span><span class="koboSpan" id="kobo.818.1">
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.819.1">is_am</span></span><span class="koboSpan" id="kobo.820.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.821.1">1</span></span><span class="koboSpan" id="kobo.822.1">h)  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.823.1">'\n'</span></span><span class="koboSpan" id="kobo.824.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.825.1">// true</span></span><span class="koboSpan" id="kobo.826.1">
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.827.1">is_am</span></span><span class="koboSpan" id="kobo.828.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.829.1">12</span></span><span class="koboSpan" id="kobo.830.1">h) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.831.1">'\n'</span></span><span class="koboSpan" id="kobo.832.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.833.1">// false</span></span><span class="koboSpan" id="kobo.834.1">
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.835.1">is_pm</span></span><span class="koboSpan" id="kobo.836.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.837.1">0</span></span><span class="koboSpan" id="kobo.838.1">h)  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.839.1">'\n'</span></span><span class="koboSpan" id="kobo.840.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.841.1">// false</span></span><span class="koboSpan" id="kobo.842.1">
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.843.1">is_pm</span></span><span class="koboSpan" id="kobo.844.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.845.1">12</span></span><span class="koboSpan" id="kobo.846.1">h) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.847.1">'\n'</span></span><span class="koboSpan" id="kobo.848.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.849.1">// true</span></span><span class="koboSpan" id="kobo.850.1">
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.851.1">is_pm</span></span><span class="koboSpan" id="kobo.852.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.853.1">23</span></span><span class="koboSpan" id="kobo.854.1">h) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.855.1">'\n'</span></span><span class="koboSpan" id="kobo.856.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.857.1">// true</span></span><span class="koboSpan" id="kobo.858.1">
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.859.1">is_pm</span></span><span class="koboSpan" id="kobo.860.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.861.1">24</span></span><span class="koboSpan" id="kobo.862.1">h) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.863.1">'\n'</span></span><span class="koboSpan" id="kobo.864.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.865.1">// false</span></span>
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.866.1">make12()</span></code><span class="koboSpan" id="kobo.867.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.868.1">make24()</span></code><span class="koboSpan" id="kobo.869.1"> that return the 12-hour equivalent of a 24-hour format time and, respectively, vice versa. </span><span class="koboSpan" id="kobo.869.2">They both take the input time as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.870.1">std::chrono::hours</span></code><span class="koboSpan" id="kobo.871.1"> value, but </span><code class="inlineCode"><span class="koboSpan" id="kobo.872.1">make24()</span></code><span class="koboSpan" id="kobo.873.1"> has an additional parameter, a Boolean indicating whether the time is P.M.:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.874.1">for</span></span><span class="koboSpan" id="kobo.875.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.876.1">auto</span></span><span class="koboSpan" id="kobo.877.1"> h : { </span><span class="hljs-number"><span class="koboSpan" id="kobo.878.1">0</span></span><span class="koboSpan" id="kobo.879.1">h, </span><span class="hljs-number"><span class="koboSpan" id="kobo.880.1">1</span></span><span class="koboSpan" id="kobo.881.1">h, </span><span class="hljs-number"><span class="koboSpan" id="kobo.882.1">12</span></span><span class="koboSpan" id="kobo.883.1">h, </span><span class="hljs-number"><span class="koboSpan" id="kobo.884.1">23</span></span><span class="koboSpan" id="kobo.885.1">h, </span><span class="hljs-number"><span class="koboSpan" id="kobo.886.1">24</span></span><span class="koboSpan" id="kobo.887.1">h })
{
   std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.888.1">make12</span></span><span class="koboSpan" id="kobo.889.1">(h).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.890.1">count</span></span><span class="koboSpan" id="kobo.891.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.892.1">'\n'</span></span><span class="koboSpan" id="kobo.893.1">;
   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.894.1">// prints 12, 1, 12, 11, 12</span></span><span class="koboSpan" id="kobo.895.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.896.1">for</span></span><span class="koboSpan" id="kobo.897.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.898.1">auto</span></span><span class="koboSpan" id="kobo.899.1"> [h, pm] : { 
   std::pair&lt;hours, </span><span class="hljs-type"><span class="koboSpan" id="kobo.900.1">bool</span></span><span class="koboSpan" id="kobo.901.1">&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.902.1">0</span></span><span class="koboSpan" id="kobo.903.1">h, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.904.1">false</span></span><span class="koboSpan" id="kobo.905.1">},
   std::pair&lt;hours, </span><span class="hljs-type"><span class="koboSpan" id="kobo.906.1">bool</span></span><span class="koboSpan" id="kobo.907.1">&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.908.1">1</span></span><span class="koboSpan" id="kobo.909.1">h, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.910.1">false</span></span><span class="koboSpan" id="kobo.911.1">}, 
   std::pair&lt;hours, </span><span class="hljs-type"><span class="koboSpan" id="kobo.912.1">bool</span></span><span class="koboSpan" id="kobo.913.1">&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.914.1">1</span></span><span class="koboSpan" id="kobo.915.1">h, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.916.1">true</span></span><span class="koboSpan" id="kobo.917.1">}, 
   std::pair&lt;hours, </span><span class="hljs-type"><span class="koboSpan" id="kobo.918.1">bool</span></span><span class="koboSpan" id="kobo.919.1">&gt;{</span><span class="hljs-number"><span class="koboSpan" id="kobo.920.1">12</span></span><span class="koboSpan" id="kobo.921.1">h, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.922.1">false</span></span><span class="koboSpan" id="kobo.923.1">}, 
   std::pair&lt;hours, </span><span class="hljs-type"><span class="koboSpan" id="kobo.924.1">bool</span></span><span class="koboSpan" id="kobo.925.1">&gt;{</span><span class="hljs-number"><span class="koboSpan" id="kobo.926.1">12</span></span><span class="koboSpan" id="kobo.927.1">h, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.928.1">true</span></span><span class="koboSpan" id="kobo.929.1">}, })
{
   std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.930.1">make24</span></span><span class="koboSpan" id="kobo.931.1">(h, pm).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.932.1">count</span></span><span class="koboSpan" id="kobo.933.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.934.1">'\n'</span></span><span class="koboSpan" id="kobo.935.1">;
   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.936.1">// prints 0, 1, 13, 0, 12</span></span><span class="koboSpan" id="kobo.937.1">
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.938.1">As you can</span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.939.1"> see from these examples, these four functions only work with an hour value, since only the hour part of a moment of time determines its format as 12h or 24h or whether it’s an A.M. </span><span class="koboSpan" id="kobo.939.2">or P.M. </span><span class="koboSpan" id="kobo.939.3">time.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.940.1">At the time of publishing the second edition of this book, the chrono changes were not completed. </span><span class="koboSpan" id="kobo.940.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.941.1">hh_mm_ss</span></code><span class="koboSpan" id="kobo.942.1"> type was called </span><code class="inlineCode"><span class="koboSpan" id="kobo.943.1">time_of_day</span></code><span class="koboSpan" id="kobo.944.1">, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.945.1">make12()</span></code><span class="koboSpan" id="kobo.946.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.947.1">make_24()</span></code><span class="koboSpan" id="kobo.948.1"> functions were members of it. </span><span class="koboSpan" id="kobo.948.2">This edition reflects the changes and utilizes the standardized API.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-336"><span class="koboSpan" id="kobo.949.1">There’s more…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.950.1">The date and time facilities described here are all based on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.951.1">std::chrono::system_clock</span></code><span class="koboSpan" id="kobo.952.1">. </span><span class="koboSpan" id="kobo.952.2">Since C++20, this clock is defined to measure the Unix time, which is the time since 00:00:00 UTC on 1 January 1970. </span><span class="koboSpan" id="kobo.952.3">This means the implicit time zone is UTC. </span><span class="koboSpan" id="kobo.952.4">However, in most cases, you might be interested in the local time of a specific time zone. </span><span class="koboSpan" id="kobo.952.5">To help with that, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.953.1">chrono</span></code><span class="koboSpan" id="kobo.954.1"> library added support for time zones, which is what we will learn about in the next recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-337"><span class="koboSpan" id="kobo.955.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.956.1">Expressing time intervals with chrono::duration</span></em><span class="koboSpan" id="kobo.957.1">, to familiarize yourself with the fundamentals of the C++11 </span><code class="inlineCode"><span class="koboSpan" id="kobo.958.1">chrono</span></code><span class="koboSpan" id="kobo.959.1"> library and to work with durations, time points, and points</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.960.1">Converting times between time zones</span></em><span class="koboSpan" id="kobo.961.1">, to learn how you can convert time points between different time zones in C++20</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-338"><span class="koboSpan" id="kobo.962.1">Converting times between time zones</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.963.1">In the </span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.964.1">previous recipe, we talked about C++20 support for working with calendars and expressing dates in the Gregorian calendar with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.965.1">year_month_day</span></code><span class="koboSpan" id="kobo.966.1"> type and others from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.967.1">chrono</span></code><span class="koboSpan" id="kobo.968.1"> library.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.969.1">We also saw how to represent times of day with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.970.1">hh_mm_ss</span></code><span class="koboSpan" id="kobo.971.1"> type. </span><span class="koboSpan" id="kobo.971.2">However, in all these examples, we worked with the time points using the system clock, which measures Unix time and, therefore, uses UTC as the default time zone. </span><span class="koboSpan" id="kobo.971.3">However, we are usually interested in the local time and, sometimes, in the time in some other time zone. </span><span class="koboSpan" id="kobo.971.4">This is possible with the facilities added to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.972.1">chrono</span></code><span class="koboSpan" id="kobo.973.1"> library to support time zones. </span><span class="koboSpan" id="kobo.973.2">In this recipe, you will learn about the most important functionalities of chrono’s time zones.</span></p>
<h2 class="heading-2" id="_idParaDest-339"><span class="koboSpan" id="kobo.974.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.975.1">Before</span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.976.1"> continuing with this recipe, it is recommended that you read the previous one, </span><em class="italic"><span class="koboSpan" id="kobo.977.1">Working with calendars</span></em><span class="koboSpan" id="kobo.978.1">, if you have not done so already.</span></p>
<h2 class="heading-2" id="_idParaDest-340"><span class="koboSpan" id="kobo.979.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.980.1">You can do the following using the C++20 </span><code class="inlineCode"><span class="koboSpan" id="kobo.981.1">chrono</span></code><span class="koboSpan" id="kobo.982.1"> library:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.983.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.984.1">std::chrono::current_zone()</span></code><span class="koboSpan" id="kobo.985.1"> to retrieve the local time zone from the time zone database.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.986.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.987.1">std::chrono::locate_zone()</span></code><span class="koboSpan" id="kobo.988.1"> to retrieve a particular time zone, using its name, from the time zone database.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.989.1">Represent a time point in a particular time zone using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.990.1">std::chrono::zoned_time</span></code><span class="koboSpan" id="kobo.991.1"> class template.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.992.1">Retrieve and display the current local time:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.993.1">auto</span></span><span class="koboSpan" id="kobo.994.1"> time = zoned_time{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.995.1">current_zone</span></span><span class="koboSpan" id="kobo.996.1">(), system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.997.1">now</span></span><span class="koboSpan" id="kobo.998.1">() };
std::cout &lt;&lt; time &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.999.1">'\n'</span></span><span class="koboSpan" id="kobo.1000.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1001.1">// 2024-01-16 22:10:30.9274320 EET</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1002.1">Retrieve and display the current time in another time zone. </span><span class="koboSpan" id="kobo.1002.2">In the following example, we use the time in Italy:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1003.1">auto</span></span><span class="koboSpan" id="kobo.1004.1"> time = zoned_time{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1005.1">locate_zone</span></span><span class="koboSpan" id="kobo.1006.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1007.1">"Europe/Rome"</span></span><span class="koboSpan" id="kobo.1008.1">),
                        system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1009.1">now</span></span><span class="koboSpan" id="kobo.1010.1">() };
std::cout &lt;&lt; time &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1011.1">'\n'</span></span><span class="koboSpan" id="kobo.1012.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1013.1">// 2024-01-16 21:10:30.9291091 CET</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1014.1">Display the current local time with proper locale formatting. </span><span class="koboSpan" id="kobo.1014.2">In this example, the current time is Romanian time, and the locale being used is for Romania:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1015.1">auto</span></span><span class="koboSpan" id="kobo.1016.1"> time = zoned_time{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1017.1">current_zone</span></span><span class="koboSpan" id="kobo.1018.1">(), system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1019.1">now</span></span><span class="koboSpan" id="kobo.1020.1">() };
std::cout &lt;&lt; std::format(std::locale{</span><span class="hljs-string"><span class="koboSpan" id="kobo.1021.1">"ro_RO"</span></span><span class="koboSpan" id="kobo.1022.1">}, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1023.1">"%c"</span></span><span class="koboSpan" id="kobo.1024.1">, time)
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1025.1">'\n'</span></span><span class="koboSpan" id="kobo.1026.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1027.1">// 16.01.2024 22:12:57</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1028.1">Represent a time point in a particular time zone and display it. </span><span class="koboSpan" id="kobo.1028.2">In the following example, this is New York’s time:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1029.1">auto</span></span><span class="koboSpan" id="kobo.1030.1"> time = local_days{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1031.1">2024</span></span><span class="koboSpan" id="kobo.1032.1">y / June / </span><span class="hljs-number"><span class="koboSpan" id="kobo.1033.1">1</span></span><span class="koboSpan" id="kobo.1034.1"> } + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1035.1">12</span></span><span class="koboSpan" id="kobo.1036.1">h + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1037.1">30</span></span><span class="koboSpan" id="kobo.1038.1">min + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1039.1">45</span></span><span class="koboSpan" id="kobo.1040.1">s + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1041.1">256</span></span><span class="koboSpan" id="kobo.1042.1">ms;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1043.1">auto</span></span><span class="koboSpan" id="kobo.1044.1"> ny_time = zoned_time&lt;std::chrono::milliseconds&gt;{
                  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1045.1">locate_zone</span></span><span class="koboSpan" id="kobo.1046.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1047.1">"America/New_York"</span></span><span class="koboSpan" id="kobo.1048.1">), time};
std::cout &lt;&lt; ny_time &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1049.1">'\n'</span></span><span class="koboSpan" id="kobo.1050.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1051.1">// 2024-06-01 12:30:45.256 EDT</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1052.1">Convert</span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.1053.1"> a time point in a particular time zone into a time point in another time zone. </span><span class="koboSpan" id="kobo.1053.2">In the following example, we convert the time from New York into the time in Los Angeles:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1054.1">auto</span></span><span class="koboSpan" id="kobo.1055.1"> la_time = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1056.1">zoned_time</span></span><span class="koboSpan" id="kobo.1057.1">&lt;std::chrono::milliseconds&gt;(
                  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1058.1">locate_zone</span></span><span class="koboSpan" id="kobo.1059.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1060.1">"America/Los_Angeles"</span></span><span class="koboSpan" id="kobo.1061.1">),
                  ny_time);
std::cout &lt;&lt; la_time &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1062.1">'\n'</span></span><span class="koboSpan" id="kobo.1063.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1064.1">// 2024-06-01 09:30:45.256 PDT</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-341"><span class="koboSpan" id="kobo.1065.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1066.1">The system maintains a copy of the IANA Time Zone (TZ) database (which is available online at </span><a href="https://www.iana.org/time-zones"><span class="url"><span class="koboSpan" id="kobo.1067.1">https://www.iana.org/time-zones</span></span></a><span class="koboSpan" id="kobo.1068.1">). </span><span class="koboSpan" id="kobo.1068.2">As a user, you cannot create or alter the database but only retrieve a read-only copy of it with functions such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1069.1">std::chrono::tzdb()</span></code><span class="koboSpan" id="kobo.1070.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1071.1">std::chrono::get_tzdb_list()</span></code><span class="koboSpan" id="kobo.1072.1">. </span><span class="koboSpan" id="kobo.1072.2">Information about a time zone is stored in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1073.1">std::chrono::time_zone</span></code><span class="koboSpan" id="kobo.1074.1"> object. </span><span class="koboSpan" id="kobo.1074.2">Instances of this class cannot be created directly; they are only created by the library when initializing the time zone database. </span><span class="koboSpan" id="kobo.1074.3">However, it is possible to obtain constant access to these instances, using two functions:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1075.1">std::chrono::current_zone()</span></code><span class="koboSpan" id="kobo.1076.1"> retrieves the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1077.1">time_zone</span></code><span class="koboSpan" id="kobo.1078.1"> object representing the local time zone.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1079.1">std::chrono::locate_zone()</span></code><span class="koboSpan" id="kobo.1080.1">retrieves the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1081.1">time_zone</span></code><span class="koboSpan" id="kobo.1082.1"> object representing the specified time zone.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1083.1">Examples of time zone names include Europe/Berlin, Asia/Dubai, and America/Los_Angeles. </span><span class="koboSpan" id="kobo.1083.2">When the name of the location contains multiple words, spaces are replaced by an underscore (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1084.1">_</span></code><span class="koboSpan" id="kobo.1085.1">), such as in the preceding example where Los Angeles is written as Los_Angeles. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1086.1">A list of all the time zones from the IANA TZ database can be found at </span><a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones"><span class="url"><span class="koboSpan" id="kobo.1087.1">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones</span></span></a><span class="koboSpan" id="kobo.1088.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1089.1">There</span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.1090.1"> are two sets of types in the C++20 </span><code class="inlineCode"><span class="koboSpan" id="kobo.1091.1">chrono</span></code><span class="koboSpan" id="kobo.1092.1"> library to represent time points:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1093.1">sys_days</span></code><span class="koboSpan" id="kobo.1094.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1095.1">sys_seconds</span></code><span class="koboSpan" id="kobo.1096.1"> (having day and second precision) represent a time point in the system’s time zone, which is UTC. </span><span class="koboSpan" id="kobo.1096.2">These are type aliases for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1097.1">std::chrono::sys_time</span></code><span class="koboSpan" id="kobo.1098.1">, which, in turn, is an alias for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1099.1">std::chrono::time_point</span></code><span class="koboSpan" id="kobo.1100.1">, which is using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1101.1">std::chrono::system_clock</span></code><span class="koboSpan" id="kobo.1102.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1103.1">local_days</span></code><span class="koboSpan" id="kobo.1104.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1105.1">local_seconds</span></code><span class="koboSpan" id="kobo.1106.1"> (having also day and second precision) represent a time point with respect to a time zone that has not yet been specified. </span><span class="koboSpan" id="kobo.1106.2">These are type aliases for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1107.1">std::chrono::local_time</span></code><span class="koboSpan" id="kobo.1108.1">, which is, in turn, a type alias for a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1109.1">std::chrono::time_point</span></code><span class="koboSpan" id="kobo.1110.1"> using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1111.1">std::chrono::local_t</span></code><span class="koboSpan" id="kobo.1112.1"> pseudo-clock. </span><span class="koboSpan" id="kobo.1112.2">The sole purpose of this clock is to indicate a not-yet-specified time zone.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1113.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1114.1">std::chrono::zoned_time</span></code><span class="koboSpan" id="kobo.1115.1"> class template represents a pairing of a time zone with a time point. </span><span class="koboSpan" id="kobo.1115.2">It can be created from either a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1116.1">sys_time</span></code><span class="koboSpan" id="kobo.1117.1">, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1118.1">local_time</span></code><span class="koboSpan" id="kobo.1119.1">, or another </span><code class="inlineCode"><span class="koboSpan" id="kobo.1120.1">zoned_time</span></code><span class="koboSpan" id="kobo.1121.1"> object. </span><span class="koboSpan" id="kobo.1121.2">Examples of all these cases are shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1122.1">auto</span></span><span class="koboSpan" id="kobo.1123.1"> zst = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1124.1">zoned_time</span></span><span class="koboSpan" id="kobo.1125.1">&lt;std::chrono::seconds&gt;(
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1126.1">current_zone</span></span><span class="koboSpan" id="kobo.1127.1">(),
  sys_days{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1128.1">2024</span></span><span class="koboSpan" id="kobo.1129.1">y / May / </span><span class="hljs-number"><span class="koboSpan" id="kobo.1130.1">10</span></span><span class="koboSpan" id="kobo.1131.1"> } +</span><span class="hljs-number"><span class="koboSpan" id="kobo.1132.1">14</span></span><span class="koboSpan" id="kobo.1133.1">h + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1134.1">20</span></span><span class="koboSpan" id="kobo.1135.1">min + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1136.1">30</span></span><span class="koboSpan" id="kobo.1137.1">s);
std::cout &lt;&lt; zst &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1138.1">'\n'</span></span><span class="koboSpan" id="kobo.1139.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1140.1">// 2024-05-10 17:20:30 EEST (or GMT+3)</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1141.1">auto</span></span><span class="koboSpan" id="kobo.1142.1"> zlt = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1143.1">zoned_time</span></span><span class="koboSpan" id="kobo.1144.1">&lt;std::chrono::seconds&gt;(
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1145.1">current_zone</span></span><span class="koboSpan" id="kobo.1146.1">(),
  local_days{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1147.1">2024</span></span><span class="koboSpan" id="kobo.1148.1">y / May / </span><span class="hljs-number"><span class="koboSpan" id="kobo.1149.1">10</span></span><span class="koboSpan" id="kobo.1150.1"> } +</span><span class="hljs-number"><span class="koboSpan" id="kobo.1151.1">14</span></span><span class="koboSpan" id="kobo.1152.1">h + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1153.1">20</span></span><span class="koboSpan" id="kobo.1154.1">min + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1155.1">30</span></span><span class="koboSpan" id="kobo.1156.1">s);
std::cout &lt;&lt; zlt &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1157.1">'\n'</span></span><span class="koboSpan" id="kobo.1158.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1159.1">// 2024-05-10 14:20:30 EEST (or GMT+3)</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1160.1">auto</span></span><span class="koboSpan" id="kobo.1161.1"> zpt = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1162.1">zoned_time</span></span><span class="koboSpan" id="kobo.1163.1">&lt;std::chrono::seconds&gt;(
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1164.1">locate_zone</span></span><span class="koboSpan" id="kobo.1165.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1166.1">"Europe/Paris"</span></span><span class="koboSpan" id="kobo.1167.1">),
  zlt);
std::cout &lt;&lt; zpt &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1168.1">'\n'</span></span><span class="koboSpan" id="kobo.1169.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1170.1">//2024-05-10 13:20:30 CEST (or GMT+2)</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1171.1">In this sample code, the times in the comments are based on the Romanian time zone. </span><span class="koboSpan" id="kobo.1171.2">Notice that, in the first example, the time is expressed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1172.1">sys_days</span></code><span class="koboSpan" id="kobo.1173.1">, which uses the UTC time zone. </span><span class="koboSpan" id="kobo.1173.2">Since Romanian time is UTC+3 on 10 May 2024 (because of Daylight Saving Time), the local time is 17:20:30. </span><span class="koboSpan" id="kobo.1173.3">In the second example, the time is specified with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1174.1">local_days</span></code><span class="koboSpan" id="kobo.1175.1">, which is time zone-agnostic. </span><span class="koboSpan" id="kobo.1175.2">For this reason, when pairing with the current time </span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.1176.1">zone, the time is actually 14:20:30. </span><span class="koboSpan" id="kobo.1176.2">In the third and last example, the local Romanian time is converted to the time in Paris, which is 13:20:30 (because on that day, the time in Paris was UTC+2).</span></p>
<h2 class="heading-2" id="_idParaDest-342"><span class="koboSpan" id="kobo.1177.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1178.1">Expressing time intervals with chrono::duration</span></em><span class="koboSpan" id="kobo.1179.1">, to familiarize yourself with the fundamentals of the C++11 </span><code class="inlineCode"><span class="koboSpan" id="kobo.1180.1">chrono</span></code><span class="koboSpan" id="kobo.1181.1"> library and to work with durations, time points, and points</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1182.1">Working with calendars</span></em><span class="koboSpan" id="kobo.1183.1">, to discover the C++20 additions to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1184.1">chrono</span></code><span class="koboSpan" id="kobo.1185.1"> library for working with dates and calendars</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-343"><span class="koboSpan" id="kobo.1186.1">Measuring function execution time with a standard clock</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1187.1">In the previous </span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.1188.1">recipe, we saw how to work with time intervals using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1189.1">chrono</span></code><span class="koboSpan" id="kobo.1190.1"> standard library. </span><span class="koboSpan" id="kobo.1190.2">However, we also often need to handle time points. </span><span class="koboSpan" id="kobo.1190.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1191.1">chrono</span></code><span class="koboSpan" id="kobo.1192.1"> library provides such a component, representing a duration of time since the epoch of a clock (that is, the beginning of time as defined by a clock). </span><span class="koboSpan" id="kobo.1192.2">In this recipe, we will learn how to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1193.1">chrono</span></code><span class="koboSpan" id="kobo.1194.1"> library and time points to measure the execution of a function.</span></p>
<h2 class="heading-2" id="_idParaDest-344"><span class="koboSpan" id="kobo.1195.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1196.1">This recipe is tightly related to a preceding one, </span><em class="italic"><span class="koboSpan" id="kobo.1197.1">Expressing time intervals with chrono::duration</span></em><span class="koboSpan" id="kobo.1198.1">. </span><span class="koboSpan" id="kobo.1198.2">If you did not go through that recipe previously, you should do that before continuing with this one.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1199.1">For the examples in this recipe, we will consider the following function, which does nothing but pause the execution of the current thread for a given interval:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1200.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1201.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1202.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1203.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1204.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1205.1"> interval = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1206.1">1000</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1207.1">)</span></span><span class="koboSpan" id="kobo.1208.1">
{
  std::this_thread::sleep_for(std::chrono::milliseconds(interval));
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1209.1">It should go without saying that this function is only meant for testing purposes and does nothing valuable. </span><span class="koboSpan" id="kobo.1209.2">In practice, you will use the counting utility provided here to test your own functions.</span></p>
<h2 class="heading-2" id="_idParaDest-345"><span class="koboSpan" id="kobo.1210.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1211.1">To measure</span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.1212.1"> the execution of a function, you must perform the following steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1213.1">Retrieve the current moment of time using a standard clock:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1214.1">auto</span></span><span class="koboSpan" id="kobo.1215.1"> start = std::chrono::high_resolution_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1216.1">now</span></span><span class="koboSpan" id="kobo.1217.1">();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1218.1">Call the function you want to measure:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1219.1">func</span></span><span class="koboSpan" id="kobo.1220.1">();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1221.1">Retrieve the current moment of time again; the difference between the two is the execution time of the function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1222.1">auto</span></span><span class="koboSpan" id="kobo.1223.1"> diff = std::chrono::high_resolution_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1224.1">now</span></span><span class="koboSpan" id="kobo.1225.1">() - start;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1226.1">Convert the difference (which is expressed in nanoseconds) to the actual resolution you are interested in:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1227.1">std::cout
  &lt;&lt; std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1228.1">duration</span></span><span class="koboSpan" id="kobo.1229.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1230.1">double</span></span><span class="koboSpan" id="kobo.1231.1">, std::milli&gt;(diff).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1232.1">count</span></span><span class="koboSpan" id="kobo.1233.1">()
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1234.1">"ms"</span></span><span class="koboSpan" id="kobo.1235.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1236.1">'\n'</span></span><span class="koboSpan" id="kobo.1237.1">;
std::cout
  &lt;&lt; std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1238.1">duration</span></span><span class="koboSpan" id="kobo.1239.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1240.1">double</span></span><span class="koboSpan" id="kobo.1241.1">, std::nano&gt;(diff).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1242.1">count</span></span><span class="koboSpan" id="kobo.1243.1">()
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1244.1">"ns"</span></span><span class="koboSpan" id="kobo.1245.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1246.1">'\n'</span></span><span class="koboSpan" id="kobo.1247.1">;
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1248.1">To implement this pattern in a reusable component, perform the following steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1249.1">Create a class template parameterized with the resolution and the clock.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1250.1">Create a static variadic function template that takes a function and its arguments.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1251.1">Implement the pattern shown previously, invoking the function with its arguments.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1252.1">Return a duration, not the number of ticks.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1253.1">This is exemplified in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1254.1">template</span></span><span class="koboSpan" id="kobo.1255.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1256.1">typename</span></span><span class="koboSpan" id="kobo.1257.1"> Time = std::chrono::microseconds,
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1258.1">typename</span></span><span class="koboSpan" id="kobo.1259.1"> Clock = std::chrono::high_resolution_clock&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1260.1">struct</span></span><span class="koboSpan" id="kobo.1261.1"> perf_timer
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1262.1">template</span></span><span class="koboSpan" id="kobo.1263.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1264.1">typename</span></span><span class="koboSpan" id="kobo.1265.1"> F, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1266.1">typename</span></span><span class="koboSpan" id="kobo.1267.1">... </span><span class="koboSpan" id="kobo.1267.2">Args&gt;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1268.1">static</span></span><span class="koboSpan" id="kobo.1269.1"> Time </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1270.1">duration</span></span><span class="koboSpan" id="kobo.1271.1">(F&amp;&amp; f, Args... </span><span class="koboSpan" id="kobo.1271.2">args)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1272.1">auto</span></span><span class="koboSpan" id="kobo.1273.1"> start = Clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1274.1">now</span></span><span class="koboSpan" id="kobo.1275.1">();
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1276.1">invoke</span></span><span class="koboSpan" id="kobo.1277.1">(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1278.1">auto</span></span><span class="koboSpan" id="kobo.1279.1"> end = Clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1280.1">now</span></span><span class="koboSpan" id="kobo.1281.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1282.1">return</span></span><span class="koboSpan" id="kobo.1283.1"> std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1284.1">duration_cast</span></span><span class="koboSpan" id="kobo.1285.1">&lt;Time&gt;(end - start);
  }
};
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-346"><span class="koboSpan" id="kobo.1286.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1287.1">A clock is a</span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.1288.1"> component that defines two things:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1289.1">A beginning of time called an </span><em class="italic"><span class="koboSpan" id="kobo.1290.1">epoch</span></em><span class="koboSpan" id="kobo.1291.1">; there is no constraint regarding what the epoch is, but typical implementations use January 1, 1970.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1292.1">A </span><em class="italic"><span class="koboSpan" id="kobo.1293.1">tick rate</span></em><span class="koboSpan" id="kobo.1294.1"> that defines the increment between two time points (such as a millisecond or nanosecond).</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1295.1">A time point is a duration of time since the epoch of a clock. </span><span class="koboSpan" id="kobo.1295.2">There are several time points that are of particular importance:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1296.1">The current time, returned by the clock’s static member </span><code class="inlineCode"><span class="koboSpan" id="kobo.1297.1">now()</span></code><span class="koboSpan" id="kobo.1298.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1299.1">The epoch, or the beginning of time; this is the time point created by the default constructor of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1300.1">time_point</span></code><span class="koboSpan" id="kobo.1301.1"> for a particular clock.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1302.1">The minimum time that can be represented by a clock, returned by the static member </span><code class="inlineCode"><span class="koboSpan" id="kobo.1303.1">min()</span></code><span class="koboSpan" id="kobo.1304.1"> of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1305.1">time_point</span></code><span class="koboSpan" id="kobo.1306.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1307.1">The maximum time that can be represented with a clock, returned by the static member </span><code class="inlineCode"><span class="koboSpan" id="kobo.1308.1">max()</span></code><span class="koboSpan" id="kobo.1309.1"> of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1310.1">time point</span></code><span class="koboSpan" id="kobo.1311.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1312.1">The standard defines several clocks:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1313.1">system_clock</span></code><span class="koboSpan" id="kobo.1314.1">: This uses the real-time clock of the current system to represent time points.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1315.1">high_resolution_clock</span></code><span class="koboSpan" id="kobo.1316.1">: This represents a clock that uses the shortest possible tick period on the current system.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1317.1">steady_clock</span></code><span class="koboSpan" id="kobo.1318.1">: This indicates a clock that is never adjusted. </span><span class="koboSpan" id="kobo.1318.2">This means that, unlike the other clocks, as time advances, the difference between two time points is always positive.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1319.1">utc_clock</span></code><span class="koboSpan" id="kobo.1320.1">: This is a C++20 clock for Coordinated Universal Time.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1321.1">tai_clock</span></code><span class="koboSpan" id="kobo.1322.1">: This is a C++20 clock for International Atomic Time.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1323.1">gps_clock</span></code><span class="koboSpan" id="kobo.1324.1">: This is a C++20 clock for GPS time.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1325.1">file_clock</span></code><span class="koboSpan" id="kobo.1326.1">: This is a C++20 clock used for expressing file times.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1327.1">The </span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.1328.1">following example prints the precision of the first three clocks in this list (the ones available in C++11), regardless of whether it is steady (or monotone) or not:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1329.1">template</span></span><span class="koboSpan" id="kobo.1330.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1331.1">typename</span></span><span class="koboSpan" id="kobo.1332.1"> T&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1333.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1334.1">print_clock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1335.1">()</span></span><span class="koboSpan" id="kobo.1336.1">
{
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1337.1">"precision: "</span></span><span class="koboSpan" id="kobo.1338.1">
            &lt;&lt; (</span><span class="hljs-number"><span class="koboSpan" id="kobo.1339.1">1000000.0</span></span><span class="koboSpan" id="kobo.1340.1"> * </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1341.1">double</span></span><span class="koboSpan" id="kobo.1342.1">(T::period::num)) / 
               (T::period::den)
            &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1343.1">'\n'</span></span><span class="koboSpan" id="kobo.1344.1">;
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1345.1">"steady: "</span></span><span class="koboSpan" id="kobo.1346.1"> &lt;&lt; T::is_steady &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1347.1">'\n'</span></span><span class="koboSpan" id="kobo.1348.1">;
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1349.1">print_clock</span></span><span class="koboSpan" id="kobo.1350.1">&lt;std::chrono::system_clock&gt;();
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1351.1">print_clock</span></span><span class="koboSpan" id="kobo.1352.1">&lt;std::chrono::high_resolution_clock&gt;();
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1353.1">print_clock</span></span><span class="koboSpan" id="kobo.1354.1">&lt;std::chrono::steady_clock&gt;();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1355.1">A possible output is the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1356.1">precision: 0.1
steady: 0
precision: 0.001
steady: 1
precision: 0.001
steady: 1
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1357.1">This means that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1358.1">system_clock</span></code><span class="koboSpan" id="kobo.1359.1"> has a resolution of 0.1 microseconds and is not a monotone clock. </span><span class="koboSpan" id="kobo.1359.2">On the other hand, the other two clocks, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1360.1">high_resolution_clock</span></code><span class="koboSpan" id="kobo.1361.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1362.1">steady_clock</span></code><span class="koboSpan" id="kobo.1363.1">, both have a resolution of 1 nanosecond and are monotone clocks.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1364.1">The steadiness of a clock is important when measuring the execution time of a function because, if the clock is adjusted while the function runs, the result will not yield the actual execution time, and values can even be negative. </span><span class="koboSpan" id="kobo.1364.2">You should rely on a steady clock to measure the function execution time. </span><span class="koboSpan" id="kobo.1364.3">The typical choice for that is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1365.1">high_resolution_clock</span></code><span class="koboSpan" id="kobo.1366.1">, and that was the clock we used in the examples in the </span><em class="italic"><span class="koboSpan" id="kobo.1367.1">How to do it...</span></em><span class="koboSpan" id="kobo.1368.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1369.1">When we </span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.1370.1">measure the execution time, we need to retrieve the current time before making the call and after the call returns. </span><span class="koboSpan" id="kobo.1370.2">For that, we use the clock’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.1371.1">now()</span></code><span class="koboSpan" id="kobo.1372.1"> static method. </span><span class="koboSpan" id="kobo.1372.2">The result is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1373.1">time_point</span></code><span class="koboSpan" id="kobo.1374.1">; when we subtract two time points, the result is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1375.1">duration</span></code><span class="koboSpan" id="kobo.1376.1">, defined by the duration of the clock.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1377.1">In order to create a reusable component that can be used to measure the execution time of any function, we have defined a class template called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1378.1">perf_timer</span></code><span class="koboSpan" id="kobo.1379.1">. </span><span class="koboSpan" id="kobo.1379.2">This class template is parameterized with the resolution we are interested in (which, by default, is microseconds) and the clock we want to use (which, by default, is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1380.1">high_resolution_clock</span></code><span class="koboSpan" id="kobo.1381.1">). </span><span class="koboSpan" id="kobo.1381.2">The class template has a single static member called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1382.1">duration()</span></code><span class="koboSpan" id="kobo.1383.1">—a variadic function template—that takes a function to execute and its variable number of arguments. </span><span class="koboSpan" id="kobo.1383.2">The implementation is relatively simple: we retrieve the current time, invoke the function using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1384.1">std::invoke</span></code><span class="koboSpan" id="kobo.1385.1"> (so that it handles the different mechanisms for invoking anything callable), and then retrieve the current time again. </span><span class="koboSpan" id="kobo.1385.2">The return value is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1386.1">duration</span></code><span class="koboSpan" id="kobo.1387.1"> (with the defined resolution). </span><span class="koboSpan" id="kobo.1387.2">The following snippet shows an example of this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1388.1">auto</span></span><span class="koboSpan" id="kobo.1389.1"> t = perf_timer&lt;&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1390.1">duration</span></span><span class="koboSpan" id="kobo.1391.1">(func, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1392.1">1500</span></span><span class="koboSpan" id="kobo.1393.1">);
std::cout &lt;&lt; std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1394.1">duration</span></span><span class="koboSpan" id="kobo.1395.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1396.1">double</span></span><span class="koboSpan" id="kobo.1397.1">, std::milli&gt;(t).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1398.1">count</span></span><span class="koboSpan" id="kobo.1399.1">()
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1400.1">"ms"</span></span><span class="koboSpan" id="kobo.1401.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1402.1">'\n'</span></span><span class="koboSpan" id="kobo.1403.1">;
std::cout &lt;&lt; std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1404.1">duration</span></span><span class="koboSpan" id="kobo.1405.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1406.1">double</span></span><span class="koboSpan" id="kobo.1407.1">, std::nano&gt;(t).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1408.1">count</span></span><span class="koboSpan" id="kobo.1409.1">()
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1410.1">"ns"</span></span><span class="koboSpan" id="kobo.1411.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1412.1">'\n'</span></span><span class="koboSpan" id="kobo.1413.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1414.1">It is important to note that we are not returning a number of ticks from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1415.1">duration()</span></code><span class="koboSpan" id="kobo.1416.1"> function, but an actual </span><code class="inlineCode"><span class="koboSpan" id="kobo.1417.1">duration</span></code><span class="koboSpan" id="kobo.1418.1"> value. </span><span class="koboSpan" id="kobo.1418.2">The reason is that by returning a number of ticks, we lose the resolution and won’t know what they actually represent. </span><span class="koboSpan" id="kobo.1418.3">It is better to call </span><code class="inlineCode"><span class="koboSpan" id="kobo.1419.1">count()</span></code><span class="koboSpan" id="kobo.1420.1"> only when the actual count of ticks is necessary. </span><span class="koboSpan" id="kobo.1420.2">This is exemplified here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1421.1">auto</span></span><span class="koboSpan" id="kobo.1422.1"> t1 = perf_timer&lt;std::chrono::nanoseconds&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1423.1">duration</span></span><span class="koboSpan" id="kobo.1424.1">(func, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1425.1">150</span></span><span class="koboSpan" id="kobo.1426.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1427.1">auto</span></span><span class="koboSpan" id="kobo.1428.1"> t2 = perf_timer&lt;std::chrono::microseconds&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1429.1">duration</span></span><span class="koboSpan" id="kobo.1430.1">(func, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1431.1">150</span></span><span class="koboSpan" id="kobo.1432.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1433.1">auto</span></span><span class="koboSpan" id="kobo.1434.1"> t3 = perf_timer&lt;std::chrono::milliseconds&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1435.1">duration</span></span><span class="koboSpan" id="kobo.1436.1">(func, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1437.1">150</span></span><span class="koboSpan" id="kobo.1438.1">);
std::cout
  &lt;&lt; std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1439.1">duration</span></span><span class="koboSpan" id="kobo.1440.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1441.1">double</span></span><span class="koboSpan" id="kobo.1442.1">, std::micro&gt;(t1 + t2 + t3).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1443.1">count</span></span><span class="koboSpan" id="kobo.1444.1">()
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1445.1">"us"</span></span><span class="koboSpan" id="kobo.1446.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1447.1">'\n'</span></span><span class="koboSpan" id="kobo.1448.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1449.1">In this </span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.1450.1">example, we measure the execution of three different functions, using three different resolutions (nanoseconds, microseconds, and milliseconds). </span><span class="koboSpan" id="kobo.1450.2">The values </span><code class="inlineCode"><span class="koboSpan" id="kobo.1451.1">t1</span></code><span class="koboSpan" id="kobo.1452.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1453.1">t2</span></code><span class="koboSpan" id="kobo.1454.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1455.1">t3</span></code><span class="koboSpan" id="kobo.1456.1"> represent durations. </span><span class="koboSpan" id="kobo.1456.2">These make it possible to easily add them together and convert the result to microseconds.</span></p>
<h2 class="heading-2" id="_idParaDest-347"><span class="koboSpan" id="kobo.1457.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1458.1">Expressing time intervals with chrono::duration</span></em><span class="koboSpan" id="kobo.1459.1">, to familiarize yourself with the fundamentals of the C++11 </span><code class="inlineCode"><span class="koboSpan" id="kobo.1460.1">chrono</span></code><span class="koboSpan" id="kobo.1461.1"> library and how to work with durations, time points, and points</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.1462.1">Chapter 3</span></em><span class="koboSpan" id="kobo.1463.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1464.1">Uniformly invoking anything callable</span></em><span class="koboSpan" id="kobo.1465.1">, to learn how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1466.1">std::invoke()</span></code><span class="koboSpan" id="kobo.1467.1"> to call functions and any callable object</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-348"><span class="koboSpan" id="kobo.1468.1">Generating hash values for custom types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1469.1">The </span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.1470.1">standard library provides several unordered associative containers: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1471.1">std::unordered_set</span></code><span class="koboSpan" id="kobo.1472.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1473.1">std::unordered_multiset</span></code><span class="koboSpan" id="kobo.1474.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1475.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.1476.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1477.1">std::unordered_map</span></code><span class="koboSpan" id="kobo.1478.1">. </span><span class="koboSpan" id="kobo.1478.2">These containers do not store their elements in a particular order; instead, they are grouped in buckets. </span><span class="koboSpan" id="kobo.1478.3">The bucket an element belongs to depends on the hash value of the element. </span><span class="koboSpan" id="kobo.1478.4">These standard containers use, by default, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1479.1">std::hash</span></code><span class="koboSpan" id="kobo.1480.1"> class template to compute the hash value. </span><span class="koboSpan" id="kobo.1480.2">The specialization for all basic types and also some library types is available. </span><span class="koboSpan" id="kobo.1480.3">However, for custom types, you must specialize the class template yourself. </span><span class="koboSpan" id="kobo.1480.4">This recipe will show you how to do that and also explain how a good hash value can be computed. </span><span class="koboSpan" id="kobo.1480.5">A good hash value can be computed fast and is uniformly dispersed across the value domain, therefore minimizing the chances of duplicate values (collisions) existing.</span></p>
<h2 class="heading-2" id="_idParaDest-349"><span class="koboSpan" id="kobo.1481.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1482.1">For the examples in this recipe, we will use the following class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1483.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1484.1">Item</span></span><span class="koboSpan" id="kobo.1485.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1486.1">int</span></span><span class="koboSpan" id="kobo.1487.1">         id;
  std::string name;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1488.1">double</span></span><span class="koboSpan" id="kobo.1489.1">      value;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1490.1">Item</span></span><span class="koboSpan" id="kobo.1491.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1492.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1493.1">const</span></span><span class="koboSpan" id="kobo.1494.1"> id, std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.1495.1">const</span></span><span class="koboSpan" id="kobo.1496.1"> &amp; name, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1497.1">double</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1498.1">const</span></span><span class="koboSpan" id="kobo.1499.1"> value)
    :</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1500.1">id</span></span><span class="koboSpan" id="kobo.1501.1">(id), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1502.1">name</span></span><span class="koboSpan" id="kobo.1503.1">(name), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1504.1">value</span></span><span class="koboSpan" id="kobo.1505.1">(value)
  {}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1506.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1507.1">operator</span></span><span class="koboSpan" id="kobo.1508.1">==(Item </span><span class="hljs-type"><span class="koboSpan" id="kobo.1509.1">const</span></span><span class="koboSpan" id="kobo.1510.1"> &amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.1511.1">const</span></span><span class="koboSpan" id="kobo.1512.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1513.1">return</span></span><span class="koboSpan" id="kobo.1514.1"> id == other.id &amp;&amp; name == other.name &amp;&amp;
           value == other.value;
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1515.1">This</span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.1516.1"> recipe covers hashing functionalities from the standard library. </span><span class="koboSpan" id="kobo.1516.2">You should be familiar with the concepts of hashes and hash functions.</span></p>
<h2 class="heading-2" id="_idParaDest-350"><span class="koboSpan" id="kobo.1517.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1518.1">In order to use your custom types with the unordered associative containers, you must perform the following steps:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1519.1">Specialize the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1520.1">std::hash</span></code><span class="koboSpan" id="kobo.1521.1"> class template for your custom type; the specialization must be done in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1522.1">std</span></code><span class="koboSpan" id="kobo.1523.1"> namespace.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1524.1">Define synonyms for the argument and result type.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1525.1">Implement the call operator so that it takes a constant reference to your type and returns a hash value.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1526.1">To compute a good hash value, you should do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1527.1">Start with an initial value, which should be a prime number (for example, 17).</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1528.1">For each field that is used to determine whether two instances of the class are equal, adjust the hash value according to the following formula:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1529.1">hashValue = hashValue * prime + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1530.1">hashFunc</span></span><span class="koboSpan" id="kobo.1531.1">(field);
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1532.1">You can use the same prime number for all fields with the preceding formula, but it is recommended to have a different value than the initial value (for instance, 31).</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1533.1">Use a specialization of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1534.1">std::hash</span></code><span class="koboSpan" id="kobo.1535.1"> to determine the hash value for class data members.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1536.1">Based on </span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.1537.1">the steps described here, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1538.1">std::hash</span></code><span class="koboSpan" id="kobo.1539.1"> specialization for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1540.1">Item</span></code><span class="koboSpan" id="kobo.1541.1"> class looks like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1542.1">namespace</span></span><span class="koboSpan" id="kobo.1543.1"> std
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1544.1">template</span></span><span class="koboSpan" id="kobo.1545.1">&lt;&gt;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1546.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1547.1">hash</span></span><span class="koboSpan" id="kobo.1548.1">&lt;Item&gt;
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1549.1">typedef</span></span><span class="koboSpan" id="kobo.1550.1"> Item argument_type;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1551.1">typedef</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1552.1">size_t</span></span><span class="koboSpan" id="kobo.1553.1"> result_type;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.1554.1">result_type </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1555.1">operator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1556.1">()(argument_type </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1557.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1558.1"> &amp; item)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1559.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.1560.1">{
      result_type hashValue = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1561.1">17</span></span><span class="koboSpan" id="kobo.1562.1">;
      hashValue = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1563.1">31</span></span><span class="koboSpan" id="kobo.1564.1"> * hashValue + std::hash&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1565.1">int</span></span><span class="koboSpan" id="kobo.1566.1">&gt;{}(item.id);
      hashValue = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1567.1">31</span></span><span class="koboSpan" id="kobo.1568.1"> * hashValue + std::hash&lt;std::string&gt;{}(item.name);
      hashValue = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1569.1">31</span></span><span class="koboSpan" id="kobo.1570.1"> * hashValue + std::hash&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1571.1">double</span></span><span class="koboSpan" id="kobo.1572.1">&gt;{}(item.value);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1573.1">return</span></span><span class="koboSpan" id="kobo.1574.1"> hashValue;
    }
  };
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1575.1">This specialization makes it possible to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1576.1">Item</span></code><span class="koboSpan" id="kobo.1577.1"> class with unordered associative containers, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1578.1">std::unordered_set</span></code><span class="koboSpan" id="kobo.1579.1">. </span><span class="koboSpan" id="kobo.1579.2">An example is provided here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1580.1">std::unordered_set&lt;Item&gt; set2
{
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.1581.1">1</span></span><span class="koboSpan" id="kobo.1582.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1583.1">"one"</span></span><span class="koboSpan" id="kobo.1584.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1585.1">1.0</span></span><span class="koboSpan" id="kobo.1586.1"> },
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.1587.1">2</span></span><span class="koboSpan" id="kobo.1588.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1589.1">"two"</span></span><span class="koboSpan" id="kobo.1590.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1591.1">2.0</span></span><span class="koboSpan" id="kobo.1592.1"> },
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.1593.1">3</span></span><span class="koboSpan" id="kobo.1594.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1595.1">"three"</span></span><span class="koboSpan" id="kobo.1596.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1597.1">3.0</span></span><span class="koboSpan" id="kobo.1598.1"> },
};
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-351"><span class="koboSpan" id="kobo.1599.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1600.1">The class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.1601.1">std::hash</span></code><span class="koboSpan" id="kobo.1602.1"> is a function object template whose call operator defines a hash function with the following properties:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1603.1">Takes an argument of the template parameter type and returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1604.1">size_t</span></code><span class="koboSpan" id="kobo.1605.1"> value.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1606.1">Does not throw any exceptions.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1607.1">For two arguments that are equal, it returns the same hash value.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1608.1">For two arguments that are not equal, the probability of returning the same value is very small (should be close to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1609.1">1.0/std::numeric_limits&lt;size_t&gt;::max()</span></code><span class="koboSpan" id="kobo.1610.1">).</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1611.1">The </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.1612.1">standard provides specialization for all basic types, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1613.1">bool</span></code><span class="koboSpan" id="kobo.1614.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1615.1">char</span></code><span class="koboSpan" id="kobo.1616.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1617.1">int</span></code><span class="koboSpan" id="kobo.1618.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1619.1">long</span></code><span class="koboSpan" id="kobo.1620.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1621.1">float</span></code><span class="koboSpan" id="kobo.1622.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1623.1">double</span></code><span class="koboSpan" id="kobo.1624.1"> (along with all the possible </span><code class="inlineCode"><span class="koboSpan" id="kobo.1625.1">unsigned</span></code><span class="koboSpan" id="kobo.1626.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1627.1">long</span></code><span class="koboSpan" id="kobo.1628.1"> variations), and the pointer type, but also library types including the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1629.1">basic_string</span></code><span class="koboSpan" id="kobo.1630.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1631.1">basic_string_view</span></code><span class="koboSpan" id="kobo.1632.1"> types, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1633.1">unique_ptr</span></code><span class="koboSpan" id="kobo.1634.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1635.1">shared_ptr</span></code><span class="koboSpan" id="kobo.1636.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1637.1">bitset</span></code><span class="koboSpan" id="kobo.1638.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1639.1">vector&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.1640.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1641.1">optional</span></code><span class="koboSpan" id="kobo.1642.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1643.1">variant</span></code><span class="koboSpan" id="kobo.1644.1"> (in C++17), and several other types. </span><span class="koboSpan" id="kobo.1644.2">However, for custom types, you have to provide your own specialization. </span><span class="koboSpan" id="kobo.1644.3">This specialization must be in the namespace </span><code class="inlineCode"><span class="koboSpan" id="kobo.1645.1">std</span></code><span class="koboSpan" id="kobo.1646.1"> (because that is the namespace where the class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.1647.1">hash</span></code><span class="koboSpan" id="kobo.1648.1"> is defined) and must meet the requirements enumerated earlier.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1649.1">The standard does not specify how hash values should be computed. </span><span class="koboSpan" id="kobo.1649.2">You can use any function you want as long as it returns the same value for equal objects, and also has a very small chance of returning the same value for non-equal objects. </span><span class="koboSpan" id="kobo.1649.3">The algorithm described in this recipe was presented in the book </span><em class="italic"><span class="koboSpan" id="kobo.1650.1">Effective Java, Second Edition</span></em><span class="koboSpan" id="kobo.1651.1"> by Joshua Bloch.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1652.1">When computing the hash value, consider only the fields that participate in determining whether two instances of the class are equal (in other words, fields that are used in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1653.1">operator==</span></code><span class="koboSpan" id="kobo.1654.1">). </span><span class="koboSpan" id="kobo.1654.2">However, you must use all these fields that are used with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1655.1">operator==</span></code><span class="koboSpan" id="kobo.1656.1">. </span><span class="koboSpan" id="kobo.1656.2">In our example, all three fields of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1657.1">Item</span></code><span class="koboSpan" id="kobo.1658.1"> class are used to determine the equality of two objects; therefore, we must use them all to compute the hash. </span><span class="koboSpan" id="kobo.1658.2">The initial hash value should be nonzero, and in our example, we picked the prime number 17. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1659.1">The important thing is that these values should not be zero; otherwise, the initial fields (that is, the first in the order of processing) that produce the hash value zero will not alter the hash (which remains zero since </span><code class="inlineCode"><span class="koboSpan" id="kobo.1660.1">x * 0 + 0 = 0</span></code><span class="koboSpan" id="kobo.1661.1">). </span><span class="koboSpan" id="kobo.1661.2">For every field used to compute the hash, we alter the current hash by multiplying its previous value with a prime number and adding the hash of the current field. </span><span class="koboSpan" id="kobo.1661.3">For this purpose, we use specializations of the class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.1662.1">std::hash</span></code><span class="koboSpan" id="kobo.1663.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1664.1">The use of the prime number 31 is advantageous for performance optimizations because </span><code class="inlineCode"><span class="koboSpan" id="kobo.1665.1">31 * x</span></code><span class="koboSpan" id="kobo.1666.1"> can be replaced by the compiler with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1667.1">(x &lt;&lt; 5) - x</span></code><span class="koboSpan" id="kobo.1668.1">, which is faster. </span><span class="koboSpan" id="kobo.1668.2">Similarly, you can use 127 because </span><code class="inlineCode"><span class="koboSpan" id="kobo.1669.1">127 * x</span></code><span class="koboSpan" id="kobo.1670.1"> is equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1671.1">(x &lt;&lt; 7) - x</span></code><span class="koboSpan" id="kobo.1672.1"> or 8191, because </span><code class="inlineCode"><span class="koboSpan" id="kobo.1673.1">8191 * x</span></code><span class="koboSpan" id="kobo.1674.1"> is equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1675.1">(x &lt;&lt; 13) - x</span></code><span class="koboSpan" id="kobo.1676.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1677.1">If your custom type contains an array and is used to determine the equality of two objects and, therefore, needs to be used to compute the hash, then treat the array as if its elements </span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.1678.1">were data members of the class. </span><span class="koboSpan" id="kobo.1678.2">In other words, apply the same algorithm described earlier to all elements of the array.</span></p>
<h2 class="heading-2" id="_idParaDest-352"><span class="koboSpan" id="kobo.1679.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.1680.1">Chapter 2</span></em><span class="koboSpan" id="kobo.1681.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1682.1">Limits and other properties of numeric types</span></em><span class="koboSpan" id="kobo.1683.1">, to learn about the minimum and maximum values, as well as the other properties of numerical types</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-353"><span class="koboSpan" id="kobo.1684.1">Using std::any to store any value</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1685.1">C++ does not</span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.1686.1"> have a hierarchical type system like other languages (such as C# or Java) and, therefore, it can’t store multiple types of a value in a single variable like it is possible to with the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1687.1">Object</span></code><span class="koboSpan" id="kobo.1688.1"> in .NET and Java or natively in JavaScript. </span><span class="koboSpan" id="kobo.1688.2">Developers have long used </span><code class="inlineCode"><span class="koboSpan" id="kobo.1689.1">void*</span></code><span class="koboSpan" id="kobo.1690.1"> for that purpose, but this only helps us store pointers to anything and is not type-safe. </span><span class="koboSpan" id="kobo.1690.2">Depending on the end goal, alternatives can include templates or overloaded functions. </span><span class="koboSpan" id="kobo.1690.3">However, C++17 has introduced a standard type-safe container, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1691.1">std::any</span></code><span class="koboSpan" id="kobo.1692.1">, that can hold a single value of any type.</span></p>
<h2 class="heading-2" id="_idParaDest-354"><span class="koboSpan" id="kobo.1693.1">Getting ready</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1694.1">std::any</span></code><span class="koboSpan" id="kobo.1695.1"> has been designed based on </span><code class="inlineCode"><span class="koboSpan" id="kobo.1696.1">boost::any</span></code><span class="koboSpan" id="kobo.1697.1"> and is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1698.1">&lt;any&gt;</span></code><span class="koboSpan" id="kobo.1699.1"> header. </span><span class="koboSpan" id="kobo.1699.2">If you are familiar with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1700.1">boost::any</span></code><span class="koboSpan" id="kobo.1701.1"> and have used it in your code, you can migrate it seamlessly to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1702.1">std::any</span></code><span class="koboSpan" id="kobo.1703.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-355"><span class="koboSpan" id="kobo.1704.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1705.1">Use the following operations to work with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1706.1">std::any</span></code><span class="koboSpan" id="kobo.1707.1">:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1708.1">To store values, use the constructor or assign them directly to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1709.1">std::any</span></code><span class="koboSpan" id="kobo.1710.1"> variable:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.1711.1">std::any </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1712.1">value</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1713.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1714.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1715.1">)</span></span><span class="koboSpan" id="kobo.1716.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1717.1">// integer 42</span></span><span class="koboSpan" id="kobo.1718.1">
value = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1719.1">42.0</span></span><span class="koboSpan" id="kobo.1720.1">;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1721.1">// double 42.0</span></span><span class="koboSpan" id="kobo.1722.1">
value = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1723.1">"42"</span></span><span class="koboSpan" id="kobo.1724.1">s;      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1725.1">// std::string "42"</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1726.1">To read values, use the non-member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1727.1">std::any_cast()</span></code><span class="koboSpan" id="kobo.1728.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1729.1">std::any value = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1730.1">42.0</span></span><span class="koboSpan" id="kobo.1731.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1732.1">try</span></span><span class="koboSpan" id="kobo.1733.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1734.1">auto</span></span><span class="koboSpan" id="kobo.1735.1"> d = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1736.1">any_cast</span></span><span class="koboSpan" id="kobo.1737.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1738.1">double</span></span><span class="koboSpan" id="kobo.1739.1">&gt;(value);
  std::cout &lt;&lt; d &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1740.1">'\n'</span></span><span class="koboSpan" id="kobo.1741.1">; // prints 42
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1742.1">catch</span></span><span class="koboSpan" id="kobo.1743.1"> (std::bad_any_cast </span><span class="hljs-type"><span class="koboSpan" id="kobo.1744.1">const</span></span><span class="koboSpan" id="kobo.1745.1"> &amp; e)
{
  std::cout &lt;&lt; e.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1746.1">what</span></span><span class="koboSpan" id="kobo.1747.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1748.1">'\n'</span></span><span class="koboSpan" id="kobo.1749.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1750.1">To </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.1751.1">check the type of the stored value, use the member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1752.1">type()</span></code><span class="koboSpan" id="kobo.1753.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1754.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1755.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1756.1">is_integer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1757.1">(std::any </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1758.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1759.1"> &amp; a)</span></span><span class="koboSpan" id="kobo.1760.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1761.1">return</span></span><span class="koboSpan" id="kobo.1762.1"> a.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1763.1">type</span></span><span class="koboSpan" id="kobo.1764.1">() == </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1765.1">typeid</span></span><span class="koboSpan" id="kobo.1766.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1767.1">int</span></span><span class="koboSpan" id="kobo.1768.1">);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1769.1">To check whether the container stores a value, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1770.1">has_value()</span></code><span class="koboSpan" id="kobo.1771.1"> member function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1772.1">auto</span></span><span class="koboSpan" id="kobo.1773.1"> ltest = [](std::any </span><span class="hljs-type"><span class="koboSpan" id="kobo.1774.1">const</span></span><span class="koboSpan" id="kobo.1775.1"> &amp; a) {
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1776.1">if</span></span><span class="koboSpan" id="kobo.1777.1"> (a.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1778.1">has_value</span></span><span class="koboSpan" id="kobo.1779.1">())
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1780.1">"has value"</span></span><span class="koboSpan" id="kobo.1781.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1782.1">'\n'</span></span><span class="koboSpan" id="kobo.1783.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1784.1">else</span></span><span class="koboSpan" id="kobo.1785.1">
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1786.1">"no value"</span></span><span class="koboSpan" id="kobo.1787.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1788.1">'\n'</span></span><span class="koboSpan" id="kobo.1789.1">;
};
std::any value;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1790.1">ltest</span></span><span class="koboSpan" id="kobo.1791.1">(value); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1792.1">// no value</span></span><span class="koboSpan" id="kobo.1793.1">
value = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1794.1">42</span></span><span class="koboSpan" id="kobo.1795.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1796.1">ltest</span></span><span class="koboSpan" id="kobo.1797.1">(value); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1798.1">// has value</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1799.1">To modify the stored value, use the member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.1800.1">emplace()</span></code><span class="koboSpan" id="kobo.1801.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1802.1">reset()</span></code><span class="koboSpan" id="kobo.1803.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1804.1">swap()</span></code><span class="koboSpan" id="kobo.1805.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1806.1">std::any value = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1807.1">42</span></span><span class="koboSpan" id="kobo.1808.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1809.1">ltest</span></span><span class="koboSpan" id="kobo.1810.1">(value); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1811.1">// has value</span></span><span class="koboSpan" id="kobo.1812.1">
value.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1813.1">reset</span></span><span class="koboSpan" id="kobo.1814.1">();
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1815.1">ltest</span></span><span class="koboSpan" id="kobo.1816.1">(value); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1817.1">// no value</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-356"><span class="koboSpan" id="kobo.1818.1">How it works...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1819.1">std::any</span></code><span class="koboSpan" id="kobo.1820.1"> is a </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.1821.1">type-safe container that can hold values of any type that is (or rather, whose decayed type is) copy constructible. </span><span class="koboSpan" id="kobo.1821.2">Storing values in the container is very simple—you can either use one of the available constructors (the default constructor creates a container that stores no value) or the assignment operator. </span><span class="koboSpan" id="kobo.1821.3">However, reading values is not directly possible, and you need to use the non-member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1822.1">std::any_cast()</span></code><span class="koboSpan" id="kobo.1823.1">, which casts the stored value to the specified type. </span><span class="koboSpan" id="kobo.1823.2">This function throws </span><code class="inlineCode"><span class="koboSpan" id="kobo.1824.1">std::bad_any_cast</span></code><span class="koboSpan" id="kobo.1825.1"> if the stored value has a different type than the one you are casting to. </span><span class="koboSpan" id="kobo.1825.2">Casting between implicitly convertible types, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1826.1">int</span></code><span class="koboSpan" id="kobo.1827.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1828.1">long</span></code><span class="koboSpan" id="kobo.1829.1">, is not possible either. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1830.1">std::bad_any_cast</span></code><span class="koboSpan" id="kobo.1831.1"> is derived from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1832.1">std::bad_cast</span></code><span class="koboSpan" id="kobo.1833.1">; therefore, you can catch any of these two exception types.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1834.1">It is possible to check the type of the stored value using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1835.1">type()</span></code><span class="koboSpan" id="kobo.1836.1"> member function, which returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1837.1">type_info</span></code><span class="koboSpan" id="kobo.1838.1"> constant reference. </span><span class="koboSpan" id="kobo.1838.2">If the container is empty, this function returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.1839.1">typeid(void)</span></code><span class="koboSpan" id="kobo.1840.1">. </span><span class="koboSpan" id="kobo.1840.2">To check whether the container stores a value, you can use the member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1841.1">has_value()</span></code><span class="koboSpan" id="kobo.1842.1">, which returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.1843.1">true</span></code><span class="koboSpan" id="kobo.1844.1"> if there is a value or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1845.1">false</span></code><span class="koboSpan" id="kobo.1846.1"> if the container is empty.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1847.1">The following example shows how to check whether the container has any value, how to check the type of the stored value, and how to read the value from the container:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1848.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1849.1">log</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1850.1">(std::any </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1851.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1852.1"> &amp; value)</span></span><span class="koboSpan" id="kobo.1853.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1854.1">if</span></span><span class="koboSpan" id="kobo.1855.1"> (value.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1856.1">has_value</span></span><span class="koboSpan" id="kobo.1857.1">())
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1858.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1859.1">const</span></span><span class="koboSpan" id="kobo.1860.1"> &amp; tv = value.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1861.1">type</span></span><span class="koboSpan" id="kobo.1862.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1863.1">if</span></span><span class="koboSpan" id="kobo.1864.1"> (tv == </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1865.1">typeid</span></span><span class="koboSpan" id="kobo.1866.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1867.1">int</span></span><span class="koboSpan" id="kobo.1868.1">))
    {
      std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1869.1">any_cast</span></span><span class="koboSpan" id="kobo.1870.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1871.1">int</span></span><span class="koboSpan" id="kobo.1872.1">&gt;(value) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1873.1">'\n'</span></span><span class="koboSpan" id="kobo.1874.1">;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1875.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1876.1">if</span></span><span class="koboSpan" id="kobo.1877.1"> (tv == </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1878.1">typeid</span></span><span class="koboSpan" id="kobo.1879.1">(std::string))
    {
      std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1880.1">any_cast</span></span><span class="koboSpan" id="kobo.1881.1">&lt;std::string&gt;(value) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1882.1">'\n'</span></span><span class="koboSpan" id="kobo.1883.1">;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1884.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1885.1">if</span></span><span class="koboSpan" id="kobo.1886.1"> (tv == </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1887.1">typeid</span></span><span class="koboSpan" id="kobo.1888.1">(
      std::chrono::time_point&lt;std::chrono::system_clock&gt;))
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1889.1">auto</span></span><span class="koboSpan" id="kobo.1890.1"> t = std::any_cast&lt;std::chrono::time_point&lt;
        std::chrono::system_clock&gt;&gt;(value);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1891.1">auto</span></span><span class="koboSpan" id="kobo.1892.1"> now = std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1893.1">to_time_t</span></span><span class="koboSpan" id="kobo.1894.1">(t);
      std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1895.1">put_time</span></span><span class="koboSpan" id="kobo.1896.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1897.1">localtime</span></span><span class="koboSpan" id="kobo.1898.1">(&amp;now), </span><span class="hljs-string"><span class="koboSpan" id="kobo.1899.1">"%F %T"</span></span><span class="koboSpan" id="kobo.1900.1">)
                &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1901.1">'\n'</span></span><span class="koboSpan" id="kobo.1902.1">;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1903.1">else</span></span><span class="koboSpan" id="kobo.1904.1">
    {
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1905.1">"unexpected value type"</span></span><span class="koboSpan" id="kobo.1906.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1907.1">'\n'</span></span><span class="koboSpan" id="kobo.1908.1">;
    }
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1909.1">else</span></span><span class="koboSpan" id="kobo.1910.1">
  {
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1911.1">"(empty)"</span></span><span class="koboSpan" id="kobo.1912.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1913.1">'\n'</span></span><span class="koboSpan" id="kobo.1914.1">;
  }
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1915.1">log</span></span><span class="koboSpan" id="kobo.1916.1">(std::any{});                       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1917.1">// (empty)</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1918.1">log</span></span><span class="koboSpan" id="kobo.1919.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1920.1">42</span></span><span class="koboSpan" id="kobo.1921.1">);                               </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1922.1">// 42</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1923.1">log</span></span><span class="koboSpan" id="kobo.1924.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1925.1">"42"</span></span><span class="koboSpan" id="kobo.1926.1">s);                            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1927.1">// 42</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1928.1">log</span></span><span class="koboSpan" id="kobo.1929.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1930.1">42.0</span></span><span class="koboSpan" id="kobo.1931.1">);                             </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1932.1">// unexpected value type</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1933.1">log</span></span><span class="koboSpan" id="kobo.1934.1">(std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1935.1">now</span></span><span class="koboSpan" id="kobo.1936.1">()); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1937.1">// 2016-10-30 22:42:57</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1938.1">If you </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.1939.1">want to store multiple values of any type, use a standard container such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1940.1">std::vector</span></code><span class="koboSpan" id="kobo.1941.1"> to hold values of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1942.1">std::any</span></code><span class="koboSpan" id="kobo.1943.1">. </span><span class="koboSpan" id="kobo.1943.2">An example is presented here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1944.1">std::vector&lt;std::any&gt; values;
values.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1945.1">push_back</span></span><span class="koboSpan" id="kobo.1946.1">(std::any{});
values.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1947.1">push_back</span></span><span class="koboSpan" id="kobo.1948.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1949.1">42</span></span><span class="koboSpan" id="kobo.1950.1">);
values.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1951.1">push_back</span></span><span class="koboSpan" id="kobo.1952.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1953.1">"42"</span></span><span class="koboSpan" id="kobo.1954.1">s);
values.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1955.1">push_back</span></span><span class="koboSpan" id="kobo.1956.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1957.1">42.0</span></span><span class="koboSpan" id="kobo.1958.1">);
values.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1959.1">push_back</span></span><span class="koboSpan" id="kobo.1960.1">(std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1961.1">now</span></span><span class="koboSpan" id="kobo.1962.1">());
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1963.1">for</span></span><span class="koboSpan" id="kobo.1964.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1965.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1966.1">const &amp;</span></span><span class="koboSpan" id="kobo.1967.1"> v : values)
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1968.1">log</span></span><span class="koboSpan" id="kobo.1969.1">(v);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1970.1">In this snippet, the vector called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1971.1">values</span></code><span class="koboSpan" id="kobo.1972.1"> contains elements of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1973.1">std::any</span></code><span class="koboSpan" id="kobo.1974.1"> type, which, in turn, contains an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1975.1">int</span></code><span class="koboSpan" id="kobo.1976.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1977.1">std::string</span></code><span class="koboSpan" id="kobo.1978.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1979.1">double</span></code><span class="koboSpan" id="kobo.1980.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1981.1">std::chrono::time_point</span></code><span class="koboSpan" id="kobo.1982.1"> value.</span></p>
<h2 class="heading-2" id="_idParaDest-357"><span class="koboSpan" id="kobo.1983.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1984.1">Using std::optional to store optional values</span></em><span class="koboSpan" id="kobo.1985.1">, to learn about the C++17 class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.1986.1">std::optional</span></code><span class="koboSpan" id="kobo.1987.1">, which manages a value that may or may not exist</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1988.1">Using std::variant as a type-safe union</span></em><span class="koboSpan" id="kobo.1989.1">, to learn how to use the C++17 </span><code class="inlineCode"><span class="koboSpan" id="kobo.1990.1">std::variant</span></code><span class="koboSpan" id="kobo.1991.1"> class to represent type-safe unions</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-358"><span class="koboSpan" id="kobo.1992.1">Using std::optional to store optional values</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1993.1">Sometimes, it is</span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.1994.1"> useful to be able to store either a value or a null pointer if a specific value is not available. </span><span class="koboSpan" id="kobo.1994.2">A typical example of such a case is the return value of a function that may fail to produce a return value, but this failure is not an error. </span><span class="koboSpan" id="kobo.1994.3">For instance, think of a function that finds and returns values from a dictionary by specifying a key. </span><span class="koboSpan" id="kobo.1994.4">Not finding a value is a probable case and, therefore, the function would either return a Boolean (or an integer value, if more error codes are necessary) and have a reference argument to hold the return value or return a pointer (raw or smart pointer). </span><span class="koboSpan" id="kobo.1994.5">In C++17, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1995.1">std::optional</span></code><span class="koboSpan" id="kobo.1996.1"> is a better alternative to these solutions. </span><span class="koboSpan" id="kobo.1996.2">The class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.1997.1">std::optional</span></code><span class="koboSpan" id="kobo.1998.1"> is a template container for storing a value that may or may not exist. </span><span class="koboSpan" id="kobo.1998.2">In this recipe, we will see how to use this container and its typical use cases.</span></p>
<h2 class="heading-2" id="_idParaDest-359"><span class="koboSpan" id="kobo.1999.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2000.1">The class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.2001.1">std::optional&lt;T&gt;</span></code><span class="koboSpan" id="kobo.2002.1"> was designed based on </span><code class="inlineCode"><span class="koboSpan" id="kobo.2003.1">boost::optional</span></code><span class="koboSpan" id="kobo.2004.1"> and is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2005.1">&lt;optional&gt;</span></code><span class="koboSpan" id="kobo.2006.1"> header. </span><span class="koboSpan" id="kobo.2006.2">If you are familiar with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2007.1">boost::optional</span></code><span class="koboSpan" id="kobo.2008.1"> and have used it in your code, you can migrate it seamlessly to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2009.1">std::optional</span></code><span class="koboSpan" id="kobo.2010.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2011.1">In the following snippets, we will refer to the following </span><code class="inlineCode"><span class="koboSpan" id="kobo.2012.1">foo</span></code><span class="koboSpan" id="kobo.2013.1"> class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2014.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2015.1">foo</span></span><span class="koboSpan" id="kobo.2016.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2017.1">int</span></span><span class="koboSpan" id="kobo.2018.1">    a;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2019.1">double</span></span><span class="koboSpan" id="kobo.2020.1"> b;
};
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-360"><span class="koboSpan" id="kobo.2021.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2022.1">Use the following operations to work with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2023.1">std::optional</span></code><span class="koboSpan" id="kobo.2024.1">:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2025.1">To store a value, use the constructor or assign the value directly to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2026.1">std::optional</span></code><span class="koboSpan" id="kobo.2027.1"> object:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2028.1">std::optional&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2029.1">int</span></span><span class="koboSpan" id="kobo.2030.1">&gt; v1;      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2031.1">// v1 is empty</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.2032.1">std::optional&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2033.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2034.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2035.1">v2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2036.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.2037.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2038.1">)</span></span><span class="koboSpan" id="kobo.2039.1">;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2040.1">// v2 contains 42</span></span><span class="koboSpan" id="kobo.2041.1">
v1 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2042.1">42</span></span><span class="koboSpan" id="kobo.2043.1">;                    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2044.1">// v1 contains 42</span></span><span class="koboSpan" id="kobo.2045.1">
std::optional&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2046.1">int</span></span><span class="koboSpan" id="kobo.2047.1">&gt; v3 = v2; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2048.1">// v3 contains 42</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2049.1">To read the stored value, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2050.1">operator*</span></code><span class="koboSpan" id="kobo.2051.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2052.1">operator-&gt;</span></code><span class="koboSpan" id="kobo.2053.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2054.1">std::optional&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2055.1">int</span></span><span class="koboSpan" id="kobo.2056.1">&gt; v1{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2057.1">42</span></span><span class="koboSpan" id="kobo.2058.1"> };
std::cout &lt;&lt; *v1 &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2059.1">'\n'</span></span><span class="koboSpan" id="kobo.2060.1">;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2061.1">// 42</span></span><span class="koboSpan" id="kobo.2062.1">
std::optional&lt;foo&gt; v2{ foo{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2063.1">42</span></span><span class="koboSpan" id="kobo.2064.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2065.1">10.5</span></span><span class="koboSpan" id="kobo.2066.1"> } };
std::cout &lt;&lt; v2-&gt;a &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2067.1">", "</span></span><span class="koboSpan" id="kobo.2068.1">
          &lt;&lt; v2-&gt;b &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2069.1">'\n'</span></span><span class="koboSpan" id="kobo.2070.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2071.1">// 42, 10.5</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2072.1">Alternatively, use the member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2073.1">value()</span></code><span class="koboSpan" id="kobo.2074.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2075.1">value_or()</span></code><span class="koboSpan" id="kobo.2076.1"> to read the stored value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2077.1">std::optional&lt;std::string&gt; v1{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.2078.1">"text"</span></span><span class="koboSpan" id="kobo.2079.1">s };
std::cout &lt;&lt; v1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2080.1">value</span></span><span class="koboSpan" id="kobo.2081.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2082.1">'\n'</span></span><span class="koboSpan" id="kobo.2083.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2084.1">// text</span></span><span class="koboSpan" id="kobo.2085.1">
std::optional&lt;std::string&gt; v2;
std::cout &lt;&lt; v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2086.1">value_or</span></span><span class="koboSpan" id="kobo.2087.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2088.1">"default"</span></span><span class="koboSpan" id="kobo.2089.1">s) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2090.1">'\n'</span></span><span class="koboSpan" id="kobo.2091.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2092.1">// default</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2093.1">To </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.2094.1">check whether the container stores a value, use a conversion operator to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2095.1">bool</span></code><span class="koboSpan" id="kobo.2096.1"> or the member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2097.1">has_value()</span></code><span class="koboSpan" id="kobo.2098.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2099.1">std::optional&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2100.1">int</span></span><span class="koboSpan" id="kobo.2101.1">&gt; v1{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2102.1">42</span></span><span class="koboSpan" id="kobo.2103.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2104.1">if</span></span><span class="koboSpan" id="kobo.2105.1"> (v1) std::cout &lt;&lt; *v1 &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2106.1">'\n'</span></span><span class="koboSpan" id="kobo.2107.1">;
std::optional&lt;foo&gt; v2{ foo{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2108.1">42</span></span><span class="koboSpan" id="kobo.2109.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2110.1">10.5</span></span><span class="koboSpan" id="kobo.2111.1"> } };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2112.1">if</span></span><span class="koboSpan" id="kobo.2113.1"> (v2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2114.1">has_value</span></span><span class="koboSpan" id="kobo.2115.1">())
  std::cout &lt;&lt; v2-&gt;a &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2116.1">", "</span></span><span class="koboSpan" id="kobo.2117.1"> &lt;&lt; v2-&gt;b &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2118.1">'\n'</span></span><span class="koboSpan" id="kobo.2119.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2120.1">To modify the stored value, use the member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2121.1">emplace()</span></code><span class="koboSpan" id="kobo.2122.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2123.1">reset()</span></code><span class="koboSpan" id="kobo.2124.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2125.1">swap()</span></code><span class="koboSpan" id="kobo.2126.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2127.1">std::optional&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2128.1">int</span></span><span class="koboSpan" id="kobo.2129.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2130.1">42</span></span><span class="koboSpan" id="kobo.2131.1"> }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2132.1">// v contains 42</span></span><span class="koboSpan" id="kobo.2133.1">
v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2134.1">reset</span></span><span class="koboSpan" id="kobo.2135.1">();                  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2136.1">// v is empty</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2137.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2138.1">std::optional</span></code><span class="koboSpan" id="kobo.2139.1"> to model any of the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2140.1">Return values from functions that may fail to produce a value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2141.1">template</span></span><span class="koboSpan" id="kobo.2142.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2143.1">typename</span></span><span class="koboSpan" id="kobo.2144.1"> K, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2145.1">typename</span></span><span class="koboSpan" id="kobo.2146.1"> V&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.2147.1">std::optional&lt;V&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2148.1">find</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2149.1">(K </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2150.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2151.1"> key,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.2152.1">                      std::map&lt;K, V&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2153.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2154.1"> &amp; m)</span></span><span class="koboSpan" id="kobo.2155.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2156.1">auto</span></span><span class="koboSpan" id="kobo.2157.1"> pos = m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2158.1">find</span></span><span class="koboSpan" id="kobo.2159.1">(key);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2160.1">if</span></span><span class="koboSpan" id="kobo.2161.1"> (pos != m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2162.1">end</span></span><span class="koboSpan" id="kobo.2163.1">())
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2164.1">return</span></span><span class="koboSpan" id="kobo.2165.1"> pos-&gt;second;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2166.1">return</span></span><span class="koboSpan" id="kobo.2167.1"> {};
}
std::map&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2168.1">int</span></span><span class="koboSpan" id="kobo.2169.1">, std::string&gt; m{
  { </span><span class="hljs-number"><span class="koboSpan" id="kobo.2170.1">1</span></span><span class="koboSpan" id="kobo.2171.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2172.1">"one"</span></span><span class="koboSpan" id="kobo.2173.1">s },{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2174.1">2</span></span><span class="koboSpan" id="kobo.2175.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2176.1">"two"</span></span><span class="koboSpan" id="kobo.2177.1">s },{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2178.1">3</span></span><span class="koboSpan" id="kobo.2179.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2180.1">"three"</span></span><span class="koboSpan" id="kobo.2181.1">s } };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2182.1">auto</span></span><span class="koboSpan" id="kobo.2183.1"> value = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2184.1">find</span></span><span class="koboSpan" id="kobo.2185.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2186.1">2</span></span><span class="koboSpan" id="kobo.2187.1">, m);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2188.1">if</span></span><span class="koboSpan" id="kobo.2189.1"> (value) std::cout &lt;&lt; *value &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2190.1">'\n'</span></span><span class="koboSpan" id="kobo.2191.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2192.1">// two</span></span><span class="koboSpan" id="kobo.2193.1">
value = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2194.1">find</span></span><span class="koboSpan" id="kobo.2195.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2196.1">4</span></span><span class="koboSpan" id="kobo.2197.1">, m);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2198.1">if</span></span><span class="koboSpan" id="kobo.2199.1"> (value) std::cout &lt;&lt; *value &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2200.1">'\n'</span></span><span class="koboSpan" id="kobo.2201.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2202.1">Parameters</span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.2203.1"> to functions that are optional:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.2204.1">std::string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2205.1">extract</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2206.1">(std::string </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2207.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2208.1"> &amp; text,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.2209.1">                    std::optional&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2210.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2211.1">&gt; start,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.2212.1">                    std::optional&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2213.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2214.1">&gt; end)</span></span><span class="koboSpan" id="kobo.2215.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2216.1">auto</span></span><span class="koboSpan" id="kobo.2217.1"> s = start.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2218.1">value_or</span></span><span class="koboSpan" id="kobo.2219.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2220.1">0</span></span><span class="koboSpan" id="kobo.2221.1">);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2222.1">auto</span></span><span class="koboSpan" id="kobo.2223.1"> e = end.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2224.1">value_or</span></span><span class="koboSpan" id="kobo.2225.1">(text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2226.1">length</span></span><span class="koboSpan" id="kobo.2227.1">());
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2228.1">return</span></span><span class="koboSpan" id="kobo.2229.1"> text.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2230.1">substr</span></span><span class="koboSpan" id="kobo.2231.1">(s, e - s);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2232.1">auto</span></span><span class="koboSpan" id="kobo.2233.1"> v1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2234.1">extract</span></span><span class="koboSpan" id="kobo.2235.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2236.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2237.1">sample"</span></span><span class="koboSpan" id="kobo.2238.1">s, {}, {});
std::cout &lt;&lt; v1 &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2239.1">'\n'</span></span><span class="koboSpan" id="kobo.2240.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2241.1">// sample</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2242.1">auto</span></span><span class="koboSpan" id="kobo.2243.1"> v2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2244.1">extract</span></span><span class="koboSpan" id="kobo.2245.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2246.1">"sample"</span></span><span class="koboSpan" id="kobo.2247.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2248.1">1</span></span><span class="koboSpan" id="kobo.2249.1">, {});
std::cout &lt;&lt; v2 &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2250.1">'\n'</span></span><span class="koboSpan" id="kobo.2251.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2252.1">// ample</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2253.1">auto</span></span><span class="koboSpan" id="kobo.2254.1"> v3 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2255.1">extract</span></span><span class="koboSpan" id="kobo.2256.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2257.1">"sample"</span></span><span class="koboSpan" id="kobo.2258.1">s, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2259.1">1</span></span><span class="koboSpan" id="kobo.2260.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2261.1">4</span></span><span class="koboSpan" id="kobo.2262.1">);
std::cout &lt;&lt; v3 &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2263.1">'\n'</span></span><span class="koboSpan" id="kobo.2264.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2265.1">// amp</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2266.1">Class data members that are optional:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2267.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2268.1">book</span></span><span class="koboSpan" id="kobo.2269.1">
{
  std::string                title;
  std::optional&lt;std::string&gt; subtitle;
  std::vector&lt;std::string&gt;   authors;
  std::string                publisher;
  std::string                isbn;
  std::optional&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2270.1">int</span></span><span class="koboSpan" id="kobo.2271.1">&gt;         pages;
  std::optional&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2272.1">int</span></span><span class="koboSpan" id="kobo.2273.1">&gt;         year;
};
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-361"><span class="koboSpan" id="kobo.2274.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2275.1">The class</span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.2276.1"> template </span><code class="inlineCode"><span class="koboSpan" id="kobo.2277.1">std::optional</span></code><span class="koboSpan" id="kobo.2278.1"> is a class template that represents a container for an optional value. </span><span class="koboSpan" id="kobo.2278.2">If the container does have a value, that value is stored as part of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2279.1">optional</span></code><span class="koboSpan" id="kobo.2280.1"> object; no heap allocations and pointers are involved. </span><span class="koboSpan" id="kobo.2280.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2281.1">std::optional</span></code><span class="koboSpan" id="kobo.2282.1"> class template is conceptually implemented like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2283.1">template</span></span><span class="koboSpan" id="kobo.2284.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2285.1">typename</span></span><span class="koboSpan" id="kobo.2286.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2287.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2288.1">optional</span></span><span class="koboSpan" id="kobo.2289.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2290.1">bool</span></span><span class="koboSpan" id="kobo.2291.1"> _initialized;
  std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.2292.1">aligned_storage_t</span></span><span class="koboSpan" id="kobo.2293.1">&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2294.1">sizeof</span></span><span class="koboSpan" id="kobo.2295.1">(t), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2296.1">alignof</span></span><span class="koboSpan" id="kobo.2297.1">(T)&gt; _storage;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2298.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2299.1">std::aligned_storage_t</span></code><span class="koboSpan" id="kobo.2300.1"> alias template allows us to create uninitialized chunks of memory that can hold objects of a given type. </span><span class="koboSpan" id="kobo.2300.2">The class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.2301.1">std::optional</span></code><span class="koboSpan" id="kobo.2302.1"> does not contain a value if it was default constructed, or if it was copy constructed or copy assigned from another empty optional object or from a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2303.1">std::nullopt_t</span></code><span class="koboSpan" id="kobo.2304.1"> value. </span><span class="koboSpan" id="kobo.2304.2">Such a value is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2305.1">std::nullopt</span></code><span class="koboSpan" id="kobo.2306.1">, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2307.1">constexpr</span></code><span class="koboSpan" id="kobo.2308.1"> value used to indicate an optional object with an uninitialized state. </span><span class="koboSpan" id="kobo.2308.2">This is a helper type, implemented as an empty class, that indicates an optional object with an uninitialized state.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2309.1">The typical use for an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2310.1">optional</span></code><span class="koboSpan" id="kobo.2311.1"> type (called </span><em class="italic"><span class="koboSpan" id="kobo.2312.1">nullable</span></em><span class="koboSpan" id="kobo.2313.1"> in other programming languages) is the return type from a function that may fail. </span><span class="koboSpan" id="kobo.2313.2">Possible solutions for this situation include the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2314.1">Return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2315.1">std::pair&lt;T, bool&gt;</span></code><span class="koboSpan" id="kobo.2316.1">, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.2317.1">T</span></code><span class="koboSpan" id="kobo.2318.1"> is the type of the return value; the second element of the pair is a Boolean flag that indicates whether the value of the first element is valid or not.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2319.1">Return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2320.1">bool</span></code><span class="koboSpan" id="kobo.2321.1">, take an extra parameter of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.2322.1">T&amp;</span></code><span class="koboSpan" id="kobo.2323.1">, and assign a value to this parameter only if the function succeeds.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2324.1">Return a raw or smart pointer type, and use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2325.1">nullptr</span></code><span class="koboSpan" id="kobo.2326.1"> to indicate a failure.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2327.1">The class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.2328.1">std::optional</span></code><span class="koboSpan" id="kobo.2329.1"> is a better approach because, on the one hand, it does not involve output parameters to the function (which, outside of C and C++, is not the canonical form for returning values) and does not require working with pointers, and on the other hand, it better encapsulates the details of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2330.1">std::pair&lt;T, bool&gt;</span></code><span class="koboSpan" id="kobo.2331.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2332.1">However, optional objects can also be used for class data members, and compilers are able to optimize the memory layout for efficient storage.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2333.1">The class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.2334.1">std::optional</span></code><span class="koboSpan" id="kobo.2335.1"> cannot be used to return polymorphic types. </span><span class="koboSpan" id="kobo.2335.2">If you write, for instance, a factory method that needs to return different types from a hierarchy of types, you cannot rely on </span><code class="inlineCode"><span class="koboSpan" id="kobo.2336.1">std::optional</span></code><span class="koboSpan" id="kobo.2337.1"> and need to return a pointer, preferably a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2338.1">std::unique_ptr</span></code><span class="koboSpan" id="kobo.2339.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2340.1">std::shared_ptr</span></code><span class="koboSpan" id="kobo.2341.1"> (depending on whether ownership of the object needs to be shared or not).</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2342.1">When you</span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.2343.1"> use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2344.1">std::optional</span></code><span class="koboSpan" id="kobo.2345.1"> to pass optional arguments to a function, you need to understand that it may incur creating copies, which can be a performance issue if large objects are involved. </span><span class="koboSpan" id="kobo.2345.2">Let’s consider the following example of a function that has a constant reference to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2346.1">std::optional</span></code><span class="koboSpan" id="kobo.2347.1"> parameter:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2348.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2349.1">bar</span></span><span class="koboSpan" id="kobo.2350.1"> { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2351.1">/* details */</span></span><span class="koboSpan" id="kobo.2352.1"> };
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2353.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2354.1">process</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2355.1">(std::optional&lt;bar&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2356.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2357.1"> &amp; arg)</span></span><span class="koboSpan" id="kobo.2358.1">
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2359.1">/* do something with arg */</span></span><span class="koboSpan" id="kobo.2360.1">
}
std::optional&lt;bar&gt; b1{ bar{} };
bar b2{};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2361.1">process</span></span><span class="koboSpan" id="kobo.2362.1">(b1); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2363.1">// no copy</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.2364.1">process</span></span><span class="koboSpan" id="kobo.2365.1">(b2); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2366.1">// copy construction</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2367.1">The first call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2368.1">process()</span></code><span class="koboSpan" id="kobo.2369.1"> does not involve any additional object construction because we pass a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2370.1">std::optional&lt;bar&gt;</span></code><span class="koboSpan" id="kobo.2371.1"> object. </span><span class="koboSpan" id="kobo.2371.2">The second call, however, will involve the copy construction of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2372.1">bar</span></code><span class="koboSpan" id="kobo.2373.1"> object, because </span><code class="inlineCode"><span class="koboSpan" id="kobo.2374.1">b2</span></code><span class="koboSpan" id="kobo.2375.1"> is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2376.1">bar</span></code><span class="koboSpan" id="kobo.2377.1"> and needs to be copied to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2378.1">std::optional&lt;bar&gt;</span></code><span class="koboSpan" id="kobo.2379.1">; a copy is made even if </span><code class="inlineCode"><span class="koboSpan" id="kobo.2380.1">bar</span></code><span class="koboSpan" id="kobo.2381.1"> has move semantics implemented. </span><span class="koboSpan" id="kobo.2381.2">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.2382.1">bar</span></code><span class="koboSpan" id="kobo.2383.1"> is a small object, this shouldn’t be of great concern, but for large objects, it can prove to be a performance issue. </span><span class="koboSpan" id="kobo.2383.2">The solution to avoid this depends on the context and can involve creating a second overload that takes a constant reference to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2384.1">bar</span></code><span class="koboSpan" id="kobo.2385.1">, or entirely avoiding using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2386.1">std::optional</span></code><span class="koboSpan" id="kobo.2387.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-362"><span class="koboSpan" id="kobo.2388.1">There’s more…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2389.1">Although </span><code class="inlineCode"><span class="koboSpan" id="kobo.2390.1">std::optional</span></code><span class="koboSpan" id="kobo.2391.1"> makes it easier to return a value from a function that may also fail, chaining together multiple such functions produces code that can be cumbersome or at least too repetitive. </span><span class="koboSpan" id="kobo.2391.2">To ease this scenario, in C++23, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2392.1">std::optional</span></code><span class="koboSpan" id="kobo.2393.1"> has several additional members (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2394.1">transform()</span></code><span class="koboSpan" id="kobo.2395.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2396.1">and_then()</span></code><span class="koboSpan" id="kobo.2397.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2398.1">or_else()</span></code><span class="koboSpan" id="kobo.2399.1">) called monadic operations. </span><span class="koboSpan" id="kobo.2399.2">We will learn about these in the next recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-363"><span class="koboSpan" id="kobo.2400.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2401.1">Using std::any to store any value</span></em><span class="koboSpan" id="kobo.2402.1">, to learn how to use the C++17 class </span><code class="inlineCode"><span class="koboSpan" id="kobo.2403.1">std::any</span></code><span class="koboSpan" id="kobo.2404.1">, which represents a type-safe container for single values of any type</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2405.1">Using std::variant as a type-safe union</span></em><span class="koboSpan" id="kobo.2406.1">, to learn how to use the C++17 </span><code class="inlineCode"><span class="koboSpan" id="kobo.2407.1">std::variant</span></code><span class="koboSpan" id="kobo.2408.1"> class to represent type-safe unions</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2409.1">Chaining together computations that may or may not produce a value</span></em><span class="koboSpan" id="kobo.2410.1">, to see how the new C++23 monadic operations of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2411.1">std::optional</span></code><span class="koboSpan" id="kobo.2412.1"> simplify scenarios where multiple functions returning </span><code class="inlineCode"><span class="koboSpan" id="kobo.2413.1">std::optional</span></code><span class="koboSpan" id="kobo.2414.1"> are called sequentially</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-364"><span class="koboSpan" id="kobo.2415.1">Chaining together computations that may or may not produce a value</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2416.1">In the </span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.2417.1">previous recipe, we have seen how to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2418.1">std::optional</span></code><span class="koboSpan" id="kobo.2419.1"> class for storing a value that may or may not exist. </span><span class="koboSpan" id="kobo.2419.2">Its use cases include optional parameters to functions and return values from functions that may fail to produce a result. </span><span class="koboSpan" id="kobo.2419.3">When multiple such functions need to be chained together, the code can become cumbersome and verbose. </span><span class="koboSpan" id="kobo.2419.4">For this reason, the C++23 standard has added several new methods to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2420.1">std::optional</span></code><span class="koboSpan" id="kobo.2421.1"> class. </span><span class="koboSpan" id="kobo.2421.2">They are referred to by the term </span><strong class="keyWord"><span class="koboSpan" id="kobo.2422.1">monadic operations</span></strong><span class="koboSpan" id="kobo.2423.1">. </span><span class="koboSpan" id="kobo.2423.2">These methods are </span><code class="inlineCode"><span class="koboSpan" id="kobo.2424.1">transform()</span></code><span class="koboSpan" id="kobo.2425.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2426.1">and_then()</span></code><span class="koboSpan" id="kobo.2427.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2428.1">or_else()</span></code><span class="koboSpan" id="kobo.2429.1">. </span><span class="koboSpan" id="kobo.2429.2">In this recipe, we’ll see what they are useful for.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2430.1">In simple terms, in functional programming, a </span><strong class="keyWord"><span class="koboSpan" id="kobo.2431.1">monad</span></strong><span class="koboSpan" id="kobo.2432.1"> is a container that encapsulates some functionality on top of a value that it wraps. </span><span class="koboSpan" id="kobo.2432.2">Such an example is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2433.1">std::optional</span></code><span class="koboSpan" id="kobo.2434.1"> in C++. </span><span class="koboSpan" id="kobo.2434.2">On the other hand, a </span><strong class="keyWord"><span class="koboSpan" id="kobo.2435.1">monadic operation</span></strong><span class="koboSpan" id="kobo.2436.1"> is a function from a domain </span><em class="italic"><span class="koboSpan" id="kobo.2437.1">D</span></em><span class="koboSpan" id="kobo.2438.1"> into </span><em class="italic"><span class="koboSpan" id="kobo.2439.1">D</span></em><span class="koboSpan" id="kobo.2440.1"> itself. </span><span class="koboSpan" id="kobo.2440.2">For instance, the </span><strong class="keyWord"><span class="koboSpan" id="kobo.2441.1">identity function</span></strong><span class="koboSpan" id="kobo.2442.1"> (a function that returns its argument) is a monadic operation. </span><span class="koboSpan" id="kobo.2442.2">The newly added functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2443.1">transform()</span></code><span class="koboSpan" id="kobo.2444.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2445.1">and_then()</span></code><span class="koboSpan" id="kobo.2446.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2447.1">or_else()</span></code><span class="koboSpan" id="kobo.2448.1"> are monadic because they take a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2449.1">std::optional</span></code><span class="koboSpan" id="kobo.2450.1"> and return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2451.1">std::optional</span></code><span class="koboSpan" id="kobo.2452.1">.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-365"><span class="koboSpan" id="kobo.2453.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2454.1">In the</span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.2455.1"> following sections, we will refer to the definitions shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2456.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2457.1">booking</span></span><span class="koboSpan" id="kobo.2458.1">
{
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2459.1">int</span></span><span class="koboSpan" id="kobo.2460.1">                        id;
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2461.1">int</span></span><span class="koboSpan" id="kobo.2462.1">                        nights;
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.2463.1">double</span></span><span class="koboSpan" id="kobo.2464.1">                     rate;
   std::string                description;
   std::vector&lt;std::string&gt;   extras;
};
</span><span class="hljs-function"><span class="koboSpan" id="kobo.2465.1">std::optional&lt;booking&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2466.1">make_booking</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2467.1">(std::string_view description, </span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2468.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2469.1"> nights, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2470.1">double</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2471.1"> rate)</span></span><span class="koboSpan" id="kobo.2472.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.2473.1">std::optional&lt;booking&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2474.1">add_rental</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2475.1">(std::optional&lt;booking&gt; b)</span></span><span class="koboSpan" id="kobo.2476.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.2477.1">std::optional&lt;booking&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2478.1">add_insurance</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2479.1">(std::optional&lt;booking&gt; b)</span></span><span class="koboSpan" id="kobo.2480.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2481.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2482.1">calculate_price</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2483.1">(std::optional&lt;booking&gt; b)</span></span><span class="koboSpan" id="kobo.2484.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2485.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2486.1">apply_discount</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2487.1">(std::optional&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2488.1">double</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2489.1">&gt; p)</span></span><span class="koboSpan" id="kobo.2490.1">;
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-366"><span class="koboSpan" id="kobo.2491.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2492.1">You can use the following monadic operations as per your use case:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2493.1">If you have an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2494.1">optional</span></code><span class="koboSpan" id="kobo.2495.1"> value and want to apply a function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2496.1">f</span></code><span class="koboSpan" id="kobo.2497.1"> and return the value of that invocation, then use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2498.1">transform()</span></code><span class="koboSpan" id="kobo.2499.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2500.1">auto</span></span><span class="koboSpan" id="kobo.2501.1"> b = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2502.1">make_booking</span></span><span class="koboSpan" id="kobo.2503.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2504.1">"Hotel California"</span></span><span class="koboSpan" id="kobo.2505.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2506.1">3</span></span><span class="koboSpan" id="kobo.2507.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2508.1">300</span></span><span class="koboSpan" id="kobo.2509.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2510.1">auto</span></span><span class="koboSpan" id="kobo.2511.1"> p = b.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2512.1">transform</span></span><span class="koboSpan" id="kobo.2513.1">(calculate_price);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2514.1">If you have an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2515.1">optional</span></code><span class="koboSpan" id="kobo.2516.1"> value and want to apply a function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2517.1">f</span></code><span class="koboSpan" id="kobo.2518.1"> that returns an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2519.1">optional</span></code><span class="koboSpan" id="kobo.2520.1"> and then return the value of that invocation, then use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2521.1">and_then()</span></code><span class="koboSpan" id="kobo.2522.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2523.1">auto</span></span><span class="koboSpan" id="kobo.2524.1"> b = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2525.1">make_booking</span></span><span class="koboSpan" id="kobo.2526.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2527.1">"Hotel California"</span></span><span class="koboSpan" id="kobo.2528.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2529.1">3</span></span><span class="koboSpan" id="kobo.2530.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2531.1">300</span></span><span class="koboSpan" id="kobo.2532.1">);
     b = b.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2533.1">and_then</span></span><span class="koboSpan" id="kobo.2534.1">(add_insurance);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2535.1">auto</span></span><span class="koboSpan" id="kobo.2536.1"> p = b.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2537.1">transform</span></span><span class="koboSpan" id="kobo.2538.1">(calculate_price);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2539.1">If you have an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2540.1">optional</span></code><span class="koboSpan" id="kobo.2541.1"> value that could be empty, in which case you want to invoke a function to handle the situation (such as to log or throw an exception) and return another </span><code class="inlineCode"><span class="koboSpan" id="kobo.2542.1">optional</span></code><span class="koboSpan" id="kobo.2543.1"> (either an alternative value or an empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.2544.1">optional</span></code><span class="koboSpan" id="kobo.2545.1">), then use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2546.1">or_else()</span></code><span class="koboSpan" id="kobo.2547.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2548.1">auto</span></span><span class="koboSpan" id="kobo.2549.1"> b = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2550.1">make_booking</span></span><span class="koboSpan" id="kobo.2551.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2552.1">"Hotel California"</span></span><span class="koboSpan" id="kobo.2553.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2554.1">3</span></span><span class="koboSpan" id="kobo.2555.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2556.1">300</span></span><span class="koboSpan" id="kobo.2557.1">)
         .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2558.1">or_else</span></span><span class="koboSpan" id="kobo.2559.1">([]() -&gt; std::optional&lt;booking&gt; {
            std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2560.1">"creating the booking failed!\n"</span></span><span class="koboSpan" id="kobo.2561.1">;  
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2562.1">return</span></span><span class="koboSpan" id="kobo.2563.1"> std::</span><span class="hljs-literal"><span class="koboSpan" id="kobo.2564.1">nullopt</span></span><span class="koboSpan" id="kobo.2565.1">; 
         });
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2566.1">A larger</span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.2567.1"> example is shown in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2568.1">auto</span></span><span class="koboSpan" id="kobo.2569.1"> p =
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2570.1">make_booking</span></span><span class="koboSpan" id="kobo.2571.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2572.1">"Hotel California"</span></span><span class="koboSpan" id="kobo.2573.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2574.1">3</span></span><span class="koboSpan" id="kobo.2575.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2576.1">300</span></span><span class="koboSpan" id="kobo.2577.1">)
   .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2578.1">and_then</span></span><span class="koboSpan" id="kobo.2579.1">(add_rental)
   .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2580.1">and_then</span></span><span class="koboSpan" id="kobo.2581.1">(add_insurance)
   .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2582.1">or_else</span></span><span class="koboSpan" id="kobo.2583.1">([]() -&gt; std::optional&lt;booking&gt; {
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2584.1">"creating the booking failed!\n"</span></span><span class="koboSpan" id="kobo.2585.1">;  
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2586.1">return</span></span><span class="koboSpan" id="kobo.2587.1"> std::</span><span class="hljs-literal"><span class="koboSpan" id="kobo.2588.1">nullopt</span></span><span class="koboSpan" id="kobo.2589.1">; })
   .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2590.1">transform</span></span><span class="koboSpan" id="kobo.2591.1">(calculate_price)
   .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2592.1">transform</span></span><span class="koboSpan" id="kobo.2593.1">(apply_discount)
   .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2594.1">or_else</span></span><span class="koboSpan" id="kobo.2595.1">([]() -&gt; std::optional&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2596.1">double</span></span><span class="koboSpan" id="kobo.2597.1">&gt; {
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2598.1">"computing price failed!\n"</span></span><span class="koboSpan" id="kobo.2599.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2600.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2601.1">-1</span></span><span class="koboSpan" id="kobo.2602.1">; });
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-367"><span class="koboSpan" id="kobo.2603.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2604.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2605.1">and_then()</span></code><span class="koboSpan" id="kobo.2606.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2607.1">transform()</span></code><span class="koboSpan" id="kobo.2608.1"> member functions are very similar. </span><span class="koboSpan" id="kobo.2608.2">They actually have the same number of overloads with the same signature. </span><span class="koboSpan" id="kobo.2608.3">They take a single argument that is a function or callable object and they both return an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2609.1">optional</span></code><span class="koboSpan" id="kobo.2610.1">. </span><span class="koboSpan" id="kobo.2610.2">If the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2611.1">optional</span></code><span class="koboSpan" id="kobo.2612.1"> does not hold a value, then both </span><code class="inlineCode"><span class="koboSpan" id="kobo.2613.1">and_then()</span></code><span class="koboSpan" id="kobo.2614.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2615.1">transform()</span></code><span class="koboSpan" id="kobo.2616.1"> return an empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.2617.1">optional</span></code><span class="koboSpan" id="kobo.2618.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2619.1">Otherwise, if the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2620.1">optional</span></code><span class="koboSpan" id="kobo.2621.1"> does hold a value, then it invokes the function or callable with the stored value. </span><span class="koboSpan" id="kobo.2621.2">Here is where they differ:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2622.1">The function/callable passed to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2623.1">and_then()</span></code><span class="koboSpan" id="kobo.2624.1"> must itself return a value of a type that is a specialization of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2625.1">std::optional</span></code><span class="koboSpan" id="kobo.2626.1">. </span><span class="koboSpan" id="kobo.2626.2">This will be the value returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.2627.1">and_then()</span></code><span class="koboSpan" id="kobo.2628.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2629.1">The function/callable passed to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2630.1">transform()</span></code><span class="koboSpan" id="kobo.2631.1"> may have any return type that is not a reference type. </span><span class="koboSpan" id="kobo.2631.2">However, the value it returns will itself be wrapped in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2632.1">std::optional</span></code><span class="koboSpan" id="kobo.2633.1"> before being returned from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2634.1">transform()</span></code><span class="koboSpan" id="kobo.2635.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2636.1">To exemplify this better, let’s consider the following function again:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2637.1">double</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2638.1">calculate_price</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2639.1">(std::optional&lt;booking&gt; b)</span></span><span class="koboSpan" id="kobo.2640.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2641.1">Previously, we have seen this snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2642.1">auto</span></span><span class="koboSpan" id="kobo.2643.1"> b = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2644.1">make_booking</span></span><span class="koboSpan" id="kobo.2645.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2646.1">"Hotel California"</span></span><span class="koboSpan" id="kobo.2647.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2648.1">3</span></span><span class="koboSpan" id="kobo.2649.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2650.1">300</span></span><span class="koboSpan" id="kobo.2651.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2652.1">auto</span></span><span class="koboSpan" id="kobo.2653.1"> p = b.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2654.1">transform</span></span><span class="koboSpan" id="kobo.2655.1">(calculate_price);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2656.1">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2657.1">p</span></code><span class="koboSpan" id="kobo.2658.1"> has</span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.2659.1"> the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.2660.1">std::optional&lt;double&gt;</span></code><span class="koboSpan" id="kobo.2661.1">. </span><span class="koboSpan" id="kobo.2661.2">This is because </span><code class="inlineCode"><span class="koboSpan" id="kobo.2662.1">calculate_price()</span></code><span class="koboSpan" id="kobo.2663.1"> returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2664.1">double</span></code><span class="koboSpan" id="kobo.2665.1">, and, therefore, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2666.1">transform()</span></code><span class="koboSpan" id="kobo.2667.1"> will return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2668.1">std::optional&lt;double&gt;</span></code><span class="koboSpan" id="kobo.2669.1">. </span><span class="koboSpan" id="kobo.2669.2">Let’s change the signature of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2670.1">calculate_price()</span></code><span class="koboSpan" id="kobo.2671.1"> to return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2672.1">std::optional&lt;double&gt;</span></code><span class="koboSpan" id="kobo.2673.1"> instead:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.2674.1">std::optional&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2675.1">double</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2676.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2677.1">calculate_price</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2678.1">(std::optional&lt;booking&gt; b)</span></span><span class="koboSpan" id="kobo.2679.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2680.1">The variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.2681.1">p</span></code><span class="koboSpan" id="kobo.2682.1"> will now have the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.2683.1">std::optional&lt;std::optional&lt;double&gt;&gt;</span></code><span class="koboSpan" id="kobo.2684.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2685.1">The third monadic function, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2686.1">or_else()</span></code><span class="koboSpan" id="kobo.2687.1">, is the opposite of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2688.1">and_then()</span></code><span class="koboSpan" id="kobo.2689.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2690.1">transform()</span></code><span class="koboSpan" id="kobo.2691.1">: if the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2692.1">optional</span></code><span class="koboSpan" id="kobo.2693.1"> object contains a value, it returns the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2694.1">optional</span></code><span class="koboSpan" id="kobo.2695.1"> without doing anything. </span><span class="koboSpan" id="kobo.2695.2">Otherwise, it invokes its single argument, which is a function or callable without any argument, and returns the value from this invocation. </span><span class="koboSpan" id="kobo.2695.3">The return type of the function/callable must be </span><code class="inlineCode"><span class="koboSpan" id="kobo.2696.1">std::optional&lt;T&gt;</span></code><span class="koboSpan" id="kobo.2697.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2698.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2699.1">or_else()</span></code><span class="koboSpan" id="kobo.2700.1"> function is typically used for handling erroneous situations when an expected value is missing. </span><span class="koboSpan" id="kobo.2700.2">The supplied function could perhaps add an entry to a log, throw an exception, or do something else. </span><span class="koboSpan" id="kobo.2700.3">Unless this callable throws an exception, it must return a value. </span><span class="koboSpan" id="kobo.2700.4">This can be an empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.2701.1">optional</span></code><span class="koboSpan" id="kobo.2702.1"> or an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2703.1">optional</span></code><span class="koboSpan" id="kobo.2704.1"> holding a default value or some alternative to the missing value.</span></p>
<h2 class="heading-2" id="_idParaDest-368"><span class="koboSpan" id="kobo.2705.1">There’s more…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2706.1">One of the most important use cases for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2707.1">std::optional</span></code><span class="koboSpan" id="kobo.2708.1"> is to return a value from a function that may or may not produce one. </span><span class="koboSpan" id="kobo.2708.2">However, when a value is missing, we probably need to know the reason for the failure. </span><span class="koboSpan" id="kobo.2708.3">This is not directly possible with optional, unless the stored type is a compound of a value and an error, or if we use additional parameters to the function to retrieve the error. </span><span class="koboSpan" id="kobo.2708.4">For this reason, the C++23 standard includes an alternative for these use cases for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2709.1">std::optional</span></code><span class="koboSpan" id="kobo.2710.1">, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2711.1">std::expected</span></code><span class="koboSpan" id="kobo.2712.1"> type.</span></p>
<h2 class="heading-2" id="_idParaDest-369"><span class="koboSpan" id="kobo.2713.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2714.1">Using std::expected to return a value or an error</span></em><span class="koboSpan" id="kobo.2715.1">, to see how this C++23 type allows us to return a value or an error code from a function</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-370"><span class="koboSpan" id="kobo.2716.1">Using std::variant as a type-safe union</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2717.1">In C++, a</span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.2718.1"> union type is a special class type that, at any point, holds a value of one of its data members. </span><span class="koboSpan" id="kobo.2718.2">Unlike regular classes, unions </span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.2719.1">cannot have base classes, nor can they be derived, and they cannot contain virtual functions (that would not make sense anyway). </span><span class="koboSpan" id="kobo.2719.2">Unions are mostly used to define different representations of the same data. </span><span class="koboSpan" id="kobo.2719.3">However, unions only work for types that are </span><strong class="keyWord"><span class="koboSpan" id="kobo.2720.1">Plain Old Data</span></strong><span class="koboSpan" id="kobo.2721.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.2722.1">POD</span></strong><span class="koboSpan" id="kobo.2723.1">). </span><span class="koboSpan" id="kobo.2723.2">If a</span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.2724.1"> union contains values of non-POD types, then these members require explicit construction with a placement </span><code class="inlineCode"><span class="koboSpan" id="kobo.2725.1">new</span></code><span class="koboSpan" id="kobo.2726.1"> and explicit destruction, which is cumbersome and error-prone. </span><span class="koboSpan" id="kobo.2726.2">In C++17, a type-safe union is available in the form of a standard library class template called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2727.1">std::variant</span></code><span class="koboSpan" id="kobo.2728.1">. </span><span class="koboSpan" id="kobo.2728.2">In this recipe, you will learn how to use it to model alternative values.</span></p>
<h2 class="heading-2" id="_idParaDest-371"><span class="koboSpan" id="kobo.2729.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2730.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2731.1">std::variant</span></code><span class="koboSpan" id="kobo.2732.1"> type implements</span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.2733.1"> a type-safe </span><strong class="keyWord"><span class="koboSpan" id="kobo.2734.1">discriminated union</span></strong><span class="koboSpan" id="kobo.2735.1">. </span><span class="koboSpan" id="kobo.2735.2">Although discussing these in detail is beyond the scope of this recipe, we will introduce them briefly here. </span><span class="koboSpan" id="kobo.2735.3">Being familiar with discriminated unions will help us better understand the design of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2736.1">variant</span></code><span class="koboSpan" id="kobo.2737.1"> and the way it works.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2738.1">Discriminated unions </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.2739.1">are also </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.2740.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.2741.1">tagged unions</span></strong><span class="koboSpan" id="kobo.2742.1"> or </span><strong class="keyWord"><span class="koboSpan" id="kobo.2743.1">disjoint unions</span></strong><span class="koboSpan" id="kobo.2744.1">. </span><span class="koboSpan" id="kobo.2744.2">A </span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.2745.1">discriminated union is a data type that is able to store one value of a collection of types and offer type-safe access for that value. </span><span class="koboSpan" id="kobo.2745.2">In C++, this is typically implemented as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2746.1">enum</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2747.1">VARTAG</span></span><span class="koboSpan" id="kobo.2748.1"> {VT_int, VT_double, VT_pint, TP_pdouble </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2749.1">/* more */</span></span><span class="koboSpan" id="kobo.2750.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2751.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2752.1">variant_t</span></span><span class="koboSpan" id="kobo.2753.1">
{
  VARTAG tag;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2754.1">union</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2755.1">Value</span></span><span class="koboSpan" id="kobo.2756.1"> 
  {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.2757.1">int</span></span><span class="koboSpan" id="kobo.2758.1">     i;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.2759.1">int</span></span><span class="koboSpan" id="kobo.2760.1">*    pi;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.2761.1">double</span></span><span class="koboSpan" id="kobo.2762.1">  d;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.2763.1">double</span></span><span class="koboSpan" id="kobo.2764.1">* pd;
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2765.1">/* more */</span></span><span class="koboSpan" id="kobo.2766.1">
  } value;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2767.1">For Windows programmers, a well-known discriminated union is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2768.1">VARIANT</span></code><span class="koboSpan" id="kobo.2769.1"> structure used</span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.2770.1"> in </span><strong class="keyWord"><span class="koboSpan" id="kobo.2771.1">Component Object Model</span></strong><span class="koboSpan" id="kobo.2772.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.2773.1">COM)</span></strong><span class="koboSpan" id="kobo.2774.1"> programming.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2775.1">The class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.2776.1">std::variant</span></code><span class="koboSpan" id="kobo.2777.1"> was designed based on </span><code class="inlineCode"><span class="koboSpan" id="kobo.2778.1">boost::variant</span></code><span class="koboSpan" id="kobo.2779.1">, and is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2780.1">&lt;variant&gt;</span></code><span class="koboSpan" id="kobo.2781.1"> header. </span><span class="koboSpan" id="kobo.2781.2">If you are familiar with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2782.1">boost::variant</span></code><span class="koboSpan" id="kobo.2783.1"> and have used it in your code, you can migrate your code with little effort to use the standard </span><code class="inlineCode"><span class="koboSpan" id="kobo.2784.1">variant</span></code><span class="koboSpan" id="kobo.2785.1"> class template.</span></p>
<h2 class="heading-2" id="_idParaDest-372"><span class="koboSpan" id="kobo.2786.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2787.1">Use</span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.2788.1"> the </span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.2789.1">following operations to work with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2790.1">std::variant</span></code><span class="koboSpan" id="kobo.2791.1">:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2792.1">To modify the stored value, use the member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2793.1">emplace()</span></code><span class="koboSpan" id="kobo.2794.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2795.1">swap()</span></code><span class="koboSpan" id="kobo.2796.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2797.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2798.1">foo</span></span><span class="koboSpan" id="kobo.2799.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2800.1">int</span></span><span class="koboSpan" id="kobo.2801.1"> value;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2802.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2803.1">foo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2804.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2805.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2806.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2807.1"> i)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2808.1"> : value(i) {</span></span><span class="koboSpan" id="kobo.2809.1">}
};
std::variant&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2810.1">int</span></span><span class="koboSpan" id="kobo.2811.1">, std::string, foo&gt; v = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2812.1">42</span></span><span class="koboSpan" id="kobo.2813.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2814.1">// holds int</span></span><span class="koboSpan" id="kobo.2815.1">
v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2816.1">emplace</span></span><span class="koboSpan" id="kobo.2817.1">&lt;foo&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2818.1">42</span></span><span class="koboSpan" id="kobo.2819.1">);                         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2820.1">// holds foo</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2821.1">To read the stored values, use the non-member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2822.1">std::get</span></code><span class="koboSpan" id="kobo.2823.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2824.1">std::get_if</span></code><span class="koboSpan" id="kobo.2825.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2826.1">std::variant&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2827.1">int</span></span><span class="koboSpan" id="kobo.2828.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2829.1">double</span></span><span class="koboSpan" id="kobo.2830.1">, std::string&gt; v = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2831.1">42</span></span><span class="koboSpan" id="kobo.2832.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2833.1">auto</span></span><span class="koboSpan" id="kobo.2834.1"> i1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2835.1">get</span></span><span class="koboSpan" id="kobo.2836.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2837.1">int</span></span><span class="koboSpan" id="kobo.2838.1">&gt;(v);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2839.1">auto</span></span><span class="koboSpan" id="kobo.2840.1"> i2 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2841.1">get</span></span><span class="koboSpan" id="kobo.2842.1">&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.2843.1">0</span></span><span class="koboSpan" id="kobo.2844.1">&gt;(v);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2845.1">try</span></span><span class="koboSpan" id="kobo.2846.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2847.1">auto</span></span><span class="koboSpan" id="kobo.2848.1"> f = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2849.1">get</span></span><span class="koboSpan" id="kobo.2850.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2851.1">double</span></span><span class="koboSpan" id="kobo.2852.1">&gt;(v);
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2853.1">catch</span></span><span class="koboSpan" id="kobo.2854.1"> (std::bad_variant_access </span><span class="hljs-type"><span class="koboSpan" id="kobo.2855.1">const</span></span><span class="koboSpan" id="kobo.2856.1"> &amp; e)
{
  std::cout &lt;&lt; e.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2857.1">what</span></span><span class="koboSpan" id="kobo.2858.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2859.1">'\n'</span></span><span class="koboSpan" id="kobo.2860.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2861.1">// Unexpected index</span></span><span class="koboSpan" id="kobo.2862.1">
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2863.1">To store a value, use the constructor or assign a value directly to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2864.1">variant</span></code><span class="koboSpan" id="kobo.2865.1"> object:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2866.1">std::variant&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2867.1">int</span></span><span class="koboSpan" id="kobo.2868.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2869.1">double</span></span><span class="koboSpan" id="kobo.2870.1">, std::string&gt; v;
v = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2871.1">42</span></span><span class="koboSpan" id="kobo.2872.1">;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2873.1">// v contains int 42</span></span><span class="koboSpan" id="kobo.2874.1">
v = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2875.1">42.0</span></span><span class="koboSpan" id="kobo.2876.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2877.1">// v contains double 42.0</span></span><span class="koboSpan" id="kobo.2878.1">
v = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2879.1">"42"</span></span><span class="koboSpan" id="kobo.2880.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2881.1">// v contains string "42"</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2882.1">To</span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.2883.1"> check what is the stored alternative, use the member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2884.1">index()</span></code><span class="koboSpan" id="kobo.2885.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2886.1">std::variant&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2887.1">int</span></span><span class="koboSpan" id="kobo.2888.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2889.1">double</span></span><span class="koboSpan" id="kobo.2890.1">, std::string&gt; v = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2891.1">42</span></span><span class="koboSpan" id="kobo.2892.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2893.1">static_assert</span></span><span class="koboSpan" id="kobo.2894.1">(std::variant_size_v&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2895.1">decltype</span></span><span class="koboSpan" id="kobo.2896.1">(v)&gt; == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2897.1">3</span></span><span class="koboSpan" id="kobo.2898.1">);
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2899.1">"index = "</span></span><span class="koboSpan" id="kobo.2900.1"> &lt;&lt; v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2901.1">index</span></span><span class="koboSpan" id="kobo.2902.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2903.1">'\n'</span></span><span class="koboSpan" id="kobo.2904.1">;
v = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2905.1">42.0</span></span><span class="koboSpan" id="kobo.2906.1">;
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2907.1">"index = "</span></span><span class="koboSpan" id="kobo.2908.1"> &lt;&lt; v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2909.1">index</span></span><span class="koboSpan" id="kobo.2910.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2911.1">'\n'</span></span><span class="koboSpan" id="kobo.2912.1">;
v = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2913.1">"42"</span></span><span class="koboSpan" id="kobo.2914.1">;
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2915.1">"index = "</span></span><span class="koboSpan" id="kobo.2916.1"> &lt;&lt; v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2917.1">index</span></span><span class="koboSpan" id="kobo.2918.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2919.1">'\n'</span></span><span class="koboSpan" id="kobo.2920.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2921.1">To </span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.2922.1">check whether a variant holds an alternative, use the non-member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2923.1">std::holds_alternative()</span></code><span class="koboSpan" id="kobo.2924.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2925.1">std::variant&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2926.1">int</span></span><span class="koboSpan" id="kobo.2927.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2928.1">double</span></span><span class="koboSpan" id="kobo.2929.1">, std::string&gt; v = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2930.1">42</span></span><span class="koboSpan" id="kobo.2931.1">;
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2932.1">"int? </span><span class="koboSpan" id="kobo.2932.2">"</span></span><span class="koboSpan" id="kobo.2933.1"> &lt;&lt; std::boolalpha
          &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2934.1">holds_alternative</span></span><span class="koboSpan" id="kobo.2935.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2936.1">int</span></span><span class="koboSpan" id="kobo.2937.1">&gt;(v)
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2938.1">'\n'</span></span><span class="koboSpan" id="kobo.2939.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2940.1">// int? </span><span class="koboSpan" id="kobo.2940.2">true</span></span><span class="koboSpan" id="kobo.2941.1">
v = </span><span class="hljs-string"><span class="koboSpan" id="kobo.2942.1">"42"</span></span><span class="koboSpan" id="kobo.2943.1">;
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2944.1">"int? </span><span class="koboSpan" id="kobo.2944.2">"</span></span><span class="koboSpan" id="kobo.2945.1"> &lt;&lt; std::boolalpha
          &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2946.1">holds_alternative</span></span><span class="koboSpan" id="kobo.2947.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2948.1">int</span></span><span class="koboSpan" id="kobo.2949.1">&gt;(v)
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2950.1">'\n'</span></span><span class="koboSpan" id="kobo.2951.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2952.1">// int? </span><span class="koboSpan" id="kobo.2952.2">false</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2953.1">To define a variant whose first alternative is not default constructible, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2954.1">std::monostate</span></code><span class="koboSpan" id="kobo.2955.1"> as the first alternative (in this example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2956.1">foo</span></code><span class="koboSpan" id="kobo.2957.1"> is the same class we used earlier):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2958.1">std::variant&lt;std::monostate, foo, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2959.1">int</span></span><span class="koboSpan" id="kobo.2960.1">&gt; v;
v = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2961.1">42</span></span><span class="koboSpan" id="kobo.2962.1">;        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2963.1">// v contains int 42</span></span><span class="koboSpan" id="kobo.2964.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2965.1">get</span></span><span class="koboSpan" id="kobo.2966.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2967.1">int</span></span><span class="koboSpan" id="kobo.2968.1">&gt;(v) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2969.1">'\n'</span></span><span class="koboSpan" id="kobo.2970.1">;
v = foo{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2971.1">42</span></span><span class="koboSpan" id="kobo.2972.1"> }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2973.1">// v contains foo{42}</span></span><span class="koboSpan" id="kobo.2974.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2975.1">get</span></span><span class="koboSpan" id="kobo.2976.1">&lt;foo&gt;(v).value &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2977.1">'\n'</span></span><span class="koboSpan" id="kobo.2978.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2979.1">To</span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.2980.1"> process the stored value of a variant and do something depending on the type of the alternative, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2981.1">std::visit()</span></code><span class="koboSpan" id="kobo.2982.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2983.1">std::variant&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2984.1">int</span></span><span class="koboSpan" id="kobo.2985.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2986.1">double</span></span><span class="koboSpan" id="kobo.2987.1">, std::string&gt; v = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2988.1">42</span></span><span class="koboSpan" id="kobo.2989.1">;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2990.1">visit</span></span><span class="koboSpan" id="kobo.2991.1">(
  [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2992.1">auto</span></span><span class="koboSpan" id="kobo.2993.1">&amp;&amp; arg) {std::cout &lt;&lt; arg &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2994.1">'\n'</span></span><span class="koboSpan" id="kobo.2995.1">; },
  v);
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-373"><span class="koboSpan" id="kobo.2996.1">How it works...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2997.1">std::variant</span></code><span class="koboSpan" id="kobo.2998.1"> is a</span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.2999.1"> class template that models a type-safe union, holding a value of one of its possible alternatives at any given time. </span><span class="koboSpan" id="kobo.2999.2">In some rare cases, though, it is possible that a variant object does not store any value. </span><code class="inlineCode"><span class="koboSpan" id="kobo.3000.1">std::variant</span></code><span class="koboSpan" id="kobo.3001.1"> has a member function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3002.1">valueless_by_exception()</span></code><span class="koboSpan" id="kobo.3003.1"> that returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.3004.1">true</span></code><span class="koboSpan" id="kobo.3005.1"> if the variant does not hold a value, which is possible only in case of an exception during initialization—therefore, the name of the function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3006.1">The size of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3007.1">std::variant</span></code><span class="koboSpan" id="kobo.3008.1"> object is as large as its largest alternative. </span><span class="koboSpan" id="kobo.3008.2">A variant does not store additional data. </span><span class="koboSpan" id="kobo.3008.3">The value stored by the variant is allocated within the memory representation of the object itself.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3009.1">A variant can hold multiple alternatives of the same type and also hold different constant- and volatile-qualified versions at the same time. </span><span class="koboSpan" id="kobo.3009.2">In this case, you cannot assign a value of the type used multiple types, but use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3010.1">emplace()</span></code><span class="koboSpan" id="kobo.3011.1"> member function instead, as shown in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3012.1">std::variant&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3013.1">int</span></span><span class="koboSpan" id="kobo.3014.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3015.1">int</span></span><span class="koboSpan" id="kobo.3016.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3017.1">double</span></span><span class="koboSpan" id="kobo.3018.1">&gt; v = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3019.1">33.0</span></span><span class="koboSpan" id="kobo.3020.1">;
v = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3021.1">42</span></span><span class="koboSpan" id="kobo.3022.1">;                               </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3023.1">// error</span></span><span class="koboSpan" id="kobo.3024.1">
v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3025.1">emplace</span></span><span class="koboSpan" id="kobo.3026.1">&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.3027.1">1</span></span><span class="koboSpan" id="kobo.3028.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3029.1">42</span></span><span class="koboSpan" id="kobo.3030.1">);                     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3031.1">// OK</span></span><span class="koboSpan" id="kobo.3032.1">
std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3033.1">get</span></span><span class="koboSpan" id="kobo.3034.1">&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.3035.1">1</span></span><span class="koboSpan" id="kobo.3036.1">&gt;(v) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3037.1">'\n'</span></span><span class="koboSpan" id="kobo.3038.1">;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3039.1">// prints 42</span></span><span class="koboSpan" id="kobo.3040.1">
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3041.1">holds_alternative</span></span><span class="koboSpan" id="kobo.3042.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3043.1">int</span></span><span class="koboSpan" id="kobo.3044.1">&gt;(v);       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3045.1">// error</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3046.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3047.1">std::holds_alternative()</span></code><span class="koboSpan" id="kobo.3048.1"> function mentioned earlier, which checks whether a variant holds an alternative type </span><code class="inlineCode"><span class="koboSpan" id="kobo.3049.1">T</span></code><span class="koboSpan" id="kobo.3050.1">, cannot be used in this case. </span><span class="koboSpan" id="kobo.3050.2">You should avoid defining variants holding multiple alternatives of the same type. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.3051.1">On the other hand, a variant cannot hold an alternative of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.3052.1">void</span></code><span class="koboSpan" id="kobo.3053.1">, or alternatives of array and reference types. </span><span class="koboSpan" id="kobo.3053.2">Moreover, the first alternative must always be default constructible. </span><span class="koboSpan" id="kobo.3053.3">The reason for this is that, just like discriminated unions, a variant is default initialized </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.3054.1">with the value of its first alternative. </span><span class="koboSpan" id="kobo.3054.2">If the first alternative type is not default constructible, then the variant must use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3055.1">std::monostate</span></code><span class="koboSpan" id="kobo.3056.1"> as the first alternative. </span><span class="koboSpan" id="kobo.3056.2">This is an empty type indented for making variants default constructible.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3057.1">It is </span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.3058.1">possible to query a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3059.1">variant</span></code><span class="koboSpan" id="kobo.3060.1"> at compile time for its size (that is, the number of alternatives it defines) and for the type of an alternative specified by its zero-based index. </span><span class="koboSpan" id="kobo.3060.2">On the other hand, you can query the index of the currently held alternative at runtime using the member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.3061.1">index()</span></code><span class="koboSpan" id="kobo.3062.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-374"><span class="koboSpan" id="kobo.3063.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3064.1">A typical way of manipulating the content of a variant is through visitation. </span><span class="koboSpan" id="kobo.3064.2">This is basically the execution of an action based on the alternative held by the variant. </span><span class="koboSpan" id="kobo.3064.3">Since it is a larger topic, it is addressed separately in the next recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-375"><span class="koboSpan" id="kobo.3065.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3066.1">Using std::any to store any value</span></em><span class="koboSpan" id="kobo.3067.1">, to learn how to use the C++17 class </span><code class="inlineCode"><span class="koboSpan" id="kobo.3068.1">std::any</span></code><span class="koboSpan" id="kobo.3069.1">, which represents a type-safe container for single values of any type</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3070.1">Using std::optional to store optional values</span></em><span class="koboSpan" id="kobo.3071.1">, to learn about the C++17 class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.3072.1">std::optional</span></code><span class="koboSpan" id="kobo.3073.1">, which manages a value that may or may not exist</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3074.1">Visiting a std::variant</span></em><span class="koboSpan" id="kobo.3075.1">, to understand how to perform type matching and execute different actions based on the type of a variant’s alternatives</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-376"><span class="koboSpan" id="kobo.3076.1">Visiting a std::variant</span></h1>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3077.1">std::variant</span></code><span class="koboSpan" id="kobo.3078.1"> is a </span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.3079.1">new standard container that was added to C++17 based on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3080.1">boost.variant</span></code><span class="koboSpan" id="kobo.3081.1"> library. </span><span class="koboSpan" id="kobo.3081.2">A variant is a type-safe union that holds the value of one of its alternative types. </span><span class="koboSpan" id="kobo.3081.3">Although, in the previous recipe, we have seen various operations with variants, the variants we used were rather simple, with POD types mostly, which is not the actual purpose for which </span><code class="inlineCode"><span class="koboSpan" id="kobo.3082.1">std::variant</span></code><span class="koboSpan" id="kobo.3083.1"> was created. </span><span class="koboSpan" id="kobo.3083.2">Variants are intended to be used for holding alternatives of similar non-polymorphic and non-POD types. </span><span class="koboSpan" id="kobo.3083.3">In this recipe, we will see a more real-world example of using variants and will learn how to visit variants.</span></p>
<h2 class="heading-2" id="_idParaDest-377"><span class="koboSpan" id="kobo.3084.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3085.1">For this recipe, you should be familiar with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3086.1">std::variant</span></code><span class="koboSpan" id="kobo.3087.1"> type. </span><span class="koboSpan" id="kobo.3087.2">It is recommended that you first read the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.3088.1">Using std::variant as a type-safe union</span></em><span class="koboSpan" id="kobo.3089.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3090.1">To explain </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.3091.1">how variant visitation can be done, we will consider a variant for representing a media DVD. </span><span class="koboSpan" id="kobo.3091.2">Let’s suppose we want to model a store or library that has DVDs that could contain either music, a movie, or software. </span><span class="koboSpan" id="kobo.3091.3">However, these options are not modeled as a hierarchy with common data and virtual functions, but rather as non-related types that may have similar properties, such as a title. </span><span class="koboSpan" id="kobo.3091.4">For simplicity, we’ll consider the following properties:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3092.1">For a movie: Title and length (in minutes)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3093.1">For an album: Title, artist name, and a list of tracks (each track having a title and length in seconds)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3094.1">For software: Title and manufacturer</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3095.1">The following code shows a simple implementation of these types, without any functions, because that is not relevant to the visitation of a variant holding alternatives of these types:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3096.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3097.1">Genre</span></span><span class="koboSpan" id="kobo.3098.1"> { Drama, Action, SF, Comedy };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3099.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3100.1">Movie</span></span><span class="koboSpan" id="kobo.3101.1">
{
  std::string title;
  std::chrono::minutes length;
  std::vector&lt;Genre&gt; genre;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3102.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3103.1">Track</span></span><span class="koboSpan" id="kobo.3104.1">
{
  std::string title;
  std::chrono::seconds length;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3105.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3106.1">Music</span></span><span class="koboSpan" id="kobo.3107.1">
{
  std::string title;
  std::string artist;
  std::vector&lt;Track&gt; tracks;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3108.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3109.1">Software</span></span><span class="koboSpan" id="kobo.3110.1">
{
  std::string title;
  std::string vendor;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3111.1">using</span></span><span class="koboSpan" id="kobo.3112.1"> dvd = std::variant&lt;Movie, Music, Software&gt;;
std::vector&lt;dvd&gt; dvds
{
  Movie{ "The Matrix"s, 2h + 16min,{ Genre::Action, Genre::SF } },
  Music{ "The Wall"s, "Pink Floyd"s,
       { { "Mother"s, 5min + 32s },
         { "Another Brick in the Wall"s, 9min + 8s } } },
  Software{ "Windows"s, "Microsoft"s },
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3113.1">On the </span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.3114.1">other hand, we will utilize the following function to convert text to uppercase:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3115.1">template</span></span><span class="koboSpan" id="kobo.3116.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3117.1">typename</span></span><span class="koboSpan" id="kobo.3118.1"> CharT&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3119.1">using</span></span><span class="koboSpan" id="kobo.3120.1"> tstring = std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;, 
                                         std::allocator&lt;CharT&gt;&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3121.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3122.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3123.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3124.1"> CharT&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3125.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3126.1"> tstring&lt;CharT&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3127.1">to_upper</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3128.1">(tstring&lt;CharT&gt; text)</span></span><span class="koboSpan" id="kobo.3129.1">
{
   std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3130.1">transform</span></span><span class="koboSpan" id="kobo.3131.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3132.1">begin</span></span><span class="koboSpan" id="kobo.3133.1">(text), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3134.1">end</span></span><span class="koboSpan" id="kobo.3135.1">(text), 
                  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3136.1">begin</span></span><span class="koboSpan" id="kobo.3137.1">(text), toupper);
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3138.1">return</span></span><span class="koboSpan" id="kobo.3139.1"> text;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3140.1">With these defined, let’s start looking at how visiting variants should be performed.</span></p>
<h2 class="heading-2" id="_idParaDest-378"><span class="koboSpan" id="kobo.3141.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3142.1">To visit a variant, you must provide one or more actions for the possible alternatives of the variant. </span><span class="koboSpan" id="kobo.3142.2">There are several types of visitors, which are used for different purposes:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3143.1">A void visitor that does not return anything but has side effects. </span><span class="koboSpan" id="kobo.3143.2">The following example prints the title of each DVD to the console:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3144.1">for</span></span><span class="koboSpan" id="kobo.3145.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3146.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3147.1">const</span></span><span class="koboSpan" id="kobo.3148.1"> &amp; d : dvds)
{
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3149.1">visit</span></span><span class="koboSpan" id="kobo.3150.1">([](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3151.1">auto</span></span><span class="koboSpan" id="kobo.3152.1">&amp;&amp; arg) {
               std::cout &lt;&lt; arg.title &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3153.1">'\n'</span></span><span class="koboSpan" id="kobo.3154.1">; },
             d);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3155.1">A visitor</span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.3156.1"> that returns a value; the value should have the same type, regardless of the current alternative of the variant, or can itself be a variant. </span><span class="koboSpan" id="kobo.3156.2">In the following example, we visit a variant and return a new variant of the same type that has the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3157.1">title</span></code><span class="koboSpan" id="kobo.3158.1"> property from any of its alternatives transformed to uppercase letters:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3159.1">for</span></span><span class="koboSpan" id="kobo.3160.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3161.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3162.1">const</span></span><span class="koboSpan" id="kobo.3163.1"> &amp; d : dvds)
{
  dvd result = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3164.1">visit</span></span><span class="koboSpan" id="kobo.3165.1">(
    [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3166.1">auto</span></span><span class="koboSpan" id="kobo.3167.1">&amp;&amp; arg) -&gt; dvd
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3168.1">auto</span></span><span class="koboSpan" id="kobo.3169.1"> cpy { arg };
      cpy.title = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3170.1">to_upper</span></span><span class="koboSpan" id="kobo.3171.1">(cpy.title);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3172.1">return</span></span><span class="koboSpan" id="kobo.3173.1"> cpy;
    },
  d);
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3174.1">visit</span></span><span class="koboSpan" id="kobo.3175.1">(
    [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3176.1">auto</span></span><span class="koboSpan" id="kobo.3177.1">&amp;&amp; arg) {
      std::cout &lt;&lt; arg.title &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3178.1">'\n'</span></span><span class="koboSpan" id="kobo.3179.1">; },
    result);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3180.1">A visitor that does type matching (which can either be a void or a value-returning visitor) implemented by providing a function object that has an overloaded call operator for each alternative type of the variant:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3181.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3182.1">visitor_functor</span></span><span class="koboSpan" id="kobo.3183.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3184.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3185.1">operator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3186.1">()(Movie </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3187.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3188.1"> &amp; arg)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3189.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.3190.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3191.1">"Movie"</span></span><span class="koboSpan" id="kobo.3192.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3193.1">'\n'</span></span><span class="koboSpan" id="kobo.3194.1">;
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3195.1">" Title: "</span></span><span class="koboSpan" id="kobo.3196.1"> &lt;&lt; arg.title &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3197.1">'\n'</span></span><span class="koboSpan" id="kobo.3198.1">;
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3199.1">" Length: "</span></span><span class="koboSpan" id="kobo.3200.1"> &lt;&lt; arg.length.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3201.1">count</span></span><span class="koboSpan" id="kobo.3202.1">()
              &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3203.1">"min"</span></span><span class="koboSpan" id="kobo.3204.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3205.1">'\n'</span></span><span class="koboSpan" id="kobo.3206.1">;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3207.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3208.1">operator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3209.1">()(Music </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3210.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3211.1"> &amp; arg)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3212.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.3213.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3214.1">"Music"</span></span><span class="koboSpan" id="kobo.3215.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3216.1">'\n'</span></span><span class="koboSpan" id="kobo.3217.1">;
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3218.1">" Title: "</span></span><span class="koboSpan" id="kobo.3219.1"> &lt;&lt; arg.title &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3220.1">'\n'</span></span><span class="koboSpan" id="kobo.3221.1">;
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3222.1">" Artist: "</span></span><span class="koboSpan" id="kobo.3223.1"> &lt;&lt; arg.artist &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3224.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3225.1">\n'</span></span><span class="koboSpan" id="kobo.3226.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3227.1">for</span></span><span class="koboSpan" id="kobo.3228.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3229.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3230.1">const</span></span><span class="koboSpan" id="kobo.3231.1"> &amp; t : arg.tracks)
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3232.1">" Track: "</span></span><span class="koboSpan" id="kobo.3233.1"> &lt;&lt; t.title
                &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3234.1">", "</span></span><span class="koboSpan" id="kobo.3235.1"> &lt;&lt; t.length.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3236.1">count</span></span><span class="koboSpan" id="kobo.3237.1">()
                &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3238.1">"sec"</span></span><span class="koboSpan" id="kobo.3239.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3240.1">'\n'</span></span><span class="koboSpan" id="kobo.3241.1">;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3242.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3243.1">operator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3244.1">()(Software </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3245.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3246.1"> &amp; arg)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3247.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.3248.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3249.1">"Software"</span></span><span class="koboSpan" id="kobo.3250.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3251.1">'\n'</span></span><span class="koboSpan" id="kobo.3252.1">;
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3253.1">" Title: "</span></span><span class="koboSpan" id="kobo.3254.1"> &lt;&lt; arg.title &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3255.1">'\n'</span></span><span class="koboSpan" id="kobo.3256.1">;
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3257.1">" Vendor: "</span></span><span class="koboSpan" id="kobo.3258.1"> &lt;&lt; arg.vendor &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3259.1">'\n'</span></span><span class="koboSpan" id="kobo.3260.1">;
  }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3261.1">for</span></span><span class="koboSpan" id="kobo.3262.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3263.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3264.1">const</span></span><span class="koboSpan" id="kobo.3265.1"> &amp; d : dvds)
{
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3266.1">visit</span></span><span class="koboSpan" id="kobo.3267.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3268.1">visitor_functor</span></span><span class="koboSpan" id="kobo.3269.1">(), d);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3270.1">A </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.3271.1">visitor that does type matching that is implemented by providing a lambda expression that performs an action based on the type of the alternative:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3272.1">for</span></span><span class="koboSpan" id="kobo.3273.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3274.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3275.1">const</span></span><span class="koboSpan" id="kobo.3276.1"> &amp; d : dvds)
{
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3277.1">visit</span></span><span class="koboSpan" id="kobo.3278.1">([](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3279.1">auto</span></span><span class="koboSpan" id="kobo.3280.1">&amp;&amp; arg) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3281.1">using</span></span><span class="koboSpan" id="kobo.3282.1"> T = std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.3283.1">decay_t</span></span><span class="koboSpan" id="kobo.3284.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3285.1">decltype</span></span><span class="koboSpan" id="kobo.3286.1">(arg)&gt;;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3287.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3288.1">constexpr</span></span><span class="koboSpan" id="kobo.3289.1"> (std::is_same_v&lt;T, Movie&gt;)
    {
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3290.1">"Movie"</span></span><span class="koboSpan" id="kobo.3291.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3292.1">'\n'</span></span><span class="koboSpan" id="kobo.3293.1">;
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3294.1">" Title: "</span></span><span class="koboSpan" id="kobo.3295.1"> &lt;&lt; arg.title &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3296.1">'\n'</span></span><span class="koboSpan" id="kobo.3297.1">;
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3298.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3299.1"> Length: "</span></span><span class="koboSpan" id="kobo.3300.1"> &lt;&lt; arg.length.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3301.1">count</span></span><span class="koboSpan" id="kobo.3302.1">()
                &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3303.1">"min"</span></span><span class="koboSpan" id="kobo.3304.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3305.1">'\n'</span></span><span class="koboSpan" id="kobo.3306.1">;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3307.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3308.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3309.1">constexpr</span></span><span class="koboSpan" id="kobo.3310.1"> (std::is_same_v&lt;T, Music&gt;)
    {
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3311.1">"Music"</span></span><span class="koboSpan" id="kobo.3312.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3313.1">'\n'</span></span><span class="koboSpan" id="kobo.3314.1">;
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3315.1">" Title: "</span></span><span class="koboSpan" id="kobo.3316.1"> &lt;&lt; arg.title &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3317.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3318.1">\n'</span></span><span class="koboSpan" id="kobo.3319.1">;
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3320.1">" Artist: "</span></span><span class="koboSpan" id="kobo.3321.1"> &lt;&lt; arg.artist &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3322.1">'\n'</span></span><span class="koboSpan" id="kobo.3323.1">;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3324.1">for</span></span><span class="koboSpan" id="kobo.3325.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3326.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3327.1">const</span></span><span class="koboSpan" id="kobo.3328.1"> &amp; t : arg.tracks)
        std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3329.1">" Track: "</span></span><span class="koboSpan" id="kobo.3330.1"> &lt;&lt; t.title
                  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3331.1">", "</span></span><span class="koboSpan" id="kobo.3332.1"> &lt;&lt; t.length.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3333.1">count</span></span><span class="koboSpan" id="kobo.3334.1">()
                  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3335.1">"sec"</span></span><span class="koboSpan" id="kobo.3336.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3337.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3338.1">\n'</span></span><span class="koboSpan" id="kobo.3339.1">;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3340.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3341.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3342.1">constexpr</span></span><span class="koboSpan" id="kobo.3343.1"> (std::is_same_v&lt;T, Software&gt;)
    {
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3344.1">"Software"</span></span><span class="koboSpan" id="kobo.3345.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3346.1">'\n'</span></span><span class="koboSpan" id="kobo.3347.1">;
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3348.1">" Title: "</span></span><span class="koboSpan" id="kobo.3349.1"> &lt;&lt; arg.title &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3350.1">'\n'</span></span><span class="koboSpan" id="kobo.3351.1">;
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3352.1">" Vendor: "</span></span><span class="koboSpan" id="kobo.3353.1"> &lt;&lt; arg.vendor &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3354.1">'\n'</span></span><span class="koboSpan" id="kobo.3355.1">;
    }
  },
  d);
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-379"><span class="koboSpan" id="kobo.3356.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3357.1">A </span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.3358.1">visitor is a callable object (a function, a lambda expression, or a function object) that accepts every possible alternative from a variant. </span><span class="koboSpan" id="kobo.3358.2">Visitation is done by invoking </span><code class="inlineCode"><span class="koboSpan" id="kobo.3359.1">std::visit()</span></code><span class="koboSpan" id="kobo.3360.1"> with the visitor and one or more variant objects. </span><span class="koboSpan" id="kobo.3360.2">The variants do not have to be of the same type, but the visitor must be able to accept every possible alternative from all the variants it is invoked for. </span><span class="koboSpan" id="kobo.3360.3">In the examples earlier, we visited a single variant object, but visiting multiple variants does not imply anything more than passing them as arguments to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3361.1">std::visit()</span></code><span class="koboSpan" id="kobo.3362.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3363.1">When you visit a variant, the callable object is invoked with the value currently stored in the variant. </span><span class="koboSpan" id="kobo.3363.2">If the visitor does not accept an argument of the type stored in the variant, the program is ill-formed. </span><span class="koboSpan" id="kobo.3363.3">If the visitor is a function object, then it must overload its call operator for all the possible alternative types of the variant. </span><span class="koboSpan" id="kobo.3363.4">If the visitor is a lambda expression, it should be a generic lambda, which is basically a function object with a call operator template, instantiated by the compiler with the actual type that it is invoked with.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3364.1">Examples of both approaches were shown in the previous section for a type-matching visitor. </span><span class="koboSpan" id="kobo.3364.2">The function object in the first example is straightforward and should not require additional explanations. </span><span class="koboSpan" id="kobo.3364.3">On the other hand, the generic lambda expression uses </span><em class="italic"><span class="koboSpan" id="kobo.3365.1">constexpr if</span></em><span class="koboSpan" id="kobo.3366.1"> to select a particular </span><code class="inlineCode"><span class="koboSpan" id="kobo.3367.1">if</span></code><span class="koboSpan" id="kobo.3368.1"> branch based on the type of the argument at compile time. </span><span class="koboSpan" id="kobo.3368.2">The result is that the compiler will create a function object with an operator call template and a body that contains </span><em class="italic"><span class="koboSpan" id="kobo.3369.1">constexpr if</span></em><span class="koboSpan" id="kobo.3370.1"> statements; when it instantiates that function template, it will produce an overload for each possible alternative type of the variant and, in each of these overloads, it will select only the </span><em class="italic"><span class="koboSpan" id="kobo.3371.1">constexpr if</span></em><span class="koboSpan" id="kobo.3372.1"> branch that matches the type of the call operator argument. </span><span class="koboSpan" id="kobo.3372.2">The result is conceptually equivalent </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.3373.1">to the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3374.1">visitor_functor</span></code><span class="koboSpan" id="kobo.3375.1"> class.</span></p>
<h2 class="heading-2" id="_idParaDest-380"><span class="koboSpan" id="kobo.3376.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3377.1">Using std::any to store any value</span></em><span class="koboSpan" id="kobo.3378.1">, to learn how to use the C++17 class </span><code class="inlineCode"><span class="koboSpan" id="kobo.3379.1">std::any</span></code><span class="koboSpan" id="kobo.3380.1">, which represents a type-safe container for single values of any type</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3381.1">Using std::optional to store optional values</span></em><span class="koboSpan" id="kobo.3382.1">, to learn about the C++17 class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.3383.1">std::optional</span></code><span class="koboSpan" id="kobo.3384.1">, which manages a value that may or may not exist</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3385.1">Using std::variant as a type-safe union</span></em><span class="koboSpan" id="kobo.3386.1">, to see how to use the C++17 </span><code class="inlineCode"><span class="koboSpan" id="kobo.3387.1">std::variant</span></code><span class="koboSpan" id="kobo.3388.1"> class to represent type-safe unions</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-381"><span class="koboSpan" id="kobo.3389.1">Using std::expected to return a value or an error</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3390.1">We </span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.3391.1">often need to write a function that returns both some data and an indication of success or failure (either as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3392.1">bool</span></code><span class="koboSpan" id="kobo.3393.1"> for the simplest case or an error code for more complex cases). </span><span class="koboSpan" id="kobo.3393.2">Typically, this can be solved either by returning a status code and using a parameter passed by reference for returning the data or by returning the actual data but throwing exceptions in the case of failure. </span><span class="koboSpan" id="kobo.3393.3">In recent times, the availability of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3394.1">std::optional</span></code><span class="koboSpan" id="kobo.3395.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3396.1">std::variant</span></code><span class="koboSpan" id="kobo.3397.1"> gave way to new solutions for this problem. </span><span class="koboSpan" id="kobo.3397.2">However, the C++23 standard provides a new approach with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3398.1">std::expected</span></code><span class="koboSpan" id="kobo.3399.1"> type, a sort of combination of the two types previously mentioned. </span><span class="koboSpan" id="kobo.3399.2">Such a type is present in other programming languages, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3400.1">Result</span></code><span class="koboSpan" id="kobo.3401.1"> in Rust and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3402.1">Either</span></code><span class="koboSpan" id="kobo.3403.1"> in Haskell. </span><span class="koboSpan" id="kobo.3403.2">In this recipe, we will learn how to use this new </span><code class="inlineCode"><span class="koboSpan" id="kobo.3404.1">std::expected</span></code><span class="koboSpan" id="kobo.3405.1"> class.</span></p>
<h2 class="heading-2" id="_idParaDest-382"><span class="koboSpan" id="kobo.3406.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3407.1">In the examples shown in this recipe, we will use the data types defined here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3408.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3409.1">Status</span></span><span class="koboSpan" id="kobo.3410.1">
{
   Success, InvalidFormat, InvalidLength, FilterError,
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3411.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3412.1">Filter</span></span><span class="koboSpan" id="kobo.3413.1">
{
   Pixelize, Sepia, Blur
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3414.1">using</span></span><span class="koboSpan" id="kobo.3415.1"> Image = std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3416.1">char</span></span><span class="koboSpan" id="kobo.3417.1">&gt;;
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-383"><span class="koboSpan" id="kobo.3418.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3419.1">You can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3420.1">std::expected&lt;T, E&gt;</span></code><span class="koboSpan" id="kobo.3421.1"> type from the new </span><code class="inlineCode"><span class="koboSpan" id="kobo.3422.1">&lt;expected&gt;</span></code><span class="koboSpan" id="kobo.3423.1"> header, as shown in the</span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.3424.1"> following examples:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3425.1">When returning data from a function, return either </span><code class="inlineCode"><span class="koboSpan" id="kobo.3426.1">std::unexpected&lt;E&gt;</span></code><span class="koboSpan" id="kobo.3427.1"> to indicate an error, or the data (a value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3428.1">T</span></code><span class="koboSpan" id="kobo.3429.1">) when everything is executed successfully:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3430.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3431.1">IsValidFormat</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3432.1">(Image </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3433.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3434.1">&amp; img)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3435.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3436.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.3437.1">true</span></span><span class="koboSpan" id="kobo.3438.1">; }
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3439.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3440.1">IsValidLength</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3441.1">(Image </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3442.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3443.1">&amp; img)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3444.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3445.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.3446.1">true</span></span><span class="koboSpan" id="kobo.3447.1">; }
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3448.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3449.1">Transform</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3450.1">(Image&amp; img, Filter </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3451.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3452.1"> filter)</span></span><span class="koboSpan" id="kobo.3453.1">
{ 
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3454.1">switch</span></span><span class="koboSpan" id="kobo.3455.1">(filter)
   {
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3456.1">case</span></span><span class="koboSpan" id="kobo.3457.1"> Filter::Pixelize:
      img.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3458.1">push_back</span></span><span class="koboSpan" id="kobo.3459.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3460.1">'P'</span></span><span class="koboSpan" id="kobo.3461.1">);
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3462.1">"Applying pixelize\n"</span></span><span class="koboSpan" id="kobo.3463.1">;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3464.1">break</span></span><span class="koboSpan" id="kobo.3465.1">;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3466.1">case</span></span><span class="koboSpan" id="kobo.3467.1"> Filter::Sepia:
      img.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3468.1">push_back</span></span><span class="koboSpan" id="kobo.3469.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3470.1">'S'</span></span><span class="koboSpan" id="kobo.3471.1">);
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3472.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3473.1">Applying sepia\n"</span></span><span class="koboSpan" id="kobo.3474.1">;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3475.1">break</span></span><span class="koboSpan" id="kobo.3476.1">;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3477.1">case</span></span><span class="koboSpan" id="kobo.3478.1"> Filter::Blur:
      img.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3479.1">push_back</span></span><span class="koboSpan" id="kobo.3480.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3481.1">'B'</span></span><span class="koboSpan" id="kobo.3482.1">);
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3483.1">"Applying blur\n"</span></span><span class="koboSpan" id="kobo.3484.1">;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3485.1">break</span></span><span class="koboSpan" id="kobo.3486.1">;
   }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3487.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.3488.1">true</span></span><span class="koboSpan" id="kobo.3489.1">; 
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.3490.1">std::expected&lt;Image, Status&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3491.1">ApplyFilter</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3492.1">(Image img, </span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.3493.1">                                         Filter </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3494.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3495.1"> filter)</span></span><span class="koboSpan" id="kobo.3496.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3497.1">if</span></span><span class="koboSpan" id="kobo.3498.1"> (!</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3499.1">IsValidFormat</span></span><span class="koboSpan" id="kobo.3500.1">(img))
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3501.1">return</span></span><span class="koboSpan" id="kobo.3502.1"> std::unexpected&lt;Status&gt; {Status::InvalidFormat};
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3503.1">if</span></span><span class="koboSpan" id="kobo.3504.1"> (!</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3505.1">IsValidLength</span></span><span class="koboSpan" id="kobo.3506.1">(img))
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3507.1">return</span></span><span class="koboSpan" id="kobo.3508.1"> std::unexpected&lt;Status&gt; {Status::InvalidLength};
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3509.1">if</span></span><span class="koboSpan" id="kobo.3510.1"> (!</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3511.1">Transform</span></span><span class="koboSpan" id="kobo.3512.1">(img, filter))
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3513.1">return</span></span><span class="koboSpan" id="kobo.3514.1"> std::unexpected&lt;Status&gt; {Status::FilterError};
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3515.1">return</span></span><span class="koboSpan" id="kobo.3516.1"> img;
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.3517.1">std::expected&lt;Image, Status&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3518.1">FlipHorizontally</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3519.1">(Image img)</span></span><span class="koboSpan" id="kobo.3520.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3521.1">return</span></span><span class="koboSpan" id="kobo.3522.1"> Image{img.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3523.1">rbegin</span></span><span class="koboSpan" id="kobo.3524.1">(), img.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3525.1">rend</span></span><span class="koboSpan" id="kobo.3526.1">()};
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3527.1">When </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.3528.1">checking the result of a function that returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.3529.1">std::expected&lt;T, E&gt;</span></code><span class="koboSpan" id="kobo.3530.1">, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3531.1">bool</span></code><span class="koboSpan" id="kobo.3532.1"> operator (or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3533.1">has_value()</span></code><span class="koboSpan" id="kobo.3534.1"> method) to check if the object holds the expected value, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3535.1">value()</span></code><span class="koboSpan" id="kobo.3536.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3537.1">error()</span></code><span class="koboSpan" id="kobo.3538.1"> methods to return the expected value or the unexpected error, respectively:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3539.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3540.1">ShowImage</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3541.1">(Image </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3542.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3543.1">&amp; img)</span></span><span class="koboSpan" id="kobo.3544.1">
{
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3545.1">"[img]:"</span></span><span class="koboSpan" id="kobo.3546.1">;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3547.1">for</span></span><span class="koboSpan" id="kobo.3548.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3549.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3550.1">const</span></span><span class="koboSpan" id="kobo.3551.1"> &amp; e : img) std::cout &lt;&lt; e;
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3552.1">'\n'</span></span><span class="koboSpan" id="kobo.3553.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3554.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3555.1">ShowError</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3556.1">(Status </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3557.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3558.1"> status)</span></span><span class="koboSpan" id="kobo.3559.1">
{
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3560.1">"Error code: "</span></span><span class="koboSpan" id="kobo.3561.1"> 
             &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3562.1">static_cast</span></span><span class="koboSpan" id="kobo.3563.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3564.1">int</span></span><span class="koboSpan" id="kobo.3565.1">&gt;(status) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3566.1">'\n'</span></span><span class="koboSpan" id="kobo.3567.1">; 
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3568.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3569.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3570.1">()</span></span><span class="koboSpan" id="kobo.3571.1">
{
   Image img{</span><span class="hljs-string"><span class="koboSpan" id="kobo.3572.1">'I'</span></span><span class="koboSpan" id="kobo.3573.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.3574.1">'M'</span></span><span class="koboSpan" id="kobo.3575.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.3576.1">'G'</span></span><span class="koboSpan" id="kobo.3577.1">};
   
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3578.1">auto</span></span><span class="koboSpan" id="kobo.3579.1"> result = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3580.1">ApplyFilter</span></span><span class="koboSpan" id="kobo.3581.1">(img, Filter::Sepia);
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3582.1">if</span></span><span class="koboSpan" id="kobo.3583.1"> (result)
   {
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3584.1">ShowImage</span></span><span class="koboSpan" id="kobo.3585.1">(result.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3586.1">value</span></span><span class="koboSpan" id="kobo.3587.1">());
   }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3588.1">else</span></span><span class="koboSpan" id="kobo.3589.1">
   {
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3590.1">ShowError</span></span><span class="koboSpan" id="kobo.3591.1">(result.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3592.1">error</span></span><span class="koboSpan" id="kobo.3593.1">());
   }
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3594.1">You</span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.3595.1"> can compose a chain of operations from functions that return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3596.1">std::expected</span></code><span class="koboSpan" id="kobo.3597.1"> value using the monadic operations </span><code class="inlineCode"><span class="koboSpan" id="kobo.3598.1">and_then()</span></code><span class="koboSpan" id="kobo.3599.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3600.1">or_else()</span></code><span class="koboSpan" id="kobo.3601.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3602.1">transform()</span></code><span class="koboSpan" id="kobo.3603.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3604.1">transform_error()</span></code><span class="koboSpan" id="kobo.3605.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3606.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3607.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3608.1">()</span></span><span class="koboSpan" id="kobo.3609.1">
{
   Image img{</span><span class="hljs-string"><span class="koboSpan" id="kobo.3610.1">'I'</span></span><span class="koboSpan" id="kobo.3611.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.3612.1">'M'</span></span><span class="koboSpan" id="kobo.3613.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.3614.1">'G'</span></span><span class="koboSpan" id="kobo.3615.1">};
   
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3616.1">ApplyFilter</span></span><span class="koboSpan" id="kobo.3617.1">(img, Filter::Sepia)                
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3618.1">and_then</span></span><span class="koboSpan" id="kobo.3619.1">([](Image result){
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3620.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3621.1">ApplyFilter</span></span><span class="koboSpan" id="kobo.3622.1">(result, Filter::Pixelize);
      })
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3623.1">and_then</span></span><span class="koboSpan" id="kobo.3624.1">([](Image result){
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3625.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3626.1">ApplyFilter</span></span><span class="koboSpan" id="kobo.3627.1">(result, Filter::Blur);
      })
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3628.1">and_then</span></span><span class="koboSpan" id="kobo.3629.1">([](Image result){
          </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3630.1">ShowImage</span></span><span class="koboSpan" id="kobo.3631.1">(result);
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3632.1">return</span></span><span class="koboSpan" id="kobo.3633.1"> std::expected&lt;Image, Status&gt;{result};
      })
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3634.1">or_else</span></span><span class="koboSpan" id="kobo.3635.1">([](Status status){
          </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3636.1">ShowError</span></span><span class="koboSpan" id="kobo.3637.1">(status);
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3638.1">return</span></span><span class="koboSpan" id="kobo.3639.1"> std::expected&lt;Image, Status&gt;{std::unexpect, 
                                              status};
      });
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-384"><span class="koboSpan" id="kobo.3640.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3641.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3642.1">std::expected&lt;T, E&gt;</span></code><span class="koboSpan" id="kobo.3643.1"> class template is available in the new C++23 header called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3644.1">&lt;expected&gt;</span></code><span class="koboSpan" id="kobo.3645.1">. </span><span class="koboSpan" id="kobo.3645.2">This class is a mixture of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3646.1">std::variant</span></code><span class="koboSpan" id="kobo.3647.1"> and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3648.1">std::optional</span></code><span class="koboSpan" id="kobo.3649.1"> types (introduced in C++17) but designed for the purpose of returning data or an unexpected value from a function. </span><span class="koboSpan" id="kobo.3649.2">It has the logical structure of a discriminated union since it either holds the value of an expected type </span><code class="inlineCode"><span class="koboSpan" id="kobo.3650.1">T</span></code><span class="koboSpan" id="kobo.3651.1">, or the value of an unexpected type (error) </span><code class="inlineCode"><span class="koboSpan" id="kobo.3652.1">E</span></code><span class="koboSpan" id="kobo.3653.1">. </span><span class="koboSpan" id="kobo.3653.2">However, its </span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.3654.1">interface is very similar to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3655.1">std::optional</span></code><span class="koboSpan" id="kobo.3656.1"> class, as it features the following members:</span></p>
<table class="table-container" id="table002-2">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.3657.1">Function</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.3658.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3659.1">has_value()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.3660.1">Returns a Boolean value that indicates whether the object contains the expected value or not.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3661.1">operator bool</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.3662.1">Same as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3663.1">has_value()</span></code><span class="koboSpan" id="kobo.3664.1">. </span><span class="koboSpan" id="kobo.3664.2">Provided for simpler usage in </span><code class="inlineCode"><span class="koboSpan" id="kobo.3665.1">if</span></code><span class="koboSpan" id="kobo.3666.1"> statements (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3667.1">if(result)</span></code><span class="koboSpan" id="kobo.3668.1"> as opposed to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3669.1">if(result.has_value()</span></code><span class="koboSpan" id="kobo.3670.1">).</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3671.1">value()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.3672.1">Returns the expected value, unless the object contains an unexpected value. </span><span class="koboSpan" id="kobo.3672.2">In this case, it throws a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3673.1">std::bad_expected_access&lt;E&gt;</span></code><span class="koboSpan" id="kobo.3674.1"> exception, containing the unexpected value.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3675.1">value_or()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.3676.1">Similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3677.1">value()</span></code><span class="koboSpan" id="kobo.3678.1"> but, instead of throwing an exception if an unexpected value is stored in the object, it returns the supplied, alternative value.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3679.1">error()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.3680.1">Returns the unexpected value. </span><span class="koboSpan" id="kobo.3680.2">If the object holds an expected value, then the behavior is undefined.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3681.1">operator-&gt;</span></code><span class="koboSpan" id="kobo.3682.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3683.1">operator*</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.3684.1">Accesses the expected value. </span><span class="koboSpan" id="kobo.3684.2">If the object holds an unexpected value, then the behavior is undefined.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.3685.1">Table 6.2: A listing of the most important members of std::expected</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3686.1">Although it was previously mentioned that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3687.1">std::expected</span></code><span class="koboSpan" id="kobo.3688.1"> type is a discriminated union of two </span><code class="inlineCode"><span class="koboSpan" id="kobo.3689.1">T</span></code><span class="koboSpan" id="kobo.3690.1"> (expected) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3691.1">E</span></code><span class="koboSpan" id="kobo.3692.1"> (error) types, it is not entirely correct. </span><span class="koboSpan" id="kobo.3692.2">The actual types it holds are either </span><code class="inlineCode"><span class="koboSpan" id="kobo.3693.1">T</span></code><span class="koboSpan" id="kobo.3694.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3695.1">std::unexpected&lt;E&gt;</span></code><span class="koboSpan" id="kobo.3696.1">. </span><span class="koboSpan" id="kobo.3696.2">This latter type is a helper class that holds an object of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.3697.1">E</span></code><span class="koboSpan" id="kobo.3698.1">. </span><span class="koboSpan" id="kobo.3698.2">There are some restrictions on the possible types used for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3699.1">T</span></code><span class="koboSpan" id="kobo.3700.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3701.1">E</span></code><span class="koboSpan" id="kobo.3702.1">:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3703.1">T</span></code><span class="koboSpan" id="kobo.3704.1"> can be either </span><code class="inlineCode"><span class="koboSpan" id="kobo.3705.1">void</span></code><span class="koboSpan" id="kobo.3706.1"> or a destructible type (a type for which a destructor can be invoked). </span><span class="koboSpan" id="kobo.3706.2">Arrays and reference types cannot be substituted for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3707.1">T</span></code><span class="koboSpan" id="kobo.3708.1">. </span><span class="koboSpan" id="kobo.3708.2">If the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.3709.1">T</span></code><span class="koboSpan" id="kobo.3710.1"> is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3711.1">void</span></code><span class="koboSpan" id="kobo.3712.1"> type, then the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3713.1">value_or()</span></code><span class="koboSpan" id="kobo.3714.1"> method is not available.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3715.1">E</span></code><span class="koboSpan" id="kobo.3716.1"> must be a destructible type. </span><span class="koboSpan" id="kobo.3716.2">Arrays, reference types, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3717.1">const</span></code><span class="koboSpan" id="kobo.3718.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3719.1">volatile</span></code><span class="koboSpan" id="kobo.3720.1"> qualified types cannot be substituted for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3721.1">E</span></code><span class="koboSpan" id="kobo.3722.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3723.1">There are cases when you want to apply multiple operations to a value. </span><span class="koboSpan" id="kobo.3723.2">In our example, this could be applying different filters in a row to an image. </span><span class="koboSpan" id="kobo.3723.3">But it could be other things such as resizing the image, changing the format/type, flipping in different directions, and so on. </span><span class="koboSpan" id="kobo.3723.4">Each </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.3724.1">of these operations could return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3725.1">std::expected</span></code><span class="koboSpan" id="kobo.3726.1"> value. </span><span class="koboSpan" id="kobo.3726.2">In this case, we can write code as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3727.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3728.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3729.1">()</span></span><span class="koboSpan" id="kobo.3730.1">
{
   Image img{</span><span class="hljs-string"><span class="koboSpan" id="kobo.3731.1">'I'</span></span><span class="koboSpan" id="kobo.3732.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.3733.1">'M'</span></span><span class="koboSpan" id="kobo.3734.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.3735.1">'G'</span></span><span class="koboSpan" id="kobo.3736.1">};
   
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3737.1">auto</span></span><span class="koboSpan" id="kobo.3738.1"> result = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3739.1">ApplyFilter</span></span><span class="koboSpan" id="kobo.3740.1">(img, Filter::Sepia);
   result = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3741.1">ApplyFilter</span></span><span class="koboSpan" id="kobo.3742.1">(result.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3743.1">value</span></span><span class="koboSpan" id="kobo.3744.1">(), Filter::Pixelize);
   result = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3745.1">ApplyFilter</span></span><span class="koboSpan" id="kobo.3746.1">(result.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3747.1">value</span></span><span class="koboSpan" id="kobo.3748.1">(), Filter::Blur);
   result = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3749.1">FlipHorizontally</span></span><span class="koboSpan" id="kobo.3750.1">(result.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3751.1">value</span></span><span class="koboSpan" id="kobo.3752.1">());
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3753.1">if</span></span><span class="koboSpan" id="kobo.3754.1"> (result)
   {
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3755.1">ShowImage</span></span><span class="koboSpan" id="kobo.3756.1">(result.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3757.1">value</span></span><span class="koboSpan" id="kobo.3758.1">());
   }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3759.1">else</span></span><span class="koboSpan" id="kobo.3760.1">
   {
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3761.1">ShowError</span></span><span class="koboSpan" id="kobo.3762.1">(result.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3763.1">error</span></span><span class="koboSpan" id="kobo.3764.1">());
   }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3765.1">If no error occurs, then the result of running this program is the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3766.1">Applying sepia
Applying pixelize
Applying blur
[img]:BPSGMI
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3767.1">However, if an error occurs in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3768.1">ApplyFilter()</span></code><span class="koboSpan" id="kobo.3769.1"> function, invoking the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3770.1">value()</span></code><span class="koboSpan" id="kobo.3771.1"> method in the subsequent call would result in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3772.1">std::bad_expected_access</span></code><span class="koboSpan" id="kobo.3773.1"> exception. </span><span class="koboSpan" id="kobo.3773.2">We actually have to check the result after each operation. </span><span class="koboSpan" id="kobo.3773.3">This can be improved using monadic operations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3774.1">Since the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3775.1">std::expected</span></code><span class="koboSpan" id="kobo.3776.1"> type is very similar to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3777.1">std::optional</span></code><span class="koboSpan" id="kobo.3778.1"> type, the monadic operations available in C++23 for </span><code class="inlineCode"><span class="koboSpan" id="kobo.3779.1">std::optional</span></code><span class="koboSpan" id="kobo.3780.1"> are also available to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3781.1">std::expected</span></code><span class="koboSpan" id="kobo.3782.1">. </span><span class="koboSpan" id="kobo.3782.2">These are the following:</span></p>
<table class="table-container" id="table003-2">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.3783.1">Function</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.3784.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3785.1">and_then()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.3786.1">If the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3787.1">std::expected</span></code><span class="koboSpan" id="kobo.3788.1"> object contains an expected value (of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.3789.1">T</span></code><span class="koboSpan" id="kobo.3790.1">), then it applies a given function on it and returns the result. </span><span class="koboSpan" id="kobo.3790.2">Otherwise, it returns the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3791.1">std::expected</span></code><span class="koboSpan" id="kobo.3792.1"> value.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3793.1">or_else()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.3794.1">If the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3795.1">std::expected</span></code><span class="koboSpan" id="kobo.3796.1"> object contains an unexpected value (of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.3797.1">E</span></code><span class="koboSpan" id="kobo.3798.1">), then it applies a given function on the unexpected value and returns the result. </span><span class="koboSpan" id="kobo.3798.2">Otherwise, it returns the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3799.1">std::expected</span></code><span class="koboSpan" id="kobo.3800.1"> value.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3801.1">transform()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.3802.1">This is similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3803.1">and_then()</span></code><span class="koboSpan" id="kobo.3804.1">, except that the returned value is also wrapped in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3805.1">std::expected</span></code><span class="koboSpan" id="kobo.3806.1"> value.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3807.1">transform_error()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.3808.1">This is similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3809.1">or_else()</span></code><span class="koboSpan" id="kobo.3810.1">, except that the returned value is also wrapped in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3811.1">std::expected</span></code><span class="koboSpan" id="kobo.3812.1"> value.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.3813.1">Table 6.3: Monadic operations of std::expected</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3814.1">We</span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.3815.1"> can rewrite the code from the last snippet using monadic operations as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3816.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3817.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3818.1">()</span></span><span class="koboSpan" id="kobo.3819.1">
{
   Image img{</span><span class="hljs-string"><span class="koboSpan" id="kobo.3820.1">'I'</span></span><span class="koboSpan" id="kobo.3821.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.3822.1">'M'</span></span><span class="koboSpan" id="kobo.3823.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.3824.1">'G'</span></span><span class="koboSpan" id="kobo.3825.1">};
   
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3826.1">ApplyFilter</span></span><span class="koboSpan" id="kobo.3827.1">(img, Filter::Sepia)                
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3828.1">and_then</span></span><span class="koboSpan" id="kobo.3829.1">([](Image result){
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3830.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3831.1">ApplyFilter</span></span><span class="koboSpan" id="kobo.3832.1">(result, Filter::Pixelize);
      })
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3833.1">and_then</span></span><span class="koboSpan" id="kobo.3834.1">([](Image result){
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3835.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3836.1">ApplyFilter</span></span><span class="koboSpan" id="kobo.3837.1">(result, Filter::Blur);
      })
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3838.1">and_then</span></span><span class="koboSpan" id="kobo.3839.1">(FlipHorizontally)       
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3840.1">and_then</span></span><span class="koboSpan" id="kobo.3841.1">([](Image result){
          </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3842.1">ShowImage</span></span><span class="koboSpan" id="kobo.3843.1">(result);
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3844.1">return</span></span><span class="koboSpan" id="kobo.3845.1"> std::expected&lt;Image, Status&gt;{result};
      })
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3846.1">or_else</span></span><span class="koboSpan" id="kobo.3847.1">([](Status status){
          </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3848.1">ShowError</span></span><span class="koboSpan" id="kobo.3849.1">(status);
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3850.1">return</span></span><span class="koboSpan" id="kobo.3851.1"> std::expected&lt;Image, Status&gt;{std::unexpect, status};
      });
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3852.1">If no error occurs, then the output is the one we already saw. </span><span class="koboSpan" id="kobo.3852.2">However, if an error occurs, let’s say when applying the sepia filter, then the output changes to the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3853.1">Applying sepia
Error code: 3
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3854.1">This</span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.3855.1"> example shows only two of the available monadic operations, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3856.1">and_then()</span></code><span class="koboSpan" id="kobo.3857.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3858.1">or_else()</span></code><span class="koboSpan" id="kobo.3859.1">. </span><span class="koboSpan" id="kobo.3859.2">The other two, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3860.1">transform()</span></code><span class="koboSpan" id="kobo.3861.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3862.1">transform_or()</span></code><span class="koboSpan" id="kobo.3863.1">, are similar but they are intended to transform (as the name implies) either the expected or the unexpected value into another value. </span><span class="koboSpan" id="kobo.3863.2">In the following snippet (a modification of the previous one), we chain a transform operation for both the expected and unexpected value, in either case returning a string:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3864.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3865.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3866.1">()</span></span><span class="koboSpan" id="kobo.3867.1">
{
   Image img{</span><span class="hljs-string"><span class="koboSpan" id="kobo.3868.1">'I'</span></span><span class="koboSpan" id="kobo.3869.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.3870.1">'M'</span></span><span class="koboSpan" id="kobo.3871.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.3872.1">'G'</span></span><span class="koboSpan" id="kobo.3873.1">};
   
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3874.1">auto</span></span><span class="koboSpan" id="kobo.3875.1"> obj = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3876.1">ApplyFilter</span></span><span class="koboSpan" id="kobo.3877.1">(img, Filter::Sepia)                
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3878.1">and_then</span></span><span class="koboSpan" id="kobo.3879.1">([](Image result){
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3880.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3881.1">ApplyFilter</span></span><span class="koboSpan" id="kobo.3882.1">(result, Filter::Pixelize);
      })
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3883.1">and_then</span></span><span class="koboSpan" id="kobo.3884.1">([](Image result){
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3885.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3886.1">ApplyFilter</span></span><span class="koboSpan" id="kobo.3887.1">(result, Filter::Blur);
      })
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3888.1">and_then</span></span><span class="koboSpan" id="kobo.3889.1">(FlipHorizontally)       
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3890.1">and_then</span></span><span class="koboSpan" id="kobo.3891.1">([](Image result){
          </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3892.1">ShowImage</span></span><span class="koboSpan" id="kobo.3893.1">(result);
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3894.1">return</span></span><span class="koboSpan" id="kobo.3895.1"> std::expected&lt;Image, Status&gt;{result};
      })
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3896.1">or_else</span></span><span class="koboSpan" id="kobo.3897.1">([](Status status){
          </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3898.1">ShowError</span></span><span class="koboSpan" id="kobo.3899.1">(status);
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3900.1">return</span></span><span class="koboSpan" id="kobo.3901.1"> std::expected&lt;Image, Status&gt;{std::unexpect, status};
      })       
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3902.1">transform</span></span><span class="koboSpan" id="kobo.3903.1">([](Image result){
          std::stringstream s;
          s &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3904.1">quoted</span></span><span class="koboSpan" id="kobo.3905.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3906.1">string</span></span><span class="koboSpan" id="kobo.3907.1">(result.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3908.1">begin</span></span><span class="koboSpan" id="kobo.3909.1">(), 
                                       result.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3910.1">end</span></span><span class="koboSpan" id="kobo.3911.1">()));
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3912.1">return</span></span><span class="koboSpan" id="kobo.3913.1"> s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3914.1">str</span></span><span class="koboSpan" id="kobo.3915.1">();
      })
      .</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3916.1">transform_error</span></span><span class="koboSpan" id="kobo.3917.1">([](Status status){
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3918.1">return</span></span><span class="koboSpan" id="kobo.3919.1"> status == Status::Success ? </span><span class="hljs-string"><span class="koboSpan" id="kobo.3920.1">"success"</span></span><span class="koboSpan" id="kobo.3921.1"> : </span><span class="hljs-string"><span class="koboSpan" id="kobo.3922.1">"fail"</span></span><span class="koboSpan" id="kobo.3923.1">;
      });
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3924.1">if</span></span><span class="koboSpan" id="kobo.3925.1">(obj)
       std::cout &lt;&lt; obj.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3926.1">value</span></span><span class="koboSpan" id="kobo.3927.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3928.1">'\n'</span></span><span class="koboSpan" id="kobo.3929.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3930.1">else</span></span><span class="koboSpan" id="kobo.3931.1">
       std::cout &lt;&lt; obj.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3932.1">error</span></span><span class="koboSpan" id="kobo.3933.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3934.1">'\n'</span></span><span class="koboSpan" id="kobo.3935.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3936.1">If no </span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.3937.1">error occurs during the execution of this program, then the following output will be printed:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3938.1">Applying sepia
Applying pixelize
Applying blur
[img]:BPSGMI
"BPSGMI"
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3939.1">However, if an error occurs during the execution, such as when applying the sepia filter, then the output becomes the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3940.1">Applying sepia
Error code: 3
fail
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3941.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3942.1">or_else()</span></code><span class="koboSpan" id="kobo.3943.1"> function above, you’ll have noticed the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3944.1">std::unexpected</span></code><span class="koboSpan" id="kobo.3945.1">. </span><span class="koboSpan" id="kobo.3945.2">This is a helper class that acts as a tag for the constructor of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3946.1">std::expected</span></code><span class="koboSpan" id="kobo.3947.1"> in order to indicate the construction of an unexpected value. </span><span class="koboSpan" id="kobo.3947.2">As a result, the argument is perfectly forwarded to the constructor of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3948.1">E</span></code><span class="koboSpan" id="kobo.3949.1"> type (the unexpected type). </span><span class="koboSpan" id="kobo.3949.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3950.1">has_value()</span></code><span class="koboSpan" id="kobo.3951.1"> method will return </span><code class="inlineCode"><span class="koboSpan" id="kobo.3952.1">false</span></code><span class="koboSpan" id="kobo.3953.1"> for the newly created </span><code class="inlineCode"><span class="koboSpan" id="kobo.3954.1">std::expected</span></code><span class="koboSpan" id="kobo.3955.1"> value, indicating that it holds an unexpected value.</span></p>
<h2 class="heading-2" id="_idParaDest-385"><span class="koboSpan" id="kobo.3956.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3957.1">Using std::optional to store optional values</span></em><span class="koboSpan" id="kobo.3958.1">, to learn about the C++17 class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.3959.1">std::optional</span></code><span class="koboSpan" id="kobo.3960.1">, which manages a value that may or may not exist</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3961.1">Using std::variant as a type-safe union</span></em><span class="koboSpan" id="kobo.3962.1">, to learn how to use the C++17 </span><code class="inlineCode"><span class="koboSpan" id="kobo.3963.1">std::variant</span></code><span class="koboSpan" id="kobo.3964.1"> class to represent type-safe unions</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-386"><span class="koboSpan" id="kobo.3965.1">Using std::span for contiguous sequences of objects</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3966.1">In C++17, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3967.1">std::string_view</span></code><span class="koboSpan" id="kobo.3968.1"> type </span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.3969.1">was added to the standard library. </span><span class="koboSpan" id="kobo.3969.2">This is an object</span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.3970.1"> that represents a view over a constant contiguous sequence of characters. </span><span class="koboSpan" id="kobo.3970.2">The view is typically implemented with a pointer to the first element of the sequence and a length. </span><span class="koboSpan" id="kobo.3970.3">Strings are one of </span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.3971.1">the most used data types in any programming language. </span><span class="koboSpan" id="kobo.3971.2">They have a non-owning view that does not allocate memory, avoids copies, and performs some operations</span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.3972.1"> faster than </span><code class="inlineCode"><span class="koboSpan" id="kobo.3973.1">std::string</span></code><span class="koboSpan" id="kobo.3974.1">, which is an important benefit. </span><span class="koboSpan" id="kobo.3974.2">However, a string is just a special vector of characters with operations specific to text. </span><span class="koboSpan" id="kobo.3974.3">Therefore, it makes sense to have a type that is a view of a contiguous sequence of objects, regardless of their type. </span><span class="koboSpan" id="kobo.3974.4">This is what the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3975.1">std::span</span></code><span class="koboSpan" id="kobo.3976.1"> class template in C++20 represents. </span><span class="koboSpan" id="kobo.3976.2">We could say that </span><code class="inlineCode"><span class="koboSpan" id="kobo.3977.1">std::span</span></code><span class="koboSpan" id="kobo.3978.1"> is to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3979.1">std::vector</span></code><span class="koboSpan" id="kobo.3980.1"> and array types what </span><code class="inlineCode"><span class="koboSpan" id="kobo.3981.1">std::string_view</span></code><span class="koboSpan" id="kobo.3982.1"> is to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3983.1">std::string</span></code><span class="koboSpan" id="kobo.3984.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-387"><span class="koboSpan" id="kobo.3985.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3986.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3987.1">std::span</span></code><span class="koboSpan" id="kobo.3988.1"> class template is available in the header </span><code class="inlineCode"><span class="koboSpan" id="kobo.3989.1">&lt;span&gt;</span></code><span class="koboSpan" id="kobo.3990.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-388"><span class="koboSpan" id="kobo.3991.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3992.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3993.1">std::span&lt;T&gt;</span></code><span class="koboSpan" id="kobo.3994.1"> instead of a pointer and size pair as you typically would with C-like interfaces. </span><span class="koboSpan" id="kobo.3994.2">In other words, replace functions like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3995.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3996.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3997.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3998.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3999.1">* buffer, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4000.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4001.1"> length)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4002.1">{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4003.1">/* ... </span><span class="koboSpan" id="kobo.4003.2">*/</span></span><span class="koboSpan" id="kobo.4004.1"> }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4005.1">with this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4006.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4007.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4008.1">(std::span&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4009.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4010.1">&gt; buffer)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4011.1">{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4012.1">/* ... </span><span class="koboSpan" id="kobo.4012.2">*/</span></span><span class="koboSpan" id="kobo.4013.1"> }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4014.1">When working with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4015.1">std::span</span></code><span class="koboSpan" id="kobo.4016.1">, you can do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4017.1">Create a span with a compile-time length (called </span><em class="italic"><span class="koboSpan" id="kobo.4018.1">static extent</span></em><span class="koboSpan" id="kobo.4019.1">) by specifying the number of elements in the span:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4020.1">int</span></span><span class="koboSpan" id="kobo.4021.1"> arr[] = {</span><span class="hljs-number"><span class="koboSpan" id="kobo.4022.1">1</span></span><span class="koboSpan" id="kobo.4023.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4024.1">1</span></span><span class="koboSpan" id="kobo.4025.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4026.1">2</span></span><span class="koboSpan" id="kobo.4027.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4028.1">3</span></span><span class="koboSpan" id="kobo.4029.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4030.1">5</span></span><span class="koboSpan" id="kobo.4031.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4032.1">8</span></span><span class="koboSpan" id="kobo.4033.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4034.1">13</span></span><span class="koboSpan" id="kobo.4035.1">};
std::span&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4036.1">int</span></span><span class="koboSpan" id="kobo.4037.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4038.1">7</span></span><span class="koboSpan" id="kobo.4039.1">&gt; s {arr};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4040.1">Create a span with a runtime length (called </span><em class="italic"><span class="koboSpan" id="kobo.4041.1">dynamic extent</span></em><span class="koboSpan" id="kobo.4042.1">) by not specifying the number of elements in the span:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4043.1">int</span></span><span class="koboSpan" id="kobo.4044.1"> arr[] = {</span><span class="hljs-number"><span class="koboSpan" id="kobo.4045.1">1</span></span><span class="koboSpan" id="kobo.4046.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4047.1">1</span></span><span class="koboSpan" id="kobo.4048.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4049.1">2</span></span><span class="koboSpan" id="kobo.4050.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4051.1">3</span></span><span class="koboSpan" id="kobo.4052.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4053.1">5</span></span><span class="koboSpan" id="kobo.4054.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4055.1">8</span></span><span class="koboSpan" id="kobo.4056.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4057.1">13</span></span><span class="koboSpan" id="kobo.4058.1">};
std::span&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4059.1">int</span></span><span class="koboSpan" id="kobo.4060.1">&gt; s {arr};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4061.1">You can use a span in a range-based for loop:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4062.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4063.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4064.1">(std::span&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4065.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4066.1">&gt; buffer)</span></span><span class="koboSpan" id="kobo.4067.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4068.1">for</span></span><span class="koboSpan" id="kobo.4069.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4070.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4071.1">const</span></span><span class="koboSpan" id="kobo.4072.1"> e : buffer)
      std::cout &lt;&lt; e &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4073.1">' '</span></span><span class="koboSpan" id="kobo.4074.1">;
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4075.1">'\n'</span></span><span class="koboSpan" id="kobo.4076.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4077.1">You</span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.4078.1"> can access the elements of a span using the methods </span><code class="inlineCode"><span class="koboSpan" id="kobo.4079.1">front()</span></code><span class="koboSpan" id="kobo.4080.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4081.1">back()</span></code><span class="koboSpan" id="kobo.4082.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4083.1">data()</span></code><span class="koboSpan" id="kobo.4084.1">, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4085.1">operator[]</span></code><span class="koboSpan" id="kobo.4086.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4087.1">int</span></span><span class="koboSpan" id="kobo.4088.1"> arr[] = {</span><span class="hljs-number"><span class="koboSpan" id="kobo.4089.1">1</span></span><span class="koboSpan" id="kobo.4090.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4091.1">1</span></span><span class="koboSpan" id="kobo.4092.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4093.1">2</span></span><span class="koboSpan" id="kobo.4094.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4095.1">3</span></span><span class="koboSpan" id="kobo.4096.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4097.1">5</span></span><span class="koboSpan" id="kobo.4098.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4099.1">8</span></span><span class="koboSpan" id="kobo.4100.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4101.1">13</span></span><span class="koboSpan" id="kobo.4102.1">};
std::span&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4103.1">int</span></span><span class="koboSpan" id="kobo.4104.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4105.1">7</span></span><span class="koboSpan" id="kobo.4106.1">&gt; s {arr};
std::cout &lt;&lt; s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4107.1">front</span></span><span class="koboSpan" id="kobo.4108.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4109.1">" == "</span></span><span class="koboSpan" id="kobo.4110.1"> &lt;&lt; s[</span><span class="hljs-number"><span class="koboSpan" id="kobo.4111.1">0</span></span><span class="koboSpan" id="kobo.4112.1">] &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4113.1">'\n'</span></span><span class="koboSpan" id="kobo.4114.1">;    
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4115.1">// prints 1 == 1</span></span><span class="koboSpan" id="kobo.4116.1">
std::cout &lt;&lt; s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4117.1">back</span></span><span class="koboSpan" id="kobo.4118.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4119.1">" == "</span></span><span class="koboSpan" id="kobo.4120.1"> &lt;&lt; s[s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4121.1">size</span></span><span class="koboSpan" id="kobo.4122.1">() - </span><span class="hljs-number"><span class="koboSpan" id="kobo.4123.1">1</span></span><span class="koboSpan" id="kobo.4124.1">] &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4125.1">'\n'</span></span><span class="koboSpan" id="kobo.4126.1">; 
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4127.1">// prints 13 == 13</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4128.1">std::cout &lt;&lt; *s.data() &lt;&lt; '\n';</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.4129.1">// prints 1</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4130.1">You </span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.4131.1">can obtain sub-spans of a span with the methods </span><code class="inlineCode"><span class="koboSpan" id="kobo.4132.1">first()</span></code><span class="koboSpan" id="kobo.4133.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4134.1">last()</span></code><span class="koboSpan" id="kobo.4135.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4136.1">subspan()</span></code><span class="koboSpan" id="kobo.4137.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4138.1">std::span&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4139.1">int</span></span><span class="koboSpan" id="kobo.4140.1">&gt; first_3 = s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4141.1">first</span></span><span class="koboSpan" id="kobo.4142.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4143.1">3</span></span><span class="koboSpan" id="kobo.4144.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4145.1">func</span></span><span class="koboSpan" id="kobo.4146.1">(first_3);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4147.1">// 1 1 2.</span></span><span class="koboSpan" id="kobo.4148.1">
std::span&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4149.1">int</span></span><span class="koboSpan" id="kobo.4150.1">&gt; last_3 = s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4151.1">last</span></span><span class="koboSpan" id="kobo.4152.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4153.1">3</span></span><span class="koboSpan" id="kobo.4154.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4155.1">func</span></span><span class="koboSpan" id="kobo.4156.1">(last_3);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4157.1">// 5 8 13</span></span><span class="koboSpan" id="kobo.4158.1">
std::span&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4159.1">int</span></span><span class="koboSpan" id="kobo.4160.1">&gt; mid_3 = s.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4161.1">subspan</span></span><span class="koboSpan" id="kobo.4162.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4163.1">2</span></span><span class="koboSpan" id="kobo.4164.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4165.1">3</span></span><span class="koboSpan" id="kobo.4166.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4167.1">func</span></span><span class="koboSpan" id="kobo.4168.1">(mid_3);    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4169.1">// 2 3 5</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-389"><span class="koboSpan" id="kobo.4170.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4171.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4172.1">std::span</span></code><span class="koboSpan" id="kobo.4173.1"> class template is not a container of objects but a lightweight wrapper that defines a view of a contiguous sequence of objects. </span><span class="koboSpan" id="kobo.4173.2">Initially, the span was called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4174.1">array_view</span></code><span class="koboSpan" id="kobo.4175.1">, which some argue was a better name, both because it clearly indicates that the type is a non-owning view of a sequence and because it would be consistent with the name of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4176.1">string_view</span></code><span class="koboSpan" id="kobo.4177.1">. </span><span class="koboSpan" id="kobo.4177.2">However, the type was adopted in the standard library under the name </span><em class="italic"><span class="koboSpan" id="kobo.4178.1">span</span></em><span class="koboSpan" id="kobo.4179.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4180.1">Although the standard does not specify the implementation details, the span is typically implemented by storing a pointer to the first element of the sequence and a length, representing the number of elements in the view. </span><span class="koboSpan" id="kobo.4180.2">Therefore, a span can be used to define a non-owning view over (but not only) a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4181.1">std::vector</span></code><span class="koboSpan" id="kobo.4182.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4183.1">std::array</span></code><span class="koboSpan" id="kobo.4184.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4185.1">T[]</span></code><span class="koboSpan" id="kobo.4186.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4187.1">T*</span></code><span class="koboSpan" id="kobo.4188.1">. </span><span class="koboSpan" id="kobo.4188.2">However, it cannot be used with lists or associative containers (for instance, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4189.1">std::list</span></code><span class="koboSpan" id="kobo.4190.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4191.1">std::map</span></code><span class="koboSpan" id="kobo.4192.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4193.1">std::set</span></code><span class="koboSpan" id="kobo.4194.1">) because these are not containers for a contiguous sequence of elements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4195.1">The span</span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.4196.1"> can have either a compile-time size </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.4197.1">or a runtime size. </span><span class="koboSpan" id="kobo.4197.2">When the number of elements in the span is specified at compile-time, we have a span with a static extent (compile-time size). </span><span class="koboSpan" id="kobo.4197.3">If the number of elements is not specified but determined at runtime, we have a dynamic extent.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4198.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4199.1">std::span</span></code><span class="koboSpan" id="kobo.4200.1"> class has a simple interface, mainly consisting of the following members:</span></p>
<table class="table-container" id="table004-2">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4201.1">Member function</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4202.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4203.1">begin()</span></code><span class="koboSpan" id="kobo.4204.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4205.1">end()</span></code></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4206.1">cbegin()</span></code><span class="koboSpan" id="kobo.4207.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4208.1">cend()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4209.1">Mutable and constant iterators to the first and the one-past-last element of the sequence.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4210.1">rbegin()</span></code><span class="koboSpan" id="kobo.4211.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4212.1">rend()</span></code></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4213.1">cbegin()</span></code><span class="koboSpan" id="kobo.4214.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4215.1">crend()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4216.1">Mutable and constant reverse iterators to the beginning and end of the sequence.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4217.1">front()</span></code><span class="koboSpan" id="kobo.4218.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4219.1">back()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4220.1">Accesses the first and last element of the sequence.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4221.1">data()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4222.1">Returns a pointer to the beginning of the sequence of elements.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4223.1">operator[]</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4224.1">Accesses an element of the sequence specified by its index.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4225.1">size()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4226.1">Retrieves the number of elements in the sequence.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4227.1">size_bytes()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4228.1">Retrieves the size of the sequence in bytes.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4229.1">empty()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4230.1">Checks whether the sequence is empty.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4231.1">first()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4232.1">Retrieves a sub-span with the first </span><em class="italic"><span class="koboSpan" id="kobo.4233.1">N</span></em><span class="koboSpan" id="kobo.4234.1"> elements of the sequence.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4235.1">last()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4236.1">Retrieves a sub-span with the last </span><em class="italic"><span class="koboSpan" id="kobo.4237.1">N</span></em><span class="koboSpan" id="kobo.4238.1"> elements of the sequence.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4239.1">subspan()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4240.1">Retrieves a sub-span with </span><em class="italic"><span class="koboSpan" id="kobo.4241.1">N</span></em><span class="koboSpan" id="kobo.4242.1"> elements starting from a specified offset. </span><span class="koboSpan" id="kobo.4242.2">If the count </span><em class="italic"><span class="koboSpan" id="kobo.4243.1">N</span></em><span class="koboSpan" id="kobo.4244.1"> is not specified, it returns a span with all the elements from offset until the end of the sequence.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.4245.1">Table 6.4: A listing of the most important member functions of std::span</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4246.1">A span is </span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.4247.1">not intended to be used with general-purpose algorithms that work with a pair of iterators to the beginning and the end of a range (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4248.1">sort</span></code><span class="koboSpan" id="kobo.4249.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4250.1">copy</span></code><span class="koboSpan" id="kobo.4251.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4252.1">find_if</span></code><span class="koboSpan" id="kobo.4253.1">, and so on), nor as a replacement for standard containers. </span><span class="koboSpan" id="kobo.4253.2">Its main purpose is to build better interfaces than the C-like ones where a pointer and a size are passed to a function. </span><span class="koboSpan" id="kobo.4253.3">The user may pass a wrong value</span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.4254.1"> for the size, which could end in accessing memory beyond the bounds of the sequence. </span><span class="koboSpan" id="kobo.4254.2">The span provides safety and bounds checking. </span><span class="koboSpan" id="kobo.4254.3">It is also a good alternative to passing a constant reference as an argument to a function to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4255.1">std::vector&lt;T&gt;</span></code><span class="koboSpan" id="kobo.4256.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.4257.1">std::vector&lt;T&gt; const &amp;</span></code><span class="koboSpan" id="kobo.4258.1">). </span><span class="koboSpan" id="kobo.4258.2">The span does not own its elements and is small enough to be passed by value (you should not pass spans by reference or constant reference).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4259.1">Unlike </span><code class="inlineCode"><span class="koboSpan" id="kobo.4260.1">std::string_view</span></code><span class="koboSpan" id="kobo.4261.1">, which does not support changing the value of the elements in the sequence, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4262.1">std::span</span></code><span class="koboSpan" id="kobo.4263.1"> defines a mutable view and supports modifying its elements. </span><span class="koboSpan" id="kobo.4263.2">For this purpose, functions such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4264.1">front()</span></code><span class="koboSpan" id="kobo.4265.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4266.1">back()</span></code><span class="koboSpan" id="kobo.4267.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4268.1">operator[]</span></code><span class="koboSpan" id="kobo.4269.1"> return a reference.</span></p>
<h2 class="heading-2" id="_idParaDest-390"><span class="koboSpan" id="kobo.4270.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.4271.1">Chapter 2</span></em><span class="koboSpan" id="kobo.4272.1">, </span><em class="italic"><span class="koboSpan" id="kobo.4273.1">Using string_view instead of constant string references</span></em><span class="koboSpan" id="kobo.4274.1">, to learn how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4275.1">std::string_view</span></code><span class="koboSpan" id="kobo.4276.1"> to improve performance in some scenarios when working with strings</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4277.1">Using std::mdspan for multidimensional views of sequences of objects</span></em><span class="koboSpan" id="kobo.4278.1">, to learn about the C++23 span class for multi-dimensional sequences</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-391"><span class="koboSpan" id="kobo.4279.1">Using std::mdspan for multi-dimensional views of sequences of objects</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4280.1">In the</span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.4281.1"> previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.4282.1">Using std::span for contiguous sequences of objects</span></em><span class="koboSpan" id="kobo.4283.1">, we learned about the C++20 class called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4284.1">std::span</span></code><span class="koboSpan" id="kobo.4285.1">, which represents a view (a non-owning wrapper) over a contiguous sequence of elements. </span><span class="koboSpan" id="kobo.4285.2">This is similar to the C++17 </span><code class="inlineCode"><span class="koboSpan" id="kobo.4286.1">std::string_view</span></code><span class="koboSpan" id="kobo.4287.1"> class, which </span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.4288.1">does the same but for a sequence of characters. </span><span class="koboSpan" id="kobo.4288.2">Both of these are views of one-dimensional sequences. </span><span class="koboSpan" id="kobo.4288.3">However, sometimes we need to work with multi-dimensional sequences. </span><span class="koboSpan" id="kobo.4288.4">These could be implemented in many ways, such as C-like arrays (</span><code class="inlineCode"><span class="koboSpan" id="kobo.4289.1">int[2][3][4]</span></code><span class="koboSpan" id="kobo.4290.1">), pointer-of-pointers (</span><code class="inlineCode"><span class="koboSpan" id="kobo.4291.1">int**</span></code><span class="koboSpan" id="kobo.4292.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4293.1">int***</span></code><span class="koboSpan" id="kobo.4294.1">), arrays of arrays (or vectors of vectors, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4295.1">vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;</span></code><span class="koboSpan" id="kobo.4296.1">). </span><span class="koboSpan" id="kobo.4296.2">A different approach is to use a one-dimensional sequence of objects but define operations that present it as a logical multi-dimensional sequence. </span><span class="koboSpan" id="kobo.4296.3">This is what the C++23 </span><code class="inlineCode"><span class="koboSpan" id="kobo.4297.1">std::mdspan</span></code><span class="koboSpan" id="kobo.4298.1"> class does: it represents a non-owning view of a contiguous sequence of objects presented as a multi-dimensional sequence. </span><span class="koboSpan" id="kobo.4298.2">We could say that </span><code class="inlineCode"><span class="koboSpan" id="kobo.4299.1">std::mdspan</span></code><span class="koboSpan" id="kobo.4300.1"> is an extension of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4301.1">std::span</span></code><span class="koboSpan" id="kobo.4302.1"> class for multi-dimensional views.</span></p>
<h2 class="heading-2" id="_idParaDest-392"><span class="koboSpan" id="kobo.4303.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4304.1">In this recipe, we will refer to the following simple implementation of a two-dimensional matrix (whose size is known at compile time):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4305.1">template</span></span><span class="koboSpan" id="kobo.4306.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4307.1">typename</span></span><span class="koboSpan" id="kobo.4308.1"> T, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4309.1">size_t</span></span><span class="koboSpan" id="kobo.4310.1"> ROWS, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4311.1">size_t</span></span><span class="koboSpan" id="kobo.4312.1"> COLS&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4313.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4314.1">matrix</span></span><span class="koboSpan" id="kobo.4315.1">
{
   T&amp; 
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.4316.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4317.1">ifdef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.4318.1"> __cpp_multidimensional_subscript</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4319.1">operator</span></span><span class="koboSpan" id="kobo.4320.1">[] </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4321.1">// C++23</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.4322.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4323.1">else</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.4324.1">operator</span></span><span class="koboSpan" id="kobo.4325.1">() </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4326.1">// previously</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.4327.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4328.1">endif</span></span><span class="koboSpan" id="kobo.4329.1">
   (std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4330.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4331.1">const</span></span><span class="koboSpan" id="kobo.4332.1"> r, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4333.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4334.1">const</span></span><span class="koboSpan" id="kobo.4335.1"> c)
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4336.1">if</span></span><span class="koboSpan" id="kobo.4337.1"> (r &gt;= ROWS || c &gt;= COLS)
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4338.1">throw</span></span><span class="koboSpan" id="kobo.4339.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4340.1">runtime_error</span></span><span class="koboSpan" id="kobo.4341.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4342.1">"Invalid index"</span></span><span class="koboSpan" id="kobo.4343.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4344.1">return</span></span><span class="koboSpan" id="kobo.4345.1"> data[r * COLS + c];
   }
   T </span><span class="hljs-type"><span class="koboSpan" id="kobo.4346.1">const</span></span><span class="koboSpan" id="kobo.4347.1"> &amp; 
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.4348.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4349.1">ifdef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.4350.1"> __cpp_multidimensional_subscript</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4351.1">operator</span></span><span class="koboSpan" id="kobo.4352.1">[] </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4353.1">// C++23</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.4354.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4355.1">else</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.4356.1">operator</span></span><span class="koboSpan" id="kobo.4357.1">() </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4358.1">// previously</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.4359.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4360.1">endif</span></span><span class="koboSpan" id="kobo.4361.1">
   (std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4362.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4363.1">const</span></span><span class="koboSpan" id="kobo.4364.1"> r, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4365.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4366.1">const</span></span><span class="koboSpan" id="kobo.4367.1"> c) </span><span class="hljs-type"><span class="koboSpan" id="kobo.4368.1">const</span></span><span class="koboSpan" id="kobo.4369.1">
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4370.1">if</span></span><span class="koboSpan" id="kobo.4371.1"> (r &gt;= ROWS || c &gt;= COLS)
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4372.1">throw</span></span><span class="koboSpan" id="kobo.4373.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4374.1">runtime_error</span></span><span class="koboSpan" id="kobo.4375.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.4376.1">"Invalid index"</span></span><span class="koboSpan" id="kobo.4377.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4378.1">return</span></span><span class="koboSpan" id="kobo.4379.1"> data[r * COLS + c];
   }
   </span><span class="hljs-function"><span class="koboSpan" id="kobo.4380.1">std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4381.1">size_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4382.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4383.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4384.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4385.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4386.1">return</span></span><span class="koboSpan" id="kobo.4387.1"> data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4388.1">size</span></span><span class="koboSpan" id="kobo.4389.1">(); }
   </span><span class="hljs-function"><span class="koboSpan" id="kobo.4390.1">std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4391.1">size_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4392.1">empty</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4393.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4394.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4395.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4396.1">return</span></span><span class="koboSpan" id="kobo.4397.1"> data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4398.1">empty</span></span><span class="koboSpan" id="kobo.4399.1">(); }
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4400.1">template</span></span><span class="koboSpan" id="kobo.4401.1"> &lt;std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4402.1">size_t</span></span><span class="koboSpan" id="kobo.4403.1"> dimension&gt;
   </span><span class="hljs-function"><span class="koboSpan" id="kobo.4404.1">std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4405.1">size_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4406.1">extent</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4407.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4408.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4409.1">{
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4410.1">static_assert</span></span><span class="koboSpan" id="kobo.4411.1">(dimension &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.4412.1">1</span></span><span class="koboSpan" id="kobo.4413.1">, 
                    </span><span class="hljs-string"><span class="koboSpan" id="kobo.4414.1">"The matrix only has two dimensions."</span></span><span class="koboSpan" id="kobo.4415.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4416.1">if</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4417.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.4418.1">(dimension == </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4419.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4420.1">)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4421.1">return</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4422.1"> ROWS</span></span><span class="koboSpan" id="kobo.4423.1">;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4424.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4425.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.4426.1">constexpr</span></span><span class="koboSpan" id="kobo.4427.1">(dimension == </span><span class="hljs-number"><span class="koboSpan" id="kobo.4428.1">1</span></span><span class="koboSpan" id="kobo.4429.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4430.1">return</span></span><span class="koboSpan" id="kobo.4431.1"> COLS;
   }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4432.1">private</span></span><span class="koboSpan" id="kobo.4433.1">:
   std::array&lt;T, ROWS* COLS&gt; data;
};
</span></code></pre>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.4434.1">In C++23, you should prefer to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4435.1">operator[]</span></code><span class="koboSpan" id="kobo.4436.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4437.1">operator()</span></code><span class="koboSpan" id="kobo.4438.1"> to access elements of a multi-dimensional data structure.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-393"><span class="koboSpan" id="kobo.4439.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4440.1">Prefer</span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.4441.1"> to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4442.1">std::mdspan</span></code><span class="koboSpan" id="kobo.4443.1"> over</span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.4444.1"> multi-dimensional C-like arrays, pointer-of-pointers, or vector-of-vector/array-of-array implementations. </span><span class="koboSpan" id="kobo.4444.2">In other words, replace functions like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4445.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4446.1">f</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4447.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4448.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4449.1"> data[</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4450.1">2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4451.1">][</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4452.1">3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4453.1">])</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4454.1">{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4455.1">/* … */</span></span><span class="koboSpan" id="kobo.4456.1"> }
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4457.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4458.1">g</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4459.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4460.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4461.1">** data, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4462.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4463.1"> row, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4464.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4465.1"> cols)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4466.1">{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4467.1">/* … */</span></span><span class="koboSpan" id="kobo.4468.1"> }
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4469.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4470.1">h</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4471.1">(std::vector&lt;std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4472.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4473.1">&gt;&gt; dat, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4474.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4475.1"> row, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4476.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4477.1"> cols)</span></span><span class="koboSpan" id="kobo.4478.1">
{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4479.1">/* … */</span></span><span class="koboSpan" id="kobo.4480.1"> }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4481.1">with this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4482.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4483.1">f</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4484.1">(std::mdspan&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4485.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4486.1">,std::extents&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4487.1">size_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4488.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4489.1">2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4490.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4491.1">3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4492.1">&gt;&gt; data)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4493.1">
{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4494.1">/* … */</span></span><span class="koboSpan" id="kobo.4495.1"> }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4496.1">When</span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.4497.1"> working </span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.4498.1">with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4499.1">std::mdspan</span></code><span class="koboSpan" id="kobo.4500.1">, you can do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4501.1">Create an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4502.1">mdspan</span></code><span class="koboSpan" id="kobo.4503.1"> with a compile-time </span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.4504.1">length (called </span><strong class="keyWord"><span class="koboSpan" id="kobo.4505.1">static extent</span></strong><span class="koboSpan" id="kobo.4506.1">) by specifying the number of elements of each dimension of the span:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4507.1">int</span></span><span class="koboSpan" id="kobo.4508.1">* data = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4509.1">get_data</span></span><span class="koboSpan" id="kobo.4510.1">();
std::mdspan&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4511.1">int</span></span><span class="koboSpan" id="kobo.4512.1">, std::extents&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4513.1">size_t</span></span><span class="koboSpan" id="kobo.4514.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4515.1">2</span></span><span class="koboSpan" id="kobo.4516.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4517.1">3</span></span><span class="koboSpan" id="kobo.4518.1">&gt;&gt; m(data);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4519.1">Create an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4520.1">mdspan</span></code><span class="koboSpan" id="kobo.4521.1"> with a</span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.4522.1"> runtime length (called </span><strong class="keyWord"><span class="koboSpan" id="kobo.4523.1">dynamic extent</span></strong><span class="koboSpan" id="kobo.4524.1">) by not specifying the number of elements of a dimension of the span at compile-time, and instead providing it at runtime:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4525.1">int</span></span><span class="koboSpan" id="kobo.4526.1">* data = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4527.1">get_data</span></span><span class="koboSpan" id="kobo.4528.1">();
std::mdspan&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4529.1">int</span></span><span class="koboSpan" id="kobo.4530.1">, std::extents&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4531.1">size_t</span></span><span class="koboSpan" id="kobo.4532.1">, 
                              </span><span class="hljs-number"><span class="koboSpan" id="kobo.4533.1">2</span></span><span class="koboSpan" id="kobo.4534.1">, 
                              std::dynamic_extent&gt;&gt; mv{v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4535.1">data</span></span><span class="koboSpan" id="kobo.4536.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.4537.1">3</span></span><span class="koboSpan" id="kobo.4538.1">};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4539.1">or</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4540.1">int</span></span><span class="koboSpan" id="kobo.4541.1">* data = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4542.1">get_data</span></span><span class="koboSpan" id="kobo.4543.1">();
std::mdspan&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4544.1">int</span></span><span class="koboSpan" id="kobo.4545.1">, std::extents&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4546.1">size_t</span></span><span class="koboSpan" id="kobo.4547.1">, 
                              std::dynamic_extent,
                              std::dynamic_extent&gt;&gt; 
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4548.1">m</span></span><span class="koboSpan" id="kobo.4549.1">(data, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4550.1">2</span></span><span class="koboSpan" id="kobo.4551.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4552.1">3</span></span><span class="koboSpan" id="kobo.4553.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4554.1">or</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4555.1">int</span></span><span class="koboSpan" id="kobo.4556.1">* data = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4557.1">get_data</span></span><span class="koboSpan" id="kobo.4558.1">();
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4559.1">std::mdspan </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4560.1">m</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4561.1">(data, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4562.1">2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4563.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4564.1">3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4565.1">)</span></span><span class="koboSpan" id="kobo.4566.1">;
</span></code></pre> </li>
</ul>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4567.1">To control the mapping of the multi-dimensional indexes of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4568.1">mdspan</span></code><span class="koboSpan" id="kobo.4569.1"> to the one-dimensional index of the underlying (contiguous) sequence of data, use a layout policy, which is the third template argument:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4570.1">std::mdspan&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4571.1">int</span></span><span class="koboSpan" id="kobo.4572.1">, 
            std::extents&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4573.1">size_t</span></span><span class="koboSpan" id="kobo.4574.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4575.1">2</span></span><span class="koboSpan" id="kobo.4576.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4577.1">3</span></span><span class="koboSpan" id="kobo.4578.1">&gt;,
            std::layout_right&gt; mv{ data };
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4579.1">or</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4580.1">std::mdspan&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4581.1">int</span></span><span class="koboSpan" id="kobo.4582.1">, 
            std::extents&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4583.1">size_t</span></span><span class="koboSpan" id="kobo.4584.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4585.1">2</span></span><span class="koboSpan" id="kobo.4586.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4587.1">3</span></span><span class="koboSpan" id="kobo.4588.1">&gt;,
            std::layout_left&gt; mv{ data };
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4589.1">or</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4590.1">std::mdspan&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4591.1">int</span></span><span class="koboSpan" id="kobo.4592.1">, 
            std::extents&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4593.1">size_t</span></span><span class="koboSpan" id="kobo.4594.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4595.1">2</span></span><span class="koboSpan" id="kobo.4596.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4597.1">3</span></span><span class="koboSpan" id="kobo.4598.1">&gt;,
            std::layout_stride&gt; mv{ data };
</span></code></pre> </li>
</ul>
<h2 class="heading-2" id="_idParaDest-394"><span class="koboSpan" id="kobo.4599.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4600.1">As the name</span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.4601.1"> implies, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4602.1">mdspan</span></code><span class="koboSpan" id="kobo.4603.1"> is a multi-dimensional span. </span><span class="koboSpan" id="kobo.4603.2">That is a non-owning view of a one-dimensional</span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.4604.1"> sequence of values that is projected as a logical multi-dimensional structure. </span><span class="koboSpan" id="kobo.4604.2">This is what we saw in the </span><em class="italic"><span class="koboSpan" id="kobo.4605.1">Getting ready</span></em><span class="koboSpan" id="kobo.4606.1"> section, where we defined a class called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4607.1">matrix</span></code><span class="koboSpan" id="kobo.4608.1"> that represents a two-dimensional matrix. </span><span class="koboSpan" id="kobo.4608.2">The operations it defines (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4609.1">operator()</span></code><span class="koboSpan" id="kobo.4610.1"> and/or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4611.1">operator[]</span></code><span class="koboSpan" id="kobo.4612.1"> in C++23) are specific to a 2D data structure. </span><span class="koboSpan" id="kobo.4612.2">However, internally, the data is laid out in a contiguous sequence, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4613.1">std::array</span></code><span class="koboSpan" id="kobo.4614.1"> in our implementation. </span><span class="koboSpan" id="kobo.4614.2">We can use this class as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4615.1">matrix&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4616.1">int</span></span><span class="koboSpan" id="kobo.4617.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4618.1">2</span></span><span class="koboSpan" id="kobo.4619.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4620.1">3</span></span><span class="koboSpan" id="kobo.4621.1">&gt; m;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4622.1">for</span></span><span class="koboSpan" id="kobo.4623.1"> (std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4624.1">size_t</span></span><span class="koboSpan" id="kobo.4625.1"> r = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4626.1">0</span></span><span class="koboSpan" id="kobo.4627.1">; r &lt; m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4628.1">extent</span></span><span class="koboSpan" id="kobo.4629.1">&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.4630.1">0</span></span><span class="koboSpan" id="kobo.4631.1">&gt;(); r++)
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4632.1">for</span></span><span class="koboSpan" id="kobo.4633.1"> (std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4634.1">size_t</span></span><span class="koboSpan" id="kobo.4635.1"> c = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4636.1">0</span></span><span class="koboSpan" id="kobo.4637.1">; c &lt; m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4638.1">extent</span></span><span class="koboSpan" id="kobo.4639.1">&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.4640.1">1</span></span><span class="koboSpan" id="kobo.4641.1">&gt;(); c++)
   {
      m[r, c] = r * m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4642.1">extent</span></span><span class="koboSpan" id="kobo.4643.1">&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.4644.1">1</span></span><span class="koboSpan" id="kobo.4645.1">&gt;() + c + </span><span class="hljs-number"><span class="koboSpan" id="kobo.4646.1">1</span></span><span class="koboSpan" id="kobo.4647.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4648.1">// m[r,c] in C++23</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.4649.1">// m(r, c) previously</span></span><span class="koboSpan" id="kobo.4650.1">
   }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4651.1">This for-in-for sequence sets the values of the matrix elements to the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-number"><span class="koboSpan" id="kobo.4652.1">1</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.4653.1">2</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.4654.1">3</span></span>
<span class="hljs-number"><span class="koboSpan" id="kobo.4655.1">4</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.4656.1">5</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.4657.1">6</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4658.1">In C++23, we can simply replace this entire class with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4659.1">std::mdspan</span></code><span class="koboSpan" id="kobo.4660.1"> class: </span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4661.1">std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4662.1">int</span></span><span class="koboSpan" id="kobo.4663.1">, 6&gt; arr;
std::mdspan m{arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4664.1">data</span></span><span class="koboSpan" id="kobo.4665.1">(), std::extents{</span><span class="hljs-number"><span class="koboSpan" id="kobo.4666.1">2</span></span><span class="koboSpan" id="kobo.4667.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4668.1">3</span></span><span class="koboSpan" id="kobo.4669.1">}};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4670.1">for</span></span><span class="koboSpan" id="kobo.4671.1"> (std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4672.1">size_t</span></span><span class="koboSpan" id="kobo.4673.1"> r = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4674.1">0</span></span><span class="koboSpan" id="kobo.4675.1">; r &lt; m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4676.1">extent</span></span><span class="koboSpan" id="kobo.4677.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4678.1">0</span></span><span class="koboSpan" id="kobo.4679.1">); r++)
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4680.1">for</span></span><span class="koboSpan" id="kobo.4681.1"> (std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4682.1">size_t</span></span><span class="koboSpan" id="kobo.4683.1"> c = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4684.1">0</span></span><span class="koboSpan" id="kobo.4685.1">; c &lt; m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4686.1">extent</span></span><span class="koboSpan" id="kobo.4687.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4688.1">1</span></span><span class="koboSpan" id="kobo.4689.1">); c++)
   {
      m[r, c] = r * m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4690.1">extent</span></span><span class="koboSpan" id="kobo.4691.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4692.1">1</span></span><span class="koboSpan" id="kobo.4693.1">) + c + </span><span class="hljs-number"><span class="koboSpan" id="kobo.4694.1">1</span></span><span class="koboSpan" id="kobo.4695.1">;
   }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4696.1">The</span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.4697.1"> only thing </span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.4698.1">that changes here is the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4699.1">extent()</span></code><span class="koboSpan" id="kobo.4700.1"> method, which previously was a function template member of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4701.1">matrix</span></code><span class="koboSpan" id="kobo.4702.1"> class. </span><span class="koboSpan" id="kobo.4702.2">However, this is simply a minor detail. </span><span class="koboSpan" id="kobo.4702.3">We can actually define </span><code class="inlineCode"><span class="koboSpan" id="kobo.4703.1">matrix</span></code><span class="koboSpan" id="kobo.4704.1"> as an alias template for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4705.1">std::mdspan</span></code><span class="koboSpan" id="kobo.4706.1">, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4707.1">template</span></span><span class="koboSpan" id="kobo.4708.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4709.1">typename</span></span><span class="koboSpan" id="kobo.4710.1"> T, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4711.1">size_t</span></span><span class="koboSpan" id="kobo.4712.1"> ROWS, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4713.1">size_t</span></span><span class="koboSpan" id="kobo.4714.1"> COLS&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4715.1">using</span></span><span class="koboSpan" id="kobo.4716.1"> matrix = std::mdspan&lt;T, std::extents&lt;std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4717.1">size_t</span></span><span class="koboSpan" id="kobo.4718.1">, ROWS, COLS&gt;&gt;;
std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4719.1">int</span></span><span class="koboSpan" id="kobo.4720.1">, 6&gt; arr;
matrix&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4721.1">int</span></span><span class="koboSpan" id="kobo.4722.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4723.1">2</span></span><span class="koboSpan" id="kobo.4724.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4725.1">3</span></span><span class="koboSpan" id="kobo.4726.1">&gt; ma {arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4727.1">data</span></span><span class="koboSpan" id="kobo.4728.1">()};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4729.1">In this example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4730.1">mdspan</span></code><span class="koboSpan" id="kobo.4731.1"> is two-dimensional, but it can be defined on any number of dimensions. </span><span class="koboSpan" id="kobo.4731.2">The interface of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4732.1">mdspan</span></code><span class="koboSpan" id="kobo.4733.1"> type includes the following members:</span></p>
<table class="table-container" id="table005-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4734.1">Name</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4735.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4736.1">operator[]</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4737.1">Provides access to the elements of the underlying data.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4738.1">size()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4739.1">Returns the number of elements.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4740.1">empty()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4741.1">Indicates whether the number of elements is zero.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4742.1">stride()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4743.1">Returns the stride of the specified dimension. </span><span class="koboSpan" id="kobo.4743.2">Unless explicitly customized, this is implicitly 1.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4744.1">extents()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4745.1">Returns the size (extent) of the specified dimension.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.4746.1">Table 6.5: A listing of some member functions of mdspan</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4747.1">If you look at the definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4748.1">std::mdspan</span></code><span class="koboSpan" id="kobo.4749.1"> class, you will see the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4750.1">template</span></span><span class="koboSpan" id="kobo.4751.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4752.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4753.1">T</span></span><span class="koboSpan" id="kobo.4754.1">,
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4755.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4756.1">Extents</span></span><span class="koboSpan" id="kobo.4757.1">,
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4758.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4759.1">LayoutPolicy</span></span><span class="koboSpan" id="kobo.4760.1"> = std::layout_right,
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4761.1">class</span></span><span class="koboSpan" id="kobo.4762.1"> AccessorPolicy = std::default_accessor&lt;T&gt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4763.1">class</span></span><span class="koboSpan" id="kobo.4764.1"> mdspan;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4765.1">The first two</span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.4766.1"> template arguments are the type of the elements and the extents (size) of each dimension. </span><span class="koboSpan" id="kobo.4766.2">We</span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.4767.1"> saw these in the previous examples. </span><span class="koboSpan" id="kobo.4767.2">The last two, however, are customization points:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4768.1">The layout policies control how the multi-dimensional index of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4769.1">mdspan</span></code><span class="koboSpan" id="kobo.4770.1"> maps to the offset in the one-dimensional underlying data. </span><span class="koboSpan" id="kobo.4770.2">There are several options available: </span><code class="inlineCode"><span class="koboSpan" id="kobo.4771.1">layout_right</span></code><span class="koboSpan" id="kobo.4772.1"> (the default) where the rightmost index gives stride-one access to the underlying memory (this is the C/C++ style); </span><code class="inlineCode"><span class="koboSpan" id="kobo.4773.1">layout_left</span></code><span class="koboSpan" id="kobo.4774.1"> where the leftmost index gives stride-one access to the underlying memory (this is the Fortran and Matlab style); and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4775.1">layout_stride</span></code><span class="koboSpan" id="kobo.4776.1">, which generalizes the previous two and allows customizing the stride on each extent. </span><span class="koboSpan" id="kobo.4776.2">The reasons for having layout policies are interoperability with other languages and to change an algorithm’s data access pattern without changing the structure of its loop.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4777.1">The accessor policy defines how the underlying sequence stores its elements and how to use the offset from the layout policy to get a reference to a stored element. </span><span class="koboSpan" id="kobo.4777.2">These are mostly intended for third-party libraries. </span><span class="koboSpan" id="kobo.4777.3">It’s unlikely you need to implement an accessor policy for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4778.1">std::mdspan</span></code><span class="koboSpan" id="kobo.4779.1">, just as it is unlikely you need to define an allocator for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4780.1">std::vector</span></code><span class="koboSpan" id="kobo.4781.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4782.1">Let’s exemplify the layout policies to understand how they work. </span><span class="koboSpan" id="kobo.4782.2">The default one is </span><code class="inlineCode"><span class="koboSpan" id="kobo.4783.1">std::layout_right</span></code><span class="koboSpan" id="kobo.4784.1">. </span><span class="koboSpan" id="kobo.4784.2">We can consider this example, which explicitly specifies the policy:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4785.1">std::vector v {</span><span class="hljs-number"><span class="koboSpan" id="kobo.4786.1">1</span></span><span class="koboSpan" id="kobo.4787.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4788.1">2</span></span><span class="koboSpan" id="kobo.4789.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4790.1">3</span></span><span class="koboSpan" id="kobo.4791.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4792.1">4</span></span><span class="koboSpan" id="kobo.4793.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4794.1">5</span></span><span class="koboSpan" id="kobo.4795.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4796.1">6</span></span><span class="koboSpan" id="kobo.4797.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4798.1">7</span></span><span class="koboSpan" id="kobo.4799.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4800.1">8</span></span><span class="koboSpan" id="kobo.4801.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4802.1">9</span></span><span class="koboSpan" id="kobo.4803.1">};
std::mdspan&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4804.1">int</span></span><span class="koboSpan" id="kobo.4805.1">, 
            std::extents&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4806.1">size_t</span></span><span class="koboSpan" id="kobo.4807.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4808.1">2</span></span><span class="koboSpan" id="kobo.4809.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4810.1">3</span></span><span class="koboSpan" id="kobo.4811.1">&gt;,
            std::layout_right&gt; mv{v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4812.1">data</span></span><span class="koboSpan" id="kobo.4813.1">()};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4814.1">The two-dimensional matrix defined here has the following content:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4815.1">1 2 3
4 5 6
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4816.1">However, if we change the layout policy to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4817.1">std::layout_left</span></code><span class="koboSpan" id="kobo.4818.1">, then the content also changes to the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4819.1">1 3 5
2 4 6
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4820.1">You can customize the stride of each dimension using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4821.1">std::layout_stride</span></code><span class="koboSpan" id="kobo.4822.1">. </span><span class="koboSpan" id="kobo.4822.2">The following</span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.4823.1"> snippet </span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.4824.1">defines a stride equivalent to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4825.1">std::layout_right</span></code><span class="koboSpan" id="kobo.4826.1">, for the 2x3 matrix we have seen so far:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4827.1">std::mdspan&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4828.1">int</span></span><span class="koboSpan" id="kobo.4829.1">, 
            std::extents&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4830.1">size_t</span></span><span class="koboSpan" id="kobo.4831.1">, 
                         std::dynamic_extent, 
                         std::dynamic_extent&gt;, 
            std::layout_stride&gt; 
mv{ v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4832.1">data</span></span><span class="koboSpan" id="kobo.4833.1">(), { std::dextents&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4834.1">size_t</span></span><span class="koboSpan" id="kobo.4835.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4836.1">2</span></span><span class="koboSpan" id="kobo.4837.1">&gt;{</span><span class="hljs-number"><span class="koboSpan" id="kobo.4838.1">2</span></span><span class="koboSpan" id="kobo.4839.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4840.1">3</span></span><span class="koboSpan" id="kobo.4841.1">}, 
                std::array&lt;std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.4842.1">size_t</span></span><span class="koboSpan" id="kobo.4843.1">, 2&gt;{</span><span class="hljs-number"><span class="koboSpan" id="kobo.4844.1">3</span></span><span class="koboSpan" id="kobo.4845.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4846.1">1</span></span><span class="koboSpan" id="kobo.4847.1">}}};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4848.1">However, different strides provide different results. </span><span class="koboSpan" id="kobo.4848.2">Several examples are shown in the following table:</span></p>
<table class="table-container" id="table006-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4849.1">Strides</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4850.1">Matrix</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4851.1">{0, 0}</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4852.1">1 1 1</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4853.1">1 1 1</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4854.1">{0, 1}</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4855.1">1 2 3</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4856.1">1 2 3</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4857.1">{1, 0}</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4858.1">1 1 1</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4859.1">2 2 2</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4860.1">{1, 1}</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4861.1">1 2 3</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4862.1">2 3 4</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4863.1">{2, 1}</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4864.1">1 2 3</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4865.1">3 4 5</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4866.1">{1, 2}</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4867.1">1 3 5</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4868.1">2 4 6</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4869.1">{2, 3}</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4870.1">1 4 7</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4871.1">3 6 9</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.4872.1">Table 6.6: Examples of custom strides and the content of resulting views</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4873.1">Let’s discuss</span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.4874.1"> the last example, which is perhaps a bit more general. </span><span class="koboSpan" id="kobo.4874.2">The stride of the first extent represents the offset increment for rows. </span><span class="koboSpan" id="kobo.4874.3">The first element is at index 0 in the underlying sequence. </span><span class="koboSpan" id="kobo.4874.4">Therefore, a stride of 2, as in this case, indicates that rows are read from indexes 0, 2, 4, and so on. </span><span class="koboSpan" id="kobo.4874.5">The stride of the second extent represents the offset</span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.4875.1"> increment for columns. </span><span class="koboSpan" id="kobo.4875.2">The first element is at the index of the corresponding row. </span><span class="koboSpan" id="kobo.4875.3">In this example, the index for the first row is 0, so a stride of 3 for columns means that the elements of the first row will be read from the index 0, 3, and 6. </span><span class="koboSpan" id="kobo.4875.4">The second row starts at index 2. </span><span class="koboSpan" id="kobo.4875.5">Therefore, the elements of the second row will be read from the indexes 2, 5, and 8. </span><span class="koboSpan" id="kobo.4875.6">This is the last example shown in the previous table.</span></p>
<h2 class="heading-2" id="_idParaDest-395"><span class="koboSpan" id="kobo.4876.1">There’s more…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4877.1">The original proposal for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4878.1">mdspan</span></code><span class="koboSpan" id="kobo.4879.1"> included a free function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4880.1">submdspan()</span></code><span class="koboSpan" id="kobo.4881.1">. </span><span class="koboSpan" id="kobo.4881.2">This function creates a slice of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4882.1">mdspan</span></code><span class="koboSpan" id="kobo.4883.1">, or, in other words, a view of a subset of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4884.1">mdspan</span></code><span class="koboSpan" id="kobo.4885.1">. </span><span class="koboSpan" id="kobo.4885.2">In order to make it possible for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4886.1">mdspan</span></code><span class="koboSpan" id="kobo.4887.1"> to be included in C++23, this function was removed and moved to C++26. </span><span class="koboSpan" id="kobo.4887.2">At the time of writing this book, it has already been included in C++26, although no compiler supports it yet.</span></p>
<h2 class="heading-2" id="_idParaDest-396"><span class="koboSpan" id="kobo.4888.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4889.1">Using std::span for contiguous sequences of objects</span></em><span class="koboSpan" id="kobo.4890.1">, to learn how to use non-owning views over contiguous sequences of elements</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-397"><span class="koboSpan" id="kobo.4891.1">Registering a function to be called when a program exits normally</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4892.1">It is </span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.4893.1">common that a program, upon exit, must clean up code to release resources, write something to a log, or do some other end operation. </span><span class="koboSpan" id="kobo.4893.2">The standard library provides two utility functions that enable us to register functions to be called when a program terminates normally, either by returning from </span><code class="inlineCode"><span class="koboSpan" id="kobo.4894.1">main()</span></code><span class="koboSpan" id="kobo.4895.1"> or through a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4896.1">std::exit()</span></code><span class="koboSpan" id="kobo.4897.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4898.1">std::quick_exit()</span></code><span class="koboSpan" id="kobo.4899.1">. </span><span class="koboSpan" id="kobo.4899.2">This is particularly useful for libraries that need to perform an action before the program is terminated, without relying on the user to explicitly call an end function. </span><span class="koboSpan" id="kobo.4899.3">In this recipe, you will learn how to install exit handlers and how they work.</span></p>
<h2 class="heading-2" id="_idParaDest-398"><span class="koboSpan" id="kobo.4900.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4901.1">All the functions discussed in this recipe, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4902.1">exit()</span></code><span class="koboSpan" id="kobo.4903.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4904.1">quick_exit()</span></code><span class="koboSpan" id="kobo.4905.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4906.1">atexit()</span></code><span class="koboSpan" id="kobo.4907.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4908.1">at_quick_exit()</span></code><span class="koboSpan" id="kobo.4909.1">, are available in the namespace </span><code class="inlineCode"><span class="koboSpan" id="kobo.4910.1">std</span></code><span class="koboSpan" id="kobo.4911.1"> in the header </span><code class="inlineCode"><span class="koboSpan" id="kobo.4912.1">&lt;cstdlib&gt;</span></code><span class="koboSpan" id="kobo.4913.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-399"><span class="koboSpan" id="kobo.4914.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4915.1">To register functions to be called upon termination of a program, you should use the following:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4916.1">std::atexit()</span></code><span class="koboSpan" id="kobo.4917.1"> to register functions to be invoked when they return from </span><code class="inlineCode"><span class="koboSpan" id="kobo.4918.1">main()</span></code><span class="koboSpan" id="kobo.4919.1"> or when a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4920.1">std::exit()</span></code><span class="koboSpan" id="kobo.4921.1"> is made:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4922.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4923.1">exit_handler_1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4924.1">()</span></span><span class="koboSpan" id="kobo.4925.1">
{
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4926.1">"exit handler 1"</span></span><span class="koboSpan" id="kobo.4927.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4928.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4929.1">\n'</span></span><span class="koboSpan" id="kobo.4930.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4931.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4932.1">exit_handler_2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4933.1">()</span></span><span class="koboSpan" id="kobo.4934.1">
{
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4935.1">"exit handler 2"</span></span><span class="koboSpan" id="kobo.4936.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4937.1">'\n'</span></span><span class="koboSpan" id="kobo.4938.1">;
}
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4939.1">atexit</span></span><span class="koboSpan" id="kobo.4940.1">(exit_handler_1);
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4941.1">atexit</span></span><span class="koboSpan" id="kobo.4942.1">(exit_handler_2);
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4943.1">atexit</span></span><span class="koboSpan" id="kobo.4944.1">([]() {std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4945.1">"exit handler 3"</span></span><span class="koboSpan" id="kobo.4946.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4947.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4948.1">\n'</span></span><span class="koboSpan" id="kobo.4949.1">; });
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.4950.1">std::at_quick_exit()</span></code><span class="koboSpan" id="kobo.4951.1"> to register functions to be invoked when a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4952.1">std::quick_exit()</span></code><span class="koboSpan" id="kobo.4953.1"> is made:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4954.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4955.1">quick_exit_handler_1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4956.1">()</span></span><span class="koboSpan" id="kobo.4957.1">
{
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4958.1">"quick exit handler 1"</span></span><span class="koboSpan" id="kobo.4959.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4960.1">'\n'</span></span><span class="koboSpan" id="kobo.4961.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4962.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4963.1">quick_exit_handler_2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4964.1">()</span></span><span class="koboSpan" id="kobo.4965.1">
{
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4966.1">"quick exit handler 2"</span></span><span class="koboSpan" id="kobo.4967.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4968.1">'\n'</span></span><span class="koboSpan" id="kobo.4969.1">;
}
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4970.1">at_quick_exit</span></span><span class="koboSpan" id="kobo.4971.1">(quick_exit_handler_1);
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4972.1">at_quick_exit</span></span><span class="koboSpan" id="kobo.4973.1">(quick_exit_handler_2);
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4974.1">at_quick_exit</span></span><span class="koboSpan" id="kobo.4975.1">([]() {
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4976.1">"quick exit handler 3"</span></span><span class="koboSpan" id="kobo.4977.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4978.1">'\n'</span></span><span class="koboSpan" id="kobo.4979.1">; });
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-400"><span class="koboSpan" id="kobo.4980.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4981.1">The</span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.4982.1"> exit handlers, regardless of the method they are registered with, are called only when the program terminates normally or quickly. </span><span class="koboSpan" id="kobo.4982.2">If termination is done in an abnormal way, via a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4983.1">std::terminate()</span></code><span class="koboSpan" id="kobo.4984.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4985.1">std::abort()</span></code><span class="koboSpan" id="kobo.4986.1">, none of them are called. </span><span class="koboSpan" id="kobo.4986.2">If any of these handlers exits via an exception, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.4987.1">std::terminate()</span></code><span class="koboSpan" id="kobo.4988.1"> is called. </span><span class="koboSpan" id="kobo.4988.2">Exit handlers must not have any parameters and must return </span><code class="inlineCode"><span class="koboSpan" id="kobo.4989.1">void</span></code><span class="koboSpan" id="kobo.4990.1">. </span><span class="koboSpan" id="kobo.4990.2">Once registered, an exit handler cannot be unregistered.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4991.1">A program can install multiple handlers. </span><span class="koboSpan" id="kobo.4991.2">The standard guarantees that at least 32 handlers can be registered with each method, although actual implementations can support any higher number. </span><span class="koboSpan" id="kobo.4991.3">Both </span><code class="inlineCode"><span class="koboSpan" id="kobo.4992.1">std::atexit()</span></code><span class="koboSpan" id="kobo.4993.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4994.1">std::at_quick_exit()</span></code><span class="koboSpan" id="kobo.4995.1"> are thread-safe and, therefore, can be called simultaneously from different threads without incurring race conditions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4996.1">If multiple handlers are registered, then they are called in the reverse order of their registration. </span><span class="koboSpan" id="kobo.4996.2">The following table shows the output of a program that registered the exit handlers, as shown in the previous section, when the program terminates via a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4997.1">std::exit()</span></code><span class="koboSpan" id="kobo.4998.1"> call and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4999.1">std::quick_exit()</span></code><span class="koboSpan" id="kobo.5000.1"> call:</span></p>
<table class="table-container" id="table007-1">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5001.1">std::exit(0);</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5002.1">std::quick_exit(0);</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5003.1">exit handler 3
exit handler 2
exit handler 1
</span></code></pre>
</td>
<td class="table-cell">
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5004.1">quick exit handler 3
quick exit handler 2
quick exit handler 1
</span></code></pre>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.5005.1">Table 6.7: Output of the previous snippet when exiting because of a call to exit() and quick_exit()</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5006.1">On the </span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.5007.1">other hand, on normal termination of the program, destruction of objects with local storage duration, destruction of objects with static storage duration, and calls to registered exit handlers are done concurrently. </span><span class="koboSpan" id="kobo.5007.2">However, it is guaranteed that exit handlers registered before the construction of a static object are called after the destruction of that static object, and exit handlers registered after the construction of a static object are called before the destruction of that static object. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.5008.1">To better exemplify this, let’s consider the following class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5009.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5010.1">static_foo</span></span><span class="koboSpan" id="kobo.5011.1">
{
  ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5012.1">static_foo</span></span><span class="koboSpan" id="kobo.5013.1">() { std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5014.1">"static foo destroyed!"</span></span><span class="koboSpan" id="kobo.5015.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5016.1">'\n'</span></span><span class="koboSpan" id="kobo.5017.1">; }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5018.1">static</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5019.1"> static_foo* </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5020.1">instance</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5021.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.5022.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.5023.1">static</span></span><span class="koboSpan" id="kobo.5024.1"> static_foo obj;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5025.1">return</span></span><span class="koboSpan" id="kobo.5026.1"> &amp;obj;
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5027.1">In this context, we will refer to the following code snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5028.1">std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5029.1">atexit</span></span><span class="koboSpan" id="kobo.5030.1">(exit_handler_1);
static_foo::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5031.1">instance</span></span><span class="koboSpan" id="kobo.5032.1">();
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5033.1">atexit</span></span><span class="koboSpan" id="kobo.5034.1">(exit_handler_2);
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5035.1">atexit</span></span><span class="koboSpan" id="kobo.5036.1">([]() {std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5037.1">"exit handler 3"</span></span><span class="koboSpan" id="kobo.5038.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5039.1">'\n'</span></span><span class="koboSpan" id="kobo.5040.1">; });
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5041.1">exit</span></span><span class="koboSpan" id="kobo.5042.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5043.1">42</span></span><span class="koboSpan" id="kobo.5044.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5045.1">When the preceding code snippet is executed, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5046.1">exit_handler_1</span></code><span class="koboSpan" id="kobo.5047.1"> is registered before the creation of the static object </span><code class="inlineCode"><span class="koboSpan" id="kobo.5048.1">static_foo</span></code><span class="koboSpan" id="kobo.5049.1">. </span><span class="koboSpan" id="kobo.5049.2">On the other hand, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5050.1">exit_handler_2</span></code><span class="koboSpan" id="kobo.5051.1"> and the lambda expression are both registered, in that order, after the static object was constructed. </span><span class="koboSpan" id="kobo.5051.2">As a result, the order of calls at normal termination is as follows:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.5052.1">Lambda expression</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.5053.1">exit_handler_2</span></code></li>
<li class="numberedList"><span class="koboSpan" id="kobo.5054.1">Destructor of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5055.1">static_foo</span></code></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.5056.1">exit_handler_1</span></code></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.5057.1">The</span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.5058.1"> output for the preceding program is listed here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5059.1">exit handler 3
exit handler 2
static foo destroyed!
</span><span class="koboSpan" id="kobo.5059.2">exit handler 1
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5060.1">When </span><code class="inlineCode"><span class="koboSpan" id="kobo.5061.1">std::at_quick_exit()</span></code><span class="koboSpan" id="kobo.5062.1"> is used, the registered functions are not called in the case of normal program termination. </span><span class="koboSpan" id="kobo.5062.2">If a function needs to be called in that case, you must register it with </span><code class="inlineCode"><span class="koboSpan" id="kobo.5063.1">std::atexit()</span></code><span class="koboSpan" id="kobo.5064.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-401"><span class="koboSpan" id="kobo.5065.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.5066.1">Chapter 3</span></em><span class="koboSpan" id="kobo.5067.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5068.1">Using lambdas with standard algorithms</span></em><span class="koboSpan" id="kobo.5069.1">, to explore the basics of lambda expressions and how you can utilize them with the standard algorithms</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-402"><span class="koboSpan" id="kobo.5070.1">Using type traits to query properties of types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5071.1">Template </span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.5072.1">metaprogramming is a powerful feature of the language that enables us to write and reuse generic code that works with all types. </span><span class="koboSpan" id="kobo.5072.2">In practice, however, it is often necessary that generic code should work differently, or not at all, with different types, either through intent or for semantic correctness, performance, or other reasons. </span><span class="koboSpan" id="kobo.5072.3">For example, you may want a generic algorithm to be implemented differently for POD and non-POD types or a function template to be instantiated only with integral types. </span><span class="koboSpan" id="kobo.5072.4">C++11 provides a set of type traits to help with this.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5073.1">Type traits are basically meta-types that provide information about other types. </span><span class="koboSpan" id="kobo.5073.2">The type traits library contains a long list of traits for querying type properties (such as checking whether a type is an integral type or whether two types are the same), but also for performing type transformation (such as removing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5074.1">const</span></code><span class="koboSpan" id="kobo.5075.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5076.1">volatile</span></code><span class="koboSpan" id="kobo.5077.1"> qualifiers or adding a pointer to a type). </span><span class="koboSpan" id="kobo.5077.2">We have used type traits in several recipes earlier in this book; however, in this recipe, we will look into what the type traits are and how they work.</span></p>
<h2 class="heading-2" id="_idParaDest-403"><span class="koboSpan" id="kobo.5078.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5079.1">All type traits introduced in C++11 are available in the namespace </span><code class="inlineCode"><span class="koboSpan" id="kobo.5080.1">std</span></code><span class="koboSpan" id="kobo.5081.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5082.1">&lt;type_traits&gt;</span></code><span class="koboSpan" id="kobo.5083.1"> header.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5084.1">Type traits </span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.5085.1">can be used in many metaprogramming contexts, and throughout this book, we have seen them used in various situations. </span><span class="koboSpan" id="kobo.5085.2">In this recipe, we will summarize some of these use cases and see how type traits work.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5086.1">In this recipe, we will discuss full and partial template specialization. </span><span class="koboSpan" id="kobo.5086.2">Familiarity with these concepts will help you better understand the way type traits work.</span></p>
<h2 class="heading-2" id="_idParaDest-404"><span class="koboSpan" id="kobo.5087.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5088.1">The following list shows various situations where type traits are used to achieve various design goals:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5089.1">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.5090.1">enable_if</span></code><span class="koboSpan" id="kobo.5091.1"> to define preconditions for the types a function template can be instantiated with:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5092.1">template</span></span><span class="koboSpan" id="kobo.5093.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5094.1">typename</span></span><span class="koboSpan" id="kobo.5095.1"> T,
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5096.1">typename</span></span><span class="koboSpan" id="kobo.5097.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5098.1">typename</span></span><span class="koboSpan" id="kobo.5099.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5100.1">enable_if_t</span></span><span class="koboSpan" id="kobo.5101.1">&lt;
                std::is_arithmetic_v&lt;T&gt; &gt; &gt;
T </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5102.1">multiply</span></span><span class="koboSpan" id="kobo.5103.1">(T </span><span class="hljs-type"><span class="koboSpan" id="kobo.5104.1">const</span></span><span class="koboSpan" id="kobo.5105.1"> t1, T </span><span class="hljs-type"><span class="koboSpan" id="kobo.5106.1">const</span></span><span class="koboSpan" id="kobo.5107.1"> t2)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5108.1">return</span></span><span class="koboSpan" id="kobo.5109.1"> t1 * t2;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5110.1">auto</span></span><span class="koboSpan" id="kobo.5111.1"> v1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5112.1">multiply</span></span><span class="koboSpan" id="kobo.5113.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5114.1">42.0</span></span><span class="koboSpan" id="kobo.5115.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5116.1">1.5</span></span><span class="koboSpan" id="kobo.5117.1">);     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5118.1">// OK</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5119.1">auto</span></span><span class="koboSpan" id="kobo.5120.1"> v2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5121.1">multiply</span></span><span class="koboSpan" id="kobo.5122.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5123.1">"42"</span></span><span class="koboSpan" id="kobo.5124.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.5125.1">"1.5"</span></span><span class="koboSpan" id="kobo.5126.1">s); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5127.1">// error</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5128.1">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.5129.1">static_assert</span></code><span class="koboSpan" id="kobo.5130.1"> to ensure that invariants are met:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5131.1">template</span></span><span class="koboSpan" id="kobo.5132.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5133.1">typename</span></span><span class="koboSpan" id="kobo.5134.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5135.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5136.1">pod_wrapper</span></span><span class="koboSpan" id="kobo.5137.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5138.1">static_assert</span></span><span class="koboSpan" id="kobo.5139.1">(std::is_standard_layout_v&lt;T&gt; &amp;&amp;
                std::is_trivial_v&lt;T&gt;,
                </span><span class="hljs-string"><span class="koboSpan" id="kobo.5140.1">"Type is not a POD!"</span></span><span class="koboSpan" id="kobo.5141.1">);
  T value;
};
pod_wrapper&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5142.1">int</span></span><span class="koboSpan" id="kobo.5143.1">&gt; i{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.5144.1">42</span></span><span class="koboSpan" id="kobo.5145.1"> };            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5146.1">// OK</span></span><span class="koboSpan" id="kobo.5147.1">
pod_wrapper&lt;std::string&gt; s{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.5148.1">"42"</span></span><span class="koboSpan" id="kobo.5149.1">s }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5150.1">// error</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5151.1">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.5152.1">std::conditional</span></code><span class="koboSpan" id="kobo.5153.1"> to select between types:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5154.1">template</span></span><span class="koboSpan" id="kobo.5155.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5156.1">typename</span></span><span class="koboSpan" id="kobo.5157.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5158.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5159.1">const_wrapper</span></span><span class="koboSpan" id="kobo.5160.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5161.1">typedef</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5162.1">typename</span></span><span class="koboSpan" id="kobo.5163.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5164.1">conditional_t</span></span><span class="koboSpan" id="kobo.5165.1">&lt;
            std::is_const_v&lt;T&gt;,
            T,
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5166.1">typename</span></span><span class="koboSpan" id="kobo.5167.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5168.1">add_const_t</span></span><span class="koboSpan" id="kobo.5169.1">&lt;T&gt;&gt; const_type;
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5170.1">static_assert</span></span><span class="koboSpan" id="kobo.5171.1">(
  std::is_const_v&lt;const_wrapper&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5172.1">int</span></span><span class="koboSpan" id="kobo.5173.1">&gt;::const_type&gt;);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5174.1">static_assert</span></span><span class="koboSpan" id="kobo.5175.1">(
  std::is_const_v&lt;const_wrapper&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5176.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5177.1">const</span></span><span class="koboSpan" id="kobo.5178.1">&gt;::const_type&gt;);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5179.1">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.5180.1">constexpr if</span></code><span class="koboSpan" id="kobo.5181.1"> to enable the compiler to generate different code based on the </span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.5182.1">type the template is instantiated with:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5183.1">template</span></span><span class="koboSpan" id="kobo.5184.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5185.1">typename</span></span><span class="koboSpan" id="kobo.5186.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5187.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5188.1">process</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5189.1">(T arg)</span></span><span class="koboSpan" id="kobo.5190.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5191.1">if</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5192.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.5193.1">(std::is_same_v&lt;T, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5194.1">bool</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5195.1">&gt;)</span></span>
<span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5196.1">return</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5197.1"> !arg</span></span><span class="koboSpan" id="kobo.5198.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5199.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5200.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5201.1">constexpr</span></span><span class="koboSpan" id="kobo.5202.1"> (std::is_integral_v&lt;T&gt;)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5203.1">return</span></span><span class="koboSpan" id="kobo.5204.1"> -arg;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5205.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5206.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5207.1">constexpr</span></span><span class="koboSpan" id="kobo.5208.1"> (std::is_floating_point_v&lt;T&gt;)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5209.1">return</span></span><span class="koboSpan" id="kobo.5210.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5211.1">abs</span></span><span class="koboSpan" id="kobo.5212.1">(arg);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5213.1">else</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5214.1">return</span></span><span class="koboSpan" id="kobo.5215.1"> arg;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5216.1">auto</span></span><span class="koboSpan" id="kobo.5217.1"> v1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5218.1">process</span></span><span class="koboSpan" id="kobo.5219.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.5220.1">false</span></span><span class="koboSpan" id="kobo.5221.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5222.1">// v1 = true</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5223.1">auto</span></span><span class="koboSpan" id="kobo.5224.1"> v2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5225.1">process</span></span><span class="koboSpan" id="kobo.5226.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5227.1">42</span></span><span class="koboSpan" id="kobo.5228.1">);    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5229.1">// v2 = -42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5230.1">auto</span></span><span class="koboSpan" id="kobo.5231.1"> v3 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5232.1">process</span></span><span class="koboSpan" id="kobo.5233.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5234.1">-42.0</span></span><span class="koboSpan" id="kobo.5235.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5236.1">// v3 = 42.0</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5237.1">auto</span></span><span class="koboSpan" id="kobo.5238.1"> v4 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5239.1">process</span></span><span class="koboSpan" id="kobo.5240.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5241.1">"42"</span></span><span class="koboSpan" id="kobo.5242.1">s); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5243.1">// v4 = "42"</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-405"><span class="koboSpan" id="kobo.5244.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5245.1">Type traits are classes that provide meta-information about types or can be used to modify types. </span><span class="koboSpan" id="kobo.5245.2">There are actually two categories of type traits:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5246.1">Traits that provide information about types, their properties, or their relations (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5247.1">is_integer</span></code><span class="koboSpan" id="kobo.5248.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5249.1">is_arithmetic</span></code><span class="koboSpan" id="kobo.5250.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5251.1">is_array</span></code><span class="koboSpan" id="kobo.5252.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5253.1">is_enum</span></code><span class="koboSpan" id="kobo.5254.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5255.1">is_class</span></code><span class="koboSpan" id="kobo.5256.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5257.1">is_const</span></code><span class="koboSpan" id="kobo.5258.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5259.1">is_trivial</span></code><span class="koboSpan" id="kobo.5260.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5261.1">is_standard_layout</span></code><span class="koboSpan" id="kobo.5262.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5263.1">is_constructible</span></code><span class="koboSpan" id="kobo.5264.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5265.1">is_same</span></code><span class="koboSpan" id="kobo.5266.1">, and so on). </span><span class="koboSpan" id="kobo.5266.2">These traits provide a constant </span><code class="inlineCode"><span class="koboSpan" id="kobo.5267.1">bool</span></code><span class="koboSpan" id="kobo.5268.1"> member called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5269.1">value</span></code><span class="koboSpan" id="kobo.5270.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5271.1">Traits that modify properties of types (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5272.1">add_const</span></code><span class="koboSpan" id="kobo.5273.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5274.1">remove_const</span></code><span class="koboSpan" id="kobo.5275.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5276.1">add_pointer</span></code><span class="koboSpan" id="kobo.5277.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5278.1">remove_pointer</span></code><span class="koboSpan" id="kobo.5279.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5280.1">make_signed</span></code><span class="koboSpan" id="kobo.5281.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5282.1">make_unsigned</span></code><span class="koboSpan" id="kobo.5283.1">, and so on). </span><span class="koboSpan" id="kobo.5283.2">These traits provide a member typedef called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5284.1">type</span></code><span class="koboSpan" id="kobo.5285.1"> that represents the transformed type.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5286.1">Both of these</span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.5287.1"> categories of types have been shown in the </span><em class="italic"><span class="koboSpan" id="kobo.5288.1">How to do it...</span></em><span class="koboSpan" id="kobo.5289.1"> section; examples have been discussed and explained in detail in other recipes. </span><span class="koboSpan" id="kobo.5289.2">For convenience, a short summary is provided here:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5290.1">In the first example, the function template </span><code class="inlineCode"><span class="koboSpan" id="kobo.5291.1">multiply()</span></code><span class="koboSpan" id="kobo.5292.1"> is allowed to be instantiated only with arithmetic types (that is, integral or floating point); when instantiated with a different kind of type, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5293.1">enable_if</span></code><span class="koboSpan" id="kobo.5294.1"> does not define a typedef member called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5295.1">type</span></code><span class="koboSpan" id="kobo.5296.1">, which produces a compilation error.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5297.1">In the second example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5298.1">pod_wrapper</span></code><span class="koboSpan" id="kobo.5299.1"> is a class template that is supposed to be instantiated only with POD types. </span><span class="koboSpan" id="kobo.5299.2">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.5300.1">static_assert</span></code><span class="koboSpan" id="kobo.5301.1"> declaration produces a compilation error if a non-POD type is used (it is either not trivial or not in the standard layout).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5302.1">In the third example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5303.1">const_wrapper</span></code><span class="koboSpan" id="kobo.5304.1"> is a class template that provides a typedef member called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5305.1">const_type</span></code><span class="koboSpan" id="kobo.5306.1"> that represents a constant-qualified type.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5307.1">In this example, we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.5308.1">std::conditional</span></code><span class="koboSpan" id="kobo.5309.1"> to select between two types at compile time: if the type parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.5310.1">T</span></code><span class="koboSpan" id="kobo.5311.1"> is already a const type, then we just select </span><code class="inlineCode"><span class="koboSpan" id="kobo.5312.1">T</span></code><span class="koboSpan" id="kobo.5313.1">. </span><span class="koboSpan" id="kobo.5313.2">Otherwise, we use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5314.1">add_const</span></code><span class="koboSpan" id="kobo.5315.1"> type trait to qualify the type with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5316.1">const</span></code><span class="koboSpan" id="kobo.5317.1"> specifier.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5318.1">If the fourth example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5319.1">process()</span></code><span class="koboSpan" id="kobo.5320.1"> is a function template that contains a series of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5321.1">if constexpr</span></code><span class="koboSpan" id="kobo.5322.1"> branches. </span><span class="koboSpan" id="kobo.5322.2">Based on the category of type, queried at compile time with various type traits (</span><code class="inlineCode"><span class="koboSpan" id="kobo.5323.1">is_same</span></code><span class="koboSpan" id="kobo.5324.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5325.1">is_integer</span></code><span class="koboSpan" id="kobo.5326.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5327.1">is_floating_point</span></code><span class="koboSpan" id="kobo.5328.1">), the compiler selects one branch only to be put into the generated code and discards the rest. </span><span class="koboSpan" id="kobo.5328.2">Therefore, a call such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5329.1">process(42)</span></code><span class="koboSpan" id="kobo.5330.1"> will produce the following instantiation of the function template:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.5331.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5332.1">process</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5333.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5334.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5335.1"> arg)</span></span><span class="koboSpan" id="kobo.5336.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5337.1">return</span></span><span class="koboSpan" id="kobo.5338.1"> -arg;
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5339.1">Type traits</span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.5340.1"> are implemented by providing a class template and a partial or full specialization for it. </span><span class="koboSpan" id="kobo.5340.2">The following represent conceptual implementations for some type traits:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5341.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5342.1">is_void()</span></code><span class="koboSpan" id="kobo.5343.1"> method indicates whether a type is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5344.1">void</span></code><span class="koboSpan" id="kobo.5345.1">; this uses full specialization:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5346.1">template</span></span><span class="koboSpan" id="kobo.5347.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5348.1">typename</span></span><span class="koboSpan" id="kobo.5349.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5350.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5351.1">is_void</span></span><span class="koboSpan" id="kobo.5352.1">
{ </span><span class="hljs-type"><span class="koboSpan" id="kobo.5353.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5354.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5355.1">bool</span></span><span class="koboSpan" id="kobo.5356.1"> value = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.5357.1">false</span></span><span class="koboSpan" id="kobo.5358.1">; };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5359.1">template</span></span><span class="koboSpan" id="kobo.5360.1"> &lt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5361.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5362.1">is_void</span></span><span class="koboSpan" id="kobo.5363.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5364.1">void</span></span><span class="koboSpan" id="kobo.5365.1">&gt;
{ </span><span class="hljs-type"><span class="koboSpan" id="kobo.5366.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5367.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5368.1">bool</span></span><span class="koboSpan" id="kobo.5369.1"> value = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.5370.1">true</span></span><span class="koboSpan" id="kobo.5371.1">; };
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5372.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5373.1">is_pointer()</span></code><span class="koboSpan" id="kobo.5374.1"> method indicates whether a type is a pointer to an object or a pointer to a function; this uses partial specialization:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5375.1">template</span></span><span class="koboSpan" id="kobo.5376.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5377.1">typename</span></span><span class="koboSpan" id="kobo.5378.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5379.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5380.1">is_pointer</span></span><span class="koboSpan" id="kobo.5381.1">
{ </span><span class="hljs-type"><span class="koboSpan" id="kobo.5382.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5383.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5384.1">bool</span></span><span class="koboSpan" id="kobo.5385.1"> value = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.5386.1">false</span></span><span class="koboSpan" id="kobo.5387.1">; };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5388.1">template</span></span><span class="koboSpan" id="kobo.5389.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5390.1">typename</span></span><span class="koboSpan" id="kobo.5391.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5392.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5393.1">is_pointer</span></span><span class="koboSpan" id="kobo.5394.1">&lt;T*&gt;
{ </span><span class="hljs-type"><span class="koboSpan" id="kobo.5395.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5396.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5397.1">bool</span></span><span class="koboSpan" id="kobo.5398.1"> value = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.5399.1">true</span></span><span class="koboSpan" id="kobo.5400.1">; };
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5401.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5402.1">enable_if()</span></code><span class="koboSpan" id="kobo.5403.1"> type trait defines a type alias for its type template parameter if and only if its non-type template parameter is an expression that evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5404.1">true</span></code><span class="koboSpan" id="kobo.5405.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5406.1">template</span></span><span class="koboSpan" id="kobo.5407.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5408.1">bool</span></span><span class="koboSpan" id="kobo.5409.1"> B, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5410.1">typename</span></span><span class="koboSpan" id="kobo.5411.1"> T = </span><span class="hljs-type"><span class="koboSpan" id="kobo.5412.1">void</span></span><span class="koboSpan" id="kobo.5413.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5414.1">struct</span></span><span class="koboSpan" id="kobo.5415.1"> enable_if {};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5416.1">template</span></span><span class="koboSpan" id="kobo.5417.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5418.1">typename</span></span><span class="koboSpan" id="kobo.5419.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5420.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5421.1">enable_if</span></span><span class="koboSpan" id="kobo.5422.1">&lt;</span><span class="hljs-literal"><span class="koboSpan" id="kobo.5423.1">true</span></span><span class="koboSpan" id="kobo.5424.1">, T&gt; { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5425.1">using</span></span><span class="koboSpan" id="kobo.5426.1"> type = T; };
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5427.1">Because the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5428.1">bool</span></code><span class="koboSpan" id="kobo.5429.1"> member </span><code class="inlineCode"><span class="koboSpan" id="kobo.5430.1">value</span></code><span class="koboSpan" id="kobo.5431.1"> for the traits of query properties (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5432.1">std::is_integer&lt;int&gt;::value</span></code><span class="koboSpan" id="kobo.5433.1">), or for the member types alias called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5434.1">type</span></code><span class="koboSpan" id="kobo.5435.1"> for traits that modify type properties (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5436.1">std::enable_if&lt;true, T&gt;::type</span></code><span class="koboSpan" id="kobo.5437.1">) is too verbose (and long), the C++14 and C++17 standards have introduced some helpers to simplify the use:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5438.1">A variable template of the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.5439.1">std::trait_v&lt;T&gt;</span></code><span class="koboSpan" id="kobo.5440.1"> for </span><code class="inlineCode"><span class="koboSpan" id="kobo.5441.1">std::trait&lt;T&gt;::value</span></code><span class="koboSpan" id="kobo.5442.1">. </span><span class="koboSpan" id="kobo.5442.2">An example is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5443.1">std::is_integer_v&lt;T&gt;</span></code><span class="koboSpan" id="kobo.5444.1">, which is defined as follows:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5445.1">template</span></span><span class="koboSpan" id="kobo.5446.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5447.1">typename</span></span><span class="koboSpan" id="kobo.5448.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5449.1">inline</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.5450.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5451.1">bool</span></span><span class="koboSpan" id="kobo.5452.1"> is_integral_v = is_integral&lt;T&gt;::value;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5453.1">An alias template of the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.5454.1">std::trait_t&lt;T&gt;</span></code><span class="koboSpan" id="kobo.5455.1"> for </span><code class="inlineCode"><span class="koboSpan" id="kobo.5456.1">std::trait&lt;T&gt;::type</span></code><span class="koboSpan" id="kobo.5457.1">. </span><span class="koboSpan" id="kobo.5457.2">An example is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5458.1">std::enable_if_t&lt;B, T&gt;</span></code><span class="koboSpan" id="kobo.5459.1">, which is defined as follows:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5460.1">template</span></span><span class="koboSpan" id="kobo.5461.1"> &lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5462.1">bool</span></span><span class="koboSpan" id="kobo.5463.1"> B, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5464.1">typename</span></span><span class="koboSpan" id="kobo.5465.1"> T = </span><span class="hljs-type"><span class="koboSpan" id="kobo.5466.1">void</span></span><span class="koboSpan" id="kobo.5467.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5468.1">using</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5469.1">enable_if_t</span></span><span class="koboSpan" id="kobo.5470.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5471.1">typename</span></span><span class="koboSpan" id="kobo.5472.1"> enable_if&lt;B,T&gt;::type;
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5473.1">Note </span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.5474.1">that, in C++20, the concept of the POD type has been deprecated. </span><span class="koboSpan" id="kobo.5474.2">This also includes the deprecation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5475.1">std::is_pod</span></code><span class="koboSpan" id="kobo.5476.1"> type trait. </span><span class="koboSpan" id="kobo.5476.2">A POD type is a type that is both </span><em class="italic"><span class="koboSpan" id="kobo.5477.1">trivial</span></em><span class="koboSpan" id="kobo.5478.1"> (has special members that are compiler-provided or explicitly defaulted and occupy a contiguous memory area) and has a </span><em class="italic"><span class="koboSpan" id="kobo.5479.1">standard layout</span></em><span class="koboSpan" id="kobo.5480.1"> (a class that does not contain language features, such as virtual functions, which are incompatible with the C language, and all members have the same access control). </span><span class="koboSpan" id="kobo.5480.2">Therefore, as of C++20, the more fine-grained concepts of trivial and standard layout types are preferred. </span><span class="koboSpan" id="kobo.5480.3">This also implies that you should no longer use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5481.1">std::is_pod</span></code><span class="koboSpan" id="kobo.5482.1">, but </span><code class="inlineCode"><span class="koboSpan" id="kobo.5483.1">std::is_trivial</span></code><span class="koboSpan" id="kobo.5484.1"> and, respectively, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5485.1">std::is_standard_layout</span></code><span class="koboSpan" id="kobo.5486.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-406"><span class="koboSpan" id="kobo.5487.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5488.1">Type traits are not limited to what the standard library provides. </span><span class="koboSpan" id="kobo.5488.2">Using similar techniques, you can define your own type traits to achieve various goals. </span><span class="koboSpan" id="kobo.5488.3">In the next recipe, </span><em class="italic"><span class="koboSpan" id="kobo.5489.1">Writing your own type traits</span></em><span class="koboSpan" id="kobo.5490.1">, we will learn how to define and use our own type traits.</span></p>
<h2 class="heading-2" id="_idParaDest-407"><span class="koboSpan" id="kobo.5491.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.5492.1">Chapter 4</span></em><span class="koboSpan" id="kobo.5493.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5494.1">Selecting branches at compile time with constexpr if</span></em><span class="koboSpan" id="kobo.5495.1">, to learn how to compile only parts of your code with </span><em class="italic"><span class="koboSpan" id="kobo.5496.1">constexpr if</span></em><span class="koboSpan" id="kobo.5497.1"> statements</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.5498.1">Chapter 4</span></em><span class="koboSpan" id="kobo.5499.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5500.1">Conditionally compiling classes and functions with enable_if</span></em><span class="koboSpan" id="kobo.5501.1">, to learn about SFINAE and how to use it to specify type constraints for templates</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.5502.1">Chapter 4</span></em><span class="koboSpan" id="kobo.5503.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5504.1">Performing compile-time assertion checks with static_assert</span></em><span class="koboSpan" id="kobo.5505.1">, to see how to define assertions that are verified at compile time</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5506.1">Writing your own type traits</span></em><span class="koboSpan" id="kobo.5507.1">, to learn how to define your own type traits</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5508.1">Using std::conditional to choose between types</span></em><span class="koboSpan" id="kobo.5509.1">, to understand how to perform a compile-time selection of types on a compile-time Boolean expression</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-408"><span class="koboSpan" id="kobo.5510.1">Writing your own type traits</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5511.1">In the </span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.5512.1">previous recipe, we learned what type traits are, what traits the standard provides, and how they can be used for various purposes. </span><span class="koboSpan" id="kobo.5512.2">In this recipe, we’ll go a step further and take a look at how to define our own custom traits.</span></p>
<h2 class="heading-2" id="_idParaDest-409"><span class="koboSpan" id="kobo.5513.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5514.1">In this recipe, we will learn how to solve the following problem: we have several classes that support serialization. </span><span class="koboSpan" id="kobo.5514.2">Without getting into any details, let’s suppose some provide a “plain” serialization to a string (regardless of what that can mean), whereas others do it based on a specified encoding. </span><span class="koboSpan" id="kobo.5514.3">The end goal is to create a single, uniform API for serializing the objects of any of these types. </span><span class="koboSpan" id="kobo.5514.4">For this, we will consider the following two classes: </span><code class="inlineCode"><span class="koboSpan" id="kobo.5515.1">foo</span></code><span class="koboSpan" id="kobo.5516.1">, which provides a simple serialization, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5517.1">bar</span></code><span class="koboSpan" id="kobo.5518.1">, which provides serialization with encoding. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.5519.1">Let’s look at the code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5520.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5521.1">foo</span></span><span class="koboSpan" id="kobo.5522.1">
{
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.5523.1">std::string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5524.1">serialize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5525.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.5526.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5527.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.5528.1">"plain"</span></span><span class="koboSpan" id="kobo.5529.1">s;
  }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5530.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5531.1">bar</span></span><span class="koboSpan" id="kobo.5532.1">
{
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.5533.1">std::string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5534.1">serialize_with_encoding</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5535.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.5536.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5537.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.5538.1">"encoded"</span></span><span class="koboSpan" id="kobo.5539.1">s;
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5540.1">It is recommended</span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.5541.1"> that you read the preceding </span><em class="italic"><span class="koboSpan" id="kobo.5542.1">Using type traits to query properties of types</span></em><span class="koboSpan" id="kobo.5543.1"> recipe first before you continue with this one.</span></p>
<h2 class="heading-2" id="_idParaDest-410"><span class="koboSpan" id="kobo.5544.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5545.1">Implement the following class and function templates:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5546.1">A class template called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5547.1">is_serializable_with_encoding</span></code><span class="koboSpan" id="kobo.5548.1"> containing a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5549.1">static</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.5550.1">const</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.5551.1">bool</span></code><span class="koboSpan" id="kobo.5552.1"> variable set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5553.1">false</span></code><span class="koboSpan" id="kobo.5554.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5555.1">template</span></span><span class="koboSpan" id="kobo.5556.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5557.1">typename</span></span><span class="koboSpan" id="kobo.5558.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5559.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5560.1">is_serializable_with_encoding</span></span><span class="koboSpan" id="kobo.5561.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5562.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5563.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5564.1">bool</span></span><span class="koboSpan" id="kobo.5565.1"> value = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.5566.1">false</span></span><span class="koboSpan" id="kobo.5567.1">;
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5568.1">A full specialization of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5569.1">is_serializable_with_encoding</span></code><span class="koboSpan" id="kobo.5570.1"> template for the class </span><code class="inlineCode"><span class="koboSpan" id="kobo.5571.1">bar</span></code><span class="koboSpan" id="kobo.5572.1"> that has the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5573.1">static</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.5574.1">const</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.5575.1">bool</span></code><span class="koboSpan" id="kobo.5576.1"> variable set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5577.1">true</span></code><span class="koboSpan" id="kobo.5578.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5579.1">template</span></span><span class="koboSpan" id="kobo.5580.1"> &lt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5581.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5582.1">is_serializable_with_encoding</span></span><span class="koboSpan" id="kobo.5583.1">&lt;bar&gt;
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5584.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5585.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5586.1">bool</span></span><span class="koboSpan" id="kobo.5587.1"> value = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.5588.1">true</span></span><span class="koboSpan" id="kobo.5589.1">;
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5590.1">A class template called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5591.1">serializer</span></code><span class="koboSpan" id="kobo.5592.1"> containing a static template method called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5593.1">serialize</span></code><span class="koboSpan" id="kobo.5594.1">, which takes an argument of the template type </span><code class="inlineCode"><span class="koboSpan" id="kobo.5595.1">T</span></code><span class="koboSpan" id="kobo.5596.1"> and calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.5597.1">serialize()</span></code><span class="koboSpan" id="kobo.5598.1"> for that object:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5599.1">template</span></span><span class="koboSpan" id="kobo.5600.1"> &lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5601.1">bool</span></span><span class="koboSpan" id="kobo.5602.1"> b&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5603.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5604.1">serializer</span></span><span class="koboSpan" id="kobo.5605.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5606.1">template</span></span><span class="koboSpan" id="kobo.5607.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5608.1">typename</span></span><span class="koboSpan" id="kobo.5609.1"> T&gt;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5610.1">static</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5611.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5612.1">serialize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5613.1">(T&amp; v)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.5614.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5615.1">return</span></span><span class="koboSpan" id="kobo.5616.1"> v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5617.1">serialize</span></span><span class="koboSpan" id="kobo.5618.1">();
  }
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5619.1">A full</span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.5620.1"> specialization class template for </span><code class="inlineCode"><span class="koboSpan" id="kobo.5621.1">true</span></code><span class="koboSpan" id="kobo.5622.1">, whose </span><code class="inlineCode"><span class="koboSpan" id="kobo.5623.1">serialize()</span></code><span class="koboSpan" id="kobo.5624.1"> static method calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.5625.1">serialize_with_encoding()</span></code><span class="koboSpan" id="kobo.5626.1"> for the argument:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5627.1">template</span></span><span class="koboSpan" id="kobo.5628.1"> &lt;&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5629.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5630.1">serializer</span></span><span class="koboSpan" id="kobo.5631.1">&lt;</span><span class="hljs-literal"><span class="koboSpan" id="kobo.5632.1">true</span></span><span class="koboSpan" id="kobo.5633.1">&gt;
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5634.1">template</span></span><span class="koboSpan" id="kobo.5635.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5636.1">typename</span></span><span class="koboSpan" id="kobo.5637.1"> T&gt;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.5638.1">static</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5639.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5640.1">serialize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5641.1">(T&amp; v)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.5642.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5643.1">return</span></span><span class="koboSpan" id="kobo.5644.1"> v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5645.1">serialize_with_encoding</span></span><span class="koboSpan" id="kobo.5646.1">();
  }
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5647.1">A function template called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5648.1">serialize()</span></code><span class="koboSpan" id="kobo.5649.1">, which uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5650.1">serializer</span></code><span class="koboSpan" id="kobo.5651.1"> class templates defined previously and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5652.1">is_serializable_with_encoding</span></code><span class="koboSpan" id="kobo.5653.1"> type trait, to select which of the actual serialization methods (plain or with encoding) should be called:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5654.1">template</span></span><span class="koboSpan" id="kobo.5655.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5656.1">typename</span></span><span class="koboSpan" id="kobo.5657.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5658.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5659.1">serialize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5660.1">(T&amp; v)</span></span><span class="koboSpan" id="kobo.5661.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5662.1">return</span></span><span class="koboSpan" id="kobo.5663.1"> serializer&lt;is_serializable_with_encoding&lt;T&gt;::value&gt;::
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5664.1">serialize</span></span><span class="koboSpan" id="kobo.5665.1">(v);
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-411"><span class="koboSpan" id="kobo.5666.1">How it works...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5667.1">is_serializable_with_encoding</span></code><span class="koboSpan" id="kobo.5668.1"> is a type trait that checks whether a type </span><code class="inlineCode"><span class="koboSpan" id="kobo.5669.1">T</span></code><span class="koboSpan" id="kobo.5670.1"> is serializable with (a specified) encoding. </span><span class="koboSpan" id="kobo.5670.2">It provides a static member of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.5671.1">bool</span></code><span class="koboSpan" id="kobo.5672.1"> called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5673.1">value</span></code><span class="koboSpan" id="kobo.5674.1"> that is equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5675.1">true</span></code><span class="koboSpan" id="kobo.5676.1"> if </span><code class="inlineCode"><span class="koboSpan" id="kobo.5677.1">T</span></code><span class="koboSpan" id="kobo.5678.1"> supports serialization with encoding, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.5679.1">false</span></code><span class="koboSpan" id="kobo.5680.1"> otherwise. </span><span class="koboSpan" id="kobo.5680.2">It is implemented as a class template with a single type template parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.5681.1">T</span></code><span class="koboSpan" id="kobo.5682.1">; this class template is fully specialized for the types that support encoded serialization—in this particular example—for the class </span><code class="inlineCode"><span class="koboSpan" id="kobo.5683.1">bar</span></code><span class="koboSpan" id="kobo.5684.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5685.1">std::cout &lt;&lt; std::boolalpha;
std::cout &lt;&lt;
  is_serializable_with_encoding&lt;foo&gt;::value &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5686.1">'\n'</span></span><span class="koboSpan" id="kobo.5687.1">;        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5688.1">// false</span></span><span class="koboSpan" id="kobo.5689.1">
std::cout &lt;&lt;
  is_serializable_with_encoding&lt;bar&gt;::value &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5690.1">'\n'</span></span><span class="koboSpan" id="kobo.5691.1">;        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5692.1">// true</span></span><span class="koboSpan" id="kobo.5693.1">
std::cout &lt;&lt;
  is_serializable_with_encoding&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5694.1">int</span></span><span class="koboSpan" id="kobo.5695.1">&gt;::value &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5696.1">'\n'</span></span><span class="koboSpan" id="kobo.5697.1">;        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5698.1">// false</span></span><span class="koboSpan" id="kobo.5699.1">
std::cout &lt;&lt;
  is_serializable_with_encoding&lt;std::string&gt;::value &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5700.1">'\n'</span></span><span class="koboSpan" id="kobo.5701.1">;</span><span class="hljs-comment"><span class="koboSpan" id="kobo.5702.1">// false</span></span><span class="koboSpan" id="kobo.5703.1">
std::cout &lt;&lt; std::boolalpha;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5704.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5705.1">serialize()</span></code><span class="koboSpan" id="kobo.5706.1"> method is a function template that represents a common API for serializing objects that support either type of serialization. </span><span class="koboSpan" id="kobo.5706.2">It takes a single argument of the type template parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.5707.1">T</span></code><span class="koboSpan" id="kobo.5708.1"> and uses a helper class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.5709.1">serializer</span></code><span class="koboSpan" id="kobo.5710.1"> to call either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5711.1">serialize()</span></code><span class="koboSpan" id="kobo.5712.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.5713.1">serialize_with_encoding()</span></code><span class="koboSpan" id="kobo.5714.1"> method of its argument.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5715.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5716.1">serializer</span></code><span class="koboSpan" id="kobo.5717.1"> type is a</span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.5718.1"> class template with a single, non-type template parameter of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.5719.1">bool</span></code><span class="koboSpan" id="kobo.5720.1">. </span><span class="koboSpan" id="kobo.5720.2">This class template contains a static function template called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5721.1">serialize()</span></code><span class="koboSpan" id="kobo.5722.1">. </span><span class="koboSpan" id="kobo.5722.2">This function template takes a single parameter of the type template parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.5723.1">T</span></code><span class="koboSpan" id="kobo.5724.1">, calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.5725.1">serialize()</span></code><span class="koboSpan" id="kobo.5726.1"> on the argument, and returns the value returned from that call. </span><span class="koboSpan" id="kobo.5726.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5727.1">serializer</span></code><span class="koboSpan" id="kobo.5728.1"> class template has a full specialization for the value </span><code class="inlineCode"><span class="koboSpan" id="kobo.5729.1">true</span></code><span class="koboSpan" id="kobo.5730.1"> of its non-type template parameter. </span><span class="koboSpan" id="kobo.5730.2">In this specialization, the function template </span><code class="inlineCode"><span class="koboSpan" id="kobo.5731.1">serialize()</span></code><span class="koboSpan" id="kobo.5732.1"> has an unchanged signature, but calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.5733.1">serialize_with_encoding()</span></code><span class="koboSpan" id="kobo.5734.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5735.1">serialize()</span></code><span class="koboSpan" id="kobo.5736.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5737.1">The selection between using the generic or the fully specialized class template is done in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5738.1">serialize()</span></code><span class="koboSpan" id="kobo.5739.1"> function template using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5740.1">is_serializable_with_encoding</span></code><span class="koboSpan" id="kobo.5741.1"> type trait. </span><span class="koboSpan" id="kobo.5741.2">The static member </span><code class="inlineCode"><span class="koboSpan" id="kobo.5742.1">value</span></code><span class="koboSpan" id="kobo.5743.1"> of the type trait is used as the argument for the non-type template parameter of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5744.1">serializer</span></code><span class="koboSpan" id="kobo.5745.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5746.1">With all that defined, we can write the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5747.1">foo f;
bar b;
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5748.1">serialize</span></span><span class="koboSpan" id="kobo.5749.1">(f) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5750.1">'\n'</span></span><span class="koboSpan" id="kobo.5751.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5752.1">// plain</span></span><span class="koboSpan" id="kobo.5753.1">
std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5754.1">serialize</span></span><span class="koboSpan" id="kobo.5755.1">(b) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5756.1">'\n'</span></span><span class="koboSpan" id="kobo.5757.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5758.1">// encoded</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5759.1">In this snippet, calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.5760.1">serialize()</span></code><span class="koboSpan" id="kobo.5761.1"> with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5762.1">foo</span></code><span class="koboSpan" id="kobo.5763.1"> argument will return the string </span><em class="italic"><span class="koboSpan" id="kobo.5764.1">plain</span></em><span class="koboSpan" id="kobo.5765.1">, while calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.5766.1">serialize()</span></code><span class="koboSpan" id="kobo.5767.1"> with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5768.1">bar</span></code><span class="koboSpan" id="kobo.5769.1"> argument will return the string </span><em class="italic"><span class="koboSpan" id="kobo.5770.1">encoded</span></em><span class="koboSpan" id="kobo.5771.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-412"><span class="koboSpan" id="kobo.5772.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5773.1">Using type traits to query properties of types</span></em><span class="koboSpan" id="kobo.5774.1">, to explore a C++ meta-programming technique that allows us to inspect and transform properties of types</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5775.1">Using std::conditional to choose between types</span></em><span class="koboSpan" id="kobo.5776.1">, to understand how to perform a compile-time selection of types on a compile-time Boolean expression</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-413"><span class="koboSpan" id="kobo.5777.1">Using std::conditional to choose between types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5778.1">In the </span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.5779.1">previous recipes, we looked at some of the features from the type support library, and type traits in particular. </span><span class="koboSpan" id="kobo.5779.2">Related topics have been discussed in other parts of this book, such as using </span><code class="inlineCode"><span class="koboSpan" id="kobo.5780.1">std::enable_if</span></code><span class="koboSpan" id="kobo.5781.1"> to hide function overloads in </span><em class="chapterRef"><span class="koboSpan" id="kobo.5782.1">Chapter 4</span></em><span class="koboSpan" id="kobo.5783.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5784.1">Preprocessing and Compilation</span></em><span class="koboSpan" id="kobo.5785.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5786.1">std::decay</span></code><span class="koboSpan" id="kobo.5787.1"> to remove </span><code class="inlineCode"><span class="koboSpan" id="kobo.5788.1">const</span></code><span class="koboSpan" id="kobo.5789.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5790.1">volatile</span></code><span class="koboSpan" id="kobo.5791.1"> qualifiers when we discussed visiting variants, also in this chapter. </span><span class="koboSpan" id="kobo.5791.2">Another type transformation feature worth discussing to a larger extent is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5792.1">std::conditional</span></code><span class="koboSpan" id="kobo.5793.1">, which enables us to choose between two types at compile time, based on a compile-time Boolean expression. </span><span class="koboSpan" id="kobo.5793.2">In this recipe, you will learn how it works and how to use it through several examples.</span></p>
<h2 class="heading-2" id="_idParaDest-414"><span class="koboSpan" id="kobo.5794.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5795.1">It is recommended that you first read the </span><em class="italic"><span class="koboSpan" id="kobo.5796.1">Using type traits to query properties of types</span></em><span class="koboSpan" id="kobo.5797.1"> recipe, earlier in this chapter.</span></p>
<h2 class="heading-2" id="_idParaDest-415"><span class="koboSpan" id="kobo.5798.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5799.1">The following is a list of examples that show you how to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.5800.1">std::conditional</span></code><span class="koboSpan" id="kobo.5801.1"> (and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5802.1">std::conditional_t</span></code><span class="koboSpan" id="kobo.5803.1">), available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5804.1">&lt;type_traits&gt;</span></code><span class="koboSpan" id="kobo.5805.1"> header, to choose between two types at compile time:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5806.1">In a type alias or typedef to select between a 32-bit and 64-bit integer type, based on the platform (the pointer size is 4 bytes on 32-bit platforms and 8 bytes on 64-bit platforms):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5807.1">using</span></span><span class="koboSpan" id="kobo.5808.1"> long_type = std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5809.1">conditional_t</span></span><span class="koboSpan" id="kobo.5810.1">&lt;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5811.1">sizeof</span></span><span class="koboSpan" id="kobo.5812.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.5813.1">void</span></span><span class="koboSpan" id="kobo.5814.1">*) &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.5815.1">4</span></span><span class="koboSpan" id="kobo.5816.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.5817.1">long</span></span><span class="koboSpan" id="kobo.5818.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.5819.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5820.1">long</span></span><span class="koboSpan" id="kobo.5821.1">&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5822.1">auto</span></span><span class="koboSpan" id="kobo.5823.1"> n = long_type{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.5824.1">42</span></span><span class="koboSpan" id="kobo.5825.1"> };
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5826.1">In an alias template to select between an 8-, 16-, 32-, or 64-bit integer type, based on the user specification (as a non-type template parameter):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5827.1">template</span></span><span class="koboSpan" id="kobo.5828.1"> &lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5829.1">int</span></span><span class="koboSpan" id="kobo.5830.1"> size&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5831.1">using</span></span><span class="koboSpan" id="kobo.5832.1"> number_type =
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5833.1">typename</span></span><span class="koboSpan" id="kobo.5834.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5835.1">conditional_t</span></span><span class="koboSpan" id="kobo.5836.1">&lt;
    size&lt;=</span><span class="hljs-number"><span class="koboSpan" id="kobo.5837.1">1</span></span><span class="koboSpan" id="kobo.5838.1">,
    std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5839.1">int8_t</span></span><span class="koboSpan" id="kobo.5840.1">,
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5841.1">typename</span></span><span class="koboSpan" id="kobo.5842.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5843.1">conditional_t</span></span><span class="koboSpan" id="kobo.5844.1">&lt;
      size&lt;=</span><span class="hljs-number"><span class="koboSpan" id="kobo.5845.1">2</span></span><span class="koboSpan" id="kobo.5846.1">,
      std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5847.1">int16_t</span></span><span class="koboSpan" id="kobo.5848.1">,
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5849.1">typename</span></span><span class="koboSpan" id="kobo.5850.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5851.1">conditional_t</span></span><span class="koboSpan" id="kobo.5852.1">&lt;
        size&lt;=</span><span class="hljs-number"><span class="koboSpan" id="kobo.5853.1">4</span></span><span class="koboSpan" id="kobo.5854.1">,
        std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5855.1">int32_t</span></span><span class="koboSpan" id="kobo.5856.1">,
        std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5857.1">int64_t</span></span><span class="koboSpan" id="kobo.5858.1">
      &gt;
    &gt;
  &gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5859.1">auto</span></span><span class="koboSpan" id="kobo.5860.1"> n = number_type&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.5861.1">2</span></span><span class="koboSpan" id="kobo.5862.1">&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.5863.1">42</span></span><span class="koboSpan" id="kobo.5864.1"> };
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5865.1">static_assert</span></span><span class="koboSpan" id="kobo.5866.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5867.1">sizeof</span></span><span class="koboSpan" id="kobo.5868.1">(number_type&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.5869.1">1</span></span><span class="koboSpan" id="kobo.5870.1">&gt;) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.5871.1">1</span></span><span class="koboSpan" id="kobo.5872.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5873.1">static_assert</span></span><span class="koboSpan" id="kobo.5874.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5875.1">sizeof</span></span><span class="koboSpan" id="kobo.5876.1">(number_type&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.5877.1">2</span></span><span class="koboSpan" id="kobo.5878.1">&gt;) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.5879.1">2</span></span><span class="koboSpan" id="kobo.5880.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5881.1">static_assert</span></span><span class="koboSpan" id="kobo.5882.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5883.1">sizeof</span></span><span class="koboSpan" id="kobo.5884.1">(number_type&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.5885.1">3</span></span><span class="koboSpan" id="kobo.5886.1">&gt;) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.5887.1">4</span></span><span class="koboSpan" id="kobo.5888.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5889.1">static_assert</span></span><span class="koboSpan" id="kobo.5890.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5891.1">sizeof</span></span><span class="koboSpan" id="kobo.5892.1">(number_type&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.5893.1">4</span></span><span class="koboSpan" id="kobo.5894.1">&gt;) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.5895.1">4</span></span><span class="koboSpan" id="kobo.5896.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5897.1">static_assert</span></span><span class="koboSpan" id="kobo.5898.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5899.1">sizeof</span></span><span class="koboSpan" id="kobo.5900.1">(number_type&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.5901.1">5</span></span><span class="koboSpan" id="kobo.5902.1">&gt;) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.5903.1">8</span></span><span class="koboSpan" id="kobo.5904.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5905.1">static_assert</span></span><span class="koboSpan" id="kobo.5906.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5907.1">sizeof</span></span><span class="koboSpan" id="kobo.5908.1">(number_type&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.5909.1">6</span></span><span class="koboSpan" id="kobo.5910.1">&gt;) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.5911.1">8</span></span><span class="koboSpan" id="kobo.5912.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5913.1">static_assert</span></span><span class="koboSpan" id="kobo.5914.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5915.1">sizeof</span></span><span class="koboSpan" id="kobo.5916.1">(number_type&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.5917.1">7</span></span><span class="koboSpan" id="kobo.5918.1">&gt;) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.5919.1">8</span></span><span class="koboSpan" id="kobo.5920.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5921.1">static_assert</span></span><span class="koboSpan" id="kobo.5922.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5923.1">sizeof</span></span><span class="koboSpan" id="kobo.5924.1">(number_type&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.5925.1">8</span></span><span class="koboSpan" id="kobo.5926.1">&gt;) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.5927.1">8</span></span><span class="koboSpan" id="kobo.5928.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5929.1">static_assert</span></span><span class="koboSpan" id="kobo.5930.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5931.1">sizeof</span></span><span class="koboSpan" id="kobo.5932.1">(number_type&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.5933.1">9</span></span><span class="koboSpan" id="kobo.5934.1">&gt;) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.5935.1">8</span></span><span class="koboSpan" id="kobo.5936.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5937.1">In a type</span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.5938.1"> template parameter to select between an integer and real uniform distribution, depending on whether the type template parameter is of an integral or floating-point type:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5939.1">template</span></span><span class="koboSpan" id="kobo.5940.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5941.1">typename</span></span><span class="koboSpan" id="kobo.5942.1"> T,
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5943.1">typename</span></span><span class="koboSpan" id="kobo.5944.1"> D = std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5945.1">conditional_t</span></span><span class="koboSpan" id="kobo.5946.1">&lt;
                         std::is_integral_v&lt;T&gt;,
                         std::uniform_int_distribution&lt;T&gt;,
                         std::uniform_real_distribution&lt;T&gt;&gt;,
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5947.1">typename</span></span><span class="koboSpan" id="kobo.5948.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5949.1">typename</span></span><span class="koboSpan" id="kobo.5950.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.5951.1">enable_if_t</span></span><span class="koboSpan" id="kobo.5952.1">&lt;
                         std::is_arithmetic_v&lt;T&gt;&gt;&gt;
std::vector&lt;T&gt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5953.1">GenerateRandom</span></span><span class="koboSpan" id="kobo.5954.1">(T </span><span class="hljs-type"><span class="koboSpan" id="kobo.5955.1">const</span></span><span class="koboSpan" id="kobo.5956.1"> min, T </span><span class="hljs-type"><span class="koboSpan" id="kobo.5957.1">const</span></span><span class="koboSpan" id="kobo.5958.1"> max,
                              </span><span class="hljs-type"><span class="koboSpan" id="kobo.5959.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5960.1">const</span></span><span class="koboSpan" id="kobo.5961.1"> size)
{
  std::vector&lt;T&gt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5962.1">v</span></span><span class="koboSpan" id="kobo.5963.1">(size);
  std::random_device rd{};
  std::mt19937 mt{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5964.1">rd</span></span><span class="koboSpan" id="kobo.5965.1">() };
  D dist{ min, max };
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5966.1">generate</span></span><span class="koboSpan" id="kobo.5967.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5968.1">begin</span></span><span class="koboSpan" id="kobo.5969.1">(v), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5970.1">end</span></span><span class="koboSpan" id="kobo.5971.1">(v),
    [&amp;dist, &amp;mt] {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5972.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.5973.1">dist</span></span><span class="koboSpan" id="kobo.5974.1">(mt); });
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5975.1">return</span></span><span class="koboSpan" id="kobo.5976.1"> v;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5977.1">auto</span></span><span class="koboSpan" id="kobo.5978.1"> v1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5979.1">GenerateRandom</span></span><span class="koboSpan" id="kobo.5980.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5981.1">1</span></span><span class="koboSpan" id="kobo.5982.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5983.1">10</span></span><span class="koboSpan" id="kobo.5984.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5985.1">10</span></span><span class="koboSpan" id="kobo.5986.1">);     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5987.1">// integers</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.5988.1">auto</span></span><span class="koboSpan" id="kobo.5989.1"> v2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5990.1">GenerateRandom</span></span><span class="koboSpan" id="kobo.5991.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5992.1">1.0</span></span><span class="koboSpan" id="kobo.5993.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5994.1">10.0</span></span><span class="koboSpan" id="kobo.5995.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5996.1">10</span></span><span class="koboSpan" id="kobo.5997.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5998.1">// doubles</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-416"><span class="koboSpan" id="kobo.5999.1">How it works...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.6000.1">std::conditional</span></code><span class="koboSpan" id="kobo.6001.1"> is a class template that defines a member called </span><code class="inlineCode"><span class="koboSpan" id="kobo.6002.1">type</span></code><span class="koboSpan" id="kobo.6003.1"> as either one or the other</span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.6004.1"> of its two type template parameters. </span><span class="koboSpan" id="kobo.6004.2">This selection is done based on a compile-time constant Boolean expression provided as an argument for a non-type template parameter. </span><span class="koboSpan" id="kobo.6004.3">Its implementation looks like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6005.1">template</span></span><span class="koboSpan" id="kobo.6006.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.6007.1">bool</span></span><span class="koboSpan" id="kobo.6008.1"> Test, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6009.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6010.1">T1</span></span><span class="koboSpan" id="kobo.6011.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6012.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6013.1">T2</span></span><span class="koboSpan" id="kobo.6014.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6015.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6016.1">conditional</span></span><span class="koboSpan" id="kobo.6017.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6018.1">typedef</span></span><span class="koboSpan" id="kobo.6019.1"> T2 type;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6020.1">template</span></span><span class="koboSpan" id="kobo.6021.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6022.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6023.1">T1</span></span><span class="koboSpan" id="kobo.6024.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6025.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6026.1">T2</span></span><span class="koboSpan" id="kobo.6027.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6028.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6029.1">conditional</span></span><span class="koboSpan" id="kobo.6030.1">&lt;</span><span class="hljs-literal"><span class="koboSpan" id="kobo.6031.1">true</span></span><span class="koboSpan" id="kobo.6032.1">, T1, T2&gt;
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6033.1">typedef</span></span><span class="koboSpan" id="kobo.6034.1"> T1 type;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6035.1">Let’s summarize the examples from the previous section:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6036.1">In the first example, if the platform is 32-bit, then the size of the pointer type is 4 bytes and, therefore, the compile-time expression </span><code class="inlineCode"><span class="koboSpan" id="kobo.6037.1">sizeof(void*) &lt;= 4</span></code><span class="koboSpan" id="kobo.6038.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.6039.1">true</span></code><span class="koboSpan" id="kobo.6040.1">; as a result, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6041.1">std::conditional</span></code><span class="koboSpan" id="kobo.6042.1"> defines its member type as </span><code class="inlineCode"><span class="koboSpan" id="kobo.6043.1">long</span></code><span class="koboSpan" id="kobo.6044.1">. </span><span class="koboSpan" id="kobo.6044.2">If the platform is 64-bit, then the condition evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.6045.1">false</span></code><span class="koboSpan" id="kobo.6046.1"> because the size of the pointer type is 8 bytes; therefore, the member type is defined as </span><code class="inlineCode"><span class="koboSpan" id="kobo.6047.1">long long</span></code><span class="koboSpan" id="kobo.6048.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6049.1">A similar situation is encountered in the second example, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.6050.1">std::conditional</span></code><span class="koboSpan" id="kobo.6051.1"> is used multiple times to emulate a series of </span><code class="inlineCode"><span class="koboSpan" id="kobo.6052.1">if...else</span></code><span class="koboSpan" id="kobo.6053.1"> statements to select an appropriate type.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6054.1">In the third example, we used the alias template </span><code class="inlineCode"><span class="koboSpan" id="kobo.6055.1">std::conditional_t</span></code><span class="koboSpan" id="kobo.6056.1"> to simplify the declaration of the function template </span><code class="inlineCode"><span class="koboSpan" id="kobo.6057.1">GenerateRandom</span></code><span class="koboSpan" id="kobo.6058.1">. </span><span class="koboSpan" id="kobo.6058.2">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6059.1">std::conditional</span></code><span class="koboSpan" id="kobo.6060.1"> is used to define the default value for a type template parameter representing a statistical distribution. </span><span class="koboSpan" id="kobo.6060.2">Depending on whether the first type template parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.6061.1">T</span></code><span class="koboSpan" id="kobo.6062.1"> is an integral or floating-point type, the default distribution type is chosen between </span><code class="inlineCode"><span class="koboSpan" id="kobo.6063.1">std::uniform_int_distribution&lt;T&gt;</span></code><span class="koboSpan" id="kobo.6064.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6065.1">std::uniform_real_distribution&lt;T&gt;</span></code><span class="koboSpan" id="kobo.6066.1">. </span><span class="koboSpan" id="kobo.6066.2">The use of other types is disabled by employing </span><code class="inlineCode"><span class="koboSpan" id="kobo.6067.1">std::enable_if</span></code><span class="koboSpan" id="kobo.6068.1"> with a third template parameter, as we have seen in other recipes already.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6069.1">To help </span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.6070.1">simplify the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.6071.1">std::conditional</span></code><span class="koboSpan" id="kobo.6072.1">, C++14 provides an alias template called </span><code class="inlineCode"><span class="koboSpan" id="kobo.6073.1">std::conditional_t</span></code><span class="koboSpan" id="kobo.6074.1">, which we have seen in the examples here, and which is defined as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6075.1">template</span></span><span class="koboSpan" id="kobo.6076.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.6077.1">bool</span></span><span class="koboSpan" id="kobo.6078.1"> Test, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6079.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6080.1">T1</span></span><span class="koboSpan" id="kobo.6081.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6082.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.6083.1">T2</span></span><span class="koboSpan" id="kobo.6084.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6085.1">using</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.6086.1">conditional_t</span></span><span class="koboSpan" id="kobo.6087.1"> = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6088.1">typename</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.6089.1">conditional_t</span></span><span class="koboSpan" id="kobo.6090.1">&lt;Test,T1,T2&gt;;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6091.1">The use of this helper class (and the many others that are similar and from the standard library) is optional but helps with writing more concise code.</span></p>
<h2 class="heading-2" id="_idParaDest-417"><span class="koboSpan" id="kobo.6092.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.6093.1">Using type traits to query properties of types</span></em><span class="koboSpan" id="kobo.6094.1">, to explore a C++ metaprogramming technique that allows us to inspect and transform properties of types</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.6095.1">Writing your own type traits</span></em><span class="koboSpan" id="kobo.6096.1">, to learn how to define your own type traits</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.6097.1">Chapter 4</span></em><span class="koboSpan" id="kobo.6098.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6099.1">Conditionally compiling classes and functions with enable_if</span></em><span class="koboSpan" id="kobo.6100.1">, to learn about SFINAE and how to use it to specify type constraints for templates</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-418"><span class="koboSpan" id="kobo.6101.1">Providing logging details with source_location</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.6102.1">Debugging is an </span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.6103.1">essential part of software development. </span><span class="koboSpan" id="kobo.6103.2">No matter how simple or complex it is, no program works as intended from the first shot. </span><span class="koboSpan" id="kobo.6103.3">Therefore, developers spend a considerable amount of time debugging their code, employing various tools and techniques from debuggers to messages</span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.6104.1"> printed to a console or a text file. </span><span class="koboSpan" id="kobo.6104.2">Sometimes, we want to provide detailed information about the source of a message in a log, including the file, the line, and maybe the function name. </span><span class="koboSpan" id="kobo.6104.3">Although this was possible with some standard macros, in C++20, a new utility type called </span><code class="inlineCode"><span class="koboSpan" id="kobo.6105.1">std::source_location</span></code><span class="koboSpan" id="kobo.6106.1"> allows us to do it in a modern way. </span><span class="koboSpan" id="kobo.6106.2">In this recipe, we will learn how.</span></p>
<h2 class="heading-2" id="_idParaDest-419"><span class="koboSpan" id="kobo.6107.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.6108.1">To log information including the file name, line number, and function name, do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6109.1">Define a logging function with parameters for all information that you need to provide (such as message, severity, etc.).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6110.1">Add one additional parameter of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.6111.1">std::source_location</span></code><span class="koboSpan" id="kobo.6112.1"> (for which you have to include the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6113.1">&lt;source_location&gt;</span></code><span class="koboSpan" id="kobo.6114.1"> header) with the default value </span><code class="inlineCode"><span class="koboSpan" id="kobo.6115.1">std::source_location::current()</span></code><span class="koboSpan" id="kobo.6116.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6117.1">Use member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.6118.1">file_name()</span></code><span class="koboSpan" id="kobo.6119.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6120.1">line()</span></code><span class="koboSpan" id="kobo.6121.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6122.1">column()</span></code><span class="koboSpan" id="kobo.6123.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6124.1">function_name()</span></code><span class="koboSpan" id="kobo.6125.1"> to retrieve information about the source of the invocation.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6126.1">An example of such a logging function is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.6127.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6128.1">log</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6129.1">(std::string_view message, </span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.6130.1">         std::source_location </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6131.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6132.1"> location = std::source_location::current())</span></span><span class="koboSpan" id="kobo.6133.1">
{
   std::cout   &lt;&lt; location.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6134.1">file_name</span></span><span class="koboSpan" id="kobo.6135.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6136.1">'('</span></span><span class="koboSpan" id="kobo.6137.1">
               &lt;&lt; location.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6138.1">line</span></span><span class="koboSpan" id="kobo.6139.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6140.1">':'</span></span><span class="koboSpan" id="kobo.6141.1">
               &lt;&lt; location.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6142.1">column</span></span><span class="koboSpan" id="kobo.6143.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6144.1">") '"</span></span><span class="koboSpan" id="kobo.6145.1">
               &lt;&lt; location.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6146.1">function_name</span></span><span class="koboSpan" id="kobo.6147.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6148.1">"': "</span></span><span class="koboSpan" id="kobo.6149.1">
               &lt;&lt; message &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6150.1">'\n'</span></span><span class="koboSpan" id="kobo.6151.1">;
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-420"><span class="koboSpan" id="kobo.6152.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.6153.1">Before C++20, logging information </span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.6154.1">such as source file, line, and function name was only possible with the help of several macros:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6155.1">__FILE__</span></code><span class="koboSpan" id="kobo.6156.1">, which expands to the name of the current file</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6157.1">__LINE__</span></code><span class="koboSpan" id="kobo.6158.1">, which expands to the source file line number</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6159.1">In</span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.6160.1"> addition, all compilers supported non-standard macros including </span><code class="inlineCode"><span class="koboSpan" id="kobo.6161.1">__func__</span></code><span class="koboSpan" id="kobo.6162.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.6163.1">__FUNCTION__</span></code><span class="koboSpan" id="kobo.6164.1">, which provide the name of the current function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6165.1">Using these macros, one could write the following logging function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.6166.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6167.1">log</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6168.1">(std::string_view message, </span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.6169.1">         std::string_view file, </span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.6170.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6171.1"> line, </span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.6172.1">         std::string_view function)</span></span><span class="koboSpan" id="kobo.6173.1">
{
   std::cout &lt;&lt; file &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6174.1">'('</span></span><span class="koboSpan" id="kobo.6175.1">
             &lt;&lt; line &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6176.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.6177.1">) '"</span></span><span class="koboSpan" id="kobo.6178.1">
             &lt;&lt; function &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6179.1">"': "</span></span><span class="koboSpan" id="kobo.6180.1">
             &lt;&lt; message &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6181.1">'\n'</span></span><span class="koboSpan" id="kobo.6182.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6183.1">The macros, however, must be used from the context of the function execution, as shown in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.6184.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6185.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6186.1">()</span></span><span class="koboSpan" id="kobo.6187.1">
{
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6188.1">log</span></span><span class="koboSpan" id="kobo.6189.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6190.1">"This is a log entry!"</span></span><span class="koboSpan" id="kobo.6191.1">, __FILE__, __LINE__, __FUNCTION__);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6192.1">The result of running this function would look as follows on the console:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.6193.1">[...]\source.cpp(23) 'main': This is a log entry!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6194.1">The C++20 </span><code class="inlineCode"><span class="koboSpan" id="kobo.6195.1">std::source_line</span></code><span class="koboSpan" id="kobo.6196.1"> is a better alternative for several reasons:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6197.1">You no longer have to rely on macros.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6198.1">It includes information about the column, not just the line.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6199.1">It can be used in the logging function signature, simplifying the invocation of the call.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6200.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.6201.1">log()</span></code><span class="koboSpan" id="kobo.6202.1"> function defined in the </span><em class="italic"><span class="koboSpan" id="kobo.6203.1">How to do it…</span></em><span class="koboSpan" id="kobo.6204.1"> section can be invoked as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.6205.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6206.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6207.1">()</span></span><span class="koboSpan" id="kobo.6208.1">
{
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6209.1">log</span></span><span class="koboSpan" id="kobo.6210.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6211.1">"This is a log entry!"</span></span><span class="koboSpan" id="kobo.6212.1">);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6213.1">This results in the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.6214.1">[...]\source.cpp(23:4) 'int __cdecl main(void)': This is a log entry!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6215.1">Although</span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.6216.1"> a default constructor exists, it initializes the data with default values. </span><span class="koboSpan" id="kobo.6216.2">To get the correct values, you must invoke </span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.6217.1">the static member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.6218.1">current()</span></code><span class="koboSpan" id="kobo.6219.1">. </span><span class="koboSpan" id="kobo.6219.2">This function works as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6220.1">When invoked directly in a function call, it initializes the data with information about the location of the call.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6221.1">When used in a default member initializer, it initializes the data with information about the location of the constructor aggregate initialization that initializes the data member.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6222.1">When used in a default argument (such as in the example shown here), it initializes the data with the location of the call site (function invocation).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6223.1">When used in another context, the behavior is undefined.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6224.1">It must be noted that the preprocessor directive </span><code class="inlineCode"><span class="koboSpan" id="kobo.6225.1">#line</span></code><span class="koboSpan" id="kobo.6226.1"> changes the source code line number and the file name. </span><span class="koboSpan" id="kobo.6226.2">This affects the value returned by the macros </span><code class="inlineCode"><span class="koboSpan" id="kobo.6227.1">__FILE__</span></code><span class="koboSpan" id="kobo.6228.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6229.1">__LINE__</span></code><span class="koboSpan" id="kobo.6230.1">. </span><span class="koboSpan" id="kobo.6230.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.6231.1">std::source_location</span></code><span class="koboSpan" id="kobo.6232.1"> is affected in the same manner as the standard macros by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6233.1">#line</span></code><span class="koboSpan" id="kobo.6234.1"> directive.</span></p>
<h2 class="heading-2" id="_idParaDest-421"><span class="koboSpan" id="kobo.6235.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.6236.1">Using the stacktrace library to print the call stack</span></em><span class="koboSpan" id="kobo.6237.1">, to learn how to walk or print the content of the current stack trace</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-422"><span class="koboSpan" id="kobo.6238.1">Using the stacktrace library to print the call sequence</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.6239.1">In the </span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.6240.1">previous recipe, we saw how to </span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.6241.1">use the C++20 </span><code class="inlineCode"><span class="koboSpan" id="kobo.6242.1">std::source_location</span></code><span class="koboSpan" id="kobo.6243.1"> to provide information about a source location for logging, testing, and debugging purposes. </span><span class="koboSpan" id="kobo.6243.2">Another mechanism for debugging is represented by asserts but these are not always enough because we often need to know the sequence of calls that led to a point of execution. </span><span class="koboSpan" id="kobo.6243.3">This is called the stack trace. </span><span class="koboSpan" id="kobo.6243.4">The C++23 standard contains a new library with diagnostics utilities. </span><span class="koboSpan" id="kobo.6243.5">This allows us to print the stack trace. </span><span class="koboSpan" id="kobo.6243.6">In this recipe, you will learn how to use these diagnostics utilities.</span></p>
<h2 class="heading-2" id="_idParaDest-423"><span class="koboSpan" id="kobo.6244.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.6245.1">You</span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.6246.1"> can use the C++23 stacktrace library to:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6247.1">Print the</span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.6248.1"> entire content of the stack trace:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.6249.1">std::cout &lt;&lt; std::stacktrace::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6250.1">current</span></span><span class="koboSpan" id="kobo.6251.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6252.1">'\n'</span></span><span class="koboSpan" id="kobo.6253.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.6254.1">Iterate over each frame in the stack trace and print it:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6255.1">for</span></span><span class="koboSpan" id="kobo.6256.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6257.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.6258.1">const</span></span><span class="koboSpan" id="kobo.6259.1"> &amp; frame : std::stacktrace::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6260.1">current</span></span><span class="koboSpan" id="kobo.6261.1">())
{
   std::cout &lt;&lt; frame &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6262.1">'\n'</span></span><span class="koboSpan" id="kobo.6263.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.6264.1">Iterate over each frame in the stack trace and retrieve information about it:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6265.1">for</span></span><span class="koboSpan" id="kobo.6266.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6267.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.6268.1">const</span></span><span class="koboSpan" id="kobo.6269.1">&amp; frame : std::stacktrace::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6270.1">current</span></span><span class="koboSpan" id="kobo.6271.1">())
{
   std::cout &lt;&lt; frame.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6272.1">source_file</span></span><span class="koboSpan" id="kobo.6273.1">()
             &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6274.1">"("</span></span><span class="koboSpan" id="kobo.6275.1">&lt;&lt; frame.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6276.1">source_line</span></span><span class="koboSpan" id="kobo.6277.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6278.1">")"</span></span><span class="koboSpan" id="kobo.6279.1">
             &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6280.1">": "</span></span><span class="koboSpan" id="kobo.6281.1"> &lt;&lt; frame.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6282.1">description</span></span><span class="koboSpan" id="kobo.6283.1">()
             &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6284.1">'\n'</span></span><span class="koboSpan" id="kobo.6285.1">;
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-424"><span class="koboSpan" id="kobo.6286.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.6287.1">The new diagnostic utilities are available in a separate header called </span><code class="inlineCode"><span class="koboSpan" id="kobo.6288.1">&lt;stacktrace&gt;</span></code><span class="koboSpan" id="kobo.6289.1">. </span><span class="koboSpan" id="kobo.6289.2">This header contains the following two classes:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6290.1">std::basic_stacktrace</span></code><span class="koboSpan" id="kobo.6291.1">, which is a class template that represents a sequence container of stack trace entries. </span><span class="koboSpan" id="kobo.6291.2">A type alias called </span><code class="inlineCode"><span class="koboSpan" id="kobo.6292.1">std::stacktrace</span></code><span class="koboSpan" id="kobo.6293.1"> is defined as </span><code class="inlineCode"><span class="koboSpan" id="kobo.6294.1">std::basic_stacktrace&lt;std::allocator&lt;std::stacktrace_entry&gt;&gt;</span></code><span class="koboSpan" id="kobo.6295.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.6296.1">std::stacktrace_entry</span></code><span class="koboSpan" id="kobo.6297.1">, which represents an evaluation in a stack trace.</span></li>
</ul>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.6298.1">When discussing the call sequence, there are two terms that need to be correctly understood: </span><strong class="keyWord"><span class="koboSpan" id="kobo.6299.1">call stack</span></strong><span class="koboSpan" id="kobo.6300.1"> and </span><strong class="keyWord"><span class="koboSpan" id="kobo.6301.1">stack trace</span></strong><span class="koboSpan" id="kobo.6302.1">. </span><span class="koboSpan" id="kobo.6302.2">A call stack is the data structure used to store information about the active frames (calls) in a running program. </span><span class="koboSpan" id="kobo.6302.3">A stack trace is a snapshot, at some moment in time, of the call stack.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.6303.1">Although </span><code class="inlineCode"><span class="koboSpan" id="kobo.6304.1">std::basic_stacktrace</span></code><span class="koboSpan" id="kobo.6305.1"> is a container, it is not meant to be instantiated and filled </span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.6306.1">with stack entries by the user. </span><span class="koboSpan" id="kobo.6306.2">There are </span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.6307.1">no member functions for adding or removing elements to the stack trace sequence; however, there are member functions for element access (</span><code class="inlineCode"><span class="koboSpan" id="kobo.6308.1">at()</span></code><span class="koboSpan" id="kobo.6309.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6310.1">operator[]</span></code><span class="koboSpan" id="kobo.6311.1">) and checking the size (</span><code class="inlineCode"><span class="koboSpan" id="kobo.6312.1">capacity()</span></code><span class="koboSpan" id="kobo.6313.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6314.1">size()</span></code><span class="koboSpan" id="kobo.6315.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6316.1">max_size()</span></code><span class="koboSpan" id="kobo.6317.1">). </span><span class="koboSpan" id="kobo.6317.2">In order to get a snapshot of the call stack, you must invoke the static member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.6318.1">current()</span></code><span class="koboSpan" id="kobo.6319.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.6320.1">std::stacktrace trace = std::stacktrace::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6321.1">current</span></span><span class="koboSpan" id="kobo.6322.1">();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6323.1">The current trace can be printed in several ways:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6324.1">To an output stream using the overloaded </span><code class="inlineCode"><span class="koboSpan" id="kobo.6325.1">operator&lt;&lt;</span></code><span class="koboSpan" id="kobo.6326.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.6327.1">std::cout &lt;&lt; std::stacktrace::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6328.1">current</span></span><span class="koboSpan" id="kobo.6329.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6330.1">'\n'</span></span><span class="koboSpan" id="kobo.6331.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.6332.1">To a </span><code class="inlineCode"><span class="koboSpan" id="kobo.6333.1">std::string</span></code><span class="koboSpan" id="kobo.6334.1"> using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.6335.1">to_string()</span></code><span class="koboSpan" id="kobo.6336.1"> member function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.6337.1">std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6338.1">to_string</span></span><span class="koboSpan" id="kobo.6339.1">(std::stacktrace::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6340.1">current</span></span><span class="koboSpan" id="kobo.6341.1">()) 
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6342.1">'\n'</span></span><span class="koboSpan" id="kobo.6343.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.6344.1">Using a formatting function such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.6345.1">std::format()</span></code><span class="koboSpan" id="kobo.6346.1">. </span><span class="koboSpan" id="kobo.6346.2">Keep in mind that no formatting specifier is allowed:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.6347.1">auto</span></span><span class="koboSpan" id="kobo.6348.1"> str = std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.6349.1">"{}\n"</span></span><span class="koboSpan" id="kobo.6350.1">, std::stacktrace::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6351.1">current</span></span><span class="koboSpan" id="kobo.6352.1">());
std::cout &lt;&lt; str;
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.6353.1">The following snippet shows an example of how a stack trace can be printed to the standard output:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.6354.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6355.1">plus_one</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6356.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6357.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6358.1"> n)</span></span><span class="koboSpan" id="kobo.6359.1">
{
   std::cout &lt;&lt; std::stacktrace::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6360.1">current</span></span><span class="koboSpan" id="kobo.6361.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6362.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.6363.1">\n'</span></span><span class="koboSpan" id="kobo.6364.1">;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6365.1">return</span></span><span class="koboSpan" id="kobo.6366.1"> n + </span><span class="hljs-number"><span class="koboSpan" id="kobo.6367.1">1</span></span><span class="koboSpan" id="kobo.6368.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.6369.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6370.1">double_n_plus_one</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6371.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.6372.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6373.1"> n)</span></span><span class="koboSpan" id="kobo.6374.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.6375.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.6376.1">plus_one</span></span><span class="koboSpan" id="kobo.6377.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.6378.1">2</span></span><span class="koboSpan" id="kobo.6379.1"> * n);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.6380.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.6381.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.6382.1">()</span></span><span class="koboSpan" id="kobo.6383.1">
{
   std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.6384.1">double_n_plus_one</span></span><span class="koboSpan" id="kobo.6385.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.6386.1">42</span></span><span class="koboSpan" id="kobo.6387.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.6388.1">'\n'</span></span><span class="koboSpan" id="kobo.6389.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6390.1">The result of</span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.6391.1"> running this program would look different based on the compiler and target system, but the following is an example of possible output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.6392.1">0&gt; [...]\main.cpp(24): chapter06!plus_one+0x4F
1&gt; [...]\main.cpp(37): chapter06!double_n_plus_one+0xE
2&gt; [...]\main.cpp(61): chapter06!main+0x5F
3&gt; D:\a\_work\1\s\src\vctools\crt\vcstartup\src\startup\exe_common.inl(78): chapter06!invoke_main+0x33
4&gt; D:\a\_work\1\s\src\vctools\crt\vcstartup\src\startup\exe_common.inl(288): chapter06!__scrt_common_main_seh+0x157
5&gt; D:\a\_work\1\s\src\vctools\crt\vcstartup\src\startup\exe_common.inl(331): chapter06!__scrt_common_main+0xD
6&gt; D:\a\_work\1\s\src\vctools\crt\vcstartup\src\startup\exe_main.cpp(17): chapter06!mainCRTStartup+0x8
7&gt; KERNEL32+0x17D59
8&gt; ntdll!RtlInitializeExceptionChain+0x6B
9&gt; ntdll!RtlClearBits+0xBF
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6393.1">For an </span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.6394.1">entry in the trace, as seen above, we can identify three parts: the source file, the line number, and a description of the evaluation. </span><span class="koboSpan" id="kobo.6394.2">These are highlighted below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.6395.1">[...]\main.cpp(24): chapter06!main+0x5F
-------------- --   -------------------
source         line description
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.6396.1">These parts can be obtained independently, using the member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.6397.1">source_file()</span></code><span class="koboSpan" id="kobo.6398.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.6399.1">source_line()</span></code><span class="koboSpan" id="kobo.6400.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6401.1">description()</span></code><span class="koboSpan" id="kobo.6402.1"> of </span><code class="inlineCode"><span class="koboSpan" id="kobo.6403.1">std::stacktrace_entry</span></code><span class="koboSpan" id="kobo.6404.1">. </span><span class="koboSpan" id="kobo.6404.2">The sequence of stack trace entries from a </span><code class="inlineCode"><span class="koboSpan" id="kobo.6405.1">stacktrace</span></code><span class="koboSpan" id="kobo.6406.1"> container can be iterated using iterators or</span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.6407.1"> accessed </span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.6408.1">with the member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.6409.1">at()</span></code><span class="koboSpan" id="kobo.6410.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6411.1">operator[]</span></code><span class="koboSpan" id="kobo.6412.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-425"><span class="koboSpan" id="kobo.6413.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.6414.1">Providing logging details with source_location</span></em><span class="koboSpan" id="kobo.6415.1">, to learn how to use the C++20 </span><code class="inlineCode"><span class="koboSpan" id="kobo.6416.1">source_location</span></code><span class="koboSpan" id="kobo.6417.1"> class to display information about the source file, line, and function name</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.6418.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.6419.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="Chapter_06.xhtml"><span class="url"><span class="koboSpan" id="kobo.6420.1">https://discord.gg/7xRaTCeEhx</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.6421.1"><img alt="" src="../Images/QR_Code2659294082093549796.png"/></span></p>
</div>
</body></html>