- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Power Management and Energy Saving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Energy efficiency has always been one of the leading factors in the microcontroller
    market. Since the early 2000s, signal-processing 16-bit RISC microcontrollers,
    such as the MSP430, have been designed for extremely low-power usage and are still
    leading the path of ultra-low-power optimization architectures in embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the last few years, more advanced 32-bit RISC microcontrollers, rich in features
    and capable of running real-time operating systems, have scaled down in size and
    power consumption, and set foot in the low-power and ultra-low-power domains.
    Battery-powered systems and devices relying on energy-harvesting techniques are
    becoming more and more common in many industries. Low-power wireless communication
    is now offered by a number of connected platforms, so an increasing number of
    IoT systems include low-power and ultra-low-power characteristics in their design.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the architecture, microcontrollers offer different strategies to
    reduce power consumption while running and implement low-power states that consume
    very little energy when activated.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the energy demand of an embedded system is often a tricky process.
    In fact, all the devices on the board may consume power if not deactivated properly.
    Generating high-frequency clocks is one of the most expensive operations, so the
    CPU and bus clocks should only be enabled when in use.
  prefs: []
  type: TYPE_NORMAL
- en: Researching the ideal strategy to save energy depends on the compromises that
    can be made between performance and energy saving. Microcontrollers designed for
    ultra-low-power applications are capable of slowing down the CPU frequency, and
    even reaching different variations of a hibernation state, where all the clocks
    are stopped and the external peripherals are turned off for maximum power savings.
  prefs: []
  type: TYPE_NORMAL
- en: With the appropriate energy profiling techniques, and by implementing ultra-low-power
    strategies, battery-powered devices can run for several years before needing to
    be replaced. Using alternative power sources, such as solar panels, heat-converting
    devices, or other forms of energy harvesting from the surrounding environment,
    a well-profiled embedded system may run indefinitely as long as the external conditions
    allow it.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced microprocessors running at very high speeds are generally not designed
    to implement effective power consumption optimizations, which is what makes smaller,
    low-power microcontrollers such as the Cortex-M so popular in all those embedded
    systems where a small power footprint is one of the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will highlight a few key practices when approaching the
    design of low-power and ultra-low-power embedded systems. Low-power extensions
    of the Cortex-M microcontroller are demonstrated as examples of real-life implementations
    of low-power optimization on real targets. The chapter is divided into three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: System configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low-power operating modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing low-power embedded applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned about the management of different
    low-power configurations for the microcontroller and peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter are available on GitHub at [https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter8](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter8).
  prefs: []
  type: TYPE_NORMAL
- en: System configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A system that includes power consumption constraints in its specifications must
    be designed to meet the requirements in all its aspects, including hardware, software,
    and mechanical design. The selection of components and peripherals must take into
    account their energy profiles. External peripherals are often the most power-demanding
    components, and thus their power source must be interrupted by the microcontroller
    when they are not being used.
  prefs: []
  type: TYPE_NORMAL
- en: This section will describe the best practices concerning peripheral configuration,
    system clock settings, and voltage control, and their impact on power consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In low-power embedded systems, the hardware design must include the possibility
    to power peripherals on or off using a GPIO pin. This is better done using a line
    that is normally low so that it can be pulled down using passive components when
    the GPIO is not driven by the microcontroller. MOSFETs are often used to control
    the power supplied to external peripherals, using a GPIO signal to control the
    gate voltage.
  prefs: []
  type: TYPE_NORMAL
- en: Even when peripherals are turned off by interrupting their power source line,
    smaller currents may leak through other signals connected to them, such as a serial
    bus or other control signals. The hardware design must be able to detect and identify
    these leakages in early prototyping stages to minimize the energy lost this way.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if the power-saving strategy includes the possibility to put the
    microprocessor into a deep-sleep operation mode, the logic of the input signals
    must be tailored to provide the correct wake-up events to resume normal operation.
    Signals that might not be driven while in sleep mode must maintain a known logic
    value enforced using passive components.
  prefs: []
  type: TYPE_NORMAL
- en: Clock management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internal peripherals and interfaces that are not in use must also stay off.
    If the platform supports it, clock gating is generally the mechanism used to selectively
    control the clock source for each peripheral and interface on the system. Each
    clock line enabled in the system clock gating configuration increases the power
    usage. Furthermore, the higher the scaling factor applied to generate the CPU
    clock from a slow oscillator, the higher the energy required by the PLL. The PLL
    is one of the most power-demanding components of the system, and the power consumed
    by the CPU is also directly proportional to its clock frequency. Many CPUs are
    designed to run with a reduced clock speed, offering a range of possible trade-offs
    between performance and energy saving. Accordingly, the PLL can generally be reconfigured
    at runtime to adapt to different profiles. However, every change to the system
    clock requires a reconfiguration of all the clock dividers for all the timers
    and peripherals currently in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the reference platform, we can reconfigure the CPU frequency at runtime
    to save a significant amount of power whenever the system does not require computing
    performance. To do this, the function in `system.c`, used to set the system clock
    in all the examples so far, has been modified to allow the selection of two different
    running frequencies. In performance mode, the system runs at its maximum frequency
    of 168 MHz. If the `powersave` flag argument is not zero, the clocks are configured
    to run at 48 MHz instead, for a more energy-efficient scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of wait states for the `flash` operation has also been changed here,
    because, according to the documentation of the STM32F407, at 48 MHz, the flash
    only requires three wait states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The procedure for setting the system clock is the usual one. First, the HSI
    is enabled and then selected as the temporary clock source. Afterward, the 8 MHz
    external oscillator is enabled, and it is ready to feed the PLL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters for the clock divisors and multipliers for the chosen mode are
    set in the PLL configuration register, and the PLL is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Changing the CPU and system clocks means that all the peripherals that use the
    clocks must be reconfigured. If a timer is running, or any device using the clocks
    as reference is in use by the application, the pre-scaler register that is used
    for providing the timing reference must be adapted accordingly based on clock
    speed updates.
  prefs: []
  type: TYPE_NORMAL
- en: Running the system at a lower speed offers other benefits, such as the possibility
    to decrease the number of wait states required to access the flash memory and
    enable extra low-power features that are only available when the system is not
    running at full speed.
  prefs: []
  type: TYPE_NORMAL
- en: An embedded platform usually includes low-frequency clock generators, in the
    kHz range, which may be used as sources for time-keeping devices such as watchdogs
    and **real-time clocks** (**RTCs**). External or internal oscillators can be active
    during low-power operating modes and used to implement wake-up strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Voltage control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microcontrollers have a relatively wide range of operating voltages. Supplying
    lower voltages, however, makes it impossible to run the CPU at full speed, and
    flash memory may require additional wait states due to the physical characteristics
    of the hardware. Nevertheless, lower-voltage-tolerant logic can improve the overall
    economy of the system in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: Internal regulators can often be configured to produce a lower voltage for the
    core signals, to reach a compromise between the power consumption and performance
    when the CPU is not running at its maximum frequency.
  prefs: []
  type: TYPE_NORMAL
- en: An important aspect that is often neglected is the power consumed by the Schmitt
    triggers in the digital input logic. When GPIOs are configured as digital input,
    but not forced to a known logic state through external passive components, they
    might be floating around the average value, due to the electromagnetic fields
    in the environment. This causes the input signal to be triggered, resulting in
    a little energy being lost at every change in the logic state.
  prefs: []
  type: TYPE_NORMAL
- en: Low-power operating modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microcontrollers can execute in different power modes, switching from full performance
    to complete hibernation. A proper understanding of the microcontroller’s low-power
    modes is fundamental to designing systems with improved energy profiles. Each
    architecture provides specific power configurations, where the CPU or other buses
    and peripherals are disabled, as well as appropriate mechanisms to be used by
    the system software to enter and exit low-power modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an ARM-based microcontroller, the terminology used for the different low-power
    modes can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal operation mode**: Active components are selected through clock gating,
    and the clock is running at the desired frequency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sleep mode**: The CPU clock is temporarily suspended, but all the peripherals
    keep functioning as in normal mode. As long as the CPU is not executing, there
    is a noticeable, even if marginal, amount of power saved in this mode. Execution
    can be resumed after receiving an interrupt request. This mode is also referred
    to as *wait mode* by some chip manufacturers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop mode**: The CPU clock and the bus clocks are disabled. All the peripherals
    powered by the microcontroller are off. The internal RAM and the CPU registers
    retain the stored values because the main voltage regulator stays on. The power
    consumption drops consistently, but it is still possible to wake up and resume
    the execution through an external interrupt or event. This mode is often also
    less appropriately called deep-sleep mode, although it is, in fact, one of two
    deep-sleep modes available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standby mode**: All the voltage regulators are off, and the content of the
    RAM and register is lost. A small amount of power, in the range of a few microwatts,
    may be required to keep the backup circuitry alive during the standby phase. Wake-up
    is then only possible under a few specific conditions, such as an externally powered
    RTC, or a hardware-predefined wake-up event pin. When the system wakes up from
    standby, the normal boot procedure is followed, and the execution resumes from
    the reset service routine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ARMv7 microcode provides two instructions to enter low-power operating
    modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wait for** **interrupt** (**WFI**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wait for** **event** (**WFE**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These instructions can be invoked at any time while in normal running mode.
    `WFI` will put the system in a low-power mode until the next interrupt request
    is received, while `WFE` is slightly different. Only a few events in the system,
    including the external interrupts, can be configured to generate an event. Normal
    interrupt requests will not put the system back into normal running mode if it
    is in a sleep or stop mode that has been entered using `WFE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The low-power mode that is entered upon invocation depends on the settings
    stored in the `0xE000ED10`. The SCR only provides 3 meaningful 1-bit flag fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SLEEPONEXIT` (bit 1): When enabled, the system will go into low-power mode
    at the end of the execution of the next interrupt handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SLEEPDEEP` (bit 2): Determines which mode is entered upon the invocation of
    `WFI` or `WFE`, or when returning from an interrupt with `SLEEPONEXIT` active.
    If this bit is cleared, sleep mode is selected. When a low-power mode is entered
    with this bit active, the system will be put on stop or standby mode, depending
    on the configuration of the power management registers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SEVONPEND` (bit 4): When this bit is active, any interrupt pending during
    a low-power mode will cause a wake-up event, regardless of whether the sleep mode
    or the stop mode was entered using a `WFI` or a `WFE` instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that bit 0, bit 3, and bits 5-31 are reserved (must be kept at value 0).
  prefs: []
  type: TYPE_NORMAL
- en: Deep-sleep configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To select between stop and standby mode, and to set up certain parameters related
    to the deep-sleep modes, our reference platform provides a power controller, mapped
    in the internal peripherals region, at address `0x40007000`. The controller consists
    of two registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PWR_CR` (control register) at an offset of `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PWR_SCR` (status and control register) at an offset of `4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The relevant parameters that can be configured in these two registers are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PWR_CR` bit 14\. When active, saves extra power in normal running mode, by
    configuring the internal regulator to produce a slightly lower voltage for the
    CPU core logic. This feature is only available if the target is not running at
    maximum frequency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PWR_CR` bit 9\. If active while going into one of the deep-sleep modes, the
    flash will be turned off completely while the system is sleeping. This results
    in a moderate amount of power saved but also impacts the wake-up time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PWR_CR`, bit 1\. This bit determines which mode is entered when the CPU goes
    into a deep sleep. If cleared, stop mode is selected. If set, the system enters
    standby.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PWR_CR` bit 0\. This bit only has an effect in stop mode. If enabled, it slightly
    reduces the energy used while in deep sleep by enabling the *under-drive* mode
    in the internal voltage regulator. The current is supplied to the core logic in
    a reduced leakage mode, which still allows you to preserve the content of memory
    and registers. This feature is only available if the system is not running at
    full speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PWR_CSR` bit 4\. This flag determines whether the wake-up pin can be used
    as a normal GPIO, or whether it is reserved to detect a wake-up signal during
    standby. The pin associated with this function in the reference platform is PA0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `PWR_CSR` bit 0\. Writing `1` into `PWR_CR` bit 2 `CWUF`).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the STM32F407 microcontroller, we can access the registers related to the
    low-power modes and configuration using the following macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For the activation of the low-power modes, and the generation of spontaneous
    events, we define macros containing single inline assembly instructions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If sleep mode is entered through `WFI`, the system suspends the execution until
    the next interrupt. Entering sleep mode with `WFE` instead ensures that only selected
    *events* can wake up the system again. Events of different types that occur on
    the system can be enabled to wake up the `WFE`.
  prefs: []
  type: TYPE_NORMAL
- en: When `WFE` is entered, all interrupts active in the NVIC will still count as
    events, thereby waking up the `WFE` call. Interrupts can be temporarily filtered
    out by disabling the corresponding IRQ line in the NVIC. If an interrupt is filtered
    this way, using NVIC, it remains in a pending state and it is handled as soon
    as the system goes back to normal running mode.
  prefs: []
  type: TYPE_NORMAL
- en: Stop mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sleep mode is entered by default every time that the `WFI` or `WFE` instructions
    are invoked, as long as `SCB_SCR_SLEEPDEEP` remains off. Other low-power modes
    can be enabled by enabling the `SLEEPDEEP` flag. To enter one of the available
    deep-sleep modes, the `SCB_SCR` and the POW registers must be configured before
    calling `WFI` or `WFE`. Depending on the configuration, the system enters one
    of the two deep-sleep modes, stop or standby.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a continuous 1 Hz timer toggles the LED 10 times
    before switching to deep-sleep mode, using `WFE`. The `main` loop stays in sleep
    mode in between timer interrupts, using `WFI`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The interrupt service routine for the timer increases the `tim2_ticks` counter
    by `1` and sets the `timer_elapsed` flag, which will make the `main` loop toggle
    the LED and consume the event generated by the timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `enter_lowpower_mode` procedure is responsible for setting the values in
    the system control block and in the power control registers, depending on the
    desired low-power mode, and configuring all the optimizations accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enter_lowpower_mode` procedure performs the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: It turns off the LED.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It sets the values in `SCB_SCR` and the power register to configure the low-power
    mode that will be entered upon `WFE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It selects the single extra power optimizations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, stop mode is configured to reduce power consumption as much as
    possible, by activating the low-power voltage regulator settings (through `POW_CR_LPDS`)
    and by turning off the flash (through `POW_CR_FPDS`).
  prefs: []
  type: TYPE_NORMAL
- en: Low-power mode is now entered through a `WFE()` call. To be able to wake up
    the system, we configure an `EXTI` event, which is associated with the user pressing
    a button on the board. To do so, we configure `EXTI0` to be sensitive to raised
    edges, as the PA0 pin changes its logical value from `0` to `1` upon being pressed.
  prefs: []
  type: TYPE_NORMAL
- en: As we are not particularly interested in the interrupt itself, we ensure that
    the flag to generate an interrupt request is turned off in `EXTI`. The event controller
    will ensure that an event is generated instead because the flag relative to the
    input pin is enforced in the `EXTI_EMR` register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial configuration for the user button event looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: No interrupts are configured for the button, as the event alone is sufficient
    to wake up the board during stop mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon entering stop mode, the PLL will be disabled, and the HSI will be automatically
    selected as the clock source when the system is back in normal running mode. To
    restore the clock configuration, there are a few steps to implement as soon as
    stop mode is exited:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SCB_SCR_SLEEPDEEP` flag is cleared so that the next invocation of `WFI` or
    `WFE` does not trigger another switch to stop mode.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `POW_CR` register is accessed to clear the wake-up flag set by the hardware
    at the end of the stop mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The PLL is configured again, as the clock is restored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The LED is turned on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `TIM2` interrupt is enabled again for the timer to restore its functionality
    in normal running mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Deep-sleep mode reduces the power consumption consistently, and it is the ideal
    situation whenever the system must maintain the current running status but can
    be frozen for a longer period.
  prefs: []
  type: TYPE_NORMAL
- en: Standby mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In standby mode, the system can go into ultra-low-power mode, consuming only
    a few microamperes, while waiting to be reinitialized by an external event. Entering
    standby mode requires you to set the `SCB_SCR_PDDS` flag prior to invoking `WFI`
    or `WFE`. While the system is on standby, all the voltage regulators are off,
    except for the low-speed oscillators, which are used to clock the independent
    watchdog timer and the real-time clock.
  prefs: []
  type: TYPE_NORMAL
- en: 'The procedure to enter standby mode is slightly different from the one used
    to enter stop mode. The `SCB_SCR_PDDS` flag is set to select standby mode as a
    deep-sleep variant. The flag `SCB_SCR_LPDS` is not activated in this case, because
    we know it has no effect in standby mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this case, it is useless to set up the `EXTI` event for the button press,
    as the GPIO controllers will be disabled while the microcontroller is in standby
    mode. The easiest way to exit this state is configuring the real-time clock to
    generate a wake-up event after a fixed amount of time. In fact, during the standby
    phase, only a few peripherals will be kept alive, and they are all grouped in
    a special section of the clock configuration, namely the backup domain. The backup
    domain consists of the real-time clock and a small portion of the clock tree,
    containing the internal and external low-speed oscillators. The write access to
    the registers related to the backup domain is controlled by the flag disabling
    protection of the backup domain, or `POW_CR_DPB`, located in the `POW_CR` register
    at bit 8.
  prefs: []
  type: TYPE_NORMAL
- en: The RTC configuration registers, mapped in the peripherals area starting at
    address `0x40002870`, are protected from accidental writing due to electromagnetic
    interference, meaning that a special value sequence must be written to the write
    protection register before accessing the other registers. The RTC integrated into
    the reference platform is complex and has a lot of features, such as keeping track
    of date and time, and setting custom alarms and regular timestamp events. For
    this example, we want to use only the wake-up event, so most of the RTC registers
    are not documented here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The restricted set of registers we access for RTC is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The control register (`RTC_CR`) exposes the configuration of the various functionalities
    provided by the RTC. In the example, we use the values related to the wake-up
    trigger, enabling the interrupt with the wake-up timer interrupt enable flag,
    `RTC_CR_WUTIE`, and enabling the wake-up timer counter also using `RTC_CR_WUTE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initialization and status register (`RTC_ISR`) in this example is used to
    check the write status of the setup register for the wake-up timer through the
    special flag, `RTC_ISR_WUTWF`, during the timer setup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The wake-up timer register (`RTC_WUTR`) is used to set the interval before the
    next wake-up event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The write protection register (`RTC_WPR`) is used to transmit the unlock sequence
    before writing to other registers in the region.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preprocessor macros that map these registers and the meaningful fields
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The procedure to initialize the RTC to generate a wake-up event includes the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Turn on the clock gating for the power configuration registers, if not already
    on, to enable the `POW_CR_DPB` flag, in order to initiate the setup of the RTC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enable the RTC using bit 15 in the backup domain register configuration within
    the RCC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enable a backup clock source, selecting from the **Low-Speed Internal** (**LSI**)
    oscillator or a **Low-Speed External** (**LSE**) oscillator, if available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example, we use the LSI oscillator because the LSE oscillator is not
    present on the reference platform. However, external oscillators are more accurate
    and are always preferable, when available, for reliable timekeeping. After the
    clock has been enabled, the procedure waits until it becomes ready by polling
    a bit in the status register:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select the LSI as the source for the RTC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enable the interrupt and event generation for line `22` of `EXTI`, associating
    an event with the raised edge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unlock the writing to the RTC registers by writing the unlock sequence to `RTC_WPR`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Disable the RTC so that it is permitted to write to the configuration registers.
    Wait until the write operation is possible, by polling `RTC_ISR_WUTWF`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the value for the interval before the next wake-up event. The LSI frequency
    is 32,768 Hz, and the default divider for the wake-up interval register is set
    to 16, so each unit in `RTC_WUTR` represents one `2048`th of a second. To set
    an interval of `5` seconds, we use the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enable the wake-up event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clear the wake-up flag that might have been set when returning from standby
    mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete the sequence, we write an invalid byte to `RTC_WPR`. This way,
    the write protection on the RCC register is turned on again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To enable the RTC, right before entering standby mode, the following procedure
    ensures that the timer is active and counting and the event generation for the
    wake-up event is active:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the procedure just shown is called before entering standby, the system will
    be up again when the wake-up event occurs, but it does not resume the execution
    from where it was suspended, as it happens in the other low-power modes. Instead,
    it starts over from the reset interrupt handler, at the beginning of the interrupt
    vector. For this reason, this example does not need an implementation for `exit_lowpower_mode`,
    and the `WFE` instruction that switches the system to standby will never return
    to the same context of execution. Eventually, the `main` function for the standby
    example looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Wake-up intervals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important aspect to consider when designing a low-power strategy is the wake-up
    time intervals, or, in other words, how long the system takes to resume the execution
    after switching into low-power mode. A system with real-time requirements may
    leave some room for compromises between power usage and reactivity, but it is
    important to understand the impact of the wake-up operations from the different
    low-power modes, in order to predict the latency of operations in the worst-case
    scenario. Wake-up times are very much conditioned by the hardware design of the
    microcontroller, and largely dependent on the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: On our reference platform, while waking up from sleep mode takes a small number
    of CPU cycles, the situation changes for deep-sleep modes. Waking up from stop
    mode takes several microseconds. Further optimizations that have been activated
    while in stop mode, such as changing voltage regulators or turning off the flash
    memory, consistently impact the amount of time spent restoring the values to return
    to normal running. Resetting after standby mode produces even longer wake-up intervals,
    in the order of milliseconds, as the system should completely reboot after a wake-up
    event, and the start-up code execution time adds up to the fraction of milliseconds
    needed by the CPU to wake up.
  prefs: []
  type: TYPE_NORMAL
- en: When designing a low-power system, these wake-up times must be taken into account
    and properly measured, especially when the system has to deal with real-time constraints.
    The optimal low-power mode that fits the application timing and energy profile
    requirements must be chosen, taking into account the overhead produced by leaving
    low-power mode if the system wakes up often enough for these intervals to become
    non-negligible.
  prefs: []
  type: TYPE_NORMAL
- en: Once the system is designed to operate in the appropriate low-power modes, we
    need a reliable mechanism to measure the power used by the system while it is
    running. The next section suggests a common mechanism to keep track of the current
    values through the circuit under test to measure the effects of the low-power
    operating modes of the microcontroller, and for the evaluation of all energy-saving
    optimizations introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring power
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current in use by the target can be measured at any time by connecting an
    ammeter in series with the device. This mechanism, however, does not show all
    the oscillations of the values during a time interval, which is why it is often
    useful to sample the values of the parasitic voltage at the ends of a shunt resistor
    using an oscilloscope.
  prefs: []
  type: TYPE_NORMAL
- en: 'A shunt resistor is placed in series with the target device, on either side
    of the power source. Its typical value is relatively small, in the range of a
    few ohms, to ensure that the parasite voltage stays low, but is still measurable
    by the oscilloscope:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Measuring the current using an oscilloscope to sample the voltage
    applied to the shunt resistor](img/B18730_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Measuring the current using an oscilloscope to sample the voltage
    applied to the shunt resistor
  prefs: []
  type: TYPE_NORMAL
- en: Due to the properties of a series circuit, the current running through the shunt
    is the same as the one used by the target system, so the voltage on the ends of
    the shunt resistor varies accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Development boards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to see the effects of the power optimizations, we must exclude the
    electronics that are not related to the system. Our reference board, for example,
    the STM32F407DISCOVERY, has an additional microcontroller that is used to provide
    a debug interface for the host, and it is powered using the same USB connector.
    However, development kits often offer a way to measure the current, excluding
    the unrelated hardware, allowing us to properly evaluate the low-power features
    of the microcontroller, excluding the development-related circuitry on board.
  prefs: []
  type: TYPE_NORMAL
- en: On our reference board, the JP1 jumper can be used to open the circuit between
    the power supply and the microcontroller circuitry. By replacing the jumper with
    an ammeter connected to the two pins, we can measure the current used by the actual
    system. In the same way, it is possible to apply a shunt resistor to monitor the
    current, using the oscilloscope to sample the voltage on the shunt.
  prefs: []
  type: TYPE_NORMAL
- en: A lab equipped with reliable energy metering is a good starting point for evaluating
    low-power implementations and assisting in the prototype and design phase of energy
    optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Designing low-power embedded applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, a few design patterns are proposed to achieve a better energy
    profile on the target device, by evaluating the power demand of all the components
    and the states of the system we are about to design. Once we know how to measure
    the values in the target, and the details about the low-power mode in the selected
    architecture and microprocessor family, the application can be programmed, keeping
    other parameters in mind, such as the energy efficiency of the software we are
    writing.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing busy loops with sleep mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The reason busy loops are very popular among hobbyists is that they are so
    easy to implement. Suppose that the system needs to wait for a digital input to
    switch to a low-logic state, and this input is mapped to a certain GPIO. This
    can be easily done with the following one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: While this is perfectly working as expected, it will force the CPU into a loop
    of fetch-decode-execute, and to jump around the same few instructions until the
    condition becomes `false`. As we have seen, the power used by the microcontroller
    mostly depends on how fast the CPU is running. A lower frequency corresponds to
    a smaller amount of power used per instruction. Executing instructions in an infinite
    loop without switching to low-power mode sets the power demand from the CPU at
    its highest value for a measurable amount of time – in this case, the entire time
    needed for the logic input to change state.
  prefs: []
  type: TYPE_NORMAL
- en: Actively polling a value is the only way to go if interrupts are not enabled.
    The examples contained in this book tend to guide you toward a proper interrupt-handling
    approach. The proper way to handle the wait for the logic switch instead foresees
    the activation of an interrupt line related to the next operation. In the case
    of a GPIO line, we can use external interrupt triggers to wake up the main loop
    when the condition is met, and switch to a low-power mode, instead of looping,
    while waiting for the event.
  prefs: []
  type: TYPE_NORMAL
- en: In many other cases, the temptation to implement loops such as the previous
    one could be avoided by investigating another way to access the peripheral that
    is currently preventing the system from carrying out the next execution step.
    Modern serial and network controllers are equipped with interrupt signals, and
    when those are not available for the hardware we are accessing, there is always
    another way to sense an event through an external interrupt line. When a device
    can really only function in polling mode, as a last resort, the polling frequency
    can be reduced by associating the action with a timer interrupt, which would allow
    polling a few times per second, or even once in a while, using intervals that
    are more in line with the actual peripheral speed. Executing timed operations
    allows the CPU to sleep in between, and to switch to a low-power mode, reducing
    the average energy that the CPU would need to use while busy-looping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exception to this rule, seen many times in this chapter, is waiting for
    a ready flag after activating a system component. The following code activates
    the internal low-speed oscillator, and it is used in the standby mode example
    before entering low-speed mode. The CSR register is polled until the low-speed
    oscillator is actually running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Operations such as this, performed on the integrated peripherals in the microcontroller
    silicon, have a well-known latency of a few CPU clocks, and thus do not impact
    the real-time constraints, as the maximum latency for similar internal actions
    is often mentioned in the microcontroller documentation. The situation changes
    whenever the polling occurs on a less predictable register, whose state and reaction
    times may depend on external factors, and long busy loops may occur in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Deep sleep during longer inactivity periods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we know, standby allows the system to be frozen with the minimum possible
    power consumption, in the ultra-low-power range. The use of standby is advised
    when the design has very strict ultra-low-power requirements and the following
    conditions are met:'
  prefs: []
  type: TYPE_NORMAL
- en: A viable wake-up strategy exists and is compatible with the current hardware
    design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system can restore the execution without relying on its previous state,
    as the content of the RAM and CPU registers is lost and the system restarts from
    the reset service routine at wake-up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, longer periods of inactivity, where, for instance, the RTC can be used
    to program a wake-up alarm at a given time, are more fit for using standby mode.
    This applies to cases such as reading sensors and enabling actuators at programmed
    intervals during the day, keeping track of the time and a few status variables.
  prefs: []
  type: TYPE_NORMAL
- en: In most other cases, stop mode still saves enough power and provides a shorter
    wake-up interval. Another major advantage of stop mode is the increased flexibility
    of the wake-up strategy options. In fact, any interrupt-based or configurable
    event can be used to wake up the system from its low-power deep-sleep mode, so
    it is more fit for states where there is still some asynchronous interactivity
    with the peripherals and interfaces surrounding the microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the clock speed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Is all the computing power offered by the platform actually needed all the time?
  prefs: []
  type: TYPE_NORMAL
- en: The processing performance of microcontrollers nowadays is comparable to that
    of the personal computers of 20 years ago, which were already capable of fast
    operations and even processing real-time multimedia content. Embedded applications
    do not always require the CPU to run at full frequency. Especially when accessing
    peripherals, rather than crunching numbers, it does not matter how fast we clock
    the CPU and the bus. Both normal running mode and sleep mode require much less
    energy when the selected frequency is scaled down every single time the CPU performance
    is not actually the bottleneck of the execution pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Many microcontrollers are designed to scale down the operating frequency for
    the CPU and the internal buses, which also generally allows the system to be fed
    with lower voltages. As we have seen, changing clocks can be done at runtime to
    compromise accordingly in terms of power and performance. However, this implies
    that all the devices using a clock as a reference must be reconfigured, so the
    change has a cost in terms of execution time and should not be abused. A convenient
    way to add frequency changes to the system design is to separate two or more CPU
    frequency scaling options into custom power states and switch to the required
    state by fading between performance and power usage.
  prefs: []
  type: TYPE_NORMAL
- en: Power state transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a system connected to a sensor, producing and transmitting data through
    a network interface. The sensor is activated, then the system has to wait until
    it becomes ready, which is known to take several seconds. The sensor is then read
    multiple times in a row and then turned off. The data is processed, encrypted,
    and transmitted using a network device. The system remains idle for the next few
    hours before repeating the same operation. Initial rough modeling of the state
    machine is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – State machine for a hypothetical sensor-reading system](img/B18730_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – State machine for a hypothetical sensor-reading system
  prefs: []
  type: TYPE_NORMAL
- en: The long idle interval foreseen in between two consecutive cycles suggests that
    it is perhaps a good idea to put the system on standby for most of the time and
    program an RTC alarm for the system to autonomously wake up in time for the next
    acquisition.
  prefs: []
  type: TYPE_NORMAL
- en: Other, less obvious optimizations are possible for the other states as well.
    While acquiring data from the sensor, the full computing power of the CPU is possibly
    never used, as the system is mostly busy communicating with the sensor, or waiting,
    possibly in sleep mode, until the next value is received. In this case, we can
    provide a power-saving running mode, which ensures that the system runs at a reduced
    frequency so, when alternating between running and sleep mode, both are affected
    by a smaller energy footprint. The only phases in which higher performance is
    required are when the data is processed, transformed, and sent over the network
    device. A faster system, in this case, would be optimized to run faster and elaborate
    data in a shorter time frame. A stop phase can be foreseen right after the sensor
    activation if the sensor is able to send an interrupt to wake up the system when
    it is ready to begin the acquisition of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once each phase has been associated with its optimized low-power mode and selected
    operating frequency, we can add notations to our design documentation, to remind
    us how the low-power optimization will be implemented, in the form of state transition,
    to achieve the best combination of performance, energy economy, and low latency.
    The following figure summarizes the transitions between the phases and the associated
    low-power modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Power usage optimization for each running and idling state](img/B18730_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Power usage optimization for each running and idling state
  prefs: []
  type: TYPE_NORMAL
- en: Tuning an embedded system for its optimal energy profiles is a delicate process
    that heavily impacts other performance indicators, introducing delays and slowing
    down the speed of execution. In most cases, it consists of finding the best trade-off
    point between providing acceptable performance while keeping the power usage and
    the energy demand within the desired range.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern embedded systems open multiple possibilities for low-power and even ultra-low-power
    designs. This chapter analyzed the different energy profiles available for the
    reference microcontroller and how to design, integrate, and evaluate those procedures
    to control power usage in energy-aware embedded systems. Having understood several
    options available for the target, implementing low-power modes and further types
    of energy-saving techniques is the key to building durable and reliable battery-powered
    and energy-harvesting devices.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will switch focus to introducing connected devices and
    describing the impact of dealing with network protocols and interfaces in the
    embedded system architecture.
  prefs: []
  type: TYPE_NORMAL
