- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Power Management and Energy Saving
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电源管理和节能
- en: Energy efficiency has always been one of the leading factors in the microcontroller
    market. Since the early 2000s, signal-processing 16-bit RISC microcontrollers,
    such as the MSP430, have been designed for extremely low-power usage and are still
    leading the path of ultra-low-power optimization architectures in embedded systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 能效一直是微控制器市场的主要因素之一。自2000年代初以来，专为极低功耗设计的信号处理16位RISC微控制器，如MSP430，一直引领着嵌入式系统中超低功耗优化架构的发展。
- en: In the last few years, more advanced 32-bit RISC microcontrollers, rich in features
    and capable of running real-time operating systems, have scaled down in size and
    power consumption, and set foot in the low-power and ultra-low-power domains.
    Battery-powered systems and devices relying on energy-harvesting techniques are
    becoming more and more common in many industries. Low-power wireless communication
    is now offered by a number of connected platforms, so an increasing number of
    IoT systems include low-power and ultra-low-power characteristics in their design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，功能丰富且能够运行实时操作系统的更先进的32位RISC微控制器，其尺寸和功耗都得到了降低，并进入了低功耗和超低功耗领域。依赖能量收集技术的电池供电系统和设备在许多行业中变得越来越普遍。现在，许多连接平台提供低功耗无线通信，因此越来越多的物联网系统在设计时包括了低功耗和超低功耗的特性。
- en: Depending on the architecture, microcontrollers offer different strategies to
    reduce power consumption while running and implement low-power states that consume
    very little energy when activated.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 根据架构，微控制器提供不同的策略来降低运行时的功耗，并在激活时实现消耗极低能量的低功耗状态。
- en: Reducing the energy demand of an embedded system is often a tricky process.
    In fact, all the devices on the board may consume power if not deactivated properly.
    Generating high-frequency clocks is one of the most expensive operations, so the
    CPU and bus clocks should only be enabled when in use.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 降低嵌入式系统的能耗通常是一个复杂的过程。实际上，如果未正确停用，板上的所有设备都可能消耗电力。生成高频时钟是最昂贵的操作之一，因此CPU和总线时钟只有在使用时才应启用。
- en: Researching the ideal strategy to save energy depends on the compromises that
    can be made between performance and energy saving. Microcontrollers designed for
    ultra-low-power applications are capable of slowing down the CPU frequency, and
    even reaching different variations of a hibernation state, where all the clocks
    are stopped and the external peripherals are turned off for maximum power savings.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 研究理想的节能策略取决于在性能和节能之间可以做出的妥协。专为超低功耗应用设计的微控制器能够降低CPU频率，甚至达到休眠状态的不同变体，在这种状态下，所有时钟都停止，外部外围设备关闭以实现最大程度的节能。
- en: With the appropriate energy profiling techniques, and by implementing ultra-low-power
    strategies, battery-powered devices can run for several years before needing to
    be replaced. Using alternative power sources, such as solar panels, heat-converting
    devices, or other forms of energy harvesting from the surrounding environment,
    a well-profiled embedded system may run indefinitely as long as the external conditions
    allow it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过适当的能量分析技术，并实施超低功耗策略，电池供电设备可以在需要更换之前运行数年。使用太阳能板、热转换设备或从周围环境获取能量的其他形式，只要外部条件允许，经过良好分析的嵌入式系统可以无限期运行。
- en: Advanced microprocessors running at very high speeds are generally not designed
    to implement effective power consumption optimizations, which is what makes smaller,
    low-power microcontrollers such as the Cortex-M so popular in all those embedded
    systems where a small power footprint is one of the requirements.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常高速运行的先进微处理器通常不是设计用来实施有效的功耗优化，这也是为什么像Cortex-M这样的小型低功耗微控制器在所有那些要求小功耗的嵌入式系统中如此受欢迎。
- en: 'In this chapter, we will highlight a few key practices when approaching the
    design of low-power and ultra-low-power embedded systems. Low-power extensions
    of the Cortex-M microcontroller are demonstrated as examples of real-life implementations
    of low-power optimization on real targets. The chapter is divided into three sections:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将强调在设计低功耗和超低功耗嵌入式系统时的一些关键实践。以Cortex-M微控制器的低功耗扩展为例，展示了在真实目标上实现低功耗优化的实际应用。本章分为三个部分：
- en: System configuration
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统配置
- en: Low-power operating modes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低功耗工作模式
- en: Measuring power
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量功耗
- en: Designing low-power embedded applications
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计低功耗嵌入式应用
- en: By the end of this chapter, you will have learned about the management of different
    low-power configurations for the microcontroller and peripherals.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何管理微控制器和外设的不同低功耗配置。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter are available on GitHub at [https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter8](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter8).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在GitHub上找到，网址为[https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter8](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter8)。
- en: System configuration
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统配置
- en: A system that includes power consumption constraints in its specifications must
    be designed to meet the requirements in all its aspects, including hardware, software,
    and mechanical design. The selection of components and peripherals must take into
    account their energy profiles. External peripherals are often the most power-demanding
    components, and thus their power source must be interrupted by the microcontroller
    when they are not being used.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在其规范中包含功耗约束的系统必须设计成在所有方面满足要求，包括硬件、软件和机械设计。组件和外设的选择必须考虑它们的能耗。外部外设通常是功耗最大的组件，因此当它们未被使用时，必须由微控制器中断它们的电源。
- en: This section will describe the best practices concerning peripheral configuration,
    system clock settings, and voltage control, and their impact on power consumption.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将描述有关外设配置、系统时钟设置和电压控制的最佳实践，以及它们对功耗的影响。
- en: Hardware design
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件设计
- en: In low-power embedded systems, the hardware design must include the possibility
    to power peripherals on or off using a GPIO pin. This is better done using a line
    that is normally low so that it can be pulled down using passive components when
    the GPIO is not driven by the microcontroller. MOSFETs are often used to control
    the power supplied to external peripherals, using a GPIO signal to control the
    gate voltage.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在低功耗嵌入式系统中，硬件设计必须包括使用GPIO引脚开启或关闭外设的可能性。这最好使用一个通常为低电平的线路来完成，以便在GPIO未被微控制器驱动时，可以使用无源元件将其拉低。MOSFETs通常用于控制外部外设的供电，使用GPIO信号来控制栅极电压。
- en: Even when peripherals are turned off by interrupting their power source line,
    smaller currents may leak through other signals connected to them, such as a serial
    bus or other control signals. The hardware design must be able to detect and identify
    these leakages in early prototyping stages to minimize the energy lost this way.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 即使通过中断外设的电源线关闭外设，也可能有较小的电流通过连接到它们的其他信号泄漏，例如串行总线或其他控制信号。硬件设计必须在早期原型阶段能够检测和识别这些泄漏，以最大限度地减少由此造成的能量损失。
- en: Additionally, if the power-saving strategy includes the possibility to put the
    microprocessor into a deep-sleep operation mode, the logic of the input signals
    must be tailored to provide the correct wake-up events to resume normal operation.
    Signals that might not be driven while in sleep mode must maintain a known logic
    value enforced using passive components.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果省电策略包括将微处理器置于深度睡眠操作模式的可能性，输入信号的逻辑必须进行调整，以提供正确的唤醒事件来恢复正常操作。在睡眠模式下可能不会驱动的信号必须保持一个已知的逻辑值，并使用无源元件强制执行。
- en: Clock management
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时钟管理
- en: Internal peripherals and interfaces that are not in use must also stay off.
    If the platform supports it, clock gating is generally the mechanism used to selectively
    control the clock source for each peripheral and interface on the system. Each
    clock line enabled in the system clock gating configuration increases the power
    usage. Furthermore, the higher the scaling factor applied to generate the CPU
    clock from a slow oscillator, the higher the energy required by the PLL. The PLL
    is one of the most power-demanding components of the system, and the power consumed
    by the CPU is also directly proportional to its clock frequency. Many CPUs are
    designed to run with a reduced clock speed, offering a range of possible trade-offs
    between performance and energy saving. Accordingly, the PLL can generally be reconfigured
    at runtime to adapt to different profiles. However, every change to the system
    clock requires a reconfiguration of all the clock dividers for all the timers
    and peripherals currently in use.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 未使用的内部外围设备和接口也必须保持关闭状态。如果平台支持，时钟门控通常是用于选择性地控制系统上每个外围设备和接口的时钟源的一种机制。在系统时钟门控配置中启用的每条时钟线都会增加功耗。此外，从慢速振荡器生成CPU时钟所应用的缩放因子越高，PLL所需的能量就越高。PLL是系统中最耗能的组件之一，CPU的功耗也与其时钟频率成正比。许多CPU被设计为以较低的时钟速度运行，提供性能和节能之间的一系列可能权衡。因此，PLL通常可以在运行时重新配置以适应不同的配置文件。然而，对系统时钟的任何更改都需要重新配置当前所有正在使用的计时器和外围设备的所有时钟分频器。
- en: 'On the reference platform, we can reconfigure the CPU frequency at runtime
    to save a significant amount of power whenever the system does not require computing
    performance. To do this, the function in `system.c`, used to set the system clock
    in all the examples so far, has been modified to allow the selection of two different
    running frequencies. In performance mode, the system runs at its maximum frequency
    of 168 MHz. If the `powersave` flag argument is not zero, the clocks are configured
    to run at 48 MHz instead, for a more energy-efficient scenario:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在参考平台上，我们可以在运行时重新配置CPU频率，以便在系统不需要计算性能时节省大量电力。为此，`system.c`中的函数已被修改，允许选择两种不同的运行频率。在性能模式下，系统以最大频率168
    MHz运行。如果`powersave`标志参数不为零，则配置时钟以48 MHz运行，以实现更节能的场景：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The number of wait states for the `flash` operation has also been changed here,
    because, according to the documentation of the STM32F407, at 48 MHz, the flash
    only requires three wait states:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存操作的等待状态数量也在此处进行了更改，因为根据STM32F407的文档，在48 MHz时，闪存只需要三个等待状态：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The procedure for setting the system clock is the usual one. First, the HSI
    is enabled and then selected as the temporary clock source. Afterward, the 8 MHz
    external oscillator is enabled, and it is ready to feed the PLL:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 设置系统时钟的步骤是常规的。首先，启用HSI并将其选为临时时钟源。之后，启用8 MHz外部振荡器，并准备好为PLL供电：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The parameters for the clock divisors and multipliers for the chosen mode are
    set in the PLL configuration register, and the PLL is enabled:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为所选模式设置的时钟分频器和乘数参数设置在PLL配置寄存器中，并启用PLL：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Changing the CPU and system clocks means that all the peripherals that use the
    clocks must be reconfigured. If a timer is running, or any device using the clocks
    as reference is in use by the application, the pre-scaler register that is used
    for providing the timing reference must be adapted accordingly based on clock
    speed updates.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更改CPU和系统时钟意味着必须重新配置使用这些时钟的所有外围设备。如果计时器正在运行，或者任何使用时钟作为参考的设备正在由应用程序使用，则必须根据时钟速度更新相应地调整用于提供时间参考的预分频寄存器。
- en: Running the system at a lower speed offers other benefits, such as the possibility
    to decrease the number of wait states required to access the flash memory and
    enable extra low-power features that are only available when the system is not
    running at full speed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以较低的速度运行系统提供了其他好处，例如，可以减少访问闪存所需的等待状态数量，并启用仅在系统未以全速运行时才可用的额外低功耗功能。
- en: An embedded platform usually includes low-frequency clock generators, in the
    kHz range, which may be used as sources for time-keeping devices such as watchdogs
    and **real-time clocks** (**RTCs**). External or internal oscillators can be active
    during low-power operating modes and used to implement wake-up strategies.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式平台通常包括低频时钟发生器，在kHz范围内，可以用作看门狗和**实时时钟**（**RTCs**）等时间保持设备的数据源。在低功耗操作模式下，外部或内部振荡器可以是活动的，并用于实现唤醒策略。
- en: Voltage control
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电压控制
- en: Microcontrollers have a relatively wide range of operating voltages. Supplying
    lower voltages, however, makes it impossible to run the CPU at full speed, and
    flash memory may require additional wait states due to the physical characteristics
    of the hardware. Nevertheless, lower-voltage-tolerant logic can improve the overall
    economy of the system in some cases.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器的运行电压范围相对较宽。然而，供电较低的电压使得无法以全速运行CPU，并且由于硬件的物理特性，闪存可能需要额外的等待状态。尽管如此，低电压容限的逻辑在某些情况下可以提高系统的整体经济性。
- en: Internal regulators can often be configured to produce a lower voltage for the
    core signals, to reach a compromise between the power consumption and performance
    when the CPU is not running at its maximum frequency.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 内部调节器通常可以配置为产生较低的核心信号电压，以便在CPU未以最大频率运行时在功耗和性能之间达到妥协。
- en: An important aspect that is often neglected is the power consumed by the Schmitt
    triggers in the digital input logic. When GPIOs are configured as digital input,
    but not forced to a known logic state through external passive components, they
    might be floating around the average value, due to the electromagnetic fields
    in the environment. This causes the input signal to be triggered, resulting in
    a little energy being lost at every change in the logic state.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 常常被忽视的一个重要方面是数字输入逻辑中施密特触发器的功耗。当GPIO配置为数字输入，但没有通过外部无源组件强制到已知逻辑状态时，它们可能会在环境中的电磁场的影响下悬浮在平均值附近。这会导致输入信号被触发，从而在每个逻辑状态变化时损失少量能量。
- en: Low-power operating modes
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低功耗操作模式
- en: Microcontrollers can execute in different power modes, switching from full performance
    to complete hibernation. A proper understanding of the microcontroller’s low-power
    modes is fundamental to designing systems with improved energy profiles. Each
    architecture provides specific power configurations, where the CPU or other buses
    and peripherals are disabled, as well as appropriate mechanisms to be used by
    the system software to enter and exit low-power modes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器可以在不同的电源模式下执行，从全性能切换到完全休眠。正确理解微控制器的低功耗模式对于设计具有改进能源配置的系统是基本的。每个架构都提供特定的电源配置，其中CPU或其他总线和外设被禁用，以及系统软件用于进入和退出低功耗模式的适当机制。
- en: 'In an ARM-based microcontroller, the terminology used for the different low-power
    modes can be summarized as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于ARM的微控制器中，用于不同低功耗模式的术语可以总结如下：
- en: '**Normal operation mode**: Active components are selected through clock gating,
    and the clock is running at the desired frequency.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正常操作模式**：通过时钟门控选择活动组件，时钟以期望的频率运行。'
- en: '**Sleep mode**: The CPU clock is temporarily suspended, but all the peripherals
    keep functioning as in normal mode. As long as the CPU is not executing, there
    is a noticeable, even if marginal, amount of power saved in this mode. Execution
    can be resumed after receiving an interrupt request. This mode is also referred
    to as *wait mode* by some chip manufacturers.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**睡眠模式**：CPU时钟暂时暂停，但所有外设保持与正常模式相同的功能。只要CPU不执行，在这种模式下可以节省明显的、即使是很小的电量。在接收到中断请求后可以恢复执行。这种模式也被一些芯片制造商称为*等待模式*。'
- en: '**Stop mode**: The CPU clock and the bus clocks are disabled. All the peripherals
    powered by the microcontroller are off. The internal RAM and the CPU registers
    retain the stored values because the main voltage regulator stays on. The power
    consumption drops consistently, but it is still possible to wake up and resume
    the execution through an external interrupt or event. This mode is often also
    less appropriately called deep-sleep mode, although it is, in fact, one of two
    deep-sleep modes available.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止模式**：CPU时钟和总线时钟被禁用。所有由微控制器供电的外设都关闭。内部RAM和CPU寄存器保留存储的值，因为主电压调节器仍然开启。功耗持续下降，但仍然可以通过外部中断或事件唤醒并恢复执行。这种模式通常也被称为深度睡眠模式，尽管实际上它是两种深度睡眠模式中的一种。'
- en: '**Standby mode**: All the voltage regulators are off, and the content of the
    RAM and register is lost. A small amount of power, in the range of a few microwatts,
    may be required to keep the backup circuitry alive during the standby phase. Wake-up
    is then only possible under a few specific conditions, such as an externally powered
    RTC, or a hardware-predefined wake-up event pin. When the system wakes up from
    standby, the normal boot procedure is followed, and the execution resumes from
    the reset service routine.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**待机模式**：所有电压稳压器都关闭，RAM和寄存器的内容丢失。在待机阶段可能需要几微瓦的少量电力来保持备用电路的运行。唤醒仅在少数特定条件下才可能，例如外部供电的RTC或硬件预定义的唤醒事件引脚。当系统从待机唤醒时，将遵循正常的引导程序，并从复位服务例程恢复执行。'
- en: 'The ARMv7 microcode provides two instructions to enter low-power operating
    modes:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ARMv7微代码提供了两条指令来进入低功耗操作模式：
- en: '**Wait for** **interrupt** (**WFI**)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等待中断**（**WFI**）'
- en: '**Wait for** **event** (**WFE**)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等待事件**（**WFE**）'
- en: These instructions can be invoked at any time while in normal running mode.
    `WFI` will put the system in a low-power mode until the next interrupt request
    is received, while `WFE` is slightly different. Only a few events in the system,
    including the external interrupts, can be configured to generate an event. Normal
    interrupt requests will not put the system back into normal running mode if it
    is in a sleep or stop mode that has been entered using `WFE`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令可以在正常运行模式下随时调用。`WFI`会将系统置于低功耗模式，直到接收到下一个中断请求，而`WFE`则略有不同。只有系统中的少数事件，包括外部中断，可以配置为生成事件。如果系统处于使用`WFE`进入的睡眠或停止模式，则正常中断请求不会将系统放回正常运行模式。
- en: 'The low-power mode that is entered upon invocation depends on the settings
    stored in the `0xE000ED10`. The SCR only provides 3 meaningful 1-bit flag fields:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 调用后进入的低功耗模式取决于存储在`0xE000ED10`中的设置。SCR仅提供3个有意义的1位标志字段：
- en: '`SLEEPONEXIT` (bit 1): When enabled, the system will go into low-power mode
    at the end of the execution of the next interrupt handler.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SLEEPONEXIT`（位1）：当启用时，系统将在下一个中断处理程序执行结束时进入低功耗模式。'
- en: '`SLEEPDEEP` (bit 2): Determines which mode is entered upon the invocation of
    `WFI` or `WFE`, or when returning from an interrupt with `SLEEPONEXIT` active.
    If this bit is cleared, sleep mode is selected. When a low-power mode is entered
    with this bit active, the system will be put on stop or standby mode, depending
    on the configuration of the power management registers.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SLEEPDEEP`（位2）：确定在调用`WFI`或`WFE`或使用`SLEEPONEXIT`激活时返回中断时进入哪种模式。如果此位被清除，则选择睡眠模式。当此位激活时进入低功耗模式，系统将被置于停止或待机模式，具体取决于电源管理寄存器的配置。'
- en: '`SEVONPEND` (bit 4): When this bit is active, any interrupt pending during
    a low-power mode will cause a wake-up event, regardless of whether the sleep mode
    or the stop mode was entered using a `WFI` or a `WFE` instruction.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEVONPEND`（位4）：当此位激活时，在低功耗模式下任何挂起的中断都会引起唤醒事件，无论是否使用`WFI`或`WFE`指令进入睡眠模式或停止模式。'
- en: Note that bit 0, bit 3, and bits 5-31 are reserved (must be kept at value 0).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，位0、位3以及位5-31是保留的（必须保持为0）。
- en: Deep-sleep configuration
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深度睡眠配置
- en: 'To select between stop and standby mode, and to set up certain parameters related
    to the deep-sleep modes, our reference platform provides a power controller, mapped
    in the internal peripherals region, at address `0x40007000`. The controller consists
    of two registers:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要在停止模式和待机模式之间进行选择，并设置与深度睡眠模式相关的某些参数，我们的参考平台提供了一个电源控制器，映射在内部外围区域，地址为`0x40007000`。该控制器由两个寄存器组成：
- en: '`PWR_CR` (control register) at an offset of `0`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PWR_CR`（控制寄存器）偏移量为`0`'
- en: '`PWR_SCR` (status and control register) at an offset of `4`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PWR_SCR`（状态和控制寄存器）偏移量为`4`'
- en: 'The relevant parameters that can be configured in these two registers are the
    following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这两个寄存器中配置的相关参数如下：
- en: '`PWR_CR` bit 14\. When active, saves extra power in normal running mode, by
    configuring the internal regulator to produce a slightly lower voltage for the
    CPU core logic. This feature is only available if the target is not running at
    maximum frequency.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PWR_CR`位14。当激活时，在正常运行模式下通过配置内部稳压器为CPU核心逻辑产生略低的电压来节省额外的电力。此功能仅在目标未以最大频率运行时可用。'
- en: '`PWR_CR` bit 9\. If active while going into one of the deep-sleep modes, the
    flash will be turned off completely while the system is sleeping. This results
    in a moderate amount of power saved but also impacts the wake-up time.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PWR_CR`位9。如果进入深度睡眠模式时处于活动状态，则在系统睡眠期间将完全关闭闪存。这导致节省了适量的电量，但也会影响唤醒时间。'
- en: '`PWR_CR`, bit 1\. This bit determines which mode is entered when the CPU goes
    into a deep sleep. If cleared, stop mode is selected. If set, the system enters
    standby.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PWR_CR`位1。此位确定CPU进入深度睡眠时进入哪种模式。如果清除，则选择停止模式。如果设置，系统进入待机模式。'
- en: '`PWR_CR` bit 0\. This bit only has an effect in stop mode. If enabled, it slightly
    reduces the energy used while in deep sleep by enabling the *under-drive* mode
    in the internal voltage regulator. The current is supplied to the core logic in
    a reduced leakage mode, which still allows you to preserve the content of memory
    and registers. This feature is only available if the system is not running at
    full speed.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PWR_CR`位0。此位仅在停止模式下有效。如果启用，它通过在内部电压调节器中启用*欠压*模式，在深度睡眠期间略微减少能耗。电流以降低泄漏模式供应给核心逻辑，这仍然允许您保留内存和寄存器的内容。此功能仅在系统未以全速运行时才可用。'
- en: '`PWR_CSR` bit 4\. This flag determines whether the wake-up pin can be used
    as a normal GPIO, or whether it is reserved to detect a wake-up signal during
    standby. The pin associated with this function in the reference platform is PA0.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PWR_CSR`位4。此标志确定唤醒引脚是否可以用作正常GPIO，或者是否保留用于在待机期间检测唤醒信号。与参考平台中此功能相关联的引脚是PA0。'
- en: A `PWR_CSR` bit 0\. Writing `1` into `PWR_CR` bit 2 `CWUF`).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`PWR_CSR`位0。将`1`写入`PWR_CR`位2（`CWUF`）。'
- en: 'On the STM32F407 microcontroller, we can access the registers related to the
    low-power modes and configuration using the following macros:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在STM32F407微控制器上，我们可以使用以下宏访问与低功耗模式和配置相关的寄存器：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For the activation of the low-power modes, and the generation of spontaneous
    events, we define macros containing single inline assembly instructions as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于低功耗模式的激活和自发生事件的生成，我们定义包含单个内联汇编指令的宏如下：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If sleep mode is entered through `WFI`, the system suspends the execution until
    the next interrupt. Entering sleep mode with `WFE` instead ensures that only selected
    *events* can wake up the system again. Events of different types that occur on
    the system can be enabled to wake up the `WFE`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过`WFI`进入睡眠模式，系统将暂停执行，直到下一个中断。使用`WFE`进入睡眠模式确保只有选定的*事件*可以再次唤醒系统。可以启用系统上发生的不同类型的事件来唤醒`WFE`。
- en: When `WFE` is entered, all interrupts active in the NVIC will still count as
    events, thereby waking up the `WFE` call. Interrupts can be temporarily filtered
    out by disabling the corresponding IRQ line in the NVIC. If an interrupt is filtered
    this way, using NVIC, it remains in a pending state and it is handled as soon
    as the system goes back to normal running mode.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当进入`WFE`时，NVIC中所有活动的中断仍将被计为事件，从而唤醒`WFE`调用。可以通过在NVIC中禁用相应的IRQ线来临时过滤掉中断。如果通过NVIC以这种方式过滤中断，它将保持挂起状态，并在系统返回正常运行模式时立即处理。
- en: Stop mode
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止模式
- en: Sleep mode is entered by default every time that the `WFI` or `WFE` instructions
    are invoked, as long as `SCB_SCR_SLEEPDEEP` remains off. Other low-power modes
    can be enabled by enabling the `SLEEPDEEP` flag. To enter one of the available
    deep-sleep modes, the `SCB_SCR` and the POW registers must be configured before
    calling `WFI` or `WFE`. Depending on the configuration, the system enters one
    of the two deep-sleep modes, stop or standby.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`WFI`或`WFE`指令时，只要`SCB_SCR_SLEEPDEEP`保持关闭状态，就会进入睡眠模式。可以通过启用`SLEEPDEEP`标志来启用其他低功耗模式。要进入可用的深度睡眠模式之一，必须在调用`WFI`或`WFE`之前配置`SCB_SCR`和POW寄存器。根据配置，系统将进入两种深度睡眠模式之一，停止或待机。
- en: 'In the following example, a continuous 1 Hz timer toggles the LED 10 times
    before switching to deep-sleep mode, using `WFE`. The `main` loop stays in sleep
    mode in between timer interrupts, using `WFI`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，一个连续的1 Hz定时器使用`WFE`切换LED 10次，然后进入深度睡眠模式。在定时器中断之间，`main`循环保持在睡眠模式，使用`WFI`：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The interrupt service routine for the timer increases the `tim2_ticks` counter
    by `1` and sets the `timer_elapsed` flag, which will make the `main` loop toggle
    the LED and consume the event generated by the timer:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器的中断服务例程将`tim2_ticks`计数器增加`1`并设置`timer_elapsed`标志，这将使`main`循环切换LED并消耗由定时器生成的事件：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `enter_lowpower_mode` procedure is responsible for setting the values in
    the system control block and in the power control registers, depending on the
    desired low-power mode, and configuring all the optimizations accordingly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`enter_lowpower_mode`过程负责根据所需的低功耗模式设置系统控制块和电源控制寄存器中的值，并相应地配置所有优化。'
- en: 'The `enter_lowpower_mode` procedure performs the following actions:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`enter_lowpower_mode`过程执行以下操作：'
- en: It turns off the LED.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭LED。
- en: It sets the values in `SCB_SCR` and the power register to configure the low-power
    mode that will be entered upon `WFE`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它设置`SCB_SCR`和电源寄存器中的值，以配置在`WFE`时将进入的低功耗模式。
- en: It selects the single extra power optimizations.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择单个额外的电源优化。
- en: 'It is implemented as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, stop mode is configured to reduce power consumption as much as
    possible, by activating the low-power voltage regulator settings (through `POW_CR_LPDS`)
    and by turning off the flash (through `POW_CR_FPDS`).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，通过激活低功耗电压调节器设置（通过`POW_CR_LPDS`）和关闭闪存（通过`POW_CR_FPDS`）来配置停止模式以尽可能减少功耗。
- en: Low-power mode is now entered through a `WFE()` call. To be able to wake up
    the system, we configure an `EXTI` event, which is associated with the user pressing
    a button on the board. To do so, we configure `EXTI0` to be sensitive to raised
    edges, as the PA0 pin changes its logical value from `0` to `1` upon being pressed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过`WFE()`调用进入低功耗模式。为了能够唤醒系统，我们配置一个与用户在板上按按钮相关的`EXTI`事件。为此，我们将`EXTI0`配置为对上升沿敏感，因为当按下时，PA0引脚的逻辑值从`0`变为`1`。
- en: As we are not particularly interested in the interrupt itself, we ensure that
    the flag to generate an interrupt request is turned off in `EXTI`. The event controller
    will ensure that an event is generated instead because the flag relative to the
    input pin is enforced in the `EXTI_EMR` register.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们并不特别关注中断本身，我们确保在`EXTI`中关闭了生成中断请求的标志。事件控制器将确保生成一个事件，因为与输入引脚相关的标志在`EXTI_EMR`寄存器中被强制执行。
- en: 'The initial configuration for the user button event looks like the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 用户按钮事件的初始配置如下：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: No interrupts are configured for the button, as the event alone is sufficient
    to wake up the board during stop mode.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 没有为按钮配置中断，因为事件本身足以在停止模式下唤醒板。
- en: 'Upon entering stop mode, the PLL will be disabled, and the HSI will be automatically
    selected as the clock source when the system is back in normal running mode. To
    restore the clock configuration, there are a few steps to implement as soon as
    stop mode is exited:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 进入停止模式后，PLL将被禁用，当系统回到正常运行模式时，HSI将自动被选为时钟源。为了恢复时钟配置，在退出停止模式后需要执行以下几个步骤：
- en: '`SCB_SCR_SLEEPDEEP` flag is cleared so that the next invocation of `WFI` or
    `WFE` does not trigger another switch to stop mode.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除`SCB_SCR_SLEEPDEEP`标志，以便下一次调用`WFI`或`WFE`不会触发另一个切换到停止模式。
- en: The `POW_CR` register is accessed to clear the wake-up flag set by the hardware
    at the end of the stop mode.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`POW_CR`寄存器以清除硬件在停止模式结束时设置的唤醒标志。
- en: The PLL is configured again, as the clock is restored.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于时钟已恢复，PLL再次被配置。
- en: The LED is turned on.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开LED。
- en: 'The `TIM2` interrupt is enabled again for the timer to restore its functionality
    in normal running mode:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次启用`TIM2`中断，以便在正常运行模式下恢复定时器的功能：
- en: '[PRE10]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Deep-sleep mode reduces the power consumption consistently, and it is the ideal
    situation whenever the system must maintain the current running status but can
    be frozen for a longer period.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 深度睡眠模式可以持续降低功耗，并且当系统必须保持当前运行状态但可以冻结更长时间时，这是理想的情况。
- en: Standby mode
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 待机模式
- en: In standby mode, the system can go into ultra-low-power mode, consuming only
    a few microamperes, while waiting to be reinitialized by an external event. Entering
    standby mode requires you to set the `SCB_SCR_PDDS` flag prior to invoking `WFI`
    or `WFE`. While the system is on standby, all the voltage regulators are off,
    except for the low-speed oscillators, which are used to clock the independent
    watchdog timer and the real-time clock.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在待机模式下，系统可以进入超低功耗模式，消耗仅几微安培的电流，同时等待外部事件重新初始化。进入待机模式需要你在调用`WFI`或`WFE`之前设置`SCB_SCR_PDDS`标志。当系统处于待机状态时，除了用于时钟独立看门狗定时器和实时时钟的低速振荡器外，所有电压调节器都关闭。
- en: 'The procedure to enter standby mode is slightly different from the one used
    to enter stop mode. The `SCB_SCR_PDDS` flag is set to select standby mode as a
    deep-sleep variant. The flag `SCB_SCR_LPDS` is not activated in this case, because
    we know it has no effect in standby mode:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 进入待机模式的步骤与进入停止模式的步骤略有不同。将`SCB_SCR_PDDS`标志设置为选择待机模式作为深度睡眠变体。在这种情况下，不激活标志`SCB_SCR_LPDS`，因为我们知道在待机模式下它没有效果：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, it is useless to set up the `EXTI` event for the button press,
    as the GPIO controllers will be disabled while the microcontroller is in standby
    mode. The easiest way to exit this state is configuring the real-time clock to
    generate a wake-up event after a fixed amount of time. In fact, during the standby
    phase, only a few peripherals will be kept alive, and they are all grouped in
    a special section of the clock configuration, namely the backup domain. The backup
    domain consists of the real-time clock and a small portion of the clock tree,
    containing the internal and external low-speed oscillators. The write access to
    the registers related to the backup domain is controlled by the flag disabling
    protection of the backup domain, or `POW_CR_DPB`, located in the `POW_CR` register
    at bit 8.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，为按钮按下设置`EXTI`事件是无用的，因为当微控制器处于待机模式时，GPIO控制器将被禁用。退出此状态的最简单方法是配置实时时钟，在固定时间后生成一个唤醒事件。实际上，在待机阶段，只有少数外设会被保持激活，它们都被分组在时钟配置的特殊部分，即备份域。备份域包括实时时钟和一小部分时钟树，包含内部和外部低速振荡器。对备份域相关寄存器的写入访问由禁用备份域保护的标志，或`POW_CR_DPB`，位于`POW_CR`寄存器的第8位控制。
- en: The RTC configuration registers, mapped in the peripherals area starting at
    address `0x40002870`, are protected from accidental writing due to electromagnetic
    interference, meaning that a special value sequence must be written to the write
    protection register before accessing the other registers. The RTC integrated into
    the reference platform is complex and has a lot of features, such as keeping track
    of date and time, and setting custom alarms and regular timestamp events. For
    this example, we want to use only the wake-up event, so most of the RTC registers
    are not documented here.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: RTC配置寄存器，从地址`0x40002870`开始映射在外设区域，由于电磁干扰而受到保护，这意味着在访问其他寄存器之前必须写入一个特殊的值序列。集成到参考平台中的RTC复杂且具有许多功能，例如跟踪日期和时间，以及设置自定义闹钟和常规时间戳事件。对于本例，我们只想使用唤醒事件，因此大多数RTC寄存器在此处未进行文档说明。
- en: 'The restricted set of registers we access for RTC is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们访问RTC的受限寄存器集如下：
- en: The control register (`RTC_CR`) exposes the configuration of the various functionalities
    provided by the RTC. In the example, we use the values related to the wake-up
    trigger, enabling the interrupt with the wake-up timer interrupt enable flag,
    `RTC_CR_WUTIE`, and enabling the wake-up timer counter also using `RTC_CR_WUTE`.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制寄存器（`RTC_CR`）暴露了RTC提供的各种功能配置。在示例中，我们使用与唤醒触发器相关的值，通过唤醒定时器中断使能标志`RTC_CR_WUTIE`启用中断，并使用`RTC_CR_WUTE`也启用唤醒定时器计数器。
- en: The initialization and status register (`RTC_ISR`) in this example is used to
    check the write status of the setup register for the wake-up timer through the
    special flag, `RTC_ISR_WUTWF`, during the timer setup.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本例中，初始化和状态寄存器（`RTC_ISR`）用于通过特殊标志`RTC_ISR_WUTWF`在定时器设置期间检查唤醒定时器设置寄存器的写入状态。
- en: The wake-up timer register (`RTC_WUTR`) is used to set the interval before the
    next wake-up event.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唤醒定时器寄存器（`RTC_WUTR`）用于设置下一次唤醒事件之前的时间间隔。
- en: The write protection register (`RTC_WPR`) is used to transmit the unlock sequence
    before writing to other registers in the region.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写保护寄存器（`RTC_WPR`）用于在向该区域的其他寄存器写入之前传输解锁序列。
- en: 'The preprocessor macros that map these registers and the meaningful fields
    are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 映射这些寄存器和有意义的字段的前置宏如下：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The procedure to initialize the RTC to generate a wake-up event includes the
    following steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化RTC以生成唤醒事件的步骤包括以下内容：
- en: 'Turn on the clock gating for the power configuration registers, if not already
    on, to enable the `POW_CR_DPB` flag, in order to initiate the setup of the RTC:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未开启，请开启时钟门控以配置电源寄存器，以启用`POW_CR_DPB`标志，从而启动RTC的设置：
- en: '[PRE20]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Enable the RTC using bit 15 in the backup domain register configuration within
    the RCC:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在RCC中，通过备份域寄存器配置中的位15启用RTC。
- en: '[PRE23]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Enable a backup clock source, selecting from the **Low-Speed Internal** (**LSI**)
    oscillator or a **Low-Speed External** (**LSE**) oscillator, if available.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可用，启用备用时钟源，选择**低速内部**（**LSI**）振荡器或**低速外部**（**LSE**）振荡器。
- en: 'In this example, we use the LSI oscillator because the LSE oscillator is not
    present on the reference platform. However, external oscillators are more accurate
    and are always preferable, when available, for reliable timekeeping. After the
    clock has been enabled, the procedure waits until it becomes ready by polling
    a bit in the status register:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用LSI振荡器，因为参考平台上没有LSE振荡器。然而，外部振荡器更准确，并且在可用时总是首选，用于可靠的计时。时钟启用后，该过程通过轮询状态寄存器中的一个位等待它变得就绪：
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Select the LSI as the source for the RTC:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择LSI作为RTC的源：
- en: '[PRE27]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Enable the interrupt and event generation for line `22` of `EXTI`, associating
    an event with the raised edge:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用中断和事件生成，将EXTI的第22行关联到上升沿：
- en: '[PRE29]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Unlock the writing to the RTC registers by writing the unlock sequence to `RTC_WPR`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过写入解锁序列到`RTC_WPR`解锁对RTC寄存器的写入：
- en: '[PRE32]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Disable the RTC so that it is permitted to write to the configuration registers.
    Wait until the write operation is possible, by polling `RTC_ISR_WUTWF`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用RTC，以便允许写入配置寄存器。通过轮询`RTC_ISR_WUTWF`等待写入操作成为可能：
- en: '[PRE34]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Set the value for the interval before the next wake-up event. The LSI frequency
    is 32,768 Hz, and the default divider for the wake-up interval register is set
    to 16, so each unit in `RTC_WUTR` represents one `2048`th of a second. To set
    an interval of `5` seconds, we use the following:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个唤醒事件之前设置间隔的值。LSI频率为32,768 Hz，唤醒间隔寄存器的默认分频器设置为16，因此`RTC_WUTR`中的每个单位代表1/2048秒。要设置5秒的间隔，我们使用以下方法：
- en: '[PRE38]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Enable the wake-up event:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用唤醒事件：
- en: '[PRE39]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Clear the wake-up flag that might have been set when returning from standby
    mode:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除在从待机模式返回时可能设置的唤醒标志：
- en: '[PRE40]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To complete the sequence, we write an invalid byte to `RTC_WPR`. This way,
    the write protection on the RCC register is turned on again:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成序列，我们将一个无效字节写入`RTC_WPR`。这样，RCC寄存器的写保护再次开启：
- en: '[PRE41]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To enable the RTC, right before entering standby mode, the following procedure
    ensures that the timer is active and counting and the event generation for the
    wake-up event is active:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进入待机模式之前，启用RTC，以下程序确保计时器处于活动状态并计数，唤醒事件的生成是活跃的：
- en: '[PRE43]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If the procedure just shown is called before entering standby, the system will
    be up again when the wake-up event occurs, but it does not resume the execution
    from where it was suspended, as it happens in the other low-power modes. Instead,
    it starts over from the reset interrupt handler, at the beginning of the interrupt
    vector. For this reason, this example does not need an implementation for `exit_lowpower_mode`,
    and the `WFE` instruction that switches the system to standby will never return
    to the same context of execution. Eventually, the `main` function for the standby
    example looks like the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在进入待机之前调用显示的流程，当唤醒事件发生时，系统将再次启动，但它不会从暂停的地方恢复执行，就像在其他低功耗模式中发生的那样。相反，它从复位中断处理程序重新开始，在中断向量表的开头。因此，此示例不需要为`exit_lowpower_mode`实现，将系统切换到待机模式的`WFE`指令永远不会返回到相同的执行上下文。最终，待机示例的`main`函数看起来如下：
- en: '[PRE52]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Wake-up intervals
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 唤醒间隔
- en: An important aspect to consider when designing a low-power strategy is the wake-up
    time intervals, or, in other words, how long the system takes to resume the execution
    after switching into low-power mode. A system with real-time requirements may
    leave some room for compromises between power usage and reactivity, but it is
    important to understand the impact of the wake-up operations from the different
    low-power modes, in order to predict the latency of operations in the worst-case
    scenario. Wake-up times are very much conditioned by the hardware design of the
    microcontroller, and largely dependent on the architecture.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计低功耗策略时需要考虑的一个重要方面是唤醒时间间隔，换句话说，系统在切换到低功耗模式后恢复执行所需的时间。具有实时要求的系统可能在功耗和反应性之间留出一些妥协的空间，但了解从不同低功耗模式唤醒操作的影响，以便预测最坏情况下的操作延迟是很重要的。唤醒时间在很大程度上取决于微控制器的硬件设计，并且很大程度上依赖于架构。
- en: On our reference platform, while waking up from sleep mode takes a small number
    of CPU cycles, the situation changes for deep-sleep modes. Waking up from stop
    mode takes several microseconds. Further optimizations that have been activated
    while in stop mode, such as changing voltage regulators or turning off the flash
    memory, consistently impact the amount of time spent restoring the values to return
    to normal running. Resetting after standby mode produces even longer wake-up intervals,
    in the order of milliseconds, as the system should completely reboot after a wake-up
    event, and the start-up code execution time adds up to the fraction of milliseconds
    needed by the CPU to wake up.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的参考平台上，从睡眠模式唤醒需要少量CPU周期，但对于深度睡眠模式，情况就不同了。从停止模式唤醒需要几个微秒。在停止模式下激活的进一步优化，例如更改电压调节器或关闭闪存，会持续影响恢复到正常运行所需的时间。从待机模式唤醒后，唤醒间隔会更长，达到毫秒级别，因为系统在唤醒事件后应该完全重新启动，而启动代码执行时间会加到CPU唤醒所需的毫秒数中。
- en: When designing a low-power system, these wake-up times must be taken into account
    and properly measured, especially when the system has to deal with real-time constraints.
    The optimal low-power mode that fits the application timing and energy profile
    requirements must be chosen, taking into account the overhead produced by leaving
    low-power mode if the system wakes up often enough for these intervals to become
    non-negligible.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计低功耗系统时，必须考虑并正确测量这些唤醒时间，尤其是在系统必须处理实时约束的情况下。必须选择适合应用时序和能量配置文件要求的最佳低功耗模式，同时考虑到如果系统经常唤醒，这些间隔变得不可忽略时，离开低功耗模式产生的开销。
- en: Once the system is designed to operate in the appropriate low-power modes, we
    need a reliable mechanism to measure the power used by the system while it is
    running. The next section suggests a common mechanism to keep track of the current
    values through the circuit under test to measure the effects of the low-power
    operating modes of the microcontroller, and for the evaluation of all energy-saving
    optimizations introduced.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦系统设计为在适当的低功耗模式下运行，我们需要一个可靠的机制来测量系统运行时的功耗。下一节建议了一种常见的机制，通过跟踪测试电路中的电流值来测量微控制器的低功耗操作模式的影响，以及评估引入的所有节能优化。
- en: Measuring power
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量功耗
- en: The current in use by the target can be measured at any time by connecting an
    ammeter in series with the device. This mechanism, however, does not show all
    the oscillations of the values during a time interval, which is why it is often
    useful to sample the values of the parasitic voltage at the ends of a shunt resistor
    using an oscilloscope.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在任何时候通过将电流表串联连接到设备来测量目标使用的电流。然而，这种机制并不能显示在时间间隔内值的所有振荡，这就是为什么通常使用示波器采样分流电阻两端的寄生电压值是有用的。
- en: 'A shunt resistor is placed in series with the target device, on either side
    of the power source. Its typical value is relatively small, in the range of a
    few ohms, to ensure that the parasite voltage stays low, but is still measurable
    by the oscilloscope:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将分流电阻串联放置在目标设备与电源的两侧。其典型值相对较小，在几欧姆的范围内，以确保寄生电压保持较低，但仍可由示波器测量：
- en: '![Figure 8.1 – Measuring the current using an oscilloscope to sample the voltage
    applied to the shunt resistor](img/B18730_08_01.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 使用示波器测量分流电阻上的电压以采样电流](img/B18730_08_01.jpg)'
- en: Figure 8.1 – Measuring the current using an oscilloscope to sample the voltage
    applied to the shunt resistor
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 使用示波器测量分流电阻上的电压以采样电流
- en: Due to the properties of a series circuit, the current running through the shunt
    is the same as the one used by the target system, so the voltage on the ends of
    the shunt resistor varies accordingly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于串联电路的特性，通过分流器的电流与目标系统使用的电流相同，因此分流电阻两端的电压相应地变化。
- en: Development boards
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发板
- en: In order to see the effects of the power optimizations, we must exclude the
    electronics that are not related to the system. Our reference board, for example,
    the STM32F407DISCOVERY, has an additional microcontroller that is used to provide
    a debug interface for the host, and it is powered using the same USB connector.
    However, development kits often offer a way to measure the current, excluding
    the unrelated hardware, allowing us to properly evaluate the low-power features
    of the microcontroller, excluding the development-related circuitry on board.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到电源优化的效果，我们必须排除与系统无关的电子设备。例如，我们的参考板 STM32F407DISCOVERY 上有一个额外的微控制器，用于为主机提供调试接口，并且它使用相同的
    USB 连接器供电。然而，开发套件通常提供一种方法来测量电流，排除无关硬件，使我们能够正确评估微控制器的低功耗特性，排除板上的开发相关电路。
- en: On our reference board, the JP1 jumper can be used to open the circuit between
    the power supply and the microcontroller circuitry. By replacing the jumper with
    an ammeter connected to the two pins, we can measure the current used by the actual
    system. In the same way, it is possible to apply a shunt resistor to monitor the
    current, using the oscilloscope to sample the voltage on the shunt.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的参考板上，JP1 跳线可用于打开电源和微控制器电路之间的电路。通过将跳线替换为连接到两个引脚的电流表，我们可以测量实际系统使用的电流。同样，可以通过使用示波器采样分流电阻上的电压来应用分流电阻以监控电流。
- en: A lab equipped with reliable energy metering is a good starting point for evaluating
    low-power implementations and assisting in the prototype and design phase of energy
    optimization.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一个配备可靠能量计量的实验室是评估低功耗实现和协助原型和设计阶段能量优化的良好起点。
- en: Designing low-power embedded applications
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计低功耗嵌入式应用程序
- en: In this section, a few design patterns are proposed to achieve a better energy
    profile on the target device, by evaluating the power demand of all the components
    and the states of the system we are about to design. Once we know how to measure
    the values in the target, and the details about the low-power mode in the selected
    architecture and microprocessor family, the application can be programmed, keeping
    other parameters in mind, such as the energy efficiency of the software we are
    writing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，提出了一些设计模式，通过评估即将设计的系统所有组件的功耗和状态，以在目标设备上实现更好的能耗配置文件。一旦我们知道如何在目标设备上测量值，以及所选架构和微处理器系列中低功耗模式的详细信息，就可以编程应用程序，同时考虑其他参数，例如我们编写的软件的能量效率。
- en: Replacing busy loops with sleep mode
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用睡眠模式替换忙碌循环
- en: 'The reason busy loops are very popular among hobbyists is that they are so
    easy to implement. Suppose that the system needs to wait for a digital input to
    switch to a low-logic state, and this input is mapped to a certain GPIO. This
    can be easily done with the following one line of code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 忙碌循环在爱好者中非常受欢迎的原因是它们非常容易实现。假设系统需要等待一个数字输入切换到低逻辑状态，并且这个输入映射到某个 GPIO。这可以通过以下一行代码轻松完成：
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: While this is perfectly working as expected, it will force the CPU into a loop
    of fetch-decode-execute, and to jump around the same few instructions until the
    condition becomes `false`. As we have seen, the power used by the microcontroller
    mostly depends on how fast the CPU is running. A lower frequency corresponds to
    a smaller amount of power used per instruction. Executing instructions in an infinite
    loop without switching to low-power mode sets the power demand from the CPU at
    its highest value for a measurable amount of time – in this case, the entire time
    needed for the logic input to change state.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这完全按预期工作，但它将迫使 CPU 进入一个 fetch-decode-execute 循环，并在相同的几个指令之间跳跃，直到条件变为 `false`。正如我们所见，微控制器使用的功率主要取决于
    CPU 的运行速度。较低的频率对应于每条指令使用的功率较小。在无限循环中执行指令而不切换到低功耗模式，将 CPU 的功耗设定在其最高值，持续一定可测量的时间——在这种情况下，逻辑输入改变状态所需的时间。
- en: Actively polling a value is the only way to go if interrupts are not enabled.
    The examples contained in this book tend to guide you toward a proper interrupt-handling
    approach. The proper way to handle the wait for the logic switch instead foresees
    the activation of an interrupt line related to the next operation. In the case
    of a GPIO line, we can use external interrupt triggers to wake up the main loop
    when the condition is met, and switch to a low-power mode, instead of looping,
    while waiting for the event.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有启用中断，积极轮询值是唯一的方法。本书中的示例倾向于引导你走向适当的中断处理方法。正确处理等待逻辑切换的方法是预见与下一个操作相关的中断线的激活。在GPIO线的情况下，我们可以使用外部中断触发器在条件满足时唤醒主循环，并在等待事件时切换到低功耗模式，而不是循环等待。
- en: In many other cases, the temptation to implement loops such as the previous
    one could be avoided by investigating another way to access the peripheral that
    is currently preventing the system from carrying out the next execution step.
    Modern serial and network controllers are equipped with interrupt signals, and
    when those are not available for the hardware we are accessing, there is always
    another way to sense an event through an external interrupt line. When a device
    can really only function in polling mode, as a last resort, the polling frequency
    can be reduced by associating the action with a timer interrupt, which would allow
    polling a few times per second, or even once in a while, using intervals that
    are more in line with the actual peripheral speed. Executing timed operations
    allows the CPU to sleep in between, and to switch to a low-power mode, reducing
    the average energy that the CPU would need to use while busy-looping.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多其他情况下，通过调查另一种访问当前阻止系统执行下一步操作的外设的方法，可以避免实现如前所述的循环。现代串行和网络控制器配备了中断信号，当我们访问的硬件没有这些信号时，总有其他方法通过外部中断线感知事件。当一个设备确实只能以轮询模式运行时，作为最后的手段，可以通过将操作与定时器中断关联来降低轮询频率，这样就可以每秒轮询几次，甚至偶尔一次，使用与实际外设速度更匹配的间隔。执行定时操作允许CPU在之间睡眠，并切换到低功耗模式，从而降低CPU在忙碌循环时所需的平均能量。
- en: 'The exception to this rule, seen many times in this chapter, is waiting for
    a ready flag after activating a system component. The following code activates
    the internal low-speed oscillator, and it is used in the standby mode example
    before entering low-speed mode. The CSR register is polled until the low-speed
    oscillator is actually running:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中多次提到的这个规则的例外情况是在激活系统组件后等待就绪标志。以下代码激活了内部低速振荡器，并在进入低速模式之前用于待机模式示例。CSR寄存器被轮询，直到低速振荡器实际运行：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Operations such as this, performed on the integrated peripherals in the microcontroller
    silicon, have a well-known latency of a few CPU clocks, and thus do not impact
    the real-time constraints, as the maximum latency for similar internal actions
    is often mentioned in the microcontroller documentation. The situation changes
    whenever the polling occurs on a less predictable register, whose state and reaction
    times may depend on external factors, and long busy loops may occur in the system.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在微控制器硅芯片中的集成外设上执行此类操作，具有几个CPU时钟周期的已知延迟，因此不会影响实时约束，因为类似内部操作的最大延迟通常在微控制器文档中提及。当轮询发生在状态和反应时间可能依赖于外部因素的不可预测的寄存器上时，情况就会改变，系统可能会出现长时间的忙碌循环。
- en: Deep sleep during longer inactivity periods
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在较长的非活动期间进行深度睡眠
- en: 'As we know, standby allows the system to be frozen with the minimum possible
    power consumption, in the ultra-low-power range. The use of standby is advised
    when the design has very strict ultra-low-power requirements and the following
    conditions are met:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，待机模式允许系统以尽可能低的功耗冻结，处于超低功耗范围内。当设计对超低功耗有非常严格的要求，并且满足以下条件时，建议使用待机模式：
- en: A viable wake-up strategy exists and is compatible with the current hardware
    design
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一种可行的唤醒策略，并且与当前的硬件设计兼容
- en: The system can restore the execution without relying on its previous state,
    as the content of the RAM and CPU registers is lost and the system restarts from
    the reset service routine at wake-up
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统可以在不依赖其先前状态的情况下恢复执行，因为RAM和CPU寄存器的内容已丢失，系统在唤醒时从复位服务例程重新启动
- en: Usually, longer periods of inactivity, where, for instance, the RTC can be used
    to program a wake-up alarm at a given time, are more fit for using standby mode.
    This applies to cases such as reading sensors and enabling actuators at programmed
    intervals during the day, keeping track of the time and a few status variables.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，较长的非活动期，例如，可以使用RTC在指定时间编程唤醒闹钟，更适合使用待机模式。这适用于在白天以编程间隔读取传感器和启用执行器、跟踪时间和一些状态变量等情况。
- en: In most other cases, stop mode still saves enough power and provides a shorter
    wake-up interval. Another major advantage of stop mode is the increased flexibility
    of the wake-up strategy options. In fact, any interrupt-based or configurable
    event can be used to wake up the system from its low-power deep-sleep mode, so
    it is more fit for states where there is still some asynchronous interactivity
    with the peripherals and interfaces surrounding the microcontroller.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数其他情况下，停止模式仍然可以节省足够的电量，并提供更短的唤醒间隔。停止模式的另一个主要优点是唤醒策略选项的灵活性增加。实际上，任何基于中断或可配置的事件都可以用来从微控制器的低功耗深度睡眠模式唤醒系统，因此它更适合与微控制器周围的外围设备和接口进行一些异步交互的状态。
- en: Choosing the clock speed
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择时钟速度
- en: Is all the computing power offered by the platform actually needed all the time?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 平台提供的所有计算能力是否在所有时候都是必需的？
- en: The processing performance of microcontrollers nowadays is comparable to that
    of the personal computers of 20 years ago, which were already capable of fast
    operations and even processing real-time multimedia content. Embedded applications
    do not always require the CPU to run at full frequency. Especially when accessing
    peripherals, rather than crunching numbers, it does not matter how fast we clock
    the CPU and the bus. Both normal running mode and sleep mode require much less
    energy when the selected frequency is scaled down every single time the CPU performance
    is not actually the bottleneck of the execution pipe.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现今微处理器的处理性能与20年前的个人计算机相当，这些计算机已经能够进行快速操作，甚至处理实时多媒体内容。嵌入式应用并不总是需要CPU以全频率运行。特别是在访问外围设备时，而不是进行数值计算，CPU和总线时钟的速度并不重要。当每次CPU性能不是执行管道的瓶颈时，无论是正常运行模式还是睡眠模式，所选频率降低时，两者所需的能量都大大减少。
- en: Many microcontrollers are designed to scale down the operating frequency for
    the CPU and the internal buses, which also generally allows the system to be fed
    with lower voltages. As we have seen, changing clocks can be done at runtime to
    compromise accordingly in terms of power and performance. However, this implies
    that all the devices using a clock as a reference must be reconfigured, so the
    change has a cost in terms of execution time and should not be abused. A convenient
    way to add frequency changes to the system design is to separate two or more CPU
    frequency scaling options into custom power states and switch to the required
    state by fading between performance and power usage.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 许多微控制器被设计为降低CPU和内部总线的运行频率，这也通常允许系统以较低的电压供电。正如我们所见，时钟的改变可以在运行时进行，以在功率和性能方面做出相应的妥协。然而，这意味着所有使用时钟作为参考的设备都必须重新配置，因此这种改变在执行时间上有成本，不应滥用。将频率变化添加到系统设计的一个方便方法是，将两个或多个CPU频率缩放选项分离成自定义电源状态，并通过在性能和功耗之间淡入淡出切换到所需状态。
- en: Power state transitions
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功率状态转换
- en: 'Consider a system connected to a sensor, producing and transmitting data through
    a network interface. The sensor is activated, then the system has to wait until
    it becomes ready, which is known to take several seconds. The sensor is then read
    multiple times in a row and then turned off. The data is processed, encrypted,
    and transmitted using a network device. The system remains idle for the next few
    hours before repeating the same operation. Initial rough modeling of the state
    machine is the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个连接到传感器的系统，通过网络接口产生和传输数据。传感器被激活后，系统必须等待它准备好，这通常需要几秒钟。然后连续读取传感器多次，然后关闭。数据通过网络设备进行处理、加密和传输。接下来几小时系统保持空闲，然后重复相同的操作。状态机的初步粗略建模如下：
- en: '![Figure 8.2 – State machine for a hypothetical sensor-reading system](img/B18730_08_02.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 假设的传感器读取系统的状态机](img/B18730_08_02.jpg)'
- en: Figure 8.2 – State machine for a hypothetical sensor-reading system
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 假设的传感器读取系统的状态机
- en: The long idle interval foreseen in between two consecutive cycles suggests that
    it is perhaps a good idea to put the system on standby for most of the time and
    program an RTC alarm for the system to autonomously wake up in time for the next
    acquisition.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在连续两个周期之间预见的长时间空闲间隔表明，将系统大部分时间置于待机状态，并为系统编程一个RTC闹钟，以便在下次采集前自动唤醒，可能是一个好主意。
- en: Other, less obvious optimizations are possible for the other states as well.
    While acquiring data from the sensor, the full computing power of the CPU is possibly
    never used, as the system is mostly busy communicating with the sensor, or waiting,
    possibly in sleep mode, until the next value is received. In this case, we can
    provide a power-saving running mode, which ensures that the system runs at a reduced
    frequency so, when alternating between running and sleep mode, both are affected
    by a smaller energy footprint. The only phases in which higher performance is
    required are when the data is processed, transformed, and sent over the network
    device. A faster system, in this case, would be optimized to run faster and elaborate
    data in a shorter time frame. A stop phase can be foreseen right after the sensor
    activation if the sensor is able to send an interrupt to wake up the system when
    it is ready to begin the acquisition of the data.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他状态，也有可能进行其他不太明显的优化。在从传感器获取数据时，CPU的完整计算能力可能从未被充分利用，因为系统大部分时间都在与传感器通信，或者等待，可能在睡眠模式下，直到接收到下一个值。在这种情况下，我们可以提供一个节能的运行模式，确保系统以较低的频率运行，这样在运行和睡眠模式之间交替时，两者都会受到较小的能量足迹的影响。只有在数据处理、转换并通过网络设备发送时，才需要更高的性能。在这种情况下，系统将被优化以更快地运行并在更短的时间内处理数据。如果传感器能够在准备开始数据采集时唤醒系统，则可以在传感器激活后预见一个停止阶段。
- en: 'Once each phase has been associated with its optimized low-power mode and selected
    operating frequency, we can add notations to our design documentation, to remind
    us how the low-power optimization will be implemented, in the form of state transition,
    to achieve the best combination of performance, energy economy, and low latency.
    The following figure summarizes the transitions between the phases and the associated
    low-power modes:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦每个阶段都与其优化的低功耗模式和选定的操作频率相关联，我们就可以在我们的设计文档中添加注释，以提醒我们低功耗优化将如何实现，以实现性能、能源经济和低延迟的最佳组合。以下图总结了阶段之间的转换及其相关的低功耗模式：
- en: '![Figure 8.3 – Power usage optimization for each running and idling state](img/B18730_08_03.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 每个运行和空闲状态下的功耗优化](img/B18730_08_03.jpg)'
- en: Figure 8.3 – Power usage optimization for each running and idling state
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 每个运行和空闲状态下的功耗优化
- en: Tuning an embedded system for its optimal energy profiles is a delicate process
    that heavily impacts other performance indicators, introducing delays and slowing
    down the speed of execution. In most cases, it consists of finding the best trade-off
    point between providing acceptable performance while keeping the power usage and
    the energy demand within the desired range.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为嵌入式系统调整其最佳能效曲线是一个精细的过程，它对其他性能指标有重大影响，会引入延迟并减慢执行速度。在大多数情况下，它包括在提供可接受性能的同时，保持功耗和能量需求在期望范围内找到最佳折衷点。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Modern embedded systems open multiple possibilities for low-power and even ultra-low-power
    designs. This chapter analyzed the different energy profiles available for the
    reference microcontroller and how to design, integrate, and evaluate those procedures
    to control power usage in energy-aware embedded systems. Having understood several
    options available for the target, implementing low-power modes and further types
    of energy-saving techniques is the key to building durable and reliable battery-powered
    and energy-harvesting devices.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现代嵌入式系统为低功耗甚至超低功耗设计打开了多种可能性。本章分析了针对参考微控制器可用的不同能效曲线，以及如何设计、集成和评估这些程序以控制能量感知嵌入式系统中的功耗。在理解了目标设备可用的几种选项后，实现低功耗模式和进一步节能技术是构建耐用且可靠的电池供电和能量收集设备的关键。
- en: In the next chapter, we will switch focus to introducing connected devices and
    describing the impact of dealing with network protocols and interfaces in the
    embedded system architecture.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将转向介绍连接设备，并描述在嵌入式系统架构中处理网络协议和接口的影响。
