<html><head></head><body>
		<div><h1 id="_idParaDest-10"><em class="italics"><a id="_idTextAnchor010"/>Chapter 1</em></h1>
		</div>
		<div><h1 id="_idParaDest-11"><a id="_idTextAnchor011"/>Antithesis</h1>
		</div>
		<div><h2 id="_idParaDest-12"><a id="_idTextAnchor012"/>Telling an Object What to Do</h2>
			<p><em class="italics">The big idea is "messaging" – that is, what the kernal [sic] of Smalltalk/Squeak is all about (and it's something that was never quite completed in our Xerox PARC phase). The Japanese have a small word – ma – for "that which is in between" – perhaps the nearest English equivalent is "interstitial." The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be.</em></p>
			<p><em class="italics">Alan Kay, (squeak-dev mailing list — </em><a href="http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html">http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html</a><em class="italics">)</em></p>
			<p>A huge amount of complexity is wrapped up in that most common of operations: invoking an object's method. In many programming languages – C++, Java, Python, and others – this takes the form <code>anObject.methodName()</code>, which means "there will be a method on the class that <code>anObject</code> is an instance of, or some antecedent class, where the method is called <code>methodName</code>, please find it and run it, with the <code>self</code> or <code>this</code> value aliased to <code>anObject</code>." So, for example, in Java we would expect to find a (non-abstract) <code>public void methodName() { /* ... */ }</code> somewhere in <code>anObject</code>'s class or parent.</p>
			<p>This guarantee introduces a lot of coupling between the caller and the object that holds the method:</p>
			<ol>
				<li>The caller knows that the object is an instance of some class (there are so many issues bound up with inheritance that it gets its own chapter, later).</li>
				<li>The caller knows that the object's class, or some ancestor of it, provides a method with the given name.</li>
				<li>The method will run to completion in this context, then give control back to the caller (this is not particularly evident from the syntax in isolation, but nonetheless is assumed).</li>
			</ol>
			<p>What would it mean to lift those assumptions? It would make the object a truly independent computer program, communicating from a distance over an agreed protocol based on message passing. What that object does, how it does it, even what programming language it's implemented in, are all private to the object. Does it collaborate with a class to find out how to respond to the message? Does that class have one parent or multiple parents?</p>
			<p>The <em class="italics">idea</em> behind message-passing is exactly that arms-length separation of concerns, but even programming languages that are based on the message-passing scheme usually treat it as a special case of "look up a method," to be followed only if the usual method-resolution fails. These languages typically have a particular named method that will be run when the requested method isn't found. In Smalltalk, it's called <code>doesNotUnderstand:</code>, while in Ruby it's called <code>method_missing()</code>. Each one receives the <em class="italics">selector</em> (that is, the unique name of the method the caller was hoping to invoke) to decide what to do with it. This gets us a higher level of decoupling: objects can send messages to one another without having to peek at the others' implementations to discover whether they implement a method matching the message.</p>
			<p>Why is that decoupling valuable? It lets us build our objects as truly standalone programs, considering only what their contract is with the outside world and how their implementation supports that contract. By requiring, for example, that an object will only receive a message if it is an instance of a class that contains a Java function of the same name that can be pushed onto the call stack, even if via a Java interface (a list of methods that a Java class can provide), we adopt a lot of assumptions about the implementation of the message receiver, turning them into constraints that the programmer must deal with when building the sender. We do not have independent, decoupled programs collaborating over a message interface, but a rigid system with a limited amount of modularity. Understanding one object means pulling in information about other parts of the system.</p>
			<p><em class="italics">This is not merely an academic distinction, as it constrains the design of real systems. Consider an application to visualize some information about a company's staff, which is located in a key-value store. If I need every object between the view and the store to know about all of the available methods, then I either duplicate my data schema everywhere in the app by defining methods like </em><code>salary()</code><em class="italics"> or </em><code>payrollNumber()</code><em class="italics">, or I provide meaningless generic interfaces like </em><code>getValue(String key)</code><em class="italics"> that remove the useful information that I'm working with representations of people in the company.</em></p>
			<p>Conversely, I could say to my <code>Employee</code> object "if you get a message you do not recognize, but it looks like a key in the key-value store, reply with the value you find for that key." I could say to my view object "if you get a message you do not recognize, but the <code>Employee</code> gives you a value in response to it, prepare that value for display and use the selector name as the label for that value." The behavior – looking up arbitrary values in the key-value store – remains the same but the message network tells us more about <em class="italics">why</em> the application is doing what it does.</p>
			<p>By providing lazy resolution paths like <code>method_missing</code>, systems like Ruby partially lift these assumptions and provide tools to enable greater decoupling and independence of objects in the network. To fully take advantage of this, we must change the language used and the way we think about these features.</p>
			<p>A guide to OOP in Ruby will probably tell you that methods are looked up by name, but if that fails, the class can optionally implement <code>method_missing</code> to supply custom behavior. This is exactly backwards: saying that objects are bags of named methods until that stops working, when they gain some autonomy.</p>
			<p>Flip this language: an object is responsible for deciding how it handles messages, and one particular convenience is that they automatically run methods that match a received selector without any extra processing. Now your object truly is an autonomous actor responding to messages, rather than a place to store particular named routines in a procedural program.</p>
			<p>There are object systems that expose this way of thinking about objects, a good example being the CMU Mach system. Mach is an operating system kernel that supplies communication between threads (in the same or different tasks) using message passing. A sender need know nothing about the receiver other than its port (the place to put outgoing messages) and how to arrange a message to be put in the port. The receiver knows nothing about the sender; just that a message has appeared on its port and can be acted on. The two could be in the same task, or not even on the same computer. They do not even need to be written in the same language, they just need to know what the messages are and how to put them on a port.</p>
			<p>In the world of service-oriented architecture, a microservice is an independent program that collaborates with peers over a loosely coupled interface comprised of messages sent over some implementation-independent transport mechanism – often HTTPS or protocol buffers. This sounds a lot like OOP.</p>
			<p>Microservice adopters are able to implement different services in different technologies, to think about changes to a given service only in terms of how they satisfy the message contract, and to independently replace individual services without disrupting the whole system. This, too, sounds a lot like OOP.</p>
			<h2 id="_idParaDest-13"><a id="_idTextAnchor013"/>Designing an Object</h2>
			<p><em class="italics">The object-oriented approach attempts to manage the complexity inherent in real-world problems by abstracting out knowledge and encapsulating it within objects. Finding or creating these objects is a problem of structuring knowledge and activities.</em></p>
			<p><em class="italics">Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener, Designing Object-Oriented Software</em></p>
			<p>An early goal of OOP was to simplify the work of software system design by reducing the big problem "design this large system to solve these problems" into the small problems "design these small systems" and "combine these small systems such that they solve these problems in concert". Brad Cox, an object technologist who built the Objective-C language and cofounded a company to exploit it, wrote an article "<em class="italics">What if there's a Silver Bullet...And the Competition Gets It First?</em>" in which he asserted that OOP represented a significant reduction in software complexity.</p>
			<p><em class="italics">In the broadest sense, "object-oriented" refers to the war and not the weapons, the ends and not the means, an objective rather than technologies for achieving it. It means orienting on objects rather than on processes for building them; wielding all the tools programmers can muster, from well-proven antiques like Cobol to as-yet missing ones like specification/testing languages, to enable software consumers, letting them reason about software products with the common-sense skills we all use to understand the tangible objects of everyday experience. </em></p>
			<p><em class="italics">It means relinquishing the traditional process-centered paradigm with the programmer-machine relationship at the center of the software universe in favor of a product-centered paradigm with the producer-consumer relationship at the center.</em></p>
			<p>Nonetheless, many "object-oriented" design techniques still rely on considering the system as a whole, building artisanal, bespoke objects from scratch that will comprise the system that satisfies the customer's needs. In this sense, Cox's vision has not come to pass: he hoped for the "software industrial revolution" in which standardized components (software-ICs, analogous with integrated circuits in electronics design) could be specified based on their externally visible behavior and composed into a system relevant to the task at hand. Rather, we still have a craft industry, but now the application-specific components we build every time are called "objects."</p>
			<p>This approach – designing a whole system as a single software product but calling the bits "objects" – goes under the name of <strong class="bold">Object-Oriented Analysis and Design</strong>. Typically, it is expressed as a way to decompose big problems according to the <em class="italics">data</em> used to solve the problem, so that OOP becomes an "alternative" to functional programming, in which the big problem is decomposed according to the <em class="italics">operations</em> used in its solution. An uncaptioned table in "Using Functions for Easier Programming" by Neil Savage — <a href="https://dl.acm.org/citation.cfm?id=3193776">https://dl.acm.org/citation.cfm?id=3193776</a> from 2018 describes the term Object-Oriented:</p>
			<p><em class="italics">The central mode for abstraction is the data itself, thus the value of a term isn't always predetermined by the input (stateful approach).</em></p>
			<p>The term Functional programming is described as:</p>
			<p><em class="italics">The central mode for abstraction is the function, not the data structure, thus the value of a term is always predetermined by the input (stateless approach).</em></p>
			<p>Never mind that "functional" languages like Haskell have mechanisms designed for handling state, or that plenty of problems we might want to solve in the world have both stateful and stateless aspects!</p>
			<p>This idea of objects-as-data does have its roots in the OOP movement. In his textbook "<em class="italics">A Touch of Class</em>" from 2009, in Section 2.3 "<em class="italics">What is an object</em>?", Bertrand Meyer uses the following definition:</p>
			<p><em class="italics">An object is a software machine allowing programs to access and modify a collection of data.</em></p>
			<p>This is in exact opposition to the usual goals of "encapsulation" or "data hiding" that we have heard about, in which we try to <em class="italics">forbid</em> programs from accessing and modifying our data! In this view, we have the object as a "software machine," which is good as it suggests some kind of independent, autonomous function, but unfortunately, we get the idea that the purpose of this machine is to look after some slice of our data from the overall collection used throughout the program.</p>
			<p>It is this mindset that leads to objects as "active structures," like this typical example in C#:</p>
			<pre>class SomeClass
 {
   private int field;
   public int Field =&gt; field;
 }</pre>
			<p>This satisfies our requirement for encapsulation (the field is private), and our requirement that an object allows programs to access and modify a collection of data. What we have ended up with is no different from a plain old data structure:</p>
			<pre>struct SomeClass
 {
   int Field;
 }</pre>
			<p>The exception is that the C# example requires a function call on each access of the field. There is no <em class="italics">real</em> encapsulation; objects with their own fields can make no guesses about the status of those fields, and a system including such objects can only be understood by considering the whole system. The hoped-for advantage that we could turn our big problem into a composition of small problems has been lost.</p>
			<p>A contributor to this objects-as-data approach seems to have been the attempt to square object-oriented programming with <strong class="bold">Software Engineering</strong>, a field of interest launched in 1968 that aimed to bring product design and construction skills to computer scientists by having very clever computer scientists think about what product design and construction might be like and not ask anybody. Process-heavy and design-artefact-heavy systems, approaches, and "methodologies" (a word that used to mean "the study of method" until highfalutin software engineers took it to mean "method, but a longer word") recommended deciding on the objects, their methods, and properties; the data involved; and the presentation and storage of that data in excruciating detail, all in the name of satisfying a <strong class="bold">Use Case</strong>, which is Software Engineering speak for "a thing somebody might want to do." </p>
			<p>The inside cover of "<em class="italics">Applying UML and Patterns</em>" by Craig Larman (1997) has 22 detailed steps to follow before <strong class="bold">Construction</strong> when constructing a product.</p>
			<p>Objects can be thought of as <em class="italics">simulations</em> of some part of the problem we're trying to solve, and a great way to learn from a simulation is to <em class="italics">interact</em> with it. If our objects are just active structures that hold some data on behalf of a program, then we don't get that benefit: we can't interact with the simulation without building out all of the rest of the program. And indeed that is the goal behind a lot of the "engineering" processes that use objects: while they may pay lip service to iterative and incremental development, they still talk about building a system at once, with each object being a jigsaw puzzle piece that satisfactorily fits its given gap in the puzzle.</p>
			<p>So, let's go back to Bertrand Meyer's definition, and remove the problematic bit about letting a program access an object's data:</p>
			<p><em class="italics">An object is a software machine</em></p>
			<p>A machine is a useful analogy. It's a device (so something that was built by people) that uses energy to produce some effect. Notice the absence of any statement about <em class="italics">how</em> the machine produces that effect, <em class="italics">how</em> the machine consumes its materials, or <em class="italics">how</em> the machine's output is supplied. We've got a thing that does a thing, but if we're going to compose these things together to do other things, we're going to need to know how to do that composition. Adding a constraint takes us from "it's a machine" to "it's a machine that we can use like this".</p>
			<p><em class="italics">An object is a software machine that can collaborate with other software machines by sending and receiving messages.</em></p>
			<p>Now we've got things that do things and can be used together. We don't restrict the level of complexity of the things that are done by each machine (so booking a flight and representing a number are both things that we could build machines to do); just how we would combine them. This has parallels with Brad Cox's software ICs analogy, too. An "integrated circuit" could be anything from a <strong class="bold">NAND</strong> gate to an <strong class="bold">UltraSPARC T2</strong>. We can use any of the IC's together, of any size, if we just know how to deal with their inputs and outputs: what voltage should appear on each pin and what that represents.</p>
			<p>This analogy tells us that our software system is like a big machine that does something useful by composing, powering, and employing smaller component machines. It tells us to worry about whether the things coming out of one machine are useful as inputs to another machine, but not to worry about what's going on inside each machine except in the restricted context of the maintenance of those machines. It tells us to consider at each point whether the machine we have is more useful than not having that machine, rather than tracking the progress toward the construction of some all-powerful supermachine. </p>
			<p>It even tells us that building an <strong class="bold">assembly line</strong> in which input of a certain type is transformed into output of a certain type is a thing we might want to do; something that, otherwise, we might believe is solely the domain of the functional programmer.</p>
			<h2 id="_idParaDest-14"><a id="_idTextAnchor014"/>Drawing an Object</h2>
			<p><em class="italics">I see a red door and I want to paint it black. No colors any more I want them to turn black.</em></p>
			<p><em class="italics">Rolling Stones, Paint it Black</em></p>
			<p>If object-oriented programming is the activity of modelling a problem in software, then the kinds of diagrams (and verbal descriptions) that software teams use to convey the features and behavior of those objects are metamodeling – the modeling of models. The rules, for example, the constraints implied when using <code>metametamodels</code>: the models that describe how the models of the models of the problems will work.</p>
			<h3 id="_idParaDest-15"><a id="_idTextAnchor015"/>Unified Modeling Language</h3>
			<p>Plenty of such systems (I will avoid the word <code>metametamodels</code> from now on) have been used over time to describe object systems. The <strong class="keyword">UML</strong> (<strong class="keyword">Unified Modeling Language</strong>) is the result of combining three prior techniques: the three Elven Kings, Grady Booch, Ivar Jacobson, and James Rumbaugh bent their rings of power (respectively, the <strong class="bold">Booch Method</strong>, <strong class="bold">Object-Oriented Software Engineering</strong>, and the <strong class="bold">Object Modelling Technique</strong> – the latter mostly recognized today because the majority of diagrams in the famous <em class="italics">Design Patterns</em> book are drawn to its rules) to the <em class="italics">One Rational Ring</em>, wielded by Mike Devlin.</p>
			<p><em class="italics">As an aside, Rational started as a company making better Ada applications and tools for other Ada programmers to make better Ada applications, including the R1000 workstation, optimized for running Ada programs and featuring an integrated development environment. The R1000 did not take off but the idea of an IDE did, and through a couple of iterations of their Rose product (as well as the UML and Rational Unified Process), made significant inroads into changing the way organizations planned, designed, and built software.</em></p>
			<p>The UML and, to differing extents, its precursor modelling techniques, represent a completist approach to object modelling in which all aspects of the implementation can be represented diagrammatically. Indeed, tools exist to "round-trip" convert UML into compatible languages like Java and back again into the UML representation.</p>
			<p>The model you create that both encapsulates enough of the "business" aspects of the system to demonstrate that you have solved a problem and enough of the implementation aspects to generate the executable program is not really a model, it <em class="italics">is</em> the program source. In shooting for completeness, the UML family of modelling tools have missed "modelling" completely and simply introduced another implementation language.</p>
			<p>If the goal of message-passing is to solve our big problem through the concerted operation of lots of small, independent computer programs loosely coupled by the communications protocol, then we should be able to look at each object through one of two lenses: internal or external. In fact, the boundary itself deserves special consideration, so there are three views:</p>
			<ol>
				<li value="1">The "external" lens: What messages can I send to this object? What do I need to arrange in order to send them? What can I expect as a result?</li>
				<li>The "internal" lens: What does this object do in response to its messages?</li>
				<li>The "boundary" lens: Does the behavior of this object satisfy the external expectations?</li>
			</ol>
			<p>The final two of these things are closely intertwingled. Indeed some popular implementation disciplines, such as <strong class="bold">Test-Driven Development</strong> lead you to implement the object internals only through the boundary lens, by saying "I need this to happen when this message is received," then arranging the object's internals so that it does, indeed, happen.</p>
			<p>The first is separated from the others, though. From the outside of an object I <em class="italics">only</em> need to know what I can ask it to do; if I also need to know how it does it or what goes on inside, then I have not decomposed my big problem into independent, small problems.</p>
			<p>UML class diagrams include all class features at all levels of visibility: public, package, protected, and private; simultaneously. Either they show a lot of redundant information (which is not to a diagram's benefit) or they expect the modeler to take the completist approach and solve the whole big problem at once, using the word "objects" to give some of that 1980s high-technology feel to their solution. This is a downhill development from Booch's earlier method, in which objects and classes were represented as fluffy cloud-shaped things, supporting the idea that there's probably some dynamism and complexity inside there but that it's not relevant right now.</p>
			<p>Interestingly, as with Bertrand Meyer's statement that "an object is a software machine allowing programs to access and modify a collection of data," explored in the section on <em class="italics">analysis and design</em>, we can find the point at which Grady Booch overshot the world of modelling tools in a single sentence in <em class="italics">Chapter One of his 1991 book Object-Oriented Design with Applications</em>.</p>
			<h4>Note</h4>
			<p class="callout">Perhaps there is a general principle in which the left half of a sentence about making software is always more valuable than the right half. If so, then the (<strong class="bold">Agile Manifesto</strong> — <a href="http://agilemanifesto.org/">http://agilemanifesto.org/</a>) is the most insightfully-designed document in our history.</p>
			<p>The sentence runs thus:</p>
			<p><em class="italics">Object-oriented design's underlying concept is that one should model software systems as collections of cooperating objects...</em></p>
			<p>So far, so good.</p>
			<p><em class="italics">... treating individual objects as instances of a class ...</em></p>
			<p>I would suggest that this is not necessary, and that classes, and particularly inheritance, deserve their own section in this part of the book (see <em class="italics">Finding a Method to Run</em> section).</p>
			<p><em class="italics">... within a hierarchy of classes.</em></p>
			<p>And here we just diverge completely. By situating his objects within "a hierarchy of classes," Booch <em class="italics">is</em> encouraging us to think about the whole system, relating objects taxonomically and defining shared features. This comes from a good intention – inheritance was long seen as the object-oriented way to achieve reuse – but promotes thinking about reuse over thinking about <em class="italics">use</em>.</p>
			<h3 id="_idParaDest-16"><a id="_idTextAnchor016"/>Class-Responsibility-Collaborator</h3>
			<p>Just as the UML represents a snapshot in the development of a way of describing objects, so do CRC cards, introduced by Kent Beck and Ward Cunningham in 1989, and propagated by Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener in their textbook <em class="italics">Designing Object-Oriented Software</em>.</p>
			<p>The CRC card describes three aspects of an object, none of which is a cyclic redundancy check:</p>
			<ul>
				<li>The <em class="italics">Class</em> names</li>
				<li>The <em class="italics">Responsibilities</em> of the object</li>
				<li>The <em class="italics">Collaborators</em> that the object will need to work with</li>
			</ul>
			<p>Not only does this school of design focus on the messaging aspect of objects (the responsibilities will be things I can ask it to do and the collaborators will be other objects it asks to do things), but it introduces a fun bit of <em class="italics">anthropomorphism</em>. You and I can each pick up a card and "play object," having a conversation to solve a problem, and letting that drive our understanding of what messages will be exchanged.</p>
			<p>David West, in his 2004 book, <em class="italics">Object Thinking</em>, presents the object cube, which extends the CRC card into three dimensions by adding five more faces:</p>
			<ul>
				<li>A textual description of instances of the class</li>
				<li>A list of named contracts (these are supposed to indicate "the intent of the class creator as to who should be able to send particular messages," and in his examples are all either "public" or "private")</li>
				<li>The "knowledge required" by an object and an indication of where it will get that knowledge</li>
				<li>The message protocol is a list of messages the object will respond to</li>
				<li>Events generated by the objects</li>
			</ul>
			<p>Some bad news: you can't make a cube out of 3x5 index cards; and you can't buy 5x5 index cards. But that's just an aside. Again, as with using the UML, we've got to record the internals and externals of our object in the same place, and now we need to use large shelves rather than index boxes to store them.</p>
			<p>With both of these techniques, the evolution seems to have been one of additive complexity. Yes, you can draw out the network of objects and messages, oh and while you're here you can also...</p>
			<p>And rationally, each part of each of these metamodels seems to make sense. Of course, at some point, I need to think about the internals of this object; at some point, I need to consider its instance variables; and at some point, I need to plan the events emitted by the object. Yes, but not at the <em class="italics">same</em> point, so they don't need to be visible at the same time on the same model.</p>
			<h3 id="_idParaDest-17"><a id="_idTextAnchor017"/>Jelly Donuts and Soccer Balls</h3>
			<p>Ironically, there <em class="italics">is</em> a form of object diagram that makes this separation between the externals and internals clear, though I have only seen it in one place: The NeXT (and subsequently Apple) <strong class="bold">jelly-donut model</strong> — <a href="http://www.cilinder.be/docs/next/NeXTStep/3.3/nd/Concepts/ObjectiveC/1_OOP/OOP.htmld/index.html">http://www.cilinder.be/docs/next/NeXTStep/3.3/nd/Concepts/ObjectiveC/1_OOP/OOP.htmld/index.html</a> This isn't a tool that programmers use for designing objects, though: it's an analogy used in some documentation.</p>
			<p>It's an analogy that some authors disagree with. In <em class="italics">Object Thinking</em>, David West says that the jelly donut model (which he calls the <strong class="bold">soccer-ball model</strong>, after Ken Auer) is the model of choice of the "traditional developer," while "an object thinker" would represent an object anthropomorphically, using a person.</p>
			<p>West may well argue that the jelly donut/soccer ball model represents traditional thinking because it reflects the Meyer-ish view that your system is designed by working out what data it needs and then carving that up between different objects. Ironically, Bertrand Meyer would probably also reject the soccer ball model, for an unrelated reason: Eiffel follows the <strong class="bold">Principle of Uniform Reference</strong>, in which an object field or a member function (method) is accessed using the same notation. To an Eiffel programmer, the idea that the data is "surrounded" by the methods is superfluous; the jelly donut indicates the use of a broken language that allows the sweet jelly to escape and make everything else sticky.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor018"/>Opposing Functional Programming</h2>
			<p><em class="italics">[An] important aspect of functional programming is that functions do not change the data with which they work [...] Object-oriented imperative languages such as C, Java, or Python change their state as they run. </em></p>
			<p><em class="italics">Neil Savage, (Using Functions for Easier Programming — </em><a href="https://dl.acm.org/citation.cfm?id=3193776">https://dl.acm.org/citation.cfm?id=3193776</a><em class="italics">)</em></p>
			<p>Many programmers define themselves through their tools, and therefore define themselves as <em class="italics">against</em> certain other tools. If you are a .NET programmer, then you do not use Java. If you are a native mobile programmer, then you do not use JavaScript. If you are a React programmer, then you do not use Angular. An affiliation with one tool automatically means a disaffiliation with others.</p>
			<p>Such partisanship is a confirming example of Sayre's law: the arguments are so fierce because the stakes are so low. For people who supposedly work in a field of rationality and science, we're really good at getting emotionally brittle when somebody wants to use a different library, language, text editor, or whitespace symbol than the one we have chosen.</p>
			<p>This fierce disagreement over strongly defended similarities extends to the programming paradigm, too. If you are an object-oriented programmer, then your mortal enemy is the functional programmer—<a href="http://www.sicpers.info/2015/03/inspired-by-swift/">http://www.sicpers.info/2015/03/inspired-by-swift/</a>, and vice versa.</p>
			<h3 id="_idParaDest-19"><a id="_idTextAnchor019"/>Messages Are Just Requests</h3>
			<p>Not so fast! Recall the working definition of objects I have used throughout the antithesis: an object is an isolated, independent computer program that communicates with other programs by passing messages. This tells us nothing about <em class="italics">how</em> to build those isolated, independent computer programs. Particularly, there is no <em class="italics">mandate</em> to have mutable state anywhere. The following interface works as a messaging interface for a time-varying list:</p>
			<pre>public interface MutableList&lt;T&gt; {
  void setElements(T[] elements);
  void appendObject(T element);
  void removeObject(int index) throws OutOfBoundsException;
  void replaceObject(int index, T element) throws OutOfBoundsException;
  int count();
  T at(int index);
 };</pre>
			<p>And so, does this one:</p>
			<pre>public interface TemporalList&lt;T&gt; {
  void setInitialState(T[] elements);
  void appendObject(T element, Time when);
  void removeObject(int index, Time when) throws   InconsistentHistoryException;
  void replaceObject(int index, T element, Time when) throws   InconsistentHistoryException;
  void revertMostRecentChange(Time beforeNow);
  int count(Time when);
  T at(int index, Time when);
 };</pre>
			<p>In the first, time in the list's lifespan is modeled using successive states of the computer memory. In the second, time in the list's lifespan is modeled explicitly, and the history of the list is preserved. Another option is to model evolution using <em class="italics">different objects</em>, turning time into space:</p>
			<pre>public interface ImmutableList&lt;T&gt; {
  ImmutableList&lt;T&gt; addObject(T element);
  ImmutableList&lt;T&gt; removeObject(int index) throws OutOfBoundsException;
  ImmutableList&lt;T&gt; replaceObject(int index, T element) throws OutOfBoundsException;
  int count();
  T at(int index);
 }</pre>
			<p>Now the list looks a lot like a sort of a functional programming list. But it's still an object. In each case, we have defined what <em class="italics">messages</em> the object responds to but, remembering the section on <em class="italics">Telling an Object What to Do</em>, we have not said <em class="italics">anything</em> about what methods exist on that object, and certainly not how they are implemented. The <code>MutableList</code> and <code>TemporalList</code> interfaces use Bertrand Meyer's principle of <code>Datalog</code> programs, or SQL programs, or be stored as a chain of events that is replayed when a query message is received.</p>
			<p>In the <code>ImmutableList</code> interface, commands are replaced by transforms, which ask for a new list that reflects the result of applying a change to the existing list. Again, no restriction on <em class="italics">how</em> you implement those transforms is stated (I could imagine building <code>addObject()</code> by having a new list that delegates every call to the original list, adding 1 to the result of <code>count()</code> and supplying its own value for <code>at(originalCount)</code>; or I could just build a new list with all of the existing elements and the new element), but in this case, it's clear to see that every method can be a pure function based on the content of the object and the message parameters.</p>
			<p>We can see that "pure function based on the content of the object and the message parameters" is the same as "pure function" more clearly by rewriting the interface in Python syntax (skipping the implementations):</p>
			<pre>class ImmutableList:
  def addObject(this, element):
     pass
  def removeObject(this, index):
     pass
  def replaceObject(this, index, element):
     pass
  def count(this):
     pass
  def at(this, index):
     pass</pre>
			<p>It's now easier to see that each of these methods is a pure function in its parameters, where <code>this</code>/<code>self</code> is a parameter that's automatically prepared in other languages (or a part of the method's environment that's automatically closed over in others).</p>
			<p>Nothing about message-passing says, "please do not use functional programming techniques."</p>
			<h3 id="_idParaDest-20"><a id="_idTextAnchor020"/>An Object's Boundary is Just a Function</h3>
			<p>The following subsections were deeply informed by the article Objects as Closures: abstract semantics of object-oriented languages — <a href="https://dl.acm.org/citation.cfm?id=62721">https://dl.acm.org/citation.cfm?id=62721</a>, which builds this view of objects much more rigorously.</p>
			<p>The interface to an object is the collection of messages it responds to. In many cases, this is backed by a collection of methods, each with the same name as the message selector that will invoke it. Not only is this the easiest thing to do, it's also an implementation constraint in many programming languages. The preceding Python implementation of <code>ImmutableList</code> can be visualized in this table:</p>
			<div><div><img alt="" src="img/B15099_01_01.jpg"/>
				</div>
			</div>
			<h6>Figure 3.1: Visualization of ImmutableList after implementation</h6>
			<p>This table can equivalently be replaced by a pure function of type <code>Message Selector-&gt;Method to Invoke</code>. A trivial implementation of the function would look up its input in the left-hand column of the table and return the value it finds in the same row in the right-hand column. An implementation of <code>ImmutableList</code> doesn't need to have any methods at all, choosing functions based on the message selector:</p>
			<pre>	class ImmutableList:
		def __init__(this, elements):
			this.elements = elements
		def __getattr__(this, name):
			if name == "count":
				return lambda: len(this.elements)
			elif name == "at":
				return lambda index: this.elements[index]
			# ...</pre>
			<p>Using this object works the same way as using an object where the methods were defined in the usual way:</p>
			<pre>    &gt;&gt;&gt; il = ImmutableList([1,2,3])
	&gt;&gt;&gt; il.count()
	3
	&gt;&gt;&gt; il.at(0)
	1
	&gt;&gt;&gt;</pre>
			<p>So, whichever way you write out an object, its methods are functions that have access to (close over) the object's internals, and its message interface is one such function that uses the message selector to choose which method to invoke.</p>
			<p>Freed from the fetters of the language's idea of where methods live, we see that the function to look up implementations from selectors can use <em class="italics">any</em> information available to it. If the object knows about another object, it can send the message on to the other object, send a different method in its place, or it could compile a new function and use that. The important idea is that <em class="italics">an object is a function for finding other functions</em>.</p>
			<h3 id="_idParaDest-21"><a id="_idTextAnchor021"/>That Function-Like Boundary? Actually, a Closure Over the Constructor Arguments</h3>
			<p>Our <code>ImmutableList</code> has a constructor method called <code>__init__</code>, which sets up the initial state of the object using its arguments, and then the message-finding <code>__getattr__</code> function, which chooses functions to respond to the messages that are sent to the object.</p>
			<p>An equivalent way to arrange this is to have the constructor function return the message-finding function as a closure over the constructor's arguments (and any transformation implied in "setting up the initial state of the object" can be arranged using local variables that are captured in the closure, too). So, all in all, an object is a single higher-order function: a function that captures its arguments and returns a closure over those arguments that accept messages and then chooses a method to execute the code:</p>
			<pre>    (constructor arguments) -&gt; message -&gt; (method arguments) -&gt; method return type</pre>
			<p>Sticking with Python, and using this insight, <code>ImmutableList</code> is reduced to a single expression:</p>
			<pre>	def ImmutableList(elements):
		return type('ImmutableList',
					(object,),
					{'__getattr__':
					 (lambda this, name:
					 (lambda: len(elements)) if name=="count"
					 else (lambda index: elements[index]) if name=="at"
					 else False)
					})()</pre>
			<p>By the way, this demonstrates why so many object-oriented languages don't seem to have a type system. If "<em class="italics">everything is an object</em>," then even in the most stringent of type systems, everything is a <code>message-&gt;method </code>function, so everything has the same type, and everything type checks.</p>
			<p>The preceding definition of <code>ImmutableList</code> does escape the "everything is an object" type scheme by ending with the phrase <code>else False</code>, meaning "if I didn't find a method, return something that isn't callable, so the user gets a <code>TypeError</code>." A more complete object system would have the object send itself a <code>doesNotRespond</code> message here, and no breaking out into Python's usual world of computation would occur.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/>Capturing Elements of Reusable Design</h2>
			<p><em class="italics">A pattern for increased monitoring for intellectual property theft by departing insiders</em></p>
			<p><em class="italics">Title of (an article in the Proceedings of the 18th Conference of Pattern Languages of Programs — </em><a href="https://dl.acm.org/citation.cfm?id=2579157">https://dl.acm.org/citation.cfm?id=2579157</a><em class="italics">), PLoP'11</em></p>
			<p>Christopher Alexander, while evidently seminal in the field of built architecture, seems pretty lazy as architects go. Why? Because rather than designing a building or even a town <em class="italics">himself</em>, he expects the people who will live, work, shop, and play there to do that for him, and even to build its prototype.</p>
			<p>In fact, this has little to do with laziness; it's because he believes that they are the best people to do the designing as they are the people who best know the uses to which the structure will be put and the problems it will solve. What does he know about that? Not much; what he knows is the expertise architects have gained in solving problems that crop up when designing and constructing towns and buildings.</p>
			<p>In <em class="italics">A Pattern Language: Towns, Buildings and Construction</em>, Alexander and his coauthors and reviewers sought to encapsulate that professional knowledge in a grammar that would allow a user to solve their own construction problems by taking advantage of the solutions known to work by the expert architects. Each pattern describes the problem it solves, the context in which it solves it, and the advantages and limitations of the solution. Some represent instant decisions to be made – the placement of columns in a building construction; others represent experiences to be nurtured gradually – the opening of street cafes to facilitate relaxed interaction between people and their environment. The grammar developed in <em class="italics">A Pattern Language</em> is additive, so each pattern develops ideas that have been introduced previously without depending on patterns that will be seen later, and there are no cyclic references. Each pattern is hyperlinked (old-school and using page numbers) to the preceding patterns it builds upon.</p>
			<p>We could expect that, in taking inspiration from <em class="italics">A Pattern Language</em>, software designers and builders would create a pattern language that allowed users of computers to design and build their own software, by elucidating the problems the users are facing and expressing known approaches to solving those problems. And indeed, that is exactly what happened when Kent Beck and Ward Cunningham published <em class="italics">Using Pattern Languages for Object-Oriented Programs</em> — <a href="http://c2.com/doc/oopsla87.html">http://c2.com/doc/oopsla87.html</a>. The five Smalltalk UI patterns listed in that report are like a microcosm of a <strong class="bold">Human Interface Guidelines</strong> document, written for the <em class="italics">people who will use the interface</em>.</p>
			<p>However, what most of us will find when looking for examples of a pattern language for software construction are the 23 patterns in the 1994 "Gang of Four" book <em class="italics">Design Patterns: Elements of Reusable Design</em> by Gamma, Helm, Johnson, and Vlissides. Compared with the 253 architectural design patterns documented by Alexander et al., the software pattern language seems positively anemic. Compared with practice, the situation looks even worse. Here are the three patterns that see regular use in modern development:</p>
			<ul>
				<li><code>Iterator</code> pattern yourself; it's the one that programming language designers have worked out how to supply for you, via the <code>for (element in collection)</code> construct.</li>
				<li><strong class="bold">Singleton</strong>: You'll have only built <em class="italics">Singleton</em> so that you could write that blog post about why <em class="italics">Singleton</em> is "Considered Harmful."</li>
				<li><strong class="bold">Abstract Factory</strong>: The butt of all jokes about Java frameworks by people who haven't used Java frameworks.</li>
			</ul>
			<p>Here's the thing: the <em class="italics">Gang of Four</em> book is actually very good, and the patterns are genuinely repeatable patterns that can be identified in software design and that solve common problems. But as Brian Marick argued in Patterns Failed. Why? Should we care?—<a href="https://www.deconstructconf.com/2017/brian-marick-patterns-failed-why-should-we-care">https://www.deconstructconf.com/2017/brian-marick-patterns-failed-why-should-we-care</a>, the 23 patterns discussed therein are <em class="italics">implementation</em> patterns, and software implementors (that's us) don't want repeatable patterns; we want <em class="italics">abstraction</em>. Don't tell me "Oh, I've seen that before, what you do is..."; tell me "Oh, I've seen that before, here's the <code>npm</code> module I wrote."</p>
			<p>The big winner for software reuse was not information that could be passed from one programmer to another, but information that could be passed from one <em class="italics">lawyer</em> to another, which allowed other information to be passed from one programmer to <em class="italics">another's program</em>. The free software license (particularly, due to the conservative nature of technologists in business, the non-copyleft free software licenses like the MIT or BSD) permitted some programmers to publish libraries to CTAN and its spiritual successors, and permitted a whole lot of other programmers to incorporate those libraries into their works.</p>
			<p>In that sense, the end situation for software reuse has been incredibly similar to the "software ICs" that Brad Cox described, for example, in <em class="italics">Object-Oriented Programming: An Evolutionary Approach</em>. He proposed that we would browse the catalogue (the <code>npm</code> repository) for software ICs that look like they do what we want, compare their data sheets (the <code>README.md</code> or Swagger docs), then pick one and download it for integration into our applications (<code>npm install</code>).</p>
			<p>Anyway, back to design patterns. Marick suggested that the way we work means that we can't benefit from implementation patterns because we don't rely on repeated practice in implementation. Some programmers do participate in <strong class="bold">Code Kata</strong> — <a href="http://codekata.com/">http://codekata.com/</a>, a technique for instilling repeated practice in programming, but by and large we try to either incorporate an existing solution or try something new, not find existing solutions and solve problems in similar ways.</p>
			<p>Indeed, we could vastly shrink the Gang of Four book by introducing <strong class="bold">Strategy (315)</strong> and describing all of the other problems in its terms. Abstract Factory? A <strong class="bold">Strategy (315)</strong> for creating objects. Factory Method? The same. Adapter? A <strong class="bold">Strategy (315)</strong> for choosing integration technologies. State? A <strong class="bold">Strategy (315)</strong> for dealing with time. But we don't do that, because we think of these as different problems, so describe them in different terms and look for different solutions.</p>
			<p>So, abstraction has to stop somewhere. Particularly, it has to stop by the time we're talking to the product owners or sponsors, as we're typically building specific software tools to support specific tasks. Built architecture has techniques for designing residences, offices, shops, and hotels, rather than "buildings," A house for a young single worker is different from a house for a retired widow, although both are residences with one occupant. So, this points us, as Brian Marick concludes, to having design patterns in our software's problem domain, telling us how domain experts address the problems they encounter. We might have good abstractions for stateful software, or desktop application widgets, or microservice-based service architecture, but we have to put them to specific ends, and the people who know the field know the problems they're trying to solve.</p>
			<p>And indeed, that is one of the modern goals of the Pattern Language of Programming conference series and the software patterns community. I expected that, on first reading, the pull quote chosen for this section ("A pattern for increased monitoring for intellectual property theft by departing insiders") would raise a few cynical laughs: "Wow, the patterns folks are so far down the rabbit hole that they're writing patterns for <em class="italics">that</em>?" Well, yes, they are, because it's a problem that is encountered multiple times by multiple people and where knowledge of the common aspects of the solution can help designers. Any enterprise IT architect, CISO, or small company HR person is going to know that leavers, particularly those who left due to disagreements with management or being poached by competitors, represent an increased risk of IP theft and will want a way to solve that problem. Here, the pattern language shows the important dimensions of the problem, the facets of the solution, and the benefits and drawbacks of the solution.</p>
			<p>A quote from the pattern description is revealing:</p>
			<p><em class="italics">The authors are unaware of any implementation of the pattern in a production environment.</em></p>
			<p>This means that, while the solution does (presumably and hopefully) capture expert knowledge about the problem and how to solve it, it is not tested. The design patterns from the Beck and Cunningham paper (and Beck's later <em class="italics">Smalltalk Best Practice Patterns</em>), and indeed the Gang of Four book, were all based on <em class="italics">observation</em> of how problems had commonly been solved. There were not lots of C++ or Smalltalk programs that all had classes called <code>AbstractFactory</code>, but there <em class="italics">were</em> lots of C++ or Smalltalk programs that solved the "We need to create families of related or dependent objects without specifying their concrete classes" problem.</p>
			<p>On the other hand, there is nobody outside of an SEI lab who has used "Increased Monitoring for Intellectual Property Theft by Departing Insiders" as their solution to, well, that. So, perhaps patterns have gotten out of hand.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/>Finding a Method to Run</h2>
			<p><em class="italics">Don't go out of your way to justify stuff that's obviously cool. Don't ridicule ideas merely because they're not the latest and greatest. Pick your own fashions. Don't let someone else tell you what you should like.</em></p>
			<p><em class="italics">Larry Wall, (Perl, the first postmodern computer language—</em><a href="https://www.perl.com/pub/1999/03/pm.html/">https://www.perl.com/pub/1999/03/pm.html/</a>)</p>
			<p>The Perl community has a mantra: <em class="italics">TIMTOWTDI</em> (pronounced "Tim Toady"). It stands for "There Is More Than One Way to Do It" and reflects the design principle that the language should enable its users to write programs in the way in which they are thinking and not in the way that the language designer thought about it. Of course, TIMTOWTDI is not the only way to do it, and the <strong class="bold">Zen of Python</strong>—<a href="http://wiki.c2.com/?PythonPhilosophy">http://wiki.c2.com/?PythonPhilosophy</a> takes a different (though not incompatible) tack:</p>
			<p><em class="italics">There should be one-- and preferably only one --obvious way to do it.</em></p>
			<p>So, how is a method found? There is more than one way to do it. The first, and easiest to understand, is that an object has a method with the same name as the message selector, and the language assumes that when you send that message, it's because you want to invoke that method. That's how this looks in Javascript:</p>
			<pre>    const foo = {
	  doAThing: () =&gt; { console.log("I'm doing a thing!"); }
	}
	
	foo.doAThing();</pre>
			<p>The next way is the most general, and doesn't exist in all languages and is made difficult to use in some. The idea is to have the object <em class="italics">itself</em> decide what to do in response to a message. In Javascript that looks like this:</p>
			<pre>    const foo = new Proxy({}, {
	  get: (target, prop, receiver) =&gt; (() =&gt; {
	    console.log("I'm doing my own thing!");
      }),
	});
	 
	foo.doAThing();</pre>
			<p>While there are many languages that don't have <em class="italics">syntax</em> for finding methods in this way, it's actually very easy to write yourself. We saw in the section on functional programming that an object is just a function that turns a message into a method, and so any language that lets you write functions returning functions will let you write objects that work the way you want them to. This argument is also pursued in the talk Object-Oriented Programming in Functional Programming in Swift—<a href="https://www.dotconferences.com/2018/01/graham-lee-object-oriented-programming-in-functional-programming-in-swift">https://www.dotconferences.com/2018/01/graham-lee-object-oriented-programming-in-functional-programming-in-swift</a>.</p>
			<p>Almost all programming languages that have objects have a fall-through mechanism, in which an object that does not have a method matching the message selector will look by default at <em class="italics">another</em> object to find the method. In Javascript, fully bought into the worldview of Tim Toady, there are two ways to do this (remember that this is already the <em class="italics">third</em> way to find methods in Javascript). The first, classic, original recipe Javascript way, is to look at the object's prototype:</p>
			<pre>    function Foo() {};
	Foo.prototype.doAThing = () =&gt; { console.log("Doing my prototype's thing!"); };
	
	new Foo().doAThing();</pre>
			<p>And the second way, which in some other languages is the <em class="italics">only</em> way to define a method, is to have the object look at its class:</p>
			<pre>    class Foo {
	  doAThing() { console.log("Doing my class's thing!"); }
	}
	
	new Foo().doAThing();</pre>
			<p>A little bit of honesty at the expense of clarity here: these last two are actually just different syntax for the same thing; the method ends up being defined on the object's prototype and is found there. The mental model is different, and that's what is important.</p>
			<p>But we can't stop there. What if <em class="italics">that</em> object can't find the method? In the prototype case, the answer is clear: it could look at its prototype, and so on, until the method is found, or we run out of prototypes. To an external user of an object, it looks like the object has all of the behavior of its prototype <em class="italics">and</em> the things it defines (which may be other, distinct features, or they may be replacements for things that the prototype already did). We could say that the object <em class="italics">inherits</em> the behavior of its prototype.</p>
			<p>The situation with inheritance when it comes to classes is muddier. If my object's class doesn't implement a method to respond to a message, where do we look next? A common approach, used in early object environments such as Simula and Smalltalk, and in Objective-C, Java, C#, and others, is to say that a class is a refinement of a <em class="italics">single</em> other class, often called the superclass, and to have instances of a class inherit the behavior defined for instances of the superclass, and its superclass, until we run out of <code>superclasses</code>.</p>
			<p>But that's quite limiting. What if there are two different classes of object that one object can be seen as a refinement of? Or two different classes that describe distinct behaviors it would make sense for this object to inherit? Python, C++, and others allow a class to inherit from <em class="italics">multiple</em> other classes. When a message is sent to an object, it will look for a method implementation in its class, then in...</p>
			<p>...and now we get confused. It could look breadth-first up the tree, considering each of its parents, then each of <em class="italics">their</em> parents, and so on. Or it could look depth-first, considering its first superclass, and <em class="italics">its</em> first superclass, and so on. If there are multiple methods that match a single selector, then which is found will depend on the search strategy. And of course, if there are two matching methods but with different behavior, then the presence of one may break features that depend on the behavior of the other.</p>
			<p>Attempts have been made to get the benefits of multiple inheritance without the confusion. <strong class="bold">Mixins</strong>—<a href="https://dl.acm.org/citation.cfm?id=97982">https://dl.acm.org/citation.cfm?id=97982</a> represent "abstract subclasses," which can be attached to any superclass. This turns a single-superclass inheritance system into one that's capable of supporting a limited form of multiple inheritance, by delegating messages to the superclass <em class="italics">and any mixins</em>.</p>
			<p>However, this does not address the problem that conflicts will arise if multiple mixins, or a superclass and a mixin, supply the same method. A refinement to the idea of mixins, called <strong class="bold">traits</strong>, introduces additional rules that avoid the conflicts. Each trait exposes the features it provides, and the features it requires, on the class into which it is mixed. If the same feature is provided by two traits, it must either be renamed in one or be removed from both and turned into a requirement. In other words, the programmer can choose to resolve the conflict themselves by building a method that does what both of the traits need to do.</p>
			<p>So, inheritance is a great tool for code reuse, allowing one object to borrow features from another to complete its task. In "<em class="italics">Smalltalk-80: The Language and its Implementation</em>," that is the justification for inheritance:</p>
			<p><em class="italics">Lack of intersection in class membership is a limitation on design in an object-oriented system since it does not allow any sharing between class descriptions. We might want two objects to be substantially similar, but to differ in some particular way.</em></p>
			<p>Over time, inheritance came to have stronger implications for the intention of the designer. While there was always an "is-a" relationship between an instance and its class (as in, an instance of the <code>OrderedCollection</code> class <em class="italics">is</em> an <code>OrderedCollection</code>), there came to be a subset relationship between a class and its subclasses (as in, <code>SmallInteger</code> is a subclass of <code>Number</code>, so any instance of <code>SmallInteger</code> is also an instance of <code>Number</code>). This then evolved into a subtype relationship (as in, you have only used inheritance correctly if any program that expects an instance of a class also works correctly when given an instance of any subclass of that class), which led to the restrictions that tied object-oriented developers in knots and led to "favor composition over inheritance": you can only get reuse through inheritance if you also conform to these other, unrelated requirements. The rules around subtypes are perfectly clear, and mathematically sound, but the premise that a subclass <em class="italics">must</em> be a subtype does not need to be upheld.</p>
			<p>Indeed, there's another assumption commonly made that implies a lot of design intent: the existence of classes. We have seen that Javascript gets on fine without classes, and when classes were added to the language, they were implemented in such a way that there is really no "class-ness" at all, with classes being turned into prototypes behind the scenes. But the <em class="italics">presence</em> of classes in the design of a system implies, well, the presence of classes: that there is some set of objects that share common features and are defined in a particular way.</p>
			<p>But what if your object truly is a hand-crafted, artisanal one-off? Well, the class design community has a solution for that: Singleton – the design pattern that says, "class of one." But why have a <em class="italics">class</em> at all? At this point, it's just additional work, when all you want is an <em class="italics">object</em>. Your class is now responsible for three aspects of the system's behavior: the object's work, the work of making the object, and the work of making sure that there is only one of those objects. This is a less cohesive design than if you just made one object that did the work.</p>
			<p>If it were possible (as it is in Javascript) to first make an object, then make another, similar object, then more, then notice the similarities and differences and encapsulate that knowledge in the design of a class that encompasses all of those objects, then that one-off object would not need to be anything more than an object that was designed once and used multiple times. There would be no need to make a class of all objects that are similar to that one, only to constrain class membership again to ensure that the singleton instance cannot be joined by any compatriots.</p>
			<p>But as you've probably experienced, most programming languages only give you one kind of inheritance, and <em class="italics">that</em> is often the "single inheritance, which we also assume to mean subtyping" variety. It's easy to construct situations where multiple inheritance makes sense (a book is both a <em class="italics">publication</em> that can be catalogued and shelved and it is a <em class="italics">product</em> that can be priced and sold); situations where single inheritance makes sense (a <em class="italics">bag</em> has all the operations of a <em class="italics">set</em>, but adding the same object twice means it's in the <em class="italics">bag</em> twice); and situations where customizing a prototype makes sense (our hypothesis is that simplifying the <strong class="bold">Checkout</strong> interaction by applying a fixed shipping cost instead of letting the customer choose from a range of options will increase completion among customers attempting to check out). It's easy to consider situations in which all three of those cases would simultaneously apply (an online bookstore could easily represent books, bags, and checkouts in a single system), so why is it difficult to model all of those in the same object system?</p>
			<p>When it comes down to it, inheritance is just a particular way to introduce delegation – one object finding another to forward a message on to. The fact that inheritance is constrained to specific forms doesn't stop us from delegating messages to whatever objects we like, but it does stop us from making the <em class="italics">reasons</em> for doing so obvious in our designs.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/>Building Objects</h2>
			<p><em class="italics">What then is a personal computer? One would hope that it would be both a medium for containing and expressing arbitrary symbolic notions, and also a collection of useful tools for manipulating these structures, with ways to add new tools to the repertoire.</em></p>
			<p><em class="italics">Alan C. Kay, "A Personal Computer for Children of All Ages"</em></p>
			<p>Smalltalk is both a very personal and a very live system. This affected the experience of using, building, and sharing objects built in the system, which were all done in a way very different from the edit-compile-assemble-link-run workflow associated with COBOL and later languages.</p>
			<p><em class="italics">As an aside, I'm mostly using "Smalltalk" here to mean "Smalltalk-80 and later things that derived from it without changing the experience much." Anything that looks and feels "quite a lot like" a Smalltalk environment, such as Pharo or Squeak, is included. Things that involve a clearly more traditional workflow, like Java or Objective-C, are excluded. Where to draw the line is left intentionally ambiguous: try out </em><strong class="bold">GNU Smalltalk</strong><em class="italics">—</em><a href="http://smalltalk.gnu.org/">http://smalltalk.gnu.org/</a><em class="italics">) and decide whether you think it is "a Smalltalk" or not.</em></p>
			<p>A Smalltalk environment is composed of two parts: the virtual machine can execute Smalltalk bytecode, and the image contains Smalltalk sources, bytecode, and the definitions of classes and objects.</p>
			<p>So, the image is both personal and universal. Personal in the sense that it is unique to me, containing the objects that I have created or acquired from others; universal in the sense that it contains the whole system: there are no private frameworks, no executables that contain the Directory Services objects but not the GUI objects, and no libraries to link before I can use networking.</p>
			<p>This makes it very easy to build things: I make the objects I need, and I find and use the objects that I can already take advantage of. On the other hand, it makes sharing quite fraught: if I need to make a change to a system object for some reason, you cannot take in my change without considering the impact that change will have on everything else in your image. If you want to add my class to your image, you have to make sure that you don't already have a class with that name. We cannot both use the same key on the <code>Smalltalk</code> dictionary for different purposes.</p>
			<p>It's also live, in that the way you modify the image is by interacting with it. Methods are implemented as Smalltalk bytecode (though that bytecode may simply be a request to execute a "primitive method" stored on the virtual machine) by writing the method into a text field and sending a message to the compiler object asking it to compile the method. Classes are added by sending a message to an existing class, asking it to create a subclass. Objects are created by sending a <code>new</code> message to a class.</p>
			<p>While there is editing, compilation and debugging, this all takes place within the image. This makes for a very rapid prototype and feedback experience (unsurprising, as one vision behind Smalltalk was to let children explore the world and computers in tandem — <a href="https://mprove.de/diplom/gui/kay72.html">https://mprove.de/diplom/gui/kay72.html</a>. Any change you make affects the system you are using, and its effects can be seen without rebuilding or quitting an application to launch it again. Similarly, the system you are using affects the changes you are making: if an object encounters a message to which it does not respond or an assertion is not satisfied, then the debugger is brought up, so you can correct your code and carry on.</p>
			<p>The fast feedback afforded by building UIs out of the objects that represent UI widgets was used by lots of <strong class="bold">Rapid Application Development</strong> tools, such as NeXT's Interface Builder, Borland's Delphi and Microsoft's Visual Basic. These tools otherwise took a very different position to the trade-offs described previously.</p>
			<p>While an IDE like Eclipse might be made out of Java, a Java developer using Eclipse is not writing Java that modifies the Eclipse environment, even where the Java package they are writing is an Eclipse plugin. Instead, they use the IDE to host tools that produce <em class="italics">another</em> program containing their code, along with references to other packages and libraries needed for the code to work. </p>
			<p>This approach is generic rather than personal (anyone with the same collection of packages and libraries can make the standalone code work without any step integrating things into their image) and specific rather than universal (the resulting program – mistakes aside – contains only the things needed by that program).</p>
			<p>This one key difference – that there is a "build phase" separating the thing you're making from the thing you're making it in – is the big distinction between the two ways of building objects, and one of the ways in which the transfer of ideas in either direction remains imperfect.</p>
			<p>Those Rapid Application Development tools with their GUI builders let you set up the UI widgets from the vendor framework and configure their properties, by working with live objects rather than writing static code to construct a UI. In practice, the limitations on being able to do so are:</p>
			<ul>
				<li>To understand the quality of a UI, you need to work with the real information and workflows the interface exposes, and that is all in the program source that's sat around in the editor panes and code browsers, waiting to be compiled and integrated with the UI layout into the (currently dormant) application.</li>
				<li>Changes outside the capability of the UI editor tool cannot be reflected within it. Changing the font on a label is easily tested; writing a new text transform to be applied to the label's contents is not.</li>
				<li>The bits of a UI that you can test within a UI builder are usually well-defined by the platform's interface guidelines anyway, so you never <em class="italics">want</em> to change the font on a label.</li>
			</ul>
			<p>In practice, even with a UI builder you still have an edit-build-debug workflow.</p>
			<p>A similar partial transfer of ideas can be seen in test-driven development. A quick summary (obviously, if you want the long version, you could always <em class="italics">buy my book</em>—<a href="https://qualitycoding.org/test-driven-ios-development-book/">https://qualitycoding.org/test-driven-ios-development-book/</a>) is that you create an object incrementally by thinking of the messages you want to send it, then what it should do in response, then you send those messages and record whether you get the expected responses. You probably do not get the expected response, as you have not told the object how to behave yet, so you add the bit of behavior that yields the correct response and move on to the next message, after doing a bit of tidying up.</p>
			<p>In the world of Smalltalk, we have already <a id="_idTextAnchor025"/>seen that something unexpected happening leaves you in the debugger, where you can patch up the thing that's broken. So, the whole of the preceding process can be resummarised as "think of a message, type it in, hit <em class="italics">do it</em>, edit the source until the debugger stops showing up," and now you have an increment of working software in your image.</p>
			<p>In the world of Java, even though the same person wrote both the SUnit and JUnit testing tools, the process is (assuming you already have a test project with the relevant artefacts):</p>
			<ol>
				<li value="1">Write the code to send the message</li>
				<li>Appease the compiler</li>
				<li>Build and run the test target</li>
				<li>Use the output to guide changes, back in the editor</li>
				<li>Repeat 3 and 4 until the test passes</li>
			</ol>
			<p>So, there's a much longer feedback loop. That applies to any kind of feedback, from acceptance testing to correctness testing. You can't build the thing you're building from within itself, so there's always a pause as you and your computer switch context.</p>
			<p>The reason for this context switch is only partly due to technology: in 2003, when Apple introduced Xcode, they made a big deal of "fix and continue," a facility also available in Java environments, amongst others: when the source code is changed, within certain limits, the associated object file can be rebuilt and injected into the running application without having to terminate and re-link it. However, that is typically not how programmers <em class="italics">think</em> about their activities. The worldview that lends us words like "toolchain" and "pipeline" is one of sequential activities, where a program may <em class="italics">end up</em> "in production" but certainly doesn't <em class="italics">start</em> there. People using the programs happens at the end, when the fun is over.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor026"/>Conclusion to Part One</h2>
			<p>We have seen that Object-Oriented Programming is indeed, as many detractors suggest, a complex paradigm with many moving parts. We have also seen that this complexity is not essential: at its core is a single idea that a problem can be modeled as lots of distinct, interacting agents, and that each of those agents can be modeled as a small, isolated computer program. The solution to the original problem is found in the interaction between those agents, which is mediated by message passing.</p>
			<p>Some of the incidental complexity seems to have been added by people wanting to make their mark: the proliferation in design patterns appears to have occurred because it is always easier to add a new pattern than to consolidate existing ones; however much some people might like to erase Singleton from history. Objects are not "just" decomposition and message-passing, they are that <em class="italics">and</em> providing access to a program's data, or that <em class="italics">and</em> a hierarchy of classes.</p>
			<p>Much of the complexity associated with objects comes from another source: trying to treat object-oriented programming as much like the structured, procedural, imperative processes that came before, and map its terminology onto the thought structures and workflows of the established ways of writing software. This is the "structured on-ramp" of this section's introduction, in which OOP is seen as an extension to existing ideas, and programs are made "better" by adding objects in the same way that food is made "better" by sprinkling paprika on top. Thus, it is that Ann Weintz could say that "A NeXT Object is simply a piece of C code" in <em class="italics">Writing NeXT Applications.</em> Thus, object-oriented software engineering is about building complex software systems by careful, top-down analysis of the procedures (or bottom-up analysis of the data and its manipulations), while also as a side activity creating a hierarchy of classes with particular relationships.</p>
			<p>If objects are something you do <em class="italics">as well as</em> writing software, then no wonder it is harder than not using the objects! OOP seems to have failed, but it may not even have been attempted.</p>
		</div>
	</body></html>