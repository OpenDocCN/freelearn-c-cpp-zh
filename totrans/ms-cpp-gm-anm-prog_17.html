<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer172" class="Basic-Text-Frame">
    <h1 class="chapterNumber">13</h1>
    <h1 id="_idParaDest-373" class="chapterTitle">Adding Simple Navigation</h1>
    <p class="normal">Welcome to <a href=""><em class="italic">Chapter 13</em></a>! In the previous chapter, we created a separate octree to enhance collision detection, allowing us to detect collisions between instances and level geometry in a quick and computationally cheap way. Then we added simple gravity to the application to keep the instances on the ground of the map, eventually resulting in the instances walking on the level floor and small hills. Finally, we used inverse kinematics on the feet of the instances to keep both feet on the ground when climbing hills or sloped areas of a map.</p>
    <p class="normal">In this chapter, we will add pathfinding and navigation. We start with a brief overview of methods used for navigation in computer games, followed by an exploration and the implementation of the A* path-finding algorithm. Next, we will add navigation targets to the application, enabling a simple way to place path destinations in the virtual world. At the end of the chapter, we will implement the navigation toward the waypoints, allowing the instances to walk or run toward a defined target.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">An overview of different ways to navigate</li>
      <li class="bulletList">The A* path-finding algorithm</li>
      <li class="bulletList">Adding navigation targets to the map</li>
      <li class="bulletList">Navigating instances to a target</li>
    </ul>
    <h1 id="_idParaDest-374" class="heading-1">Technical requirements</h1>
    <p class="normal">The example code for this chapter is available in the <code class="inlineCode">chapter13</code> folder, in the <code class="inlineCode">01_opengl_navigation</code> subfolder for OpenGL and the <code class="inlineCode">02_vulkan_navigation</code> subfolder for Vulkan.</p>
    <h1 id="_idParaDest-375" class="heading-1">An overview of different ways to navigate</h1>
    <p class="normal">Pathfinding and navigation <a id="_idIndexMarker706"/>have been used in video games for much longer than one might think. Let’s explore a couple of navigation methods.</p>
    <h2 id="_idParaDest-376" class="heading-2">Distance-based navigation</h2>
    <p class="normal">One of the oldest games using a simple algorithm to mimic intelligent behavior for enemies is <strong class="screenText">Pac-Man</strong> by <strong class="screenText">Namco</strong>. Each of the four <a id="_idIndexMarker707"/>ghosts (Blinky, Pinky, Inky, and Clyde) has a slightly different kind of “character,” created only by the target point of the ghost’s movement.</p>
    <p class="normal">While the red ghost (Blinky) is<a id="_idIndexMarker708"/> chasing Pac-Man directly, the pink ghost (Pinky) and the blue ghost (Inky) will try to get in front of Pac-Man, effectively trying to surround the player. The fourth ghost (the orange Clyde) has “a mind of its own” and switches between chasing the player and running away.</p>
    <p class="normal">The decision about the new path to choose is made only at the intersections in the game’s maze and is based entirely on the distance to the target tile for all possible ways at the intersection. The game does not use more advanced look-ahead path planning, sometimes leading to a bad decision. <em class="italic">Figure 13.1</em> shows such a decision situation at an intersection:</p>
    <figure class="mediaobject"><img src="../Images/B22428_13_01.png" alt="" width="874" height="578"/></figure>
    <p class="packt_figref">Figure 13.1: Navigation decision of the red ghost in Pac-Man</p>
    <p class="normal">In <em class="italic">Figure 13.1</em>, the green box is the field triggering a decision to go left or right and the two dashed green lines are the direct distances to the red-outlined target tile. Even though the right path is shorter, the left path will be chosen due to the shorter decision distance on the left, creating erratic behavior of the ghost. A link is available in the <em class="italic">Additional resources</em> section with in-depth information about the internals of ghost navigation.</p>
    <p class="normal">Simple distance-based navigation is still used in games today, for instance, to find the spot where an enemy could intercept the player, based on the speed and direction of both entities. Planning the path to the player is then done with a graph-based navigation algorithm.</p>
    <h2 id="_idParaDest-377" class="heading-2">Graph-based navigation</h2>
    <p class="normal">In a graph, search algorithms use <a id="_idIndexMarker709"/>the nodes of a graph to describe locations <a id="_idIndexMarker710"/>on a game map and the edges to describe the connections between the nodes. By building a graph of the map, the shortest path between two locations can be found in an organized manner.</p>
    <p class="normal">Several graph algorithms are used in navigation. The most common ones are:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Depth-First Search</strong> (<strong class="keyWord">DFS</strong>)</li>
      <li class="bulletList"><strong class="keyWord">Breadth-First Search</strong> (<strong class="keyWord">BFS</strong>)</li>
      <li class="bulletList">Dijkstra’s algorithm</li>
      <li class="bulletList">A* (pronounced “A star”)</li>
    </ul>
    <h3 id="_idParaDest-378" class="heading-3">DFS and BFS algorithms</h3>
    <p class="normal">Both of these are <a id="_idIndexMarker711"/>simple algorithms. While DFS traverses the graph “depth-first,” from<a id="_idIndexMarker712"/> the start node to the most distant node, BFS visits the<a id="_idIndexMarker713"/> nearest nodes first, advancing in “rings” to the<a id="_idIndexMarker714"/> next nodes. <em class="italic">Figure 13.2</em> shows an example graph made of six nodes named A to F:</p>
    <figure class="mediaobject"><img src="../Images/B22428_13_02.png" alt="" width="970" height="480"/></figure>
    <p class="packt_figref">Figure 13.2: BFS and DFS</p>
    <p class="normal">The BFS algorithm on the left side of <em class="italic">Figure 13.2</em> starts with the closest nodes (B, C, and D) after the root node (A) and then traverses to nodes E and F. The DFS algorithm on the right side of <em class="italic">Figure 13.2</em> traverses child node D and D’s child node (F) first, advancing to nodes C and E, and, finally, to node B.</p>
    <h3 id="_idParaDest-379" class="heading-3">Dijkstra’s algorithm</h3>
    <p class="normal">Dijkstra’s algorithm adds weights to the edges of a graph. The weights can be seen as costs or distances to travel from one node to<a id="_idIndexMarker715"/> another, depending on the problem to solve. Dijkstra’s algorithm <a id="_idIndexMarker716"/>traverses the entire graph, building a table containing the shortest paths from a start node to all other nodes of the graph.</p>
    <p class="normal"><em class="italic">Figure 13.3</em> shows the starting graph and the result after all steps of the algorithm:</p>
    <figure class="mediaobject"><img src="../Images/B22428_13_03.png" alt="" width="1305" height="403"/></figure>
    <p class="packt_figref">Figure 13.3: A graph and the shortest distances from A to all other nodes</p>
    <p class="normal">By using Dijkstra’s algorithm, any weighted graph can be traversed to find the paths with the lowest costs (or distances) from<a id="_idIndexMarker717"/> one node to all other nodes, but the algorithm must be rerun for every start node. For a full description of the algorithm, a link in the <em class="italic">Additional resources</em> section is <a id="_idIndexMarker718"/>provided showing the steps of finding the shortest distances for the graph in <em class="italic">Figure 13.3</em>.</p>
    <h3 id="_idParaDest-380" class="heading-3">A* algorithm</h3>
    <p class="normal">A* uses Dijkstra’s algorithm as<a id="_idIndexMarker719"/> a basis, but two additions are made:</p>
    <ul>
      <li class="bulletList">A so-called <strong class="keyWord">heuristic</strong> is<a id="_idIndexMarker720"/> added to each node, stating the estimated distance from each node to the<a id="_idIndexMarker721"/> target node.</li>
      <li class="bulletList">The algorithm searches from a start node to a specified target node and usually terminates when the target node has been reached.</li>
    </ul>
    <p class="normal">By combining the distance from the start node to a node and the estimated distance from the same node to the target node and using the shortest sum while traversing to the next node, A* does a directed search toward the target node. So, instead of doing an undirected search like BFS or DFS, A* always heads in the direction of the target node. We will discuss A* in depth in the <em class="italic">The A* path-finding algorithm</em> section.</p>
    <p class="normal">One drawback of the algorithms in this section is that they have to recreate the entire path if the target is not static. For dynamic targets, algorithms like LPA*, D*, or D*-Lite could deliver better results. Also, several other path-finding algorithms have been created since the introduction of A*, aiming for special environments like in robotics, or to further optimize the outcome path-finding process, like in Theta*.</p>
    <p class="normal">Before exploring A*, let’s look at another popular navigation type in video games, using triangles or other polygons to describe the walkable area for bots and NPCs, and also take a short look at machine learning as an alternative version to create navigation data.</p>
    <h2 id="_idParaDest-381" class="heading-2">Mesh-based navigation</h2>
    <p class="normal">Simple games like Pac-Man and many strategy games use distance-based navigation by dividing the world into a grid, usually<a id="_idIndexMarker722"/> built from rectangular or hexagonal<a id="_idIndexMarker723"/> structures. But the needs of three-dimensional games (like an open world) or first- and third-person exploration and fighting games are different. Due to overlapping parts of the virtual world, a three-dimensional structure is needed to be able to guide computer-controlled characters through the map.</p>
    <p class="normal">Most games with three-dimensional maps use either navigation meshes, area awareness, or a combination of both.</p>
    <h3 id="_idParaDest-382" class="heading-3">Navigation meshes</h3>
    <p class="normal"><strong class="keyWord">Navigation meshes</strong> (also called <strong class="keyWord">NavMeshes</strong>) were introduced in <a id="_idIndexMarker724"/>games around the year 2000. A navigation mesh is an additional data structure made of polygons (triangles in most implementations), overlaying the level geometry. The polygons in a navigation mesh mark the walkable area of a level, omitting any objects and structures a computer-controlled <a id="_idIndexMarker725"/>character could collide with.</p>
    <p class="normal">By using a navigation mesh, a bot or NPC can walk around in the virtual world while avoiding costly collision checks with static level geometry if the character stays on the navigation mesh. Only if the character can leave the navigation mesh are collision checks required. In combination with a graph-based<a id="_idIndexMarker726"/> algorithm like A*, fine-grained control of the behavior of computer-controlled characters is possible. A link to a comprehensive introduction to pathfinding with navigation meshes is available in the <em class="italic">Additional resources</em> section. <em class="italic">Figure 13.4</em> shows a simple example:</p>
    <figure class="mediaobject"><img src="../Images/B22428_13_04.png" alt="" width="1160" height="953"/></figure>
    <p class="packt_figref">Figure 13.4: Navigation mesh with start (green), target (red), and path from start to target</p>
    <p class="normal">In <em class="italic">Figure 13.4</em>, the top picture shows the shortest possible path from the starting triangle (green) to the target triangle (red) by using the next vertex in a line of sight to the next sharp corner of the mesh.</p>
    <p class="normal">In comparison, the path in the middle picture uses the triangle centers as graph nodes for the path-finding algorithm, and the bottom picture uses the inner triangle edges as graph nodes.</p>
    <p class="normal">The path’s quality <a id="_idIndexMarker727"/>depends on the mesh and which part or parts of a triangle will be used for the graph node. Combinations of the methods in <em class="italic">Figure 13.4</em> are possible, so both the center and the middle of triangle edges could be used as graph nodes. The resulting path can also be smoothed by skipping to the next directly visible node and by using splines for the curves.</p>
    <p class="normal">Be aware that if the edge <a id="_idIndexMarker728"/>navigation mesh is too close to walls or borders in a narrow passage, an instance may collide with the walls, generating additional movement corrections or leading to an impassable part of the mesh. Static obstacles in a level should also be bypassed at a safe distance.</p>
    <p class="normal">As a rule of thumb, use the distance between the edges and the center of the axis-aligned bounding box of an<a id="_idIndexMarker729"/> instance as the minimum distance between the edges of the navigation mesh and the adjacent level geometry. By keeping the instance away from walls at any time, no collision can occur during normal navigation.</p>
    <div class="note">
      <p class="normal">Generating a navigation mesh from level data</p>
      <p class="normal">Usually, a navigation mesh will be created by hand and added to the level data. But we need a solution for levels found on<a id="_idIndexMarker730"/> the internet, so we will do a shortcut in the code and use the same upward-facing triangles as “possibly walkable ground” that are used for the detection if the instance collides with the level ground.</p>
      <p class="normal">In combination with adjacency relations between all ground triangles, an estimation of the walkable area in the level can be achieved. A couple of enhancements to the ground area creation code are available as tasks in the <em class="italic">Practical sessions</em> section.</p>
    </div>
    <p class="normal">By using navigation meshes, two kinds of navigation are possible: free roaming through the virtual world and patrolling between waypoints.</p>
    <h4 class="heading-4">Free navigation</h4>
    <p class="normal">With free navigation, any point <a id="_idIndexMarker731"/>on a map can be a target point for the start and destination. Moving from one part <a id="_idIndexMarker732"/>of the level to another may be costly to calculate; in the worst case, the entire mesh must be checked during pathfinding. Also, the path of the character may be entirely different between two path plannings, depending on the exact position of the start and target.</p>
    <h4 class="heading-4">Waypoint navigation</h4>
    <p class="normal">A better <a id="_idIndexMarker733"/>approach for mesh-based <a id="_idIndexMarker734"/>navigation is to define waypoints on the navigation mesh that are visible to each other. For instance, every door in a group of rooms will be a waypoint or every fork in the road. When a bot moves through the virtual world, a waypoint is set as the next target after reaching the desired waypoint. If the player is <a id="_idIndexMarker735"/>spotted and then lost, the bot can return to the nearest waypoint. By making sure that the <a id="_idIndexMarker736"/>computer-controlled character can always “see” at least one waypoint, path planning to that next waypoint becomes cheap and easy to calculate.</p>
    <h3 id="_idParaDest-383" class="heading-3">Area awareness system</h3>
    <p class="normal">In 1999, <strong class="keyWord">id Software</strong> used a <a id="_idIndexMarker737"/>system called <strong class="keyWord">area awareness</strong> in <strong class="keyWord">Quake III Arena</strong>. Instead <a id="_idIndexMarker738"/>of two-dimensional graphs, a simplified <a id="_idIndexMarker739"/>three-dimensional <a id="_idIndexMarker740"/>representation of the levels was created, containing all information about the level structure, other bots, and the player.</p>
    <p class="normal">The bots can traverse the awareness areas not only by walking, jumping, or swimming but also by using a teleporter, a jump pad, or even by doing a rocket jump. With such a large repertoire of actions, a bot can easily follow the player around in the level or try to cut off the player’s path.</p>
    <p class="normal">A full description of the area awareness system is available in a link to a PDF document in the <em class="italic">Additional resources</em> section.</p>
    <h2 id="_idParaDest-384" class="heading-2">Using machine learning to generate navigation data</h2>
    <p class="normal">A more recent way to create navigation data for computer-controlled characters is machine learning, mostly in the form <a id="_idIndexMarker741"/>of so-called <strong class="keyWord">reinforced learning</strong>. During reinforced learning, an agent representing the character <a id="_idIndexMarker742"/>explores the virtual world on its own in a large amount of “trial-and-error” style rounds, but with added rewards for achieving a defined task or a punishment for failing to complete the task.</p>
    <p class="normal">Such a task could be something like “Reach a defined target point with maximum health,” “Don’t fall off the level,” or “Complete the level in minimum time.” By taking the rewards and punishments of previous explorations into account, the agent optimizes its behavior to maximize rewards and minimize punishments. When the data generated by these agents is used in games, the enemies can utilize the strategies from machine learning to appear even more natural when moving around in the virtual world.</p>
    <p class="normal">Two challenges of machine learning are making the usage time- and cost-expensive:</p>
    <ul>
      <li class="bulletList">Goals, rewards, and punishments must be clearly defined and adjusted during the calculations. Even if we humans think that the goals and rewards are well-defined, the machine learning algorithm could find unexpected ways to maximize rewards. A failure in the setup may result in discarding the data and doing a complete restart of the entire machine learning cycle.</li>
      <li class="bulletList">Since machine learning is exploring the virtual world by trial and error, progress is non-deterministic and may happen only in insignificant amounts. Even for simple tasks, thousands of game rounds must be played to achieve the desired results while the game is running. Creating a complex AI that explores big levels of the game may need a significant amount of computational resources, leading to excessive development costs.</li>
    </ul>
    <p class="normal">Even though machine learning may produce better results than algorithm-based navigation, it is recommended to check the trade-offs between possible improvements and additional costs. A link to a video showing the progress of letting a machine learn how to drive a car is available in the <em class="italic">Additional resources</em> section.</p>
    <p class="normal">After the short round-up of navigation methods, let’s dive into the A* algorithm next.</p>
    <h1 id="_idParaDest-385" class="heading-1">The A* path-finding algorithm</h1>
    <p class="normal">The A* algorithm was published in 1968 in the earlier days of computing. A* is the result of the path planning for an AI-controlled <a id="_idIndexMarker743"/>mobile robot called <strong class="screenText">Shakey</strong>. The robot was developed at the Stanford Research Institute. Its software included computer vision and natural language processing, and it was able to do simple tasks like driving to a place in the lab on its own, without describing every single action in advance. A link is available in the <em class="italic">Additional resources</em> section with more details about the project and the robot.</p>
    <p class="normal">But what makes A* different from Dijkstra’s algorithm?</p>
    <h2 id="_idParaDest-386" class="heading-2">Estimating the distance to the target</h2>
    <p class="normal">While Dijkstra’s algorithm only uses the weights between nodes, A* adds a heuristic value to every node. The heuristic<a id="_idIndexMarker744"/> function calculates an estimated cost of the cheapest path from every node to the selected target. In many cases, such as for large worlds and many nodes, calculating the minimal costs between every pair of nodes is computationally expensive, so an “educated guess” for the costs is cheaper to calculate and also good enough.</p>
    <p class="normal">For the heuristics<a id="_idIndexMarker745"/> function, any distance calculation function can be used. In most cases, either the so-called <strong class="keyWord">L1 norm</strong> will be used, known <a id="_idIndexMarker746"/>as the <strong class="keyWord">Manhattan distance</strong>, or the <strong class="keyWord">L2 norm</strong>, known<a id="_idIndexMarker747"/> as the <strong class="keyWord">Euclidean distance</strong>. <em class="italic">Figure 13.5</em> shows the idea behind both distance calculations:</p>
    <figure class="mediaobject"><img src="../Images/B22428_13_05.png" alt="" width="642" height="564"/></figure>
    <p class="packt_figref">Figure 13.5: Manhattan and Euclidean distances from start to target</p>
    <p class="normal">The Manhattan distance is modeled after the path of a taxicab in Manhattan. The streets are organized in parallel lines, crossing at an angle of 90 degrees. Like a cab in Manhattan, the blue paths in <em class="italic">Figure 13.5</em> can only use the grid lines between the start and the target. It also does not matter whether we use straight, direct lines, as in the dark blue path, or a staircase version, like the light blue path; the distance for both paths is identical.</p>
    <p class="normal">In contrast, the Euclidean distance for the green path in <em class="italic">Figure 13.5</em> is calculated by using the Pythagorean theorem. This means squaring the lengths of the distances in both directions, summing up the squares, and calculating the square root of the sum.</p>
    <p class="normal">Whether Manhattan distance, Euclidean distance, or any other distance calculation will be used for the heuristics function of A* heavily depends on the needs of the application. For instance, obstacles, hills, or enemies in a game map may need to be considered when estimating the distances. An intuitive way to find the best function is by drawing the paths for every heuristic function and a set of combinations for the start and target node and comparing the results.</p>
    <p class="normal">By using the heuristic value to the target node, A* tries to minimize the costs of the path to the target for every iteration.</p>
    <h2 id="_idParaDest-387" class="heading-2">Minimizing path costs</h2>
    <p class="normal">In every iteration, A* uses the sum of the known costs of the path <em class="italic">from the start</em> node and the estimated costs <em class="italic">to the target</em> node for every neighbor of the current node to calculate the minimal costs to reach the target node. Then, the algorithm chooses the neighboring node with the minimum costs, makes that neighboring node the current node, and starts the next iteration.</p>
    <p class="normal">In addition, A* saves a reference to the <a id="_idIndexMarker748"/>current node in each visited neighboring node if the overall cost from the start to the target over this neighbor is minimal among all neighboring nodes. Storing the parent node in a node allows backtracking to the best path from target to source after the target node has been reached.</p>
    <p class="normal">To visualize the algorithm, let’s step through a small example.</p>
    <h2 id="_idParaDest-388" class="heading-2">Exploring the A*algorithm</h2>
    <p class="normal"><em class="italic">Figure 13.6</em> shows a graph with<a id="_idIndexMarker749"/> nodes A, B, C, and D, plus the heuristics table from every node to the desired target node, D. The start node, in this case, is node A.</p>
    <figure class="mediaobject"><img src="../Images/B22428_13_06.png" alt="" width="1025" height="419"/></figure>
    <p class="packt_figref">Figure 13.6: A graph to traverse plus estimated distances to the target node, D</p>
    <p class="normal">We can immediately see the shortest path from node A to node D: ABCD. But for the computer, the A* algorithm must walk through the nodes to find this path.</p>
    <p class="normal">For the first iteration, we visit the neighbors of node A, as shown in <em class="italic">Figure 13.7</em>:</p>
    <figure class="mediaobject"><img src="../Images/B22428_13_07.png" alt="" width="1370" height="325"/></figure>
    <p class="packt_figref">Figure 13.7: Visiting nodes B and C</p>
    <p class="normal">Here, we calculate the estimated distance as the sum of the known distance from A and the heuristic value of each node. The sum for node B is lower, so we proceed to node B. We also remember the parent node for B since A is the direct predecessor of B.</p>
    <p class="normal">Then, we look at all neighbors of node B, as shown in <em class="italic">Figure 13.8</em>:</p>
    <figure class="mediaobject"><img src="../Images/B22428_13_08.png" alt="" width="1630" height="484"/></figure>
    <p class="packt_figref">Figure 13.8: Visiting nodes C and D</p>
    <p class="normal">We do the same calculations for node C and sum up the costs from A to B, B to C, and the heuristic from C to D. In an optimized version of A*, our search could be already over since we reached the target node, D.</p>
    <p class="normal">But we continue here by checking the remaining neighbors of node D in case there is an even shorter path available. So, we update <a id="_idIndexMarker750"/>the parent node of nodes C and D, and visit node C as the last yet unvisited neighbor of node D, as shown in <em class="italic">Figure 13.9</em>:</p>
    <figure class="mediaobject"><img src="../Images/B22428_13_09.png" alt="" width="1298" height="584"/></figure>
    <p class="packt_figref">Figure 13.9: The shortest path from A to D is ABCD</p>
    <p class="normal">Indeed, the path to node D via nodes B and C is much shorter than the path via B. So, we set node C as the new parent node for node D. After all the neighboring nodes of the target node D have been visited, A* has fulfilled its job to find a path from node A to node D.</p>
    <p class="normal">By backtracking the parent nodes, we get the path from the target to the start. By reversing the node order, we now have the shortest path from the start to the target: ABCD.</p>
    <p class="normal">As you can see, even in this very simple example, A* cares about the total estimated costs to the target when choosing the node to proceed with. If the algorithm learns about a shorter distance while working on a node, the<a id="_idIndexMarker751"/> parent node used to backtrack the best path is also updated. In the <em class="italic">Additional resources</em> section, a link to a website with a deep dive into A* is available.</p>
    <p class="normal">After an overview of the algorithm, let’s add the path-finding code.</p>
    <h2 id="_idParaDest-389" class="heading-2">Implementing A*-based navigation</h2>
    <p class="normal">Since we will not have a simple two-dimensional terrain in most maps, a two-dimensional grid for navigation cannot be<a id="_idIndexMarker752"/> used. Instead, we will use a navigation mesh to find a path from a source object to a target object in the virtual world.</p>
    <p class="normal">As already stated in the <em class="italic">Navigation meshes</em> section, creating the meshes is at least a partially manual job, depending on the editor used to create the game map. Some editors can create a navigation mesh based on the map’s elements, but in most cases, the generated mesh must be corrected manually. The navigation mesh must be stored on the same map as the rest of the level data or in a separate data file.</p>
    <p class="normal">To support both in-map and separate navigation mesh, the path-finding class is kept modular when it comes to the walkable ground meshes. For instance, if your navigation mesh is saved with a special name in the map file, you could import the navigation polygons and their adjacency properties into the path-finding class. You also have to import the navigation triangles into a separate triangle octree and do an additional ray-to-triangle intersection to find both the ground-level triangle and the navigation mesh triangle. The A* path-finding algorithm has also been implemented as a separate method, allowing you to easily add other algorithms or a different heuristics function.</p>
    <p class="normal">In the example code in this chapter, we will use the same idea as for the ground-level detection and use the normal of each mesh triangle to decide whether it is walkable or not. This method will result in having all upward-facing triangles in the navigation mesh, even if the triangles may be unreachable by any instance. But to demonstrate the general idea of pathfinding and navigation in a game map, creating a navigation mesh from the ground triangles of the map is sufficient and delivers reasonable results.</p>
    <p class="normal">We will use the Euclidean distance to calculate the distance between nodes and for the heuristic function, as the triangles in the map are most probably not arranged in a rectangular grid. To speed up the distance calculations, we will extend the mesh triangle data structure.</p>
    <h2 id="_idParaDest-390" class="heading-2">Preparing the mesh triangles</h2>
    <p class="normal">The <code class="inlineCode">MeshTriangle</code> struct is <a id="_idIndexMarker753"/>defined in the <code class="inlineCode">OGLRenderData.h</code> file for OpenGL and in the <code class="inlineCode">VkRenderData.h</code> file for <a id="_idIndexMarker754"/>Vulkan. At the end of the <code class="inlineCode">MeshTriangle</code> struct, we add the two new arrays, <code class="inlineCode">edges</code> and <code class="inlineCode">edgeLengths</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span> <span class="hljs-title">MeshTriangle</span> {
<span class="code-highlight"><strong class="hljs-slc">  std::array&lt;glm::vec3, 3&gt; edges{};</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  std::array&lt;</strong><strong class="hljs-type-slc">float</strong><strong class="hljs-slc">, 3&gt; edgeLengths{};</strong></span>
};
</code></pre>
    <p class="normal">In the <code class="inlineCode">edges</code> array, we store the three edges of each triangle. We order the edges by using the same winding as the original triangles. As we will need the lengths of the edges during the calculation of any adjacent<a id="_idIndexMarker755"/> triangles, we store the length of each edge<a id="_idIndexMarker756"/> in the corresponding <code class="inlineCode">edgeLengths</code> element.</p>
    <p class="normal">Now we can jump directly into the implementation of the path-finding class.</p>
    <h2 id="_idParaDest-391" class="heading-2">Adding the path-finding class</h2>
    <p class="normal">The path-finding class (named <code class="inlineCode">PathFinder</code>) will reside in the <code class="inlineCode">tools</code> folder where all other helper classes created<a id="_idIndexMarker757"/> in the previous chapters are stored, like <code class="inlineCode">AABB</code> or <code class="inlineCode">IKSolver</code>. To keep the naming consistent, the header file is named <code class="inlineCode">PathFinder.h</code> and the implementation will go into the <code class="inlineCode">PathFinder.cpp</code> file.</p>
    <p class="normal">On top of the <code class="inlineCode">PathFinder.h</code> header, right after all the <code class="inlineCode">#include</code> directives, we add two <code class="inlineCode">struct</code> entries. The first new struct is named <code class="inlineCode">NavTriangle</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span> <span class="hljs-title">NavTriangle</span> {
  <span class="hljs-type">int</span> index;
  std::array&lt;glm::<span class="hljs-type">vec3</span>, 3&gt; points{};
  glm::<span class="hljs-type">vec3</span> center{};
  glm::<span class="hljs-type">vec3</span> normal{};
  std::unordered_set&lt;<span class="hljs-type">int</span>&gt; neighborTris{};
};
</code></pre>
    <p class="normal">We don’t reuse <code class="inlineCode">MeshTriangle</code> here as we need a couple of different variables. While <code class="inlineCode">index</code>, the <code class="inlineCode">points</code> array, and the <code class="inlineCode">normal</code> vector are the same, we also need to store the world position of the center of each triangle in the <code class="inlineCode">center</code> variable and the surrounding triangles in <code class="inlineCode">neighborTris</code>. The instance will navigate from one triangle center to the next, and the triangles stored in <code class="inlineCode">neighborTris</code> are used to find the triangle with the shortest distance to the target.</p>
    <p class="normal">For the neighbor triangles, <code class="inlineCode">std::unordered_set</code> has been chosen over a plain <code class="inlineCode">std::vector</code> to have an automatic removal for duplicate entries.</p>
    <p class="normal">The second struct is called <code class="inlineCode">NavData</code> and contains the data for the A* algorithm:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span> <span class="hljs-title">NavData</span> {
  <span class="hljs-type">int</span> triIndex;
  <span class="hljs-type">int</span> prevTriIndex;
  <span class="hljs-type">float</span> distanceFromSource;
  <span class="hljs-type">float</span> heuristicToDest;
  <span class="hljs-type">float</span> distanceToDest;
};
</code></pre>
    <p class="normal">In the <code class="inlineCode">triIndex</code> variable, we store the triangle index of the corresponding <code class="inlineCode">NavTriangle</code>. By using the index, we can do a simple lookup to find triangle data like position or neighbor triangles. As soon as we visit a neighboring node of a triangle, we add the index of the triangle with the shortest path so far to <code class="inlineCode">prevTriIndex</code>, allowing us to backtrack the shortest path at the end of the pathfinding run.</p>
    <p class="normal">The remaining three variables (<code class="inlineCode">distanceFromSource</code>, <code class="inlineCode">heuristicToDest</code>, and <code class="inlineCode">distanceToDest</code>) are the workhorses of the A* algorithm. Here we store the aggregated distance from the source to the current node, the result of the heuristic function for the distance between the current node and the target, and the sum of both distances. By comparing the values of <code class="inlineCode">distanceToDest</code> for all<a id="_idIndexMarker758"/> neighboring nodes, A* chooses the next node toward the target node.</p>
    <p class="normal">After the two new structs, the <code class="inlineCode">PathFinder</code> class is declared, starting with the two public methods, <code class="inlineCode">generateGroundTriangles()</code> and <code class="inlineCode">findPath()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">generateGroundTriangles</span><span class="hljs-params">(OGLRenderData&amp; renderData,</span>
<span class="hljs-params">      std::shared_ptr&lt;TriangleOctree&gt; octree,</span>
<span class="hljs-params">      BoundingBox3D worldbox)</span>;
    <span class="hljs-function">std::vector&lt;</span><span class="hljs-type">int</span><span class="hljs-function">&gt; </span><span class="hljs-title">findPath</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> startTriIndex,</span>
<span class="hljs-params">      </span><span class="hljs-type">int</span><span class="hljs-params"> targetTriIndex)</span>;
</code></pre>
    <p class="normal">By calling <code class="inlineCode">generateGroundTriangles()</code>, all upward-facing triangles in the triangle octree are located and the neighbor information for each “walkable” triangle is created. Once the ground data is ready, <code class="inlineCode">findPath()</code> can be used to find a path from the start triangle to the target triangle. The result of <code class="inlineCode">findPath()</code> is the path found by A* as a vector of triangle indices to step on, ordered from the start triangle to the target triangle, or an empty vector if no valid path exists.</p>
    <p class="normal">Also in the <code class="inlineCode">PathFinder</code> class is the <code class="inlineCode">private</code> member called <code class="inlineCode">mNavTriangles</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">    std::unordered_map&lt;<span class="hljs-type">int</span>, NavTriangle&gt; mNavTriangles{};
</code></pre>
    <p class="normal">We store the calculated ground triangles in the <code class="inlineCode">mNavTriangles</code> map. A mapping between the index and the triangle data is used for fast access by using the triangle index, also stored as part of a <code class="inlineCode">NavData</code> element.</p>
    <p class="normal">Let’s step through the ground triangle generation code next.</p>
    <h2 id="_idParaDest-392" class="heading-2">Generating ground triangles</h2>
    <p class="normal">The ground triangles are <a id="_idIndexMarker759"/>generated by utilizing the <a id="_idIndexMarker760"/>triangle octree generated by the renderer. Since we will make a lot of requests to the triangle octree, it will be given as the second parameter in the <code class="inlineCode">generateGroundTriangles()</code> method.</p>
    <p class="normal">After clearing any previously generated navigation triangles, we get all triangles from the octree by a query with the world boundaries given as the third parameter:</p>
    <pre class="programlisting code"><code class="hljs-code">  mNavTriangles.<span class="hljs-built_in">clear</span>();
  std::vector&lt;MeshTriangle&gt; levelTris =
    octree-&gt;<span class="hljs-built_in">query</span>(worldbox);
</code></pre>
    <p class="normal">Then we loop over all level triangles to find the subset of upward-facing triangles:</p>
    <pre class="programlisting code"><code class="hljs-code">  std::vector&lt;MeshTriangle&gt; groundTris{};
  NavTriangle navTri;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; tri: levelTris) {
    <span class="hljs-keyword">if</span> (glm::<span class="hljs-built_in">dot</span>(tri.normal,
     glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>)) &gt;=
      std::<span class="hljs-built_in">cos</span>(glm::<span class="hljs-built_in">radians</span>(
      renderData.rdMaxLevelGroundSlopeAngle))) {
        groundTris.<span class="hljs-built_in">emplace_back</span>(tri);
</code></pre>
    <p class="normal">Comparing the dot product of a triangle’s normal and an upward-facing vector with the cosine of the <code class="inlineCode">rdMaxLevelGroundSlopeAngle</code> value is known from the collision detection in <a href="Chapter_12.xhtml"><em class="italic">Chapter 12</em></a>. If the current triangle<a id="_idIndexMarker761"/> fulfills the check, we add it to the <code class="inlineCode">groundTris</code> vector.</p>
    <p class="normal">Next to the ground <a id="_idIndexMarker762"/>triangles in <code class="inlineCode">groundTris</code>, we fill the <code class="inlineCode">NavTriangle</code> named <code class="inlineCode">navTri</code> with minimal data and add <code class="inlineCode">navTri</code> to the <code class="inlineCode">mNavTriangles</code> map:</p>
    <pre class="programlisting code"><code class="hljs-code">      navTri.points = tri.points;
      navTri.normal = tri.normal;
      navTri.index = tri.index;
      navTri.center = (tri.points.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) +
        tri.points.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) + tri.points.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>)) / <span class="hljs-number">3.0f</span>;
      mNavTriangles.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(tri.index,
        navTri))
    }
  }
</code></pre>
    <p class="normal">We use different sets of data in the <code class="inlineCode">groundTris</code> vector and the <code class="inlineCode">mNavTriangles</code> map here since a query to the triangle octree returns a vector of <code class="inlineCode">MeshTriangles</code> but we maintain a better fitting map of <code class="inlineCode">NavTriangles</code> for the ground triangles.</p>
    <p class="normal">Now we can iterate over all ground triangles and query the triangle octree for all colliding triangles in the level:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; tri : groundTris) {
    std::vector&lt;MeshTriangle&gt; nearbyTris =
      octree-&gt;<span class="hljs-built_in">query</span>(tri.boundingBox);
</code></pre>
    <p class="normal">This query works well as, in <a href="Chapter_12.xhtml"><em class="italic">Chapter 12</em></a>, we had to make the bounding box of every triangle in the <code class="inlineCode">generateLevelOctree()</code> method of the renderer classes <code class="inlineCode">OGLRenderer</code> or <code class="inlineCode">VkRenderer</code> a bit bigger to avoid a size of zero in any of the three dimensions. With this minimal size change, the bounding boxes of adjacent triangles in the level data are colliding now, and the triangle octree returns all neighbor triangles.</p>
    <p class="normal">Then we get a reference to the same ground triangle in the <code class="inlineCode">mNavTriangles</code> map and iterate over all triangles reported by the octree query:</p>
    <pre class="programlisting code"><code class="hljs-code">    NavTriangle&amp; navTri = mNavTriangles.<span class="hljs-built_in">at</span>(tri.index);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; peer : nearbyTris) {
</code></pre>
    <p class="normal">Using a reference for the ground triangle is important because we will update the neighbor triangles directly on the <code class="inlineCode">NavTriangle</code> object in the map.</p>
    <p class="normal">And even though these two nested loops look awful, the overall computation time is still small because the octree query reports only a small number of neighbor triangles. We can even sort out more triangles by simple checks:</p>
    <pre class="programlisting code"><code class="hljs-code">      <span class="hljs-keyword">if</span> (tri.index == peer.index) {
        <span class="hljs-keyword">continue</span>;
      }
      <span class="hljs-keyword">if</span> (glm::<span class="hljs-built_in">dot</span>(peer.normal,
        glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>)) &lt;
          std::<span class="hljs-built_in">cos</span>(glm::<span class="hljs-built_in">radians</span>(
          renderData.rdMaxLevelGroundSlopeAngle))) {
        <span class="hljs-keyword">continue</span>;
      }
</code></pre>
    <p class="normal">The query for colliding <a id="_idIndexMarker763"/>triangles may also report the ground triangle we are currently inspecting, so we return immediately if we find it in the results. We also remove all triangles not facing upward from the list of possible neighbors as we are <a id="_idIndexMarker764"/>only interested in adjacent ground triangles.</p>
    <p class="normal">In case of triangulation errors made by <code class="inlineCode">Assimp</code>, we also need to check if the peer triangle is in <code class="inlineCode">mNavTriangles</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">      <span class="hljs-keyword">if</span> (mNavTriangles.<span class="hljs-built_in">count</span>(peer.index) == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">continue</span>;
      }
</code></pre>
    <p class="normal">If we find a valid neighbor triangle, we get the neighbor triangle from the <code class="inlineCode">mNavTriangles</code> map:</p>
    <pre class="programlisting code"><code class="hljs-code">      NavTriangle peerNavTri =
        mNavTriangles.<span class="hljs-built_in">at</span>(peer.index);
</code></pre>
    <p class="normal">Finally, we can do a loop over all three vertices of both triangles to check for adjacency:</p>
    <pre class="programlisting code"><code class="hljs-code">      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; ++j) {
</code></pre>
    <p class="normal">Inside the loop, we calculate the distance of every vertex from the edges of the other triangle:</p>
    <pre class="programlisting code"><code class="hljs-code">          glm::<span class="hljs-type">vec3</span> pointToPeerLine =
            glm::<span class="hljs-built_in">cross</span>(tri.<span class="hljs-keyword">points</span>.at(j) -
            peer. <span class="hljs-keyword">points</span>.at(i), tri.<span class="hljs-keyword">points</span>.at(j) -
            peer.<span class="hljs-keyword">points</span>.at((i + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>));
          <span class="hljs-type">float</span> pointDistance =
            glm::<span class="hljs-built_in">length</span>(pointToPeerLine) /
            peer.edgeLengths.at(i);
          glm::<span class="hljs-type">vec3</span> peerPointToTriLine =
            glm::<span class="hljs-built_in">cross</span>(peer.<span class="hljs-keyword">points</span>.at(j) -
            tri. <span class="hljs-keyword">points</span>.at(i), peer.<span class="hljs-keyword">points</span>.at(j) -
            tri.<span class="hljs-keyword">points</span>.at((i + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>));
          <span class="hljs-type">float</span> peerPointDistance =
            glm::<span class="hljs-built_in">length</span>(peerPointToTriLine) /
            tri.edgeLengths.at(i);
</code></pre>
    <p class="normal">By calculating the distance from all vertices to every edge of the other triangle, we can detect if the triangles share a vertex or a <a id="_idIndexMarker765"/>side, or if a vertex of one triangle is on the edge of the other triangle.</p>
    <p class="normal">If the distance is small <a id="_idIndexMarker766"/>enough, we add the index of the current peer triangle to the set of neighbor triangles of the currently inspected ground triangle:</p>
    <pre class="programlisting code"><code class="hljs-code">          <span class="hljs-keyword">if</span> ((pointDistance &lt; <span class="hljs-number">0.01f</span> ||
              peerPointDistance &lt; <span class="hljs-number">0.01f</span>)) {
            navTri.neighborTris.<span class="hljs-built_in">insert</span>(peerNavTri.index);
          }
</code></pre>
    <p class="normal">After the <code class="inlineCode">generateGroundTriangles()</code> method has finished the calculations, the <code class="inlineCode">mNavTriangles</code> map contains all possibly “walkable” ground triangles, and for every triangle, a list of triangles sharing at least a side or a vertex.</p>
    <div class="note">
      <p class="normal">A note on the navigation mesh quality</p>
      <p class="normal">The quality of the generated ground triangle mesh heavily depends on the map: Since the upward-facing triangles in the map may not form a perfect triangle mesh that shares vertices between triangles, the generated ground triangles in the <code class="inlineCode">mNavTriangles</code> map may contain more neighbors than a separate navigation mesh would have. More triangles in a level usually also bring better quality here.</p>
    </div>
    <p class="normal">With a navigation mesh of ground triangles at hand, we can go for the A* algorithm.</p>
    <h2 id="_idParaDest-393" class="heading-2">Finding a path between two ground triangles</h2>
    <p class="normal">The implementation<a id="_idIndexMarker767"/> of the <code class="inlineCode">findPath()</code> method follows the A* algorithm and should be easy to understand.</p>
    <h3 id="_idParaDest-394" class="heading-3">Preparing the data</h3>
    <p class="normal">We start by extracting the center <a id="_idIndexMarker768"/>points of the target and start triangles:</p>
    <pre class="programlisting code"><code class="hljs-code">  NavTriangle targetTri = mNavTriangles.<span class="hljs-built_in">at</span>(targetTriIndex);
  glm::<span class="hljs-type">vec3</span> targetPoint = targetTri.center;
  NavTriangle startTri = mNavTriangles.<span class="hljs-built_in">at</span>(startTriIndex);
  glm::<span class="hljs-type">vec3</span> startPoint = startTri.center;
</code></pre>
    <p class="normal">We will need the center point to calculate the distances between the nodes.</p>
    <p class="normal">Next, we create two sets called <code class="inlineCode">navOpenList</code> and <code class="inlineCode">navClosedList</code> and a map named <code class="inlineCode">navPoints</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  std::unordered_set&lt;<span class="hljs-type">int</span>&gt; navOpenList{};
  std::unordered_set&lt;<span class="hljs-type">int</span>&gt; navClosedList{};
  std::unordered_map&lt;<span class="hljs-type">int</span>, NavData&gt; navPoints{};
</code></pre>
    <p class="normal">In the <code class="inlineCode">navOpenList</code> variable, we store all neighbors of nodes that are candidates for the next iteration, and in <code class="inlineCode">navClosedList</code>, we save all nodes that were already fully explored. The <code class="inlineCode">navPoints</code> map contains data about all known nodes, like the distances and the parent node.</p>
    <p class="normal">Prior to the first iteration of<a id="_idIndexMarker769"/> the A* algorithm, we set the <code class="inlineCode">currentIndex</code> variable to the start triangle and create the navigation data for the start triangle:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">int</span> currentIndex = startTriIndex;
  NavData navStartPoint{};
  navStartPoint.triIndex = startTriIndex;
  navStartPoint.prevTriIndex = <span class="hljs-number">-1</span>;
  navStartPoint.distanceFromSource = <span class="hljs-number">0</span>;
  navStartPoint.heuristicToDest =
    glm::<span class="hljs-built_in">distance</span>(startPoint, targetPoint);
  navStartPoint.distanceToDest =
    navStartPoint.distanceFromSource +
    navStartPoint.heuristicToDest;
  navPoints.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">make_pair</span>(startTriIndex,
    navStartPoint));
  navOpenList.<span class="hljs-built_in">insert</span>(startTriIndex);
</code></pre>
    <p class="normal">The distance to the target point is calculated as Euclidean distance by using a call to <code class="inlineCode">glm::distance</code> and the distance to the start point is set to zero as we are still at the start point. We also add the start node to both the list of open nodes and the map containing the navigation data.</p>
    <h3 id="_idParaDest-395" class="heading-3">Running the main loop</h3>
    <p class="normal">For the main loop of the A* algorithm, we start a <code class="inlineCode">while</code> loop that ends if we hit the target triangle. The loop is <em class="italic">not</em> guaranteed to end at<a id="_idIndexMarker770"/> some point in time (for instance, if the target triangle is outside of the reachable mesh), so we will need to add an exit condition at the end of the loop:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">while</span> (currentIndex != targetTriIndex) {
    NavTriangle currentTri = mNavTriangles.<span class="hljs-built_in">at</span>(currentIndex);
    glm::vec3 currentTriPoint = currentTri.center;
    std::unordered_set&lt;<span class="hljs-type">int</span>&gt; neighborTris =
      currentTri.neighborTris;
</code></pre>
    <p class="normal">For every loop iteration, we extract the current triangle from the <code class="inlineCode">mNavTriangles</code> map and get the center point in world coordinates and the neighbor triangles.</p>
    <p class="normal">Next, we loop over all neighbor triangles and extract the center point of the triangle:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; navTriIndex : neighborTris) {
      NavTriangle navTri = mNavTriangles.<span class="hljs-built_in">at</span>(navTriIndex);
      glm::vec3 navTriPoint = navTri.center;
</code></pre>
    <p class="normal">If the neighboring node is not<a id="_idIndexMarker771"/> fully explored and not even visited yet, we continue inside the two <code class="inlineCode">if</code> conditions and add the node to the open list:</p>
    <pre class="programlisting code"><code class="hljs-code">      <span class="hljs-keyword">if</span> (navClosedList.<span class="hljs-built_in">count</span>(navTriIndex) == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (navOpenList.<span class="hljs-built_in">count</span>(navTriIndex) == <span class="hljs-number">0</span>) {
          navOpenList.<span class="hljs-built_in">insert</span>(navTriIndex);
</code></pre>
    <p class="normal">As a reminder, the closed list contains all fully explored nodes, and the open list contains all known neighbors but not yet fully explored nodes of any of the nodes (even already closed nodes). At this point, we know that this is a new node to visit, so we create new navigation data:</p>
    <pre class="programlisting code"><code class="hljs-code">          NavData navPoint{};
          navPoint.triIndex = navTriIndex;
          navPoint.prevTriIndex = currentIndex;
</code></pre>
    <p class="normal">For the distance calculation, we get the distance from the current index (our parent node) and add the distance between the two nodes to the distance from the source:</p>
    <pre class="programlisting code"><code class="hljs-code">          NavData prevNavPoint =
            navPoints.<span class="hljs-built_in">at</span>(navPoint.prevTriIndex);
          navPoint.distanceFromSource =
            prevNavPoint.distanceFromSource +
            glm::<span class="hljs-built_in">distance</span>(currentTriPoint, navTriPoint);
          navPoint.heuristicToDest =
            glm::<span class="hljs-built_in">distance</span>(navTriPoint, targetPoint);
          navPoint.distanceToDest =
            navPoint.distanceFromSource +
            navPoint.heuristicToDest;
          navPoints.<span class="hljs-built_in">emplace</span>(
            std::<span class="hljs-built_in">make_pair</span>(navTriIndex, navPoint));
        }
</code></pre>
    <p class="normal">As the last step of the code block, we add the new navigation data to the <code class="inlineCode">navPoints</code> map that contains data about all currently known nodes.</p>
    <p class="normal">If the neighboring node is already in the list of open nodes, we check if we need to update the existing navigation data:</p>
    <pre class="programlisting code"><code class="hljs-code">        } <span class="hljs-keyword">else</span> {
          NavData&amp; navPoint = navPoints.<span class="hljs-built_in">at</span>(navTriIndex);
</code></pre>
    <p class="normal">Here, we get a reference to the navigation data to be able to update the information in place. For the existing navigation point, we calculate the new estimated distance from the known distance to the source and<a id="_idIndexMarker772"/> the heuristic value to the target:</p>
    <pre class="programlisting code"><code class="hljs-code">          NavData possibleNewPrevNavPoint =
             navPoints.<span class="hljs-built_in">at</span>(currentIndex);
          <span class="hljs-type">float</span> newDistanceFromSource =
            possibleNewPrevNavPoint.distanceFromSource +
            glm::<span class="hljs-built_in">distance</span>(currentTriPoint, navTriPoint);
          <span class="hljs-type">float</span> newDistanceToDest = newDistanceFromSource +
            navPoint.heuristicToDest;
</code></pre>
    <p class="normal">If the new path through this node is shorter than the previously known path, we update the navigation data to reflect the new, shorter path:</p>
    <pre class="programlisting code"><code class="hljs-code">         <span class="hljs-keyword">if</span> (newDistanceToDest &lt; navPoint.distanceToDest) {
            navPoint.prevTriIndex = currentIndex;
            navPoint.distanceFromSource =
              newDistanceFromSource;
            navPoint.distanceToDest = newDistanceToDest;
          }
</code></pre>
    <p class="normal">After all neighboring nodes have been checked, we add the current node to the closed list, marking it as fully explored:</p>
    <pre class="programlisting code"><code class="hljs-code">    navClosedList.<span class="hljs-built_in">insert</span>(currentIndex);
</code></pre>
    <p class="normal">If our open list becomes empty, we return an empty vector:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> (navOpenList.<span class="hljs-built_in">empty</span>()) {
      <span class="hljs-keyword">return</span> std::vector&lt;<span class="hljs-type">int</span>&gt;{};
    }
</code></pre>
    <p class="normal">We check for an empty open list before going on since the next step involves a loop over all elements of the open list.</p>
    <h3 id="_idParaDest-396" class="heading-3">Extracting the best node</h3>
    <p class="normal">Once we have collected all the new <a id="_idIndexMarker773"/>nodes and updated the distances of all existing nodes, we need to find the node with the shortest combined distance from start to target. We will use a priority queue here to minimize the costs to access the node having the smallest distance. The priority queue will sort all nodes according to a comparison function into a tree structure and allow accessing the largest or smallest node as the topmost element.</p>
    <p class="normal">First, we create the comparison function for the priority queue:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">auto</span> cmp = [](NavData left, NavData right) {
    <span class="hljs-keyword">return</span> left.distanceToDest &gt; right.distanceToDest;
  };
</code></pre>
    <p class="normal">By default, a priority uses <code class="inlineCode">std::less</code> as a comparison function, resulting in a queue with the maximum value as the top <a id="_idIndexMarker774"/>element. But by using the <code class="inlineCode">cmp</code> function, we will have the minimum distance to the destination as the top element.</p>
    <p class="normal">Now we can fill the queue by pushing all triangles in the open list:</p>
    <pre class="programlisting code"><code class="hljs-code">    std::priority_queue&lt;NavData, std::vector&lt;NavData&gt;,
      <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">naviDataQueue</span>(cmp);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; navTriIndex : navOpenList) {
      NavData navPoint = navPoints.<span class="hljs-built_in">at</span>(navTriIndex);
      naviDataQueue.<span class="hljs-built_in">push</span>(navPoint);
    }
</code></pre>
    <p class="normal">Next, we declare an empty navigation data variable and extract the index with the minimum distance from the queue by a call to <code class="inlineCode">top()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">      NavData nextPointToDest{};
      nextPointToDest = naviDataQueue.<span class="hljs-built_in">top</span>();
      currentIndex = nextPointToDest.triIndex;
</code></pre>
    <p class="normal">The new triangle index will be used for the next loop of <code class="inlineCode">while</code>, looping until the target triangle has been found as the triangle with the minimal distance.</p>
    <p class="normal">As a final step for the A* algorithm, we erase the node from the open list:</p>
    <pre class="programlisting code"><code class="hljs-code">    navOpenList.<span class="hljs-built_in">erase</span>(currentIndex);
    }
</code></pre>
    <p class="normal">Once we have found the target triangle, the outer <code class="inlineCode">while</code> loop ends, and we can collect and return the shortest path</p>
    <h3 id="_idParaDest-397" class="heading-3">Backtracking the shortest path</h3>
    <p class="normal">Since we have saved the parent <a id="_idIndexMarker775"/>node with the shortest distance so far in the navigation data for every triangle, we just need to follow the chain along the parent nodes, starting from the target node until we hit the start node. The start node is marked by a parent node of <code class="inlineCode">-1</code>, so we know when to stop.</p>
    <p class="normal">First, we create a new vector named <code class="inlineCode">foundPath</code> and store <code class="inlineCode">currentIndex</code> in it:</p>
    <pre class="programlisting code"><code class="hljs-code">  std::vector&lt;<span class="hljs-type">int</span>&gt; foundPath{};
  foundPath.<span class="hljs-built_in">emplace_back</span>(currentIndex);
</code></pre>
    <p class="normal">The main <code class="inlineCode">while</code> loop ends when <code class="inlineCode">currentIndex</code> is identical to the requested <code class="inlineCode">targetIndex</code>, so we could use any of the two variables here.</p>
    <p class="normal">Then, we get the navigation data of the current triangle and loop over all parents until we hit the start triangle:</p>
    <pre class="programlisting code"><code class="hljs-code">  NavData navPoint = navPoints.<span class="hljs-built_in">at</span>(currentIndex);
  <span class="hljs-keyword">while</span> (navPoint.prevTriIndex != <span class="hljs-number">-1</span>) {
    foundPath.<span class="hljs-built_in">emplace_back</span>(navPoint.prevTriIndex);
    navPoint = navPoints.<span class="hljs-built_in">at</span>(navPoint.prevTriIndex);
  }
</code></pre>
    <p class="normal">As we started the<a id="_idIndexMarker776"/> backtracking at the target triangle and ended on the start triangle, the order of the triangles in <code class="inlineCode">foundPath</code> is also from target to start. To fix the order, we reverse the vector:</p>
    <pre class="programlisting code"><code class="hljs-code">  std::<span class="hljs-built_in">reverse</span>(foundPath.<span class="hljs-built_in">begin</span>(), foundPath.<span class="hljs-built_in">end</span>());
</code></pre>
    <p class="normal">Finally, we return the reversed path:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">return</span> foundPath;
</code></pre>
    <p class="normal">We can call <code class="inlineCode">findPath()</code> now with any combination of start and target triangles and get a path back if such a path exists. If no path from start to target exists, <code class="inlineCode">findPath()</code> returns an empty vector by the check for the empty open list.</p>
    <p class="normal">The starting point of the pathfinding is known; it’s the instance. But what about the target? Let’s add some configurable navigation targets to the virtual world.</p>
    <h1 id="_idParaDest-398" class="heading-1">Adding navigation targets to the map</h1>
    <p class="normal">Before we start, let us imagine<a id="_idIndexMarker777"/> which properties a possible navigation target must have:</p>
    <ul>
      <li class="bulletList">It should come in any shape and number.</li>
      <li class="bulletList">It should be easy to select and move around.</li>
      <li class="bulletList">It can be placed anywhere on the ground.</li>
      <li class="bulletList">Ideally, it should be able to move by itself.</li>
    </ul>
    <p class="normal">So, our ideal target is a model instance! And since we already have all the ingredients for this list, implementing navigation targets becomes easy.</p>
    <h2 id="_idParaDest-399" class="heading-2">Adjusting model and instance</h2>
    <p class="normal">First, we add a<a id="_idIndexMarker778"/> new Boolean variable named <code class="inlineCode">msUseAsNavigationTarget</code> to the <code class="inlineCode">ModelSettings</code> struct:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">bool</span> msUseAsNavigationTarget = <span class="hljs-literal">false</span>;
</code></pre>
    <p class="normal">The <code class="inlineCode">AssimpModel</code> class also needs two simple <code class="inlineCode">public</code> methods named <code class="inlineCode">setAsNavigationTarget()</code> and <code class="inlineCode">isNavigationTarget()</code> to set and query the new variable:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">setAsNavigationTarget</span><span class="hljs-params">(</span><span class="hljs-type">bool</span><span class="hljs-params"> value)</span>;
    <span class="hljs-type">bool</span><span class="hljs-function"> </span><span class="hljs-title">isNavigationTarget</span><span class="hljs-params">()</span>;
</code></pre>
    <p class="normal">In the <code class="inlineCode">UserInterface</code> class, a checkbox will be added to set the state of a model with a simple mouse click. <em class="italic">Figure 13.10</em> shows the <strong class="screenText">Models</strong> layout with the new checkbox:</p>
    <figure class="mediaobject"><img src="../Images/B22428_13_10.png" alt="" width="1130" height="272"/></figure>
    <p class="packt_figref">Figure 13.10: The Models part of the UI with the new navigation target checkbox</p>
    <p class="normal">By setting the <strong class="screenText">Use as NavTarget</strong> checkbox in <em class="italic">Figure 13.10</em>, we can control whether or not a model should be used as a navigation target.</p>
    <p class="normal">For the instances, we add the five variables to the <code class="inlineCode">InstanceSettings</code> struct:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">bool</span> isNavigationEnabled = <span class="hljs-literal">false</span>;
  <span class="hljs-type">int</span> isPathTargetInstance = <span class="hljs-number">-1</span>;
  <span class="hljs-type">int</span> isPathStartTriangleIndex = <span class="hljs-number">-1</span>;
  <span class="hljs-type">int</span> isPathTargetTriangleIndex = <span class="hljs-number">-1</span>;
  std::vector&lt;<span class="hljs-type">int</span>&gt; isPathToTarget{};
</code></pre>
    <p class="normal">To control the navigation on<a id="_idIndexMarker779"/> a per-instance basis, <code class="inlineCode">isNavigationEnabled</code> is used. The two variables <code class="inlineCode">isPathTargetInstance</code> and <code class="inlineCode">isPathToTarget</code> should not need an explanation; their names state what they are for. In <code class="inlineCode">isPathStartTriangleIndex</code>, the index of the triangle is saved where the instance currently resides, and <code class="inlineCode">isPathTargetTriangleIndex</code> is filled with the triangle index of the target instance.</p>
    <p class="normal">In the <code class="inlineCode">AssimpInstance</code> class, simple <code class="inlineCode">public</code> setter and getter methods for the new variables are added:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">setPathStartTriIndex</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> index)</span>;
    <span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">setPathTargetTriIndex</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> index)</span>;
    <span class="hljs-type">int</span><span class="hljs-function"> </span><span class="hljs-title">getPathTargetTriIndex</span><span class="hljs-params">()</span>;
    <span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">setPathTargetInstanceId</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> instanceId)</span>;
    <span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">setPathToTarget</span><span class="hljs-params">(std::vector&lt;</span><span class="hljs-type">int</span><span class="hljs-params">&gt; indices)</span>;
    <span class="hljs-function">std::vector&lt;</span><span class="hljs-type">int</span><span class="hljs-function">&gt; </span><span class="hljs-title">getPathToTarget</span><span class="hljs-params">()</span>;
</code></pre>
    <p class="normal">In the <strong class="screenText">Instances</strong> collapsing header of the <code class="inlineCode">UserInterface</code> class, a couple of new controls are added too:</p>
    <figure class="mediaobject"><img src="../Images/B22428_13_11.png" alt="" width="1040" height="176"/></figure>
    <p class="packt_figref">Figure 13.11: New navigation controls for the instances</p>
    <p class="normal">When checking the <strong class="screenText">Enable Navigation</strong> checkbox, the remaining parts of the navigation controls are enabled. If any navigation target model exists, the <strong class="screenText">Nav Targets</strong> combo box is populated with the indices of the instances, allowing us the set the instance number to use as the target. In the case that a target was set, <strong class="screenText">Nav Target</strong> shows the index of the current target, or <code class="inlineCode">-1</code> if no target was selected. To find the target without switching instances, <code class="inlineCode">Center Target</code> can be pressed, centering the target in the middle of the screen.</p>
    <p class="normal">For the combo box with<a id="_idIndexMarker780"/> the navigation targets, a callback named <code class="inlineCode">getNavTargetsCallback</code> will be added to the <code class="inlineCode">Callbacks.h</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">using</span> getNavTargetsCallback = std::function&lt;std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">void</span>)&gt;;
</code></pre>
    <p class="normal">The corresponding method in the renderer class files <code class="inlineCode">OGLRenderer.cpp</code> and <code class="inlineCode">VkRenderer.cpp</code> is called <code class="inlineCode">getNavTargets()</code> and collects the indices of all instances from models enabled as navigation targets:</p>
    <pre class="programlisting code"><code class="hljs-code"> std::vector&lt;<span class="hljs-type">int</span>&gt; targets;
 <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; model : mModelInstCamData.micModelList) {
   <span class="hljs-keyword">if</span> (!model-&gt;<span class="hljs-built_in">isNavigationTarget</span>()) {
     <span class="hljs-keyword">continue</span>;
   }
</code></pre>
    <p class="normal">We loop over all models, and if the model is not a navigation target, we continue with the next model. If the model is marked as a navigation target, we store all indices in a vector named <code class="inlineCode">targets</code> and return the vector:</p>
    <pre class="programlisting code"><code class="hljs-code">    std::string modelName = model-&gt;<span class="hljs-built_in">getModelFileName</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; instance : mModelInstCamData.
        micAssimpInstancesPerModel[modelName]) {
      InstanceSettings settings =
        instance-&gt;<span class="hljs-built_in">getInstanceSettings</span>();
      targets.<span class="hljs-built_in">emplace_back</span>(
        settings.isInstanceIndexPosition);
    }
  }
  <span class="hljs-keyword">return</span> targets;
</code></pre>
    <p class="normal">To place the targets on the ground, we also need gravity to apply.</p>
    <h2 id="_idParaDest-400" class="heading-2">Adding gravity for non-animated instances</h2>
    <p class="normal">Gravity is currently only affecting any animated instances since we needed them to stay on the ground for collision detection and inverse kinematics in <a href="Chapter_12.xhtml"><em class="italic">Chapter 12</em></a>. Thanks to keeping the code for animated and<a id="_idIndexMarker781"/> non-animated models mostly similar, adding gravity for non-animated instances is done with only a couple of small changes.</p>
    <p class="normal">First, copy the entire code block with the <code class="inlineCode">mLevelCollisionTimer.start()</code> and <code class="inlineCode">mLevelCollisionTimer()</code> calls below the call that adds the current instance to the instance octree, as shown in the following code block:</p>
    <pre class="programlisting code"><code class="hljs-code">          mOctree-&gt;<span class="hljs-built_in">add</span>(
            instSettings.isInstanceIndexPosition);
<span class="code-highlight"><strong class="hljs-slc">          mLevelCollisionTimer.</strong><strong class="hljs-built_in-slc">start</strong><strong class="hljs-slc">();</strong></span>
<span class="code-highlight"><strong class="hljs-slc">          ...</strong></span>
<span class="code-highlight"><strong class="hljs-slc">          mRenderData.rdLevelCollisionTime +=</strong></span>
<span class="code-highlight"><strong class="hljs-slc">            mLevelCollisionTimer.</strong><strong class="hljs-built_in-slc">stop</strong><strong class="hljs-slc">();</strong></span>
</code></pre>
    <p class="normal">Then, add a call to <code class="inlineCode">updateInstancePosition()</code> below the new code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">          instances.</strong><strong class="hljs-built_in-slc">at</strong><strong class="hljs-slc">(i)-&gt;</strong><strong class="hljs-built_in-slc">updateInstancePosition</strong><strong class="hljs-slc">(</strong></span>
<span class="code-highlight"><strong class="hljs-slc">            deltaTime);</strong></span>
</code></pre>
    <p class="normal">Finally, move the retrieval of the matrix containing the world transforms from the start of the block after the instance position update:</p>
    <pre class="programlisting code"><code class="hljs-code">          mWorldPosMatrices.<span class="hljs-built_in">at</span>(i) =
            instances.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">getWorldTransformMatrix</span>();
</code></pre>
    <p class="normal">That’s all!</p>
    <p class="normal">Now the gravity and ground collisions are also calculated for non-animated instances, the instance position is updated, and the most recent world transforms are collected and added to the <code class="inlineCode">mWorldPosMatrices</code> array, which is then uploaded to a Shader Storage Buffer Object.</p>
    <h2 id="_idParaDest-401" class="heading-2">Saving and loading the new model and instance data</h2>
    <p class="normal">Storing the new values in the YAML configuration file and restoring the settings should need no further explanation. The Boolean <a id="_idIndexMarker782"/>to use a model as a navigation target is stored in the <code class="inlineCode">ModelSettings</code> struct and all new path-finding and navigation variables for the instance are stored in the <code class="inlineCode">InstanceSettings</code> struct. Adding the new values to the YAML emitter and parser is only a matter of copying and pasting. The YAML configuration version should be updated, too, to reflect the new values.</p>
    <p class="normal">We have ground triangles, a path-finding algorithm, and the start and target points of a path. What’s left is the logic to make an instance follow the path. So, let’s add the last part now.</p>
    <h1 id="_idParaDest-402" class="heading-1">Navigating instances to a target</h1>
    <p class="normal">To calculate or<a id="_idIndexMarker783"/> update the path to the target instance, we need to add more code to the renderer. We start by adding the code to compute the actual path from an instance to the target position.</p>
    <h2 id="_idParaDest-403" class="heading-2">Calculating the path to the target</h2>
    <p class="normal">The best place for the path update code is in the loop over all animated instances in the <code class="inlineCode">draw()</code> call of the renderer class <code class="inlineCode">OGLRenderer.cpp</code> or <code class="inlineCode">VKRenderer.cpp</code>, right after the ground and collision detection<a id="_idIndexMarker784"/> code that was just copied for the non-animated instances. We have the final world position of the instance available, including any gravity updates, and can use this position as the starting point of the path-finding algorithm.</p>
    <p class="normal">First, we check if navigation is enabled for the instance and get the instance index of the target:</p>
    <pre class="programlisting code"><code class="hljs-code">      <span class="hljs-keyword">if</span> (instSettings.isNavigationEnabled) {
        <span class="hljs-type">int</span> pathTargetInstance =
          instSettings.isPathTargetInstance;
</code></pre>
    <p class="normal">Then, we do a sanity check of the target instance to avoid a crash when accessing the <code class="inlineCode">micAssimpInstances</code> vector:</p>
    <pre class="programlisting code"><code class="hljs-code">        <span class="hljs-keyword">if</span> (pathTargetInstance &gt;=
           mModelInstCamData.micAssimpInstances.<span class="hljs-built_in">size</span>()) {
         pathTargetInstance = <span class="hljs-number">-1</span>;
         instances.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">setPathTargetInstanceId</span>(
           pathTargetInstance);
       }
</code></pre>
    <p class="normal">Next, extract the index <a id="_idIndexMarker785"/>of the triangle the target is currently on plus the world position of the target:</p>
    <pre class="programlisting code"><code class="hljs-code">        <span class="hljs-type">int</span> pathTargetInstanceTriIndex = <span class="hljs-number">-1</span>;
        glm::vec3 pathTargetWorldPos = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>);
        <span class="hljs-keyword">if</span> (pathTargetInstance != <span class="hljs-number">-1</span>) {
          std::shared_ptr&lt;AssimpInstance&gt;
            targetInstance =
            mModelInstCamData.micAssimpInstances.<span class="hljs-built_in">at</span>(
            pathTargetInstance);
          pathTargetInstanceTriIndex =
            targetInstance-&gt;
              <span class="hljs-built_in">getCurrentGroundTriangleIndex</span>();
          pathTargetWorldPos =
            targetInstance-&gt;<span class="hljs-built_in">getWorldPosition</span>();
        }
</code></pre>
    <p class="normal">As the target instance may move by itself or may be moved by the user, the target triangle index must be retrieved before every path update. This triangle index update ensures that the instance is following the target, regardless of the target being a static waypoint or another instance that roams around in the level.</p>
    <p class="normal">Now we check if both the current instance and the target instance have a valid ground triangle and if we or the target moved away from the saved triangle. Only if all conditions are met do we recalculate the path at all, avoiding costly computations when no changes to the source or target occurred:</p>
    <pre class="programlisting code"><code class="hljs-code">     <span class="hljs-keyword">if</span> ((instSettings.isCurrentGroundTriangleIndex &gt; <span class="hljs-number">-1</span> &amp;&amp;
        pathTargetInstanceTriIndex &gt; <span class="hljs-number">-1</span>) &amp;&amp;
        (instSettings.isCurrentGroundTriangleIndex !=
        instSettings.isPathStartTriangleIndex ||
        pathTargetInstanceTriIndex !=
        instSettings.isPathTargetTriangleIndex)) {
        instances.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">setPathStartTriIndex</span>(
      instSettings.isCurrentGroundTriangleIndex);
      instances.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">setPathTargetTriIndex</span>(
        pathTargetInstanceTriIndex);
</code></pre>
    <p class="normal">In the case of any changes, we adjust the start and the target triangle of the current instance. With the most recent data for the triangles, we can call <code class="inlineCode">findPath()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">      std::vector&lt;<span class="hljs-type">int</span>&gt; pathToTarget =
        mPathFinder.<span class="hljs-built_in">findPath</span>(
        instSettings.isCurrentGroundTriangleIndex,
        pathTargetInstanceTriIndex);
</code></pre>
    <p class="normal">The result may be empty if no valid path has been found. In that case, we disable the navigation of the instance<a id="_idIndexMarker786"/> and invalidate the target instance by setting it to <code class="inlineCode">-1</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">      <span class="hljs-keyword">if</span> (pathToTarget.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {
        instances.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">setNavigationEnabled</span>(<span class="hljs-literal">false</span>);
        instances.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">setPathTargetInstanceId</span>(<span class="hljs-number">-1</span>);
      } <span class="hljs-keyword">else</span> {
        instances.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">setPathToTarget</span>(pathToTarget);
      }
</code></pre>
    <p class="normal">If the path was valid, we set the path indices in the instance.</p>
    <p class="normal">Since the path will only update on changes, we get the saved or just updated path of the instance now:</p>
    <pre class="programlisting code"><code class="hljs-code">    std::vector&lt;<span class="hljs-type">int</span>&gt; pathToTarget =
      instances.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">getPathToTarget</span>();
</code></pre>
    <p class="normal">To avoid awkward movement when starting or ending the path to a target, we remove the start and target triangles from the instance path:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> (pathToTarget.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) {
      pathToTarget.<span class="hljs-built_in">pop_back</span>();
    }
    <span class="hljs-keyword">if</span> (pathToTarget.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) {
      pathToTarget.<span class="hljs-built_in">erase</span>(pathToTarget.<span class="hljs-built_in">begin</span>());
    }
</code></pre>
    <p class="normal">The path is created between the center of the ground triangle the instance is currently standing on to the ground triangle the target resides. If the instance is already closer than the triangle center, the path would point backward, and the instance may never leave the current ground triangle. We could also remove the elements in the <code class="inlineCode">PathFinder</code> class, but if we want to use the data generated in <code class="inlineCode">findPath()</code> anywhere else, the triangles may be needed. So, we cut off the triangle indices here.</p>
    <p class="normal">As the last step for pathfinding, we rotate the instance toward the next path point or the target, depending on whether we have a path left in <code class="inlineCode">pathToTarget</code> or not:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> (pathToTarget.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-type">int</span> nextTarget = pathToTarget.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>);
      glm::vec3 destPos =
        mPathFinder.<span class="hljs-built_in">getTriangleCenter</span>(nextTarget);
      instances.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">rotateTo</span>(destPos, deltaTime);
    } <span class="hljs-keyword">else</span> {
      instances.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">rotateTo</span>(pathTargetWorldPos,
        deltaTime);
    }
</code></pre>
    <p class="normal">The call to <code class="inlineCode">getTriangleCenter()</code> of the <code class="inlineCode">PathFinder</code> class returns the center of the requested triangle in world coordinates. This center point is then fed into the <code class="inlineCode">rotateTo()</code> method of the instance, so let’s look<a id="_idIndexMarker787"/> at the implementation of the rotation method next.</p>
    <h2 id="_idParaDest-404" class="heading-2">Rotating the instance to reach the target</h2>
    <p class="normal">The new <code class="inlineCode">public</code> method<a id="_idIndexMarker788"/> called <code class="inlineCode">rotateTo()</code> must be added to the <code class="inlineCode">AssimpInstance</code> class.</p>
    <p class="normal">First, we check if the instance walks or runs right now. Rotating the instance while standing idle on the ground may look strange:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span> (mInstanceSettings.isMoveState != moveState::walk &amp;&amp;
      mInstanceSettings.isMoveState != moveState::run) {
    <span class="hljs-keyword">return</span>;
  }
</code></pre>
    <p class="normal">Then, we get the rotation vector of the current instance and the vector from our position toward the target position:</p>
    <pre class="programlisting code"><code class="hljs-code">  glm::<span class="hljs-type">vec3</span> myRotation = <span class="hljs-built_in">get2DRotationVector</span>();
  glm::<span class="hljs-type">vec3</span> twoDimWorldPos =
    glm::<span class="hljs-type">vec3</span>(mInstanceSettings.isWorldPosition.x,
     <span class="hljs-number">0.0f</span>, mInstanceSettings.isWorldPosition.z);
  glm::<span class="hljs-type">vec3</span> toTarget = glm::<span class="hljs-built_in">normalize</span>(glm::<span class="hljs-type">vec3</span>(
    targetPos.x, <span class="hljs-number">0.0f</span>, targetPos.z) - twoDimWorldPos);
</code></pre>
    <p class="normal">We are only interested in a rotation around the Y axis, so we use the two-dimensional rotation vector of the instance and reduce the vector to the target and also to the values of the X and Z dimensions.</p>
    <p class="normal">By using the two vectors <code class="inlineCode">myRotation</code> and <code class="inlineCode">toTarget</code>, we can calculate the angle between the two vectors via the dot product:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">float</span> angleDiff = glm::<span class="hljs-built_in">degrees</span>(std::<span class="hljs-built_in">acos</span>(
    glm::<span class="hljs-built_in">dot</span>(myRotation, toTarget)));
</code></pre>
    <p class="normal">Finally, we calculate a quaternion containing the rotation between the two vectors, extract the Euler angles, and use the <code class="inlineCode">y</code> element of the angle to rotate the instance:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span> (angleDiff &gt; <span class="hljs-number">6.0f</span>) {
    glm::quat destRoation =
      glm::<span class="hljs-built_in">rotation</span>(toTarget, myRotation);
    glm::vec3 angles = glm::<span class="hljs-built_in">eulerAngles</span>(destRoation);
    <span class="hljs-built_in">rotateInstance</span>(glm::<span class="hljs-built_in">degrees</span>(angles.y) *
      deltaTime * <span class="hljs-number">2.0f</span>);
  }
</code></pre>
    <p class="normal">The multiplication with <code class="inlineCode">deltaTime</code> makes the instance rotation smooth since the angle in every frame is small. The initial comparison of the <code class="inlineCode">angleDiff</code> value makes sure we have a small “dead zone” left, leading to fewer rotations if the path is nearly straight and avoiding oscillations in case the rotation<a id="_idIndexMarker789"/> oversteers a bit.</p>
    <p class="normal">If the target is moving around in the level, the dead zone also reduces the number of corrections when the path of the instance is recreated. By carefully tuning the amount of oversteering and the dead zone angle, a chasing instance will behave more naturally since both parameters could reduce the number of directional changes while following the target.</p>
    <p class="normal">To make the calculated path visible, we should also add a visual output for the renderer.</p>
    <h2 id="_idParaDest-405" class="heading-2">Adding debug lines for the path</h2>
    <p class="normal">Drawing the path to the screen is astonishingly easy. Next to adding a control Boolean named <code class="inlineCode">rdDrawInstancePaths</code> to the <code class="inlineCode">OGLRenderData</code> struct for OpenGL, respective to the <code class="inlineCode">VkRenderData</code> struct for Vulkan, a<a id="_idIndexMarker790"/> new line mesh in the renderer and a checkbox in the <code class="inlineCode">UserInterface</code> class, creating the lines between all path points is easy. The best place for the new code is after the code added in the <em class="italic">Calculating the path to the target</em> section.</p>
    <p class="normal">First, we check if we should create the lines at all and if we have a valid target:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> (mRenderData.rdDrawInstancePaths &amp;&amp;
      pathTargetInstance &gt; <span class="hljs-number">-1</span>) {
</code></pre>
    <p class="normal">Then, we set the desired color and a height offset for the path and create a vertex to draw the line:</p>
    <pre class="programlisting code"><code class="hljs-code">      glm::<span class="hljs-type">vec3</span> pathColor = glm::<span class="hljs-type">vec3</span>(<span class="hljs-number">0.4f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.4f</span>);
      glm::<span class="hljs-type">vec3</span> pathYOffset = glm::<span class="hljs-type">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>);
      OGLLineVertex vert;
      vert.color = pathColor;
</code></pre>
    <p class="normal">Next, we add the world position of the current instance as the starting point for the lines:</p>
    <pre class="programlisting code"><code class="hljs-code">      vert.position = instSettings.isWorldPosition +
        pathYOffset;
      mInstancePathMesh-&gt;vertices.<span class="hljs-built_in">emplace_back</span>(vert);
</code></pre>
    <p class="normal">If we have a valid path, we extract the world position of the first triangle center of the path as the second point for the first line. Since we already removed the starting triangle, the line will be drawn to the next triangle in the path:</p>
    <pre class="programlisting code"><code class="hljs-code">      <span class="hljs-keyword">if</span> (pathToTarget.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) {
        vert.position = mPathFinder.<span class="hljs-built_in">getTriangleCenter</span>(
          pathToTarget.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>)) + pathYOffset;
        mInstancePathMesh-&gt;vertices.<span class="hljs-built_in">emplace_back</span>(vert);
</code></pre>
    <p class="normal">Then, we create a new temporary line mesh and retrieve the vertices of the path segments by calling <code class="inlineCode">getAsLineMesh()</code> of the <code class="inlineCode">PathFinder</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">        std::shared_ptr&lt;OGLLineMesh&gt; pathMesh =
          mPathFinder.<span class="hljs-built_in">getAsLineMesh</span>(pathToTarget,
          pathColor, pathYOffset);
        mInstancePathMesh-&gt;vertices.<span class="hljs-built_in">insert</span>(
        mInstancePathMesh-&gt;vertices.<span class="hljs-built_in">end</span>(),
          pathMesh-&gt;vertices.<span class="hljs-built_in">begin</span>(),
          pathMesh-&gt;vertices.<span class="hljs-built_in">end</span>());
</code></pre>
    <p class="normal">The helper method <code class="inlineCode">getAsLineMesh()</code> just extracts the center points of the ground triangles on the path, adds the desired <a id="_idIndexMarker791"/>offset to the world position of the vertices, and creates lines from the vertices.</p>
    <p class="normal">Now, we add the last position as a possible starting point for the last line:</p>
    <pre class="programlisting code"><code class="hljs-code">        vert.position = mPathFinder.<span class="hljs-built_in">getTriangleCenter</span>(
          pathToTarget.<span class="hljs-built_in">at</span>(pathToTarget.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) +
          pathYOffset;
        mInstancePathMesh-&gt;vertices.<span class="hljs-built_in">emplace_back</span>(vert);
      }
</code></pre>
    <p class="normal">As a final step for the line creation, we add the world position of the target:</p>
    <pre class="programlisting code"><code class="hljs-code">      vert.position = pathTargetWorldPos + pathYOffset;
      mInstancePathMesh-&gt;vertices.<span class="hljs-built_in">emplace_back</span>(vert);
</code></pre>
    <p class="normal">If the path is empty after removing the first and/or last element, we skip the code inside the <code class="inlineCode">if</code> condition and draw only a line from our own position to the target. This happens only if we have a valid target, and the start and target triangles are directly next to each other. If an error occurs during pathfinding and the path is empty, we reset the target instance, and the line is no longer drawn.</p>
    <p class="normal">To draw the created lines, a new <code class="inlineCode">private</code> method called <code class="inlineCode">drawInstancePaths()</code> is created in the renderer class <code class="inlineCode">OGLRendere.cpp</code> or <code class="inlineCode">VkRender.cpp</code> that just sends the lines to the shader. After enabling the navigation debug draw by enabling the <strong class="screenText">Enable Navigation</strong> checkbox under the <strong class="screenText">Navigation</strong> header and the <strong class="screenText">Draw Instance Path</strong> checkbox under the <strong class="screenText">Levels</strong> header, navigation paths for the instances will be drawn as green lines, similar to <em class="italic">Figure 13.12</em>:</p>
    <figure class="mediaobject"><img src="../Images/B22428_13_12.png" alt="" width="1376" height="679"/></figure>
    <p class="packt_figref">Figure 13.12: Debug lines showing the path of the instances</p>
    <p class="normal">In <em class="italic">Figure 13.12</em>, the model of a traffic cone was added and marked as a navigation target. Then, the instances were instructed to walk to their desired targets.</p>
    <p class="normal">The jagged paths between the instances and the targets are a result of large ground triangles in the selected level map. Since the<a id="_idIndexMarker792"/> instances are moving from triangle center to triangle center, the paths have larger angles as the distances between the center points are quite large. A level with smaller ground triangles will have much smoother paths for the instances.</p>
    <h1 id="_idParaDest-406" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we implemented a simple path-finding navigation. After an overview of methods to allow computer-controlled instances to navigate in a game map, we explored and implemented the A* path-finding algorithm, supported by a custom navigation mesh creation. Then, we modified models to use them as navigation targets in the virtual world and enabled instances to use instances of the special models as path targets. As the last step, we added navigation to the instances, allowing them to walk or run toward a random target.</p>
    <p class="normal">In the next and last chapter of the book, we will take a step back from the implementation side and take a look at different ways to enhance immersion and visual quality. We will start with the audible side and discuss methods and tools to add sound effects and music to the application. Then, we will check out ideas to fill the world with more life, followed by a discussion about ideas to enhance the visuals in the virtual world. We will look at quests and interactions between instances and, finally, explore the impact of daytime and weather changes.</p>
    <h1 id="_idParaDest-407" class="heading-1">Practical sessions</h1>
    <p class="normal">Here are some additions you could make to the code:</p>
    <ul>
      <li class="bulletList">Smooth the path even with large ground triangles.</li>
    </ul>
    <p class="normal-one">By looking up the next couple of path segments, it may be possible to create an average of the segments. For sharper turns, the transitions between the triangles could be smoothed by using splines.</p>
    <ul>
      <li class="bulletList">Clean up the generated triangle neighbor list.</li>
    </ul>
    <p class="normal-one">Right now, the list of adjacent triangles is quite large. This fact can be seen when the neighbor mesh debug drawing for a level is activated. Try to find a solution to include only triangles sharing parts of an edge.</p>
    <ul>
      <li class="bulletList">Add a minimum distance between walls and path lines.</li>
    </ul>
    <p class="normal-one">For the generated ground triangles, some of the center positions may be so close to a wall that the instance will collide when following the path. In some cases, the paths even go through edges of level geometry when the triangles are seen as adjacent. When creating the ground triangles, try to find the outlines of the mesh and reduce the size by a configurable amount.</p>
    <ul>
      <li class="bulletList">Use the instance AABB to detect narrow passages.</li>
    </ul>
    <p class="normal-one">Some maps may have passages where the navigation needs to be exact. In the absence of a real navigation mesh, you could try to use the bounding box of the instance along the path to find possible collisions and adjust the path to avoid a collision with the level structures.</p>
    <ul>
      <li class="bulletList">Advanced difficulty: Create a navigation mesh in an editor and load that mesh.</li>
    </ul>
    <p class="normal-one">If you are confident working with a tool like Blender, you could try to create a navigation mesh as a separate mesh of a level, or even as a separate file, saved next to the level file. Then, load the navigation mesh into the <code class="inlineCode">PathFinder</code> class to have a collision-free ground for the instances.</p>
    <h1 id="_idParaDest-408" class="heading-1">Additional resources</h1>
    <ul>
      <li class="bulletList">Ghost navigation in Pac-Man: <a href="https://gameinternals.com/understanding-pac-man-ghost-behavior"><span class="url">https://gameinternals.com/understanding-pac-man-ghost-behavior</span></a></li>
      <li class="bulletList">Dijkstra’s algorithm: <a href="https://graphicmaths.com/computer-science/graph-theory/dijkstras-algorithm/"><span class="url">https://graphicmaths.com/computer-science/graph-theory/dijkstras-algorithm/</span></a></li>
      <li class="bulletList">Quake III Arena’s area awareness system: <a href="http://www.kbs.twi.tudelft.nl/docs/MSc/2001/Waveren_Jean-Paul_van/thesis.pdf"><span class="url">http://www.kbs.twi.tudelft.nl/docs/MSc/2001/Waveren_Jean-Paul_van/thesis.pdf</span></a></li>
      <li class="bulletList">Navigation meshes: <a href="https://www.gamedev.net/tutorials/programming/artificial-intelligence/navigation-meshes-and-pathfinding-r4880/"><span class="url">https://www.gamedev.net/tutorials/programming/artificial-intelligence/navigation-meshes-and-pathfinding-r4880/</span></a></li>
      <li class="bulletList">Shakey the Robot: <a href="https://www.sri.com/hoi/shakey-the-robot/"><span class="url">https://www.sri.com/hoi/shakey-the-robot/</span></a></li>
      <li class="bulletList">Introduction to A*: <a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html"><span class="url">https://www.redblobgames.com/pathfinding/a-star/introduction.html</span></a></li>
      <li class="bulletList">Using A* with navigation meshes: <a href="https://medium.com/@mscansian/a-with-navigation-meshes-246fd9e72424"><span class="url">https://medium.com/@mscansian/a-with-navigation-meshes-246fd9e72424</span></a></li>
      <li class="bulletList">Navigation meshes in Unreal Engine: <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/basic-navigation-in-unreal-engine"><span class="url">https://dev.epicgames.com/documentation/en-us/unreal-engine/basic-navigation-in-unreal-engine</span></a></li>
      <li class="bulletList">Implementing A* in an Unreal Engine project: <a href="https://www.youtube.com/watch?v=xakl29fupCA"><span class="url">https://www.youtube.com/watch?v=xakl29fupCA</span></a></li>
      <li class="bulletList">Training an unbeatable AI in Trackmania: <a href="https://www.youtube.com/watch?v=Dw3BZ6O_8LY"><span class="url">https://www.youtube.com/watch?v=Dw3BZ6O_8LY</span></a></li>
      <li class="bulletList">Recast Navigation: <a href="https://github.com/recastnavigation/recastnavigation"><span class="url">https://github.com/recastnavigation/recastnavigation</span></a></li>
      <li class="bulletList">Optimization for Smooth Paths: <a href="https://www.gameaipro.com/GameAIPro3/GameAIPro3_Chapter20_Optimization_for_Smooth_Paths.pdf"><span class="url">https://www.gameaipro.com/GameAIPro3/GameAIPro3_Chapter20_Optimization_for_Smooth_Paths.pdf</span></a></li>
      <li class="bulletList">Toward More Realistic Pathfinding: <a href="https://www.gamedeveloper.com/programming/toward-more-realistic-pathfinding"><span class="url">https://www.gamedeveloper.com/programming/toward-more-realistic-pathfinding</span></a></li>
    </ul>
    <h1 id="_idParaDest-409" class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/cppgameanimation"><span class="url">https://packt.link/cppgameanimation</span></a></p>
    <p class="normal"><img src="../Images/QR_code_Discord.png" alt="A qr code with black squares  AI-generated content may be incorrect." width="150" height="150"/></p>
  </div>
</div></div></body></html>