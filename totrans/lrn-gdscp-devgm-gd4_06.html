<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-155"><a id="_idTextAnchor411"/>6</h1>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor412"/>Creating a World of Your Own in Godot</h1>
			<p>In <em class="italic">Part 1</em> of this book, you learned the basics of programming! No small feat if you ask me. So, congrats on that milestone! Now, it’s time to tie it all together and start working on our game.</p>
			<p>In the early days of game development, everything happened through code. A computer wizard had to program everything, from systems and features to levels and asset placement. In recent times, the tooling for creating games has gotten way better, is free, and is very user-friendly.</p>
			<p>Godot, like most modern game engines (Unity, Unreal Engine, Construct, and others), has a graphical interface that makes it <a id="_idIndexMarker332"/>easy to drag and drop elements of our game into levels or other scenes. In this chapter, we’ll learn how to use this graphical interface by creating a rudimentary player character and a little world for them to inhabit.</p>
			<p>We’ll also learn some tricks to tie the code and graphical editor together with node references and variable exports.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>The node-based system of Godot</li>
				<li>Creating a player character</li>
				<li>Referencing nodes in scripts</li>
				<li>Exporting variables</li>
				<li>Making rudimentary shapes<a id="_idTextAnchor413"/></li>
			</ul>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor414"/>Technical requirements</h1>
			<p>Because we will create a game from scratch, I took the liberty of providing you with the base of a project. You can find this base project in the folder for this chapter under <code>/start</code>. This project supplies some assets, such as pictures and sounds. Creating these assets is outside the scope of this book. The resulting project files for this chapter can be found under <code>/result</code> of this chapter’s folder.</p>
			<p>In the subsequent chapters, you’ll find the resulting project in the <code>root</code> folder of that chapter. It’s assumed that you use the results from the previous chapter as a starting point.</p>
			<p>So, get the starting project, and let’s dive in: <a href="https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter06/start">https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter06/start</a>.<a id="_idTextAnchor415"/></p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor416"/>Game design</h1>
			<p>Before mindlessly creating a game, let’s plan out what kind of game we want to make. This will structure our thoughts and make sure we work toward the game we want to make without taking unnecessary detours. The best<a id="_idIndexMarker333"/> way to do this is through a <strong class="bold">game design document</strong> (<strong class="bold">GDD</strong>). Though there is no set format for this kind of <a id="_idIndexMarker334"/>document, it should eventually answer some basic questions about the game:</p>
			<ul>
				<li>Which genre is the game?</li>
				<li>What mechanics will be in the game?</li>
				<li>What is the story?</li>
			</ul>
			<p>Some game design documents are hundreds of pages long. But as this is not a game design book, let’s define our game regarding these three questions and then work out the details as we g<a id="_idTextAnchor417"/>o.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor418"/>Genre</h2>
			<p>Recently, we have witnessed the<a id="_idIndexMarker335"/> birth of a new<a id="_idIndexMarker336"/> genre known as <strong class="bold">vampire survivor-likes</strong>, also known as a <strong class="bold">VS</strong> game. In this type of game, you control a character in a 2D top-down world. The character has to defeat waves of monsters coming after them by shooting them. The player can control the character by moving them around, but shooting happens automatically. It does not require input.</p>
			<p>This genre has a huge player base, and the base game is relatively simple to implement and yet satisfying to play. Therefore, it would be the ideal type of game to recreate throughout the following chapt<a id="_idTextAnchor419"/>ers.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor420"/>Mechanics</h2>
			<p>The survivor-like genre has some <a id="_idIndexMarker337"/>staple mechanics that are very important to get right:</p>
			<ul>
				<li><strong class="bold">2D world</strong>: The playing field is a 2D plane on which we have a top-down view. Some of them are indeed in 3D, but the mechanics still shine in 2D.</li>
				<li><strong class="bold">Movement of the character</strong>: We need to be able to move the character around in the world.</li>
				<li><strong class="bold">Waves of enemies</strong>: We need enemies that threaten to kill the player and we need to spawn them so that they pose a proper challenge .</li>
				<li><strong class="bold">Automatic shooting</strong>: The player character will automatically shoot projectiles aimed at the enemies.</li>
			</ul>
			<p>Now that we have sorted out the genre and staple mechanics, let’s work out the story our game will be base<a id="_idTextAnchor421"/>d on.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor422"/>Story</h2>
			<p>Let’s not burden ourselves too<a id="_idIndexMarker338"/> much with writing the whole story. In games, the story can also be told through how the game looks and feels. So, we can specify a general setting that binds the whole experience together.</p>
			<p>How about this as our setting: You are a medieval knight fighting in the king’s tournament to find the strongest soldier in the whole land. You’ll have to battle multiple enemies, such as orcs and trolls, in multiple rounds, each harder than the last. The only weapon you are given is a bow, with which you can shoot arrows at your adversaries.</p>
			<p>Now that we have an idea of the kind of game we are creating, let’s get in<a id="_idTextAnchor423"/>to it!</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor424"/>Creating a player character</h1>
			<p>We’ll start by creating a<a id="_idIndexMarker339"/> rudimentary player character for our game:</p>
			<ol>
				<li>Open the <code>main.tscn</code> file I provided in the project base.</li>
				<li>Select the <code>root</code> node, called <code>Main</code>, and press the <strong class="bold">Add Child </strong><strong class="bold">Node</strong> button:</li>
			</ol>
			<div><div><img alt="Figure 6.1 – The button to add a new child node to the selected node in the tree" src="img/B19358_06_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The button to add a new child node to the selected node in the tree</p>
			<ol>
				<li value="3">Then, find and add a <strong class="bold">Node2D</strong> node. You can use the search bar at the top to make searching for the node easier. This is a node that has a position in 2D space:</li>
			</ol>
			<div><div><img alt="Figure 6.2 – Finding and selecting the Node2D node" src="img/B19358_06_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Finding and selecting the Node2D node</p>
			<ol>
				<li value="4">Next, rename this Node2D as <code>Player</code> by right clicking the node and choosing <strong class="bold">Rename</strong>, just like we did in <a href="B19358_02.xhtml#_idTextAnchor044"><em class="italic">Chapter 2</em></a>.</li>
			</ol>
			<p><code>Player</code> will be the base <a id="_idIndexMarker340"/>node for our player character. From here, we will add all the other nodes that comprise the <code>Player</code> node. The first of these nodes will be a s<a id="_idTextAnchor425"/>prite.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor426"/>Adding a sprite</h2>
			<p>The first thing we can do to flesh<a id="_idIndexMarker341"/> out our player character is to give it a visual, something that the player can relate to as the main character. Follow <em class="italic">Steps 1</em> to <em class="italic">3</em> in the <em class="italic">Creating a player character</em> section again to add a node called <code>Sprite2D</code> to the <code>Player</code> node so that the scene tree looks like this:</p>
			<div><div><img alt="Figure 6.3 – The scene tree so far" src="img/B19358_06_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – The scene tree so far</p>
			<p>The <code>Sprite2D</code> node is a node<a id="_idIndexMarker342"/> that can display an image, also called a <code>Sprite2D</code>, you’ll see that the <strong class="bold">Inspector</strong> view on the right-hand side gets populated with information about that node:</p>
			<div><div><img alt="Figure 6.4 – The Inspector view of a Sprite2D node" src="img/B19358_06_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – The Inspector view of a Sprite2D node</p>
			<p>There are settings for <strong class="bold">Texture</strong>, <strong class="bold">Offset</strong>, <strong class="bold">Animation</strong>, <strong class="bold">Region</strong>, and more. You can look through them to get an idea<a id="_idIndexMarker343"/> of all the available settings. The different tabs are <strong class="bold">Property Groups</strong>, while the settings themselves are called <strong class="bold">Properties</strong>.</p>
			<p>We are only interested in the <strong class="bold">Texture</strong> property because this is where we can set the image this node displays. So, let’s add a sprite for our character!</p>
			<ol>
				<li>In the <code>assets/sprites/character</code>.<p class="list-inset">Here, you’ll find a bunch of premade character sprites.</p></li>
			</ol>
			<p class="callout-heading">Kenney assets</p>
			<p class="callout">The assets we are using in this book all come from Kenney and are free to use in any project you want. You can find more of his great assets at <a href="https://kenney.nl/">https://kenney.nl/</a>.</p>
			<ol>
				<li value="2">Drag and drop any of <a id="_idIndexMarker344"/>them onto the <code>Sprite2D</code> node. I’m using the <code>character01.png</code> texture.</li>
				<li>The <code>Sprite2D</code> node should now look something like this:</li>
			</ol>
			<div><div><img alt="Figure 6.5 – Adding a texture to a sprite node" src="img/B19358_06_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Adding a texture to a sprite node</p>
			<p>The sprite should also <a id="_idIndexMarker345"/>turn up in the 2D view of the editor. However, it seems to be very small. That’s because the image is only <code>16</code> × <code>16</code> pixels in size. Let’s scale it up a little. Under the <code>3</code>. You can set the scale for the X and Y axes separately, but we want them both to be equal so that the sprite scales without stretching:</p>
			<div><div><img alt="Figure 6.6 – The Transform properties of a sprite node" src="img/B19358_06_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – The Transform properties of a sprite node</p>
			<p>Oh no – what’s this?</p>
			<div><div><img alt="Figure 6.7 – A blurry pixel art sprite" src="img/B19358_06_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – A blurry pixel art sprite</p>
			<p>The sprite looks blurry! This<a id="_idIndexMarker346"/> happened because we’re using <strong class="bold">pixel art</strong> assets, a style well known for its <a id="_idIndexMarker347"/>blocky pixels. When upscaling, Godot Engine uses an algorithm that blurs out these pixels. This is great for other art styles, such as hand-drawn or vector art, but not for pixel art. Luckily, there is a solution. Follow these steps:</p>
			<ol>
				<li>Navigate to <strong class="bold">Project </strong>| <strong class="bold">Project Settings...</strong>:</li>
			</ol>
			<div><div><img alt="Figure 6.8 – Going to Project Settings..." src="img/B19358_06_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Going to Project Settings...</p>
			<ol>
				<li value="2">Under <strong class="bold">Rendering</strong> | <strong class="bold">Textures</strong>, set<a id="_idIndexMarker348"/> <strong class="bold">Default Texture Filter</strong> to <strong class="bold">Nearest</strong>:</li>
			</ol>
			<div><div><img alt="Figure 6.9 – Setting Default Texture Filter to Nearest" src="img/B19358_06_09.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Setting Default Texture Filter to Nearest</p>
			<p>These settings will scale the image in a way that is better suited for pixel art. Now, our sprite looks way better!</p>
			<div><div><img alt="Figure 6.10 – A crisp pixel art sprite" src="img/B19358_06_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – A crisp pixel art sprite</p>
			<p>Now that we can see our <a id="_idIndexMarker349"/>player, let’s look into displaying a hea<a id="_idTextAnchor427"/>lth UI.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor428"/>Displaying health</h2>
			<p>Next, let’s add something to display the<a id="_idIndexMarker350"/> player’s health above the character. Sure, we haven’t created a script for the player yet that tracks health, but we can put the visuals i<a id="_idTextAnchor429"/>n place. We will use a <code>Label</code> node, which can display text in the game:</p>
			<ol>
				<li>Find and add a <code>Label</code> node to the <code>Player</code> node.</li>
				<li>Name the node <code>HealthLabel</code>:</li>
			</ol>
			<div><div><img alt="Figure 6.11 - The scene tree with the HealthLabel node added" src="img/B19358_06_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 - The scene tree with the HealthLabel node added</p>
			<ol>
				<li value="3">When selecting the <code>Label</code> node, the <code>10/10</code> into it as if the player has 10 out of their 10 lives:</li>
			</ol>
			<div><div><img alt="Figure 6.12 – The Inspector view of a Label node with the text set to 10/10" src="img/B19358_06_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – The Inspector view of a Label node with the text set to 10/10</p>
			<ol>
				<li value="4">Next, drag the<a id="_idIndexMarker351"/> label on top of the player so that it’s out of the way of the sprite:</li>
			</ol>
			<div><div><img alt="Figure 6.13 – Repositioning the HealthLabel node above the player character" src="img/B19358_06_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Repositioning the HealthLabel node above the player character</p>
			<p>Great! With the <code>HealthLabel</code> label in place, we can update it through a script later on (see the <em class="italic">Creating the player script</em> section). This is all we need to set up the nodes in the scene tree.</p>
			<p>Now, let’s see how we <a id="_idIndexMarker352"/>can manipulate the nodes we’ve <a id="_idTextAnchor430"/>added.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor431"/>Manipulating nodes in the editor</h2>
			<p>Now that we have a small <a id="_idIndexMarker353"/>scene tree in place, let’s look at what tools we have available to manipulate the nodes. If you look at the top right of the 2D editor, you’ll see some of these tools:</p>
			<div><div><img alt="Figure 6.14 – The toolbar in the 2D editor view" src="img/B19358_06_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – The toolbar in the 2D editor view</p>
			<p>There are many interesting tools in this toolbar, but the first four are the most important ones for now:</p>
			<ul>
				<li><strong class="bold">Select mode</strong>: This is the default mode and is a multitool. You can select nodes within the scene and drag them around.</li>
				<li><strong class="bold">Move mode</strong>: In this mode, you can move the selected node.</li>
				<li><strong class="bold">Rotate mode</strong>: In this mode, you can rotate the selected node.</li>
				<li><strong class="bold">Scale mode</strong>: In this mode, you can scale the selected node.</li>
			</ul>
			<p>Try these modes by selecting the <code>Player</code> node and messing around a bit. This could lead you to a result like this:</p>
			<div><div><img alt="Figure 6.15 – The Player node after multiple transform manipulations" src="img/B19358_06_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – The Player node after multiple transform manipulations</p>
			<p>You’ll also notice that when you move, rotate, or scale a node, its child nodes will be manipulated in the same way. This<a id="_idIndexMarker354"/> inheritance of transformation is the strength of the hierarchical node system.</p>
			<p>If you look at the <code>Player</code> node, you’ll see the exact modifications you made to it. If you change any of these values, you’ll see them reflected in the 2D editor too:</p>
			<div><div><img alt="Figure 6.16 – The Transform parameters after multiple transform manipulations" src="img/B19358_06_16.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – The Transform parameters after multiple transform manipulations</p>
			<p>As an experiment, try changing the value for <code>Skew</code> from the <strong class="bold">Inspector</strong> view.</p>
			<p>Before you continue with the following sections, don’t forget to reset all these manipulations in the <code>Player</code> node. You can do this simply by pressing the ↺ symbol next to each property. This button will set the property back to its default value. Let’s also set the position of the <code>Player</code> node so that the player character is roughly centered on the screen:</p>
			<div><div><img alt="Figure 6.17 – Positioning the player character in the middle of the screen" src="img/B19358_06_17.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17 – Positioning the player character in the middle of the screen</p>
			<p>With that, we’ve finished creating the base for our player character and learned how we can manipulate nodes within the editor. Next, we’ll focus on the player character’s script and learn how we <a id="_idIndexMarker355"/>can manipulate nodes through code.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor432"/>Creating the player script</h1>
			<p>This is the moment we have<a id="_idIndexMarker356"/> been training for. We already know how to do this! So, start by creating a new script that is attached to the <code>Player</code> node:</p>
			<ol>
				<li>Right-click the <code>Player</code> node and select <strong class="bold">Attach Script</strong>:</li>
			</ol>
			<div><div><img alt="Figure 6.18 – Attaching a script to the Player node" src="img/B19358_06_18.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.18 – Attaching a script to the Player node</p>
			<ol>
				<li value="2">In the dialogue<a id="_idIndexMarker357"/> that pops up, call the script <code>player.gd</code>:</li>
			</ol>
			<div><div><img alt="Figure 6.19 – Calling the script player.gd" src="img/B19358_06_19.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.19 – Calling the script player.gd</p>
			<ol>
				<li value="3">We’ll keep it simple <a id="_idIndexMarker358"/>for now and just add some code to manage the health of the p<a id="_idTextAnchor433"/>layer:<pre class="source-code">
extends <a id="_idTextAnchor434"/>N<a id="_idTextAnchor435"/>ode2D
const MAX_HEALTH: in<a id="_idTextAnchor436"/>t<a id="_idTextAnchor437"/> = 10
var health: in<a id="_idTextAnchor438"/>t<a id="_idTextAnchor439"/> = 10
func add__health_points(difference:<a id="_idTextAnchor440"/> int):
   health += diff<a id="_idTextAnchor441"/>erence
   health = clamp(health, 0, MAX_HEALTH)</pre><p class="list-inset">The <code>clamp()</code> function we use in the <code>add_health_points()</code> function takes a numeric value as the first argument and keeps it in between the second two numeric parameters.</p></li>			</ol>
			<p>This way, the health is always between <code>0</code> and <code>MAX_HEALTH</code>, which is <code>10</code> at the max.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Remember that you can <em class="italic">Ctrl</em> and click on Windows and Linux or <em class="italic">Option</em> and click on Mac on any function to go to the documentation and have a look at what it does.</p>
			<p>With this in place, we can <a id="_idIndexMarker359"/>change the player’s health. Now, let’s look at how we can update the <code>HealthLabel</code> node we created earlier to reflect this<a id="_idTextAnchor442"/> value.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor443"/>Referencing nodes in a script</h2>
			<p>We want to update the <code>HealthLabel</code> node of our player character according to the amount of health the <a id="_idIndexMarker360"/>player still has left. To change nodes in our scene from within the script, we need to be able to reference them. Luckily, this is pretty easy in Godot 4.</p>
			<p>There are multiple ways to get a node’s reference, but the easiest is the dollar notation. This notation looks li<a id="_idTextAnchor444"/>ke this:</p>
			<pre class="source-code">
$HealthLabel</pre>			<p>The notation starts with a dollar sign (<code>$</code>), followed by the path through the scene tree to the node we want. Here, we reference the health label we created earlier.</p>
			<p>Note that this path is relative to the node with the script where this path is mentioned. So if the main node has a script and we want to reference the player’s health label, the notation would look li<a id="_idTextAnchor445"/>ke this:</p>
			<pre class="source-code">
$Player/HealthLabel</pre>			<p>So, now that we know how to get the reference to a node, let’s create a small function that updates the player’s health label and call it in the <code>add_health_points()</code> f<a id="_idTextAnchor446"/>unction:</p>
			<pre class="source-code">
func update_health_<a id="_idTextAnchor447"/>label():
   <code>update_health_label()</code> function, we take the <code>HealthLabel</code> node and directly change its <code>text</code> variable. This will change whatever text the label is showing on the screen.</p>
			<p>Here, we use a new function named <code>str()</code> in <code>update_health_label()</code>. This function takes any parameter and converts it into a string. We need to do this because the <code>health</code> and <code>MAX_HEALTH</code> values, which<a id="_idIndexMarker361"/> are integers, we’ll have to convert them into a string.</p>
			<p>Now, we can use this <code>update_health_label()</code> function whenever we change the <code>heal<a id="_idTextAnchor448"/>th</code> value:</p>
			<pre class="source-code">
func add_health_points(differen<a id="_idTextAnchor449"/>ce: int):
   health += d<a id="_idTextAnchor450"/>ifference
   health = clamp(health, 0, MA<a id="_idTextAnchor451"/>X<a id="_idTextAnchor452"/>_HEALTH)
   <code>HealthLabel</code> node is displaying. But there is a better way of accessing or referencing nodes within the scene tree: by caching them. We’ll take a look at t<a id="_idTextAnchor453"/>hat next.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor454"/>Caching node references</h2>
			<p>Though the dollar notation is very<a id="_idIndexMarker362"/> convenient, sometimes, you will need to access a certain node often. In such cases, using the dollar notation will be slow because the engine will have to keep searching for the node within the tree and accessing it every time.</p>
			<p class="callout-heading">Caching</p>
			<p class="callout">In computer lingo, caching means storing a certain piece of data for later so that you don’t have to load it every time it is needed.</p>
			<p>To stop searching the node each time, we can save a reference to the node in a variable. For example, we can change the player scrip<a id="_idTextAnchor455"/>t like so:</p>
			<pre class="source-code">
exte<a id="_idTextAnchor456"/>n<a id="_idTextAnchor457"/>ds Node2D
<strong class="bold">@onready var _health_label: Label = $H<a id="_idTextAnchor458"/>e<a id="_idTextAnchor459"/>althLabel</strong>
func update_healt<a id="_idTextAnchor460"/>h_label():
   <code>HealthLabel</code> node in a variable called <code>_health_label</code>. Later on, we can use this reference.</p>
			<p>The upside is, of course, that we only <a id="_idIndexMarker363"/>have to change the path to the node at one point: the line where the reference gets stored in a variable. Another upside is that we can type-hint the variable with the type of the node. So, we are making it even safer than the previous way of referencing the node.</p>
			<p>You’ll also notice that I use the <code>@onready</code> annotation. We call commands that start with an <code>@</code> annotation, like the one shown previously. This annotation executes that line of code when the node is ready and has entered the scene tree. This is right before the <code>_ready()</code> function of that node is called. In Godot, the <code>_ready()</code> function of each node gets called after each of its children are ready, meaning that their <code>_ready()</code> functions get called before the parent node’s <code>_ready()</code> function. We need to wait for this moment to get any nodes in the tree because otherwise, there is a possibility for them not to exist yet!</p>
			<p class="callout-heading">Annotations</p>
			<p class="callout">There are more annotations. We’ll return to them when they are applicable. But it’s already good to know that all of these annotations affect how external tools will treat the script and don’t change any logic within the script itself.</p>
			<p>I advise that you always cache variables as described here because it will keep your code clea<a id="_idTextAnchor461"/>n and fast.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor462"/>Trying out the player script</h2>
			<p>To try out what we have created so far, we can run a quick test by adding the <code>_ready()</code> function to the <a id="_idIndexMarker364"/>pl<a id="_idTextAnchor463"/>ayer script:</p>
			<pre class="source-code">
fu<a id="_idTextAnchor464"/>nc _ready():
   add_health_points(-2)</pre>			<p>Now, when you run the scene, you should see that the health label says <strong class="bold">8/10</strong>, like so:</p>
			<div><div><img alt="Figure 6.20 – The player’s health label has been updated to 8/10" src="img/B19358_06_20.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.20 – The player’s health label has been updated to 8/10</p>
			<p>After testing the script, remove the preceding lines again so that they don’t interfere with the rest of our coding.</p>
			<p>In this section, we learned how to reference nodes from the scene tree within our code and how to update the values of these nodes. We also set up a basic script for tracking the health of our player. In the following section, we’ll learn about exporting<a id="_idTextAnchor465"/> variables.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor466"/>Exporting variables to the editor</h1>
			<p>We have always defined variables<a id="_idIndexMarker365"/> within code and every time we wanted to change them, we had to change the code too. But in Godot, it is straightforward to expose variables to the editor so that we can change them without even opening the code editor. This is extremely useful when you want to test things out and tweak variables on the fly. An exported variable pops up in the <strong class="bold">Inspector</strong> view of that node, just like the transformation and text properties we saw in the <em class="italic">Manipulating nodes in the </em><em class="italic">editor</em> section.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">An exported variable is also useful for people who don’t know how to code, such as level designers, but still want to change the behavior of specific nodes.</p>
			<p>To export a variable to the<a id="_idIndexMarker366"/> editor, we can use the <code>@export</code> annotation. Let’s change the line where we define the <code>health</code> variable, like so:</p>
			<pre class="source-code">
<strong class="bold">@export</strong> var health: int = 10</pre>			<p>Make sure you save the script. Go to the 2D editor using the button at the top of the editor.</p>
			<div><div><img alt="Figure 6.21 – Click 2D to go back to the 2D editor" src="img/B19358_06_21.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.21 – Click 2D to go back to the 2D editor</p>
			<p>Click on our <code>Player</code> node, and see the <code>health</code> variable in the <strong class="bold">Inspector</strong> view. This is our exported variable. Changing it will change the variable’s value at the start of the game, not directly in the script itself:</p>
			<div><div><img alt="Figure 6.22 – The health variable as an exported variable in the Inspector view of the Player node" src="img/B19358_06_22.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.22 – The health variable as an exported variable in the Inspector view of the Player node</p>
			<p>Now, when you change the player’s health value through the <code>health</code> label in the <code>_ready()</code> function<a id="_idTextAnchor467"/>, like so:</p>
			<pre class="source-code">
fun<a id="_idTextAnchor468"/>c _ready():
   update_health_label()</pre>			<p>This will ensure that the health label is updated from the moment the <code>Player</code> node enters the scene tree.</p>
			<p class="callout-heading">More information</p>
			<p class="callout">If you want to learn more about export variables, you can check out the official documentation: <a href="https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_exports.html">https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_exports.html</a>.</p>
			<p>Now, we start the game<a id="_idIndexMarker367"/> with the correct amount of health displayed on the health label. But there is a better way of updating this health label: using setters <a id="_idTextAnchor469"/>and getters.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor470"/>Setters and getters</h2>
			<p>When you change the player’s health value through the <code>_ready()</code> funct<a id="_idTextAnchor471"/>ion, like so:</p>
			<pre class="source-code">
f<a id="_idTextAnchor472"/>unc _ready():
   print(health)</pre>			<p>That is because the <code>update_health_label()</code> function is not being called when we change the value!</p>
			<p>Luckily, we can fix this. In programming, <strong class="bold">getter</strong> and <strong class="bold">setter</strong> functions exist. These functions are called when you get or <a id="_idIndexMarker369"/>set the value of a variable. With these getter or setter functions, we <a id="_idIndexMarker370"/>can execute all the logic needed to handle a new value. We can define a getter and setter for our health va<a id="_idTextAnchor473"/>riable like so:</p>
			<pre class="source-code">
@export var he<a id="_idTextAnchor474"/>alth: i<a id="_idTextAnchor475"/>nt = 10<strong class="bold">:</strong>
   <strong class="bold">get:</strong>
    <a id="_idTextAnchor476"/>  return health
   <a id="_idTextAnchor477"/><strong class="bold">set(new_value):</strong>
      health = clamp(new_value,<a id="_idTextAnchor478"/> 0, MAX_HEALTH)
      update_health_label()</pre>			<p>So, the getter is defined by <code>get:</code>, followed by the code block that defines the getter logic, and the setter by <code>set(new_value):</code>, followed by its code block. <code>new_value</code> is the new value that is assigned to the variable. Within the setter, we get the opportunity to process this value if needed or set other processes in motion. In our case, we don’t want to process the new value, but we do want to update the health label.</p>
			<p>The getter does nothing special – it just returns the health value. On the other hand, the setter clamps the new value so that it is<a id="_idIndexMarker371"/> valid and then updates the health label.</p>
			<p>When we get or set the <code>health</code> value, the interpreter will execute these functions first. He<a id="_idTextAnchor479"/>re’s an example:</p>
			<pre class="source-code">
print(health) # Ex<a id="_idTextAnchor480"/>ecute the getter
health = 100 # Execute the setter</pre>			<p>This also simplifies the <code>add_health_points()</code> function because we no longer have to clamp the new health value as this already gets done in the setter. So, let’s update the <code>add_health_points()</code> function t<a id="_idTextAnchor481"/>o the following:</p>
			<pre class="source-code">
func add_health_points(d<a id="_idTextAnchor482"/>ifference: int):
   health += difference</pre>			<p>But what is this? The project errors when we run it now!</p>
			<div><div><img alt="Figure 6.23 – An error showing that the health label is non-existing" src="img/B19358_06_23.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.23 – An error showing that the health label is non-existing</p>
			<p>The setter function gets executed before the <code>_health_label</code> reference is created. So, we must make sure<a id="_idIndexMarker372"/> that the <code>_health_label</code> is filled in before we update its text. If it isn’t, we can just return fr<a id="_idTextAnchor483"/>om the function:</p>
			<pre class="source-code">
func update<a id="_idTextAnchor484"/>_health_label():
   <strong class="bold">if not is_instance_valid<a id="_idTextAnchor485"/>(_health_labe<a id="_idTextAnchor486"/>l<a id="_idTextAnchor487"/>):</strong>
      <strong class="bold">return</strong>
   _health_label.text = str(health) + "/" + str(MAX_HEALTH)</pre>			<p>The <code>is_instance_valid()</code> function checks if the reference to a node is valid. It returns <code>true</code> if it is and <code>false</code> otherwise.</p>
			<p class="callout-heading">Checking if a node reference exists</p>
			<p class="callout">Your first instinct might be to check if the reference to the node is not <code>null</code> by running <code>_health_label != null</code>. However, this does not guarantee that the node is available. When the node is deleted, for example, this check for <code>null</code> will still return <code>true</code> because the reference still exists within the variable. <code>is_instance_valid(_health_label)</code> will check more than just whether the variable is <code>null</code> – it will also make sure that the node still exists and is in use within the scene tree.</p>
			<p>At this point, the code<a id="_idIndexMarker373"/> for the player shoul<a id="_idTextAnchor488"/>d look like thi<a id="_idTextAnchor489"/>s<a id="_idTextAnchor490"/>:</p>
			<pre class="source-code">
extends Node2D
const MAX<a id="_idTextAnchor491"/>_<a id="_idTextAnchor492"/>HEALTH: int = 10
@onready var _health_label: Lab<a id="_idTextAnchor493"/>e<a id="_idTextAnchor494"/>l = $HealthLabel
@export var <a id="_idTextAnchor495"/>health: int = 10:
   get:
      return health
   set(new_value):
      health = clamp(new_value, 0, MAX_HEALTH)
      upda<a id="_idTextAnchor496"/>t<a id="_idTextAnchor497"/>e_health_label()
func _ready():
   upda<a id="_idTextAnchor498"/>t<a id="_idTextAnchor499"/>e_health_label()
func update_health_label():
   if not is_instance_valid(_health_label):
      return
   _health_label.text = str(health) + "/" <a id="_idTextAnchor500"/>+<a id="_idTextAnchor501"/> str(MAX_HEALTH)
func add_health_points(difference: int):
   health += difference</pre>			<p>Setters and getters help us encapsulate behavior related to updating variables, as we saw in <a href="B19358_05.xhtml#_idTextAnchor365"><em class="italic">Chapter 5</em></a>. It abstracts the logic behind what needs to happen when updating this variable so that the user of the class doesn’t have to worry about it.</p>
			<p>With this code set up, the<a id="_idIndexMarker374"/> health of our player can easily be updated using the regular or special assignment operators and the health label will u<a id="_idTextAnchor502"/>pdate accordingly.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor503"/>Changing values while the game is running</h2>
			<p>Another cool thing<a id="_idIndexMarker375"/> about these exported variables, now that we have a setter and a getter defined for them, is that we can change them while the game runs! So, if you run the game and change the <code>health</code> parameter in the <strong class="bold">Inspector</strong> view while it is running, you will see that change reflected in the health label instantaneously.</p>
			<p>This (mostly) works with all built-in parameters too! If you keep the game open and change the player’s <strong class="bold">Transformation</strong> parameters, for example, you’ll see them c<a id="_idTextAnchor504"/>hange in real time.</p>
			<p>This will be useful later on so that we don’t always have to re-launch the game when working on it.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor505"/>Different types of exported variables</h2>
			<p>When exporting a variable that we type hinted, Godot will choose the right input field type for that type. It will have a <a id="_idIndexMarker376"/>numerical input field with up and down arrows for integers, while it will use a normal text input for strings, like so:</p>
			<pre class="source-code">
@export var health: int = 10
@export var damage: float = 0.0
@export var player_name: String = "Erika"</pre>			<p>These three lines will each export a variable to the editor, but each with a different data type: integer, floating-point number, and string, respectively. The result is that we get a different kind of input field for each of the variables:</p>
			<div><div><img alt="Figure 6.24 – Different variable types that get exported" src="img/B19358_06_24.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.24 – Different variable types that get exported</p>
			<p>There are also other export annotations to be even more specific. One of those is the <code>@export_range</code> annotation, which specifies a number range the value should be in, like so:</p>
			<pre class="source-code">
@export_range(0, 10) health: int = 10</pre>			<p>In the preceding code excerpt, we <a id="_idIndexMarker377"/>export the <code>health</code> variable and specify that it should be a number between 0 and 10, including the outer values of 0 and 20. When you try out this ranged export, you’ll see that you cannot input values that fall outside of this range.</p>
			<p>To make it more dynamic, we can use the <code>MAX_HEALTH</code> variable we defined earlier within the player’s script:</p>
			<pre class="source-code">
@export_range(0, MAX_HEALTH) health: int = 10</pre>			<p>Exporting variables is a very important technique to keep in our toolkit for tweaking variables and values when testing out the game. Now, let’s direct our attention to the arena and world the player will b<a id="_idTextAnchor506"/>e walking around in.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor507"/>Creating a little world</h1>
			<p>Now that we have a little player character, let’s create<a id="_idIndexMarker378"/> a world for them to inhabit! In this section, we’ll flesh out the arena in which the player has to battle challenging foes.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor508"/>Changing the background color</h2>
			<p>Let’s start simple by <a id="_idIndexMarker379"/>changing the background color for our arena. We can easily do this from the project settings:</p>
			<ol>
				<li>Navigate to <strong class="bold">Rendering</strong> | <strong class="bold">Environment</strong> in the project settings:</li>
			</ol>
			<div><div><img alt="Figure 6.25 – Finding Default Clear Color under Rendering &gt; Environment in the project settings" src="img/B19358_06_25.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.25 – Finding Default Clear Color under Rendering &gt; Environment in the project settings</p>
			<ol>
				<li value="2">Set the <code>#e0bf7b</code> because it looks like sand or dried-up mud:</li>
			</ol>
			<div><div><img alt="Figure 6.26 – Picking a color using the color selection tool" src="img/B19358_06_26.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.26 – Picking a color using the color selection tool</p>
			<p>With this nice color in <a id="_idIndexMarker380"/>place, let’s add some features, such as boulders and<a id="_idTextAnchor509"/><a id="_idTextAnchor510"/> walls, to our arena.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor511"/>Adding Polygon2D boulders</h2>
			<p>Now that we have a ground for the <a id="_idIndexMarker381"/>player character to stand on, let’s add some boulders that will serve as obstacles in the arena. To do this, we will be using the <code>Polygon2D</code> node. This node can draw any polygon shape on the screen in any color we want:</p>
			<ol>
				<li>Add a <code>Arena</code> to the root node of our <code>Main</code> scene.</li>
				<li>Now, drag the <code>Arena</code> node we just created above the <code>Player</code> node. This will ensure everything within the <code>Arena</code> node will be drawn beneath the <code>Player</code> node. See the <em class="italic">Node drawing order</em> section to learn more about this.</li>
				<li>We will put all our arena elements, such as boulders and walls, into this node. This way, we’ll keep<a id="_idIndexMarker382"/> the tree structure nice and tidy.</li>
				<li>Now, add a <code>Polygon2D</code> node under the <code>Arena</code> node and call it <code>Boulder</code>:</li>
			</ol>
			<div><div><img alt="Figure 6.27 – The scene tree with the Arena node and a Boulder node" src="img/B19358_06_27.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.27 – The scene tree with the Arena node and a Boulder node</p>
			<ol>
				<li value="5">You can add points to the polygon by left-clicking anywhere on the screen while the <code>Boulder</code> node is selected. Right-clicking will remove a point. You can also drag earlier placed points around. Place some points and close the shape by clicking on the first point you put down:</li>
			</ol>
			<div><div><img alt="Figure 6.28 – Drawing a boulder using a Polygon2D node" src="img/B19358_06_28.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.28 – Drawing a boulder using a Polygon2D node</p>
			<ol>
				<li value="6">Set the <code>Boulder</code> node’s color property to something that resembles a stone. I chose <code>#504f51</code>.</li>
			</ol>
			<p>These boulders might look <a id="_idIndexMarker383"/>simple, but they will serve our purpose.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor512"/>Node drawing order</h2>
			<p>So, why did we drag the <code>Arena</code> node above the <code>Player</code> node? By default, the nodes get drawn in the order they’re in within<a id="_idIndexMarker384"/> the tree. The nodes closest to their parents get drawn first and the ones further away from the parent node within the tree structure are drawn on top of the ones below.</p>
			<p>There are ways to circumvent this, but that’s out of the scope of this book. So, for now, we must structure our node tree correctly:</p>
			<div><div><img alt="Figure 6.29 – Nodes get drawn in the order they are in within the scene tree" src="img/B19358_06_29.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.29 – Nodes get drawn in the order they are in within the scene tree</p>
			<p>A well-structured tree will draw all nodes in the exact orde<a id="_idTextAnchor513"/>r we want them to be.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor514"/>Creating an outer wall</h2>
			<p>For the outer wall of the <a id="_idIndexMarker385"/>arena, we’ll use a <code>Polygon2D</code> node again, but in a different way this time:</p>
			<ol>
				<li>Add a <code>Polygon2D</code> node under the <code>Arena</code> node and call it <code>OuterWall</code>.</li>
				<li>Draw a rough rectangle that will be the inside of the arena. It’s okay if this rectangle is not perfect. This will make the arena look extra medieval:</li>
			</ol>
			<div><div><img alt="Figure 6.30 – Drawing an arena outer wall using a Polygon2D node" src="img/B19358_06_30.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.30 – Drawing an arena outer wall using a Polygon2D node</p>
			<ol>
				<li value="3">Now, with <code>OuterWall</code> selected, find<a id="_idIndexMarker386"/> and enable the <strong class="bold">Invert</strong> parameter in the <strong class="bold">Inspector</strong> view. This option inverts the shape and makes it look like the outer walls of the arena:</li>
			</ol>
			<div><div><img alt="Figure 6.31 – Inverting the shape of a Polygon2D node" src="img/B19358_06_31.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.31 – Inverting the shape of a Polygon2D node</p>
			<ol>
				<li value="4">Set the <code>1000px</code>, so that the walls expand very far.</li>
				<li>Give the wall a fitting <a id="_idIndexMarker387"/>color. I chose <code>#2d2c2e</code>, which is a little darker than the boulders, so that the player sees the difference:</li>
			</ol>
			<div><div><img alt="Figure 6.32 – The resulting arena" src="img/B19358_06_32.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.32 – The resulting arena</p>
			<p>Inverting a polygon makes it very easy to create the internals of an arena or room. The natural next step is to let our imagination loose and make a<a id="_idTextAnchor515"/> visually nice arena.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor516"/>Getting creative</h2>
			<p>With these simple tools, get creative and create some interesting terrain to serve as an arena.</p>
			<p>For instance, you can <a id="_idIndexMarker388"/>add some more boulders to your arena. You can do this by creating an entirely new <code>Polygon2D</code> node or by duplicating your earlier boulder and altering them a bit by dragging points around and using the <strong class="bold">Transform</strong> tools we learned about.</p>
			<p>You can also add more walls and change the outer boundaries of the arena some more.</p>
			<p>I came up with this arena:</p>
			<div><div><img alt="Figure 6.33 – My arena after spending some more time refining it" src="img/B19358_06_33.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.33 – My arena after spending some more time refining it</p>
			<p>Now that we can create <a id="_idIndexMarker389"/>our little worlds and arenas using colored rectangles and polygons, we have everything to create the basic visual structure of our game. Next, we’ll do some extra exercises and summarize this chapter.</p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor517"/>Additional exercises – Sharpening the axe</h1>
			<ol>
				<li>Start by making more boulders and walls based on what we learned in the previous section so that you can populate your arena.</li>
				<li>Based on what you learned about the <code>health</code> value of the player, add an exported variable that tracks the number of coins the player has, called <code>number_of_coins</code>, to the player script.</li>
				<li>Add a setter and getter for the <code>number_of_coins</code> variable.</li>
				<li>Lastly, make a label that shows the coins above the player’s head. Make sure that everything gets handled and updated correctly so that we can update the variable from the editor and the code while the label always stays up to date <a id="_idTextAnchor518"/>when running the game.</li>
			</ol>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor519"/>Summary</h1>
			<p>In this chapter, we created our first real scene. We saw how different nodes do different things for us and we extended <strong class="bold">Node2D</strong> with a script that will manage the player’s health. We also created the area in which all the action will take place.</p>
			<p>In the next chapter, we’ll make it possible for the player to move around and we’ll also refresh our vector math. Don’t worry – it won’t be painful, but a bit o<a id="_idTextAnchor520"/>f math will be useful.</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor521"/>Quiz time</h1>
			<ul>
				<li>Why did we start by making a Game Design Document (GDD) instead of jumping right into creating the game?</li>
				<li>How do you reference nodes within a script?</li>
				<li>What keyword can we use to make a variable, such as the amount of health, available <a id="_idTextAnchor522"/>in the <strong class="bold">Inspector</strong> view?</li>
				<li>What are setter and getter functions used for?</li>
			</ul>
		</div>
	</body></html>