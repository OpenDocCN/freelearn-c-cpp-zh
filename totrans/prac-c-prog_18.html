<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Applying Security in Coding</h1>
                </header>
            
            <article>
                
<p>While coding, sometimes you may use functions that don't check or constrain the data entered by the user. The user either may enter incorrect data or content that might be larger than the capacity of the receiving variable. In such a situation, a buffer overflow or segmentation fault may occur. Consequently, the program will give an erroneous output.</p>
<p>In this chapter, we will use the following recipes to see how we can error-proof the entering of data in a program:</p>
<ul>
<li>Avoiding buffer overflow while reading strings from the keyboard</li>
<li>Writing secure code while copying strings</li>
<li>Avoiding errors while string formatting</li>
<li>Avoid vulnerabilities while accessing files in C</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Buffer overflow</h1>
                </header>
            
            <article>
                
<p>The most common vulnerability in C programming is buffer overflows. The buffer, as the name suggests, represents a temporary area of memory storage in the RAM that a program uses to run itself. Usually, all the variables used in a program are assigned temporary buffer storage for keeping the values assigned to them. Some functions don't limit the data within the buffer boundaries while assigning larger values (larger than the assigned buffer) to the variables, leading to overflowing of the buffer. The overflowing data corrupts or overwrites data of other buffers.</p>
<p>These buffer overflows might be used by hackers or malicious users to damage files or data or to extract sensitive information. That is, an attacker might enter such an input that leads to buffer overflows.</p>
<p class="mce-root"/>
<div class="packt_infobox">While assigning values to an array, there are no bounds checks and the code might work, whether the memory being accessed belongs to your program or not. In most cases, it leads to a segmentation fault, overwriting data in another memory region.</div>
<p><span>We will be using some terms and functions repeatedly in this program. Let's do a quick overview of them.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">gets()</h1>
                </header>
            
            <article>
                
<p><span>The <kbd>gets()</kbd> function r</span>eads characters from the standard input device and assigns them to the specified string. Reading of characters stops when the newline character is reached. This function does not check for buffer length and always results in a vulnerability. Here is its syntax:</p>
<pre><strong>char *gets ( char *str);</strong></pre>
<p>Here, <kbd>str</kbd> represents the pointer to the string (array of characters) to which the read characters are assigned.</p>
<p>On successful execution, the function returns <kbd>str</kbd> and <kbd>NULL</kbd> if any error occurs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">fgets()</h1>
                </header>
            
            <article>
                
<p>The <kbd>fgets()</kbd> function is used for reading a string from the specified source, where the source can be any file, keyboard, or another input device. <span>Here is its syntax</span>:</p>
<pre><strong>char *fgets(char *str, int numb, FILE *src);</strong></pre>
<p>The <kbd>numb</kbd> number of bytes are read from the specified source <kbd>src</kbd> and assigned to the string pointed to by <kbd>str</kbd>. The function either reads <kbd>numb-1</kbd> bytes, or until a newline (<kbd>\n</kbd>) is reached, or an end of file is encountered, whichever happens first.</p>
<p>The function also appends the null character (<kbd>\0</kbd>) to the string that is read to terminate the string. If executed successfully, the function returns a pointer to <kbd>str</kbd> and returns <kbd>NULL</kbd> if an error occurs.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">fpurge(stdin)</h1>
                </header>
            
            <article>
                
<p>The <kbd>fpurge(stdin)</kbd> function is used to flush or clear out the input buffer of the stream. Sometimes, after feeding data for some variables, the data (which might be in the form of spaces or a newline character) is left behind in the buffer and is not cleared. In such cases, this function is used. If executed successfully, the function returns zero, else it returns EOF.</p>
<p><span>Here is its syntax</span>:</p>
<pre><strong>fpurge(stdin)</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">sprintf()</h1>
                </header>
            
            <article>
                
<p>The <kbd>sprintf()</kbd> function is used for assigning formatted text to a string. <span>Here is its syntax</span>:</p>
<pre><strong>int sprintf(char *str, const char *format, ...)</strong></pre>
<p>Here, <kbd>str</kbd> is a pointer to the string where the formatted string has to be assigned, and <kbd>format</kbd> is the same as in a <kbd>printf</kbd> statement, where different formatting tags such as <kbd>%d</kbd> and <kbd>%s</kbd> can be used to format the content.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">snprintf()</h1>
                </header>
            
            <article>
                
<p>The <kbd>snprintf()</kbd> function formats the given content and assigns it to the specified string. Only the specified number of bytes will be assigned to the destination string. <span>Here is its syntax</span>:</p>
<pre><strong>int snprintf(char *str, size_t numb, const char *format, ...);</strong></pre>
<p>Here's a breakdown of what the preceding code represents:</p>
<ul>
<li><kbd>*str</kbd>: Represents the pointer that points to the string where formatted content will be assigned.</li>
<li><kbd>numb</kbd>: Represents the maximum number of bytes that can be assigned to the string.</li>
<li><kbd>format</kbd>: Like the <kbd>printf</kbd> statement, several formatting tags such as <kbd>%d</kbd> and <kbd>%s</kbd> can be used to format the content.</li>
</ul>
<p class="mce-root"/>
<div class="packt_infobox">Note: <kbd>snprintf</kbd> automatically appends a null character to the formatted string.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">strcpy()</h1>
                </header>
            
            <article>
                
<p>The <kbd>strcpy()</kbd> function is used for copying the content from one string to another. <span>Here is its syntax</span>:</p>
<pre><strong>char* strcpy(char* dest, const char* src);</strong></pre>
<p>Here, <kbd>src</kbd> represents the pointer to the source string from where the content has to be copied and <kbd>dest</kbd> represents the pointer to the destination string to which the content has to be copied.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">strncpy( )</h1>
                </header>
            
            <article>
                
<p>The <kbd>strncpy()</kbd> function is used for copying the specified number of bytes from one string into another. <span>Here is its syntax</span>:</p>
<pre><strong>char * strncpy ( char * dest, const char *src, size_t numb);</strong></pre>
<p>Here's a breakdown of what the preceding code represents:</p>
<ul>
<li><kbd>dest</kbd>: Represents the pointer to the destination string to where the bytes have to be copied</li>
<li><kbd>src</kbd>: Represents the pointer to the source string from where the bytes have to be copied</li>
<li><kbd>numb</kbd>: Represents the number of bytes to be copied from source to the destination string</li>
</ul>
<p>If the value of the <kbd>numb</kbd> parameter is larger than the length of the source string, the destination string will be padded with null bytes. If the length of the destination string is smaller than the <kbd>numb</kbd> parameter, then the string will be truncated to be equal to the length of the destination string.</p>
<p>Let's now begin our journey for secure coding with the first recipe.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding how a buffer overflow occurs</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will learn to get input from the user and will see the situations that lead to a buffer overflow and result in ambiguous output. We will also learn the procedure to avoid a buffer overflow.</p>
<p>Basically, we will make a structure comprising two members and in one of the members, we will deliberately enter text that is larger than its capacity, as a result of which a buffer overflow will occur. This will lead to the overwriting of the content of another member of the structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Here are the steps to make a program that will lead to a buffer overflow:</p>
<ol start="1">
<li>Define a structure consisting of two members, <kbd>name</kbd> and <kbd>orderid</kbd>.</li>
<li>Define two variables of the structure type defined in <em>step 1</em>. In one of the structure variables, we will deliberately generate a buffer overflow by entering a large amount of data.</li>
<li>Prompt the user to enter a value for the <kbd>orderid</kbd> <span>member </span>for the first structure.</li>
<li>Invoke the <kbd>fpurge</kbd> function to empty out the input stream buffer before invoking the <kbd>gets</kbd> function.</li>
<li>Invoke the <kbd>gets</kbd> function to enter data for the <kbd>name</kbd> member for the first structure. Enter text that is larger than the length of the <kbd>name</kbd> member.</li>
<li>Repeat <em>steps 3</em> to <em>5</em> to enter data for the <kbd>orderid</kbd> and <kbd>name</kbd> members for the second structure. This time, enter data within the capacity of the <kbd>name</kbd> member.</li>
<li>Display data assigned to the <kbd>orderid</kbd> and <kbd>name</kbd> members of the first structure. Buffer overflow will occur in the case of the first structure and you will get an ambiguous output while displaying the <kbd>orderid</kbd> value.</li>
<li>Display data assigned to the <kbd>orderid</kbd> and <kbd>name</kbd> member of the second structure. No buffer overflow takes place in this structure and you get exactly the same data that was entered for both the members.</li>
</ol>
<p class="mce-root"/>
<p>The following program will take the name and order number values for two structures. In one member of the structure, we will enter data that is larger than its capacity to generate a buffer overflow:</p>
<pre>//<strong>getsproblem.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/><br/>struct users {<br/>  char name[10];<br/>  int orderid;<br/>};<br/>int main(void) {<br/>  struct users user1, user2;<br/>  printf("Enter order number ");<br/>  scanf("%d", &amp; user1.orderid);<br/>  fpurge(stdin);<br/>  printf("Enter first user name ");<br/>  gets(user1.name);<br/>  printf("Enter order number ");<br/>  scanf("%d", &amp; user2.orderid);<br/>  fpurge(stdin);<br/>  printf("Enter second user name ");<br/>  gets(user2.name);<br/>  printf("Information of first user - Name %s, Order number %d\n", <br/>   user1.name, user1.orderid);<br/>  printf("Information of second user - Name %s, Order number %d\n", <br/>   user2.name, user2.orderid);<br/>}</pre>
<p>Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The program will ask for two pairs of names and order numbers. In the first pair, we will deliberately generate a buffer overflow by entering text that is longer than the variable size, whereas for the second pair, we will enter <span>the data </span>within the specified range. Consequently, the information of the first user (pair) will be displayed incorrectly, that is, the data will not appear exactly the same as it was entered, whereas that of the second user will appear correctly.</p>
<p>So, we will define a structure called <kbd>users</kbd> with two fields or members called <kbd>name</kbd> and <kbd>orderid</kbd>, where <kbd>name</kbd> is defined as a string of size 10 bytes and <kbd>orderid</kbd> is defined as an int variable of 2 bytes. Then, we will define two variables <kbd>user1</kbd> and <kbd>user2</kbd> of the <kbd>users</kbd> structure type; that means both the <kbd>user1</kbd> and <kbd>user2</kbd> <span>variables </span>will get a <kbd>name</kbd> and <kbd>orderid</kbd> <span>member </span>each.</p>
<p>You will be prompted to enter the username and order number twice. The first pair of names and the order numbers entered will be assigned to <kbd>user1</kbd> and the second to <kbd>user2</kbd>. The entered information of the two users is then displayed on the screen.</p>
<p>Let's use GCC to compile the <kbd>getsproblem.c</kbd> program. If you get no errors or warnings, it means the <kbd>getsproblem.c</kbd> <span>program </span>has compiled into an executable file: <kbd>getsproblem.exe</kbd>. Let's run this file:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/aa9293f3-cf51-44ab-87b7-7c2384259cb4.png" style="width:45.58em;height:11.92em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 18.1</div>
<p>We can see in the preceding output that because of the buffer overflow made by the <kbd>name</kbd> member in the first structure, the value of the <kbd>orderid</kbd> member, which was <kbd>101</kbd>, is overwritten. Consequently, we get a garbage value for the <kbd>orderid</kbd> of the first structure. The output of the second structure is correct because the value entered for its members is within their capacity.</p>
<p>To avoid overflow while entering data, we simply replace the <kbd>gets</kbd> function with the <kbd>fgets</kbd> function. With the <kbd>fgets</kbd> function, we can specify the maximum number of characters that can be allowed in the specified string. The extra text will be truncated and will not be assigned to the specified string.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning how to avoid a buffer overflow </h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we defined two structure variables because we wanted to show that if data entered is larger in size than the member field allows, it will result in ambiguous output; and if data is entered within the capacity of the receiving variables, it will generate the correct output.</p>
<p>In the following recipe, we don't need two structure variables as we will be using the <kbd>fgets</kbd> function to address our concern. This function never results in a buffer overflow. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Here are the steps for avoiding a buffer overflow using the <kbd>fgets</kbd> function:</p>
<ol>
<li>Define a structure consisting of two members, <kbd>name</kbd> and <kbd>orderid</kbd>.</li>
<li>Define a variable of the structure type defined in <em>step 1</em>.</li>
<li><span>Prompt the user to enter a value for the <kbd>orderid</kbd> member of the structure.</span></li>
<li><span>Invoke the <kbd>fpurge</kbd> function to empty out the input stream buffer before invoking the <kbd>fgets</kbd> function.</span></li>
<li><span>Invoke the <kbd>fgets</kbd> function to enter data for the <kbd>name</kbd> member of the structure. In order to constrain the size of the text to be assigned to <kbd>name</kbd> member, its length is computed by invoking the <kbd>sizeof</kbd> function and that length of string is supplied to the <kbd>fgets</kbd> function.</span></li>
<li><span>Add a null character to the string, if one is not already there, to terminate the string.</span></li>
<li><span>Display data assigned to the <kbd>orderid</kbd> and <kbd>name</kbd> members of the structure to verify that there is no buffer overflow.</span></li>
</ol>
<p>The following program defines a structure consisting of two members and explains how a buffer overflow can be avoided while entering data through the keyboard:</p>
<pre>//<strong>getssolved.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;<br/>#include &lt;stdlib.h&gt;<br/><br/>struct users {<br/>  char name[10];<br/>  int orderid;<br/>};<br/><br/>int main(void) {<br/>  struct users user1;<br/>  int n;<br/>  printf("Enter order number ");<br/>  scanf("%d", &amp; user1.orderid);<br/>  fpurge(stdin);<br/>  printf("Enter user name ");<br/>  fgets(user1.name, sizeof(user1.name), stdin);<br/>  n = strlen(user1.name) - 1;<br/>  if (user1.name[n] == '\n')<br/>    user1.name[n] = '\0';<br/>  printf("Information of the user is - Name %s, Order number %d\n", <br/>   user1.name, user1.orderid);<br/>}</pre>
<p>Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In the program, the <kbd>fgets</kbd> function takes input from the standard input device and the maximum number of characters that will be read from the input device will be equal to the number of bytes allowed in the <kbd>name</kbd> variable of the <kbd>user1</kbd> structure. As a result, even if the user enters a larger string, only the specified number of bytes from the input will be picked up; that is, only the first 10 characters in the input will be picked up and assigned to the <kbd>name</kbd> member of the <kbd>user1</kbd> structure.</p>
<p>The <kbd>fgets</kbd> function appends the null character (<kbd>\0</kbd>) to the string, provided the number of characters entered is one less than the maximum length specified in the function. But for the string that is larger than the specified length, we need to insert the null character at the end of the string. To do so, we need to check if the newline character is there as the last character of the string. If yes, then we replace the newline character in the string with the null character to terminate the string.</p>
<p>Let's use GCC to compile the <kbd>getssolved.c</kbd> program. <span>If you get no errors or warnings, it means the <kbd>getssolved.c</kbd> program has compiled into an executable file: <kbd>getssolved.exe</kbd>. Let's run this file:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e4374252-eb37-4725-a33a-1db7f9bfb903.png" style="width:37.83em;height:7.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 18.2</div>
<p>We can see in the <span>preceding </span>output that the larger text assigned to the <kbd>name</kbd> member of the structure is truncated as per the member's size, hence no buffer overflow occurs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding how a vulnerability occurs while copying strings</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will see the vulnerability that might occur while copying a string. We will also see how to avoid that vulnerability. We will first define a structure consisting of two members. In one of the members, we will be copying a text that is larger than its capacity, which will result in overwriting the content of another member.</p>
<p>In the next recipe, we will learn how to avoid this problem.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Here are the steps to </span>understand how a vulnerability occurs while copying a string:</p>
<ol>
<li>Define a structure consisting of two members, <kbd>name</kbd> and <kbd>orderid</kbd>.</li>
<li>Define a variable of the structure type defined in <em>step 1</em>.</li>
<li>Assign any integer value to the <kbd>orderid</kbd> <span>member </span>of the structure.</li>
</ol>
<ol start="4">
<li>Invoke the <kbd>strcpy</kbd> function to assign text to the <kbd>name</kbd> member of the structure. In order to generate a buffer overflow, assign a larger text to it. </li>
<li>Display data assigned to the <kbd>orderid</kbd> and <kbd>name</kbd> members of the structure to confirm if the ambiguous output is generated, which verifies that a buffer overflow has occurred.</li>
</ol>
<p>The program that shows a vulnerability when copying a string is as follows:</p>
<pre>//<strong>strcpyproblem.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;<br/><br/>struct users {<br/>  char name[10];<br/>  int orderid;<br/>};<br/><br/>int main(void) {<br/>  struct users user1;<br/>  char userid[] = "administrator";<br/>  user1.orderid = 101;<br/>  strcpy(user1.name, userid);<br/>  printf("Information of the user - Name %s, Order number %d\n", <br/>   user1.name, user1.orderid);<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>To enter the name and order number of a customer, define a structure called users with two members, <kbd>name</kbd> and <kbd>orderid</kbd>. The <kbd>name</kbd> member is a character array or string of 10 bytes in <span>length, </span>and the <kbd>orderid</kbd> member is a variable of the <kbd>int</kbd> data type consisting of 2 bytes.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>A variable, <kbd>user1</kbd>, is defined as the <kbd>users</kbd> structure type; hence, the <kbd>user1</kbd> structure will get two members, <kbd>name</kbd> and <kbd>orderid</kbd>. An integer value 101 is assigned to the <kbd>orderid</kbd> member of <kbd>user1</kbd> structure. Also, a string, <kbd>administrator</kbd>, is assigned to the <kbd>name</kbd> member of <kbd>user1</kbd>. Because the string administrator is larger than the size of the <kbd>name</kbd> member, a buffer overflow will occur, overwriting the memory of the next memory location, that is, of the <kbd>orderid</kbd> <span>member. </span>Consequently, while displaying the information of the user, though the data in the <kbd>name</kbd> member may appear correctly, the content of <kbd>orderid</kbd> member will appear incorrectly, as its content is overwritten.</p>
<p>Let's use GCC to compile the <kbd>strcpyproblem.c</kbd> program. If you get no errors or warnings, it means the <kbd>strcpyproblem.c</kbd> <span>program </span>has compiled into an executable file: <kbd>strcpyproblem.exe</kbd>. Let's run this file:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9720450c-8077-47f1-b468-e088eac27fa0.png" style="width:36.42em;height:5.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 18.3</span></div>
<p>In the <span>preceding </span>output, you can see that because the <kbd>name</kbd> member is assigned a string that is larger than its size, this results in it overwriting the content of another member, <kbd>orderid</kbd>. The content of the <kbd>name</kbd> member appears the same as entered by the user, whereas that of <kbd>orderid</kbd> is displayed incorrectly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning how to write secure code while copying strings</h1>
                </header>
            
            <article>
                
<p>To avoid the buffer overflow that occurs when using the <kbd>strcpy</kbd> function, simply replace the <kbd>strcpy</kbd> function with the <kbd>strncpy</kbd> function. <kbd>strncpy</kbd> will copy only the specified number of bytes into the destination string, hence buffer overflows don't occur in this function. Let's see how it is done.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Here are the steps to make secure code while copying a string:</p>
<ol>
<li>Define a structure consisting of two members, <kbd>name</kbd> and <kbd>orderid</kbd>.</li>
<li>Define a variable of the structure type defined in <em>step 1</em>.</li>
<li><span>Assign any integer value to the <kbd>orderid</kbd> member of the structure.</span></li>
<li>Determine the length of the <kbd>name</kbd> member of the structure to find the maximum number of characters that it can accommodate.</li>
<li>Invoke the <kbd>strncpy</kbd> function for copying a text to the <kbd>name</kbd> member of the structure. Pass the length of the <kbd>name</kbd> member, too, to the <kbd>strncpy</kbd> function to truncate the text if it is larger than the capacity of the <kbd>name</kbd> member.</li>
<li>Add a null character to the string, if it is not there already, to terminate it.</li>
<li>Display data assigned to the <kbd>orderid</kbd> and <kbd>name</kbd> members of the structure to verify that a buffer overflow does not occur and the same data is displayed<span> as was entered</span>.</li>
</ol>
<p>The program that is secure enough for copying strings is as follows:</p>
<pre>//<strong>strcpysolved.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;<br/><br/>struct users {<br/>  char name[10];<br/>  int orderid;<br/>};<br/><br/>int main(void) {<br/>  int strsize;<br/>  struct users user1;<br/>  char userid[] = "administrator";<br/>  user1.orderid = 101;<br/>  strsize = sizeof(user1.name);<br/>  strncpy(user1.name, userid, strsize);<br/>  if (user1.name[strsize - 1] != '\0')<br/>    user1.name[strsize - 1] = '\0';<br/>  printf("Information of the user - Name %s, Order number %d\n", <br/>   user1.name, user1.orderid);<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, everything is the same as the previous recipe. The point of difference is that we invoke the <kbd>strncpy</kbd> function. When this function is invoked, only the <kbd>strsize</kbd> number of bytes from the administrator text is assigned to the <kbd>name</kbd> member of the <kbd>user1</kbd> structure. Because <kbd>strsize</kbd> contains the maximum length of the <kbd>name</kbd> member, no buffer overflow will occur in this case.</p>
<p>Finally, we check if the null character, <kbd>\0</kbd>, exists as the last character in the <kbd>name</kbd> member. If not, then the null character is added at its end to terminate the string. On displaying the information of the user, we see that because the length of the <kbd>name</kbd> member is 10, only the first 9 characters from the text <kbd>administrator</kbd> are assigned to the <kbd>name</kbd> member, followed by a null character. As a result of this, the value of the <kbd>orderid</kbd> member will also appear correctly, exactly the same as was entered.</p>
<p>Let's use GCC to compile the <kbd>strcpysolved.c</kbd> program. If you get no errors or warnings, it means the <kbd>strcpysolved.c</kbd> <span>program </span>has compiled into an executable file: <kbd>strcpysolved.exe</kbd>. Let's run this file:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2b32d2d3-e0db-4caf-a6ab-119f39ed60e0.png" style="width:34.58em;height:5.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 18.4</span></div>
<p>You can see in the <span>preceding </span>output that whatever value is entered for the two members, we get exactly the same output.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the errors that occur while formatting strings</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will understand what kind of error might occur while formatting strings. We will also see how to avoid that error. We will define a structure consisting of two members, and to one member, we will be assigning a formatted string. Let's see what error we come across.</p>
<p>In the next recipe, we will see how to avoid it.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>Here are the steps to</span> make a program in which an error occurs due to string formatting:</p>
<ol>
<li>Define a structure consisting of two members, <kbd>name</kbd> and <kbd>orderid</kbd>.</li>
<li>Define a variable of the structure type defined in <em>step 1</em>.</li>
<li>Assign any integer value to the <kbd>orderid</kbd> <span>member </span>of the structure.</li>
<li>Invoke the <kbd>sprintf</kbd> function to assign formatted text to the <kbd>name</kbd> member of the structure. In order to generate a buffer overflow, assign a larger text to it.</li>
<li>Display data assigned to the <kbd>orderid</kbd> and <kbd>name</kbd> members of the structure to confirm if the ambiguous output is generated to verify whether buffer overflow has occurred.</li>
</ol>
<p>The following is the program that generates an erroneous output because of applying string formatting:</p>
<pre>//<strong>sprintfproblem.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/><br/>struct users {<br/>  char name[10];<br/>  int orderid;<br/>};<br/><br/>int main(void) {<br/>  struct users user1;<br/>  user1.orderid = 101;<br/>  sprintf(user1.name, "%s", "bintuharwani");<br/>  printf("Information of the user - Name %s, Order number <br/>   %d\n", user1.name, user1.orderid);<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We want to enter information about the customer's name and the order placed by them. So, we define a structure called <kbd>users</kbd> with two members, <kbd>name</kbd> and <kbd>orderid</kbd>, where the <kbd>name</kbd> member is defined as a character array of length 10 bytes, and the <kbd>orderid</kbd> member is defined of the int data type consisting of 2 bytes. A variable, <kbd>user1</kbd>, is defined of the <kbd>users</kbd> structure type, hence the <kbd>user1</kbd> structure will get two members, <kbd>name</kbd> and <kbd>orderid</kbd>. An integer of value <kbd>101</kbd> is assigned to the <kbd>orderid</kbd> member of the <kbd>user1</kbd> structure.</p>
<p>Using the <kbd>sprintf</kbd> function, a string, <kbd>bintuharwani</kbd>, is assigned to the <kbd>name</kbd> member of the <kbd>user1</kbd> structure. The <kbd>bintuharwani</kbd> <span>string </span>is larger than the <kbd>name</kbd> member, hence a buffer overflow will occur, overwriting the memory of the next memory location, that is, the memory of the <kbd>orderid</kbd> <span>member. So,</span> while displaying the information of the user, the name will appear correctly but you will get a different or ambiguous value for the <kbd>orderid</kbd> member.</p>
<p>Let's use GCC to compile the <kbd>sprintfproblem.c</kbd> program. If you get no errors or warnings, it means the <kbd>sprintfproblem.c</kbd> <span>program </span>has compiled into an executable file: <kbd>sprintfproblem.exe</kbd>. Let's run this file:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/18cee49a-1d7f-44c9-9e93-0c6e5f435e65.png" style="width:35.08em;height:5.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 18.5</div>
<p>In the output, you can see that the order number is displayed incorrectly; that is, instead of the assigned value, <kbd>101</kbd>, it displays the value <kbd>0</kbd>. This is because on assigning the <kbd>bintuharwani</kbd> <span>string </span>to the <kbd>name</kbd> member, the fact that the string is larger in size than the capacity of the <kbd>name</kbd> member leads to a buffer overflow that overwrites the value of the <kbd>orderid</kbd> member.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning how to avoid errors while formatting strings</h1>
                </header>
            
            <article>
                
<p><span>In this recipe, we will use the <kbd>snprintf</kbd> function. The <kbd>snprintf</kbd> function will assign the formatted text to the <kbd>name</kbd> member but will limit the size of the string assigned to it. The difference between the <kbd>sprintf</kbd> and <kbd>snprintf</kbd> functions is that <kbd>sprintf</kbd> simply assigns the complete formatted text to the destination string no matter what its capacity, whereas <kbd>snprintf</kbd> allows us to specify the maximum length of the text that can be assigned to the destination string. Therefore, a buffer overflow will not occur as only the specified size of the text is assigned to the destination string.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span> Here are the steps to</span><span> </span>make a program in which an error occurs due to string formatting:</p>
<ol>
<li>Define a structure consisting of two members, <kbd>name</kbd> and <kbd>orderid</kbd>.</li>
<li>Define a variable of the structure type defined in <em>step 1</em>.</li>
<li>Assign any integer value to the <kbd>orderid</kbd> <span>member </span>of the structure.</li>
<li>Invoke the <kbd>snprintf</kbd> function to assign formatted text to the <kbd>name</kbd> member of the structure. <span>Pass the length of the <kbd>name</kbd> member to the <kbd>snprintf</kbd> function, as well, to truncate the text if it is larger than the capacity of the <kbd>name</kbd> member.</span></li>
<li>Display data assigned to the <kbd>orderid</kbd> and <kbd>name</kbd> members of the structure to<span> verify that a buffer overflow does not occur and the same data is displayed as was entered.</span></li>
</ol>
<p>The following program shows how the error related to string <span>formatting </span>can be avoided:</p>
<pre>//<strong>sprintfsolved.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/><br/>struct users {<br/>  char name[10];<br/>  int orderid;<br/>};<br/><br/>int main(void) {<br/>  struct users user1;<br/>  user1.orderid = 101;<br/>  snprintf(user1.name, sizeof(user1.name), "%s", "bintuharwani");<br/>  printf("Information of the user - Name %s, Order number <br/>   %d\n", user1.name, user1.orderid);<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><span>To constrain the size of the content assigned to the</span> <kbd>name</kbd> <span>member of the <kbd>user1</kbd> structure, we will make use of the <kbd>snprintf</kbd> function. </span>You can see that through the <kbd>snprintf</kbd> function, only the first 10 characters from the text <kbd>bintuharwani</kbd> are assigned to the <kbd>name</kbd> <span>member.</span> Because the length of the <kbd>name</kbd> member is 10, it is capable of storing 10 characters and hence no buffer overflow occurs and the value assigned to the <kbd>orderid</kbd> member will remain intact and undisturbed. On displaying the values of the <kbd>orderid</kbd> and <kbd>name</kbd> members, both of their values will be displayed correctly.</p>
<p>Let's use GCC to compile the <kbd>sprintfsolved.c</kbd> program. <span>If you get no errors or warnings, it means the <kbd>sprintfsolved.c</kbd> program has compiled into an executable file: <kbd>sprintfsolved.exe</kbd>. Let's run this file:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a61c9e8f-fc93-4768-bd4a-38b57a818263.png" style="width:32.67em;height:5.08em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 18.6</span></div>
<p>In the <span>preceding </span>output, we can see that the extra formatted text that is assigned to the <kbd>name</kbd> member is truncated, hence the correct output of the <kbd>name</kbd> and <kbd>orderid</kbd> members is displayed on the screen.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding how vulnerabilities occur while accessing files in C</h1>
                </header>
            
            <article>
                
<p>Let's assume that you wrote a program to create a text file named <kbd>file1.txt</kbd>. In such programs, a malicious user or hacker might add some soft links to some important or sensitive file in the file that you want to create. As a result, it will lead to overwriting of the important file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will start by assuming that some important file by the name of <kbd>file2.txt</kbd> already exists on your computer and contains some sensitive information. Here are the steps that a malicious user or hacker can use in your program to create a file to overwrite <kbd>file2.txt</kbd>:</p>
<ol>
<li>A file pointer is defined.</li>
<li>The hacker might create a soft link and attach a sensitive file to the file that we want to create.</li>
<li>Open the file to which we want to write the content. But in reality, the sensitive file that is attached to our file will be opened in write-only mode.</li>
<li>Prompt the user to enter the lines of text to be written into the file.</li>
<li>Write the lines entered by the user into the file.</li>
<li>Repeat <em>steps 4</em> and <em>5</em> until the user enters <kbd>stop</kbd>.</li>
<li>Close the file pointed to by the file pointer, <kbd>fp</kbd>.</li>
</ol>
<p>Following is the program that a malicious user can use to link some important file to the file that you want to create, and hence can overwrite and destroy that important file on your system:</p>
<pre>//<strong>fileproblem.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;unistd.h&gt;<br/><br/>#define BUFFSIZE 255<br/><br/>void main(int argc, char * argv[]) {<br/>  FILE * fp;<br/>  char str[BUFFSIZE];<br/>  if (symlink("file2.txt", "file1.txt") != 0) {<br/>    perror("symlink() error");<br/>    unlink("file2.txt");<br/>    exit(1);<br/>  } else {<br/>    fp = fopen("file1.txt", "w");<br/>    if (fp == NULL) {<br/>      perror("An error occurred in creating the file\n");<br/>      exit(1);<br/>    }<br/>    printf("Enter content for the file\n");<br/>    gets(str);<br/>    while (strcmp(str, "stop") != 0) {<br/>      fputs(str, fp);<br/>      gets(str);<br/>    }<br/>  }<br/>  fclose(fp);<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>A file pointer is defined by the name <kbd>fp</kbd>. At this stage, a hacker or malicious user might invoke the <kbd>symlink</kbd> function to create a soft link named <kbd>file1.txt</kbd> to the file named <kbd>file2.txt</kbd>. In this program, <kbd>file2.txt</kbd> can be replaced by the password file or some other sensitive file that the malicious user may want to overwrite or destroy.</p>
<p>Because the program is for creating a new file, the program invokes the <kbd>fopen</kbd> function to open <kbd>file1.txt</kbd> in write-only mode and the opened file will be pointed at by <kbd>fp</kbd>, the<span> file pointer.</span> But because <kbd>file1.txt</kbd> and <kbd>file2.txt</kbd> are linked, <kbd>file2.txt</kbd> will be actually opened instead of <kbd>file1.txt</kbd>, and in write-only mode, and will be pointed at by the file pointer, <kbd>fp</kbd>. The program will terminate if the file cannot be opened in write-only mode or some other error occurs.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The user is prompted to enter lines of text for the file. The lines entered by the user are assigned to the <kbd>str</kbd> <span>string. </span>The <kbd>fputs</kbd> function is invoked to write the content assigned to the <kbd>str</kbd> <span>string </span>into the file pointed at by the <span>file pointer, <kbd>fp</kbd>.</span> Consequently, the sensitive file will be overwritten. The user can enter as many lines of text as desired and can enter <kbd>stop</kbd> when they are done. So a <kbd>while</kbd> loop is set to execute that will keep taking lines of text from the user and will keep writing them into the file until <kbd>stop</kbd> is entered. Finally, the file pointed to by the<span> </span>file pointer, <kbd>fp</kbd>,  is closed.</p>
<p>Let's use GCC to compile the <kbd>fileproblem.c</kbd> program as shown in the following screenshot. If you get no errors or warnings, it means the <kbd>fileproblem.c</kbd> <span>program </span>has compiled into an executable file: <kbd>fileproblem.exe</kbd>. Let's run this file:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cf883cc0-f3ab-4093-bd35-8832b53a9a6c.png" style="width:24.42em;height:7.33em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 18.7</span></div>
<p>The <span>preceding </span>text will not go into the desired file, <kbd>file1.txt</kbd>, but will overwrite the sensitive file, <kbd>file2.txt</kbd>, deleting its earlier content, if any. If we look at the content of the <kbd>file2.txt</kbd> <span>file,</span> we will see the content that was supposed to be written into <kbd>file1.txt</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/96d98c10-a207-4c8f-b8b2-98656963c2df.png" style="width:26.17em;height:3.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 18.8</span></div>
<p>Now, let's rewrite the program to remove the file vulnerabilities.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning how to avoid vulnerabilities while writing a file in C</h1>
                </header>
            
            <article>
                
<p><span>The special care we will take in this recipe is that we will unlink all the links (if any) to the file that we are going to create. We will also ensure that our program does not overwrite any file if it already exists. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Here are the steps to write a program to avoid vulnerabilities while creating a file in C:</p>
<ol start="1">
<li>A file pointer is defined.</li>
<li>The hacker might create a soft link and attach a sensitive file to the file that we want to create.</li>
<li>Remove the links from the file that you want to write in.</li>
<li>Open the file using the flags that check whether the file already exists or not. If the file exists, it should be overwritten.</li>
<li>Associate the file descriptor with the file stream.</li>
<li>Prompt the user to enter the lines of text to be written into the file.</li>
<li>Write the lines entered by the user into the file.</li>
<li>Repeat <em>steps 5</em> and <em>6</em> until the user enters <kbd>stop</kbd>.</li>
<li>Close the file pointed to by the file pointer, <kbd>fp</kbd>.</li>
</ol>
<p>The following is the program that removes vulnerabilities while creating a text file:</p>
<pre>//<strong>filesolved.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;unistd.h&gt;<br/><br/>#define BUFFSIZE 255<br/><br/>void main(int argc, char * argv[]) {<br/>  int ifp;<br/>  FILE * fp;<br/>  char str[BUFFSIZE];<br/>  if (symlink("file2.txt", "file1.txt") != 0) {<br/>    perror("symlink() error");<br/>    unlink("file2.txt");<br/>    exit(1);<br/>  } else {<br/>    unlink("file1.txt");<br/>    ifp = open("file1.txt", O_WRONLY | O_CREAT | O_EXCL, 0600);<br/>    if (ifp == -1) {<br/>      perror("An error occurred in creating the file\n");<br/>      exit(1);<br/>    }<br/>    fp = fdopen(ifp, "w");<br/>    if (fp == NULL) {<br/>      perror("Could not be linked to the stream\n");<br/>      exit(1);<br/>    }<br/>    printf("Enter content for the file\n");<br/>    gets(str);<br/>    while (strcmp(str, "stop") != 0) {<br/>      fputs(str, fp);<br/>      gets(str);<br/>    }<br/>  }<br/>  fclose(fp);<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You can see in the program that a file pointer is defined by the name <kbd>fp</kbd>. We are expecting that a hacker or malicious user might have created a soft link called <kbd>file1.txt</kbd> to the existing file, <kbd>file2.txt</kbd>. <kbd>file2.txt</kbd> is a sensitive file that we don't want to be overwritten or destroyed. To make the program free from any vulnerability, the <kbd>unlink()</kbd> function is invoked to remove any links to the <kbd>file1.txt</kbd>. This will avoid overwriting of any sensitive file that might be linked with <kbd>file1.txt</kbd>.</p>
<p>Also, the <kbd>open</kbd> function is invoked to open the file instead of the traditional <kbd>fopen</kbd> function. The <kbd>open</kbd> function opens the <kbd>file1.txt</kbd> file in write-only mode with the <kbd>O_CREAT</kbd> and <kbd>O_EXCL</kbd> <span>flags, </span>which will fail the <kbd>open</kbd> function if the file already exists. This will ensure that no existing sensitive file will be overwritten accidentally in case it is linked to <kbd>file1.txt</kbd>. The <kbd>open</kbd> function will return a file descriptor for the opened file that will be assigned to the <kbd>ifp</kbd> <span>variable.</span></p>
<p>To work with the file, we need a file stream. So the <kbd>fdopen</kbd> function is invoked to associate a file stream with the <kbd>ifp</kbd> <span>file descriptor </span>that is generated through the <kbd>open</kbd> function. The <kbd>fdopen</kbd> function returns a pointer to the file stream that is assigned to the file pointer, <kbd>fp</kbd>. In addition, the <kbd>w</kbd> mode is used in the <kbd>fdopen</kbd> function because although it opens the file in write mode, it will never cause truncation of the file. This makes the program much safer and avoids the accidental deletion of any file.</p>
<p>Thereafter, the program is the same as the previous program. It asks the user to enter certain lines, which are then written in  <kbd>file1.txt</kbd>. Finally, the file pointed to by the file pointer, <kbd>fp</kbd>, is closed.</p>
<p>Let's use GCC to compile the <kbd>filesolved.c</kbd> program, as shown in the <span>following</span> screenshot. <span>If you get no errors or warnings, it means the <kbd>filesolved.c</kbd> program has compiled into an executable file: <kbd>filesolved.exe</kbd>. Let's run this file:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/78fb48b4-a144-4251-bc2c-a4f0a8456e13.png" style="width:31.67em;height:6.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 18.9</div>
<p>We can verify whether the content entered while running the program has gone into <kbd>file1.txt</kbd> or not. To do so, we will open <kbd>file1.txt</kbd> to see its contents as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/93d61213-b17e-450f-86a0-e6ca54bc1c03.png" style="width:29.58em;height:2.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 18.10</div>
<p>We can see that the content entered by the user has gone into <kbd>file1.txt</kbd>.</p>
<p>The contents of <kbd>file2.txt</kbd> are intact as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fb799e9d-66c3-4c79-88a3-854900d7458a.png" style="width:36.17em;height:6.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 18.11</div>


            </article>

            
        </section>
    </body></html>