<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer020">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor014"/>1</h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor015"/>Getting Started with Linux Systems and the POSIX Standard</h1>
<p>This book is about <strong class="bold">Linux</strong> and how we use <strong class="bold">C++</strong> in <strong class="bold">Linux</strong> environments to manage critical resources. The <strong class="bold">C++</strong> language<a id="_idIndexMarker000"/> is continuously improving, as you’ll explore in the following chapters. Before we go there, we’d like to spend some time in this chapter developing a fundamental understanding of <strong class="bold">operating systems</strong> (<strong class="bold">OSs</strong>). You are going to learn more about the origins of some specific techniques, the <strong class="bold">system call interface </strong>and the <strong class="bold">Portable Operating System </strong><span class="No-Break"><strong class="bold">Interface</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">POSIX</strong></span><span class="No-Break">).</span></p>
<p>Your choice of OS matters. Although OSs were created with a single purpose, nowadays their roles differ. Much is expected of them as well. Each OS has its own strengths and weaknesses, which we are going to discuss briefly. <strong class="bold">Linux</strong> is in widespread use across multiple technological areas and has a huge community worldwide, so it is perfect for our practical purposes. In our experience, programming in Linux or other <em class="italic">Unix-based OS</em> environments is rather common. Wherever your expertise resides – from <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) devices and embedded <a id="_idIndexMarker001"/>software development to mobile devices, supercomputing, or spacecraft – there is a good chance that you will cross paths with a Linux distribution at <span class="No-Break">some point.</span></p>
<p>Use this chapter as an introduction to system programming. Even if you are already familiar with the topic, take your time to revisit the terms and details. Most of them are covered by college courses or are taken as common knowledge, but it is nonetheless important for us to explain some of the fundamentals here to make sure we will be on the same page in the chapters <span class="No-Break">to come.</span></p>
<p>In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
<ul>
<li>Getting familiar with the concept <span class="No-Break">of OSs</span></li>
<li>Getting to know the <span class="No-Break">Linux kernel</span></li>
<li>Introducing the system call interface and <span class="No-Break">system programming</span></li>
<li>Navigating through files, processes, <span class="No-Break">and threads</span></li>
<li>Running services with <strong class="source-inline">init</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">systemd</strong></span></li>
<li><strong class="bold">Portable Operating System </strong><span class="No-Break"><strong class="bold">Interface</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">POSIX</strong></span><span class="No-Break">)</span></li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor016"/>Technical requirements</h1>
<p>In order to get familiar with the programming environment, the reader must prepare <span class="No-Break">the following:</span></p>
<ul>
<li>A Linux-based system capable of compiling and executing C++20 (for example, Linux <span class="No-Break">Mint 21)</span></li>
</ul>
<h1 id="_idParaDest-19"><a id="_idTextAnchor017"/>Getting familiar with the concept of OSs</h1>
<p>So, what is an OS? You<a id="_idIndexMarker002"/> could probably provide at least one answer, but let’s discuss this briefly as it is important to understand what our computer system truly is and how we manipulate it. Although you might be familiar with most of the information provided here, we are using this chapter to align with you on the matter of OSs and their uses. Some might say that the OS was created to make the hardware work as a whole. Others will argue that it is an aggregation of programs, dedicated to managing the system resources overall. It is crucial to utilize these resources, such as CPU and memory, efficiently. There is also the concept of the OS as an abstraction and an extension of the hardware. Ultimately, we can safely say that the modern OS is a complex entity. It also has additional functions, such as the collection of statistics, multimedia handling, system safety and security, overall stability, reliable error handling, and <span class="No-Break">so on.</span></p>
<p>While the OS is obliged to execute all those tasks, it is still necessary for the programmer to pay attention to the system specifics and requirements. Working from a higher level of abstraction, through virtual machines, for example, does not mean discarding the need to understand how our code impacts the system’s behavior. And programmers, who are closer to the OS layers, are required to manage the system’s resources efficiently as well. This is one of the reasons that OSs provide <strong class="bold">application programming interfaces</strong>, or <strong class="bold">APIs</strong>. It is valuable expertise to know how to use such APIs and what kind of benefits <span class="No-Break">they provide.</span></p>
<p>We believe that the ability to work closely with the OS is a skill that is not so common. Knowledge of how the OS and the computer architecture will behave is at the expert level of software engineering. We will discuss some types of OSs just to give you a broad picture, but the focus of the book<a id="_idIndexMarker003"/> is specifically on <strong class="bold">POSIX-compliant</strong> OSs. That said, let’s get familiar with one of our <span class="No-Break">main toolsets.</span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor018"/>Types of OSs</h2>
<p>If we do some<a id="_idIndexMarker004"/> quick research online, we will find many types of OSs, and the type definition will strictly be based on the criterion searched for. One example is the purpose of the OS: is it a general-purpose one, such as macOS and Windows, or more specific, such <a id="_idIndexMarker005"/>as <strong class="bold">Embedded Linux</strong> and <strong class="bold">FreeRTOS</strong>? Another <a id="_idIndexMarker006"/>example is OSs for PCs versus those for mobile devices. Likewise, the licensing could describe the OSs as open source, enterprise, or enterprise open source. Based on the number of active users at a time, Windows could be considered a <em class="italic">single-user</em> OS, as<a id="_idIndexMarker007"/> it constructs just one <strong class="bold">Win32 API</strong> for<a id="_idIndexMarker008"/> the current <em class="italic">user session</em>. On the other hand, Unix-like OSs are <a id="_idIndexMarker009"/>considered <em class="italic">multi-user</em>, as multiple users can work simultaneously on the system, where each <em class="italic">shell</em> or a <em class="italic">Terminal</em> instance is considered a separate <span class="No-Break">user session.</span></p>
<p>So, the system’s applications and their constraints are fundamental. Therefore, a key distinction to be aware of is the level of restrictions on <a id="_idIndexMarker010"/>the system’s behavior. The <strong class="bold">general-purpose operating systems</strong> (<strong class="bold">GPOSs</strong>) started initially<a id="_idIndexMarker011"/> as <em class="italic">time-sharing</em> OSs. Historically, there is another type of OS, originating from the same period as the time-sharing ones – the <strong class="bold">real-time operating systems</strong> (<strong class="bold">RTOSs</strong>). It is expected <a id="_idIndexMarker012"/>that system programmers understand the specifics of <strong class="bold">GPOSs</strong> and <strong class="bold">RTOSs</strong>. In the following chapters, we will discuss how properties such as task priorities, timer values, peripheral speeds, interrupt and signal handlers, multithreading, and dynamic memory allocation can lead to changes in system behavior. Sometimes these are unpredictable. That’s why we recognize two types of <strong class="bold">RTOSs</strong>: hard and soft <strong class="bold">RTOSs</strong>. Hard <strong class="bold">RTOSs</strong> are usually strictly related to a given piece of hardware. The system developer is familiar with the end device requirements. The task execution times can be preliminary evaluated and programmed, although the device’s input is still treated as asynchronous and unpredictable. Therefore, our focus in this book<a id="_idIndexMarker013"/> remains on <strong class="bold">GPOS</strong> <a id="_idIndexMarker014"/>programming with a bit of soft <span class="No-Break"><strong class="bold">RTOS</strong></span><span class="No-Break"> functions.</span></p>
<p>Let’s set the stage like this: the user receives system resources in a cyclic manner so often that it creates the impression that the user is the only one relying on those resources. The user’s work must not be disrupted, and quick response times are to be expected from an OS; theoretically, the smaller the procedures, the shorter the response times. We will discuss this further in <a href="B20833_02.xhtml#_idTextAnchor029"><span class="No-Break"><em class="italic">Chapter 2</em></span></a> as it is not <span class="No-Break">completely true.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">The user is the main <em class="italic">driver</em> of the system’s functionality with a <strong class="bold">GPOS</strong>. The main job of the OS is maintaining active dialog with the users and the high availability <span class="No-Break">of operations.</span></p>
<p>Here, each task and each request to the OS must be handled quickly within a strict time interval. The <strong class="bold">RTOS</strong> expects user input only during exceptional situations, errors, and <span class="No-Break">unpredicted behavior.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Asynchronously working devices and additional peripheral electronics are the main <em class="italic">drivers</em> of the system’s functionality in an RTOS. The main job of the OS remains process management and <span class="No-Break">task scheduling.</span></p>
<p>As we said, there are two types of <strong class="bold">RTOS</strong>: <em class="italic">hard RTOS</em> and <em class="italic">soft RTOS</em>. In a hard <strong class="bold">RTOS</strong>, real-time <a id="_idIndexMarker015"/>tasks are guaranteed to<a id="_idIndexMarker016"/> be executed on time. System reaction deadlines are usually preliminarily defined, and the <em class="italic">mission-critical</em> data is stored in ROM, so it cannot be updated at runtime. Functionalities such as virtual memory are often removed. Some modern CPU cores provide the so-called <strong class="bold">tightly coupled memory</strong> (<strong class="bold">TCM</strong>), into <a id="_idIndexMarker017"/>which the frequently used data and code lines are loaded from<a id="_idIndexMarker018"/> the <strong class="bold">non-volatile memory</strong> (<strong class="bold">NVM</strong>) on system startup. The system’s behavior is <em class="italic">scripted</em> <em class="italic">a priori</em>. The role of these OSs is related to machine control, where the user’s input <span class="No-Break">is forbidden.</span></p>
<p>A <a id="_idIndexMarker019"/>soft <strong class="bold">RTOS</strong> provides critical tasks with the highest priority until completion and without interruptions. Still, real-time tasks are expected to be completed in a timely manner and should not wait endlessly. It is obvious that this type of OS cannot be utilized for mission-critical tasks: factory machines robots, vehicles, and so on. But it can be used to control the overall system behavior, so this type of OS is found in multimedia and research projects, artificial intelligence, computer graphics, virtual reality devices, and more. As these <strong class="bold">RTOSs</strong> do not clash with the <strong class="bold">GPOS</strong>s, they can be integrated with them. Their functions can be found in some Linux distributions as well. An interesting realization<a id="_idIndexMarker020"/> of this <span class="No-Break">is </span><span class="No-Break"><strong class="bold">QNX</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor019"/>Linux in short</h2>
<p>There are a few <a id="_idIndexMarker021"/>misconceptions here, so let’s settle them briefly. Linux is a <em class="italic">Unix-like OS</em>, meaning it provides similar (and occasionally the same) interfaces as Unix – its functions, especially APIs, are designed to match the ones from Unix. But it is not a <em class="italic">Unix-based</em> OS. Their functions are not implemented in the same way. A similar misconception exists in understandings of the FreeBSD-macOS relationship. Although both share a significant portion of code, their approach is completely different, including the way their kernels <span class="No-Break">are structured.</span></p>
<p>It is important to bear these facts in mind as not all functions we are going to use in this book exist or are reachable on all Unix-like OSs. We are focusing on Linux, and our examples will work as long as the respective technical requirements for each chapter <span class="No-Break">are met.</span></p>
<p>There are a few reasons for this decision. First, Linux is open-sourced, and you can easily check its <a id="_idIndexMarker022"/>kernel code: <a href="https://github.com/torvalds/linux">https://github.com/torvalds/linux</a>. You should be able to read it easily as it is written in C. Even though C is not an object-oriented language, the Linux kernel follows many <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) paradigms. The OS itself consists of many independent design<a id="_idIndexMarker023"/> blocks, called <em class="italic">modules</em>. You could easily configure, integrate, and apply them specifically for your system’s needs. Linux gives us the ability to work with real-time systems (described later in the chapter) and do parallel code executions (discussed in <a href="B20833_06.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>). In short – Linux is easily adaptable, expandable, and configurable; we could easily use this to our advantage. But <span class="No-Break"><em class="italic">where</em></span><span class="No-Break">, exactly?</span></p>
<p>Well, we could develop applications that are close to the OS, or we could even produce some modules ourselves, which can be loaded or unloaded at runtime. Such an example is a filesystem or device driver. We are going to revisit this topic in <a href="B20833_02.xhtml#_idTextAnchor029"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, when deep diving into <a id="_idIndexMarker024"/>the <em class="italic">process</em> entity. For now, let’s say that the modules pretty much look like an OOP design: they are constructible and destructible; sometimes, based on the kernel’s needs, common code could be generalized into one module, and these modules have hierarchical dependencies. Nevertheless, the Linux kernel is considered <em class="italic">monolithic</em>; for<a id="_idIndexMarker025"/> example, it has complex functionality, but the entire OS runs <a id="_idIndexMarker026"/>in <em class="italic">kernel space</em>. In contrast, there are <em class="italic">micro-kernels</em> (QNX, MINIX, or L4), which <a id="_idIndexMarker027"/>constitute the bare minimum of a running OS. Additional functionality in this case is provided through modules that work outside the kernel itself. This leads to a slightly chaotic but overall clear picture of the possibilities of the <span class="No-Break">Linux kernel.</span></p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor020"/>Getting to know the Linux kernel</h1>
<p><span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.1</em> illustrates an example <a id="_idIndexMarker028"/>of a Linux kernel. Based on your needs, the system architecture could look different, but you can observe the three main layers we expect to see in any given <span class="No-Break">Linux system.</span></p>
<p>These are the <em class="italic">user space</em> (running processes and their threads), the <em class="italic">kernel space</em> (the running kernel itself, usually a process of its own), and the <em class="italic">computer </em>– this could be any kind of computing device, such as a PC, tablet, smartphone, supercomputer, IoT device, and so on. One by one, all the terms observed in the diagram will fall into place as we explain them in the following chapters, so don’t worry if you are not familiar with all of them <span class="No-Break">right now.</span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<img alt="Figure 1.1 – Overview of the Linux kernel and the neighboring layers" height="630" src="image/Figure_1.1_B20833.jpg" width="1224"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Overview of the Linux kernel and the neighboring layers</p>
<p>Some<a id="_idIndexMarker029"/> interdependencies in the preceding diagram have probably made an impression on you already. For example, see how<a id="_idIndexMarker030"/> the <em class="italic">device drivers</em>, the <em class="italic">respective devices</em>, and the <em class="italic">interrupts</em> are related. The <a id="_idIndexMarker031"/>device drivers are a generalization of <em class="italic">character device drivers</em>, <em class="italic">block device drivers</em>, and <em class="italic">network device drivers.</em> Note how the interrupts are related to the <em class="italic">scheduling</em> of the tasks. This is a trivial but fundamental mechanism, used heavily in the implementation of drivers. It is an initial <em class="italic">communication</em> <em class="italic">and</em> <em class="italic">control</em> mechanism of the OS and <span class="No-Break">the hardware.</span></p>
<p>Just one example: let’s say you want to restore and read a file from the disk (<strong class="bold">NVM</strong>), and <a id="_idIndexMarker032"/>you request it through some standard programming function. A <strong class="source-inline">read()</strong> call will be executed under the hood, which is then translated to a <em class="italic">filesystem</em> operation. The filesystem calls the device driver to find and retrieve the content behind the given file descriptor, which is then related to an address known by the filesystem. This will be discussed further in <a href="B20833_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>. The required device (<strong class="bold">NVM</strong>) starts to search for the piece of data – a file. Until the operation is finished, if the caller process is a single-threaded process and has nothing else to do, it will be stopped. Another process will start to work until the device <em class="italic">finds</em> and <em class="italic">returns a pointer</em> to the file’s address. Then an interrupt is triggered, and this helps the OS to invoke the <em class="italic">scheduler</em>. Our initial process will be started again using the newly loaded data, and the second process will now <span class="No-Break">be stopped.</span></p>
<p>This task <a id="_idIndexMarker033"/>example demonstrates how you can impact the system’s behavior with just a small, insignificant operation – and this is one you will have learned to code in your first programming classes. In most cases, nothing bad will happen, of course. Many processes will be rescheduled all the time during the lifespan of your system. It is the OS’s job to make this happen <span class="No-Break">without disruptions.</span></p>
<p>But the interrupt is a heavy operation that could lead to needless memory accesses and useless application state switches. We will discuss this in <a href="B20833_02.xhtml#_idTextAnchor029"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>. For now, just think about what happens if the system is overloaded – the CPU is at 99% usage, or the disk has received many requests and cannot handle them in a timely manner. And what if that system was part of an airplane’s embedded devices? Of course, this is highly unlikely in reality, as airplanes have strict technical requirements and high-quality standards to meet. But just for the sake of argument, consider how you might prevent a similar situation from happening, or how you would guarantee the code’s successful execution in any <span class="No-Break">user scenario.</span></p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor021"/>Introducing the system call interface and system programming</h1>
<p>Of course, the <a id="_idIndexMarker034"/>example that we just saw is simplified but gives us some idea about the work that the OS needs to do – in essence, it is responsible for managing and providing resources, but at the same time remains available for other processes’ requests. This is a messy job on modern OSs. Rarely can we do anything about it. So, to have better control and predictability of system behavior, programmers might directly use the<a id="_idIndexMarker035"/> OS’s API, called the <strong class="bold">system </strong><span class="No-Break"><strong class="bold">call interface</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">The NVM data request is a procedure that benefits from the <strong class="bold">system call interface</strong>, as the OS will be obliged to turn this<a id="_idIndexMarker036"/> request into an <strong class="bold">application binary interface</strong> (<strong class="bold">ABI</strong>) call, referring to the respective device driver. Such an operation is known as a <em class="italic">system call</em>. Using system calls to implement or execute functions provided by the OS is known<a id="_idIndexMarker037"/> as<em class="italic"> system programming</em>. The system calls are the only entry points to the kernel’s services. They are generally wrapped by libraries such as <strong class="source-inline">glibc</strong> and are not <span class="No-Break">invoked directly.</span></p>
<p>In other <a id="_idIndexMarker038"/>words, the system calls define the programmer’s interface through which all kernel services are made available. The OS can be considered as more of a mediator between the kernel service and the hardware. Unless you like to play with hardware pins and low-level platform instructions, or you are a module architect yourself, you should bravely leave the details to the OS. It is the OS’s responsibility to handle the specific computer physical interface operations. It is the application’s responsibility to use the correct system calls. And it is the software engineer’s task to be aware of their impact on the system’s overall behavior. Bear in mind that using system calls comes with <span class="No-Break">a price.</span></p>
<p>As observed in the example, the OS will do a lot while retrieving a file. And even more will be done when memory is allocated dynamically, or a single memory chunk is accessed by multiple threads. We will discuss this further in the following chapters, and will emphasize using systems calls sparingly, with awareness, whether voluntarily or involuntarily, wherever possible. Simply said, system calls are not trivial function calls as they are not executed in user space. Instead of going to the next procedure in your program’s stack, the system call triggers a mode switch, which leads to a jump to a routine in the kernel’s memory stack. Reading from a file can be visualized <span class="No-Break">as follows:</span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<img alt="Figure 1.2 – System call interface representation of reading from a file" height="251" src="image/Figure_1.2_B20833.jpg" width="698"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – System call interface representation of reading from a file</p>
<p>When should we use system calls then? Put simply, when we want to be very precise about some OS tasks, <a id="_idIndexMarker039"/>often<a id="_idIndexMarker040"/> related<a id="_idIndexMarker041"/> to <strong class="bold">device management</strong>, <strong class="bold">file management</strong>, <strong class="bold">process control</strong>, or <strong class="bold">communication infrastructure</strong>. We <a id="_idIndexMarker042"/>are going to present many examples of these roles in the later chapters, but in brief, you are welcome to read more and get familiar yourself with <span class="No-Break">the following:</span></p>
<pre class="source-code">
<strong class="bold">syscall()</strong>
<strong class="bold">fork()</strong>
<strong class="bold">exec()</strong>
<strong class="bold">exit()</strong>
<strong class="bold">wait()</strong>
<strong class="bold">kill()</strong></pre> <p class="callout-heading">Important links</p>
<p class="callout">The right place to start is <a id="_idIndexMarker043"/>the <strong class="bold">Linux man-pages project</strong>, linked <span class="No-Break">here: </span><a href="https://www.kernel.org/doc/man-pages/"><span class="No-Break">https://www.kernel.org/doc/man-pages/</span></a><span class="No-Break">.</span></p>
<p class="callout">A brief list of the<a id="_idIndexMarker044"/> useful system calls can be found at the following <span class="No-Break">link: </span><a href="https://man7.org/linux/man-pages/man2/syscalls.2.xhtml"><span class="No-Break">https://man7.org/linux/man-pages/man2/syscalls.2.xhtml</span></a><span class="No-Break">.</span></p>
<p>We strongly <a id="_idIndexMarker045"/>encourage you to do more research on system calls used in your own projects. Are there any, and what kind of job do they do? Are there any alternatives in <span class="No-Break">your implementations?</span></p>
<p>You have probably already guessed that using the <strong class="bold">system call interface</strong> involves a security risk for the system, too. Being that close to the kernel and the device control provides a great opportunity for malicious software to infiltrate your software. While your software is impacting system behavior, another program might sniff around and gather valuable data. The least you could do is design your code in such a way that the user’s interface is well isolated from the crucial procedures, especially system calls. It is impossible to be 100% safe, and while there are many comprehensive books on the matter of security, the art of securing a system is a constantly evolving <span class="No-Break">process itself.</span></p>
<p>Speaking about processes, let’s proceed to the next topic: the fundamental entities of a <span class="No-Break">Linux system.</span></p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor022"/>Navigating through files, processes, and threads</h1>
<p>If you made it to here – great job! We are going to cover processes and threads thoroughly in <a href="B20833_02.xhtml#_idTextAnchor029"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, and filesystems in <a href="B20833_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>. In the meantime, we will take a short detour here, just to paint a better picture for you, through the definition of three important terms: <strong class="bold">files</strong>, <strong class="bold">processes</strong>, and <strong class="bold">threads</strong>. You probably already noticed two of these in the kernel overview earlier, so we will explain them briefly now in case you are not familiar <span class="No-Break">with them.</span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor023"/>File</h2>
<p>In short, we<a id="_idIndexMarker046"/> require files to represent multiple kinds of resources on our system. The programs we write are files as well. The compiled code, for example, the executable binaries (<strong class="source-inline">.bin</strong>, <strong class="source-inline">.exe</strong>), and the libraries are all files (<strong class="source-inline">.o</strong>, <strong class="source-inline">.so</strong>, <strong class="source-inline">.lib</strong>, .<strong class="source-inline">dll</strong>, and so on). Additionally, we need them for communication mechanisms and for storage management. Do you know what types of files are recognizable on Linux? Let’s brief you on <span class="No-Break">that quickly:</span></p>
<ul>
<li><strong class="bold">Ordinary or regular files</strong>: Almost <a id="_idIndexMarker047"/>all files storing data on the system are treated as regular files: text, media, code, and <span class="No-Break">so on.</span></li>
<li><strong class="bold">Directories</strong>: Used<a id="_idIndexMarker048"/> for building the hierarchical structure of the filesystem. Instead of storing data, they store the locations of <span class="No-Break">other files.</span></li>
<li><strong class="bold">Special (device) files</strong>: You <a id="_idIndexMarker049"/>can find them under your <strong class="source-inline">/dev</strong> directory, representing all your <span class="No-Break">hardware devices.</span></li>
<li><strong class="bold">Links</strong>: We <a id="_idIndexMarker050"/>use these to allow access to another file at a different location. Actually, they are substitutions of real files, and through them those files are accessed directly. This is different than Windows’ shortcuts. They are specific file types, and an application is required to support them – first to handle the shortcut metadata, then to point at the resource, so the file is not accessed in <span class="No-Break">one go.</span></li>
<li><strong class="bold">Sockets</strong>: This <a id="_idIndexMarker051"/>is the communication endpoint for a process to exchange data, including with <span class="No-Break">other systems.</span></li>
<li><strong class="bold">Named pipes</strong>: We <a id="_idIndexMarker052"/>use named pipes to exchange bidirectional data between two processes currently running on <span class="No-Break">the system.</span></li>
</ul>
<p>In <a href="B20833_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we will play around with these through some practical examples. You will see the usage of every file type there, except sockets, which will be explained in great detail later in the book. What we need now is a program <span class="No-Break">to run.</span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor024"/>Process and thread</h2>
<p>A<a id="_idIndexMarker053"/> process is an <em class="italic">instance of a program, </em>an executing instance, to be precise. It has its own address space and remains isolated from other processes. This means that each process has a range of (usually virtual) addresses that the OS assigns to it. Linux treats them<a id="_idIndexMarker054"/> as <em class="italic">tasks</em>. They are not observable by the general user. This is just how the kernel does its job. Each task is described through the <strong class="source-inline">task_struct</strong> entity, defined in <strong class="source-inline">include/linux/sched.h</strong>. System administrators and system programmers observe processes through the process table, hashed through each process’s specific process identifier – <strong class="source-inline">pid</strong>. This method is used for a quick lookup of a process – use the <strong class="source-inline">ps</strong> command in Terminal to see the process status on the system and then type the following command to see the specific info for a <span class="No-Break">single process:</span></p>
<pre class="console">
ps -p &lt;required pid&gt;</pre> <p>For example, let’s start some program, called <strong class="source-inline">test</strong>, and let <span class="No-Break">it run:</span></p>
<pre class="console">
$ ./test</pre> <p>You can open a separate Terminal and see <strong class="source-inline">test</strong> in the list of running processes <span class="No-Break">as follows:</span></p>
<pre class="console">
$ ps
PID TTY           TIME CMD
...
56693 ttys001    0:00.00 test</pre> <p>And if you know the <strong class="source-inline">PID</strong> already, then just do <span class="No-Break">the following:</span></p>
<pre class="console">
$ ps –p 56693
56693 ttys001    0:00.00 test</pre> <p>A new process is created via a copy of the current process’s attributes and will belong to a <em class="italic">process group</em>. One or <a id="_idIndexMarker055"/>more groups<a id="_idIndexMarker056"/> create a <em class="italic">session</em>. Each session is related to a <em class="italic">terminal</em>. Both groups and sessions have <em class="italic">process leaders</em>. The <em class="italic">cloning</em> of <a id="_idIndexMarker057"/>attributes is used <a id="_idIndexMarker058"/>mainly for resource sharing. If two<a id="_idIndexMarker059"/> processes share the same virtual memory space, they are treated and <a id="_idIndexMarker060"/>managed as two <em class="italic">threads</em> in a single process, but they are not as heavyweight as processes. What is a <span class="No-Break">thread, then?</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Overall, there are four entities we care about: first is the executable file as it is the unit-carrier of the instructions to be executed. Second is the process – the worker unit executing those instructions. Third – we need these instructions as instruments to handle and manage system resources. And fourth is the thread – the smallest sequence of instructions, managed independently by the OS, and part of a process. Bear in mind that the implementations of processes and threads are different for every OS, so do your research before <span class="No-Break">using them.</span></p>
<p>From the kernel’s<a id="_idIndexMarker061"/> point of view, the main thread of the process is the<em class="italic"> task group leader</em>, identified<a id="_idIndexMarker062"/> in the code as <strong class="source-inline">group_leader</strong>. All threads spawned by the group leader are iterable through <strong class="source-inline">thread_node</strong>. Actually, they are stored in a singly linked list and <strong class="source-inline">thread_node</strong> is its head. The spawned threads carry a pointer to the <strong class="source-inline">group_leader</strong> tool. The <em class="italic">process creator</em>’s <strong class="source-inline">task_struct</strong><em class="italic"> </em>object<em class="italic"> </em>is pointed <a id="_idIndexMarker063"/>by it. You probably already guessed correctly that it is the same as the <strong class="source-inline">task_struct</strong> of the <span class="No-Break">group leader.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">If a process spawns another process, for example, through <strong class="source-inline">fork()</strong>, the newly created processes (known as <em class="italic">child processes</em>) know <a id="_idIndexMarker064"/>about their creator through the <strong class="source-inline">parent</strong> pointer. They are also aware of their siblings through the <strong class="source-inline">sibling</strong> pointer, which is a list node to some other child process of the parent. Each parent knows about its children through <strong class="source-inline">children</strong> – a pointer to the list head, storing the children and providing access <span class="No-Break">to them.</span></p>
<p>As we can see in the following figure, the threads do not define any other <span class="No-Break">data structures:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<img alt="Figure 1.3 – Structures of processes and threads through task_structs" height="505" src="image/Figure_1.3_B20833.jpg" width="763"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Structures of processes and threads through task_structs</p>
<p>We’ve <a id="_idIndexMarker065"/>mentioned <strong class="source-inline">fork()</strong>already a couple of times, but what is it? Well, put simply, it is a system function that creates a process copy of the process caller. It provides the parent with the new process’s ID and initiates the execution of the child. We are going to provide some code examples in the next chapter, so you could take a look there for more details. There’s something important we should mention now, as we are on the topic of <span class="No-Break">Linux environments.</span></p>
<p>Behind the scenes, <strong class="source-inline">fork()</strong> is replaced with <strong class="source-inline">clone()</strong>. Different options are provided through <strong class="source-inline">flags</strong>, but if all are set to zero, <strong class="source-inline">clone()</strong> behaves like <strong class="source-inline">fork()</strong>. We advise you to read more <span class="No-Break">here: </span><a href="https://man7.org/linux/man-pages/man2/clone.2.xhtml"><span class="No-Break">https://man7.org/linux/man-pages/man2/clone.2.xhtml</span></a><span class="No-Break">.</span></p>
<p>You’re probably asking yourself why this implementation is preferable. Think about it this way: when the kernel does a switch between the processes, it checks the address of the current process in the virtual memory, the <em class="italic">page directory</em> to be exact. If it is the same as the<a id="_idIndexMarker066"/> newly executed process, then they share the same address space. Then, the switch is only a simple pointer jump instruction, usually to the entry point of the program. This means a faster rescheduling is to be expected. Be careful – the processes might share the <a id="_idIndexMarker067"/>same address space, but not the same program stack. <strong class="source-inline">clone()</strong> takes care of creating a different stack for <span class="No-Break">each process.</span></p>
<p>Now that the process is created, we must take a<a id="_idIndexMarker068"/> look at its <em class="italic">running mode</em>. Note that this is not the same <a id="_idIndexMarker069"/>as the <span class="No-Break"><em class="italic">process state</em></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor025"/>Types of processes based on their running mode</h2>
<p>Some processes <a id="_idIndexMarker070"/>require user interaction to be initiated or interacted with. They are <a id="_idIndexMarker071"/>known as <em class="italic">foreground processes</em>. But as you’ve probably figured out, there are some processes that run independently of our, or any other user’s, activity. Processes of this kind are <a id="_idIndexMarker072"/>known<a id="_idIndexMarker073"/> as <em class="italic">background processes</em>. Unless instructed otherwise, the terminal inputs as program execution calls or user commands are treated as foreground processes by default. To run a process in the background, simply place <strong class="source-inline">&amp;</strong> at the end of the command line that you use to start the process. For example, let’s call the already known <strong class="source-inline">test</strong>, and after it finishes, we see the following <span class="No-Break">in Terminal:</span></p>
<pre class="console">
$ ./test &amp;
[1] 62934
[1]  + done       ./test</pre> <p>You can easily stop it using its <strong class="source-inline">pid</strong> when calling the <span class="No-Break"><strong class="source-inline">kill</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
$ ./test &amp;
[1] 63388
$ kill 63388
[1]  + terminated./test</pre> <p>As you can see, killing a process and letting it terminate by itself are two different things, and killing the process could lead to unpredictable system behavior or the inability to access some resource, such as a file or a socket left unclosed. This topic will be revisited later in <span class="No-Break">the book.</span></p>
<p>Other processes run unattended. They <a id="_idIndexMarker074"/>are known as <em class="italic">daemons</em> and run constantly in the background. They are expected to be always available. Daemons are usually started through the system’s startup scripts and run until it’s shut down. They usually provide system services and multiple users rely on them. Therefore, the daemons on startup are usually initiated by the user with ID 0 (usually <strong class="source-inline">root</strong>) and might run with <span class="No-Break"><strong class="source-inline">root</strong></span><span class="No-Break"> privileges.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">The user with the highest privileges on a Linux system is known as the root user, or simply root. This privilege level allows the performing of security-related tasks. This role has a direct impact on the system’s integrity, therefore all other users must be set with the least-possible privilege level until a higher one <span class="No-Break">is required.</span></p>
<p>A <em class="italic">zombie process</em> is a <a id="_idIndexMarker075"/>process that has been terminated, but <a id="_idIndexMarker076"/>is still recognized through its <strong class="source-inline">pid</strong>. It has no address space. Zombie processes continue to exist for as long as their parent processes run. This means that until we exit the main process, shut down the system, or restart it, the zombie process will still appear as <strong class="source-inline">&lt;defunct&gt;</strong> when listed <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">ps</strong></span><span class="No-Break">:</span></p>
<pre class="console">
$ ps
  PID TTY           TIME CMD
…
64690 ttys000    0:00.00 &lt;defunct&gt;</pre> <p>You can see zombie processes through <strong class="source-inline">top</strong> <span class="No-Break">as well:</span></p>
<pre class="console">
$ top
t–p - 07:58:26 up 100 days,  2:34, 2 users,  load average: 1.20, 1.12, 1.68
Tasks: 200 total,   1 running, 197 sleeping,   1 stopped,   1 zombie</pre> <p>Getting back to the discussion on background processes, there is another way to execute specific procedures without explicitly starting background processes. Even better – we can manage such processes running on system startup or on different system events. Let’s look at this in the <span class="No-Break">next section.</span></p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor026"/>Running services with init and systemd</h1>
<p>Let’s use<a id="_idIndexMarker077"/> this opportunity to discuss the <strong class="source-inline">init</strong> and the <strong class="source-inline">systemd</strong> process daemons. There are others as well, but we’ve decided to retain our focus on these two. The first one is the initial process, executed on a Linux system by the kernel, and its <strong class="source-inline">pid</strong> is <span class="No-Break">always </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">:</span></p>
<pre class="console">
$ ps -p 1
PID TTY          TIME CMD
1 ?        04:53:20 systemd</pre> <p>It is known as <a id="_idIndexMarker078"/>the parent of all processes on the system as it is used to initialize, manage, and track other services and daemons. The first <strong class="source-inline">init</strong> daemon for Linux is called <strong class="source-inline">Init</strong> and it defines six system states. All system services are mapped to those states, respectively. Its script is used to start processes in a pre-defined order, which is occasionally used by system programmers. One possible reason to use this is to reduce the startup duration of the system. To create a service or edit the script, you could modify <strong class="source-inline">/etc/init.d</strong>. As this is a directory, we could list it with the <strong class="source-inline">ls</strong> command and see all the services that could be run through <strong class="source-inline">init</strong>. </p>
<p>This is what we have on <span class="No-Break">our machine:</span></p>
<pre class="console">
$ ls /etc/init.d/
acpid
alsa-utils
anacron
...
ufw
unidd
x11-common</pre> <p>Each of these scripts follows the same code template for its execution <span class="No-Break">and maintenance:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<img alt="Figure 1.4 – init.d script, representing the possible service actions" height="785" src="image/Figure_1.4_B20833.jpg" width="545"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – init.d script, representing the possible service actions</p>
<p>You can <a id="_idIndexMarker079"/>generate the same template yourself <a id="_idIndexMarker080"/>and read more about the <strong class="source-inline">init</strong> script source code through the <span class="No-Break">following command:</span></p>
<pre class="console">
$ man init-d-script</pre> <p>You can list the status of the available services through the <span class="No-Break">following command:</span></p>
<pre class="console">
$ service --status-all
 [ + ]  acpid
 [ - ]  alsa-utils
 [ - ]  anacron
...
 [ + ]  ufw
 [ - ]  uuidd
 [ - ]  x11-common</pre> <p>We<a id="_idIndexMarker081"/> could<a id="_idIndexMarker082"/> stop the firewall service – <span class="No-Break"><strong class="source-inline">ufw</strong></span><span class="No-Break">:</span></p>
<pre class="console">
$ service ufw stop</pre> <p>Now, let’s check <span class="No-Break">its status:</span></p>
<pre class="console">
$ service ufw status
● ufw.service - Uncomplicated firewall
Loaded: loaded (/lib/systemd/system/ufw.service; enabled; vendor preset: enabled)
Active: inactive (dead) since Thu 2023-04-06 14:33:31 EEST; 46s ago
Docs: man:ufw(8)
Process: 404 ExecStart=/lib/ufw/ufw-init start quiet (code=exited, status=0/SUCCESS)
Process: 3679 ExecStop=/lib/ufw/ufw-init stop (code=exited, status=0/SUCCESS)
Main PID: 404 (code=exited, status=0/SUCCESS)
Apr 06 14:33:30 oem-virtual-machine systemd[1]: Stopping Uncomplicated firewall...
Apr 06 14:33:31 oem-virtual-machine ufw-init[3679]: Skip stopping firewall: ufw (not enabled)
Apr 06 14:33:31 oem-virtual-machine systemd[1]: ufw.service: Succeeded.
Apr 06 14:33:31 oem-virtual-machine systemd[1]: Stopped Uncomplicated firewall.</pre> <p>Now, let’s start it again and check its status <span class="No-Break">once more:</span></p>
<pre class="console">
$ service ufw start
$ service ufw status
● ufw.service - Uncomplicated firewall
Loaded: loaded (/lib/systemd/system/ufw.service; enabled; vendor preset: enabled)
Active: active (exited) since Thu 2023-04-06 14:34:56 EEST; 7s ago
Docs: man:ufw(8)
Process: 3736 ExecStart=/lib/ufw/ufw-init start quiet (code=exited, status=0/SUCCESS)
Main PID: 3736 (code=exited, status=0/SUCCESS)
Apr 06 14:34:56 oem-virtual-machine systemd[1]: Starting Uncomplicated firewall...
Apr 06 14:34:56 oem-virtual-machine systemd[1]: Finished Uncomplicated firewall.</pre> <p>In a<a id="_idIndexMarker083"/> similar fashion, you could create your own service and use the <strong class="source-inline">service</strong> command to start it. An important remark is that <strong class="source-inline">init</strong> is <a id="_idIndexMarker084"/>considered an outdated approach on modern, full-scale Linux systems. Still, it can be found on <a id="_idIndexMarker085"/>every Unix-based OS, unlike <strong class="bold">systemd</strong>, so system programmers would anticipate its use as a common interface to services. Therefore, we use it more as a simple example and an explanation for where services are coming from. If we want to use the latest approach, we must turn <span class="No-Break">to </span><span class="No-Break"><strong class="bold">systemd</strong></span><span class="No-Break">.</span></p>
<p><strong class="bold">systemd</strong> is an <strong class="bold">init</strong> daemon <a id="_idIndexMarker086"/>that represents the modern approach to running services on Linux systems. It provides a parallel system services startup feature, which additionally speeds up the initialization procedure. Each service is stored in a <strong class="source-inline">.service</strong> file under the <strong class="source-inline">/lib/systemd/system</strong> or <strong class="source-inline">/etc/systemd/system</strong> directory. The services found in <strong class="source-inline">/lib</strong> are definitions for system startup services and those in <strong class="source-inline">/etc</strong> are for the services that start during system runtime. Let’s <span class="No-Break">list them:</span></p>
<pre class="console">
$ ls /lib/systemd/system
accounts-daemon.service
acpid.path
acpid.service
...
sys-kernel-config.mount
sys-kernel-debug.mount
sys-kernel-tracing.mount
syslog.socket
$ ls /etc/systemd/system
bluetooth.target.wants
display-manager.service
…
timers.target.wants
vmtoolsd.service</pre> <p>Before<a id="_idIndexMarker087"/> we continue with an example, let’s put one disclaimer here – <strong class="source-inline">systemd</strong> has a much more complex interface than <strong class="source-inline">init</strong>. We <a id="_idIndexMarker088"/>encourage you to spend time examining it separately as we cannot summarize it in short here. But if you list your <strong class="source-inline">systemd</strong> directories, you will probably observe many types of files. In the context of the daemon, they are known as <strong class="source-inline">units</strong>. Each of them provides a different interface as they each relate to a certain entity managed by <strong class="source-inline">systemd</strong>. The script inside each file describes what options are set and what the given service does. The <strong class="source-inline">units</strong> names are eloquent. <strong class="source-inline">.timer</strong> is for timer management, <strong class="source-inline">.service</strong> is for how a given service will be initiated and what it depends on, <strong class="source-inline">.path</strong> describes the path-based activation of a given service, and <span class="No-Break">so on.</span></p>
<p>Let’s make a simple <strong class="source-inline">systemd</strong> service that will have the purpose of monitoring whether a given file is being modified. One example is monitoring some configuration: we wouldn’t want to limit its permissions for file update, but we’d still like to know whether someone has <span class="No-Break">changed it.</span></p>
<p>First, let’s create some dummy file through a simple text editor. Let’s imagine it’s a real configuration. Printing it out gives <span class="No-Break">the following:</span></p>
<pre class="console">
$ cat /etc/test_config/config
test test</pre> <p>Let’s prepare a script that describes the procedure we require to be executed when the file is changed. Again, just for the purposes of this example, let’s create it through a simple text editor – it will look <span class="No-Break">like this:</span></p>
<pre class="console">
$ cat ~/sniff_printer.sh
echo "File /etc/test_config/config changed!"</pre> <p>When <a id="_idIndexMarker089"/>the script is called, there will be a message<a id="_idIndexMarker090"/> that the file has changed. Of course, you could put any program here. Let’s call it <strong class="source-inline">sniff_printer</strong>, because we are sniffing for a file change through the service, and we will print <span class="No-Break">some data.</span></p>
<p>How does this happen then? First, we define our new service through the required <strong class="source-inline">unit</strong> – <strong class="source-inline">myservice_test.service</strong> – implementing the <span class="No-Break">following script:</span></p>
<pre class="console">
[Unit]
Description=This service is triggered through a file change
[Service]
Type=oneshot
ExecStart=bash /home/oem/sniff_printer.sh
[Install]
WantedBy=multi-user.target</pre> <p>Second, we describe the file path we’re monitoring through another <strong class="source-inline">unit</strong> called <strong class="source-inline">myservice_test.path</strong>, implemented via the <span class="No-Break">following code:</span></p>
<pre class="console">
[Unit]
Description=Path unit for watching for changes in "config"
[Path]
PathModified=/etc/test_config/config
Unit=myservice_test.service
[Install]
WantedBy=multi-user.target</pre> <p>Combining <a id="_idIndexMarker091"/>all these pieces together, we get a <a id="_idIndexMarker092"/>service that will print out a simple message. It will be triggered whenever the provided file is updated. Let’s see how it goes. As we are adding a new file to the service directory, we must execute <span class="No-Break">a reload:</span></p>
<pre class="console">
$ systemctl daemon-reload</pre> <p>Now, let’s enable and start <span class="No-Break">the service:</span></p>
<pre class="console">
$ systemctl enable myservice_test
$ systemctl start myservice_test</pre> <p>We need to update the file through some text editor, such as <span class="No-Break">the following:</span></p>
<pre class="console">
$ vim /etc/test_config/config</pre> <p>In order to see the effect we’ve triggered, we have to go through the <span class="No-Break">service status:</span></p>
<pre class="console">
$ systemctl status myservice_test
● myservice_test.service - This service is for printing the "config".
Loaded: loaded (/etc/systemd/system/myservice_test.service; enabled; vendor preset: enabled)
Active: inactive (dead) since Thu 2023-04-06 15:37:12 EEST; 31s ago
Process: 5340 ExecStart=/bin/bash /home/oem/sniff_printer.sh (code=exited, status=0/SUCCESS)
Main PID: 5340 (code=exited, status=0/SUCCESS)
Apr 06 15:37:12 oem-virtual-machine systemd[1]: Starting This service is for printing the "config"....
Apr 06 15:37:12 oem-virtual-machine bash[5340]: File /etc/test_config/config changed!
Apr 06 15:37:12 oem-virtual-machine systemd[1]: myservice_test.service: Succeeded.
Apr 06 15:37:12 oem-virtual-machine systemd[1]: Finished This service is for printing the "config"..</pre> <p>You <a id="_idIndexMarker093"/>can validate that the service has been<a id="_idIndexMarker094"/> triggered as our message <span class="No-Break">is present:</span></p>
<pre class="console">
Apr 06 15:37:12 oem-virtual-machine bash[5340]: File /etc/test_config/config changed!</pre> <p>We also see the code that was executed and its <span class="No-Break">successful status:</span></p>
<pre class="console">
Process: 5340 ExecStart=/bin/bash /home/oem/sniff_printer.sh (code=exited, status=0/SUCCESS)
Main PID: 5340 (code=exited, status=0/SUCCESS)</pre> <p>But the process is no longer active as the service <strong class="source-inline">unit</strong> is of type <strong class="source-inline">oneshot</strong>, therefore only another file update will retrigger it. We believe this example offers a simple explanation of how a daemon could be created and started during system runtime. Feel free to experiment yourself and try different unit types <span class="No-Break">or options.</span></p>
<p>The process daemon and the startup procedures are a large area of expertise in system administration, programming, monitoring, and obtaining execution flow information. These topics as well as that of the next section deserve books of <span class="No-Break">their own.</span></p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor027"/>Portable Operating System Interface (POSIX)</h1>
<p>The <strong class="bold">POSIX</strong> standard <a id="_idIndexMarker095"/>has the main task of maintaining compatibility between different OSs. Therefore, POSIX is frequently used by both standard application software developers and system programmers. Nowadays, it can be found not only on Unix-like OSs, but in Windows environments as well – for <a id="_idIndexMarker096"/>example, <strong class="bold">Cygwin</strong>, <strong class="bold">MinGW</strong>, and <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>). POSIX <a id="_idIndexMarker097"/>defines both the system- and the user-level<a id="_idIndexMarker098"/> APIs with one remark: using POSIX, the programmer doesn’t need to distinguish between system calls and <span class="No-Break">library functions.</span></p>
<p>The<a id="_idIndexMarker099"/> POSIX API is <a id="_idIndexMarker100"/>frequently used in <a id="_idIndexMarker101"/>the C programming language. Thus, it is compilable with C++. Additional functions are provided to <a id="_idIndexMarker102"/>the <strong class="bold">system call interface</strong> in a few<a id="_idIndexMarker103"/> important areas of system programming: <strong class="bold">file operations</strong>, <strong class="bold">memory management</strong>, <strong class="bold">process and thread control</strong>, <strong class="bold">networking and communications</strong>, and <strong class="bold">regular expressions</strong> – as you can see, it <a id="_idIndexMarker104"/>pretty<a id="_idIndexMarker105"/> much<a id="_idIndexMarker106"/> covers everything that the already existing system calls do. Just don’t get confused and think that this is always <span class="No-Break">the case.</span></p>
<p>As with every standard, POSIX has multiple versions, and you must be aware of which one is present in your system. It also could be a part of some environment subsystem, such as <a id="_idIndexMarker107"/>the <strong class="bold">Microsoft POSIX subsystem</strong> for Windows. This is a key remark as it is possible that the environment itself doesn’t expose the entire interface to you. One reason could be the security assessment of <span class="No-Break">the system.</span></p>
<p>With<a id="_idIndexMarker108"/> the <a id="_idIndexMarker109"/>evolution of POSIX, rules for<a id="_idIndexMarker110"/> code quality have been <a id="_idIndexMarker111"/>established. Some <a id="_idIndexMarker112"/>of them are related to <strong class="bold">multithreaded memory access</strong>, <strong class="bold">synchronization mechanisms</strong> and <strong class="bold">concurrent executions</strong>, <strong class="bold">security</strong> and <strong class="bold">access restrictions</strong>, and <strong class="bold">type safety</strong>. A famous concept in POSIX’s software requirements is <em class="italic">write once, </em><span class="No-Break"><em class="italic">adopt everywhere</em></span><span class="No-Break">.</span></p>
<p>The standard defines and targets four main areas of its application, <span class="No-Break">called volumes:</span></p>
<ul>
<li><strong class="bold">Base definitions</strong>: Main<a id="_idIndexMarker113"/> definitions for the specification: syntax, concepts, terms, and <span class="No-Break">service operations</span></li>
<li><strong class="bold">System interfaces</strong>: Interface<a id="_idIndexMarker114"/> descriptions and <span class="No-Break">definitions’ availability</span></li>
<li><strong class="bold">Utilities</strong>: Shell, command, and <a id="_idIndexMarker115"/><span class="No-Break">utility descriptions</span></li>
<li><strong class="bold">Rationale</strong>: Versioning <a id="_idIndexMarker116"/>information and <span class="No-Break">historical data</span></li>
</ul>
<p>With all that said, in this book our focus is mainly on POSIX as a different approach to system calls. In the following chapters, we will see the benefit of the general pattern for using objects such as message queues, semaphores, shared memory, or threads. A significant improvement is the simplicity of the function calls and their naming conventions. For example, <strong class="source-inline">shm_open()</strong>, <strong class="source-inline">mq_open()</strong>, and <strong class="source-inline">sem_open()</strong> are used to create and open a shared memory object, a message queue, and a semaphore, respectively. Their similarity is obvious. Similar ideas in POSIX are welcomed by system programmers. The API is public, too, and there are substantial community contributions. Additionally, POSIX provides an interface to objects such as the mutex, which is not trivially found and used on Unix. However, in later chapters, we will advise readers to focus more on the C++20 features and for good reason, so bear <span class="No-Break">with us.</span></p>
<p>Using POSIX allows software engineers to generalize their OS-related code and declare it as <em class="italic">not-OS-specific</em>. This allows easier and faster reintegration of the software, thus reducing the time to market. System programmers can also easily switch from one system to another while still writing the same type <span class="No-Break">of code.</span></p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor028"/>Summary</h1>
<p>In this chapter, we have covered the definitions of basic concepts related to OSs. You have learned about Linux’s main kernel structure and its expectations of software design. Real-time OSs were briefly introduced, and we covered the definitions of system calls, the system call interface, and POSIX as well. We’ve also laid the foundations of multiprocessing and multithreading. In the next chapter, we will discuss the process as the main resource user and manager. We will start with some C++20 code. Through this, you will learn about the Linux’s process memory layout, the OS’s process-scheduling mechanism, and how multiprocessing operates plus the challenges it brings. You will also learn some interesting facts about <span class="No-Break">atomic operations.</span></p>
</div>
</div></body></html>