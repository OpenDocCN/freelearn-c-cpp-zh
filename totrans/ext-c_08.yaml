- en: Chapter 08
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章
- en: Inheritance and Polymorphism
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和多态
- en: This chapter is a continuation of the previous two chapters, where we introduced
    how you can do OOP in C and reached the concepts of composition and aggregation.
    This chapter mainly continues the discussion regarding relationships between objects
    and their corresponding classes and covers inheritance and polymorphism. As part
    of this chapter, we conclude this topic and we continue with *Abstraction* in the
    following chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是前两章的延续，在前两章中，我们介绍了如何在C中进行面向对象编程，并达到了组合和聚合的概念。本章主要继续讨论对象与其对应类之间的关系，并涵盖继承和多态。作为本章的一部分，我们总结了这个主题，并在下一章继续讨论*抽象*。
- en: This chapter is heavily dependent on the theory explained in the previous two
    chapters, where we were discussing the possible relationships between classes.
    We explained *composition* and *aggregation* relationships, and now we are going
    to talk about the *extension* or *inheritance* relationship in this chapter, along
    with a few other topics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在很大程度上依赖于前两章中解释的理论，在前两章中，我们讨论了类之间可能存在的关系。我们解释了*组合*和*聚合*关系，现在我们将在本章中讨论*扩展*或*继承*关系，以及一些其他主题。
- en: 'The following are the topics that will be explained throughout this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释以下主题：
- en: As explained earlier, the inheritance relationship is the first topic that we
    discuss. The methods for implementing the inheritance relationship in C will be
    covered, and we will conduct a comparison between them.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，继承关系是我们首先讨论的主题。我们将介绍在C中实现继承关系的方法，并进行比较。
- en: The next big topic is *polymorphism*. Polymorphism allows us to have different
    versions of the same behavior in the child classes, in the case of having an inheritance
    relationship between those classes. We will discuss the methods for having a polymorphic
    function in C; this will be the first step in our understanding of how C++ offers
    polymorphism.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个重要主题是*多态性*。多态性允许我们在子类中拥有相同行为的不同版本，在那些类之间存在继承关系的情况下。我们将讨论在C中实现多态函数的方法；这将是我们理解C++如何提供多态性的第一步。
- en: Let's start our discussion with the inheritance relationship.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从继承关系开始讨论。
- en: Inheritance
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: We closed the previous chapter by talking about *to-have* relationships, which
    eventually led us to composition and aggregation relationships. In this section,
    we are going to talk about *to-be* or *is-a* relationships. The inheritance relationship
    is a to-be relationship.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一章结束时讨论了*拥有*关系，这最终引导我们到了组合和聚合关系。在本节中，我们将讨论*是*或*属于*关系。继承关系是一种是关系。
- en: An inheritance relationship can also be called an *extension relationship* because
    it only adds extra attributes and behaviors to an existing object or class. In
    the following sections, we'll explain what inheritance means and how it can be
    implemented in C.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 继承关系也可以称为*扩展关系*，因为它只向现有的对象或类添加额外的属性和行为。在接下来的几节中，我们将解释继承的含义以及如何在C中实现它。
- en: There are situations when an object needs to have the same attributes that exist
    in another object. In other words, the new object is an extension to the other
    object.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有时一个对象需要拥有存在于另一个对象中的相同属性。换句话说，新对象是另一个对象的扩展。
- en: 'For example, a student has all the attributes of a person, but may also have
    extra attributes. See *Code Box 8-1*:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个学生具有人的所有属性，但也可能有额外的属性。参见*代码框8-1*：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 8-1: The attribute structures of the Person class and the Student
    class'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框8-1：Person类和Student类的属性结构
- en: This example clearly shows how `student_t` extends the attributes of `person_t`
    with new attributes, `student_number` and `passed_credits`, which are student-specific
    attributes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子清楚地展示了`student_t`如何通过新的属性`student_number`和`passed_credits`扩展了`person_t`的属性，这些属性是特定于学生的。
- en: As we have pointed out before, inheritance (or extension) is a to-be relationship,
    unlike composition and aggregation, which are to-have relationships. Therefore,
    for the preceding example, we can say that "a student is a person," which seems
    to be correct in the domain of educational software. Whenever a to-be relationship
    exists in a domain, it is probably an inheritance relationship. In the preceding
    example, `person_t` is usually called the *supertype*, or the *base* type, or
    simply the *parent* type, and `student_t` is usually called the *child* type or
    the *inherited subtype*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前指出的，继承（或扩展）是一种将要成为的关系，与组合和聚合不同，它们是拥有关系。因此，对于前面的例子，我们可以说“一个学生是一个人”，这在教育软件的领域中似乎是正确的。每当一个将要成为的关系存在于一个领域中，它可能就是一个继承关系。在前面的例子中，`person_t`
    通常被称为 *超类型*，或 *基类型*，或简单地称为 *父类型*，而 `student_t` 通常被称为 *子类型* 或 *继承子类型*。
- en: The nature of inheritance
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承的本质
- en: If you were to dig deeper and see what an inheritance relationship really is,
    you would find out that it is really a composition relationship in its nature.
    For example, we can say that a student has a person's nature inside of them. In
    other words, we can suppose that there is a private person object inside the `Student`
    class's attribute structure. That is, an inheritance relationship can be equivalent
    to a one-to-one composition relationship.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你深入挖掘并了解继承关系真正是什么，你会发现它本质上实际上是一种组合关系。例如，我们可以说一个学生体内有人的本质。换句话说，我们可以假设在 `Student`
    类的属性结构内部有一个私有的 `person` 对象。也就是说，继承关系可以等同于一对一的组合关系。
- en: 'So, the structures in *Code Box 8-1* can be written as:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*代码框 8-1* 中的结构可以写成如下：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Code Box 8-2: The attribute structures of the Person and Student classes but
    nested this time'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 8-2：Person 和 Student 类的属性结构，但这次是嵌套的
- en: This syntax is totally valid in C, and in fact nesting structures by using structure
    variables (not pointers) is a powerful setup. It allows you to have a structure
    variable inside your new structure that is really an extension to the former.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法在 C 语言中是完全有效的，实际上通过使用结构变量（而非指针）嵌套结构是一种强大的设置。它允许你在新的结构中拥有一个结构变量，这实际上是对之前结构的扩展。
- en: With the preceding setup, necessarily having a field of type `person_t` as the
    first field, a `student_t` pointer can be easily cast to a `person_t` pointer,
    and both of them can point to the same address in memory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述设置中，必然有一个 `person_t` 类型的字段作为第一个字段，一个 `student_t` 指针可以轻松地转换为 `person_t` 指针，并且它们都可以指向内存中的相同地址。
- en: This is called *upcasting*. In other words, casting a pointer of the type of
    the child's attribute structure to the type of the parent's attribute structure
    is upcasting. Note that with structure variables, you cannot have this feature.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为 *向上转型*。换句话说，将子属性结构的指针类型转换为父属性结构类型的类型是向上转型。请注意，使用结构变量时，您无法拥有此功能。
- en: '*Example 8.1* demonstrates this as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8.1* 如下演示了这一点：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Code Box 8-3 [ExtremeC_examples_chapter8_1.c]: Example 8.1, showing upcasting
    between Student and Person object pointers'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 8-3 [ExtremeC_examples_chapter8_1.c]：示例 8.1，展示了 Student 和 Person 对象指针之间的向上转型
- en: 'As you can see, we expect that the `s_ptr` and `p_ptr` pointers are pointing
    to the same address in memory. The following is the output after building and
    running *example 8.1*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们预计 `s_ptr` 和 `p_ptr` 指针都指向内存中的相同地址。以下是在构建和运行 *示例 8.1* 后的输出：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Shell Box 8-1: The output of example 8.1'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 8-1：示例 8.1 的输出
- en: And yes, they are pointing to the same address. Note that the shown addresses
    can be different in each run, but the point is that the pointers are referring
    to the same address. This means that a structure variable of the type `student_t`
    is really inheriting the `person_t` structure in its memory layout. This implies
    that we can use the function behaviors of the `Person` class with a pointer that
    is pointing to a `student` object. In other words, the `Person` class's behavior
    functions can be reused for the `student` objects, which is a great achievement.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它们指向的是同一个地址。请注意，显示的地址在每次运行中可能不同，但重点是这些指针正在引用相同的地址。这意味着 `student_t` 类型的结构变量实际上在内存布局中继承了
    `person_t` 结构。这暗示我们可以使用指向 `student` 对象的指针使用 `Person` 类的函数行为。换句话说，`Person` 类的行为函数可以用于
    `student` 对象，这是一个巨大的成就。
- en: 'Note that the following is wrong, and the code won''t compile:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容是错误的，代码无法编译：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Code Box 8-4: Establishing an inheritance relationship which doesn''t compile!'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 8-4：无法编译的继承关系建立！
- en: The line declaring the `person` field generates an error because you cannot
    create a variable from an *incomplete type*. You should remember that the forward
    declaration of a structure (similar to the first line in *Code Box 8-4*) results
    in the declaration of an incomplete type. You can have only pointers of incomplete
    types, *not* variables. As you've seen before, you cannot even allocate Heap memory
    for an incomplete type.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 声明`person`字段的行会生成错误，因为你不能从一个*不完整类型*创建变量。你应该记住，结构的向前声明（类似于*代码框 8-4*中的第一行）会导致不完整类型的声明。你可以只有不完整类型的指针，*不能*有变量。正如你之前看到的，你甚至不能为不完整类型分配堆内存。
- en: So, what does this mean? It means that if you're going to use nested structure
    variables in order to implement inheritance, the `student_t` structure should
    see the actual definition of `person_t`, which, based on what we learned about
    encapsulation, should be private and not visible to any other class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这意味着什么呢？这意味着，如果你打算使用嵌套结构变量来实现继承，`student_t`结构应该看到`person_t`的实际定义，根据我们关于封装所学的知识，它应该是私有的，并且对任何其他类不可见。
- en: 'Therefore, you have two approaches for implementing the inheritance relationship:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你有两种实现继承关系的方法：
- en: Make it so that the child class has access to the private implementation (actual
    definition) of the base class.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让子类能够访问基类的私有实现（实际定义）。
- en: Make it so that the child class only has access to the public interface of the base
    class.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让子类只能访问基类的公共接口。
- en: The first approach for having inheritance in C
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C语言中实现继承的第一种方法
- en: We'll demonstrate the first approach in the following example, *example 8.2*,
    and the second approach in *example 8.3*, which will come up in the next section.
    Both of them represent the same classes, `Student` and `Person`, with some behavior
    functions, having some objects playing in a simple scenario in the `main` function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下示例中演示第一种方法，即*示例 8.2*，第二种方法将在下一节中的*示例 8.3*中展示。它们都代表了相同的类，`Student`和`Person`，具有一些行为函数，在`main`函数中的一些对象在一个简单场景中发挥作用。
- en: 'We''ll start with *example 8.2*, in which the `Student` class needs to have
    access to the actual private definition of the `Person` class''s attribute structure.
    The following code boxes present the headers and the sources for the `Student`
    and `Person` classes together with the `main` function. Let''s start with the
    header file declaring the `Person` class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从*示例 8.2*开始，其中`Student`类需要访问`Person`类属性结构的实际私有定义。以下代码框展示了`Student`和`Person`类的头部文件和源代码，以及`main`函数。让我们从声明`Person`类的头部文件开始：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Code Box 8-5 [ExtremeC_examples_chapter8_2_person.h]: Example 8.2, the public
    interface of the Person class'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 8-5 [ExtremeC_examples_chapter8_2_person.h]: 示例 8.2，`Person`类的公共接口'
- en: 'Look at the constructor function in *Code Box 8-5*. It accepts all the values
    required for creating a `person` object: `first_name`, `second_name`, and `birth_year`.
    As you see, the attribute structure `person_t` is incomplete, hence the `Student`
    class cannot use the preceding header file for establishing an inheritance relationship,
    similar to what we demonstrated in the previous section.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下*代码框 8-5*中的构造函数。它接受创建`person`对象所需的所有值：`first_name`、`second_name`和`birth_year`。正如你所看到的，属性结构`person_t`是不完整的，因此`Student`类不能使用前面章节中展示的头部文件来建立继承关系。
- en: On the other hand, the preceding header file must not contain the actual definition
    of the attribute structure `person_t`, since the preceding header file is going
    to be used by other parts of the code which should not know anything about the
    `Person` internals. So, what should we do? We want a certain part of the logic
    to know about a structure definition that other parts of the code must not know
    about. That's where *private header files* jump in.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，前面的头部文件不应该包含属性结构`person_t`的实际定义，因为前面的头部文件将被代码的其他部分使用，这些部分不应该了解`Person`的内部情况。那么我们应该怎么做呢？我们希望逻辑的一部分了解结构定义，而代码的其他部分不应该了解这个定义。这就是*私有头部文件*介入的地方。
- en: 'A private header file is an ordinary header file that is supposed to be included
    and used by a certain part of code or a certain class that actually needs it.
    Regarding *example 8.2*, the actual definition of `person_t` should be part of
    a private header. In the following code box, you will see an example of a private
    header file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 私有头文件是一个普通头文件，它应该被包含并用于代码的某个部分或某个实际需要它的类。关于 *示例 8.2*，`person_t` 的实际定义应该是私有头文件的一部分。在下面的代码框中，您将看到一个私有头文件的示例：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Code Box 8-6 [ExtremeC_examples_chapter8_2_person_p.h]: The private header
    file which contains the actual definition of person_t'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 8-6 [ExtremeC_示例_第8章_2_person_p.h]: 包含 `person_t` 实际定义的私有头文件'
- en: 'As you see, it only contains the definition of the `person_t` structure and
    nothing more than that. This is the part of the `Person` class which should stay
    private, but it needs to become public to the `Student` class. We are going to
    need this definition for defining the `student_t` attribute structure. The next
    code box demonstrates the private implementation of the `Person` class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，它只包含 `person_t` 结构的定义，没有其他内容。这是 `Person` 类应该保持私有的部分，但它需要成为 `Student` 类的公共部分。我们将需要这个定义来定义
    `student_t` 属性结构。下一个代码框演示了 `Person` 类的私有实现：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Code Box 8-7 [ExtremeC_examples_chapter8_2_person.c]: The definition of the
    Person class'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 8-7 [ExtremeC_示例_第8章_2_person.c]: Person 类的定义'
- en: 'There is nothing special about the definition of the `Person` class and it
    is like all previous examples. The following code box shows the public interface
    of the `Student` class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person` 类的定义没有特别之处，它和所有之前的示例类似。下面的代码框显示了 `Student` 类的公共接口：'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Code Box 8-8 [ExtremeC_examples_chapter8_2_student.h]: The public interface
    of the Student class'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 8-8 [ExtremeC_示例_第8章_2_student.h]: Student 类的公共接口'
- en: As you can see, the constructor of the class accepts similar arguments to the
    `Person` class's constructor. That's because a `student` object actually contains
    a `person` object and it needs those values for populating its composed `person`
    object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，类的构造函数接受与 `Person` 类构造函数相似的参数。这是因为 `student` 对象实际上包含一个 `person` 对象，并且它需要这些值来填充其组成的
    `person` 对象。
- en: This implies that the `student` constructor needs to set the attributes for
    the `person` part of the `student`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `student` 构造函数需要设置 `student` 的 `person` 部分的属性。
- en: Note that we have only two additional behavior functions as part of the `Student`
    class, and that's because we can use the `Person` class's behavior functions for
    `student` objects as well.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们作为 `Student` 类的一部分只添加了两个额外的行为函数，这是因为我们可以使用 `Person` 类的行为函数来处理 `student`
    对象。
- en: 'The next code box contains the private implementation of the `Student` class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码框包含了 `Student` 类的私有实现：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Code Box 8-9 [ExtremeC_examples_chapter8_2_student.c]: The private definition
    of the Student class'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 8-9 [ExtremeC_示例_第8章_2_student.c]: Student 类的私有定义'
- en: The preceding code box contains the most important code regarding the inheritance
    relationship. Firstly, we needed to include the private header of the `Person`
    class because as part of defining `student_t`, we want to have the first field
    from the `person_t` type. And, since that field is an actual variable and not
    a pointer, it requires that we have `person_t` already defined. Note that this
    variable must be the *first field* in the structure. Otherwise, we lose the possibility
    of using the `Person` class's behavior functions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码框包含了关于继承关系最重要的代码。首先，我们需要包含 `Person` 类的私有头文件，因为作为定义 `student_t` 的一部分，我们希望有
    `person_t` 类型的第一个字段。而且，由于该字段是一个实际变量而不是指针，这就要求我们已经有 `person_t` 定义。请注意，这个变量必须是结构的
    *第一个字段*。否则，我们将失去使用 `Person` 类的行为函数的可能性。
- en: Again, in the preceding code box, as part of the `Student` class's constructor,
    we call the parent's constructor to initialize the attributes of the parent (composed)
    object. Look at how we cast the `student_t` pointer to a `person_t` pointer when
    passing it to the `person_ctor` function. This is possible just because the `person`
    field is the first member of `student_t`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在前面的代码框中，作为 `Student` 类构造函数的一部分，我们调用父构造函数来初始化父（组合）对象的属性。看看我们如何将 `student_t`
    指针转换为 `person_t` 指针，当传递给 `person_ctor` 函数时。这仅仅是因为 `person` 字段是 `student_t` 的第一个成员。
- en: 'Similarly, as part of the `Student` class''s destructor, we called the parent''s
    destructor. This destruction should happen first at the child level and then the
    parent level, in the opposite order of construction. The next code box contains
    *example 8.2*''s main scenario, which is going to use the `Student` class and
    create an object of type `Student`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，作为 `Student` 类析构函数的一部分，我们调用了父类的析构函数。这种销毁应该首先在子级发生，然后在父级发生，与构建的顺序相反。下一个代码框包含
    *示例 8.2* 的主场景，它将使用 `Student` 类并创建一个 `Student` 类型的对象：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Code Box 8-10 [ExtremeC_examples_chapter8_2_main.c]: The main scenario of example
    8.2'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 8-10 [ExtremeC_examples_chapter8_2_main.c]: 示例 8.2 的主场景'
- en: As you see in the main scenario, we have included the public interfaces of both
    the `Person` and `Student` classes (not the private header file), but we have
    only created one `student` object. As you can see, the `student` object has inherited
    all attributes from its internal `person` object, and they can be read via the
    `Person` class's behavior functions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在主场景中看到的那样，我们包含了 `Person` 和 `Student` 类的公共接口（不是私有头文件），但我们只创建了一个 `student`
    对象。正如你所看到的，`student` 对象从其内部的 `person` 对象继承了所有属性，并且可以通过 `Person` 类的行为函数来读取。
- en: 'The following shell box shows how to compile and run *example 8.2*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 Shell 框展示了如何编译和运行 *示例 8.2*：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Shell Box 8-2: Building and running example 8.2'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 8-2：构建和运行示例 8.2
- en: The following example, *example 8.3*, will address the second approach to implementing
    inheritance relationships in C. The output should be very similar to *example
    8.2*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例，*示例 8.3*，将介绍在 C 语言中实现继承关系的第二种方法。输出应该与 *示例 8.2* 非常相似。
- en: The second approach to inheritance in C
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C 语言中的继承的第二种方法
- en: Using the first approach, we kept a structure variable as the first field in
    the child's attribute structure. Now, using the second approach, we'll keep a
    pointer to the parent's structure variable. This way, the child class can be independent
    of the implementation of the parent class, which is a good thing, considering
    information-hiding concerns.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一种方法，我们将结构变量作为子属性结构中的第一个字段。现在，使用第二种方法，我们将保留对父结构变量的指针。这样，子类就可以独立于父类的实现，这在考虑信息隐藏问题时是个好事。
- en: We gain some advantages, and we lose some by choosing the second approach. After
    demonstrating *example 8.3* we will conduct a comparison between the two approaches,
    and you will see the advantages and disadvantages of using each of these techniques.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择第二种方法，我们获得了一些优势，也失去了一些。在演示 *示例 8.3* 之后，我们将对两种方法进行比较，你将看到使用这些技术各自的优缺点。
- en: '*Example 8.3*, below, is remarkably similar to *example 8.2*, especially in
    terms of the output and the final results. However, the main difference is that
    as part of this example, the `Student` class only relies on the public interface
    of the `Person` class, and not its private definition. This is great because it
    decouples the classes and allows us to easily change the implementation of the
    parent class without altering the implementation of the child class.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 *示例 8.3* 与 *示例 8.2* 非常相似，尤其是在输出和最终结果方面。然而，主要区别在于，在这个示例中，`Student` 类只依赖于
    `Person` 类的公共接口，而不是其私有定义。这很好，因为它解耦了类，使我们能够轻松地更改父类的实现，而不会更改子类的实现。
- en: In the preceding example, the `Student` class didn't strictly violate information-hiding
    principles, but it could have done that because it had access to the actual definition
    of `person_t` and its fields. As a result, it could read or modify the fields
    without using `Person`'s behavior functions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`Student` 类并没有严格违反信息隐藏原则，但它可以这样做，因为它可以访问 `person_t` 的实际定义及其字段。因此，它可以读取或修改字段，而无需使用
    `Person` 的行为函数。
- en: 'As noted, *example 8.3* is remarkably similar to *example 8.2*, but it has
    some fundamental differences. The `Person` class has the same public interface
    as part of the new example. But this is not true regarding the `Student` class
    and its public interface has to be changed. The following code box shows the `Student`
    class''s new public interface:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，*示例 8.3* 与 *示例 8.2* 非常相似，但有一些基本的不同之处。`Person` 类在新示例中具有相同的公共接口。但这一点并不适用于
    `Student` 类，其公共接口需要更改。下面的代码框展示了 `Student` 类的新公共接口：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Code Box 8-11 [ExtremeC_examples_chapter8_3_student.h]: The new public interface
    of the Student class'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 8-11 [ExtremeC_examples_chapter8_3_student.h]: 学生类的新公共接口'
- en: For reasons you will realize shortly, the `Student` class has to repeat all
    the behavior functions declared as part of the `Person` class. That's because
    of the fact that we can no longer cast a `student_t` pointer to a `person_t` pointer.
    In other words, upcasting doesn't work anymore regarding `Student` and `Person`
    pointers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你很快就会意识到的原因，`Student` 类必须重复所有作为 `Person` 类一部分声明的行为函数。这是因为我们不能再将 `student_t`
    指针转换为 `person_t` 指针。换句话说，关于 `Student` 和 `Person` 指针，向上转换不再起作用。
- en: 'While the public interface of the `Person` class is not changed from *example
    8.2*, its implementation has changed. The following code box demonstrates the
    implementation of the `Person` class as part of *example 8.3*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Person` 类的公共接口与 *示例 8.2* 中没有变化，但其实现已经改变。以下代码框展示了 *示例 8.3* 中 `Person` 类的实现：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code Box 8-12 [ExtremeC_examples_chapter8_3_person.c]: The new implementation
    of the Person class'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 8-12 [ExtremeC_examples_chapter8_3_person.c]：`Person` 类的新实现
- en: As you see, the private definition of `person_t` is placed inside the source
    file and we are not using a private header anymore. This means that we are not
    going to share the definition with other classes such as the `Student` class at
    all. We want to conduct a complete encapsulation of the `Person` class and hide
    all its implementation details.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`person_t` 的私有定义放置在源文件中，我们不再使用私有头文件。这意味着我们根本不会与其他类，如 `Student` 类共享定义。我们希望对
    `Person` 类进行完全封装，并隐藏其所有实现细节。
- en: 'The following is the private implementation of the `Student` class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的内容是 `Student` 类的私有实现：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Code Box 8-13 [ExtremeC_examples_chapter8_3_student.c]: The new implementation
    of the Student class'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 8-13 [ExtremeC_examples_chapter8_3_student.c]：`Student` 类的新实现
- en: As demonstrated in the preceding code box, we've used the `Person` class's public
    interface by including its header file. In addition, as part of the definition
    of `student_t`, we've added a pointer field, which points to the parent `Person`
    object. This should remind you of the implementation of a composition relationship
    done as part of the previous chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个代码框所示，我们通过包含其头文件使用了 `Person` 类的公共接口。此外，作为 `student_t` 定义的一部分，我们添加了一个指针字段，该字段指向父
    `Person` 对象。这应该会让你想起上一章中作为组合关系实现的部分。
- en: Note that there is no need for this pointer field to be the first item in the
    attribute structure. This is in contrast to what we saw in the first approach.
    The pointers of the types `student_t` and `person_t` are no longer interchangeable,
    and they are pointing to different addresses in the memory that are not necessarily
    adjacent. This is again in contrast to what we did in the previous approach.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个指针字段不需要作为属性结构中的第一个项目。这与我们在第一种方法中看到的情况不同。`student_t` 和 `person_t` 类型的指针不再可以互换，它们指向内存中的不同地址，这些地址不一定相邻。这又与我们在之前的方法中做的不一样。
- en: Note that, as part of the `Student` class's constructor, we instantiate the
    parent object. Then, we construct it by calling the `Person` class's constructor
    and passing the required parameters. That's the same for destructors as well and
    we destruct the parent object lastly in the `Student` class's destructor.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，作为 `Student` 类构造函数的一部分，我们实例化了父对象。然后，我们通过调用 `Person` 类的构造函数并传递所需的参数来构建它。这与析构函数相同，我们最后在
    `Student` 类的析构函数中销毁父对象。
- en: Since we cannot use the behaviors of the `Person` class to read the inherited
    attributes, the `Student` class is required to offer its set of behavior functions
    to expose those inherited and private attributes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法使用 `Person` 类的行为来读取继承的属性，`Student` 类需要提供其行为函数集来暴露那些继承的私有属性。
- en: In other words, the `Student` class has to provide some wrapper functions to
    expose the private attributes of its inner parent `person` object. Note that the
    `Student` object itself doesn't know anything about the private attributes of
    the `Person` object, and this is in contrast with what we saw in the first approach.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`Student` 类必须提供一些包装函数来暴露其内部父 `person` 对象的私有属性。请注意，`Student` 对象本身对 `Person`
    对象的私有属性一无所知，这与我们在第一种方法中看到的情况形成对比。
- en: 'The main scenario is also very similar to how it was as part of *example 8.2*.
    The following code box demonstrates that:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 主要场景也与 *示例 8.2* 中的情况非常相似。以下代码框展示了这一点：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Code Box 8-14 [ExtremeC_examples_chapter8_3_main.c]: The main scenario of example
    8.3'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 8-14 [ExtremeC_examples_chapter8_3_main.c]：示例 8.3 的主要场景
- en: In comparison to the main function in *example 8.2*, we have not included the
    public interface of the `Person` class. We have also needed to use the `Student`
    class's behavior functions because the `student_t` and `person_t` pointers are
    not interchangeable anymore.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与*示例 8.2*中的主函数相比，我们没有包含`Person`类的公共接口。我们还必须使用`Student`类的行为函数，因为`student_t`和`person_t`指针不再可以互换。
- en: 'The following shell box demonstrates how to compile and run *example 8.3*.
    As you might have guessed, the outputs are identical:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell框演示了如何编译和运行*示例 8.3*。正如你可能猜到的，输出是相同的：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Shell Box 8-3: Building and running example 8.3'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 8-3：构建和运行示例 8.3
- en: In the following section, we're going to compare the aforementioned approaches
    to implement an inheritance relationship in C.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将比较上述方法来实现C语言中的继承关系。
- en: Comparison of two approaches
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两种方法的比较
- en: 'Now that you''ve seen two different approaches that we can take to implement
    inheritance in C, we can compare them. The following bullet points outline the
    similarities and differences between the two approaches:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了我们可以采取的两种不同的方法来实现C语言中的继承，我们可以比较它们。以下要点概述了两种方法之间的相似之处和不同之处：
- en: Both approaches intrinsically show composition relationships.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两种方法本质上都显示了组合关系。
- en: The first approach keeps a structure variable in the child's attribute structure
    and relies on having access to the private implementation of the parent class.
    However, the second approach keeps a structure pointer from the incomplete type
    of the parent's attribute structure, and hence, it doesn't rely on the private
    implementation of the parent class.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法在子类的属性结构中保留一个结构变量，并依赖于对父类私有实现的访问。然而，第二种方法保留指向父类属性结构不完整类型的结构指针，因此它不依赖于父类的私有实现。
- en: In the first approach, the parent and child types are strongly dependent. In
    the second approach, the classes are independent of each other, and everything
    inside the parent implementation is hidden from the child.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种方法中，父类和子类之间有很强的依赖性。在第二种方法中，类之间相互独立，父类实现中的所有内容对子类都是隐藏的。
- en: In the first approach, you can have only one parent. In other words, it is a way
    to implement *single inheritance* in C. However, in the second approach, you can
    have as many parents as you like, thereby demonstrating the concept of *multiple
    inheritance*.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种方法中，你只能有一个父类。换句话说，这是一种在C语言中实现*单继承*的方法。然而，在第二种方法中，你可以有任意多的父类，从而演示了*多继承*的概念。
- en: In the first approach, the parent's structure variable must be the first field
    in the attribute structure of the child class, but in the second approach, the
    pointers to parent objects can be put anywhere in the structure.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种方法中，父类的结构变量必须是子类属性结构中的第一个字段，但在第二种方法中，指向父对象指针可以放在结构中的任何位置。
- en: In the first approach, there were no two separate parent and child objects.
    The parent object was included in the child object, and a pointer to the child
    object was actually a pointer to the parent object.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种方法中，没有两个独立的父类和子类对象。父类对象包含在子类对象中，指向子类对象的指针实际上是指向父类对象的指针。
- en: In the first approach, we could use the behavior functions of the parent class,
    but in the second approach, we needed to forward the parent's behavior functions
    through new behavior functions in the child class.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种方法中，我们可以使用父类的行为函数，但在第二种方法中，我们需要通过子类中的新行为函数来转发父类的行为函数。
- en: So far, we have only talked about inheritance itself and we haven't gone through
    its usages. One of the most important usages of inheritance is to have *polymorphism*
    in your object model. In the following section, we're going to talk about polymorphism
    and how it can be implemented in C.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了继承本身，还没有讨论其用法。继承最重要的用法之一是在你的对象模型中实现*多态性*。在下一节中，我们将讨论多态性以及如何在C语言中实现它。
- en: Polymorphism
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性
- en: Polymorphism is not really a relationship between two classes. It is mostly
    a technique for keeping the same code while having different behaviors. It allows
    us to extend code or add functionalities without having to recompile the whole
    code base.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性实际上并不是两个类之间的关系。它主要是一种在保持相同代码的同时实现不同行为的技术。它允许我们在不重新编译整个代码库的情况下扩展代码或添加功能。
- en: In this section, we try to cover what polymorphism is and how we can have it
    in C. This also gives us a better view of how modern programming languages such
    as C++ implement polymorphism. We'll start by defining polymorphism.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们试图解释多态是什么以及我们如何在C语言中实现它。这也让我们更好地了解现代编程语言（如C++）是如何实现多态的。我们将从定义多态开始。
- en: What is polymorphism?
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态是什么？
- en: Polymorphism simply means to have different behaviors by just using the same
    public interface (or set of behavior functions).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 多态简单地说就是通过使用相同的公共接口（或行为函数集）来拥有不同的行为。
- en: 'Suppose that we have two classes, `Cat` and `Duck`, and they each have a behavior
    function, `sound`, which makes them print their specific sound. Explaining polymorphism
    is not an easy task to do and we''ll try to take a top-down approach in explaining
    it. First, we''ll try to give you an idea of how polymorphic code looks and how
    it behaves, and then we''ll dive into implementing it in C. Once you get the idea,
    it will be easier to move into the implementation. In the following code boxes,
    we first create some objects, and then we see how we would expect a polymorphic
    function to behave if polymorphism was in place. First, let''s create three objects.
    We have already assumed that both the `Cat` and `Duck` classes are children of
    the `Animal` class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个类，`Cat`和`Duck`，它们各自有一个行为函数`sound`，这使得它们打印出它们特定的声音。解释多态不是一个容易的任务，我们将尝试自顶向下的方法来解释它。首先，我们将尝试给你一个多态代码看起来如何以及它如何表现的概念，然后我们将深入到在C语言中实现它。一旦你有了这个概念，进入实现就会更容易。在以下代码框中，我们首先创建一些对象，然后看看如果多态存在，我们期望多态函数会如何表现。首先，让我们创建三个对象。我们已经假设`Cat`和`Duck`类都是`Animal`类的子类：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Code Box 8-15: Creating three objects of types Animal, Cat, and Duck'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 8-15：创建Animal、Cat和Duck三种类型的三个对象
- en: '*Without* polymorphism, we would have called the `sound` behavior function
    for each object as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有**多态的情况下，我们会像下面这样为每个对象调用`sound`行为函数：'
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Code Box 8-16: Calling the sound behavior function on the created objects'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 8-16：在创建的对象上调用发声行为函数
- en: 'And the output would be as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Shell Box 8-4: The output of the function calls'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 8-4：函数调用的输出
- en: 'The preceding code box is not demonstrating polymorphism because it uses different
    functions, `cat_sound` and `duck_sound`, to call specific behaviors from the `Cat`
    and `Duck` objects. However, the following code box shows how we expect a polymorphic
    function to behave. The following code box contains a perfect example of polymorphism:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码框没有展示多态，因为它使用了不同的函数`cat_sound`和`duck_sound`来从`Cat`和`Duck`对象中调用特定的行为。然而，下面的代码框展示了我们期望多态函数如何表现。下面的代码框包含了一个完美的多态示例：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Code Box 8-17: Calling the same sound behavior function on all three objects'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 8-17：在所有三个对象上调用相同的发声行为函数
- en: 'Despite calling the same function three times, we expect to see different behaviors.
    It seems that passing different object pointers changes the actual behavior behind
    `animal_sound`. The following shell box would be the output of *Code Box 8-17*
    if `animal_sound` was polymorphic:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管调用了三次相同的函数，但我们期望看到不同的行为。看起来传递不同的对象指针会改变`animal_sound`背后的实际行为。以下Shell框将显示如果`animal_sound`是多态的，则*代码框
    8-17*的输出：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Shell Box 8-5: The output of the function calls'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 8-5：函数调用的输出
- en: As you see in *Code Box 8-17*, we have used the same function, `animal_sound`,
    but with different pointers, and as a result, different functions have been invoked
    behind the scenes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在*代码框 8-17*中看到的，我们使用了相同的函数`animal_sound`，但是使用了不同的指针，结果在幕后调用了不同的函数。
- en: '**CAUTION**:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Please don't move forward if you're having trouble understanding the preceding
    code; if you are, please recap the previous section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在理解前面的代码时遇到困难，请不要继续前进；如果你遇到了，请回顾前面的章节。
- en: 'The preceding polymorphic code implies that there should be an inheritance
    relationship between the `Cat` and `Duck` classes with a third class, `Animal`,
    because we want to be able to cast the `duck_t` and `cat_t` pointers to an `animal_t`
    pointer. This also implies something else: we have to use the first approach of
    implementing inheritance in C in order to benefit from the polymorphism mechanism
    we introduced before.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的多态代码意味着`Cat`类和`Duck`类之间应该存在一个继承关系，并且有一个第三类`Animal`，因为我们希望能够将`duck_t`和`cat_t`指针转换为`animal_t`指针。这也意味着另一件事：我们必须使用C语言中实现继承的第一种方法，以便从我们之前引入的多态机制中受益。
- en: 'You may recall that in the first approach to implementing inheritance, the
    child class had access to the private implementation of the parent class, and
    here a structure variable from the `animal_t` type should have been put as the
    first field in the definitions of the `duck_t` and `cat_t` attribute structures.
    The following code shows the relationship between these three classes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，在实现继承的第一种方法中，子类可以访问父类的私有实现，在这里，`animal_t`类型的结构变量应该被放在`duck_t`和`cat_t`属性结构定义中的第一个字段。以下代码显示了这三个类之间的关系：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Code Box 8-18: The definitions of the attribute structures of classes Animal,
    Cat, and Duck'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框8-18：Animal、Cat和Duck类属性结构的定义
- en: With this setup, we can cast the `duck_t` and `cat_t` pointers to the `animal_t`
    pointers, and then we can use the same behavior functions for both child classes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设置下，我们可以将`duck_t`和`cat_t`指针转换为`animal_t`指针，然后我们可以为这两个子类使用相同的行为函数。
- en: So far, we have shown how a polymorphic function is expected to behave and how
    an inheritance relationship should be defined between the classes. What we haven't
    shown is how this polymorphic behavior is fulfilled. In other words, we haven't
    talked about the actual mechanism behind the polymorphism.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了多态函数应该如何表现以及如何在类之间定义继承关系。我们没有展示的是如何实现这种多态行为。换句话说，我们还没有讨论多态背后的实际机制。
- en: 'Suppose that the behavior function `animal_sound` is defined as it can be seen
    in code box 8-19\. No matter the pointer you send inside as the argument, we will
    have always one behavior and the function calls won''t be polymorphic without
    the underlying mechanism. The mechanism will be explained as part of *example
    8.4* which you will see shortly:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设行为函数`animal_sound`的定义如代码框8-19所示。无论你发送什么指针作为参数，我们都会有相同的行为，并且没有底层机制，函数调用不会是多态的。这个机制将在*示例8.4*中作为一部分进行解释，你很快就会看到：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Code Box 8-19: The function animal_sound is not polymorphic yet!'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框8-19：`animal_sound`函数还不是多态的！
- en: 'As you see next, calling the behavior function `animal_sound` with various
    pointers won''t change the logic of the behavior function; in other words, it
    is not polymorphic. We will make this function polymorphic as part of the next
    example, *example 8.4*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你接下来看到的，使用各种指针调用行为函数`animal_sound`不会改变行为函数的逻辑；换句话说，它不是多态的。我们将在下一个示例，*示例8.4*中使这个函数成为多态。
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Shell Box 8-6: The output of the functional calls in Code Box 8-19'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Shell框8-6：代码框8-19中功能调用的输出
- en: So, what is the underlying mechanism that enables polymorphic behavior functions?
    We answer that question in the upcoming sections, but before that we need to know
    why we want to have polymorphism in the first place.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，使多态行为函数得以实现的底层机制是什么？我们将在接下来的章节中回答这个问题，但在那之前，我们需要知道为什么我们首先想要多态。
- en: Why do we need polymorphism?
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们为什么需要多态？
- en: Before talking further about the way in which we're going to implement polymorphism
    in C, we should spend some time talking about the reasons behind the need for
    polymorphism. The main reason why polymorphism is needed is that we want to keep
    a piece of code "as is," even when using it with various subtypes of a base type.
    You are going to see some demonstration of this shortly in the examples.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步讨论我们在C语言中实现多态的方法之前，我们应该花一些时间来谈谈多态需求背后的原因。多态之所以需要，主要原因是我们要保持一段代码“原样”，即使在使用它时与基类型的各种子类型一起使用。你将在接下来的示例中看到一些关于此的演示。
- en: We don't want to modify the current logic very often when we add new subtypes
    to the system, or when the behavior of one subtype is being changed. It's just
    not realistic to have zero changes when a new feature is added – there will always
    be some changes – but using polymorphism, we can significantly reduce the number
    of changes that are needed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向系统中添加新的子类型或改变一个子类型的行为时，我们不想经常修改当前的逻辑。当添加新功能时，完全没有变化是不现实的——总会有一些变化——但使用多态，我们可以显著减少所需更改的数量。
- en: Another motivation for having polymorphism is due to the concept of *abstraction*.
    When we have abstract types (or classes), they usually have some vague or unimplemented
    behavior functions that need to be *overridden* in child classes and polymorphism
    is the key way to do this.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 多态存在的另一个动机是由于*抽象*的概念。当我们有抽象类型（或类）时，它们通常有一些模糊或未实现的行为函数，这些函数需要在子类中*重写*，而多态是实现这一点的关键方式。
- en: Since we want to use abstract types to write our logic, we need a way to call
    the proper implementation when dealing with pointers of very abstract types. This
    is another place where polymorphism comes in. No matter what the language is,
    we need a way to have polymorphic behaviors, otherwise the cost of maintaining
    a big project can grow quickly, for instance when we are going to add a new subtype
    to our code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想使用抽象类型来编写我们的逻辑，我们需要一种在处理非常抽象类型的指针时调用适当实现的方法。这又是多态性发挥作用的地方。无论什么语言，我们都需要一种实现多态行为的方法，否则维护大型项目的成本可能会迅速增加，例如当我们准备向代码中添加新的子类型时。
- en: Now that we've established the importance of polymorphism, it's time to explain
    how we can have it in C.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确立了多态性的重要性，现在是时候解释如何在C语言中实现它了。
- en: How to have polymorphic behavior in C
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在C语言中实现多态行为
- en: If we want to have polymorphism in C, we need to use the first approach we explored
    to implementing inheritance in C. To achieve polymorphic behavior, we can utilize
    *function pointers*. However, this time, these function pointers need to be kept
    as some fields in the attribute structure. Let's implement the animal sound example
    to illustrate this.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在C语言中实现多态性，我们需要使用我们之前探索的C语言实现继承的第一种方法。为了实现多态行为，我们可以利用函数指针。然而，这次，这些函数指针需要作为属性结构中的某些字段来保留。让我们通过实现动物声音示例来说明这一点。
- en: We have three classes, `Animal`, `Cat`, and `Duck`, and `Cat` and `Duck` are
    subtypes of `Animal`. Each class has one header and one source. The `Animal` class
    has an extra private header file that contains the actual definition of its attribute
    structure. This private header is required since we are taking the first approach
    to implement inheritance. The private header is going to be used by the `Cat`
    and `Duck` classes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个类，`Animal`、`Cat`和`Duck`，其中`Cat`和`Duck`是`Animal`的子类型。每个类都有一个头文件和一个源文件。`Animal`类有一个额外的私有头文件，其中包含其实际的属性结构定义。由于我们正在采用第一种方法实现继承，这个私有头文件是必需的。私有头文件将被`Cat`和`Duck`类使用。
- en: 'The following code box shows the public interface of the `Animal` class:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框展示了`Animal`类的公共接口：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Code Box 8-20 [ExtremeC_examples_chapter8_4_animal.h]: The public interface
    of the Animal class'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框8-20 [ExtremeC_examples_chapter8_4_animal.h]：`Animal`类的公共接口
- en: The `Animal` class has two behavior functions. The `animal_sound` function is
    supposed to be polymorphic and can be overridden by the child classes, while the
    other behavior function, `animal_get_name`, is not polymorphic, and children cannot
    override it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Animal`类有两个行为函数。`animal_sound`函数应该是多态的，可以被子类覆盖，而另一个行为函数`animal_get_name`不是多态的，子类不能覆盖它。'
- en: 'The following is the private definition of the `animal_t` attribute structure:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`animal_t`属性结构的私有定义：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Code Box 8-21 [ExtremeC_examples_chapter8_4_animal_p.h]: The private header
    of the Animal class'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框8-21 [ExtremeC_examples_chapter8_4_animal_p.h]：`Animal`类的私有头文件
- en: In polymorphism, every child class can provide its own version of the `animal_sound`
    function. In other words, every child class can override the function inherited
    from its parent class. Therefore, we need to have a different function for each
    child class that wants to override it. This means, if the child class has overridden
    the `animal_sound`, its own overridden function should be called.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在多态性中，每个子类都可以提供自己的`animal_sound`函数版本。换句话说，每个子类都可以覆盖从其父类继承的函数。因此，我们需要为每个想要覆盖它的子类提供一个不同的函数。这意味着，如果子类覆盖了`animal_sound`，则应该调用其覆盖的函数。
- en: That's why we are using function pointers here. Each instance of `animal_t`
    will have a function pointer dedicated to the behavior `animal_sound`, and that
    pointer is pointing to the actual definition of the polymorphic function inside
    the class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，我们在这里使用函数指针。每个`animal_t`实例都将有一个专用于行为`animal_sound`的函数指针，而这个指针指向类内部的多态函数的实际定义。
- en: For each polymorphic behavior function, we have a dedicated function pointer.
    Here, you will see how we use this function pointer to do the correct function
    call in each subclass. In other words, we show how the polymorphism actually works.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个多态行为函数，我们都有一个专用的函数指针。在这里，您将看到我们如何使用这个函数指针在各个子类中进行正确的函数调用。换句话说，我们展示了多态性实际上是如何工作的。
- en: 'The following code box shows the definition of the `Animal` class:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框展示了`Animal`类的定义：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Code Box 8-22 [ExtremeC_examples_chapter8_4_animal.c]: The definition of the
    Animal class'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框8-22 [ExtremeC_examples_chapter8_4_animal.c]：`Animal`类的定义
- en: The actual polymorphic behavior is happening in *Code Box 8-22*, inside the
    function `animal_sound`. The private function `__animal_sound` is supposed to
    be the default behavior of the `animal_sound` function when the subclasses decide
    not to override it. You will see in the next chapter that polymorphic behavior
    functions have a default definition which will get inherited and used if the subclass
    doesn't provide the overridden version.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的多态行为发生在*代码框 8-22*中，在`animal_sound`函数内部。私有函数`__animal_sound`是当子类决定不覆盖它时`animal_sound`函数的默认行为。你将在下一章中看到，多态行为函数有一个默认定义，如果子类没有提供覆盖版本，它将被继承并使用。
- en: Moving on, inside the constructor `animal_ctor`, we store the address of `__animal_sound`
    into the `sound_func` field of the `animal` object. Remember that `sound_func`
    is a function pointer. In this setup, every child object inherits this function
    pointer, which points to the default definition `__animal_sound`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在构造函数`animal_ctor`中，我们将`__animal_sound`的地址存储到`animal`对象的`sound_func`字段中。记住，`sound_func`是一个函数指针。在这个设置中，每个子对象都继承了这个函数指针，它指向默认定义`__animal_sound`。
- en: And the final step, inside the behavior function `animal_sound`, we just call
    the function that is being pointed to by the `sound_func` field. Again, `sound_func`
    is the function pointer field pointing to the actual definition of the sound behavior
    which in the preceding case is `__animal_sound`. Note that the `animal_sound`
    function behaves more like a relay to the actual behavior function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步，在行为函数`animal_sound`内部，我们只是调用由`sound_func`字段指向的函数。再次强调，`sound_func`是函数指针字段，指向实际的声音行为定义，在前面的例子中是`__animal_sound`。请注意，`animal_sound`函数更像是一个将实际行为函数作为中继的行为。
- en: Using this setup, if the `sound_func` field was pointing to another function,
    then that function would have been called if `animal_sound` was invoked. That's
    the trick we are going to use in the `Cat` and `Duck` classes to override the
    default definition of the `sound` behavior.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，如果`sound_func`字段指向另一个函数，那么在调用`animal_sound`时，就会调用那个函数。这就是我们在`Cat`和`Duck`类中用来覆盖默认`sound`行为定义的技巧。
- en: 'Now, it''s time to show the `Cat` and `Duck` classes. The following code boxes
    will show the `Cat` class''s public interface and private implementation. First,
    we show the `Cat` class''s public interface:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候展示`Cat`和`Duck`类了。以下代码框将展示`Cat`类的公共接口和私有实现。首先，我们展示`Cat`类的公共接口：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Code Box 8-23 [ExtremeC_examples_chapter8_4_cat.h]: The public interface of
    the Cat class'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 8-23 [ExtremeC_examples_chapter8_4_cat.h]: `Cat`类的公共接口'
- en: As you will see shortly, it will inherit the `sound` behavior from its parent
    class, the `Animal` class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如你很快就会看到的，它将从其父类`Animal`类继承`sound`行为。
- en: 'The following code box shows the definition of the `Cat` class:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框展示了`Cat`类的定义：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Code Box 8-24 [ExtremeC_examples_chapter8_4_cat.c]: The private implementation
    of the Cat class'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 8-24 [ExtremeC_examples_chapter8_4_cat.c]: `Cat`类的私有实现'
- en: As you see in the previous code box, we have defined a new function for the
    cat's sound, `__cat_sound`. Then inside the constructor, we make the `sound_func`
    pointer point to this function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的代码框中所见，我们为猫的声音定义了一个新函数`__cat_sound`。然后在构造函数中，我们将`sound_func`指针指向这个函数。
- en: Now, overriding is happening, and from now on, all `cat` objects will actually
    call `__cat_sound` instead of `__animal_sound`. The same technique is used for
    the `Duck` class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，覆盖正在发生，从现在起，所有`cat`对象实际上都会调用`__cat_sound`而不是`__animal_sound`。同样的技术也用于`Duck`类。
- en: 'The following code box shows the public interface of the `Duck` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框展示了`Duck`类的公共接口：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Code Box 8-25 [ExtremeC_examples_chapter8_4_duck.h]: The public interface of
    the Duck class'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 8-25 [ExtremeC_examples_chapter8_4_duck.h]: `Duck`类的公共接口'
- en: 'As you see, that''s quite similar to the `Cat` class. Let''s bring up the private
    definition of the `Duck` class:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这与`Cat`类非常相似。让我们来看看`Duck`类的私有定义：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Code Box 8-26 [ExtremeC_examples_chapter8_4_duck.c]: The private implementation
    of the Duck class'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 8-26 [ExtremeC_examples_chapter8_4_duck.c]: `Duck`类的私有实现'
- en: As you can see, the technique has been used to override the default definition
    of the `sound` behavior. A new private behavior function, `__duck_sound`, has
    been defined that does the duck-specific sound, and the `sound_func` pointer is
    updated to point to this function. This is basically the way that polymorphism
    is introduced to C++. We will talk more about this in the next chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，该技术已被用来覆盖 `sound` 行为的默认定义。定义了一个新的私有行为函数 `__duck_sound`，它执行鸭特有的声音，并且
    `sound_func` 指针被更新以指向这个函数。这基本上是将多态引入 C++ 的方式。我们将在下一章中更多地讨论这一点。
- en: 'Finally, the following code box demonstrates the main scenario of *example
    8.4*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下代码框演示了*示例 8.4*的主要场景：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Code Box 8-27 [ExtremeC_examples_chapter8_4_main.c]: The main scenario of example
    8.4'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 8-27 [ExtremeC_examples_chapter8_4_main.c]：示例 8.4 的主要场景
- en: As you see in the preceding code box, we are only using the public interfaces
    of the `Animal`, `Cat`, and `Duck` classes. So, the `main` function doesn't know
    anything about the internal implementation of the classes. Calling the `animal_sound`
    function with passing different pointers demonstrates how a polymorphic behavior
    should work. Let's look at the output of the example.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的代码框中看到的，我们只使用了 `Animal`、`Cat` 和 `Duck` 类的公共接口。因此，`main` 函数对类的内部实现一无所知。通过传递不同的指针调用
    `animal_sound` 函数，展示了多态行为应该如何工作。让我们看看示例的输出。
- en: 'The following shell box shows how to compile and run *example 8.4*:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 框展示了如何编译和运行*示例 8.4*：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Shell Box 8-7: The compilation, execution, and output of example 8.4'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 8-7：示例 8.4 的编译、执行和输出
- en: As you can see in *example 8.4*, in class-based programming languages the behavior
    functions which we want to be polymorphic need special care and should be treated
    differently. Otherwise, a simple behavior function without the underlying mechanism
    that we discussed as part of *example 8.4* cannot be polymorphic. That's why we
    have a special name for these behavior functions, and why we use specific keywords
    to denote a function to be polymorphic in a language such as C++. These functions
    are called *virtual* functions. Virtual functions are behavior functions that
    can be overridden by child classes. Virtual functions need to be tracked by the
    compiler, and proper pointers should be placed in the corresponding objects to
    point to the actual definitions when overridden. These pointers are used at runtime
    to execute the right version of the function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在*示例 8.4*中看到的，在基于类的编程语言中，我们想要实现多态的行为函数需要特别注意，并且应该以不同的方式处理。否则，没有我们作为*示例 8.4*一部分讨论的底层机制的简单行为函数不能实现多态。这就是为什么我们为这些行为函数取了特殊名称，以及为什么我们在像
    C++ 这样的语言中使用特定的关键字来表示函数是多态的。这些函数被称为*虚函数*。虚函数是可以被子类覆盖的行为函数。虚函数需要被编译器跟踪，并且应该在相应的对象中放置适当的指针，以便在覆盖时指向实际的定义。这些指针在运行时用于执行函数的正确版本。
- en: In the next chapter, we'll see how C++ handles object-oriented relationships
    between classes. Also, we will find out how C++ implements polymorphism. We will
    also discuss *Abstraction* which is a direct result of polymorphism.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到 C++ 如何处理类之间的面向对象关系。我们还将了解 C++ 如何实现多态。我们还将讨论*抽象*，这是多态的直接结果。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we continued our exploration of topics in OOP, picking up
    from where we left off in the previous chapter. The following topics were discussed
    in this chapter:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续探索面向对象编程（OOP）中的主题，从上一章结束的地方继续。本章讨论了以下主题：
- en: We explained how inheritance works and looked at the two approaches that we
    can use to implement inheritance in C.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了继承是如何工作的，并查看了我们可以在 C 中实现继承的两种方法。
- en: The first approach allows direct access to all the private attributes of the
    parent class, but the second approach has a more conservative approach, hiding
    the private attributes of the parent class.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法允许直接访问父类的所有私有属性，但第二种方法采取了一种更为保守的方法，隐藏了父类的私有属性。
- en: We compared these approaches, and we saw that each of them can be suitable in
    some use cases.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们比较了这些方法，并看到它们中的每一个在某些用例中可能是合适的。
- en: Polymorphism was the next topic that we explored. To put it simply, it allows
    us to have different versions of the same behavior and invoke the correct behavior
    using the public API of an abstract supertype.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态是我们接下来探索的主题。简单来说，它允许我们拥有同一行为的不同版本，并使用抽象超类型的公共 API 调用正确的行为。
- en: We saw how to write polymorphic code in C and saw how function pointers contribute
    to choosing the correct version of a particular behavior at runtime.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到了如何在C语言中编写多态代码，并了解了函数指针如何有助于在运行时选择特定行为的正确版本。
- en: The next chapter will be our final chapter about object orientation. As part
    of it, we'll explore how C++ handles encapsulation, inheritance, and polymorphism.
    More than that, we will discuss the topic of abstraction and how it leads to a
    bizarre type of class which is called an *abstract class*. We cannot create objects
    from these classes!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将是关于面向对象编程的最后一章。作为其中的一部分，我们将探讨C++如何处理封装、继承和多态。不仅如此，我们还将讨论抽象这个主题，以及它如何导致一种被称为*抽象类*的奇特类型的类。我们不能从这些类中创建对象！
