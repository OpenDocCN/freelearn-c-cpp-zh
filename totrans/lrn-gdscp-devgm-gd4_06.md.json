["```cpp\n    extends Node2D\n    const MAX_HEALTH: int = 10\n    var health: int = 10\n    func add__health_points(difference: int):\n       health += difference\n       health = clamp(health, 0, MAX_HEALTH)\n    ```", "```cpp\n$HealthLabel\n```", "```cpp\n$Player/HealthLabel\n```", "```cpp\nfunc update_health_label():\n   update_health_label() function, we take the HealthLabel node and directly change its text variable. This will change whatever text the label is showing on the screen.\n\t\t\tHere, we use a new function named `str()` in `update_health_label()`. This function takes any parameter and converts it into a string. We need to do this because the `health` and `MAX_HEALTH` values, which are integers, we’ll have to convert them into a string.\n\t\t\tNow, we can use this `update_health_label()` function whenever we change the `health` value:\n\n```", "```cpp\nextends Node2D\n@onready var _health_label: Label = $HealthLabel\nfunc update_health_label():\n   HealthLabel node in a variable called _health_label. Later on, we can use this reference.\n\t\t\tThe upside is, of course, that we only have to change the path to the node at one point: the line where the reference gets stored in a variable. Another upside is that we can type-hint the variable with the type of the node. So, we are making it even safer than the previous way of referencing the node.\n\t\t\tYou’ll also notice that I use the `@onready` annotation. We call commands that start with an `@` annotation, like the one shown previously. This annotation executes that line of code when the node is ready and has entered the scene tree. This is right before the `_ready()` function of that node is called. In Godot, the `_ready()` function of each node gets called after each of its children are ready, meaning that their `_ready()` functions get called before the parent node’s `_ready()` function. We need to wait for this moment to get any nodes in the tree because otherwise, there is a possibility for them not to exist yet!\n\t\t\tAnnotations\n\t\t\tThere are more annotations. We’ll return to them when they are applicable. But it’s already good to know that all of these annotations affect how external tools will treat the script and don’t change any logic within the script itself.\n\t\t\tI advise that you always cache variables as described here because it will keep your code clean and fast.\n\t\t\tTrying out the player script\n\t\t\tTo try out what we have created so far, we can run a quick test by adding the `_ready()` function to the player script:\n\n```", "```cpp\n\n\t\t\tNow, when you run the scene, you should see that the health label says **8/10**, like so:\n\t\t\t![Figure 6.20 – The player’s health label has been updated to 8/10](img/B19358_06_20.jpg)\n\n\t\t\tFigure 6.20 – The player’s health label has been updated to 8/10\n\t\t\tAfter testing the script, remove the preceding lines again so that they don’t interfere with the rest of our coding.\n\t\t\tIn this section, we learned how to reference nodes from the scene tree within our code and how to update the values of these nodes. We also set up a basic script for tracking the health of our player. In the following section, we’ll learn about exporting variables.\n\t\t\tExporting variables to the editor\n\t\t\tWe have always defined variables within code and every time we wanted to change them, we had to change the code too. But in Godot, it is straightforward to expose variables to the editor so that we can change them without even opening the code editor. This is extremely useful when you want to test things out and tweak variables on the fly. An exported variable pops up in the **Inspector** view of that node, just like the transformation and text properties we saw in the *Manipulating nodes in the* *editor* section.\n\t\t\tImportant note\n\t\t\tAn exported variable is also useful for people who don’t know how to code, such as level designers, but still want to change the behavior of specific nodes.\n\t\t\tTo export a variable to the editor, we can use the `@export` annotation. Let’s change the line where we define the `health` variable, like so:\n\n```", "```cpp\n\n\t\t\tMake sure you save the script. Go to the 2D editor using the button at the top of the editor.\n\t\t\t![Figure 6.21 – Click 2D to go back to the 2D editor](img/B19358_06_21.jpg)\n\n\t\t\tFigure 6.21 – Click 2D to go back to the 2D editor\n\t\t\tClick on our `Player` node, and see the `health` variable in the **Inspector** view. This is our exported variable. Changing it will change the variable’s value at the start of the game, not directly in the script itself:\n\t\t\t![Figure 6.22 – The health variable as an exported variable in the Inspector view of the Player node](img/B19358_06_22.jpg)\n\n\t\t\tFigure 6.22 – The health variable as an exported variable in the Inspector view of the Player node\n\t\t\tNow, when you change the player’s health value through the `health` label in the `_ready()` function, like so:\n\n```", "```cpp\n\n\t\t\tThis will ensure that the health label is updated from the moment the `Player` node enters the scene tree.\n\t\t\tMore information\n\t\t\tIf you want to learn more about export variables, you can check out the official documentation: [https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_exports.html](https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_exports.html).\n\t\t\tNow, we start the game with the correct amount of health displayed on the health label. But there is a better way of updating this health label: using setters and getters.\n\t\t\tSetters and getters\n\t\t\tWhen you change the player’s health value through the `_ready()` function, like so:\n\n```", "```cpp\n\n\t\t\tThat is because the `update_health_label()` function is not being called when we change the value!\n\t\t\tLuckily, we can fix this. In programming, **getter** and **setter** functions exist. These functions are called when you get or set the value of a variable. With these getter or setter functions, we can execute all the logic needed to handle a new value. We can define a getter and setter for our health variable like so:\n\n```", "```cpp\n\n\t\t\tSo, the getter is defined by `get:`, followed by the code block that defines the getter logic, and the setter by `set(new_value):`, followed by its code block. `new_value` is the new value that is assigned to the variable. Within the setter, we get the opportunity to process this value if needed or set other processes in motion. In our case, we don’t want to process the new value, but we do want to update the health label.\n\t\t\tThe getter does nothing special – it just returns the health value. On the other hand, the setter clamps the new value so that it is valid and then updates the health label.\n\t\t\tWhen we get or set the `health` value, the interpreter will execute these functions first. Here’s an example:\n\n```", "```cpp\n\n\t\t\tThis also simplifies the `add_health_points()` function because we no longer have to clamp the new health value as this already gets done in the setter. So, let’s update the `add_health_points()` function to the following:\n\n```", "```cpp\n\n\t\t\tBut what is this? The project errors when we run it now!\n\t\t\t![Figure 6.23 – An error showing that the health label is non-existing](img/B19358_06_23.jpg)\n\n\t\t\tFigure 6.23 – An error showing that the health label is non-existing\n\t\t\tThe setter function gets executed before the `_health_label` reference is created. So, we must make sure that the `_health_label` is filled in before we update its text. If it isn’t, we can just return from the function:\n\n```", "```cpp\n\n\t\t\tThe `is_instance_valid()` function checks if the reference to a node is valid. It returns `true` if it is and `false` otherwise.\n\t\t\tChecking if a node reference exists\n\t\t\tYour first instinct might be to check if the reference to the node is not `null` by running `_health_label != null`. However, this does not guarantee that the node is available. When the node is deleted, for example, this check for `null` will still return `true` because the reference still exists within the variable. `is_instance_valid(_health_label)` will check more than just whether the variable is `null` – it will also make sure that the node still exists and is in use within the scene tree.\n\t\t\tAt this point, the code for the player should look like this:\n\n```", "```cpp\n\n\t\t\tSetters and getters help us encapsulate behavior related to updating variables, as we saw in [*Chapter 5*](B19358_05.xhtml#_idTextAnchor365). It abstracts the logic behind what needs to happen when updating this variable so that the user of the class doesn’t have to worry about it.\n\t\t\tWith this code set up, the health of our player can easily be updated using the regular or special assignment operators and the health label will update accordingly.\n\t\t\tChanging values while the game is running\n\t\t\tAnother cool thing about these exported variables, now that we have a setter and a getter defined for them, is that we can change them while the game runs! So, if you run the game and change the `health` parameter in the **Inspector** view while it is running, you will see that change reflected in the health label instantaneously.\n\t\t\tThis (mostly) works with all built-in parameters too! If you keep the game open and change the player’s **Transformation** parameters, for example, you’ll see them change in real time.\n\t\t\tThis will be useful later on so that we don’t always have to re-launch the game when working on it.\n\t\t\tDifferent types of exported variables\n\t\t\tWhen exporting a variable that we type hinted, Godot will choose the right input field type for that type. It will have a numerical input field with up and down arrows for integers, while it will use a normal text input for strings, like so:\n\n```", "```cpp\n\n\t\t\tThese three lines will each export a variable to the editor, but each with a different data type: integer, floating-point number, and string, respectively. The result is that we get a different kind of input field for each of the variables:\n\t\t\t![Figure 6.24 – Different variable types that get exported](img/B19358_06_24.jpg)\n\n\t\t\tFigure 6.24 – Different variable types that get exported\n\t\t\tThere are also other export annotations to be even more specific. One of those is the `@export_range` annotation, which specifies a number range the value should be in, like so:\n\n```", "```cpp\n\n\t\t\tIn the preceding code excerpt, we export the `health` variable and specify that it should be a number between 0 and 10, including the outer values of 0 and 20\\. When you try out this ranged export, you’ll see that you cannot input values that fall outside of this range.\n\t\t\tTo make it more dynamic, we can use the `MAX_HEALTH` variable we defined earlier within the player’s script:\n\n```", "```cpp\n\n\t\t\tExporting variables is a very important technique to keep in our toolkit for tweaking variables and values when testing out the game. Now, let’s direct our attention to the arena and world the player will be walking around in.\n\t\t\tCreating a little world\n\t\t\tNow that we have a little player character, let’s create a world for them to inhabit! In this section, we’ll flesh out the arena in which the player has to battle challenging foes.\n\t\t\tChanging the background color\n\t\t\tLet’s start simple by changing the background color for our arena. We can easily do this from the project settings:\n\n\t\t\t\t1.  Navigate to **Rendering** | **Environment** in the project settings:\n\n\t\t\t![Figure 6.25 – Finding Default Clear Color under Rendering > Environment in the project settings](img/B19358_06_25.jpg)\n\n\t\t\tFigure 6.25 – Finding Default Clear Color under Rendering > Environment in the project settings\n\n\t\t\t\t1.  Set the `#e0bf7b` because it looks like sand or dried-up mud:\n\n\t\t\t![Figure 6.26 – Picking a color using the color selection tool](img/B19358_06_26.jpg)\n\n\t\t\tFigure 6.26 – Picking a color using the color selection tool\n\t\t\tWith this nice color in place, let’s add some features, such as boulders and walls, to our arena.\n\t\t\tAdding Polygon2D boulders\n\t\t\tNow that we have a ground for the player character to stand on, let’s add some boulders that will serve as obstacles in the arena. To do this, we will be using the `Polygon2D` node. This node can draw any polygon shape on the screen in any color we want:\n\n\t\t\t\t1.  Add a `Arena` to the root node of our `Main` scene.\n\t\t\t\t2.  Now, drag the `Arena` node we just created above the `Player` node. This will ensure everything within the `Arena` node will be drawn beneath the `Player` node. See the *Node drawing order* section to learn more about this.\n\t\t\t\t3.  We will put all our arena elements, such as boulders and walls, into this node. This way, we’ll keep the tree structure nice and tidy.\n\t\t\t\t4.  Now, add a `Polygon2D` node under the `Arena` node and call it `Boulder`:\n\n\t\t\t![Figure 6.27 – The scene tree with the Arena node and a Boulder node](img/B19358_06_27.jpg)\n\n\t\t\tFigure 6.27 – The scene tree with the Arena node and a Boulder node\n\n\t\t\t\t1.  You can add points to the polygon by left-clicking anywhere on the screen while the `Boulder` node is selected. Right-clicking will remove a point. You can also drag earlier placed points around. Place some points and close the shape by clicking on the first point you put down:\n\n\t\t\t![Figure 6.28 – Drawing a boulder using a Polygon2D node](img/B19358_06_28.jpg)\n\n\t\t\tFigure 6.28 – Drawing a boulder using a Polygon2D node\n\n\t\t\t\t1.  Set the `Boulder` node’s color property to something that resembles a stone. I chose `#504f51`.\n\n\t\t\tThese boulders might look simple, but they will serve our purpose.\n\t\t\tNode drawing order\n\t\t\tSo, why did we drag the `Arena` node above the `Player` node? By default, the nodes get drawn in the order they’re in within the tree. The nodes closest to their parents get drawn first and the ones further away from the parent node within the tree structure are drawn on top of the ones below.\n\t\t\tThere are ways to circumvent this, but that’s out of the scope of this book. So, for now, we must structure our node tree correctly:\n\t\t\t![Figure 6.29 – Nodes get drawn in the order they are in within the scene tree](img/B19358_06_29.jpg)\n\n\t\t\tFigure 6.29 – Nodes get drawn in the order they are in within the scene tree\n\t\t\tA well-structured tree will draw all nodes in the exact order we want them to be.\n\t\t\tCreating an outer wall\n\t\t\tFor the outer wall of the arena, we’ll use a `Polygon2D` node again, but in a different way this time:\n\n\t\t\t\t1.  Add a `Polygon2D` node under the `Arena` node and call it `OuterWall`.\n\t\t\t\t2.  Draw a rough rectangle that will be the inside of the arena. It’s okay if this rectangle is not perfect. This will make the arena look extra medieval:\n\n\t\t\t![Figure 6.30 – Drawing an arena outer wall using a Polygon2D node](img/B19358_06_30.jpg)\n\n\t\t\tFigure 6.30 – Drawing an arena outer wall using a Polygon2D node\n\n\t\t\t\t1.  Now, with `OuterWall` selected, find and enable the **Invert** parameter in the **Inspector** view. This option inverts the shape and makes it look like the outer walls of the arena:\n\n\t\t\t![Figure 6.31 – Inverting the shape of a Polygon2D node](img/B19358_06_31.jpg)\n\n\t\t\tFigure 6.31 – Inverting the shape of a Polygon2D node\n\n\t\t\t\t1.  Set the `1000px`, so that the walls expand very far.\n\t\t\t\t2.  Give the wall a fitting color. I chose `#2d2c2e`, which is a little darker than the boulders, so that the player sees the difference:\n\n\t\t\t![Figure 6.32 – The resulting arena](img/B19358_06_32.jpg)\n\n\t\t\tFigure 6.32 – The resulting arena\n\t\t\tInverting a polygon makes it very easy to create the internals of an arena or room. The natural next step is to let our imagination loose and make a visually nice arena.\n\t\t\tGetting creative\n\t\t\tWith these simple tools, get creative and create some interesting terrain to serve as an arena.\n\t\t\tFor instance, you can add some more boulders to your arena. You can do this by creating an entirely new `Polygon2D` node or by duplicating your earlier boulder and altering them a bit by dragging points around and using the **Transform** tools we learned about.\n\t\t\tYou can also add more walls and change the outer boundaries of the arena some more.\n\t\t\tI came up with this arena:\n\t\t\t![Figure 6.33 – My arena after spending some more time refining it](img/B19358_06_33.jpg)\n\n\t\t\tFigure 6.33 – My arena after spending some more time refining it\n\t\t\tNow that we can create our little worlds and arenas using colored rectangles and polygons, we have everything to create the basic visual structure of our game. Next, we’ll do some extra exercises and summarize this chapter.\n\t\t\tAdditional exercises – Sharpening the axe\n\n\t\t\t\t1.  Start by making more boulders and walls based on what we learned in the previous section so that you can populate your arena.\n\t\t\t\t2.  Based on what you learned about the `health` value of the player, add an exported variable that tracks the number of coins the player has, called `number_of_coins`, to the player script.\n\t\t\t\t3.  Add a setter and getter for the `number_of_coins` variable.\n\t\t\t\t4.  Lastly, make a label that shows the coins above the player’s head. Make sure that everything gets handled and updated correctly so that we can update the variable from the editor and the code while the label always stays up to date when running the game.\n\n\t\t\tSummary\n\t\t\tIn this chapter, we created our first real scene. We saw how different nodes do different things for us and we extended **Node2D** with a script that will manage the player’s health. We also created the area in which all the action will take place.\n\t\t\tIn the next chapter, we’ll make it possible for the player to move around and we’ll also refresh our vector math. Don’t worry – it won’t be painful, but a bit of math will be useful.\n\t\t\tQuiz time\n\n\t\t\t\t*   Why did we start by making a Game Design Document (GDD) instead of jumping right into creating the game?\n\t\t\t\t*   How do you reference nodes within a script?\n\t\t\t\t*   What keyword can we use to make a variable, such as the amount of health, available in the **Inspector** view?\n\t\t\t\t*   What are setter and getter functions used for?\n\n```", "```cpp\n\n```"]