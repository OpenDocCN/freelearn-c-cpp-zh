- en: '*Chapter 3*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Synthesis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *Chapter 2, Thesis*, we saw that the core benefits of OOP can be achieved
    with a small number of considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects are *independent programs*, ignorant of context to the largest possible
    extent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects communicate by *sending messages*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects behave in ways described in *contracts* expressing their responses to
    messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects can be written, changed, inspected, and adapted *in context*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no system currently available that supports all of these requirements
    simultaneously. Ironically, while OOP has become *overcomplicated*, as demonstrated
    in *Chapter 1, Antithesis*, it has also remained *incomplete*. In the final part
    of this book, let's consider what such a system would look like.
  prefs: []
  type: TYPE_NORMAL
- en: Objects Are Independent Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest problem to solve is allowing developers to independently design
    objects without expressing constraints that inhibit the developers' design freedoms.
    One way is to provide a `MetaObject` protocol that allows developers to adapt
    the rules of a language to fit a particular context. An even easier way (both
    to create and to use) is to make the *primitive parts of the message system* available
    to developers, to combine as needed to fulfill their design goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is easier to create because any more complex system would need these primitives
    anyway. It is easier to use because it allows the developers to construct solutions
    to problems as they encounter them, rather than trying to work out how to adapt
    existing rules onto the models they have for their solutions. That adaptation
    was one of the difficulties with using OOP we explored in *Chapter 1, Antithesis*:
    if what you''ve got is Java inheritance, you need to solve your problem using
    Java inheritance, even if your problem doesn''t seem like it fits with Java inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: The primitives needed are small in number. Here is a worked example in Python
    that is based on the functional programming view of objects explored in *Chapter
    1, Antithesis*.
  prefs: []
  type: TYPE_NORMAL
- en: '**A selector type**. This is a type that can be used to name messages, and
    thus it must be comparable: the receiver needs to know which selector was named
    in a message so it can decide what to do. Python''s string type is sufficient
    as a selector type, though many OO languages use an interned string type (Ruby''s
    symbols, for example) to make comparison cheaper.'
  prefs: []
  type: TYPE_NORMAL
- en: '`__getattr__()` function to do this, both for its `object.attribute` syntax
    and to implement the `getattr(object, attribute)` function, and conveniently,
    it expects the attribute''s name to be a string, so this works with the message
    selectors.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A way to send a message**. This will let the object find the appropriate
    method implementation using its own lookup function, then execute that method
    with the arguments supplied in the message. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice the convention that the first argument to any message is the receiving
    object. This allows the object to recursively message itself, even if the method
    being invoked was not found on the receiver but on a delegated object that would
    otherwise be ignorant of the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: '**A recursive case for message lookup**. If an object does not know how to
    implement a given message, it can ask a different object. This is *delegation*.
    It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`doesNotUnderstand` function provides that behavior (in our case, raising an
    error), and we''ll also supply a `Base` type that uses `doesNotUnderstand` and
    can terminate any delegation chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to the message-sending convention, `myself` is the object that received
    the message, while `this` is the object that is handling the message on its behalf:
    these could be, but do not have to be, the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Now these 13 lines of Python (found in **objective-py** at [https://gitlab.labrary.online/leeg/objective-py](https://gitlab.labrary.online/leeg/objective-py))
    are sufficient to build any form of object-oriented delegation, including the
    common forms of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: An **object** can inherit from a prototype by delegating all unknown messages
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: A **class** is an object that implements methods on behalf of its instances.
    A created instance of a class contains all of its own data, but delegates all
    messages to the class object.
  prefs: []
  type: TYPE_NORMAL
- en: The class can have no parents (it does not delegate unknown messages), one parent
    (it delegates all unknown messages to a single parent class object) or multiple
    parents (it delegates unknown messages to any of a list of parent class objects).
    It can also support traits or mixins, again by adding them to the list of objects
    to search for method implementations in.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class could even have a `metaclass`: a class object to which it delegates
    messages that it has received itself. That `metaclass` could have a `metametaclass`,
    if desired.'
  prefs: []
  type: TYPE_NORMAL
- en: Any, or multiple, of these schemes can be used within the same system, because
    the objects are ignorant of each other and how they are constructed. They simply
    know that they can use `msg_send()` to send each other messages, and that they
    can use `delegate` to have another object respond to messages on their behalf.
  prefs: []
  type: TYPE_NORMAL
- en: But, Python being Python, these objects all run synchronously on the same thread,
    in the same process. They are not truly independent programs yet.
  prefs: []
  type: TYPE_NORMAL
- en: Sticking with Python, it is easy to separate our objects out into separate processes
    by using a different Python interpreter for each object via the `execnet`—[https://codespeak.net/execnet/index.html](https://codespeak.net/execnet/index.html)
    module.
  prefs: []
  type: TYPE_NORMAL
- en: A quick, but important, aside
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The example here (and available at [https://gitlab.labrary.online/leeg/objactive-py](https://gitlab.labrary.online/leeg/objactive-py))
    focuses on demonstrating the possibility of running isolated objects, and is not
    really appropriate for using in a real application or system. The lack of production
    systems based around the simple object-oriented principles described in this book
    is the motivation for writing the book in the first place!
  prefs: []
  type: TYPE_NORMAL
- en: 'Each object can live in its own module. Creating an object involves creating
    a new Python interpreter and telling it to run this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When `execnet` runs a module, it has a special name that we can use to store
    the receiving channel and install the message handler. In this code, the receiver
    is stored in a global variable; as this is running in its own Python interpreter
    in a separate process from the rest of our system, that *global* is in fact unique
    to the receiving object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `handler` function is our object''s message dispatch function: it inspects
    the message selector and decides what code to run. This can work in exactly the
    same way as in previous examples—in other words, it can work however we want.
    Once an object receives a message, it should be up to *that object* to decide
    what to do with it, and how to act in response.'
  prefs: []
  type: TYPE_NORMAL
- en: An Object's Behavior Can Be Described in A Contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it is up to any one object to decide how it responds to messages, we need
    to know whether that object represents a useful addition to our system. In other
    words, we want to know *what* the object will do in response to *what* messages.
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Chapter 2, Thesis*, the Eiffel language encapsulates this knowledge
    about an object in the form of a *contract*, describing the preconditions and
    postconditions for each method along with the invariants that hold when the object
    has been created and whenever it is not executing a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This contract is, as the language in *Object-Oriented Software Construction*
    implies, a useful *design* tool: describe your object in terms of the messages
    it receives, what it expects when it receives those messages, and what the sender
    can expect in return.'
  prefs: []
  type: TYPE_NORMAL
- en: Eiffel also demonstrates that the contract is an effective *correctness testing*
    tool, because the assertions contained in an object's contract can be checked
    whenever appropriate, whether the object is being used in a test or a production
    system. In principle, the contract could even be used to *generate* tests in the
    style of property-based testing; what is "for all (expected input structure) ->
    (assertions that some properties hold of results)" other than a statement of preconditions
    and postconditions? In practice, this integration does not yet exist.
  prefs: []
  type: TYPE_NORMAL
- en: As the contract describes what an object can do, what must be true for the object
    to do it, and what will be true after the object has done it, it's also a great
    candidate for the position of *standard documentation structure* for each object.
    We already see in the world of HTTP APIs that the **Open API Specification** (formerly
    Swagger, [https://swagger.io/specification](https://swagger.io/specification))
    is a machine and human-readable description of what operations an API supports,
    its parameters and responses. An approach like this could easily be adopted for
    individual objects; after all, an object represents a model of a small, isolated
    computer program and so its message boundary *is* an API supporting particular
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Objects Can Be Written, Inspected, And Changed in Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: David West describes objects as *actors* on the computer stage, and even the
    meta-acting of programmers picking up the CRC card representing an object and
    role-playing its part in the system, explaining what data they're using and what
    messages they're sending to the other objects. Objects are fundamentally a live,
    interactive way of *thinking about software*, so they would be best supported
    by a live, interactive way of *turning thought into software*.
  prefs: []
  type: TYPE_NORMAL
- en: The Smalltalk environments, including modern ones such as **Pharo** and **Amber**—[https://www.amber-lang.net/](https://www.amber-lang.net/),
    demonstrate that such tools are possible. Pharo in particular features novel additions
    to the developer experience, one of the bullet points on the project's About page
    ([https://pharo.org/about](https://pharo.org/about)) tells us that "yes, we code
    in the debugger."
  prefs: []
  type: TYPE_NORMAL
- en: Distributing the software that is made with such an environment, currently,
    can be suboptimal. With Pharo, you either export specific classes into a package
    that somebody else who already has Pharo set up can use, or you write the state
    of your whole Pharo environment to an *image file*, and give the Pharo VM and
    the image file to the person who will use your software. Amber works like this
    too, but in the background is using the popular Bower package manager for JavaScript
    and its *image* contains just a few classes that implement JavaScript functions.
    Additionally, many JavaScript developers do not *distribute* their software in
    the conventional sense, as it is either served as needed to the browser or run
    by the developers themselves in a Node.js service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such live interaction is not confined to the Smalltalk world. I am writing
    this section of the book using the **GNU Emacs**—[https://www.gnu.org/software/emacs/](https://www.gnu.org/software/emacs/)
    text editor, which is really an Emacs Lisp interpreter with a dynamic text-centric
    user interface. At any time, I can type some Emacs Lisp in and evaluate it, including
    defining new functions or redefining existing functions. For example, given a
    paragraph containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I can move my cursor to the end of the paragraph, run the Emacs Lisp `eval-last-sexp`
    function, and then have a new `words` function that returns 1909, the number of
    words (at the time of writing) in this part of the manuscript. If it didn't do
    that, if I had accidentally counted characters instead of words, I could edit
    the function, re-evaluate it, and carry on using the fixed version. There's no
    need to quit Emacs while I re-build it, because I'm editing the code in the same
    environment that it runs in.
  prefs: []
  type: TYPE_NORMAL
- en: Put That All Together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the parts explored here exist, but not in the same place. Putting these
    together is a significant undertaking; building message passing and delegation
    between objects in separate processes may only take a few source lines, design-by-contract
    is a judicious application of the `assert()` statement, but a whole interactive
    environment to allow live development and debugging of such a system is a much
    bigger undertaking. So why consider it?
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the development environment and the deployment environment are the same,
    developers get a higher fidelity experience that makes turnaround time on development
    lower by reducing the likelihood that a change will "break in CI" (or even in
    production) due to differences in the environments.
  prefs: []
  type: TYPE_NORMAL
- en: The people using the software can have higher confidence too, because they know
    that the developer has built the thing in the same environment it will be used
    in. Additionally, the use of contracts in this proposed development system increases
    confidence, because the software is stated (and demonstrated) to work for *all*
    satisfactory inputs rather than merely a few test cases thought of by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Such fidelity is typically provided to developers at the *expense* of speed.
    Programmers connect over the network to a production-like server or wait for virtual
    machine or container images to be constructed on their local system. This time
    gets added to the typical steps, such as compiling or linking that come from separating
    development and deployment, giving us time to get distracted and lose our thread
    of concentration while getting validation of our work so far.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, though, the speed comes from *experimentation*. When development
    is close to deployment, it's easier to ask questions such as "what if I change
    this to be like that?" and to answer them. When systems are decomposed into small,
    isolated, independent objects, it's easier to change or even discard and replace
    objects that need improvement or adaptation.
  prefs: []
  type: TYPE_NORMAL
- en: While there is value in *designing* by contract, there is also value in *progressively*
    adding details to an object's contract as more properties of the system being
    simulated become known, and confidence in the shape of the objects increases.
    Contracts are great for documentation and for confidence in the behavior of an
    object, but those benefits need not come at the expense of forcing a developer's
    train of thought to call at particular stations in a prescribed order. As we saw
    in *Chapter 1, Antithesis*, a lot of complexity in object-oriented programming
    to date came from requiring that software teams consider their use cases, or their
    class hierarchies, or their data sharing, or other properties of the system at
    particular points in an object-oriented software engineering process.
  prefs: []
  type: TYPE_NORMAL
- en: It's far better to say, "here are the tools, use them when it makes sense,"
    so that the developer experience is not on rails. If that means taking time designing
    the developer system so that use, construction, documentation, testing, and configuration
    of the thing being developed can happen in any order, then so be it.
  prefs: []
  type: TYPE_NORMAL
- en: Tailoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Such experimentation also lends itself to *adaptation*. A frequent call for
    the industrialization of software involves the standardization of components and
    the ability for end users to plug those components together as required. Brad
    Cox's Software ICs, Sal Soghoian's AppleScript dictionaries, and even the NPM
    repository represent approaches to designing reuse by defining the boundary between
    "things that are reused" and "contexts in which they are reused."
  prefs: []
  type: TYPE_NORMAL
- en: 'In all of these situations, though, the distinction is arbitrary: a Software
    IC could implement a whole application, or the innards of a Mac app could be written
    in AppleScript. In a live development environment, the distinction is erased,
    and any part is available for extension, modification, or replacement. There is
    a famous story about Dan Ingalls adding smooth scrolling to a running Smalltalk
    system ([http://www.righto.com/2017/10/the-xerox-alto-smalltalk-and-rewriting.html](http://www.righto.com/2017/10/the-xerox-alto-smalltalk-and-rewriting.html))
    during a demo for a team from Apple Computer that included Steve Jobs. At that
    moment, Dan Ingalls'' Alto computer had smooth scrolling, and nobody else''s did.
    He didn''t need to recompile his Smalltalk machine and take the computer down
    to redeploy it, it just started working that way.'
  prefs: []
  type: TYPE_NORMAL
- en: My assertion is that the addition of contracts to a live programming environment
    *enables* experimentation, customization, and adaptation by increasing confidence
    in the replacement parts. Many object-oriented programmers already design their
    objects to adhere to the Liskov Substitution Principle, which says (roughly) that
    one object can act as a replacement for another if its preconditions are at most
    as strict as the other object's, and its postconditions are at least as strict.
  prefs: []
  type: TYPE_NORMAL
- en: 'In current environments, however, this idea of substitutability is unnecessarily
    coupled to the type system and to inheritance. In the proposed system, an object''s
    inheritance or lack thereof is its own business, so we ask a simpler question:
    is this object''s contract compatible with that use of an object? If it is, then
    they can be swapped and we know that things will work (at least to the extent
    that the contract is sufficient, anyway). If it is not, then we know *what* will
    not work, and what adaptation is required to hook things up.'
  prefs: []
  type: TYPE_NORMAL
- en: Propriety
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '"But how will we make money?" has been a rallying cry for developers who don''t
    want to use a new tool or technique for decades. We said we couldn''t make money
    when free and open source software made our source code available to our users,
    then started running GNU/Linux servers that our users connect to so they can download
    our JavaScript source code.'
  prefs: []
  type: TYPE_NORMAL
- en: The system described here involves combining the development and deployment
    environments, so how could we possibly make money? Couldn't users extract our
    code and run it themselves for free, or give it to their friends, or sell it to
    their friends?
  prefs: []
  type: TYPE_NORMAL
- en: Each object on the system is an *independent program* running in its own process,
    and its interface is the loosely coupled abstraction of message-sending. Any particular
    object could be a compiled executable based on a proprietary algorithm, distributed
    without its source code. Or it could be running on the developer's own server,
    handling messages remotely, or it could be deployed as a **dApp** to **Ethereum**
    or **NEO**. In each case, the developer avoids having to deploy their source code
    to the end user, and while that means that the user can't inspect or adapt the
    object, it does not stop them from *replacing* it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is interesting to consider how the economics of software delivery might
    change under such a system. At the moment, paid-outright applications, regular
    subscription fees, and free applications with paid-for content or components are
    all common, as are free (zero cost) applications and components. Other models
    do exist: some API providers charge per use, and blockchain dApps also cost *money*
    (albeit indirectly via tokens) to execute the distributed functions. An app or
    a web service has a clear brand, visible via the defined entry point for the user
    (their web address, or home screen icon). How might software businesses charge
    for the fulfilment of a programmatic contract, or for parts of an application
    that are augmented by other objects, or even replaced after deployment?'
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It was mentioned when discussing the propriety of objects that each object
    is hidden behind the loosely coupled message-sending abstraction. Implications
    on the security of such a system are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For an object to trust the content of a message, it must have sufficient information
    to make a trust decision and the confidence that the message it has received is
    as intended with no modifications. Using operating system IPC, the messages sent
    between objects are mediated by the kernel, which can enforce any access restrictions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Sufficient information" may include metadata that would be supplied by the
    messaging broker, for example, information about the context of the sender or
    the chain of events that led to this message being sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form in which the object receives the message does not have to be the form
    in which it was transmitted; for example, the messaging layer could encrypt the
    message and add an authentication code on sending that is checked on receipt before
    allowing the object to handle the message. Developers who work on web applications
    will be familiar with this anyway, as their requests involve HTTP verbs such as
    `GET` or `POST` and readable data such as `JSON`, but are then sent in a compressed
    format over encrypted, authenticated TLS channels. There is no reason such measures
    need to be limited to the network edges of an application nor (as evinced with
    a microservices architecture) for the network edge and the physical edge of the
    system to be in the same place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiprocessing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computers have not been getting faster, in terms of single-task instructions
    per second, for a very long time. Nonetheless, they still *are* significantly
    faster than the memory from which they are loading their code and data.
  prefs: []
  type: TYPE_NORMAL
- en: This hypothesis needs verifying, but my prediction is that small, independent
    objects communicating via message passing are a better fit for today's multi-core
    hardware architectures, as each object is a small self-contained program that
    should do a better job of fitting within the cache near to a CPU core than a monolithic
    application process.
  prefs: []
  type: TYPE_NORMAL
- en: Modern high-performance computing architectures are already massively parallel
    systems that run separate instances of the workload that synchronize, share data,
    and communicate results via message sending, typically based on the MPI standard.
    Many of the processor designs used in HPC are even *slower* in terms of instruction
    frequency than those used in desktop or server applications, but have many more
    cores in a single package and higher memory bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of breaking down an application to separate, independent objects is
    compatible with the observation that we don't need *a fast program*, but *a fast
    system* comprising multiple programs. As with cloud computing architectures, such
    systems can get faster by scaling. We don't necessarily need to make a faster
    widget if we can run tens of copies of the same widget and share the work out
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: Usability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of this discussion focuses on the benefits (observed or hypothesized) of
    the approach to writing software that has been developed in this book. We need
    to be realistic, though, and admit that working in the way described here is untested
    and is a significant departure from the way programmers currently work.
  prefs: []
  type: TYPE_NORMAL
- en: Smalltalk programmers already love their Smalltalk, but then C++ programmers
    love their C++ too, so there isn't a one-size-fits-all solution to the happiness
    of programmers, even if it could be shown that for some supposed objective property
    of the software construction process or the resulting software, one tool or technique
    had an advantage over others.
  prefs: []
  type: TYPE_NORMAL
- en: Some people may take a "better the devil you know" outlook, while others may
    try this way (assuming such a system even gets built!) and decide that it isn't
    for them. Still others may even fall in love with the *idea* of working in this
    way, though we could find that it slows them down or makes lower quality output
    than their current way of working! Experimentation and study will be needed to
    find out what's working, for whom, and how it could be improved.
  prefs: []
  type: TYPE_NORMAL
- en: This could turn out to be the biggest area of innovation in the whole system.
    Developer experiences are typically extremely conservative. "Modern" projects
    use the edit-compile-link-run-debug workflow that arose to satisfy technical,
    not experiential, constraints decades ago. They are driven from a **DEC VT-100**
    emulator. Weirdly, that is never the interface of choice for consumer products
    delivered by teams staffed with designers and user experience experts.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion to Part Three
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The story of this book has been one of deconstruction and reconstruction. The
    enormous complexity of three decades of OOP was deconstructed, to find a simple
    core, and an object-oriented programming experience was reconstructed around that
    core. The reconstruction contains all of the distinctive and important elements
    of the paradigm, while shedding the complexity borne of additive consultancy and
    capitulation to existing processes.
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, this new reconstruction still takes lessons from the two schools
    of thought in computing, which I call the *laboratory school* and the *library
    school*.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Laboratory School**'
  prefs: []
  type: TYPE_NORMAL
- en: The Laboratory School is the experimental approach. Go out, make a thing, and
    adapt, refine, or reject it based on your observations of how it performs. Don't
    worry about making the right thing, or making the thing right, just ensure it
    is made. You can adapt it later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extreme Programming** (**XP**) and the Lean Startup movement both exhibit
    influences of the laboratory school. Both schemes advocate experimentation and
    fast feedback. Both recommend starting small and simple – XP with its *Ya Ain''t
    Gonna Need It* principle and the Lean Startup with its *minimum viable product*
    – and then rapidly iterating based on feedback.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Smalltalk style of object-oriented programming also evinces the laboratory
    way of thinking. Loose coupling via message-sending lets programmers replace the
    collaborating objects in a system with other objects easily and quickly. Integrated
    development and deployment environments enable a style called **Debugger-Driven
    Design**—[https://medium.com/concerning-pharo/pharo-50c66685913c](https://medium.com/concerning-pharo/pharo-50c66685913c):
    find the thing that breaks the system because you haven''t built it yet, build
    it, then let the system carry on with its new behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Library School**'
  prefs: []
  type: TYPE_NORMAL
- en: The library school is the research-driven approach. Understand your problem,
    discover the properties of a solution that appropriately addresses the problem,
    implement the solution with those properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The disciplines related to *object-oriented software engineering* show associations
    with the library school. While the Rational Unified Process, as one example, does
    promote *iterative and incremental* development, the increments tend to be additive
    rather than exploratory: build the walking skeleton, then design, implement, and
    test this use case, then that use case. Add more use cases until the funding runs
    out. Make sure that at each step you retain your carefully-considered hierarchy
    of class relationships.'
  prefs: []
  type: TYPE_NORMAL
- en: The *if it type checks, it works* principle in programming appears to come from
    the library school. A type system is a machine for constructing proofs about the
    software that uses types from that system. Design your software with consistent
    application of those types and you get theorems for free ([https://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf](https://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf))
    about the behavior of the software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Design by contract demonstrates library-school thinking applied to OOP. The
    principle characteristic of an object is not its named type, but its *shape*:
    the messages it responds to and the things it does in response to those messages.
    Taking the mathematical proof tools from formal methods and applying them to the
    shape of objects, you end up with the *contract*: a mathematical statement about
    the messages an object responds to and the behavior resulting from receiving those
    messages.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Labrary**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are lessons to be learned from each of these schools of thought, and
    rather than siding with either one, the system described here adopts details from
    both. Not in an additive *let''s do all the things these people do, and add all
    the things these people do* way, but in a synthetic *let''s see what ideas these
    people promote and how they can be combined* way. We have contracts from the library,
    but don''t require *design by contract*: they are part of a live, experimental
    system from the laboratory that can be added and removed at any time.'
  prefs: []
  type: TYPE_NORMAL
- en: There is of course, one big problem with this environment, produced by the synthetic
    "Labrary" school of thought. That problem is that the environment doesn't exist.
    Yet. To the Labrary!
  prefs: []
  type: TYPE_NORMAL
