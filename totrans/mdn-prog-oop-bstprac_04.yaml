- en: '*Chapter 3*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*'
- en: Synthesis
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 综合考虑
- en: 'In *Chapter 2, Thesis*, we saw that the core benefits of OOP can be achieved
    with a small number of considerations:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章，论点*中，我们看到了使用面向对象编程（OOP）的核心好处可以通过少数几个考虑来实现：
- en: Objects are *independent programs*, ignorant of context to the largest possible
    extent
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象是*独立的程序*，尽可能无知于上下文
- en: Objects communicate by *sending messages*
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象通过*发送消息*进行通信
- en: Objects behave in ways described in *contracts* expressing their responses to
    messages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的行为由*合约*描述，这些合约表达了它们对消息的响应
- en: Objects can be written, changed, inspected, and adapted *in context*
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象可以在上下文中编写、更改、检查和适应
- en: There is no system currently available that supports all of these requirements
    simultaneously. Ironically, while OOP has become *overcomplicated*, as demonstrated
    in *Chapter 1, Antithesis*, it has also remained *incomplete*. In the final part
    of this book, let's consider what such a system would look like.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有一个系统能够同时支持所有这些要求。讽刺的是，尽管面向对象编程（OOP）已经变得*过于复杂*，正如第1章“对立”中所示，它也仍然*不完整*。在这本书的最后部分，让我们考虑一下这样一个系统会是什么样子。
- en: Objects Are Independent Programs
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象是独立的程序
- en: The easiest problem to solve is allowing developers to independently design
    objects without expressing constraints that inhibit the developers' design freedoms.
    One way is to provide a `MetaObject` protocol that allows developers to adapt
    the rules of a language to fit a particular context. An even easier way (both
    to create and to use) is to make the *primitive parts of the message system* available
    to developers, to combine as needed to fulfill their design goals.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易解决的问题是可以让开发者独立设计对象，而不必表达限制开发者设计自由的约束。一种方法是为开发者提供一个`MetaObject`协议，允许他们根据特定上下文调整语言的规则。一个更简单的方法（无论是创建还是使用）是将*消息系统的原始部分*提供给开发者，按需组合以满足他们的设计目标。
- en: 'This is easier to create because any more complex system would need these primitives
    anyway. It is easier to use because it allows the developers to construct solutions
    to problems as they encounter them, rather than trying to work out how to adapt
    existing rules onto the models they have for their solutions. That adaptation
    was one of the difficulties with using OOP we explored in *Chapter 1, Antithesis*:
    if what you''ve got is Java inheritance, you need to solve your problem using
    Java inheritance, even if your problem doesn''t seem like it fits with Java inheritance.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这更容易创建，因为任何更复杂的系统都需要这些原始操作。使用起来也更简单，因为它允许开发者根据遇到的问题构建解决方案，而不是试图将现有规则适应他们为解决方案构建的模型。这种适应是我们第1章“对立”中探讨使用面向对象编程（OOP）的困难之一：如果你有Java继承，你需要使用Java继承来解决你的问题，即使你的问题看起来并不适合Java继承。
- en: The primitives needed are small in number. Here is a worked example in Python
    that is based on the functional programming view of objects explored in *Chapter
    1, Antithesis*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的原始操作数量很少。以下是一个基于第1章“对立”中探讨的对象函数式编程视图的Python示例。
- en: '**A selector type**. This is a type that can be used to name messages, and
    thus it must be comparable: the receiver needs to know which selector was named
    in a message so it can decide what to do. Python''s string type is sufficient
    as a selector type, though many OO languages use an interned string type (Ruby''s
    symbols, for example) to make comparison cheaper.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择器类型**。这是一种可以用来命名消息的类型，因此它必须是可比较的：接收者需要知道消息中命名了哪个选择器，以便它可以决定要做什么。Python的字符串类型足以作为选择器类型，尽管许多面向对象的语言使用内部字符串类型（例如Ruby的符号）来降低比较的成本。'
- en: '`__getattr__()` function to do this, both for its `object.attribute` syntax
    and to implement the `getattr(object, attribute)` function, and conveniently,
    it expects the attribute''s name to be a string, so this works with the message
    selectors.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`__getattr__()`函数来完成这项工作，无论是为了实现`object.attribute`语法还是为了实现`getattr(object,
    attribute)`函数，而且方便的是，它期望属性名是一个字符串，因此这与消息选择器兼容。
- en: '**A way to send a message**. This will let the object find the appropriate
    method implementation using its own lookup function, then execute that method
    with the arguments supplied in the message. It looks like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送消息的方式**。这将允许对象使用其自己的查找函数找到适当的方法实现，然后使用消息中提供的参数执行该方法。它看起来像这样：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice the convention that the first argument to any message is the receiving
    object. This allows the object to recursively message itself, even if the method
    being invoked was not found on the receiver but on a delegated object that would
    otherwise be ignorant of the receiver.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到任何消息的第一个参数都是接收对象。这允许对象递归地给自己发送消息，即使被调用的方法不是在接收器上找到的，而是在一个被委托的对象上，否则这个对象可能对接收器一无所知。
- en: '**A recursive case for message lookup**. If an object does not know how to
    implement a given message, it can ask a different object. This is *delegation*.
    It looks like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息查找的递归情况**。如果一个对象不知道如何实现给定的消息，它可以请求另一个对象。这是 *委托*。它看起来是这样的：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`doesNotUnderstand` function provides that behavior (in our case, raising an
    error), and we''ll also supply a `Base` type that uses `doesNotUnderstand` and
    can terminate any delegation chain:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`doesNotUnderstand` 函数提供了这种行为（在我们的情况下，引发错误），我们还将提供一个使用 `doesNotUnderstand`
    并可以终止任何委托链的 `Base` 类型：'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Due to the message-sending convention, `myself` is the object that received
    the message, while `this` is the object that is handling the message on its behalf:
    these could be, but do not have to be, the same.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于消息发送约定，`myself` 是接收消息的对象，而 `this` 是代表其处理消息的对象：这些可以是，但不一定必须是同一个对象。
- en: Now these 13 lines of Python (found in **objective-py** at [https://gitlab.labrary.online/leeg/objective-py](https://gitlab.labrary.online/leeg/objective-py))
    are sufficient to build any form of object-oriented delegation, including the
    common forms of inheritance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这13行Python代码（在 **objective-py** 的 [https://gitlab.labrary.online/leeg/objective-py](https://gitlab.labrary.online/leeg/objective-py)
    找到）足以构建任何形式的面向对象委托，包括常见的继承形式。
- en: An **object** can inherit from a prototype by delegating all unknown messages
    to it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **对象** 可以通过将所有未知消息委托给原型来继承原型。
- en: A **class** is an object that implements methods on behalf of its instances.
    A created instance of a class contains all of its own data, but delegates all
    messages to the class object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**类** 是一个代表其实例实现方法的对象。一个类的创建实例包含它自己的所有数据，但将所有消息委托给类对象。'
- en: The class can have no parents (it does not delegate unknown messages), one parent
    (it delegates all unknown messages to a single parent class object) or multiple
    parents (it delegates unknown messages to any of a list of parent class objects).
    It can also support traits or mixins, again by adding them to the list of objects
    to search for method implementations in.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以没有父类（它不委托未知消息），有一个父类（它将所有未知消息委托给单个父类对象）或多个父类（它将未知消息委托给父类对象列表中的任何一个）。它还可以支持特性或混入，通过将它们添加到搜索方法实现的对象列表中来实现。
- en: 'A class could even have a `metaclass`: a class object to which it delegates
    messages that it has received itself. That `metaclass` could have a `metametaclass`,
    if desired.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类甚至可以有一个 `metaclass`：一个类对象，它将接收到的消息委托给它。如果需要，`metaclass` 还可以有一个 `metametaclass`。
- en: Any, or multiple, of these schemes can be used within the same system, because
    the objects are ignorant of each other and how they are constructed. They simply
    know that they can use `msg_send()` to send each other messages, and that they
    can use `delegate` to have another object respond to messages on their behalf.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方案中的任何一个或多个都可以在同一个系统中使用，因为对象之间互不知晓，也不知道它们的构造方式。它们只知道它们可以使用 `msg_send()` 发送彼此的消息，并且可以使用
    `delegate` 让另一个对象代表它们响应消息。
- en: But, Python being Python, these objects all run synchronously on the same thread,
    in the same process. They are not truly independent programs yet.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Python 作为 Python，这些对象都在同一个线程、同一个进程中同步运行。它们还不是真正独立的程序。
- en: Sticking with Python, it is easy to separate our objects out into separate processes
    by using a different Python interpreter for each object via the `execnet`—[https://codespeak.net/execnet/index.html](https://codespeak.net/execnet/index.html)
    module.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用 Python，通过为每个对象使用不同的 Python 解释器，我们可以很容易地将我们的对象分离到不同的进程中，通过使用 `execnet` 模块——[https://codespeak.net/execnet/index.html](https://codespeak.net/execnet/index.html)。
- en: A quick, but important, aside
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个简短但重要的补充
- en: The example here (and available at [https://gitlab.labrary.online/leeg/objactive-py](https://gitlab.labrary.online/leeg/objactive-py))
    focuses on demonstrating the possibility of running isolated objects, and is not
    really appropriate for using in a real application or system. The lack of production
    systems based around the simple object-oriented principles described in this book
    is the motivation for writing the book in the first place!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的示例（以及可在 [https://gitlab.labrary.online/leeg/objactive-py](https://gitlab.labrary.online/leeg/objactive-py)
    获取）专注于展示运行隔离对象的可能性，实际上并不适合用于实际的应用或系统。本书中描述的简单面向对象原则缺乏生产系统，正是最初写这本书的动机！
- en: 'Each object can live in its own module. Creating an object involves creating
    a new Python interpreter and telling it to run this module:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象可以存在于自己的模块中。创建对象涉及创建一个新的 Python 解释器并告诉它运行此模块：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When `execnet` runs a module, it has a special name that we can use to store
    the receiving channel and install the message handler. In this code, the receiver
    is stored in a global variable; as this is running in its own Python interpreter
    in a separate process from the rest of our system, that *global* is in fact unique
    to the receiving object:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `execnet` 运行一个模块时，它有一个特殊名称，我们可以用它来存储接收通道并安装消息处理程序。在此代码中，接收者存储在一个全局变量中；由于它在自己的
    Python 解释器中运行，与我们的系统其他部分是分开的进程，因此这个 *全局* 实际上是接收对象的唯一标识：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `handler` function is our object''s message dispatch function: it inspects
    the message selector and decides what code to run. This can work in exactly the
    same way as in previous examples—in other words, it can work however we want.
    Once an object receives a message, it should be up to *that object* to decide
    what to do with it, and how to act in response.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`handler` 函数是我们对象的信使分发函数：它检查信使选择器并决定运行什么代码。这可以与之前的示例完全相同地工作——换句话说，它可以按照我们的意愿工作。一旦对象收到一个消息，它应该由
    *该对象* 决定如何处理它，以及如何响应。'
- en: An Object's Behavior Can Be Described in A Contract
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象的行为可以用契约来描述
- en: While it is up to any one object to decide how it responds to messages, we need
    to know whether that object represents a useful addition to our system. In other
    words, we want to know *what* the object will do in response to *what* messages.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然任何对象都有权决定如何响应消息，但我们需要知道该对象是否代表对我们系统的有用补充。换句话说，我们想知道 *对象* 将如何响应 *什么* 消息。
- en: As seen in *Chapter 2, Thesis*, the Eiffel language encapsulates this knowledge
    about an object in the form of a *contract*, describing the preconditions and
    postconditions for each method along with the invariants that hold when the object
    has been created and whenever it is not executing a method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *第二章，论文* 所见，Eiffel 语言将关于对象的知识封装成 *契约* 的形式，描述了每个方法的先决条件和后置条件，以及对象创建时和未执行方法时保持的不变量。
- en: 'This contract is, as the language in *Object-Oriented Software Construction*
    implies, a useful *design* tool: describe your object in terms of the messages
    it receives, what it expects when it receives those messages, and what the sender
    can expect in return.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 *面向对象软件构造* 中的语言所暗示的，这个契约是一个有用的 *设计* 工具：用对象接收到的消息、接收这些消息时的期望以及发送者可以期望得到什么来描述你的对象。
- en: Eiffel also demonstrates that the contract is an effective *correctness testing*
    tool, because the assertions contained in an object's contract can be checked
    whenever appropriate, whether the object is being used in a test or a production
    system. In principle, the contract could even be used to *generate* tests in the
    style of property-based testing; what is "for all (expected input structure) ->
    (assertions that some properties hold of results)" other than a statement of preconditions
    and postconditions? In practice, this integration does not yet exist.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Eiffel 还表明，契约是一个有效的 *正确性测试* 工具，因为对象契约中包含的断言可以在适当的时候进行检查，无论对象是在测试还是生产系统中使用。原则上，契约甚至可以用来
    *生成* 基于属性的测试；"对于所有（预期输入结构）->（断言结果中某些属性成立)" 除了是先决条件和后置条件的陈述之外，还有什么？在实践中，这种集成尚不存在。
- en: As the contract describes what an object can do, what must be true for the object
    to do it, and what will be true after the object has done it, it's also a great
    candidate for the position of *standard documentation structure* for each object.
    We already see in the world of HTTP APIs that the **Open API Specification** (formerly
    Swagger, [https://swagger.io/specification](https://swagger.io/specification))
    is a machine and human-readable description of what operations an API supports,
    its parameters and responses. An approach like this could easily be adopted for
    individual objects; after all, an object represents a model of a small, isolated
    computer program and so its message boundary *is* an API supporting particular
    operations.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据合同描述一个对象可以做什么，对象执行该操作必须满足什么条件，以及对象执行后会发生什么，它也是每个对象 *标准文档结构* 的绝佳候选人。我们已经在 HTTP
    API 的世界中看到，**Open API 规范**（以前称为 Swagger，[https://swagger.io/specification](https://swagger.io/specification)）是
    API 支持的操作、其参数和响应的机器和人类可读描述。这种方法可以很容易地应用于单个对象；毕竟，一个对象代表了一个小型、隔离的计算机程序模型，因此它的消息边界
    *就是* 支持特定操作的一个 API。
- en: Objects Can Be Written, Inspected, And Changed in Context
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象可以在上下文中编写、检查和更改
- en: David West describes objects as *actors* on the computer stage, and even the
    meta-acting of programmers picking up the CRC card representing an object and
    role-playing its part in the system, explaining what data they're using and what
    messages they're sending to the other objects. Objects are fundamentally a live,
    interactive way of *thinking about software*, so they would be best supported
    by a live, interactive way of *turning thought into software*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 大卫·韦斯特将对象描述为计算机舞台上的 *演员*，甚至程序员拿起代表对象的 CRC 卡并扮演其在系统中的角色，解释他们使用的数据以及他们向其他对象发送的消息。对象本质上是一种实时、交互式的
    *思考软件* 的方式，因此它们最好通过一种实时、交互式的方式 *将思想转化为软件*。
- en: The Smalltalk environments, including modern ones such as **Pharo** and **Amber**—[https://www.amber-lang.net/](https://www.amber-lang.net/),
    demonstrate that such tools are possible. Pharo in particular features novel additions
    to the developer experience, one of the bullet points on the project's About page
    ([https://pharo.org/about](https://pharo.org/about)) tells us that "yes, we code
    in the debugger."
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk 环境，包括现代的 **Pharo** 和 **Amber**——[https://www.amber-lang.net/](https://www.amber-lang.net/)，证明了这样的工具是可能的。特别是
    Pharo，它为开发者体验增添了新颖的功能，项目“关于”页面上的一个要点（[https://pharo.org/about](https://pharo.org/about)）告诉我们，“是的，我们在调试器中编码。”
- en: Distributing the software that is made with such an environment, currently,
    can be suboptimal. With Pharo, you either export specific classes into a package
    that somebody else who already has Pharo set up can use, or you write the state
    of your whole Pharo environment to an *image file*, and give the Pharo VM and
    the image file to the person who will use your software. Amber works like this
    too, but in the background is using the popular Bower package manager for JavaScript
    and its *image* contains just a few classes that implement JavaScript functions.
    Additionally, many JavaScript developers do not *distribute* their software in
    the conventional sense, as it is either served as needed to the browser or run
    by the developers themselves in a Node.js service.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，使用这种环境制作的软件的分发可能不是最优的。使用 Pharo，你可以将特定的类导出到一个包中，其他人可以使用已经设置好 Pharo 的包，或者你可以将整个
    Pharo 环境的状态写入一个 *镜像文件*，并将 Pharo 虚拟机和镜像文件提供给将使用你的软件的人。Amber 也以这种方式工作，但在后台使用流行的
    Bower 包管理器来管理 JavaScript，其 *镜像* 只包含实现 JavaScript 函数的几个类。此外，许多 JavaScript 开发者并不以传统方式
    *分发* 他们的软件，因为它们要么被作为浏览器所需的服务提供，要么由开发者自己在 Node.js 服务中运行。
- en: 'Such live interaction is not confined to the Smalltalk world. I am writing
    this section of the book using the **GNU Emacs**—[https://www.gnu.org/software/emacs/](https://www.gnu.org/software/emacs/)
    text editor, which is really an Emacs Lisp interpreter with a dynamic text-centric
    user interface. At any time, I can type some Emacs Lisp in and evaluate it, including
    defining new functions or redefining existing functions. For example, given a
    paragraph containing the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实时交互不仅限于 Smalltalk 世界。我正在使用 **GNU Emacs**——[https://www.gnu.org/software/emacs/](https://www.gnu.org/software/emacs/)
    文本编辑器编写这本书的这一部分，它实际上是一个带有动态文本中心用户界面的 Emacs Lisp 解释器。在任何时候，我都可以输入一些 Emacs Lisp
    并对其进行评估，包括定义新函数或重新定义现有函数。例如，给定一个包含以下内容的段落：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I can move my cursor to the end of the paragraph, run the Emacs Lisp `eval-last-sexp`
    function, and then have a new `words` function that returns 1909, the number of
    words (at the time of writing) in this part of the manuscript. If it didn't do
    that, if I had accidentally counted characters instead of words, I could edit
    the function, re-evaluate it, and carry on using the fixed version. There's no
    need to quit Emacs while I re-build it, because I'm editing the code in the same
    environment that it runs in.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以将我的光标移至段落的末尾，运行 Emacs Lisp 的 `eval-last-sexp` 函数，然后得到一个新的 `words` 函数，它返回
    1909（写作时的数字）这个部分手稿中的单词数。如果它没有这样做，如果我意外地计算了字符而不是单词，我可以编辑这个函数，重新评估它，并继续使用修正后的版本。在我重新构建它的时候，没有必要退出
    Emacs，因为我正在编辑它在其中运行的相同环境中的代码。
- en: Put That All Together
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有这些放在一起
- en: All of the parts explored here exist, but not in the same place. Putting these
    together is a significant undertaking; building message passing and delegation
    between objects in separate processes may only take a few source lines, design-by-contract
    is a judicious application of the `assert()` statement, but a whole interactive
    environment to allow live development and debugging of such a system is a much
    bigger undertaking. So why consider it?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里探索的所有部分都存在，但不在同一个地方。将这些部分组合起来是一项重大任务；在分离的进程中构建对象之间的消息传递和委派可能只需要几行源代码，通过合同设计是
    `assert()` 语句的明智应用，但提供一个整个交互式环境以允许对这样的系统进行实时开发和调试则是一项更大的任务。那么为什么考虑它呢？
- en: Speed
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 速度
- en: When the development environment and the deployment environment are the same,
    developers get a higher fidelity experience that makes turnaround time on development
    lower by reducing the likelihood that a change will "break in CI" (or even in
    production) due to differences in the environments.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发环境和部署环境相同时，开发者可以获得更高的保真度体验，这通过减少由于环境差异而导致更改“在 CI 中中断”（甚至在生产中）的可能性，从而降低了开发周期。
- en: The people using the software can have higher confidence too, because they know
    that the developer has built the thing in the same environment it will be used
    in. Additionally, the use of contracts in this proposed development system increases
    confidence, because the software is stated (and demonstrated) to work for *all*
    satisfactory inputs rather than merely a few test cases thought of by the developer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该软件的人也可以更有信心，因为他们知道开发者是在将要使用的相同环境中构建了这个东西。此外，在这个提议的开发系统中使用合同增加了信心，因为软件被声明（并证明）对所有*满意*的输入都有效，而不仅仅是开发者想到的几个测试用例。
- en: Such fidelity is typically provided to developers at the *expense* of speed.
    Programmers connect over the network to a production-like server or wait for virtual
    machine or container images to be constructed on their local system. This time
    gets added to the typical steps, such as compiling or linking that come from separating
    development and deployment, giving us time to get distracted and lose our thread
    of concentration while getting validation of our work so far.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种保真度通常是以牺牲速度为代价提供给开发者的。程序员通过网络连接到类似生产的服务器，或者在他们的本地系统上构建虚拟机或容器镜像。这段时间被添加到典型的步骤中，例如编译或链接，这些步骤来自分离开发和部署，这给了我们时间在验证到目前为止的工作时分心并失去专注。
- en: Ultimately, though, the speed comes from *experimentation*. When development
    is close to deployment, it's easier to ask questions such as "what if I change
    this to be like that?" and to answer them. When systems are decomposed into small,
    isolated, independent objects, it's easier to change or even discard and replace
    objects that need improvement or adaptation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终的速度来自于*实验*。当开发接近部署时，更容易提出诸如“如果我将其改为那样会怎样？”等问题，并回答它们。当系统被分解为小型、隔离、独立的对象时，更容易更改或甚至丢弃和替换需要改进或适应的对象。
- en: While there is value in *designing* by contract, there is also value in *progressively*
    adding details to an object's contract as more properties of the system being
    simulated become known, and confidence in the shape of the objects increases.
    Contracts are great for documentation and for confidence in the behavior of an
    object, but those benefits need not come at the expense of forcing a developer's
    train of thought to call at particular stations in a prescribed order. As we saw
    in *Chapter 1, Antithesis*, a lot of complexity in object-oriented programming
    to date came from requiring that software teams consider their use cases, or their
    class hierarchies, or their data sharing, or other properties of the system at
    particular points in an object-oriented software engineering process.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过合同进行设计有其价值，但随着对被模拟系统更多属性的了解和对象形状的信心增加，逐步向对象的合同中添加细节也有其价值。合同对于文档和对象行为的信心非常有用，但这些好处不必以强迫开发者的思维过程在规定的顺序中停靠在特定站点为代价。正如我们在*第一章，对立面*中看到的，迄今为止面向对象编程中的许多复杂性都源于要求软件团队在面向对象软件工程过程的特定点上考虑他们的用例、类层次结构、数据共享或其他系统属性。
- en: It's far better to say, "here are the tools, use them when it makes sense,"
    so that the developer experience is not on rails. If that means taking time designing
    the developer system so that use, construction, documentation, testing, and configuration
    of the thing being developed can happen in any order, then so be it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最好这样说，“这里有一些工具，当它们有意义时使用它们”，这样开发者的体验就不会受到限制。如果这意味着花时间设计开发者系统，以便开发、构建、文档、测试和配置正在开发的东西可以按任何顺序进行，那么就这样吧。
- en: Tailoring
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定制
- en: Such experimentation also lends itself to *adaptation*. A frequent call for
    the industrialization of software involves the standardization of components and
    the ability for end users to plug those components together as required. Brad
    Cox's Software ICs, Sal Soghoian's AppleScript dictionaries, and even the NPM
    repository represent approaches to designing reuse by defining the boundary between
    "things that are reused" and "contexts in which they are reused."
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的实验也适合于*适应*。对软件工业化的频繁呼吁包括组件的标准化和最终用户根据需要将这些组件连接在一起的能力。布拉德·科克斯（Brad Cox）的软件集成电路、萨尔·索戈扬（Sal
    Soghoian）的AppleScript字典，甚至NPM存储库都代表了通过定义“可重用的事物”和“它们被重用的上下文”之间的边界来设计重用方法的方法。
- en: 'In all of these situations, though, the distinction is arbitrary: a Software
    IC could implement a whole application, or the innards of a Mac app could be written
    in AppleScript. In a live development environment, the distinction is erased,
    and any part is available for extension, modification, or replacement. There is
    a famous story about Dan Ingalls adding smooth scrolling to a running Smalltalk
    system ([http://www.righto.com/2017/10/the-xerox-alto-smalltalk-and-rewriting.html](http://www.righto.com/2017/10/the-xerox-alto-smalltalk-and-rewriting.html))
    during a demo for a team from Apple Computer that included Steve Jobs. At that
    moment, Dan Ingalls'' Alto computer had smooth scrolling, and nobody else''s did.
    He didn''t need to recompile his Smalltalk machine and take the computer down
    to redeploy it, it just started working that way.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，尽管如此，这种区别是任意的：一个软件集成电路（IC）可以实现一个完整的应用程序，或者Mac应用程序的内部可能用AppleScript编写。在实时开发环境中，这种区别被抹去，任何部分都可以用于扩展、修改或替换。有一个著名的故事是关于丹·英加尔斯（Dan
    Ingalls）在为包括史蒂夫·乔布斯（Steve Jobs）在内的苹果电脑团队进行演示时，向运行中的Smalltalk系统添加了平滑滚动功能（[http://www.righto.com/2017/10/the-xerox-alto-smalltalk-and-rewriting.html](http://www.righto.com/2017/10/the-xerox-alto-smalltalk-and-rewriting.html)）。在那个时刻，丹·英加尔斯的Alto电脑有了平滑滚动，而其他人的电脑没有。他不需要重新编译他的Smalltalk机器并将电脑关闭以重新部署，它只是开始那样工作。
- en: My assertion is that the addition of contracts to a live programming environment
    *enables* experimentation, customization, and adaptation by increasing confidence
    in the replacement parts. Many object-oriented programmers already design their
    objects to adhere to the Liskov Substitution Principle, which says (roughly) that
    one object can act as a replacement for another if its preconditions are at most
    as strict as the other object's, and its postconditions are at least as strict.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我的观点是，将合同添加到实时编程环境*使*实验、定制和适应成为可能，因为它增加了对替换部件的信心。许多面向对象程序员已经设计他们的对象以符合Liskov替换原则，该原则（大致上）说，如果一个对象的前置条件至多与另一个对象相同，并且它的后置条件至少与另一个对象相同，那么它可以作为另一个对象的替代。
- en: 'In current environments, however, this idea of substitutability is unnecessarily
    coupled to the type system and to inheritance. In the proposed system, an object''s
    inheritance or lack thereof is its own business, so we ask a simpler question:
    is this object''s contract compatible with that use of an object? If it is, then
    they can be swapped and we know that things will work (at least to the extent
    that the contract is sufficient, anyway). If it is not, then we know *what* will
    not work, and what adaptation is required to hook things up.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在当前环境中，这种可替换性的想法不必要地与类型系统和继承耦合在一起。在所提出的系统中，一个对象是否具有继承性是其自身的事务，所以我们问一个更简单的问题：这个对象的合约是否与该对象的使用兼容？如果是，那么它们可以被交换，我们知道事情将会工作（至少在合约足够的情况下）。如果不是，那么我们知道**什么**将不会工作，以及需要什么适应来连接事物。
- en: Propriety
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 专有性
- en: '"But how will we make money?" has been a rallying cry for developers who don''t
    want to use a new tool or technique for decades. We said we couldn''t make money
    when free and open source software made our source code available to our users,
    then started running GNU/Linux servers that our users connect to so they can download
    our JavaScript source code.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: “但我们如何赚钱？”几十年来一直是那些不愿意使用新工具或技术的开发者的口号。我们说过，当免费和开源软件使我们的源代码对用户可用，然后开始运行用户连接的GNU/Linux服务器，以便他们可以下载我们的JavaScript源代码时，我们无法赚钱。
- en: The system described here involves combining the development and deployment
    environments, so how could we possibly make money? Couldn't users extract our
    code and run it themselves for free, or give it to their friends, or sell it to
    their friends?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里描述的系统涉及将开发和部署环境相结合，那么我们怎么可能赚钱呢？用户难道不能免费提取我们的代码并自行运行，或者将其提供给朋友，或者卖给朋友吗？
- en: Each object on the system is an *independent program* running in its own process,
    and its interface is the loosely coupled abstraction of message-sending. Any particular
    object could be a compiled executable based on a proprietary algorithm, distributed
    without its source code. Or it could be running on the developer's own server,
    handling messages remotely, or it could be deployed as a **dApp** to **Ethereum**
    or **NEO**. In each case, the developer avoids having to deploy their source code
    to the end user, and while that means that the user can't inspect or adapt the
    object, it does not stop them from *replacing* it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 系统上的每个对象都是一个在其自身进程中运行的**独立程序**，其接口是松散耦合的消息发送抽象。任何特定的对象都可能是一个基于专有算法的编译可执行文件，没有源代码的分布式。或者它可能运行在开发者的自有服务器上，远程处理消息，或者它可能被部署为**dApp**到**以太坊**或**NEO**。在每种情况下，开发者都避免了将源代码部署给最终用户，虽然这意味着用户无法检查或修改该对象，但这并不阻止他们**替换**它。
- en: 'It is interesting to consider how the economics of software delivery might
    change under such a system. At the moment, paid-outright applications, regular
    subscription fees, and free applications with paid-for content or components are
    all common, as are free (zero cost) applications and components. Other models
    do exist: some API providers charge per use, and blockchain dApps also cost *money*
    (albeit indirectly via tokens) to execute the distributed functions. An app or
    a web service has a clear brand, visible via the defined entry point for the user
    (their web address, or home screen icon). How might software businesses charge
    for the fulfilment of a programmatic contract, or for parts of an application
    that are augmented by other objects, or even replaced after deployment?'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在这样的系统下软件交付的经济可能如何改变是很有趣的。目前，一次性付费的应用程序、定期订阅费、免费应用程序带有付费内容或组件，以及免费（零成本）应用程序和组件都很常见。其他模型也存在：一些API提供商按使用次数收费，区块链dApps也通过代币间接收费来执行分布式功能。一个应用程序或网络服务有一个清晰的标志，通过用户定义的入口点（他们的网址或主屏幕图标）可见。软件企业如何为履行程序性合约收费，或者为应用程序中由其他对象增强的部分收费，甚至部署后替换的部分收费呢？
- en: Security
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全性
- en: 'It was mentioned when discussing the propriety of objects that each object
    is hidden behind the loosely coupled message-sending abstraction. Implications
    on the security of such a system are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论对象的专有性时提到，每个对象都隐藏在松散耦合的消息发送抽象之后。这种系统对安全性的影响如下：
- en: For an object to trust the content of a message, it must have sufficient information
    to make a trust decision and the confidence that the message it has received is
    as intended with no modifications. Using operating system IPC, the messages sent
    between objects are mediated by the kernel, which can enforce any access restrictions.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使对象信任消息的内容，它必须拥有足够的信息来做出信任决定，并且有信心它收到的消息是按照预期发送的，没有修改。使用操作系统IPC，对象之间发送的消息由内核介导，可以强制执行任何访问限制。
- en: '"Sufficient information" may include metadata that would be supplied by the
    messaging broker, for example, information about the context of the sender or
    the chain of events that led to this message being sent.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “足够的信息”可能包括消息代理提供的元数据，例如，关于发送者背景或导致发送此消息的事件链的信息。
- en: The form in which the object receives the message does not have to be the form
    in which it was transmitted; for example, the messaging layer could encrypt the
    message and add an authentication code on sending that is checked on receipt before
    allowing the object to handle the message. Developers who work on web applications
    will be familiar with this anyway, as their requests involve HTTP verbs such as
    `GET` or `POST` and readable data such as `JSON`, but are then sent in a compressed
    format over encrypted, authenticated TLS channels. There is no reason such measures
    need to be limited to the network edges of an application nor (as evinced with
    a microservices architecture) for the network edge and the physical edge of the
    system to be in the same place.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象接收消息的形式不必是传输时的形式；例如，消息层可以在发送时加密消息并添加一个在接收时检查的认证代码，在允许对象处理消息之前检查。从事Web应用程序开发的开发者对此已经很熟悉了，因为他们的请求涉及HTTP动词，如`GET`或`POST`，以及可读数据，如`JSON`，但随后以压缩格式通过加密、认证的TLS通道发送。没有理由这样的措施需要限制在应用程序的网络边缘，也没有理由（如微服务架构所示）网络边缘和系统的物理边缘在同一个地方。
- en: Multiprocessing
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多进程
- en: Computers have not been getting faster, in terms of single-task instructions
    per second, for a very long time. Nonetheless, they still *are* significantly
    faster than the memory from which they are loading their code and data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机在每秒单任务指令方面已经很久没有变快了。尽管如此，它们仍然**是**从其中加载其代码和数据的内存的显著更快。
- en: This hypothesis needs verifying, but my prediction is that small, independent
    objects communicating via message passing are a better fit for today's multi-core
    hardware architectures, as each object is a small self-contained program that
    should do a better job of fitting within the cache near to a CPU core than a monolithic
    application process.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个假设需要验证，但我的预测是，通过消息传递进行通信的小型、独立对象更适合今天的多核硬件架构，因为每个对象都是一个小的自包含程序，它应该比一个单一的应用程序进程更好地适应靠近CPU核心的缓存。
- en: Modern high-performance computing architectures are already massively parallel
    systems that run separate instances of the workload that synchronize, share data,
    and communicate results via message sending, typically based on the MPI standard.
    Many of the processor designs used in HPC are even *slower* in terms of instruction
    frequency than those used in desktop or server applications, but have many more
    cores in a single package and higher memory bandwidth.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现代高性能计算架构已经是大规模并行系统，它们运行独立的工作负载实例，通过消息发送同步、共享数据和通信结果，通常基于MPI标准。在HPC中使用的许多处理器设计在指令频率方面甚至比桌面或服务器应用程序使用的处理器更**慢**，但单个包中具有更多的核心和更高的内存带宽。
- en: The idea of breaking down an application to separate, independent objects is
    compatible with the observation that we don't need *a fast program*, but *a fast
    system* comprising multiple programs. As with cloud computing architectures, such
    systems can get faster by scaling. We don't necessarily need to make a faster
    widget if we can run tens of copies of the same widget and share the work out
    between them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分解为独立的、分离的对象的想法与观察结果相一致，即我们不需要一个**快速程序**，而是一个由多个程序组成的**快速系统**。正如云计算架构一样，这样的系统可以通过扩展来提高速度。如果我们能够运行同一部件的数十个副本并在它们之间共享工作，那么我们就不必一定要使部件更快。
- en: Usability
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可用性
- en: All of this discussion focuses on the benefits (observed or hypothesized) of
    the approach to writing software that has been developed in this book. We need
    to be realistic, though, and admit that working in the way described here is untested
    and is a significant departure from the way programmers currently work.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些讨论都集中在本书中开发出的编写软件方法的益处（观察到的或假设的）。然而，我们需要现实一些，承认这里描述的工作方式尚未经过测试，并且与程序员目前的工作方式有重大差异。
- en: Smalltalk programmers already love their Smalltalk, but then C++ programmers
    love their C++ too, so there isn't a one-size-fits-all solution to the happiness
    of programmers, even if it could be shown that for some supposed objective property
    of the software construction process or the resulting software, one tool or technique
    had an advantage over others.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk 程序员已经深爱着他们的 Smalltalk，但 C++ 程序员也深爱着他们的 C++，因此没有一种适合所有程序员的解决方案，即使可以证明在某些所谓的软件构建过程或结果的客观属性上，一种工具或技术比其他工具或技术有优势。
- en: Some people may take a "better the devil you know" outlook, while others may
    try this way (assuming such a system even gets built!) and decide that it isn't
    for them. Still others may even fall in love with the *idea* of working in this
    way, though we could find that it slows them down or makes lower quality output
    than their current way of working! Experimentation and study will be needed to
    find out what's working, for whom, and how it could be improved.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会采取“宁为鸡头，不为凤尾”的视角，而其他人可能会尝试这种方法（假设这样的系统甚至被构建出来！）并决定它不适合他们。还有一些人甚至可能会爱上这种**方式**的**想法**，尽管我们发现这可能会减慢他们的速度或比他们目前的工作方式产生更低质量的结果！实验和研究将有助于找出什么有效，对谁有效，以及如何改进。
- en: This could turn out to be the biggest area of innovation in the whole system.
    Developer experiences are typically extremely conservative. "Modern" projects
    use the edit-compile-link-run-debug workflow that arose to satisfy technical,
    not experiential, constraints decades ago. They are driven from a **DEC VT-100**
    emulator. Weirdly, that is never the interface of choice for consumer products
    delivered by teams staffed with designers and user experience experts.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是整个系统中最大的创新领域。开发者的体验通常非常保守。"现代"项目使用几十年前为了满足技术而非经验约束而出现的编辑-编译-链接-运行-调试工作流程。奇怪的是，这从来不是由拥有设计师和用户体验专家的团队提供的消费产品的首选界面。
- en: Conclusion to Part Three
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三部分结论
- en: The story of this book has been one of deconstruction and reconstruction. The
    enormous complexity of three decades of OOP was deconstructed, to find a simple
    core, and an object-oriented programming experience was reconstructed around that
    core. The reconstruction contains all of the distinctive and important elements
    of the paradigm, while shedding the complexity borne of additive consultancy and
    capitulation to existing processes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的故事一直是解构与重建。三十年OOP的巨大复杂性被解构，以找到简单的核心，并在该核心周围重建面向对象编程体验。重建包含了该范式的所有独特和重要元素，同时摒弃了由附加咨询和对现有流程的屈服带来的复杂性。
- en: Importantly, this new reconstruction still takes lessons from the two schools
    of thought in computing, which I call the *laboratory school* and the *library
    school*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，这种新的重建仍然从计算机的两个思想流派中吸取教训，我将它们称为**实验室学校**和**图书馆学校**。
- en: '**The Laboratory School**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**实验室学校**'
- en: The Laboratory School is the experimental approach. Go out, make a thing, and
    adapt, refine, or reject it based on your observations of how it performs. Don't
    worry about making the right thing, or making the thing right, just ensure it
    is made. You can adapt it later.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室学校是实验性的方法。走出去，做一件事，并根据你对它表现出的观察来调整、改进或拒绝它。不要担心做对的事情，或者把事情做对，只需确保它被完成。你可以稍后调整它。
- en: '**Extreme Programming** (**XP**) and the Lean Startup movement both exhibit
    influences of the laboratory school. Both schemes advocate experimentation and
    fast feedback. Both recommend starting small and simple – XP with its *Ya Ain''t
    Gonna Need It* principle and the Lean Startup with its *minimum viable product*
    – and then rapidly iterating based on feedback.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**极限编程**（**XP**）和精益创业运动都体现了实验室学校的影响。这两种方案都倡导实验和快速反馈。它们都建议从小和简单开始——XP 通过其 *Ya
    Ain''t Gonna Need It* 原则，精益创业通过其 *最小可行产品*——然后根据反馈快速迭代。'
- en: 'The Smalltalk style of object-oriented programming also evinces the laboratory
    way of thinking. Loose coupling via message-sending lets programmers replace the
    collaborating objects in a system with other objects easily and quickly. Integrated
    development and deployment environments enable a style called **Debugger-Driven
    Design**—[https://medium.com/concerning-pharo/pharo-50c66685913c](https://medium.com/concerning-pharo/pharo-50c66685913c):
    find the thing that breaks the system because you haven''t built it yet, build
    it, then let the system carry on with its new behavior.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk风格的面向对象编程也体现了实验室思维方式。通过消息发送的松散耦合让程序员能够轻松快速地替换系统中的协作对象。集成开发和部署环境使得一种称为**调试驱动设计**（Debugger-Driven
    Design）的风格成为可能——[https://medium.com/concerning-pharo/pharo-50c66685913c](https://medium.com/concerning-pharo/pharo-50c66685913c)：找出因为尚未构建而破坏系统的东西，构建它，然后让系统继续其新的行为。
- en: '**The Library School**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**图书馆学校**'
- en: The library school is the research-driven approach. Understand your problem,
    discover the properties of a solution that appropriately addresses the problem,
    implement the solution with those properties.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆学校是研究驱动的方法。理解你的问题，发现一个解决方案的属性，这个解决方案适当地解决了问题，用这些属性实现解决方案。
- en: 'The disciplines related to *object-oriented software engineering* show associations
    with the library school. While the Rational Unified Process, as one example, does
    promote *iterative and incremental* development, the increments tend to be additive
    rather than exploratory: build the walking skeleton, then design, implement, and
    test this use case, then that use case. Add more use cases until the funding runs
    out. Make sure that at each step you retain your carefully-considered hierarchy
    of class relationships.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与*面向对象软件工程*相关的学科显示出与图书馆学校的关联。以理性统一过程（Rational Unified Process）为例，它确实促进了*迭代和增量*开发，但这些增量往往是累加的而不是探索性的：先构建行走骨架，然后设计、实现和测试这个用例，然后是那个用例。添加更多用例，直到资金耗尽。确保在每一步你都能保留你仔细考虑过的类关系层次。
- en: The *if it type checks, it works* principle in programming appears to come from
    the library school. A type system is a machine for constructing proofs about the
    software that uses types from that system. Design your software with consistent
    application of those types and you get theorems for free ([https://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf](https://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf))
    about the behavior of the software.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的*如果类型检查通过，它就工作*原则似乎来自图书馆学校。类型系统是一个构建关于使用该系统类型的软件的证明的机器。通过一致地应用这些类型来设计你的软件，你将免费获得关于软件行为的定理([https://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf](https://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf))。
- en: 'Design by contract demonstrates library-school thinking applied to OOP. The
    principle characteristic of an object is not its named type, but its *shape*:
    the messages it responds to and the things it does in response to those messages.
    Taking the mathematical proof tools from formal methods and applying them to the
    shape of objects, you end up with the *contract*: a mathematical statement about
    the messages an object responds to and the behavior resulting from receiving those
    messages.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过合同进行设计展示了将图书馆学校的思想应用于面向对象编程。一个对象的主要特征不是它的命名类型，而是它的*形状*：它响应的消息以及它对这些消息的响应。从形式方法中采用数学证明工具并将其应用于对象的形状，你最终得到*合同*：一个关于对象响应的消息及其接收这些消息产生的行为的数学陈述。
- en: '**The Labrary**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**图书馆**'
- en: 'There are lessons to be learned from each of these schools of thought, and
    rather than siding with either one, the system described here adopts details from
    both. Not in an additive *let''s do all the things these people do, and add all
    the things these people do* way, but in a synthetic *let''s see what ideas these
    people promote and how they can be combined* way. We have contracts from the library,
    but don''t require *design by contract*: they are part of a live, experimental
    system from the laboratory that can be added and removed at any time.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些思想流派中我们可以学到很多经验教训，而不是站在任何一方，这里描述的系统采用了两者的细节。不是以累加的方式*让我们做这些人做的所有事情，并添加这些人做的所有事情*，而是以综合的方式*让我们看看这些人推广了哪些想法，以及它们如何可以结合在一起*。我们有来自图书馆的合同，但不需要*通过合同进行设计*：它们是实验室中一个活生生的、实验性的系统的一部分，可以随时添加或删除。
- en: There is of course, one big problem with this environment, produced by the synthetic
    "Labrary" school of thought. That problem is that the environment doesn't exist.
    Yet. To the Labrary!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个环境存在一个很大的问题，这是由合成“图书馆”学派思想产生的。这个问题就是环境还不存在。去图书馆吧！
