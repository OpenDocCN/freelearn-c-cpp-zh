["```cpp\nenki::TaskSchedulerConfig config;\nconfig.numTaskThreadsToCreate = 4;\nenki::TaskScheduler task_scheduler;\ntask_scheduler.Initialize( config );\n```", "```cpp\nStruct ParallelTaskSet : enki::ItaskSet {\n    void ExecuteRange(  enki::TaskSetPartition range_,\n                        uint32_t threadnum_ ) override {\n        // do something here, can issue tasks with\n           task_scheduler\n    }\n};\nint main(int argc, const char * argv[]) {\n    enki::TaskScheduler task_scheduler;\n    task_scheduler.Initialize( config );\n    ParallelTaskSet task; // default constructor has a set\n                             size of 1\n    task_scheduler.AddTaskSetToPipe( &task );\n    // wait for task set (running tasks if they exist)\n    // since we've just added it and it has no range we'll\n       likely run it.\n    Task_scheduler.WaitforTask( &task );\n    return 0;\n}\n```", "```cpp\nenki::TaskSet task( 1, []( enki::TaskSetPartition range_,\n  uint32_t threadnum_  ) {\n         // do something here\n  }  );\ntask_scheduler.AddTaskSetToPipe( &task );\n```", "```cpp\nconfig.numTaskThreadsToCreate = 4;\n```", "```cpp\n// Create IO threads at the end\nRunPinnedTaskLoopTask run_pinned_task;\nrun_pinned_task.threadNum = task_scheduler.\n                            GetNumTaskThreads() - 1;\ntask_scheduler.AddPinnedTask( &run_pinned_task );\n```", "```cpp\n// Send async load task to external thread\nAsynchronousLoadTask async_load_task;\nasync_load_task.threadNum = run_pinned_task.threadNum;\ntask_scheduler.AddPinnedTask( &async_load_task );\n```", "```cpp\nstruct RunPinnedTaskLoopTask : enki::IPinnedTask {\n    void Execute() override {\n        while ( task_scheduler->GetIsRunning() && execute )\n         {\n            task_scheduler->WaitForNewPinnedTasks();\n            // this thread will 'sleep' until there are new\n               pinned tasks\n            task_scheduler->RunPinnedTasks();\n        }\n    }\n    enki::TaskScheduler*task_scheduler;\n    bool execute = true;\n}; // struct RunPinnedTaskLoopTask\n```", "```cpp\nstruct AsynchronousLoadTask : enki::IPinnedTask {\n    void Execute() override {\n        while ( execute ) {\n            async_loader->update();\n        }\n    }\n    AsynchronousLoader*async_loader;\n    enki::TaskScheduler*task_scheduler;\n    bool execute = true;\n}; // struct AsynchronousLoadTask\n```", "```cpp\n{\n    \"VkQueueFamilyProperties\": {\n        \"queueFlags\": [\n            \"VK_QUEUE_GRAPHICS_BIT\",\n            \"VK_QUEUE_COMPUTE_BIT\",\n            \"VK_QUEUE_TRANSFER_BIT\",\n            \"VK_QUEUE_SPARSE_BINDING_BIT\"\n        ],\n        \"queueCount\": 1,\n    }\n},\n{\n    \"VkQueueFamilyProperties\": {\n        \"queueFlags\": [\n            \"VK_QUEUE_COMPUTE_BIT\",\n            \"VK_QUEUE_TRANSFER_BIT\",\n            \"VK_QUEUE_SPARSE_BINDING_BIT\"\n        ],\n        \"queueCount\": 2,\n    }\n},\n{\n    \"VkQueueFamilyProperties\": {\n        \"queueFlags\": [\n            \"VK_QUEUE_TRANSFER_BIT\",\n            \"VK_QUEUE_SPARSE_BINDING_BIT\"\n        ],\n        \"queueCount\": 2,\n    }\n}\n```", "```cpp\nu32 queue_family_count = 0;\n    vkGetPhysicalDeviceQueueFamilyProperties(\n    vulkan_physical_device, &queue_family_count, nullptr );\n    VkQueueFamilyProperties*queue_families = (\n        VkQueueFamilyProperties* )ralloca( sizeof(\n            VkQueueFamilyProperties ) * queue_family_count,\n                temp_allocator );\n        vkGetPhysicalDeviceQueueFamilyProperties(\n            vulkan_physical_device, &queue_family_count,\n                queue_families );\n    u32 main_queue_index = u32_max, transfer_queue_index =\n    u32_max;\n    for ( u32 fi = 0; fi < queue_family_count; ++fi) {\n        VkQueueFamilyProperties queue_family =\n            queue_families[ fi ];\n        if ( queue_family.queueCount == 0 ) {\n            continue;\n        }\n        // Search for main queue that should be able to do\n           all work (graphics, compute and transfer)\n        if ( (queue_family.queueFlags & (\n              VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT |\n              VK_QUEUE_TRANSFER_BIT )) == (\n              VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT |\n              VK_QUEUE_TRANSFER_BIT ) ) {\n                 main_queue_index = fi;\n        }\n        // Search for transfer queue\n        if ( ( queue_family.queueFlags &\n               VK_QUEUE_COMPUTE_BIT ) == 0 &&\n               (queue_family.queueFlags &\n               VK_QUEUE_TRANSFER_BIT) ) {\n            transfer_queue_index = fi;\n        }\n    }\n```", "```cpp\n// Queue creation\nVkDeviceQueueCreateInfo queue_info[ 2 ] = {};\nVkDeviceQueueCreateInfo& main_queue = queue_info[ 0 ];\nmain_queue.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE\n                   _CREATE_INFO;\nmain_queue.queueFamilyIndex = main_queue_index;\nmain_queue.queueCount = 1;\nmain_queue.pQueuePriorities = queue_priority;\nif ( vulkan_transfer_queue_family < queue_family_count ) {\n    VkDeviceQueueCreateInfo& transfer_queue_info =\n        queue_info[ 1 ];\n    transfer_queue_info.sType = VK_STRUCTURE_TYPE\n                                _DEVICE_QUEUE_CREATE_INFO;\n    transfer_queue_info.queueFamilyIndex = transfer_queue\n                                           _index;\ntransfer_queue_info.queueCount = 1;\ntransfer_queue_info.pQueuePriorities = queue_priority;\n}\nVkDeviceCreateInfo device_create_info {\n    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO };\ndevice_create_info.queueCreateInfoCount = vulkan_transfer\n    _queue_family < queue_family_count ? 2 : 1;\ndevice_create_info.pQueueCreateInfos = queue_info;\n...\nresult = vkCreateDevice( vulkan_physical_device,\n                         &device_create_info,\n                         vulkan_allocation_callbacks,\n                         &vulkan_device );\n```", "```cpp\n// Queue retrieval\n// Get main queue\nvkGetDeviceQueue( vulkan_device, main_queue_index, 0,\n                  &vulkan_main_queue );\n// Get transfer queue if present\nif ( vulkan_transfer_queue_family < queue_family_count ) {\n    vkGetDeviceQueue( vulkan_device, transfer_queue_index,\n                      0, &vulkan_transfer_queue );\n}\n```", "```cpp\nfor ( u32 i = 0; i < GpuDevice::k_max_frames; ++i) {\nVkCommandPoolCreateInfo cmd_pool_info = {\n    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO, nullptr };\ncmd_pool_info.queueFamilyIndex = gpu->vulkan\n                                 _transfer_queue_family;\ncmd_pool_info.flags = VK_COMMAND_POOL_CREATE_RESET\n                      _COMMAND_BUFFER_BIT;\nvkCreateCommandPool( gpu->vulkan_device, &cmd_pool_info,\n                     gpu->vulkan_allocation_callbacks,\n                     &command_pools[i]);\n}\n```", "```cpp\nfor ( u32 i = 0; i < GpuDevice::k_max_frames; ++i) {\n    VkCommandBufferAllocateInfo cmd = {\n        VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,\n            nullptr };\n       cmd.commandPool = command_pools[i];\ncmd.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;\ncmd.commandBufferCount = 1;\nvkAllocateCommandBuffers( renderer->gpu->vulkan_device,\n                          &cmd, &command_buffers[i].\n                          vk_command_buffer );\n```", "```cpp\nBufferCreation bc;\nbc.reset().set( VK_BUFFER_USAGE_TRANSFER_SRC_BIT,\n                ResourceUsageType::Stream, rmega( 64 )\n                ).set_name( \"staging_buffer\" ).\n                set_persistent( true );\nBufferHandle staging_buffer_handle = gpu->create_buffer\n                                     ( bc );\n```", "```cpp\nVkBufferCreateInfo buffer_info{\n    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };\nbuffer_info.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;\nbuffer_info.size = 64 * 1024 * 1024; // 64 MB\nVmaAllocationCreateInfo allocation_create_info{};\nallocation_create_info.flags = VMA_ALLOCATION_CREATE\n_STRATEGY_BEST_FIT_BIT | VMA_ALLOCATION_CREATE_MAPPED_BIT;\nVmaAllocationInfo allocation_info{};\ncheck( vmaCreateBuffer( vma_allocator, &buffer_info,\n       &allocation_create_info, &buffer->vk_buffer,\n       &buffer->vma_allocation, &allocation_info ) );\n```", "```cpp\nbuffer->mapped_data = static_cast<u8*>(allocation_info.\n                                       pMappedData);\n```", "```cpp\nVkSemaphoreCreateInfo semaphore_info{\n    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO };\nvkCreateSemaphore( gpu->vulkan_device, &semaphore_info,\n                   gpu->vulkan_allocation_callbacks,\n                   &transfer_complete_semaphore );\nVkFenceCreateInfo fence_info{\n    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO };\nfence_info.flags = VK_FENCE_CREATE_SIGNALED_BIT;\nvkCreateFence( gpu->vulkan_device, &fence_info,\n               gpu->vulkan_allocation_callbacks,\n               &transfer_fence );\n```", "```cpp\nFileLoadRequest load_request = file_load_requests.back();\n// Process request\nint x, y, comp;\nu8* texture_data = stbi_load( load_request.path, &x, &y,\n                              &comp, 4 );\n// Signal the loader that an upload data is ready to be\n   transferred to the GPU\nUploadRequest& upload_request = upload_requests.push_use();\nupload_request.data = texture_data;\nupload_request.texture = load_request.texture;\n```", "```cpp\n// Wait for transfer fence to be finished\nif ( vkGetFenceStatus( gpu->vulkan_device, transfer_fence )\n     != VK_SUCCESS ) {\nreturn;\n}\n// Reset if file requests are present.\nvkResetFences( gpu->vulkan_device, 1, &transfer_fence );\n```", "```cpp\n// Get last request\nUploadRequest request = upload_requests.back();\nconst sizet aligned_image_size = memory_align(\n                                 texture->width *\n                                 texture->height *\n                                 k_texture_channels,\n                                 k_texture_alignment );\n// Request place in buffer\nconst sizet current_offset = staging_buffer_offset +\n                             aligned_image_size;\nCommandBuffer* cb = &command_buffers[ gpu->current_frame ;\ncb->begin();\ncb->upload_texture_data( texture->handle, request.data,\n                         staging_buffer->handle,\n                         current_offset );\nfree( request.data );\ncb->end();\n```", "```cpp\n// Copy buffer_data to staging buffer\nmemcpy( staging_buffer->mapped_data +\n        staging_buffer_offset, texture_data,\n        static_cast< size_t >( image_size ) );\n```", "```cpp\nVkBufferImageCopy region = {};\nregion.bufferOffset = staging_buffer_offset;\nregion.bufferRowLength = 0;\nregion.bufferImageHeight = 0;\n```", "```cpp\n// Pre copy memory barrier to perform layout transition\nVkImageMemoryBarrier preCopyMemoryBarrier;\n...\n.srcAccessMask = 0,\n.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT,\n.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED,\n.newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,\n.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,\n.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,\n.image = image,\n.subresourceRange = ... };\n...\n```", "```cpp\n// Copy from the staging buffer to the image\nvkCmdCopyBufferToImage( vk_command_buffer,\n                        staging_buffer->vk_buffer,\n                        texture->vk_image,\n                        VK_IMAGE_LAYOUT_TRANSFER_DST\n                        _OPTIMAL, 1, &region );\n```", "```cpp\n// Post copy memory barrier\nVkImageMemoryBarrier postCopyTransferMemoryBarrier = {\n...\n.srcAccessMask = VK_ACCESS_TRANFER_WRITE_BIT,\n.dstAccessMask = 0,\n.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,\n.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,\n.srcQueueFamilyIndex = transferQueueFamilyIndex,\n.dstQueueFamilyIndex = graphicsQueueFamilyIndex,\n.image = image,\n.subresourceRange = ... };\n```", "```cpp\nVkImageMemoryBarrier postCopyGraphicsMemoryBarrier = {\n...\n.srcAccessMask = 0,\n.dstAccessMask = VK_ACCESS_SHADER_READ_BIT,\n.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,\n.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,\n.srcQueueFamilyIndex = transferQueueFamilyIndex,\n.dstQueueFamilyIndex = graphicsQueueFamilyIndex,\n.image = image,\n.subresourceRange = ... };\n```", "```cpp\nvoid CommandBufferManager::reset_pools( u32 frame_index ) {\n    for ( u32 i = 0; i < num_pools_per_frame; i++ ) {\n        const u32 pool_index = pool_from_indices(\n                               frame_index, i );\n        vkResetCommandPool( gpu->vulkan_device,\n                            vulkan_command_pools[\n                            pool_index ], 0 );\n    }\n}\n```", "```cpp\nVkSubmitInfo submit_info = {\n    VK_STRUCTURE_TYPE_SUBMIT_INFO };\nsubmit_info.commandBufferCount = num_queued_command\n                                 _buffers;\nsubmit_info.pCommandBuffers = enqueued_command_buffers;\n...\nvkQueueSubmit( vulkan_main_queue, 1, &submit_info,\n               *render_complete_fence );\n```", "```cpp\nVkClearValue clearValues[2];\nVkRenderPassBeginInfo renderPassBeginInfo {};\nrenderPassBeginInfo.renderPass = renderPass;\nrenderPassBeginInfo.framebuffer = frameBuffer;\nvkBeginCommandBuffer(primaryCommandBuffer, &cmdBufInfo);\n```", "```cpp\nvkCmdBeginRenderPass(primaryCommandBuffer, &renderPassBeginInfo, VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS);\n```", "```cpp\nVkCommandBufferInheritanceInfo inheritanceInfo {};\ninheritanceInfo.renderPass = renderPass;\ninheritanceInfo.framebuffer = frameBuffer;\n```", "```cpp\nVkCommandBufferBeginInfo commandBufferBeginInfo {};\ncommandBufferBeginInfo.flags =\nVK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT;\ncommandBufferBeginInfo.pInheritanceInfo = &inheritanceInfo;\nVkBeginCommandBuffer(secondaryCommandBuffer,\n                     &commandBufferBeginInfo);\n```", "```cpp\nvkCmdSetViewport(secondaryCommandBuffers.background, 0, 1,\n                 &viewport);\nvkCmdSetScissor(secondaryCommandBuffers.background, 0, 1,\n                &scissor);\nvkCmdBindPipeline(secondaryCommandBuffers.background,\n                  VK_PIPELINE_BIND_POINT_GRAPHICS,\n                  pipelines.starsphere);\nVkDrawIndexed(…)\n```", "```cpp\nvkCmdExecuteCommands(primaryCommandBuffer,\n                     commandBuffers.size(),\n                     commandBuffers.data());\n```", "```cpp\nSecondaryDrawTask secondary_tasks[ parallel_recordings ]{ };\nu32 start = 0;\nfor ( u32 secondary_index = 0;\n      secondary_index < parallel_recordings;\n      ++secondary_index ) {\n    SecondaryDrawTask& task = secondary_tasks[\n                              secondary_index ];\n    task.init( scene, renderer, gpu_commands, start,\n               start + draws_per_secondary );\n    start += draws_per_secondary;\n    task_scheduler->AddTaskSetToPipe( &task );\n}\n```", "```cpp\nfor ( u32 secondary_index = 0;\n      secondary_index < parallel_recordings;\n      ++secondary_index ) {\n    SecondaryDrawTask& task = secondary_tasks[\n                              secondary_index ];\n    task_scheduler->WaitforTask( &task );\n    vkCmdExecuteCommands( gpu_commands->vk_command_buffer,\n                          1, &task.cb->vk_command_buffer );\n}\n```"]