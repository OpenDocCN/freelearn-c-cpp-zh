- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Deferred Reclamation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟回收
- en: In [*Chapter 9*](B21071_09.xhtml#_idTextAnchor141), we showed some examples
    of unusual memory allocation mechanisms and how they can be used, including how
    to react to errors to give our programs a form of “second chance” to continue,
    as well as how to use atypical or exotic memory through the mediation of the C++
    language facilities. Then, in [*Chapter 10*](B21071_10.xhtml#_idTextAnchor153),
    we examined arena-based allocation and some variants thereof with an eye on issues
    of speed, determinism, and control over resource consumption.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B21071_09.xhtml#_idTextAnchor141)中，我们展示了某些不寻常的内存分配机制的示例以及如何使用它们，包括如何响应错误以给我们的程序一种“第二次机会”来继续执行，以及如何通过C++语言设施使用非典型或异国内存。然后，在第[*第10章*](B21071_10.xhtml#_idTextAnchor153)中，我们考察了基于竞技场的分配及其一些变体，重点关注速度、确定性和对资源消耗的控制问题。
- en: 'What we will do in the current chapter is something that is not often done
    in C++ but that is common practice in programs written in many other languages,
    particularly those with integrated garbage collectors: we will write mechanisms
    that delay the destruction of dynamically allocated objects at selected moments
    in the execution of a program.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前章节中，我们将进行一些在C++中不常见但在许多其他语言中是常见做法的操作：我们将在程序执行过程中选择特定时刻延迟动态分配对象的销毁。
- en: We will *not* write a proper garbage collector, as that would involve deeper
    involvement in the inner workings of the compiler and impact the programming model
    that makes C++ such a wonderful tool. However, we will put together mechanisms
    for **deferred reclamation**, in the sense that selected objects will deliberately
    be destroyed and see their underlying storage freed together at chosen moments,
    but without necessarily guaranteeing a destruction order. We will, of course,
    not provide an exhaustive overview of techniques to achieve this objective, but
    we will hopefully give you, dear reader, enough “food for thought” to build your
    own deferred reclamation mechanisms should you need to.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将*不会*编写一个真正的垃圾回收器，因为这会涉及到对编译器内部工作的更深入参与，并影响使C++成为如此美妙工具的编程模型。然而，我们将组装**延迟回收**的机制，即选择性地在特定时刻销毁选定的对象，并一起释放其底层存储，但不保证销毁顺序。当然，我们不会提供实现这一目标的技术的详尽概述，但我们希望给你，亲爱的读者，足够的“思考材料”，以便在需要时构建自己的延迟回收机制。
- en: 'The techniques in this chapter can be coupled with those seen in [*Chapter
    10*](B21071_10.xhtml#_idTextAnchor153) to make programs faster and reduce memory
    fragmentation, but we will cover deferred reclamation as a standalone topic to
    make our discourse clearer. After reading this chapter, you will be able to do
    the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的技术可以与第[*第10章*](B21071_10.xhtml#_idTextAnchor153)中看到的技术相结合，以使程序运行更快并减少内存碎片，但我们将单独介绍延迟回收，以使我们的论述更加清晰。阅读本章后，你将能够做到以下几件事情：
- en: Understand the trade-offs associated with deferred reclamation, as there are
    gains to be made but there are also costs involved (this is not a panacea!)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解与延迟回收相关的权衡，因为虽然可以取得收益，但也涉及成本（这并非万能药！）
- en: Implement an almost transparent external wrapper to track the memory that needs
    to be collected
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个几乎透明的外部包装器，以跟踪需要收集的内存
- en: Implement an almost transparent external wrapper to help finalize the objects
    that are subjected to deferred reclamation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个几乎透明的外部包装器，以帮助最终确定那些受到延迟回收的对象
- en: Implement a counting pointer akin to the reference counter of a `std::shared_ptr`
    object in order to identify objects that can be reclaimed at the end of a chosen
    scope
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个类似于`std::shared_ptr`对象的引用计数的计数指针，以识别在所选作用域结束时可以回收的对象
- en: The first step we need to take is to try to understand some problem domains
    where deferred reclamation can be helpful, including its relation to the (different
    but not entirely dissimilar) problem of garbage collection.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取的第一步是尝试理解一些可以从中受益的延迟回收问题领域，包括它与（不同但并非完全不相似的）垃圾收集问题的关系。
- en: Finalization? Reclamation?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最终化？回收？
- en: You will notice that, in this chapter, we will often use the word *finalization*
    instead of the word *destruction*, as we seek to emphasize the fact that the code
    executed at the end of an object’s lifetime (its destructor) is distinct from
    the code that frees its underlying storage. As a bonus, **finalization** is also
    more common in garbage-collected languages, and garbage collection is a cousin
    of the techniques discussed in the sections that follow. Consider finalization
    (without reclamation) as the equivalent of calling the destructor of an object
    (without deallocating the underlying storage).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在本章中，我们经常使用“finalization”（最终化）这个词而不是“destruction”（销毁）这个词，因为我们试图强调这样一个事实：在对象生命周期的末尾（其析构函数）执行的代码与释放其底层存储的代码是不同的。作为额外的好处，**finalization**在垃圾回收语言中更为常见，而垃圾回收是接下来几节讨论的技术的一个近亲。将finalization（不进行回收）视为调用对象析构函数（不释放底层存储）的等价物。
- en: As stated earlier in this chapter, we will name **reclamation** the act of freeing
    the memory for one or many objects at selected moments, for example, at the end
    of a scope or when reaching the end of a program’s execution. Again, this term
    is more common in garbage-collected languages than it is in C++, but the topic
    of this chapter is in some ways closer to what these languages do so, hopefully,
    using similar terms will help develop a common understanding of the ideas and
    techniques involved.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，我们将**回收**定义为在选定的时刻（例如，作用域结束时或程序执行结束时）释放一个或多个对象的内存。再次强调，这个术语在垃圾回收语言中比在C++中更为常见，但本章的主题在某种程度上更接近这些语言所做的工作，因此，使用类似的术语可能有助于形成对涉及的思想和技术的共同理解。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code files for this chapter in the book’s GitHub repository
    here: [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter11](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter11).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub仓库中找到本章的代码文件：[https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter11](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter11)。
- en: What do we mean by deferred reclamation?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们所说的延迟回收是什么意思？
- en: Why would one want to resort to deferred reclamation? That’s a valid question
    indeed, so thanks for asking!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会有人想要求助于延迟回收？这确实是一个合理的问题，所以感谢您提问！
- en: The short answer is that it solves a real problem. Indeed, there are programs
    where it makes sense not to collect objects right after they stop being referred
    to by client code, or where it’s unclear whether they can be collected at all
    until we know for sure the code that could use them concludes. These programs
    are somewhat rare in C++ because of the way we reason about code in our language,
    but they are not rare when looking at the programming world in general.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是，它解决了实际问题。确实，有些程序在对象停止被客户端代码引用后不立即收集对象是有意义的，或者在我们确定可能使用它们的代码结束之前，不清楚它们是否可以被收集。由于我们用C++语言思考代码的方式，这些程序在C++中相对较少，但从一般编程世界的角度来看，它们并不罕见。
- en: 'For example, consider a function in which there are circular references between
    some of the locally allocated objects, or one where there is a tree that one can
    navigate from the root node to its leaf nodes, but in which the leaves of the
    tree also have a reference to its root node. Sometimes, we can determine how to
    destroy the set of objects: for example, in the case of a tree, we could decide
    to start at the root and go down the branches. In other situations, if we know
    that a group of objects will not escape a given function, we can also use the
    knowledge that, at the end of that function, they all can be reclaimed as a group.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个函数，其中一些局部分配的对象之间存在循环引用，或者一个可以从根节点导航到其叶节点的树，但在这个树中，叶节点也指向其根节点。有时，我们可以确定如何销毁一组对象：例如，在树的情况下，我们可以决定从根节点开始，沿着分支向下进行。在其他情况下，如果我们知道一组对象不会逃离给定的函数，我们也可以利用在函数结束时它们都可以作为一个组回收的知识。
- en: If you are familiar with garbage-collected languages, you probably know that
    in most of them, the collector “reclaims the bytes,” freeing the underlying storage
    of the reclaimed objects (and sometimes compacting the memory as it proceeds),
    but does not finalize the objects. One reason for this is that it is difficult
    (in some cases, impossible) for an object in such a language to know which other
    objects still exist in the program since there is no order-of-finalization guarantee…
    and how could there be one if the garbage collector needs to deal with cycles
    of objects referring to each other? Not knowing which other objects still exist
    when an object reaches the end of its lifetime severely limits what finalization
    code can do.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉垃圾回收语言，你可能知道在大多数语言中，回收器“回收字节”，释放回收对象的基础存储（有时在执行过程中还会压缩内存），但不会最终化对象。其中一个原因是，在这样的语言中，一个对象很难（在某些情况下，甚至不可能）知道程序中还存在哪些其他对象，因为没有最终化顺序的保证……如果垃圾回收器需要处理相互引用的对象循环，又怎么可能存在这样的顺序呢？当对象达到其生命周期结束时，不知道哪些其他对象仍然存在，这严重限制了最终化代码能做的事情。
- en: 'The fact that reclamation does not mean finalization in many languages simplifies
    the task of collecting the objects: one can conceptually call `std::free()` or
    some equivalent function and free memory without worrying about the objects therein.
    In languages that do guarantee finalization before reclamation, one often finds
    a class hierarchy rooted in a single, common base class (often called `object`
    or `Object`), which makes it possible to call the equivalent of a `virtual` destructor
    on each object and polymorphically finalize it. Of course, what one can do when
    finalizing an object under such circumstances is limited since the order in which
    objects are finalized is usually unknown.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多语言中，回收并不意味着最终化，这简化了收集对象的任务：从概念上讲，可以调用`std::free()`或一些等效函数来释放内存，而无需担心其中的对象。在那些在回收之前保证最终化的语言中，通常会发现一个以单个公共基类（通常称为`object`或`Object`）为根的类层次结构，这使得可以在每个对象上调用等效的`virtual`析构函数，并多态地最终化它。当然，在这种情况下，在最终化对象时能做的事情是有限的，因为对象最终化的顺序通常是未知的。
- en: What is more common in contemporary garbage-collected languages is to make finalization
    the responsibility of client code and leave the collection to the language itself.
    Such languages often use a special interface (`IDisposable` in C# and `Closeable`
    in Java come to mind) that is implemented by classes for which finalization is
    important (typically, classes that manage external resources), and client code
    will explicitly put in place the required mechanisms for the ordered finalization
    of objects. This moves part of the responsibility over resource management from
    the object itself (as is customary in C++ with the RAII idiom described in [*Chapter
    4*](B21071_04.xhtml#_idTextAnchor062)) to the code that uses it, which is a reminder
    that garbage collectors tend to simplify memory management but, at the same time,
    tend to complicate the management of other resources.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在当代垃圾回收语言中，更常见的是将最终化的责任交给客户端代码，而将回收工作留给语言本身。这样的语言通常使用一个特殊的接口（例如C#中的`IDisposable`和Java中的`Closeable`），由需要最终化的类实现（通常是管理外部资源的类），客户端代码将明确地放置所需的机制以实现对象的有序最终化。这将从对象本身（如C++中的RAII习语所述，见[*第4章*](B21071_04.xhtml#_idTextAnchor062)）将部分资源管理责任转移到使用它的代码上，这提醒我们，垃圾回收器倾向于简化内存管理，但同时也倾向于使其他资源的管理复杂化。
- en: Examples of such client code-driven resource management include a `try` block
    accompanied by a `finally` block, which serves as the locus of cleanup code applied
    regardless of whether the `try` block concluded normally or some `catch` block
    was entered. There are also simplified syntaxes that perform the same thing in
    a less burdensome manner for client code. For example, Java uses try-with blocks
    and implicitly calls `close()` on selected `Closeable` objects at *end of scope*,
    and C# uses `using` blocks likewise in order to implicitly call `Dispose()` on
    selected `IDisposable` objects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的客户端代码驱动的资源管理示例包括一个带有`finally`块的`try`块，无论`try`块是否正常结束或进入了一些`catch`块，它都作为应用清理代码的焦点。还有一些简化语法，以更轻松的方式为客户代码执行相同的事情。例如，Java使用try-with块，并在作用域结束时隐式调用所选`Closeable`对象的`close()`，而C#使用`using`块以类似的方式隐式调用所选`IDisposable`对象的`Dispose()`。
- en: C++ does not have `finally` blocks, nor does it use intrusive techniques such
    as special interfaces known to the language that receive special treatment or
    a common base class to all types. In C++, objects are usually made responsible
    for the management of their resources through the RAII idiom; this leads to a
    different mindset and different programming techniques when compared to other
    popular languages.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 没有提供 `finally` 块，也不使用侵入式技术，例如语言已知并给予特殊处理或作为所有类型公共基类的特殊接口。在 C++ 中，对象通常通过
    RAII 习语来负责管理自己的资源；与其他流行语言相比，这导致了一种不同的思维方式和不同的编程技术。
- en: 'In this chapter, we will face a similar yet different situation to the one
    faced in garbage-collected languages: if we want to use deferred reclamation of
    objects, we cannot guarantee that during destruction, one of the reclaimed objects
    will be able to access other objects reclaimed in the same group, so one should
    not try to do this. On the other hand, the fact that we will choose to apply deferred
    reclamation to *selected* objects (instead of doing so for all objects) means
    that objects not part of this group and known to survive that group’s reclamation
    can still be accessed during the finalization of reclaimed objects. It’s a benefit
    of not having a one-size-fits-all solution, really: C++ is nothing if not versatile,
    as you probably knew even before starting to read this book.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将面临与垃圾回收语言中遇到的情况相似但不同的情况：如果我们想使用对象的延迟回收，我们不能保证在销毁过程中，回收的对象之一能够访问同一组中回收的其他对象，因此不应该尝试这样做。另一方面，我们选择将延迟回收应用于
    *选定* 对象（而不是对所有对象都这样做）的事实意味着，不属于该组且已知能够存活到该组回收的对象，在回收对象的最终化过程中仍然可以访问。这确实是拥有一种一刀切解决方案的好处：如果你在开始阅读这本书之前就知道，C++
    如果不是多才多艺的，那将什么都不是。
- en: Not having a common base class to all types means that we will have to either
    forego finalization (and this can work if we limit ourselves to allocating objects
    of trivially destructible types, something we could validate at compile time)
    or that we will have to find some other way to remember the types of the objects
    we allocated and call the appropriate destructor when the time comes. In this
    chapter, we will show how one can implement both approaches.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 没有所有类型的公共基类意味着我们可能不得不放弃最终化（如果我们限制自己分配具有平凡析构类型的对象，这可以在编译时验证，那么这可以工作）或者我们必须找到其他方法来记住我们分配的对象的类型，并在适当的时候调用相应的析构函数。在这一章中，我们将展示如何实现这两种方法。
- en: Contrary to popular belief, some garbage collectors have been implemented for
    C++. One of the best-known ones (the Boehm-Demers-Weiser collector made by Hans
    Boehm, Alan Demers, and Mark Weiser) does not finalize objects in general but
    allows the registration of chosen finalizers from user code. This is done through
    a facility named `GC_register_finalizer`, but the authors warn users of this facility
    that what such a finalizer can do is limited, as is the case in garbage-collected
    languages (and discussed earlier in this section).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与流行观点相反，一些垃圾回收器已经为 C++ 实现。其中最著名的一个（由 Hans Boehm、Alan Demers 和 Mark Weiser 制作的
    Boehm-Demers-Weiser 收集器）在一般情况下不终结对象，但允许从用户代码中注册选定的终结器。这是通过名为 `GC_register_finalizer`
    的功能完成的，但作者警告用户，这种终结器能做的事情是有限的，就像垃圾回收语言中（以及在本节中之前讨论过）的情况一样。
- en: Further reading
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To explore further, please check [https://www.hboehm.info/gc/](https://www.hboehm.info/gc/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步探索，请查看[https://www.hboehm.info/gc/](https://www.hboehm.info/gc/).
- en: 'We will use other techniques in this chapter. As is always the case in this
    book, the intent is to present ideas from which you can experiment and build the
    kind of solution your code needs. We will show three different examples:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将使用其他技术。正如本书中始终所做的那样，我们的意图是展示你可以从中实验并构建你代码需要的解决方案的想法。我们将展示三个不同的示例：
- en: Code that reclaims selected objects at the end of program execution but does
    not finalize them, limiting deferred reclamation to trivially destructible objects
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序执行结束时回收选定对象但不会终结它们的代码，将延迟回收限制为具有平凡析构类型的对象
- en: Code that reclaims and finalizes selected objects at the end of program execution
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序执行结束时回收和终结选定对象的代码
- en: Code that reclaims and finalizes selected objects at the end of selected scopes
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在选定作用域结束时回收和终结选定对象的代码
- en: We will proceed differently in each case, to give you a broader perspective
    on what can be done. In all three cases, we will store the pointers in a globally
    accessible object. Yes, a singleton, but that’s the correct tool here as we are
    discussing a feature that impacts the whole program. Ready? Here we go!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们将采取不同的方法，以给你更广泛的视角，了解可以做什么。在所有三种情况下，我们将在全局可访问的对象中存储指针。是的，这是一个单例，但在这里这是正确的工具，因为我们正在讨论影响整个程序的功能。准备好了吗？我们开始了！
- en: Things we sometimes do to make examples readable…
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时会做一些事情来使示例更易于阅读…
- en: The code in the following sections can seem strange to some readers. In an effort
    to focus on the deferred reclamation aspects of the code and keep the overall
    presentation readable, I chose not to go into aspects of thread safety, although
    this is essential in contemporary code. In the GitHub repository for this chapter,
    however, you will find both the code presented in this book and the thread-safe
    equivalent for each example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下文中的代码可能会让一些读者感到奇怪。为了专注于代码的延迟回收方面，并保持整体演示的可读性，我选择不深入探讨线程安全方面，尽管这在当代代码中是至关重要的。然而，在本章的
    GitHub 仓库中，你可以找到本书中展示的代码以及每个示例的线程安全等效代码。
- en: Reclamation (without finalization) at the end of the program
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序结束时的回收（不进行最终化）
- en: Our first implementation will provide reclamation but not finalization at the
    end of program execution. For this reason, it will not accept managing objects
    of some type `T` if `T` is not trivially destructible since objects of that type
    have a destructor that might have to be executed to avoid leaks or other problems
    along the way.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一种实现将在程序执行结束时提供回收，但不提供最终化。因此，它不会接受管理类型 `T` 的对象，如果 `T` 不是平凡可析构的，因为该类型的对象可能需要执行析构函数以避免泄漏或其他问题。
- en: 'With this example, as with the others in this chapter, we will start with our
    test code, and then go on to see how the reclamation mechanics are implemented.
    Our test code will go as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本章中的其他示例一样，我们将从我们的测试代码开始，然后继续了解回收机制是如何实现的。我们的测试代码如下：
- en: We will declare two types, `NamedThing` and `Identifier`. The former will not
    be trivially destructible as its destructor will contain user code that prints
    out debugging information, but the latter will be, as it will only contain trivially
    destructible non-static data members and offer no user-provided destructor.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将声明两个类型，`NamedThing` 和 `Identifier`。前者不会是平凡可析构的，因为它的析构函数将包含打印调试信息的用户代码，而后者将是平凡的，因为它只包含平凡可析构的非静态数据成员，并且不提供用户提供的析构函数。
- en: We will provide two `g()` functions. The first one will be commented out as
    it tries to allocate `NamedThing` objects through our reclamation system, something
    that would not compile as type `NamedThing` does not meet our requirement of trivial
    destructibility. The second one will be used as the objects it allocates are of
    a type that meets those requirements.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将提供两个 `g()` 函数。第一个将被注释掉，因为它试图通过我们的回收系统分配 `NamedThing` 对象，这不会编译，因为 `NamedThing`
    类型不符合我们平凡可析构的要求。第二个将被使用，因为它分配的对象符合那些要求。
- en: The `f()`, `g()`, and `main()` functions will construct objects at various levels
    in the call stack of our program. However, the reclaimable objects will only be
    at the end of program execution.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f()`、`g()` 和 `main()` 函数将在我们程序调用栈的各个级别构造对象。然而，可回收的对象将仅在程序执行结束时存在。'
- en: 'The client code in this case would be as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，客户端代码如下：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With this code and the (so far missing) deferred reclamation code, this program
    will print the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码和（到目前为止缺失的）延迟回收代码，这个程序将打印以下内容：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that `f()` allocates and returns an object from which `main()` calls the
    `m()` member function without explicitly resorting to a smart pointer, yet this
    program does not leak memory. Objects allocated through the `gcnew<T>()` function
    are registered in the `GC` object, and the destructor of the `GC` object will
    ensure the registered memory blocks will be deallocated.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`f()` 函数分配并返回一个对象，`main()` 函数通过该对象调用 `m()` 成员函数，而不需要明确使用智能指针，但这个程序并没有内存泄漏。通过
    `gcnew<T>()` 函数分配的对象被注册在 `GC` 对象中，`GC` 对象的析构函数将确保注册的内存块将被释放。
- en: How does `gcnew<T>()` work, then, and why write such a function instead of simply
    overloading `operator new()`? Well, remember that `operator new()` intervenes
    in the overall allocation process as an allocation function – one that trades
    in raw memory, not one that knows what the type of object to create will be. In
    this example, we want (a) memory to be allocated for the new object, (b) the object
    to be constructed (hence the need for the type and the arguments that will be
    passed to the constructor), and (c) to reject types that are not trivially destructible.
    We need to know the type of object to construct, something `operator new()` is
    not aware of.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`gcnew<T>()`是如何工作的，为什么要写这样一个函数而不是简单地重载`operator new()`呢？记住，`operator new()`作为一个分配函数介入了整体分配过程——它交换的是原始内存，而不是知道要创建的对象的类型。在这个例子中，我们想要（a）为新对象分配内存，（b）构造对象（因此需要类型和传递给构造函数的参数），以及（c）拒绝不是简单可销毁的类型。我们需要知道要构造的对象的类型，这是`operator
    new()`所不知道的。
- en: To be able to reclaim the memory for these objects at the end of program execution,
    we will need a form of globally available storage where we will put the pointers
    that have been allocated. We will call such pointers `roots` and store them in
    a singleton of the `GC` type (inspired by the nickname typically associated with
    garbage collectors, even though this is not exactly what we are implementing –
    that name will convey the intent well, and it’s short enough not to get in the
    way).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在程序执行结束时回收这些对象的内存，我们需要一种全局可用的存储形式，我们将把分配的指针放在那里。我们将这样的指针称为“roots”，并将它们存储在`GC`类型的单例中（受垃圾收集器通常使用的昵称的启发，尽管这并不是我们正在实现的功能——这个名称将很好地传达意图，而且足够短，不会妨碍使用）。
- en: The `GC::add_root<T>(args...)` member function will ensure that `T` is a trivially
    destructible type, allocate a chunk of `sizeof(T)` bytes, construct `T(args...)`
    at that location, store an abstract pointer (a `void*`) to that object in `roots`,
    and return a `T*` object to the newly created object. The `gcnew<T>()` function
    will allow user code to interface with `GC::add_root<T>()` in a simplified manner;
    since we want user code to use `gcnew<T>()`, we will qualify `GC::add_root<T>()`
    as `private` and make `gcnew<T>()` a `friend` of the `GC` class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`GC::add_root<T>(args...)`成员函数将确保`T`是一个简单可销毁的类型，分配一个`sizeof(T)`字节的块，在该位置构造`T(args...)`，在`roots`中存储对该对象的抽象指针（一个`void*`），并返回一个指向新创建对象的`T*`对象。`gcnew<T>()`函数将允许用户代码以简化的方式与`GC::add_root<T>()`接口；由于我们希望用户代码使用`gcnew<T>()`，我们将`GC::add_root<T>()`标记为`private`，并将`gcnew<T>()`作为`GC`类的`friend`。'
- en: 'Note that the `GC` class itself is not a generic class (it’s not a template).
    It exposes template member functions, but structurally only stores raw addresses
    (`void*` objects), which makes this class mostly type-agnostic. This all leads
    to the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`GC`类本身不是一个泛型类（它不是一个模板）。它公开了模板成员函数，但在结构上只存储原始地址（`void*`对象），这使得这个类在类型上大部分是无知的。所有这些都导致了以下代码：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: // ...
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '// note: not trivially destructible'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '// note: not trivially destructible'
- en: struct NamedThing {
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: struct NamedThing {
- en: const char *name;
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: const char *name;
- en: 'NamedThing(const char *name) : name{ name } {'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'NamedThing(const char *name) : name{ name } {'
- en: std::print("{} ctor\n", name);
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: std::print("{} ctor\n", name);
- en: '}'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ~NamedThing() {
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ~NamedThing() {
- en: std::print("{} dtor\n", name);
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: std::print("{} dtor\n", name);
- en: '}'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: void g() {
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: void g() {
- en: '[[maybe_unused]] auto p = gcnew<NamedThing>("hi");'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[[maybe_unused]] auto p = gcnew<NamedThing>("hi");'
- en: '[[maybe_unused]] auto q = gcnew<NamedThing>("there");'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[[maybe_unused]] auto q = gcnew<NamedThing>("there");'
- en: '}'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: auto h() {
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: auto h() {
- en: struct X {
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: struct X {
- en: int m() const { return 123; }
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: int m() const { return 123; }
- en: '};'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: return gcnew<X>();
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: return gcnew<X>();
- en: '}'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: auto f() {
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: auto f() {
- en: g();
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: g();
- en: return h();
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: return h();
- en: '}'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int main() {
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: std::print("Pre\n");
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: std::print("Pre\n");
- en: std::print("{}\n", f()->m());
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: std::print("{}\n", f()->m());
- en: std::print("Post\n");
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: std::print("Post\n");
- en: '}'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Pre
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Pre
- en: hi ctor
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: hi ctor
- en: there ctor
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: there ctor
- en: '123'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '123'
- en: Post
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Post
- en: hi dtor
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: hi dtor
- en: there dtor
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: there dtor
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#include <vector>'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <vector>'
- en: '#include <memory>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <memory>'
- en: '#include <print>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <print>'
- en: class GC {
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: class GC {
- en: class GcRoot {
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: class GcRoot {
- en: void *p;
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: void *p;
- en: 'public:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: auto get() const noexcept { return p; }
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: auto get() const noexcept { return p; }
- en: 'GcRoot(void *p) : p{ p } {'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'GcRoot(void *p) : p{ p } {'
- en: '}'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: GcRoot(const GcRoot &) = delete;
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: GcRoot(const GcRoot &) = delete;
- en: GcRoot& operator=(const GcRoot &) = delete;
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: GcRoot& operator=(const GcRoot &) = delete;
- en: virtual void destroy(void *) const noexcept = 0;
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: virtual void destroy(void *) const noexcept = 0;
- en: virtual ~GcRoot() = default;
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: virtual ~GcRoot() = default;
- en: '};'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: // ...
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: // ...
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: 'template <class T> class GcNode : public GcRoot {'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'template <class T> class GcNode : public GcRoot {'
- en: void destroy(void* q) const noexcept override {
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: void destroy(void* q) const noexcept override {
- en: delete static_cast<T*>(q);
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: delete static_cast<T*>(q);
- en: '}'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'public:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: template <class ... Args>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: template <class T, class ... Args>
- en: 'GcNode(Args &&... args) :'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'GcNode(Args &&... args) :'
- en: GcRoot(new T(std::forward<Args>(args)...)) {
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: GcRoot(new T(std::forward<Args>(args)...)) {
- en: '}'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ~GcNode() {
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ~GcNode() {
- en: destroy(get());
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: destroy(get());
- en: '}'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: // ...
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: // ...
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: std::vector<std::unique_ptr<GcRoot>> roots;
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: std::vector<std::unique_ptr<GcRoot>> roots;
- en: GC() = default;
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: GC() = default;
- en: static auto &get() {
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: static auto &get() {
- en: static GC gc;
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: static GC gc;
- en: return gc;
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: return gc;
- en: '}'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: template <class T, class ... Args>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: template <class T, class ... Args>
- en: T *add_root(Args &&... args) {
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: T *add_root(Args &&... args) {
- en: return static_cast<T*>(roots.emplace_back(
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: return static_cast<T*>(roots.emplace_back(
- en: std::make_unique<GcNode<T>>(
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: std::make_unique<GcNode<T>>(
- en: std::forward<Args>(args)...)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: std::forward<Args>(args)...)
- en: )->get());
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: )->get());
- en: '}'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: template <class T, class ... Args>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: template <class T, class ... Args>
- en: friend T* gcnew(Args&&...);
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: friend T* gcnew(Args&&...);
- en: 'public:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: GC(const GC &) = delete;
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: GC(const GC &) = delete;
- en: GC& operator=(const GC &) = delete;
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: GC& operator=(const GC &) = delete;
- en: '};'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: template <class T, class ... Args>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: template <class T, class ... Args>
- en: T *gcnew(Args &&...args) {
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: T *gcnew(Args &&...args) {
- en: return GC::get().add_root<T>(
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: return GC::get().add_root<T>(
- en: std::forward<Args>(args)...
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: std::forward<Args>(args)...
- en: );
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // ...
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: // ...
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '// note: not trivially destructible'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: // 注意：不是简单可销毁的
- en: struct NamedThing {
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: struct NamedThing {
- en: const char *name;
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: const char *name;
- en: 'NamedThing(const char *name) : name{ name } {'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'NamedThing(const char *name) : name{ name } {'
- en: std::cout << name << " ctor" << std::endl;
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << name << " ctor" << std::endl;
- en: '}'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ~NamedThing() {
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ~NamedThing() {
- en: std::cout << name << " dtor" << std::endl;
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << name << " dtor" << std::endl;
- en: '}'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: auto g() {
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: auto g() {
- en: auto _ = scoped_collect{};
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: auto _ = scoped_collect{};
- en: '[[maybe_unused]] auto p = gcnew<NamedThing>("hi");'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[[maybe_unused]] auto p = gcnew<NamedThing>("hi");'
- en: auto q = gcnew<NamedThing>("there");
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: auto q = gcnew<NamedThing>("there");
- en: return q;
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: return q;
- en: '} // a reclamation will occur here'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '} // 在这里将发生回收'
- en: auto h() {
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: auto h() {
- en: struct X {
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: struct X {
- en: int m() const { return 123; }
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: int m() const { return 123; }
- en: '};'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: return gcnew<X>();
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: return gcnew<X>();
- en: '}'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: auto f() {
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: auto f() {
- en: auto _ = scoped_collect{};
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: auto _ = scoped_collect{};
- en: auto p = g();
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: auto p = g();
- en: std::cout << '\"' << p->name << '\"' << std::endl;
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: std::cout << '\"' << p->name << '\"' << std::endl;
- en: '} // a reclamation will occur here'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '} // 在这里将发生回收'
- en: int main() {
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: using namespace std;
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: using namespace std;
- en: cout << "Pre" << endl;
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: cout << "Pre" << endl;
- en: f();
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: f();
- en: cout << h()->m() << endl;
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: cout << h()->m() << endl;
- en: cout << "Post" << endl;
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: cout << "Post" << endl;
- en: '} scoped_collect object lives will lead to the reclamation of all objects allocated
    through gcnew<T>() that are not referenced anymore at that point; this holds regardless
    of whether they were allocated in that scope or somewhere else in the program.
    The intent here is that the end of such as scope is a point where we are willing
    to “pay” the time and effort required to collect a group of objects. Do not use
    a scoped_collect object in a scope where either speed or deterministic behavior
    is of the essence!'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '} scoped_collect对象的生命周期结束将导致通过gcnew<T>()分配且在该点不再被引用的所有对象的回收；这无论它们是在该作用域内还是程序的其他地方分配的都成立。这里的意图是，作用域的结束是一个我们愿意“付出”收集一组对象所需的时间和精力的点。不要在速度或确定性行为至关重要的作用域中使用scoped_collect对象！'
- en: 'Executing this code, we end up with the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码，我们最终得到以下结果：
- en: '[PRE8]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see, objects that are still being referred to remain available, and
    objects that are not being referred to are collected either when the destructor
    of a `scoped_collect` object is called, or at program termination if there are
    still some reclaimable objects in the program at that point.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，仍然被引用的对象仍然可用，而不再被引用的对象要么在`scoped_collect`对象的析构函数被调用时回收，要么在程序终止时回收，如果此时程序中仍有可回收的对象。
- en: 'The `scoped_collect` type itself is very simple, its main role being to interact
    with the `GC` global object. It is simply a non-copiable, non-movable RAII object
    that invokes a reclamation at the end of its lifetime:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoped_collect`类型本身非常简单，其主要作用是与`GC`全局对象交互。它是一个不可复制、不可移动的RAII对象，在其生命周期结束时执行回收：'
- en: '[PRE9]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How does this whole infrastructure work? Let’s take it step by step. We will
    inspire ourselves from the previous sections of this chapter, where we initially
    collect all objects at the end of program execution, and then add finalization
    for these objects. The novelty in this section is that we will add the possibility
    of collecting objects at various times in program execution and implement the
    required code to track references to objects.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 整个基础设施是如何工作的？让我们一步一步来。我们将从本章前面的部分汲取灵感，在那里我们最初在程序执行结束时收集所有对象，然后为这些对象添加终结。本节的新颖之处在于，我们将添加在程序执行过程中的不同时间收集对象的可能性，并实现跟踪对象引用所需的代码。
- en: 'To track references to objects, we will use objects of the `counting_ptr<T>`
    type:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪对象的引用，我们将使用 `counting_ptr<T>` 类型的对象：
- en: '[PRE10]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As can be seen, we can (and do!) implement this type solely through standard
    tools. Note that the `count` data member is a pointer as it might be shared between
    instances of `counting_ptr<T>`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，我们可以（并且确实！）仅通过标准工具实现此类。请注意，`count` 数据成员是一个指针，因为它可能在 `counting_ptr<T>` 的实例之间共享：
- en: '[PRE11]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that the relational operators are in place, we can implement copy and move
    semantics for our type:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关系运算符已经就位，我们可以为我们的类型实现拷贝和移动语义：
- en: '[PRE12]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Instead of destroying the counter and the pointee like a `shared_ptr<T>` would,
    `counting_ptr<T>` will delete the counter but “mark” the pointee, making it a
    candidate for ulterior reclamation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `shared_ptr<T>` 相似，`counting_ptr<T>` 不会像销毁计数器和指针一样销毁，而是删除计数器但“标记”指针，使其成为后续回收的候选对象。
- en: 'The general `GC`, `GC::GcRoot`, and `GC::GcNode<T>` approach from the previous
    section remains, but is enhanced as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 上节中提到的通用 `GC`、`GC::GcRoot` 和 `GC::GcNode<T>` 方法仍然保留，但如下进行了增强：
- en: The `roots` container couples a `unique_ptr<GcRoot>` with a “mark” data member
    of type `bool`
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roots` 容器将 `unique_ptr<GcRoot>` 与一个类型为 `bool` 的“标记”数据成员相结合'
- en: The `make_collectable(p)` member function marks the root associated with the
    `p` pointer as collectable
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make_collectable(p)` 成员函数将 `p` 指针关联的根标记为可回收'
- en: The `collect()` member functions reclaim all the roots that are marked as collectable
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collect()` 成员函数回收所有标记为可回收的根'
- en: What this implementation does is (a) associate a Boolean mark (collect or do
    not collect) with each reclaimable pointer, (b) use `counting_ptr<T>` object with
    each `T*` to keep track of how each pointee is being used, and (c) collect reclaimable
    pointees as a group whenever a collection request arrives. The easiest way to
    request such a collection is to reach the destructor of a `scoped_collect` object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现所做的（a）是给每个可回收指针关联一个布尔标记（回收或不回收），（b）使用 `counting_ptr<T>` 对象与每个 `T*` 一起跟踪每个指针的使用情况，以及（c）每当收到回收请求时，将可回收指针作为一组进行收集。请求此类收集的最简单方法是通过
    `scoped_collect` 对象的析构函数。
- en: 'The code for this somewhat more sophisticated version is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个稍微复杂一些的版本的代码如下：
- en: '[PRE13]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The collection functions in this case would be as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，收集函数如下：
- en: '[PRE14]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, dear reader, this last example would benefit from several optimizations,
    but it works and is meant to be simple enough to understand and improve.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，亲爱的读者，这个最后的例子可以从几个优化中受益，但它可以工作，并且旨在足够简单，以便理解和改进。
- en: We now know it is possible to reclaim objects in groups in C++, as it is in
    other popular languages. It might not be idiomatic C++ code, but deferred reclamation
    can be achieved with reasonable effort, on an opt-in basis. Not bad!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，在 C++ 中，像在其他流行语言中一样，可以以组的形式回收对象。这可能不是典型的 C++ 代码，但通过合理的努力，可以以可选的方式实现延迟回收。还不错！
- en: Summary
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter took us in the territory of deferred reclamation, a territory that’s
    unfamiliar to many C++ programmers. We saw ways in which we can reclaim objects
    in groups at specific points in a program, discussed restrictions on what could
    be done when reclaiming such objects, and examined various techniques to finalize
    objects before freeing their associated memory storage.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本章带我们进入了延迟回收的领域，这对许多 C++ 程序员来说是不熟悉的。我们看到了在程序中的特定点以组的形式回收对象的方法，讨论了在回收此类对象时可能进行的限制，并检查了在释放相关内存存储之前最终化对象的各种技术。
- en: We are now ready to look at how memory management interacts with C++ containers,
    an important topic that will occupy us in the next three chapters.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看内存管理如何与 C++ 容器交互，这是一个重要的主题，将在接下来的三章中占据我们的注意力。
- en: Indeed, we could write containers that handle memory explicitly, but in general,
    that would be counterproductive (for example, if we tied `std::vector<T>` to `new`
    and `delete`, how could `std::vector<T>` handle some type `T` for which allocation
    and deallocation have to be done through other means?).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可以编写处理内存的容器，但通常这会适得其反（例如，如果我们把 `std::vector<T>` 与 `new` 和 `delete` 绑定，`std::vector<T>`
    如何处理需要通过其他方式分配和释放的类型 `T`？）。
- en: There are, of course, quite a few ways to get there. Want to know some of them?
    Let’s take a deep breath and dive in…
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，到达那里的方法有很多。想知道一些吗？让我们深呼吸，深入探讨…
- en: '[PRE15]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Part 4: Writing Generic Containers (and a Bit More)'
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：编写泛型容器（以及更多内容）
- en: In this part, we will focus on writing efficient generic containers, doing so
    through explicit memory management, then through implicit memory management, and
    finally, through allocators, under the various guises these types have held over
    the years. Leveraging our deeper understanding of memory management techniques
    and facilities, we will express two types of containers (one that uses contiguous
    memory and another that uses linked nodes) in ways that can sometimes be much
    more efficient than a simpler, more naïve implementation would be. We end this
    part with a look to the near future in memory management with C++.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们将专注于编写高效的泛型容器，通过显式内存管理来实现，然后通过隐式内存管理，最后通过分配器，在多年来的各种形式下。利用我们对内存管理技术和设施的更深入理解，我们将以比简单、更直观的实现方式更有效的方式表达两种类型的容器（一种使用连续内存，另一种使用链式节点）。我们以对C++内存管理近未来展望结束本部分。
- en: 'This part has the following chapters:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 12*](B21071_12.xhtml#_idTextAnchor172), *Writing Generic Containers
    with Explicit Memory Management*'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B21071_12.xhtml#_idTextAnchor172), *使用显式内存管理编写泛型容器*'
- en: '[*Chapter 13*](B21071_13.xhtml#_idTextAnchor187), *Writing Generic Containers
    with Implicit Memory Management*'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B21071_13.xhtml#_idTextAnchor187), *使用隐式内存管理编写泛型容器*'
- en: '[*Chapter 14*](B21071_14.xhtml#_idTextAnchor199), *Writing Generic Containers
    with Allocator Support*'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B21071_14.xhtml#_idTextAnchor199), *使用分配器支持的泛型容器编写*'
- en: '[*Chapter 15*](B21071_15.xhtml#_idTextAnchor213), *Contemporary Issues*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B21071_15.xhtml#_idTextAnchor213), *当代问题*'
