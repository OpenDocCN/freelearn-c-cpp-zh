- en: Loading Secure Web Pages with HTTPS and OpenSSL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTTPS 和 OpenSSL 加载安全网页
- en: In this chapter, we'll learn how to initiate secure connections to web servers
    using **Hypertext Transfer Protocol Secure** (**HTTPS**). HTTPS provides several
    benefits over HTTP. HTTPS gives an authentication method to identify servers and
    detect impostors. It also protects the privacy of all transmitted data and prevents
    interceptors from tampering with or forging transmitted data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将学习如何使用 **超文本传输协议安全**（**HTTPS**）来建立与 Web 服务器的安全连接。HTTPS 相比 HTTP 提供了多项优势。HTTPS
    提供了一种身份验证方法来识别服务器并检测冒名者。它还保护了所有传输数据的安全性，防止拦截者篡改或伪造传输数据。
- en: In HTTPS, communication is secured using **Transport Layer Security** (**TLS**).
    In this chapter, we'll learn how to use the popular OpenSSL library to provide
    TLS functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTPS 中，通信是通过 **传输层安全性**（**TLS**）来加密的。在本章中，我们将学习如何使用流行的 OpenSSL 库来提供 TLS 功能。
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Background information about HTTPS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTPS 的背景信息
- en: Types of encryption ciphers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密算法类型
- en: How servers are authenticated
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器如何进行身份验证
- en: Basic OpenSSL usage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本OpenSSL使用
- en: Creating a simple HTTPS client
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建简单的 HTTPS 客户端
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example programs from this chapter can be compiled using any modern C compiler.
    We recommend MinGW for Windows and GCC for Linux and macOS. You also need to have
    the OpenSSL library installed. See [Appendices B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml), *Setting
    Up Your C Compiler on Windows*, [Appendices C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml), *Setting
    Up Your C Compiler on Linux*, and [Appendices D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml), *Setting
    Up Your C Compiler on macOS,* for compiler setup and OpenSSL installation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例程序可以使用任何现代 C 编译器编译。我们推荐 Windows 使用 MinGW，Linux 和 macOS 使用 GCC。你还需要安装 OpenSSL
    库。请参阅附录 B [在 Windows 上设置您的 C 编译器](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml)、附录
    C [在 Linux 上设置您的 C 编译器](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml) 和附录 D [在 macOS
    上设置您的 C 编译器](632db68e-0911-4238-a2be-bd1aa5296120.xhtml)，了解编译器和 OpenSSL 的安装设置。
- en: The code for this book can be found at [https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码可以在 [https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C)
    找到。
- en: 'From the command line, you can download the code for this chapter with the
    following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，你可以使用以下命令下载本章的代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each example program in this chapter runs on Windows, Linux, and macOS. While
    compiling on Windows, each example program requires linking with the Winsock library.
    This can be accomplished by passing the `-lws2_32` option to `gcc`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的每个示例程序都可在 Windows、Linux 和 macOS 上运行。在 Windows 上编译时，每个示例程序都需要与 Winsock 库链接。这可以通过向
    `gcc` 传递 `-lws2_32` 选项来实现。
- en: Each example also needs to be linked against the OpenSSL libraries, `libssl.a` and
    `libcrypto.a`. This is accomplished by passing `-lssl -lcrypto` to `gcc`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例还需要链接到 OpenSSL 库，`libssl.a` 和 `libcrypto.a`。这可以通过向 `gcc` 传递 `-lssl -lcrypto`
    来实现。
- en: We provide the exact commands needed to compile each example as it is introduced.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了编译每个示例所需的精确命令。
- en: All of the example programs in this chapter require the same header files and
    C macros that we developed in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*. For brevity, we put these statements in a
    separate header file, `chap09.h`, which we can include in each program. For an
    explanation of these statements, please refer to [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例程序都需要与我们在第 2 章 [掌握套接字 API](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)
    中开发的相同头文件和 C 宏。为了简洁，我们将这些语句放在一个单独的头文件 `chap09.h` 中，我们可以在每个程序中包含它。有关这些语句的解释，请参阅第
    2 章 [掌握套接字 API](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)。
- en: 'The content of `chap09.h` begins by including the necessary networking header
    files. The code for this follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`chap09.h` 文件的内容首先包含必要的网络头文件。相应的代码如下：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also define some macros to assist with writing portable code like so:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一些宏来帮助编写可移植的代码，如下所示：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, `chap09.h` includes some additional headers, including the headers
    for the OpenSSL library. This is shown in the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`chap09.h` 包含了一些额外的头文件，包括 OpenSSL 库的头文件。以下代码展示了这一点：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: HTTPS overview
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS 概述
- en: HTTPS provides security to HTTP. We covered HTTP in [Chapter 6](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml),
    *Building a Simple Web Client*. HTTPS secures HTTP by using TLS over TCP on port `443`.
    TLS is a protocol that can provide security to any TCP connection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS为HTTP提供安全。我们在[第6章](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml)“构建简单的Web客户端”中介绍了HTTP。HTTPS通过在端口`443`上使用TCP的TLS来保护HTTP。TLS是一种可以为任何TCP连接提供安全的协议。
- en: TLS is the successor to **Secure Socket Layer** (**SSL**), an earlier protocol
    also used by HTTPS. TLS and SSL are compatible, and most of the information in
    this chapter also applies to SSL. Generally, establishing an HTTPS connection
    involves the client and server negotiating which protocol to use. The ideal outcome
    is that the client and server agree on the most secure, mutually supported protocol
    and cipher.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**TLS**是**安全套接字层**（**SSL**）的继任者，SSL是一个较早的协议，也被HTTPS使用。TLS和SSL是兼容的，本章的大部分信息也适用于SSL。通常，建立HTTPS连接涉及客户端和服务器协商使用哪种协议。理想的结果是客户端和服务器就使用最安全、相互支持的协议和密钥协商一致。'
- en: 'When we talk about protocol security, we are generally looking for the following
    three things:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论协议安全时，我们通常寻找以下三个要素：
- en: '**Authentication**: We need a way to prevent impostors from posing as legitimate
    communication partners. TLS provides peer authentication methods for this reason.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：我们需要一种方法来防止冒充者伪装成合法的通信伙伴。TLS提供对等身份验证方法来解决这个问题。'
- en: '**Encryption**: TLS uses encryption to obfuscate transmitted data. This prevents
    an eavesdropper from correctly interpreting intercepted data.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密**：TLS使用加密来混淆传输的数据。这阻止了窃听者正确解释截获的数据。'
- en: '**Integrity**: TLS also ensures that received data has not been tampered with
    or otherwise forged.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：TLS还确保接收到的数据没有被篡改或伪造。'
- en: '**HTTP** is most commonly used to transmit web pages. The text on a web page
    is first encoded as **Hypertext Markup Language** (**HTML**). **HTML** provides
    formatting, layout, and styling to web pages. **HTTP** is then used to transmit
    the **HTML**, and **HTTP** itself is transmitted over a **TCP** connection.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP**最常用于传输网页。网页上的文本首先被编码为**超文本标记语言**（**HTML**）。**HTML**为网页提供格式化、布局和样式。然后使用**HTTP**传输**HTML**，而**HTTP**本身是通过**TCP**连接传输的。'
- en: 'Visually, an **HTTP** session is encapsulated like the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，一个**HTTP**会话封装如下：
- en: '![](img/f6ee2b1c-e5bf-49e0-bdf8-c5cb6b83cdfe.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6ee2b1c-e5bf-49e0-bdf8-c5cb6b83cdfe.png)'
- en: '**TLS** works inside TCP to provide a secure communication channel. HTTPS is
    then basically the same as the **HTTP** protocol, but it is sent inside a **TLS**
    channel.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**TLS**在TCP内部工作，以提供安全的通信通道。然后HTTPS基本上与**HTTP**协议相同，但它是在**TLS**通道中发送的。'
- en: 'Visually, HTTPS is encapsulated in the following manner:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，HTTPS是以以下方式封装的：
- en: '![](img/691de8da-d33f-47a0-9d2f-a9b21f640a45.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/691de8da-d33f-47a0-9d2f-a9b21f640a45.png)'
- en: Of course, the same abstraction still applies if **HTTP** is used to transmit
    an image, video, or other data instead of **HTML**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果使用**HTTP**传输图像、视频或其他数据而不是**HTML**，相同的抽象仍然适用。
- en: Do keep in mind that these abstractions are accurate at the conceptual level,
    but some details transcend layers. For example, some HTTPS headers are used to
    refer to security parameters of how **TLS** should be applied. In general, though,
    it is reasonable to think of **TLS** as securing the **TCP** connection used by
    HTTPS.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必记住，这些抽象在概念层面上是准确的，但有些细节超越了层次。例如，一些HTTPS头信息用于引用**TLS**应用的安全参数。不过，总的来说，将**TLS**视为保护HTTPS使用的**TCP**连接是合理的。
- en: Although **TLS** is most commonly used for HTTPS security, **TLS** is also used
    to secure many other **TCP**-based protocols. The email protocol, SMTP, which
    we covered in [Chapter 8](47e209f2-0231-418c-baef-82db74df8c29.xhtml), *Making
    Your Program Send Email*, is also commonly secured by **TLS**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**TLS**最常用于HTTPS安全，但**TLS**也被用于保护许多基于**TCP**的其他协议。我们在[第8章](47e209f2-0231-418c-baef-82db74df8c29.xhtml)“让你的程序发送电子邮件”中提到的电子邮件协议SMTP也通常通过**TLS**进行加密。
- en: Before going into further detail about using **TLS**, it is useful to understand
    some necessary background information on encryption.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步详细介绍使用**TLS**之前，了解一些加密的必要背景信息是有用的。
- en: Encryption basics
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密基础
- en: '**Encryption** is a method of encoding data so that only authorized parties
    can access it. Encryption does not prevent interception or interference, but it
    denies the original data to a would-be attacker.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密**是一种编码数据的方法，只有授权的当事人才能访问它。加密不能防止拦截或干扰，但它阻止了潜在的攻击者访问原始数据。'
- en: Encryption algorithms are called **ciphers**. An encryption cipher takes unencrypted
    data as input, referred to as **plaintext**. The cipher produces encrypted data,
    called **ciphertext**, as its output. The act of converting plaintext into ciphertext
    is called encryption, and the act of reversing it back is called **decryption**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 加密算法被称为**密码**。加密密码将未加密的数据作为输入，称为**明文**。密码产生加密数据，称为**密文**，作为其输出。将明文转换为密文的过程称为加密，将其反向转换的过程称为**解密**。
- en: Modern ciphers use keys to control the encryption and decryption of data. Keys
    are typically relatively short, pseudo-random data sequences. Ciphertext encrypted
    with a given key cannot be decrypted without the proper key.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现代密码使用密钥来控制数据的加密和解密。密钥通常是相对较短的伪随机数据序列。使用给定密钥加密的密文，如果没有正确的密钥，则无法解密。
- en: Broadly, there are two categories of ciphers—symmetric and asymmetric. A symmetric
    cipher uses the same key for both encryption and decryption, while an asymmetric
    cipher uses two different keys.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 广义上，密码分为两大类——对称密码和非对称密码。对称密码在加密和解密时使用相同的密钥，而非对称密码则使用两个不同的密钥。
- en: Symmetric ciphers
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称密码
- en: 'The following diagram illustrates a symmetric cipher:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了对称密码：
- en: '![](img/ca2c2000-2b21-4918-8248-b0cf74dae2a8.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca2c2000-2b21-4918-8248-b0cf74dae2a8.png)'
- en: In the preceding diagram, the plaintext **Hello!** is encrypted using a symmetric
    cipher. A secret key is used with the cipher to produce a ciphertext. This ciphertext
    can then be transmitted over an insecure channel, and eavesdroppers cannot decipher
    it without knowledge of the secret key. The privileged receiver of the ciphertext
    uses the decryption algorithm and secret key to convert it back into plaintext.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，明文**Hello!**使用对称密码进行加密。使用密钥与密码结合产生密文。这个密文可以传输到不安全的通道上，窃听者如果没有知道密钥，就无法解密它。密文的特权接收者使用解密算法和密钥将其转换回明文。
- en: 'Some symmetric ciphers in general use (not just for TLS) are the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一些通用对称密码（不仅限于TLS）如下：
- en: '**American Encryption Standard** (**AES**), also known as **Rijndael**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**美国加密标准**（**AES**），也称为**Rijndael**'
- en: Camellia
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Camellia
- en: '**Data Encryption Standard** (**DES**)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据加密标准**（**DES**）'
- en: Triple DES
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三重DES
- en: '**International Data Encryption Algorithm** (**IDEA**)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**国际数据加密算法**（**IDEA**）'
- en: QUAD
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QUAD
- en: RC4
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RC4
- en: Salsa20, Chacha20
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Salsa20, Chacha20
- en: '**Tiny Encryption Algorithm** (**TEA**)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小型加密算法**（**TEA**）'
- en: One issue with symmetric encryption is that the same key must be known to both
    the sender and receiver. Generating and transmitting this key securely poses a
    problem. How can the key be sent between parties if they don't already have a
    secure communication channel? If they do already have a secure communication channel,
    why is encryption needed in the first place?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密的一个问题是，相同的密钥必须为发送者和接收者所知。生成和传输这个密钥的安全性问题。如果双方没有安全的通信渠道，如何将密钥在双方之间发送？如果他们已经有了安全的通信渠道，那么为什么还需要加密呢？
- en: Key exchange algorithms attempt to address these problems. Key exchange algorithms
    work by allowing both communicating parties to generate the same secret key. In
    general, the parties first agree on a public, non-secret key. Then, each party
    generates its own secret key and combines it with the public key. These combined
    keys are exchanged. Each party then adds its own secret to the combined keys to
    arrive at a combined, secret key. This combined, secret key is then known to both
    parties, but not derivable by an eavesdropper.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥交换算法试图解决这些问题。密钥交换算法通过允许双方通信方生成相同的秘密密钥来工作。一般来说，双方首先同意一个公开的非秘密密钥。然后，每一方生成自己的秘密密钥并将其与公开密钥结合。这些组合密钥被交换。然后，每一方将其自己的秘密添加到组合密钥中，以得到一个组合的秘密密钥。这个组合的秘密密钥然后为双方所知，但窃听者无法推导出来。
- en: The most common key exchange algorithm in use today is the **Diffie-Hellman
    key exchange algorithm**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最常用的密钥交换算法是**Diffie-Hellman密钥交换算法**。
- en: While key exchange algorithms are resistant against eavesdroppers, they are
    not resilient to interception. In the case of interception, an attacker could
    stand in the middle of a key exchange, while posing as each corresponding party.
    This is called a **man-in-the-middle attack**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然密钥交换算法对窃听者具有抵抗力，但它们对拦截没有抵抗力。在拦截的情况下，攻击者可以站在密钥交换的中间，同时假装是相应的每一方。这被称为**中间人攻击**。
- en: Asymmetric ciphers can be used to address some of these problems.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称密码可以用来解决这些问题中的某些问题。
- en: Asymmetric ciphers
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非对称密码
- en: '**Asymmetric encryption**, also known as **public-key encryption**, attempts
    to solve the key exchange and authentication problems of symmetric encryption.
    With asymmetric encryption, two keys are used. One key can encrypt data, while
    the other key can decrypt it. These keys are generated together and related mathematically.
    However, deriving one key from the other after the fact is not possible.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**非对称加密**，也称为 **公钥加密**，试图解决对称加密中的密钥交换和认证问题。在非对称加密中，使用两个密钥。一个密钥可以加密数据，而另一个密钥可以解密它。这些密钥一起生成，并且数学上相关。然而，在事后从其中一个密钥推导出另一个密钥是不可能的。'
- en: 'The following diagram shows an asymmetric cipher:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一个非对称加密算法：
- en: '![](img/0ed9f4d0-7f5d-4e39-9a6c-3e3e5a476bbc.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0ed9f4d0-7f5d-4e39-9a6c-3e3e5a476bbc.png)'
- en: Establishing a secure communication channel with asymmetric encryption is easier.
    Each party can generate its own asymmetric encryption keys. The encryption key
    can then be transmitted without the worry of interception, while the decryption
    key is kept private. In this scheme, these keys are referred to as the **Public
    Key** and the **Private Key**, respectively.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非对称加密建立安全的通信通道更为简单。每一方都可以生成自己的非对称加密密钥。加密密钥可以无担忧地传输，而解密密钥则保持私密。在这个方案中，这些密钥分别被称为
    **公钥** 和 **私钥**。
- en: The **Rivest-Shamir-Adleman** (**RSA**) cipher is one of the first public-key
    ciphers and is widely used today. Newer **elliptic-curve cryptography** (**ECC**)
    algorithms promise greater efficiency and are quickly gaining market share.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rivest-Shamir-Adleman** (**RSA**) 加密算法是第一种公钥加密算法之一，并且至今仍被广泛使用。较新的 **椭圆曲线加密**
    (**ECC**) 算法承诺更高的效率，并且正在迅速增加市场份额。'
- en: Asymmetric ciphers are also used to implement digital signatures. A digital
    signature is used to verify the authenticity of data. Digital signatures are created
    by using a private key to generate a signature for a document. The public key
    can then be used to verify that the document was signed by the holder of the private
    key.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密也用于实现数字签名。数字签名用于验证数据的真实性。数字签名是通过使用私钥为文档生成签名来创建的。然后可以使用公钥来验证文档是否由私钥持有者签署。
- en: 'The following diagram illustrates a digital signing and verifying process:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了数字签名和验证过程：
- en: '![](img/9657cca3-eed9-47bb-a65a-2ad088b23853.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9657cca3-eed9-47bb-a65a-2ad088b23853.png)'
- en: TLS uses a combination of these methods to achieve security.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 使用这些方法的组合来实现安全性。
- en: How TLS uses ciphers
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS 使用加密算法的方式
- en: Digital signatures are essential in TLS; they are used to authenticate servers.
    Without digital signatures, a TLS client wouldn't be able to differentiate between
    an authentic server and an impostor.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名在 TLS 中至关重要；它们用于验证服务器。如果没有数字签名，TLS 客户端将无法区分真实服务器和冒充者。
- en: TLS can also use digital signatures to authenticate the client, although this
    is much less common in practice. Most web applications either don't care about
    client authentication, or use other simpler methods, such as passwords.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 也可以使用数字签名来验证客户端，尽管在实践中这并不常见。大多数网络应用要么不关心客户端认证，要么使用其他更简单的方法，例如密码。
- en: In theory, asymmetric encryption could be used to protect an entire communication
    channel. However, in practice, modern asymmetric ciphers are inefficient and only
    able to protect small amounts of data. For this reason, symmetric ciphers are
    preferred whenever possible. TLS uses asymmetric ciphers only to authenticate
    the server. TLS uses a key exchange algorithm and symmetric ciphers to protect
    the actual communication.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，非对称加密可以用来保护整个通信通道。然而，在实践中，现代的非对称加密算法效率低下，只能保护少量数据。因此，在可能的情况下，首选对称加密算法。TLS
    仅使用非对称加密来验证服务器。TLS 使用密钥交换算法和对称加密来保护实际的通信。
- en: Vulnerabilities are found for encryption algorithms all the time. It is, therefore,
    imperative that TLS connections are able to select the best algorithms that are
    mutually supported by both parties. This is done using **cipher suites**. A cipher
    suite is a list of algorithms, generally a **key exchange algorithm**, a **bulk
    encryption algorithm**, and a **message authentication algorithm** (**MAC**).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加密算法，总是会发现漏洞。因此，TLS 连接能够选择双方都支持的最好算法至关重要。这是通过 **加密套件** 来实现的。加密套件是一系列算法，通常包括
    **密钥交换算法**、**批量加密算法** 和 **消息认证算法** (**MAC**)。
- en: When a TLS connection is first established, the TLS client sends a list of preferred **cipher
    suites** to the server. The TLS server will select one of these cipher suites
    to be used for the connection. If the server doesn't support any of the cipher
    suites given by the client, then a secure TLS connection cannot be established.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当TLS连接首次建立时，TLS客户端向服务器发送一个首选的**加密套件**列表。TLS服务器将从中选择一个用于连接的加密套件。如果服务器不支持客户端提供的任何加密套件，那么将无法建立安全的TLS连接。
- en: With some background information about security out of the way, we can discuss
    TLS in more detail.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完一些关于安全性的背景信息之后，我们可以更详细地讨论TLS。
- en: The TLS protocol
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS协议
- en: After a TCP connection is established, the TLS handshake is initiated by the
    client. The client sends a number of specifications to the server, including which
    versions of SSL/TLS it is running, which cipher suites it supports, and which
    compression methods it would like to use.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP连接建立之后，TLS握手由客户端发起。客户端向服务器发送一系列规范，包括它正在运行的SSL/TLS版本、它支持的加密套件以及它希望使用的压缩方法。
- en: The server selects the highest mutually supported version of SSL/TLS to use.
    It also chooses a cipher suite and compression method from the choices given by
    the client.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器选择SSL/TLS协议中双方都支持的最高版本来使用。它还从客户端提供的选项中选择一个加密套件和压缩方法。
- en: If the client and server do not support any cipher suite in common, then no
    TLS connection can be established. This is not uncommon when using very old browsers
    with newer servers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端和服务器都不支持任何共同的加密套件，那么将无法建立TLS连接。当使用非常旧的浏览器与较新的服务器一起使用时，这种情况并不少见。
- en: After the basic setup is done, the server sends the client its certificate.
    This is used by the client to verify that it's connected to a legitimate server.
    We'll discuss more on certificates in the next section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本设置完成后，服务器向客户端发送其证书。客户端使用这个证书来验证它是否连接到了合法的服务器。我们将在下一节中更详细地讨论证书。
- en: Once the client has verified that the server really is who it claims to be,
    a key exchange is initiated. After key exchange completes, both the client and
    server have a shared secret key. All further communication is encrypted using
    this key and their chosen symmetric cipher.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端验证了服务器确实是它所声称的身份，就会发起密钥交换。密钥交换完成后，客户端和服务器都拥有一个共享的秘密密钥。所有后续的通信都使用这个密钥和它们选择的对称加密算法进行加密。
- en: Certificates are used to verify server identities with digital signatures. Let's
    explore how they work next.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 证书用于通过数字签名验证服务器身份。接下来让我们探讨它们是如何工作的。
- en: Certificates
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 证书
- en: Each HTTPS server uses one or more certificates to verify their identity. This
    certificate must either be trusted by the client itself or trusted by a third
    party that the client trusts. In common usages, such as web browsers, it's not
    really possible to list all trusted certificates. For this reason, it's most common
    to validate certificates by verifying that a trusted third party trusts them.
    This trust is proven using digital signatures.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTPS服务器使用一个或多个证书来验证其身份。这个证书必须要么被客户端本身信任，要么被客户端信任的第三方信任。在常见的用法中，例如在网页浏览器中，实际上不可能列出所有受信任的证书。因此，最常见的方法是通过验证受信任的第三方是否信任它们来验证证书。这种信任是通过数字签名来证明的。
- en: For example, a popular digital certificate authority is DigiCert Inc. Suppose
    that you trust DigiCert Inc. and have stored a certificate from them locally;
    you then connect to a website, `example.com`. You may not trust `example.com`,
    because you haven't seen their certificate before. However, `example.com` shows
    you that their certificate has been digitally signed by the DigiCert Inc. certificate
    you do trust. Therefore, you trust `example.com` website's certificate too.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个流行的数字证书颁发机构是DigiCert Inc. 假设你信任DigiCert Inc. 并已将他们提供的证书存储在本地；然后你连接到网站 `example.com`。你可能不信任
    `example.com`，因为你之前没有见过他们的证书。然而，`example.com` 向你展示，他们的证书已被你信任的DigiCert Inc. 证书数字签名。因此，你也信任
    `example.com` 网站的证书。
- en: In practice, certificate chains can be several layers deep. As long as you can
    verify digital signatures back to a certificate you trust, you are able to validate
    the whole chain.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，证书链可以有几层深。只要你能验证数字签名回溯到你信任的证书，你就能验证整个链。
- en: This method is the common one used by HTTPS to authenticate servers. It does
    have some issues; namely, you must entirely trust the certificate authority. This
    is because certificate authorities could theoretically issue a certificate to
    an impostor, in which case you would be forced to trust the impostor. Certificate
    authorities are careful to avoid this, as it would ruin their reputation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是HTTPS用于验证服务器的常用方法。它确实存在一些问题；即，你必须完全信任证书颁发机构。这是因为证书颁发机构理论上可以向冒名顶替者颁发证书，在这种情况下，你将被迫信任冒名顶替者。证书颁发机构会小心避免这种情况，因为这会破坏它们的声誉。
- en: 'The most popular certificate authorities at the time of this writing are the
    following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，最受欢迎的证书颁发机构如下：
- en: IdenTrust
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IdenTrust
- en: Comodo
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Comodo
- en: DigiCert
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DigiCert
- en: GoDaddy
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GoDaddy
- en: GlobalSign
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GlobalSign
- en: The five preceding certificate authorities are responsible for over 90% of the
    HTTPS certificates found on the web.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前五个证书颁发机构负责了网络上90%以上的HTTPS证书。
- en: It is also possible to self-sign a certificate. In this case, no certificate
    authority is used. In these cases, a client needs to somehow reliably obtain and
    verify a copy of your certificate before it can be trusted.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能自行签名证书。在这种情况下，不使用任何证书颁发机构。在这些情况下，客户端需要以某种可靠的方式获取并验证您的证书副本，然后才能信任它。
- en: Certificates are usually matched to domain names, but it's also possible for
    them to identify other information, such as company names, address, and so on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 证书通常与域名匹配，但它们也可以识别其他信息，例如公司名称、地址等。
- en: In the next chapter, [Chapter 10](f57ffaa2-3eba-45cf-914b-bb6aef36174f.xhtml), *Implementing
    a Secure Web Server*, certificates are covered in more detail.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章[第10章](f57ffaa2-3eba-45cf-914b-bb6aef36174f.xhtml)《实现安全Web服务器》中，将更详细地介绍证书。
- en: It's common today for one server to host many different domains, and each domain
    requires its own certificate. Let's now consider how these servers know which
    certificate to send.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通常一个服务器托管多个不同的域名，每个域名都需要自己的证书。现在让我们考虑这些服务器如何知道要发送哪个证书。
- en: Server name identification
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器名称标识
- en: Many servers host multiple domains. Certificates are tied to domains; therefore,
    TLS must provide a method for the client to specify which domain it's connecting
    to. You may recall that the HTTP *Host* header servers this purpose. The problem
    is that the TLS connection should be established before the HTTP data is sent.
    Therefore, the server must decide which certificate to transmit before the HTTP
    *Host* header is received.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 许多服务器托管多个域名。证书与域名相关联；因此，TLS必须提供一种方法让客户端指定它正在连接到哪个域名。你可能还记得，HTTP *Host* 标头用于此目的。问题是，TLS连接应在发送HTTP数据之前建立。因此，服务器必须在接收到HTTP
    *Host* 标头之前决定要传输哪个证书。
- en: This is accomplished using **Server Name Indication** (**SNI**). SNI is a technique
    that, when used by TLS, requires the client to indicate to the server which domain
    it is attempting to connect to. The server can then find a matching certificate
    to use for the TLS connection.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用**服务器名称指示**（**SNI**）来实现的。SNI是一种技术，当TLS使用时，要求客户端向服务器表明它正在尝试连接到哪个域名。然后服务器可以找到用于TLS连接的匹配证书。
- en: SNI is relatively new, and older browsers and servers do not support it. Before
    SNI was popular, servers had two choices—they could either host only one domain
    per IP address, or they could send certificates for all hosted domains for each
    connection.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: SNI相对较新，较旧的浏览器和服务器不支持它。在SNI流行之前，服务器有两个选择——它们可以每个IP地址只托管一个域名，或者它们可以为每个连接发送所有托管域的证书。
- en: It should be noted that SNI involves sending the unencrypted domain name over
    the network. This means an eavesdropper can see which host the client is connecting
    to, even though they wouldn't know which resources the client is requesting from
    that host. Newer protocols, such as **encrypted server name identification** (**ESNI**),
    address this problem but are not widely deployed yet.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，SNI涉及在网络中发送未加密的域名。这意味着窃听者可以看到客户端正在连接到哪个主机，尽管他们不知道客户端正在请求该主机的哪些资源。较新的协议，如**加密服务器名称标识**（**ESNI**），解决了这个问题，但尚未广泛部署。
- en: With a basic understanding of the TLS protocol, we're ready to look at the most
    popular library that implements it—OpenSSL.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在对TLS协议有基本了解之后，我们准备查看实现它的最流行库——OpenSSL。
- en: OpenSSL
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenSSL
- en: '**OpenSSL** is a widely used open source library that provides SSL and TLS
    services to applications. We use it in this chapter for secure connections required
    by HTTPS.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenSSL** 是一个广泛使用的开源库，为应用程序提供 SSL 和 TLS 服务。我们在本章中使用它来实现 HTTPS 所需的安全连接。'
- en: OpenSSL can be challenging to install. Refer to [Appendices B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml),
    *Setting Up Your C Compiler on Windows*, [Appendices C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml), *Setting
    Up* *Your* *C Compiler on Linux*, and [Appendices D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml), *Setting
    Up Your C Compiler on macOS,* for more information.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL 的安装可能会有些挑战。有关更多信息，请参阅[附录 B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml)，*在
    Windows 上设置您的 C 编译器*，[附录 C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml)，*在 Linux
    上设置您的 C 编译器*，以及[附录 D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml)，*在 macOS 上设置您的
    C 编译器*。
- en: 'You can check whether you have the OpenSSL command-line tools installed by
    running the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来检查是否已安装 OpenSSL 命令行工具：
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot shows this on Ubuntu Linux:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在 Ubuntu Linux 上的情况：
- en: '![](img/29d33ad8-8b0d-491f-9ad6-4f850bfd74fa.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29d33ad8-8b0d-491f-9ad6-4f850bfd74fa.png)'
- en: 'You''ll also need to ensure that you have the OpenSSL library installed. The
    following program can be used to test this. If it compiles and runs successfully,
    then you do have the OpenSSL library installed and working:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要确保已安装 OpenSSL 库。以下程序可以用来测试这一点。如果它编译并成功运行，那么您确实已安装并正在使用 OpenSSL 库：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you're using an older version of OpenSSL, you may need to replace the `OpenSSL_version()`
    function call with `SSLeay_version()` instead. However, a better solution is to
    just upgrade to a newer OpenSSL version.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用较旧的 OpenSSL 版本，您可能需要将 `OpenSSL_version()` 函数调用替换为 `SSLeay_version()`。然而，更好的解决方案是直接升级到较新的
    OpenSSL 版本。
- en: 'The preceding `openssl_version.c` program is compiled on macOS and Linux using
    the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令用于在 macOS 和 Linux 上编译前面的 `openssl_version.c` 程序：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows compiling and running `openssl_version.c`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了编译和运行 `openssl_version.c`：
- en: '![](img/627f1ba2-5ed2-4fa7-99b3-a8215a27a85d.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/627f1ba2-5ed2-4fa7-99b3-a8215a27a85d.png)'
- en: 'On Windows, `openssl_version` can be compiled using MinGW and the following
    commands:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，`openssl_version` 可以使用 MinGW 和以下命令进行编译：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once the OpenSSL library is installed and usable, we are ready to begin using
    encrypted sockets.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 OpenSSL 库安装并可用，我们就可以开始使用加密套接字。
- en: Encrypted sockets with OpenSSL
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenSSL 加密套接字
- en: The TLS provided by OpenSSL can be applied to any TCP socket.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL 提供的 TLS 可以应用于任何 TCP 套接字。
- en: 'Before using OpenSSL in your program, it is important to initialize it. The
    following code does this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的程序中使用 OpenSSL 之前，初始化它是很重要的。以下代码执行此操作：
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, the call to `SSL_library_init()` is required to initialize
    the OpenSSL library. The second call (to `OpenSSL_add_all_algorithms()`) causes
    OpenSSL to load all available algorithms. Alternately, you could load only the
    algorithms you know are needed. For our purposes, it is easy to load them all.
    The third call, `SSL_load_error_strings()`, causes OpenSSL to load error strings.
    This call isn't strictly needed, but it is handy to have easily readable error
    messages when something goes wrong.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，调用 `SSL_library_init()` 是初始化 OpenSSL 库所必需的。第二个调用（调用 `OpenSSL_add_all_algorithms()`）导致
    OpenSSL 加载所有可用的算法。作为替代，您也可以只加载您知道需要的算法。对于我们来说，加载所有算法很容易。第三个调用 `SSL_load_error_strings()`
    导致 OpenSSL 加载错误字符串。此调用不是严格必需的，但在出错时提供易于阅读的错误消息很有用。
- en: Once OpenSSL is initialized, we are ready to create an SSL context. This is
    done by calling the `SSL_CTX_new()` function, which returns an `SSL_CTX` object.
    You can think of this object as a sort of factory for SSL/TLS connections. It
    holds the initial settings that you want to use for your connections. Most programs
    only need to create one `SSL_CTX` object, and they can reuse it for all their
    connections.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化 OpenSSL，我们就可以创建 SSL 上下文。这是通过调用 `SSL_CTX_new()` 函数来完成的，它返回一个 `SSL_CTX`
    对象。您可以将此对象视为 SSL/TLS 连接的某种工厂。它包含您想要用于连接的初始设置。大多数程序只需要创建一个 `SSL_CTX` 对象，并且可以将其用于所有连接。
- en: 'The following code creates the SSL context:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建 SSL 上下文：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `SSL_CTX_new()` function takes one argument. We use `TLS_client_method()`,
    which indicates that we want general-purpose, version-flexible TLS methods available.
    Our client automatically negotiates the best mutually supported algorithm with
    the server upon connecting.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`SSL_CTX_new()`函数接受一个参数。我们使用`TLS_client_method()`，这表示我们想要通用的、版本灵活的TLS方法。我们的客户端在连接时自动与服务器协商最佳相互支持的算法。'
- en: If you're using an older version of OpenSSL, you may need to replace `TLS_client_method()`
    with `TLSv1_2_client_method()` in the preceding code. However, a much better solution
    is to upgrade to a newer OpenSSL version.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是较旧的OpenSSL版本，您可能需要在前面代码中将`TLS_client_method()`替换为`TLSv1_2_client_method()`。然而，一个更好的解决方案是升级到较新的OpenSSL版本。
- en: 'To secure a TCP connection, you must first have a TCP connection. This TCP
    connection should be established in the normal way. The following pseudo-code
    shows this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要安全地建立TCP连接，您必须首先有一个TCP连接。这个TCP连接应该以正常方式建立。以下伪代码展示了这一点：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For more information on setting up a TCP connection, refer to [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml),
    *An In-Depth Overview of TCP Connections*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置TCP连接的更多信息，请参阅[第3章](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml)，*TCP连接的深入概述*。
- en: 'Once `connect()` has returned successfully, and a TCP connection is established,
    you can use the following code to initiate a TLS connection:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`connect()`成功返回，并建立了TCP连接，您可以使用以下代码来初始化TLS连接：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, `SSL_new()` is used to create an `SSL` object. This object
    is used to track the new SSL/TLS connection.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`SSL_new()`用于创建一个`SSL`对象。此对象用于跟踪新的SSL/TLS连接。
- en: We then use `SSL_set_tlsext_host_name()` to set the domain for the server we
    are trying to connect to. This allows OpenSSL to use SNI. This call is optional,
    but without it, the server does not know which certificate to send in the case
    that it hosts more than one site.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`SSL_set_tlsext_host_name()`来设置我们试图连接的服务器的域名。这允许OpenSSL使用SNI。此调用是可选的，但如果没有它，当服务器托管多个站点时，服务器不知道应该发送哪个证书。
- en: Finally, we call `SSL_set_fd()` and `SSL_connect()` to initiate the new TLS/SSL
    connection on our existing TCP socket.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`SSL_set_fd()`和`SSL_connect()`在我们的现有TCP套接字上初始化新的TLS/SSL连接。
- en: 'It is possible to see which cipher the TLS connection is using. The following
    code shows this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可以查看TLS连接正在使用哪种加密套件。以下代码展示了这一点：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once the TLS connection is established, data can be sent and received using
    `SSL_write()` and `SSL_read()`, respectively. These functions are used in a nearly
    identical manner as the standard socket `send()` and `recv()` functions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦TLS连接建立，可以使用`SSL_write()`和`SSL_read()`分别发送和接收数据。这些函数的用法几乎与标准套接字`send()`和`recv()`函数相同。
- en: 'The following example shows transmitting a simple message over a TLS connection:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了通过TLS连接传输简单消息：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Receiving data, done with `SSL_read()`, is shown in the following example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接收数据，通过`SSL_read()`完成，如下面的示例所示：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the connection is finished, it''s important to free the used resources
    by calling `SSL_shutdown()` and `SSL_free(ssl)`. This is shown in the following
    code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接结束时，通过调用`SSL_shutdown()`和`SSL_free(ssl)`释放使用的资源非常重要。以下代码展示了这一点：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you''re done with an SSL context, you should also call `SSL_CTX_free()`.
    In our case, it looks like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成SSL上下文的工作时，也应该调用`SSL_CTX_free()`。在我们的例子中，它看起来像这样：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If your program requires authentication of the connected peer, it is important
    to look at the certificates sent during the TLS initialization. Let's consider
    that next.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的程序需要验证连接的对方，那么在TLS初始化期间发送的证书非常重要。让我们考虑一下。
- en: Certificates
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 证书
- en: 'Once the TLS connection is established, we can use the `SSL_get_peer_certificate()`
    function to get the server''s certificate. It''s also easy to print the certificate
    subject and issuer, as shown in the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦TLS连接建立，我们可以使用`SSL_get_peer_certificate()`函数获取服务器的证书。打印证书主题和发行者也很简单，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'OpenSSL automatically verifies the certificate during the TLS/SSL handshake.
    You can get the verification results using the `SSL_get_verify_result()` function.
    Its usage is shown in the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL在TLS/SSL握手过程中自动验证证书。您可以使用`SSL_get_verify_result()`函数获取验证结果。其用法在以下代码中展示：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If `SSL_get_verify_result()` returns `X509_V_OK`, then the certificate chain
    was verified by OpenSSL and the connection can be trusted. If `SSL_get_verify_result()`
    does not return `X509_V_OK`, then HTTPS authentication has failed, and the connection
    should be abandoned.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `SSL_get_verify_result()` 返回 `X509_V_OK`，则 OpenSSL 已验证证书链，并且可以信任连接。如果 `SSL_get_verify_result()`
    不返回 `X509_V_OK`，则 HTTPS 认证失败，应该放弃连接。
- en: 'In order for OpenSSL to successfully verify the certificate, we must tell it
    which certificate authorities we trust. This can be done by using the `SSL_CTX_load_verify_locations()`
    function. It must be passed the filename that stores all of the trusted root certificates.
    Assuming your trusted certificates are in `trusted.pem`, the following code sets
    this up:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 OpenSSL 成功验证证书，我们必须告诉它我们信任哪些证书颁发机构。这可以通过使用 `SSL_CTX_load_verify_locations()`
    函数来完成。它必须传递存储所有受信任根证书的文件名。假设您的受信任证书存储在 `trusted.pem` 中，以下代码设置了这一配置：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Deciding which root certificates to trust isn't easy. Each operating system
    provides a list of trusted certificates, but there is no general, easy way to
    import these lists. Using the operating system's default list is also not always
    appropriate for every application. For these reasons, certificate verification
    has been omitted from the examples in this chapter. However, it is absolutely
    critical that it be implemented appropriately in order for your HTTPS connections
    to be secure.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 决定信任哪些根证书并不容易。每个操作系统都提供了一份受信任证书列表，但没有一种通用的、简单的方法来导入这些列表。使用操作系统的默认列表也不总是适合每个应用程序。出于这些原因，本章的示例中省略了证书验证。然而，为了确保您的
    HTTPS 连接安全，适当地实现证书验证是绝对必要的。
- en: In addition to validating the certificate's signatures, it is also important
    to validate that the certificate is actually valid for the particular server you're
    connected with! Newer versions of OpenSSL provide functions to help with this,
    but with older versions of OpenSSL, you're on your own. Consult the OpenSSL documentation
    for more information.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 除了验证证书的签名外，验证证书实际上是否适用于您连接的特定服务器也很重要！较新的 OpenSSL 版本提供了帮助完成这一任务的函数，但使用较旧的 OpenSSL
    版本时，您需要自行处理。有关更多信息，请参阅 OpenSSL 文档。
- en: We've now covered enough background information about TLS and OpenSSL that we're
    ready to tackle a concrete example program.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了关于 TLS 和 OpenSSL 的足够背景信息，可以开始处理一个具体的示例程序。
- en: A simple HTTPS client
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的 HTTPS 客户端
- en: To bring the concepts of this chapter together, we build a simple HTTPS client.
    This client can connect to a given HTTPS web server and request the root document `/`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将本章的概念结合起来，我们构建了一个简单的 HTTPS 客户端。这个客户端可以连接到指定的 HTTPS 网络服务器并请求根文档 `/`。
- en: 'Our program begins by including the needed chapter header, defining `main()`,
    and initializing Winsock as shown here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序首先包含所需的章节头文件，定义 `main()` 函数，并初始化 Winsock，如下所示：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then initialize the OpenSSL library with the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码初始化 OpenSSL 库：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `SSL_load_error_strings()` function call is optional, but it's very useful
    if we run into problems.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`SSL_load_error_strings()` 函数调用是可选的，但如果遇到问题，它非常有用。'
- en: 'We can also create an OpenSSL context. This is done by calling `SSL_CTX_new()`
    as shown by the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个 OpenSSL 上下文。这是通过调用 `SSL_CTX_new()` 来完成的，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If we were going to do certificate verification, this would be a good place
    to include the `SSL_CTX_load_verify_locations()` function call, as explained in
    the *Certificates* section of this chapter. We're omitting certification verification
    in this example for simplicity, but it is important to include it in real-world
    applications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要进行证书验证，这将是一个包含 `SSL_CTX_load_verify_locations()` 函数调用的好地方，正如本章的 *证书* 部分所解释的。为了简化示例，我们省略了证书验证，但在实际应用中，包含它是很重要的。
- en: 'Our program then checks that a hostname and a port number was passed in on
    the command line like so:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序随后检查是否在命令行中传递了主机名和端口号，如下所示：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The standard HTTPS port number is `443`. Our program lets the user specify any
    port number, which can be useful for testing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 HTTPS 端口号是 `443`。我们的程序允许用户指定任何端口号，这在测试中可能很有用。
- en: 'We then configure the remote address for the socket connection. This code uses
    the same technique that we''ve been using since [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml),
    *An In-Depth Overview of TCP connections*. The code for this is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们配置套接字连接的远程地址。此代码使用自第 3 章[深入概述 TCP 连接](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml)以来我们所使用的相同技术。该代码如下：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We continue to create the socket using a call to `socket()`, and we connect
    it using the `connect()` function as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用 `socket()` 调用创建套接字，并使用 `connect()` 函数连接它，如下所示：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At this point, a TCP connection has been established. If we didn''t need encryption,
    we could communicate over it directly. However, we are going to use OpenSSL to
    initiate a TLS/SSL connection over our TCP connection. The following code creates
    a new SSL object, sets the hostname for SNI, and initiates the TLS/SSL handshake:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，已建立 TCP 连接。如果我们不需要加密，我们可以直接通过它进行通信。然而，我们将使用 OpenSSL 在我们的 TCP 连接上初始化 TLS/SSL
    连接。以下代码创建一个新的 SSL 对象，设置 SNI 的主机名，并初始化 TLS/SSL 握手：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code is explained in the *Encrypted Sockets with OpenSSL* section
    earlier in this chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在本章前面的 *使用 OpenSSL 的加密套接字* 部分中进行了说明。
- en: The call to `SSL_set_tlsext_host_name()` is optional, but useful if you may
    be connecting to a server that hosts multiple domains. Without this call, the
    server wouldn't know which certificates are relevant to this connection.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`SSL_set_tlsext_host_name()` 调用是可选的，但如果您可能连接到托管多个域的服务器，则很有用。如果没有这个调用，服务器将不知道哪些证书与这个连接相关。'
- en: 'It is sometimes useful to know which cipher suite the client and server agreed
    upon. We can print the selected cipher suite with the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有时了解客户端和服务器同意的加密套件也很有用。我们可以使用以下代码打印选定的加密套件：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It is also useful to see the server''s certificate. The following code prints
    the server''s certificate:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 看看服务器的证书也很有用。以下代码打印服务器的证书：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The certificate *subject* should match the domain we're connecting to. The issuer
    should be a certificate authority that we trust. Note that the preceding code
    does *not* validate the certificate. Refer to the *Certificates* section in this
    chapter for more information.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 证书的 *主题* 应该与我们连接到的域名匹配。发行者应该是我们信任的证书机构。注意，前面的代码 *不* 验证证书。有关更多信息，请参阅本章的 *证书*
    部分。
- en: 'We can then send our HTTPS request. This request is the same as if we were
    using plain HTTP. We begin by formatting the request into a buffer and then sending
    it over the encrypted connection using `SSL_write()`. The following code shows
    this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以发送我们的 HTTPS 请求。此请求与使用纯 HTTP 相同。我们首先将请求格式化到缓冲区中，然后使用 `SSL_write()` 通过加密连接发送它。以下代码展示了这一点：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For more information about the HTTP protocol, please refer back to [Chapter
    6](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml), *Building a Simple Web Client*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 HTTP 协议的更多信息，请参阅第 6 章[构建简单的 Web 客户端](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml)。
- en: 'Our client now simply waits for data from the server until the connection is
    closed. This is accomplished by using `SSL_read()` in a loop. The following code
    receives the HTTPS response:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端现在简单地等待来自服务器的数据，直到连接关闭。这是通过在循环中使用 `SSL_read()` 实现的。以下代码接收 HTTPS 响应：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code also prints any data received over the HTTPS connection.
    Note that it does not parse the received HTTP data, which would be more complicated.
    See the `https_get.c` program in this chapter's code repository for a more advanced
    program that does parse the HTTP response.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码还打印了通过 HTTPS 连接接收到的任何数据。请注意，它不会解析接收到的 HTTP 数据，这会更复杂。请参阅本章代码库中的 `https_get.c`
    程序，它是一个更高级的程序，可以解析 HTTP 响应。
- en: 'Our simple client is almost done. We only have to shut down the TLS/SSL connection,
    close the socket, and clean up. This is done by the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的客户端几乎完成了。我们只需关闭 TLS/SSL 连接，关闭套接字，并进行清理。以下代码执行此操作：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That concludes `https_simple.c`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 `https_simple.c`。
- en: 'You should be able to compile and run it on Windows using MinGW and the following
    commands:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在 Windows 上使用 MinGW 和以下命令编译和运行它：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you're using certain older versions of OpenSSL, you may also need an additional
    linker option—`-lgdi32`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用某些较旧的 OpenSSL 版本，可能还需要额外的链接器选项—`-lgdi32`。
- en: 'Compiling and executing on macOS and Linux can be done using the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 和 Linux 上编译和执行可以使用以下方法：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you run into linker errors, you should check that your OpenSSL library is
    properly installed. You may find it helpful to attempt compiling the `openssl_version.c`
    program first.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到链接错误，你应该检查你的 OpenSSL 库是否正确安装。尝试首先编译 `openssl_version.c` 程序可能会有所帮助。
- en: 'The following screenshot shows successfully compiling `https_simple.c` and
    using it to connect to `example.org`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了成功编译 `https_simple.c` 并使用它连接到 `example.org`：
- en: '![](img/3b7332ca-c781-4e1f-85c3-0318b7b59384.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b7332ca-c781-4e1f-85c3-0318b7b59384.png)'
- en: The `https_simple` program should serve as an elementary example of the techniques
    of connecting as an HTTPS client. These same techniques can be applied to any
    TCP connection.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`https_simple` 程序应该作为连接作为 HTTPS 客户端的技术的入门级示例。这些相同的技巧可以应用于任何 TCP 连接。'
- en: It's easy to apply these techniques to some of the programs developed earlier
    in the book, such as `tcp_client` and `web_get`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些技术应用于书中早期开发的某些程序，如 `tcp_client` 和 `web_get`，是很容易的。
- en: It is also worth mentioning that, while TLS works only with TCP connections, **Datagram
    Transport Layer** **Security** (**DTLS**) aims to provide many of the same guarantees
    for **User Datagram Protocol** (**UDP**) datagrams. OpenSSL provides support for
    DTLS too.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，虽然 TLS 只与 TCP 连接一起工作，但**数据报传输层安全**（**DTLS**）旨在为**用户数据报协议**（**UDP**）数据报提供许多相同的保证。OpenSSL
    也提供了对 DTLS 的支持。
- en: Other examples
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他示例
- en: 'A few other examples are included in this chapter''s repository. They are the
    following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的存储库中还包括了一些其他示例。它们如下：
- en: '`tls_client.c`: This is `tcp_client.c` from [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml),
    *An In-Depth Overview of TCP Connections*, but it has been modified to make TLS
    connections.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tls_client.c`：这是 [第 3 章](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml)，*TCP
    连接的深入概述* 中的 `tcp_client.c`，但它已被修改以建立 TLS 连接。'
- en: '`https_get.c`: This is the `web_get.c` program from [Chapter 6](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml),
    *Building a Simple Web Client*, but it has been modified for HTTPS. You can think
    of it as the extended version of `https_simple.c`.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https_get.c`：这是 [第 6 章](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml)，*构建简单的
    Web 客户端* 中的 `web_get.c` 程序，但它已被修改为支持 HTTPS。你可以将其视为 `https_simple.c` 的扩展版本。'
- en: '`tls_get_cert.c`: This is like `https_simple.c`, but it simply prints the connected
    server''s certificate and exits.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tls_get_cert.c`：这个程序类似于 `https_simple.c`，但它只是打印出已连接服务器的证书并退出。'
- en: Keep in mind that none of the examples in this chapter perform certification
    verification. This is an important step that must be added before using these
    programs in the field.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，本章中的所有示例都不执行证书验证。在使用这些程序在实际环境中之前，这是一个必须添加的重要步骤。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the features that HTTPS provides over HTTP,
    such as authentication and encryption. We saw that HTTPS is really just HTTP over
    a TLS connection and that TLS can be applied to any TCP connection.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 HTTPS 相较于 HTTP 提供的功能，例如身份验证和加密。我们了解到 HTTPS 实际上是在 TLS 连接上的 HTTP，并且
    TLS 可以应用于任何 TCP 连接。
- en: We also learned about basic encryption concepts. We saw how asymmetric ciphers
    use two keys, and how this allows for digital signatures. The very basics of certificates
    were covered, and we explored some of the difficulties with verifying them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了基本的加密概念。我们看到了非对称加密如何使用两个密钥，以及这如何允许数字签名。我们简要介绍了证书的基础知识，并探讨了验证它们的一些困难。
- en: Finally, we worked through a concrete example that established a TLS connection
    to an HTTPS server.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过一个具体的示例建立了与 HTTPS 服务器的 TLS 连接。
- en: This chapter was all about HTTPS clients, but in the next chapter, we focus
    on how HTTPS servers work.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于 HTTPS 客户端，但在下一章中，我们将关注 HTTPS 服务器的工作方式。
- en: Questions
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下问题来测试你对本章知识的掌握：
- en: What port does HTTPS typically operate on?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTPS 通常在哪个端口上运行？
- en: How many keys does symmetric encryption use?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对称加密使用多少个密钥？
- en: How many keys does asymmetric encryption use?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非对称加密使用多少个密钥？
- en: Does TLS use symmetric or asymmetric encryption?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TLS 使用的是对称加密还是非对称加密？
- en: What is the difference between SSL and TLS?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSL 和 TLS 之间的区别是什么？
- en: What purpose do certificates fill?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证书有什么作用？
- en: Answers are in [Appendix A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml), *Answers
    to Questions*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在 [附录 A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml)，*问题解答* 中。
- en: Further reading
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about HTTPS and OpenSSL, please refer to the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 HTTPS 和 OpenSSL 的更多信息，请参阅以下内容：
- en: OpenSSL documentation ([https://www.openssl.org/docs/](https://www.openssl.org/docs/))
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSL 文档 ([https://www.openssl.org/docs/](https://www.openssl.org/docs/))
- en: '**RFC 5246**: *The **Transport Layer Security** (**TLS**) Protocol* ([https://tools.ietf.org/html/rfc5246](https://tools.ietf.org/html/rfc5246))'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 5246**: *传输层安全性协议（**TLS**）* ([https://tools.ietf.org/html/rfc5246](https://tools.ietf.org/html/rfc5246))'
