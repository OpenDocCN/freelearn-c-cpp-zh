- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sanitizing and Testing Asynchronous Software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Testing** is the process of evaluating and verifying that a software solution
    does what it’s meant to do, validating its quality and ensuring that user requirements
    are met. With proper testing, we can prevent bugs from happening and improve performance.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore several techniques to test asynchronous software,
    mainly using the **GoogleTest** library and sanitizers available from **GNU Compiler
    Collection** ( **GCC** ) and **Clang** compilers. Some prior knowledge in unit
    testing is required. In the *Further reading* section at the end of this chapter,
    you can find some references that could be useful to refresh and expand your knowledge
    in these areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing code to analyze the software and find potential issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we will need to install **GoogleTest** ( [https://google.github.io/googletest](https://google.github.io/googletest)
    ) to compile some of the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples need a compiler supporting C++20. Therefore, check the *Technical
    requirements* section in [*Chapter 3*](B22219_03.xhtml#_idTextAnchor051) , as
    it includes some guidance on how to install GCC 13 and Clang 8 compilers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all the complete code in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples for this chapter are located under the **Chapter_12** folder.
    All source code files can be compiled using CMake as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Executable binaries will be generated under the **bin** directory.
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing code to analyze the software and find potential issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sanitizers** are tools, originally developed by Google, used to detect and
    prevent various types of issues or security vulnerabilities in code, helping developers
    catch bugs early in the development process, reducing the cost of issues being
    fixed late, and increasing software stability and security.'
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizers are usually integrated into development environments and are usually
    enabled during manual testing or when running unit tests, **continuous integration**
    ( **CI** ) pipelines, or code review pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: C++ compilers, such as GCC and Clang, have compiler options to generate code
    when building the program to track the execution at runtime and report errors
    and vulnerabilities. They are implemented in Clang from version 3.1 and GCC from
    version 4.8.
  prefs: []
  type: TYPE_NORMAL
- en: As extra instructions are injected into the program’s binary code, there is
    a performance penalty of around 1.5x to 4x slowdowns depending on the sanitizer
    type. Also, there is an overall memory overhead of 2x to 4x and a stack size increase
    of up to 3x. But note that slowdowns are much lower than the ones experienced
    when using other instrumentation frameworks or dynamic analysis tools, such as
    **Valgrind** ( [https://valgrind.org](https://valgrind.org) ), which imposes a
    much higher slowdown of up to 50 times slower than production binaries. On the
    other hand, the benefit of using Valgrind is that no recompilation is needed.
    Both approaches only detect issues while the program is running and only on those
    code paths that the execution traverses. So, we need to ensure sufficient coverage.
  prefs: []
  type: TYPE_NORMAL
- en: There are also static analysis tools and linters, useful for detecting issues
    during compilation and checking all the code that is being included in the program.
    For example, compilers, such as GCC and Clang, can perform extra checks and provide
    useful information by enabling the **–Werror** , **–Wall** , and **–** **pedantic**
    options.
  prefs: []
  type: TYPE_NORMAL
- en: There are also open source alternatives, such as **Cppcheck** or **Flawfinder**
    , or commercial solutions that are free for open source projects, such as **PVS-Studio**
    or **Coverity Scan** . Other solutions, such as **SonarQube** , **CodeSonar**
    , or **OCLint** , can be used in **continuous integration / continuous delivery**
    ( **CI/CD** ) pipelines for ongoing quality tracking.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will focus on sanitizers, which can be enabled by passing
    some special options to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To enable sanitizers, we need to pass some compiler options when compiling the
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main option is **--fsanitize=sanitizer_name** , where **sanitizer_name**
    is one of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**address** : This is for **AddressSanitizer** ( **ASan** ), to detect memory
    errors such as buffer overflows and use-after-free bugs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**thread** : This is for **ThreadSanitizer** ( **TSan** ), to identify data
    races and other thread synchronization issues in multi-threaded programs by monitoring
    thread interactions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**leak** : This is for **LeakSanitizer** ( **LSan** ), to spot memory leaks
    by tracking memory allocations and ensuring that all allocated memory is properly
    freed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**memory** : This is for **MemorySanitizer** ( **MSan** ), to uncover the use
    of uninitialized memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**undefined** : This is for **UndefinedBehaviorSanitizer** ( **UBSan** ), to
    detect undefined behavior, such as integer overflows, invalid type casts, and
    other erroneous operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clang also includes **dataflow** , **cfi** (control flow integrity), **safe_stack**
    , and **realtime** .
  prefs: []
  type: TYPE_NORMAL
- en: GCC adds **kernel-address** , **hwaddress** , **kernel-hwaddress** , **pointer-compare**
    , **pointer-subtract** , and **shadow-call-stack** .
  prefs: []
  type: TYPE_NORMAL
- en: As this list and flag behavior can change over time, it’s recommended to check
    the compilers’ official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional flags might be needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-fno-omit-frame-pointer** : A **frame pointer** is a register used by compilers
    to track the current stack frame, containing, among other information, the base
    address of the current function. Omitting frame pointers might increase the performance
    of the program but at the cost of making debugging significantly harder; it makes
    it more difficult to locate local variables and reconstruct stack traces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-g** : Include debug information and display filenames and line numbers in
    the warning messages. If the debugger GDB is used, the **–ggdb** option might
    be desirable as the compiler can produce more expressive symbols to be used when
    debugging. Also, a level can be specified by using **–g[level]** , with **[level]**
    being a value from **0** to **3** , adding more debug information at each level
    increase. The default level is **2** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**–fsanitize-recover** : These options cause the sanitizer to attempt to continue
    running the program as if no error was detected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**–fno-sanitize-recover** : The sanitizer will detect only the first error,
    and the program will exit with a non-zero exit code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To keep a reasonable performance, we might need to adjust the optimization level
    by specifying the **–O[num]** option. Different sanitizers work best up to a certain
    level of optimization. It’s best to start with **–O0** and, if the slowdown is
    significant, try to increase to **–O1** , **–O2** , and so on. Also, as different
    sanitizers and compilers recommend specific optimization levels, check their documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Clang, to make stack traces easy to understand and let sanitizers
    convert addresses into source code locations, apart from using the flags mentioned
    earlier, we can also set the specific environment variable, **[X]SAN_SYMBOLIZER_PATH**
    , to the location of **llvm-symbolizer** (with **[X]** being **A** for AddressSatinizer,
    **L** for LSan, **M** for MSan, and so on). We can also include this location
    in the **PATH** environment variable. Here is an example of setting the **PATH**
    variables when using **AddressSatinizer** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that enabling **–Werror** with certain sanitizers can lead to false positives.
    Also, other compiler flags might be needed, but warning messages during execution
    will show that a problem is happening and will be evident that a flag is needed.
    Check the sanitizers’ and compilers’ documentation to find which flag to use in
    those cases.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding sanitizing part of the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, we may want to silence some sanitizer warning and skip sanitizing
    some functions due to the following reasons: it is a well-known issue, the function
    is correct, it’s a false positive, this function needs to speed up, or it is an
    issue in a third-party library. In those cases, we can use suppression files or
    exclude the code area by using some macro instructions. There is also a blacklist
    mechanism, but as it is deprecated in favor of suppression files; we will not
    comment on it here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With suppression files, we just need to create a text file listing the areas
    of the code where we don’t want the sanitizer to run. Each line consists of a
    pattern following a specific format depending on the sanitizer, but typically,
    the structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, **type** indicates the type of suppression, for example, the **leak**
    and **race** values, and **location_pattern** is a regular expression matching
    the function or library name to suppress. Here is an example of a suppression
    file for an ASan, explained in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s call this file **myasan.supp** . Then, compile and pass this suppression
    file to the sanitizer via **[X]SAN_OPTIONS** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use macros in source code to exclude specific functions to be sanitized
    by using **__attribute__((no_sanitize("<sanitizer_name>")))** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This technique provides a fine-grained compile-time control over what should
    be instrumented by the sanitizer.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now explore the most common types of code sanitizers, starting with one
    of the most relevant to check address misusages.
  prefs: []
  type: TYPE_NORMAL
- en: AddressSanitizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of ASan is to detect memory-related errors happening due to buffer
    overflows (heap, stack, and global) during out-of-bounds accesses of arrays, using
    a block of memory after being released with free or delete operations, and other
    memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from setting **-fsanitize=address** and other flags recommended earlier,
    we can also use **–fsanitize-address-use-after-scope** to detect the memory used
    after moving out of scope or setting the **ASAN_OPTIONS=option detect_stack_use_after_return=1**
    environment variable to detect use after return.
  prefs: []
  type: TYPE_NORMAL
- en: '**ASAN_OPTIONS** can also be used to instruct the ASan to print the stack trace
    or set a log file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Clang on Linux has full support for ASan, followed by GCC on Linux. By default,
    ASan is disabled as it adds extra runtime overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Also, ASan processes all calls to **glibc** – the GNU C library providing the
    core libraries for GNU systems. However, this is not the case with other libraries,
    so it’s recommended to recompile such libraries with the **–fsanitize=address**
    option. As commented earlier, with Valgrind, recompilation is not required.
  prefs: []
  type: TYPE_NORMAL
- en: ASan can be combined with UBSan, which we will see later, but It slows down
    the performance by around 50%.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want a more aggressive diagnostics sanitizing, we can use the following
    flag combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see two examples of using ASan to detect common software issues, with
    memory being used after being freed and detecting buffer overflows.
  prefs: []
  type: TYPE_NORMAL
- en: Memory usage after being freed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One common issue in software is using memory after being freed. In this example,
    memory allocated in the heap is being used after being deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s suppose that the previous source code is in a file called **test.cpp**
    . To enable ASan, we just compile the file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, executing the resulting output **test** program, we obtain the following
    output (note that the output is simplified, only showing relevant content and
    might differ from different compiler versions and execution context):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that the ASan was applied and detected a heap-use-after-free
    error. This error is happening in the **T0** thread (main thread). The output
    also points to the code where that memory region was allocated, and later freed,
    and its size (400 bytes region).
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of errors not only happen with heap memory but also with memory
    regions allocated in the stack or global area. ASan can be used to detect these
    kinds of issues, such as memory overflows.
  prefs: []
  type: TYPE_NORMAL
- en: Memory overflows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Memory overflows, also known as buffer overflows or overruns, happen when some
    data is written in a memory address past the allocated memory of a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a heap memory overflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling and running the resulting program, this is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the output, now ASan reports a heap-buffer-overflow error
    in the main thread ( **T0** ) when accessing a memory address beyond a 400-byte
    region (the **arr** variable).
  prefs: []
  type: TYPE_NORMAL
- en: A sanitizer that is integrated into ASan is LSan. Let’s learn now how to detect
    memory leaks using this sanitizer.
  prefs: []
  type: TYPE_NORMAL
- en: LeakSanitizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LSan is used to detect memory leaks happening when memory has been allocated
    but not properly freed.
  prefs: []
  type: TYPE_NORMAL
- en: LSan is integrated into ASan and enabled by default on Linux systems. It can
    be enabled on macOS by using **ASAN_OPTIONS=detect_leaks=1** . To disable it,
    just set **detect_leaks=0** .
  prefs: []
  type: TYPE_NORMAL
- en: If the **–fsanitize=leak** option is used, the program will link against a subset
    of the ASan supporting LSan, disabling compile-time instrumentation and reducing
    the ASan slowdown. Note that this mode is not as well tested as the default mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of memory leak:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, 100 bytes are allocated (the **arr** variable) but never freed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable LSan, we just compile the file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the resulting test binary, we obtain the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: LSan correctly reports that a memory region of 100 bytes was allocated by using
    the operator **new** but never deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this book explores multithreading and asynchronous programming, let’s learn
    now about a sanitizer to detect data races and other thread issues: TSan.'
  prefs: []
  type: TYPE_NORMAL
- en: ThreadSanitizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TSan is used to detect threading issues, especially data races and synchronization
    issues. It cannot be combined with ASan or LSan. TSan is the sanitizer most aligned
    with the content of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sanitizer is enabled by specifying the **–fsanitize=thread** compiler
    option and its behavior can be modified by using the **TSAN_OPTIONS** environment
    variable. For example, if we want to stop after the first error, just use the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Also, for a reasonable performance, use the compiler’s **–** **O2** option.
  prefs: []
  type: TYPE_NORMAL
- en: TSan only reports race conditions happening at runtime, thus it won’t alert
    on race conditions present in code paths not executed at runtime. Therefore, we
    need to design tests that provide good coverage and use a realistic workload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some examples of TSan detecting data races. In the next example,
    we’ll do this by using a global variable without protecting its access with a
    mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling the program, use the following command to enable TSan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the resulting program generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: From the output, it’s clear that there is a data race when accessing **globalVar**
    in the **increase()** and **decrease()** functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we decide to use GCC instead of Clang, the following error can be reported
    when running the resulting program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This memory mapping issue is caused by a security feature called **address space
    layout randomization** ( **ASLR** ), a memory-protection technique used by the
    OS to protect against buffer overflow attacks by randomizing the address space
    of processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'One solution is to reduce ASLR by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The value passed to **vm.mmap_rnd_bits** ( **30** in the preceding command)
    can be reduced further if the error is still happening. To check that the value
    is correctly set, just run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that this change is not permanent. Therefore, when the machine reboots,
    its value will be set to the default one. To persist this change, add **m.mmap_rnd_bits=30**
    to **/etc/sysctl.conf** .
  prefs: []
  type: TYPE_NORMAL
- en: 'But that reduces the security of the system, so it might be preferable to temporarily
    disable ASLR for a particular program by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding command will show a similar output to what was shown earlier
    when compiling with Clang.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move to another example where a **std::map** object is accessed without
    a mutex. Even if the map is being accessed for different key values, as writing
    to a **std::map** invalidates their iterators, that can cause data races:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the resulting binary generates a large output with three
    warnings. Here, we only show the most relevant lines of the first warning (other
    warnings are similar):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The TSan warnings are flagged when both the **t1** and **t2** threads are writing
    into the map, **m** .
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, there is only one auxiliary thread accessing the map via
    a pointer, but this thread is competing against the main thread to access and
    use the map. The **t** thread accesses the map, **m** , to change the value for
    the **foo** key; meanwhile, the main thread prints its value to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running this example generates a massive output with seven TSan
    warnings. Here, we only show the first warning. Feel free to check the complete
    report by compiling and running the example in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: From the output, TSan is warning about a data race when accessing a **std::map**
    object allocated in the heap. That object is the map **m** .
  prefs: []
  type: TYPE_NORMAL
- en: However, TSan can not only detect data races due to a lack of mutexes but can
    also report when a variable must be atomic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example shows that scenario. The **RefCountedObject** class defines
    objects that can keep a reference count of how many objects of that class have
    been created. Smart pointers follow this idea to delete the underlying allocated
    memory on destruction when the counter reaches the value **0** . In this example,
    we are only showing the **Ref()** and **Unref()** functions that increment and
    decrement the reference count variable, **ref_** . To avoid issues in a multithreading
    environment, **ref_** must be an atomic variable. As here, this is not the case,
    and the **t1** and **t2** threads are modifying **ref_** , a possible data race
    can happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running this example shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: TSan output shows that there is a data race condition happening in the **Unref()**
    function when accessing a memory location previously modified by the **Ref()**
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data races can also happen in objects being initialized from several threads
    without any synchronization mechanism. In the following example, an object of
    type **MyObj** is being created in the **init_object()** function, and the global
    static pointer, **obj** , is assigned its address. As this pointer is not protected
    by a mutex, there is a data race happening when the **t1** and **t2** threads
    try to create an object and update the **obj** pointer from the **func1()** and
    **func2()** functions respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output after compiling and running this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The output shows what we described earlier, a data race happening due to access
    to the **obj** global variable from **func1()** and **func2()** .
  prefs: []
  type: TYPE_NORMAL
- en: As the C++11 standard has officially deemed data races as undefined behavior,
    let’s see now how to use UBSan to detect undefined behavior issues in the program.
  prefs: []
  type: TYPE_NORMAL
- en: UndefinedBehaviorSanitizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UBSan can detect undefined behavior in code, for example, when shifting bits
    by an excessive amount, integer overflows, or misuse of null pointers. It can
    be enabled by specifying the **–fsanitize=undefined** option. Its behavior can
    be modified at runtime by setting the **UBSAN_OPTIONS** variable.
  prefs: []
  type: TYPE_NORMAL
- en: Many errors that can be detected by UBSan are also detected by the compiler
    during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the program and enable UBSan, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the resulting program generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The output is quite simple and self-explanatory; there is a signed integer overflow
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now learn about another useful C++ sanitizer to detect uninitialized
    memory and other memory usage issues: MSan.'
  prefs: []
  type: TYPE_NORMAL
- en: MemorySanitizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MSan can detect uninitialized memory usage, for example, when using variables
    or pointers before they have been assigned a value or address. It can also track
    uninitialized bits in a bitfield.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable MSan, use the following compiler flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It can also track each uninitialized value to the memory allocation from where
    it was created by specifying the **-** **fsanitize-memory-track-origins** option.
  prefs: []
  type: TYPE_NORMAL
- en: GCC has no support for MSan, so the **-fsanitize=memory** flag is not valid
    when using this compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the **arr** integer array is created, but only its
    position **5** is initialized. The value at position **0** is used when printing
    the message to the console, but this value is still uninitialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the program and enable MSan, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the resulting program generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Again, the output shows clearly that an uninitialized value is being used at
    line 6 when reading the value at position **0** in the **arr** array.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s summarize other sanitizers in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Other sanitizers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are other sanitizers available that are useful when developing for certain
    systems, such as kernel or real-time development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware-assisted AddressSanitizers (HWASan)** : A new variant of ASan that
    consumes much less memory by using the hardware ability to ignore the top byte
    of a pointer. It can be enabled by specifying the **–** **fsanitize=hwaddress**
    option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RealTimeSanitizer (RTSan)** : Real-time testing tool to detect real-time
    violations when calling methods that are not safe in functions with deterministic
    runtime requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FuzzerSanitizer** : A sanitizer that detects potential vulnerabilities by
    feeding large volumes of random data into the program, checking if the program
    crashes, and looking for memory corruption or other security vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kernel-related sanitizers** : There are also sanitizers available to track
    issues by kernel developers. For the sake of curiosity, some of these are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kernel Address** **Sanitizer** ( **KASAN** )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kernel Concurrency** **Sanitizer** ( **KCSAN** )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kernel** **Electric-Fence** ( **KFENCE** )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kernel Memory** **Sanitizer** ( **KMSAN** )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kernel Thread** **Sanitizer** ( **KTSAN** )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sanitizers can automatically find many issues in our code. Once we have found
    and debugged some bugs and can reproduce scenarios that lead to those specific
    bugs, it would be convenient to design some tests that cover those cases to avoid
    future changes in code that could lead to similar problems or incidents.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn how to test multithreaded and asynchronous code in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, let’s explore some techniques to test asynchronous code. The examples
    shown in this section need **GoogleTest** and **GoogleTest Mock** ( **gMock**
    ) libraries to compile. If you are unfamiliar with these libraries, please check
    the official documentation on how to install and use them.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, **unit testing** is the practice of writing small and isolated tests
    that verify the functionality and behavior of a single unit of code. Unit testing
    helps to find and fix bugs, refactor and improve your code quality, document and
    communicate the underlying code design, and facilitate collaboration and integration.
  prefs: []
  type: TYPE_NORMAL
- en: This section will not cover the best way to group tests into logical and descriptive
    suites, or when you should use assertions or expectations to verify the values
    of different variables and tested methods outcomes. The purpose of this section
    is to provide some guidelines on how to create unit tests to test asynchronous
    code. Therefore, some previous knowledge about unit testing or **test-driven development**
    ( **TDD** ) is desirable.
  prefs: []
  type: TYPE_NORMAL
- en: The main difficulty when dealing with asynchronous code is that it might execute
    in another thread, and usually without knowing when that will happen, or when
    it will complete.
  prefs: []
  type: TYPE_NORMAL
- en: The main approach to follow when testing asynchronous code is to try to separate
    the functionality from multithreading, meaning that we might want to test the
    asynchronous code in a synchronous way, trying to execute it in one specific thread,
    removing context switching, threads creation and destruction, and other activities
    that might affect the result and timings on the tests. Sometimes, timers are also
    used, waiting for a callback to be invoked before timeout.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a simple asynchronous function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with a small example of testing an asynchronous operation. This
    example shows a **asyncFunc()** function that is tested by running it asynchronously
    by using **std::async** , as shown in [*Chapter 7*](B22219_07.xhtml#_idTextAnchor143)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**std::async** returns a future that is used to retrieve the computed value.
    In this case, **asyncFunc** just waits for **100ms** before returning the value
    **42** . If the asynchronous task runs properly, the test will pass as there is
    an expectation instruction checking that the returned value is in fact **42**
    .'
  prefs: []
  type: TYPE_NORMAL
- en: There is only one test defined, using the **TEST()** macro, where its first
    parameter is the test suite name (in this example, **AsyncTests** ) and the second
    parameter is the test name ( **TestHandleAsyncOperation** ).
  prefs: []
  type: TYPE_NORMAL
- en: In the **main()** function, the GoogleTest library is initialized by calling
    **::testing::InitGoogleTest()** . This function parses the command line for the
    flags that GoogleTest recognizes. Then, **RUN_ALL_TESTS()** is called, which collects
    and runs all tests and returns **0** if all tests are successful or **1** otherwise.
    This function originally was a macro, which is why its name is in uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting test durations by using timeouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One issue that could happen with this approach is that the asynchronous task
    can fail to be scheduled for any reason, take longer than expected to complete,
    or just not get completed for any reason. To deal with this situation, a timer
    can be used, setting its timeout period to a reasonable value to give enough time
    for the test to complete successfully. Therefore, if the timer times out, the
    test will fail. The following example shows that approach by using a timed waiting
    on the future returned by **std::async** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, the **wait_for()** function of the future object **result** is called,
    waiting 200 ms for the asynchronous task to complete. As the task will be completed
    in 100 ms, the timeout will not expire. If for any reason **wait_for()** is called
    with a value lower than 100 ms, it would time out and the **FAIL()** macro will
    be called, making the test fail.
  prefs: []
  type: TYPE_NORMAL
- en: The test continues running and checks if the returned value is **42** as in
    the previous example, and then also checks if the time spent running the asynchronous
    task is less than the used timeout.
  prefs: []
  type: TYPE_NORMAL
- en: Testing callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing callback is a relevant task, especially when implementing libraries
    and **application programming interfaces** ( **APIs** ). The following example
    shows how to test that a callback has been called and its result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The **TestCallback** test just defines a callback as a lambda function that
    accepts an argument. This lambda function captures by reference the **result**
    variable where the **value** argument is stored, and the **callback_called** Boolean
    variable that by default is **false** and set to **true** when the callback is
    called.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the test calls the **asyncFunc()** function that spawns a thread that
    waits for one second before calling the callback and passing the value **42**
    . The test waits for two seconds before checking if the callback has been called
    by using the **EXPECT_TRUE** macro and checking the value of **callback_called**
    , and if **result** has the expected value of **42** .
  prefs: []
  type: TYPE_NORMAL
- en: Testing event-driven software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw in [*Chapter 9*](B22219_09.xhtml#_idTextAnchor184) how to use **Boost.Asio**
    and its event queue to dispatch asynchronous tasks. In event-driven programming,
    typically, we also need to test callbacks, as in the previous example. We can
    set up the test to inject callbacks and validate the result after they are called.
    The following example shows how to test asynchronous tasks in a Boost.Asio program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The **BoostAsio** test starts by creating an I/O execution context object, **io_context**
    , and passing it to the **asyncFunc()** function together with a lambda function
    implementing a task or callback to run in the background. This callback simply
    sets the value of the **result** variable, captured by the lambda function, to
    the value passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: The **asyncFunc()** function just uses **io_context** to post a task that consists
    of a lambda function that calls the callback with the value **42** after waiting
    for 100 ms.
  prefs: []
  type: TYPE_NORMAL
- en: The test then just waits for 150 ms for the background task to finish and checks
    that the result value is **42** to mark the test as passed.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking external resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the asynchronous code also depends on external resources, such as file access,
    network servers, timers, or other modules, we might need to mock them and avoid
    unwanted failures due to any resource issues translated into the tests. Mocking
    and stubbing are techniques used to replace or modify the behavior of a real object
    or function with a fake or simplified one, for testing purposes. This way, we
    can control the input and output of the asynchronous code and avoid side effects
    or interference from other factors.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the tested code depends on a server, the server can fail to
    connect or execute its task, making the test fail. In these cases, failures are
    due to resource issues, not due to the asynchronous code being tested, causing
    a false, and usually transient, failure. We can mock external resources by using
    our own mock classes that mimic their interfaces. Let’s see an example of how
    to use a mock class and use dependency injection to use that class for testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, there is an external resource, **AsyncTaskScheduler** , whose
    **runTask()** method is used to execute an asynchronous task. As we only want
    to test the asynchronous task and remove any undesired side effects that the asynchronous
    task scheduler could generate, we can use a mock class mimicking the **AsyncScheduler**
    interface. This class is **MockTaskScheduler** , which inherits from **AsyncTaskScheduler**
    and implements its **runTask()** base class method, where the task is run synchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The **TestDependencyInjection** test just creates a **MockTaskScheduler** object
    and a task in the form of a lambda function and uses the mock object to execute
    the task by running the **runTask()** function. Once the task runs, **result**
    will have the value **42** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of fully defining the mock class, we can also use the gMock library
    and mock only the needed methods. This example shows gMock in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, **MockTaskScheduler** also inherits from **AsyncTaskScheduler** , where
    the interface is defined, but instead of overriding its methods, the **MOCK_METHOD**
    macro is used instead, where the return type, the mocked method name, and its
    parameters are passed.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the **TestMockMethod** test uses the **EXPECT_CALL** macro to define an
    expected call to the **runTask()** mocked method in **MockTaskScheduler** , which
    will happen only once and invoke the lambda function task, which returns the value
    **42** .
  prefs: []
  type: TYPE_NORMAL
- en: That call just happens in the next instruction where **scheduler.runTask()**
    is called, storing the returned value in the result. The test finishes by checking
    if **result** is the expected value of **42** .
  prefs: []
  type: TYPE_NORMAL
- en: Testing exceptions and failures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asynchronous tasks do not always succeed and generate a valid result. Sometimes
    something can go wrong (network failures, timeouts, exceptions, etc.), and returning
    an error or throwing an exception is the way to let the user know about this situation.
    We should simulate failures to ensure that the code handles these gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing errors or exceptions can be done in the usual way, by using a try-catch
    block and using assertions or expectations to check if an error is thrown and
    make the test succeed or fail. GoogleTest also provides the **EXPECT_ANY_THROW()**
    macro that simplifies checking if an exception has happened. Both approaches are
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Both the **TestAsyncFailure1** and **TestAsyncFailure2** tests are very similar.
    Both execute asynchronously the **asyncFunc()** function, which now accepts a
    **should_fail** Boolean argument indicating whether the task should succeed and
    return the value **42** or fail and throw an exception. Both tests make the task
    fail, with the difference being that **TestAsyncFailure1** uses the **FAIL()**
    macro if no exception is thrown, making the test fail, or **SUCCEED()** if an
    exception is caught by the try-catch block, and **TestAsyncFailure2** uses the
    **EXPECT_ANY_THROW()** macro to check if an exception happens when trying to retrieve
    the result from the future result by calling its **get()** method.
  prefs: []
  type: TYPE_NORMAL
- en: Testing multiple threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When testing asynchronous software involving multiple threads in C++, one common
    and effective technique is using condition variables to synchronize the threads.
    As we have seen in [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074) , condition
    variables allow threads to wait for certain conditions to be met before proceeding,
    making them essential for managing inter-thread communication and coordination.
  prefs: []
  type: TYPE_NORMAL
- en: Next is an example where multiple threads perform some tasks while the main
    thread waits for all other threads to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by defining some necessary global variables, such as the total
    number of threads ( **num_threads** ), **counter** as an atomic variable that
    will increase each time the asynchronous task is invoked, and the condition variable,
    **cv** , and its associated mutex, **mtx** , which will help to unblock the main
    thread once all asynchronous tasks have been completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The **asyncTask()** function will execute the asynchronous task (simply waiting
    for 100 ms in this example) before increasing the **counter** atomic variable
    and notifying via the **cv** condition variable to the main thread that its work
    is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The **TestMultipleThreads** test will start by spawning a number of threads
    where each one will asynchronously run the **asyncTask()** task. Then, it will
    wait, using a condition variable that **counter** has the same value as the number
    of threads, meaning that all background tasks have finished their work. The condition
    variable sets a timeout of 150 ms using the **wait_for()** function to limit the
    time the test can run but gives some room for all background tasks to be completed
    successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The test finishes by checking that indeed **counter** has the same value as
    **num_threads** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the **main()** function is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As explained earlier, the program starts by initializing the GoogleTest library
    by calling **::testing::InitGoogleTest()** and then calling **RUN_ALL_TESTS()**
    to collect and run all tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing coroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With C++20, coroutines provide a new way to write and manage asynchronous code.
    Coroutine-based code can be tested by using a similar approach to other asynchronous
    code, but with the subtle difference that coroutines can suspend and be resumed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see an example with a simple coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen in [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164) that coroutines
    have some boilerplate code to define their promise type and awaitable methods.
    Let’s start by implementing the **Task** structure that will define the coroutine.
    Please revisit [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164) to fully understand
    this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by defining the **Task** structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside **Task** , we define **promise_type** , which describes how the coroutine
    is managed. This type provides certain predefined methods (hooks) that control
    how the values are returned, how the coroutine is suspended, and how resources
    are managed once the coroutine is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the methods used for controlling the suspension and resumption of the
    coroutine are implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Having the **Task** structure in place, let’s define two coroutines, one that
    computes a valid value and another that throws an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As test functions inside the **TEST()** macro in GoogleTest cannot directly
    be coroutines because they don’t have a **promise_type** structure associated
    with them, we need to define some helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'With that in place, we can now implement the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The **TestCoroutine** test defines a task using the **testCoroutineHelper()**
    helper function and passing the value **5** . When resuming the coroutine, it’s
    expected that it will return the value doubled, thus the value **10** , which
    is tested using **EXPECT_EQ()** .
  prefs: []
  type: TYPE_NORMAL
- en: The **TestCoroutineWithException** test uses a similar approach, but now using
    the **testCoroutineWithExceptionHelper()** helper function, which will throw an
    exception when the coroutine is resumed. This is exactly what happens inside the
    **EXPECT_THROW()** assertion macro before checking that indeed the exception is
    of type **std::runtime_error** .
  prefs: []
  type: TYPE_NORMAL
- en: Stress testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A race condition detector can be achieved by performing stress testing. For
    highly concurrent or multi-threaded asynchronous code, stress testing is crucial.
    We can simulate high load with multiple asynchronous tasks to check if the system
    behaves correctly under stress. Also, it’s important to use random delays, thread
    interleaving, or stress-testing tools, to reduce deterministic conditions, increasing
    the test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example shows the implementation of a stress test that spawns 100
    ( **total_nums** ) threads that execute the asynchronous task where the atomic
    variable counter is increased with each run after a random wait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The test succeeds if the counter has the same value as the total number of threads.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelizing tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run test suites quicker we can parallelize the tests running in different
    threads, but tests must be independent, each running in a specific thread as a
    synchronous single-threaded solution. Also, they need to set up and tear down
    any necessary objects without keeping the state from previous test runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using CMake together with GoogleTest, we can run all detected tests in
    parallel by specifying the number of concurrent jobs we want to use with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: All the examples shown in this section are a small subset of what can be done
    for testing asynchronous code. We hope that these techniques provide enough insight
    and knowledge to develop further testing techniques that deal with specific scenarios
    you might face.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about how to sanitize and test asynchronous programs.
  prefs: []
  type: TYPE_NORMAL
- en: We started by learning how to sanitize code using sanitizers to help find multithreaded
    and asynchronous issues, such as race conditions, memory leaks, and use-after-scope
    errors, among many other issues.
  prefs: []
  type: TYPE_NORMAL
- en: Then, some testing techniques designed to deal with asynchronous software were
    described, using GoogleTest as the testing library.
  prefs: []
  type: TYPE_NORMAL
- en: Using these tools and techniques helps detect and prevent undefined behavior,
    memory errors, and security vulnerabilities while ensuring that concurrent operations
    execute correctly, timing issues are handled properly, and code performs as expected
    under various conditions. This improves the overall program’s reliability and
    stability.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about performance and optimization techniques
    that can be used to improve asynchronous programs’ runtime and resource usage.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sanitizers: [https://github.com/google/sanitizers](https://github.com/google/sanitizers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clang 20.0 ASan: [https://clang.llvm.org/docs/AddressSanitizer.html](https://clang.llvm.org/docs/AddressSanitizer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clang 20.0 hardware-assisted ASan: [https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html](https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clang 20.0 TSan: [https://clang.llvm.org/docs/ThreadSanitizer.html](https://clang.llvm.org/docs/ThreadSanitizer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clang 20.0 MSan: [https://clang.llvm.org/docs/MemorySanitizer.html](https://clang.llvm.org/docs/MemorySanitizer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clang 20.0 UBSan : [https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clang 20.0 DataFlowSanitizer: [https://clang.llvm.org/docs/DataFlowSanitizer.html](https://clang.llvm.org/docs/DataFlowSanitizer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clang 20.0 LSan: [https://clang.llvm.org/docs/LeakSanitizer.html](https://clang.llvm.org/docs/LeakSanitizer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clang 20.0 RealtimeSanitizer: [https://clang.llvm.org/docs/RealtimeSanitizer.html](https://clang.llvm.org/docs/RealtimeSanitizer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clang 20.0 SanitizerCoverage: [https://clang.llvm.org/docs/SanitizerCoverage.html](https://clang.llvm.org/docs/SanitizerCoverage.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clang 20.0 SanitizerStats: [https://clang.llvm.org/docs/SanitizerStats.html](https://clang.llvm.org/docs/SanitizerStats.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GCC: *Program Instrumentation* *Options* : [https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apple Developer: *Diagnosing memory, thread, and crash issues* *early* : [https://developer.apple.com/documentation/xcode/diagnosing-memory-thread-and-crash-issues-early](https://developer.apple.com/documentation/xcode/diagnosing-memory-thread-and-crash-issues-early)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GCC: *Options for Debugging Your* *Program* : [https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html](https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenSSL: *Compiler Options Hardening Guide for C and* *C++* : [https://best.openssf.org/Compiler-Hardening-Guides/Compiler-Options-Hardening-Guide-for-C-and-C++.html](https://best.openssf.org/Compiler-Hardening-Guides/Compiler-Options-Hardening-Guide-for-C-and-C++.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory error checking in C and C++: Comparing Sanitizers and Valgrind: [https://developers.redhat.com/blog/2021/05/05/memory-error-checking-in-c-and-c-comparing-sanitizers-and-valgrind](https://developers.redhat.com/blog/2021/05/05/memory-error-checking-in-c-and-c-comparing-sanitizers-and-valgrind)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The GNU C Library: [https://www.gnu.org/software/libc](https://www.gnu.org/software/libc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sanitizers: Common flags: [https://github.com/google/sanitizers/wiki/SanitizerCommonFlags](https://github.com/google/sanitizers/wiki/SanitizerCommonFlags)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AddressSanitizer flags: [https://github.com/google/sanitizers/wiki/AddressSanitizerFlags](https://github.com/google/sanitizers/wiki/AddressSanitizerFlags)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AddressSanitizer: A Fast Address Sanity Checker: [https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf](https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MemorySanitizer: Fast detector of uninitialized memory use in C++: [https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43308.pdf](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43308.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux Kernel Sanitizers: [https://github.com/google/kernel-sanitizers](https://github.com/google/kernel-sanitizers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TSan flags: [https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags](https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TSan: Popular data races: [https://github.com/google/sanitizers/wiki/ThreadSanitizerPopularDataRaces](https://github.com/google/sanitizers/wiki/ThreadSanitizerPopularDataRaces)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TSan report format: [https://github.com/google/sanitizers/wiki/ThreadSanitizerReportFormat](https://github.com/google/sanitizers/wiki/ThreadSanitizerReportFormat)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TSan algorithm: [https://github.com/google/sanitizers/wiki/ThreadSanitizerAlgorithm](https://github.com/google/sanitizers/wiki/ThreadSanitizerAlgorithm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Address space layout randomization: [https://en.wikipedia.org/wiki/Address_space_layout_randomization](https://en.wikipedia.org/wiki/Address_space_layout_randomization)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GoogleTest User’s Guide: [https://google.github.io/googletest](https://google.github.io/googletest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
