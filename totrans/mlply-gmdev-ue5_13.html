<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-254"><a id="_idTextAnchor255"/>13</h1>
<h1 id="_idParaDest-255"><a id="_idTextAnchor256"/>Handling Data During a Session</h1>
<p>To work on a multiplayer game, you need a solid system in place to manage the flow of data between levels. This means tracking variables – such as character inventory or health – to keep players up to date with the information they need. In short, an effective multiplayer game requires careful management of data to ensure a smooth, engaging experience for all players.</p>
<p>In this chapter, you’ll be adding the final touches to the previous chapter’s session system by creating a system that will serve as an entry point for the players. This means working on a new level that will let the player create a session – if they’re starting the game as a server – or look for available sessions in the network – if they’re playing as a client.</p>
<p>Additionally, you will learn how to customize the player character – by adding skin variants – and how to send this data from the session selection level to the actual game level. This will make your character special and even more cool and colorful than before!</p>
<p>By the end of the chapter, you will be able to host a local network game session with a computer acting as a listen server and other PCs connecting to it as clients and have different skins for every player in the game.</p>
<p>In this chapter, I will guide you through the following sections:</p>
<ul>
<li>Creating the main menu level</li>
<li>Handling data during a session</li>
<li>Making further improvements</li>
</ul>
<h1 id="_idParaDest-256"><a id="_idTextAnchor257"/>Technical requirements</h1>
<p>To follow the topics presented in this chapter, you should have completed <a href="B18203_12.xhtml#_idTextAnchor239"><em class="italic">Chapter 12</em></a>, <em class="italic">Managing Multiplayer Sessions</em>, and understood its content.</p>
<p>Additionally, if you would prefer to begin with the code from the companion repository for this book, you can download the <code>.zip</code> project files provided in this book’s companion project repository: <a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</a>.</p>
<p>You can download the files that are up to date with the end of the previous chapter by clicking the <code>Unreal Shadows – </code><a href="B18203_12.xhtml#_idTextAnchor239"><em class="italic">Chapter 12</em></a><code> </code><code>End</code> link.</p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor258"/>Creating the main menu level</h1>
<p>In this section, you’ll be<a id="_idIndexMarker735"/> working on creating a new level that will serve as a starting point for creating a game session or joining one. You’ll be leveraging the power and flexibility of the previously created user interface by adding the needed Gameplay Framework classes, such as a dedicated GameMode and a player Pawn.</p>
<p>First things first, let’s open up your programming IDE and start writing some code!</p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor259"/>Creating the Pawn</h2>
<p>In this <a id="_idIndexMarker736"/>subsection, you’ll be creating a Pawn that will show the character model and activate the user interface through its controller. This Actor will also be used to show the character model when the player enters the main menu level.</p>
<p>So, from the Unreal Engine Editor, create a new C++ class extending from <code>US_MainMenuPawn</code>. Once the class has been created, open the <code>US_MainMenuPawn.h</code> header file and add the following code just after the <code>GENERATED_BODY()</code> macro:</p>
<pre class="source-code">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Arrow", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UArrowComponent&gt; Arrow;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Camera", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UCameraComponent&gt; Camera;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Camera", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;USkeletalMeshComponent&gt; Mesh;</pre>
<p>Then, in the <code>protected</code> section, add the corresponding getter functions:</p>
<pre class="source-code">
FORCEINLINE UArrowComponent* GetArrow() const { return Arrow; }
FORCEINLINE UCameraComponent* GetCamera() const { return Camera; }
FORCEINLINE USkeletalMeshComponent* GetMesh() const { return Mesh; }</pre>
<p>All of the <a id="_idIndexMarker737"/>previous code is quite straightforward, and you should already be familiar with it from the previous chapters; we are declaring the needed components – an arrow, a camera, and a mesh – and then we are exposing the corresponding getter methods.</p>
<p>Next, open the <code>US_MainMenuPawn.cpp</code> file and add the needed <code>include</code> declarations:</p>
<pre class="source-code">
#include "Camera/CameraComponent.h"
#include "Components/ArrowComponent.h"</pre>
<p>Then, locate the constructor and add the following code:</p>
<pre class="source-code">
Arrow = CreateDefaultSubobject&lt;UArrowComponent&gt;(TEXT("Arrow"));
RootComponent = Arrow;
Camera = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT("Camera"));
Camera-&gt;SetupAttachment(RootComponent);
Camera-&gt;SetRelativeLocation(FVector(450.f, 90.f, 160.f));
Camera-&gt;SetRelativeRotation(FRotator(-10.f, 180.f, 0.f));
Mesh = CreateDefaultSubobject&lt;USkeletalMeshComponent&gt;(TEXT("Mesh"));
Mesh-&gt;SetupAttachment(RootComponent);
Camera-&gt;SetRelativeLocation(FVector(0.f, -30.f, 90.f));
static ConstructorHelpers::FObjectFinder&lt;USkeletalMesh&gt; SkeletalMeshAsset(TEXT("/Game/KayKit/Characters/rogue"));
if (SkeletalMeshAsset.Succeeded())
{
 Mesh-&gt;SetSkeletalMesh(SkeletalMeshAsset.Object);
}</pre>
<p>We are <a id="_idIndexMarker738"/>not adding anything new here. As normal, we are just adding a list of components for the Actor, including a utility arrow element, the mesh, and the camera.</p>
<p>Now that the basic <code>Pawn</code> class has been created, it’s time to implement a Blueprint from it and add the previously created user interface. So, return to the Unreal Engine Editor and, in the <code>BP_MainMenuPawn</code>. Then, open the Blueprint and, in the Event Graph, complete the following steps:</p>
<ol>
<li>Add a <strong class="bold">Get Player </strong><strong class="bold">Controller</strong> node.</li>
<li>Add a <strong class="bold">Create Widget</strong> node to the graph and connect its incoming execution pin to the outgoing execution pin of the <strong class="bold">Event </strong><strong class="bold">BeginPlay</strong> node.</li>
<li>From the <strong class="bold">Class</strong> drop-down menu, select the <strong class="bold">WB_MainMenu</strong> class.</li>
<li>Connect the <strong class="bold">Owning Player</strong> pin to the <strong class="bold">Return</strong> value of the <strong class="bold">Get Player </strong><strong class="bold">Controller</strong> node.</li>
<li>From <a id="_idIndexMarker739"/>the outgoing execution pin of the <strong class="bold">Create Widget</strong> node, click and drag to add an <strong class="bold">Add to Viewport</strong> node. Then, connect the <strong class="bold">Target</strong> pin to <strong class="bold">Return Value</strong> of the <strong class="bold">Create </strong><strong class="bold">Widget</strong> node.</li>
<li>Click and drag from <strong class="bold">Return Value</strong> of the <strong class="bold">Get Player Controller</strong> node to add <strong class="bold">Set Show Mouse Cursor</strong>. Then, tick the <strong class="bold">Show Mouse Cursor</strong> checkbox and connect the incoming execution pin to the outgoing execution pin of the <strong class="bold">Add to </strong><strong class="bold">Viewport</strong> node.</li>
</ol>
<p>The final graph is depicted in <em class="italic">Figure 13</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 13.1 – The final graph for the BP_MainMenuPawn Blueprint" src="img/Figure_13_01_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – The final graph for the BP_MainMenuPawn Blueprint</p>
<p>The <code>BP_MainMenuPawn</code> Blueprint is complete and ready to go, so we can now move on to working on the GameMode class.</p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor260"/>Creating the GameMode</h2>
<p>It’s now time <a id="_idIndexMarker740"/>to create the GameMode that will handle the main menu level. In the <code>BP_MainMenuGameMode</code>.</p>
<p>Next, open the Blueprint. Then, in the <strong class="bold">Details</strong> panel, locate the <strong class="bold">Classes</strong> category and, in the <strong class="bold">Default Pawn Class</strong> drop-down menu, select <strong class="bold">BP_MainMenuPawn</strong>, as shown in <em class="italic">Figure 13</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 13.2 – The BP_MainMenuGameMode settings" src="img/Figure_13_02_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – The BP_MainMenuGameMode settings</p>
<p>The GameMode <a id="_idIndexMarker741"/>is now ready; we just need to create a new level and use it to show the session user interface.</p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor261"/>Creating the level</h2>
<p>Creating the<a id="_idIndexMarker742"/> main menu level is quite straightforward:</p>
<ol>
<li>Open the <code>Content</code> | <code>Maps</code> folder.</li>
<li>From the main menu, select <code>Level_MainMenu</code>.</li>
<li>Open the level and, in the <strong class="bold">Worlds Settings</strong> panel, locate <strong class="bold">GameMode Override</strong>. In the corresponding drop-down menu, select <strong class="bold">BP_MainMenuGameMode</strong>.</li>
<li>In the <strong class="bold">Editor</strong> main menu, select <strong class="bold">Edit</strong> | <strong class="bold">Project Settings</strong> and, in the newly opened window, locate the <strong class="bold">Maps &amp; Modes</strong> section. Then, from the <strong class="bold">Editor Template Map Overrides</strong> drop-down menu, select <strong class="bold">Level_MainMenu</strong>.</li>
</ol>
<p>Congratulations, you’ve <a id="_idIndexMarker743"/>made it through this section and built your game’s starting level! With this, your players can now create and host game sessions like a boss on their LAN or join in on the action as a client. Let’s start testing these features by playing the game.</p>
<h2 id="_idParaDest-261"><a id="_idTextAnchor262"/>Testing the session system</h2>
<p>To start <a id="_idIndexMarker744"/>testing a game session, open the <strong class="bold">Level_MainMenu</strong> map and play with these settings:</p>
<ul>
<li>Set <strong class="bold">Net Mode</strong> set to <strong class="bold">Play Standalone</strong></li>
<li>Set <code>3</code></li>
</ul>
<p> You will see the user interface you’ve created so far, as depicted in <em class="italic">Figure 13</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 13.3 – The user interface" src="img/Figure_13_03_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – The user interface</p>
<p>From this interface, you will be able to create a session, like so:</p>
<ol>
<li>From the <strong class="bold">Max Players</strong> spinner, set the maximum number of players to <strong class="bold">3</strong> or more.</li>
<li>Click the <strong class="bold">Create</strong> button; you will start the game and see the game level.</li>
</ol>
<p>Then, to join a session, follow these steps:</p>
<ol>
<li>Select <a id="_idIndexMarker745"/>one of the other opened clients and click the <strong class="bold">Find Session</strong> button; this operation will start the server search and, after a while, you should see the list of available servers in the LAN, along with the number of players already connected. <em class="italic">Figure 13</em><em class="italic">.4</em> shows a game where there is a player already connected (that is, the listen server) with a maximum of 3 players:</li>
</ol>
<div><div><img alt="Figure 13.4 – The session search result" src="img/Figure_13_04_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – The session search result</p>
<ol>
<li value="2">Click the <strong class="bold">Join Session</strong> button to, well... join the session. Your character will be teleported to the game level and you will be able to start playing.</li>
</ol>
<p>In this section, you <a id="_idIndexMarker746"/>were introduced to session management and learned how to create, search for, and join sessions in a multiplayer game.</p>
<p>Brace yourself because, in the upcoming section, you’ll be spicing up your game with an extra dose of customization. That’s right – get ready to add skin variants that will make each player’s character truly one of a kind. It’s time to get creative and let your imagination run wild!</p>
<h1 id="_idParaDest-262"><a id="_idTextAnchor263"/>Handling data during a session</h1>
<p>In this section, you’ll <a id="_idIndexMarker747"/>be working on a new topic: passing data from one level to another when joining a session. You already possess almost all the knowledge necessary to perform this task – you just need to put things together.</p>
<p>What we need to do here is create a skin system for the character model that will do the following:</p>
<ul>
<li>Select a random skin in the main menu level from a list of possible variants</li>
<li>Store this data while joining a session</li>
<li>Update the character skin variant once the session has been joined</li>
</ul>
<p>In the following steps, you will be working on a class that has remained inactive until this point, but that will prove to be incredibly useful moving forward. So, get ready to put the <strong class="bold">US_GameInstance</strong> class to work and see what it can do!</p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor264"/>Updating the US_GameInstance class</h2>
<p>You may <a id="_idIndexMarker748"/>have forgotten but, at the beginning of this project, you created the <strong class="bold">US_GameInstance</strong> class. This class offers a couple of interesting peculiarities:</p>
<ul>
<li>It is persistent across levels</li>
<li>It is unique for each client (that is, it is not replicated over the network)</li>
</ul>
<p>These features make it an awesome candidate for transporting data between levels while keeping them locally. You can use it to pass things such as the experience points gained by a player or their actual equipment. In our case, we will be using it to store a really <a id="_idIndexMarker749"/>simple piece of information: an index of the selected skin of the character (we’ll be implementing the skin list later in this chapter).</p>
<p>Open the <code>US_GameInstance.h</code> header file and, in the <code>public</code> section, add this declaration:</p>
<pre class="source-code">
UPROPERTY(BlueprintReadWrite)
int32 SkinIndex;</pre>
<p>As easy as it may seem, it’s all we need to pass the skin selection from one level to another!</p>
<p>In the next few steps, we will be creating a data structure to handle the character skin variants.</p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor265"/>Adding the CharacterSkins data</h2>
<p>In this <a id="_idIndexMarker750"/>subsection, you’ll be creating a data structure similar to the one you created in <a href="B18203_06.xhtml#_idTextAnchor125"><em class="italic">Chapter 6</em></a>, <em class="italic">Replicating Properties </em><em class="italic">O</em><em class="italic">ver the Network</em>, but this time, you will be storing just material references that will be used to change the character’s mesh colors.</p>
<p>The character model has six materials, as shown in <em class="italic">Figure 13</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 13.5 – The character model materials" src="img/Figure_13_05_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – The character model materials</p>
<p>For the <a id="_idIndexMarker751"/>character customization, we will only need four of them - specifically, <strong class="bold">Element 0</strong>, <strong class="bold">Element 1</strong>, and <strong class="bold">Element 2</strong>, all of which will change the character’s hair and clothes, and <strong class="bold">Element 4</strong>, which will change the character’s skin.</p>
<h3>Creating the structure</h3>
<p>To create<a id="_idIndexMarker752"/> the structure that will contain the skin data, open your programming IDE and create a file named <code>US_CharacterSkins.h</code>. Then, inside that file, add the following code:</p>
<pre class="source-code">
#pragma once
#include "CoreMinimal.h"
#include "Engine/DataTable.h"
#include "US_CharacterSkins.generated.h"
USTRUCT(BlueprintType)
struct UNREALSHADOWS_LOTL_API FUS_CharacterSkins : public FTableRowBase
{
 GENERATED_BODY()
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 UMaterialInterface *Material4;
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 UMaterialInterface *Material0;
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 UMaterialInterface *Material1;
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 UMaterialInterface *Material2;
};</pre>
<p>As you <a id="_idIndexMarker753"/>can see, we are creating a data structure from <code>FTableRowBase</code> – the structure that will let us create data tables – and then we are declaring the four material references. As a side note, remember that the <code>UNREALSHADOWS_LOTL_API API </code>identifier may change, depending on your project name.</p>
<p>In the next steps, you will be creating the actual skin data out of this structure by generating a data table.</p>
<h3>Creating the data table</h3>
<p>Now that you <a id="_idIndexMarker754"/>have created a data structure, you are ready to create the actual data from it. To create your skin data table, follow these steps:</p>
<ol>
<li>Open your <strong class="bold">Blueprints</strong> folder in the Content Browser, right-click, and select <strong class="bold">Miscellaneous</strong> | <strong class="bold">Data Table</strong>.</li>
<li>In the <strong class="bold">Pick Row Structure</strong> pop-up window, select <strong class="bold">US_CharacterSkins</strong> from the drop-down menu.</li>
<li>Click the <code>DT_CharacterSkins</code>.</li>
<li>Double-click on the newly created asset to open it. You will get an empty dataset; create your character skin rows by using any material from the project (or create custom materials!).</li>
</ol>
<p>During the development phase, I like to create debug skins that will help me identify each unique character. In this case, I used a single color for all the elements in a row set (that is, all green, all red, or all blue), as shown in <em class="italic">Figure 13</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 13.6 – The Skins data table" src="img/Figure_13_06_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – The Skins data table</p>
<p>Once you are <a id="_idIndexMarker755"/>satisfied with the skin system and you have battle-tested it, you will need some more realistic skins for your thief character; this process will be as easy as creating a new data table with the skin colors of your choice and setting this table as the selected one in the <strong class="bold">Pawn</strong> variable.</p>
<p>Now that you have a skin catalog asset, you can start adding code to the main menu <code>Pawn</code> class to set its skins at runtime.</p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor266"/>Updating the US_MainMenuPawn class</h2>
<p>In this <a id="_idIndexMarker756"/>section, you’ll be enhancing your character’s appearance by assigning a random skin. Every time players connect to the main menu level, their character will be allotted a unique set of colors for their skin, taken from the previously created data table. So, get ready to see a little more variety in your game!</p>
<p>As I mentioned previously, you dealt with this in <a href="B18203_06.xhtml#_idTextAnchor125"><em class="italic">Chapter 6</em></a>, <em class="italic">Replicating Properties Over the Network</em>, but as the old saying goes, practice makes perfect!</p>
<p>With<a id="_idIndexMarker757"/> your programming IDE, open the <code>US_MainMenuPawn.h</code> header file and, in the implicit <code>private</code> section, add the data table and skin declarations:</p>
<pre class="source-code">
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Character Data", meta = (AllowPrivateAccess = "true"))
class UDataTable* CharacterSkinDataTable;
struct FUS_CharacterSkins* CharacterSkin;</pre>
<p>Next, in the <code>public</code> section, add the getter method for the selected character skin:</p>
<pre class="source-code">
FORCEINLINE FUS_CharacterSkins* GetCharacterSkin() const { return CharacterSkin; }</pre>
<p>And in the <code>protected</code> section, declare a function that will handle the skin randomization process:</p>
<pre class="source-code">
void RandomizeCharacterSkin();</pre>
<p>Now, you can open the <code>US_MainMenuPawn.cpp</code> file to start adding the skin handling implementation. First of all, declare the needed includes:</p>
<pre class="source-code">
#include "US_CharacterSkins.h"
#include "US_GameInstance.h"</pre>
<p>Then, add the <code>RandomizeCharacterSkin()</code> implementation:</p>
<pre class="source-code">
void AUS_MainMenuPawn::RandomizeCharacterSkin()
{
 if(CharacterSkinDataTable)
 {
  TArray&lt;FUS_CharacterSkins*&gt; CharacterSkinsRows;
  CharacterSkinDataTable-&gt;GetAllRows&lt;FUS_CharacterSkins&gt;(TEXT("US_Character"), CharacterSkinsRows);
  if(CharacterSkinsRows.Num() &gt; 0)
  {
   const auto NewIndex = FMath::RandRange(0, CharacterSkinsRows.Num() - 1);
   CharacterSkin = CharacterSkinsRows [NewIndex];
   Mesh-&gt;SetMaterial(4, CharacterSkinsRows[NewIndex]-&gt;Material4);
   Mesh-&gt;SetMaterial(0, CharacterSkinsRows[NewIndex]-&gt;Material0);
   Mesh-&gt;SetMaterial(1, CharacterSkinsRows[NewIndex]-&gt;Material1);
   Mesh-&gt;SetMaterial(2, CharacterSkinsRows[NewIndex]-&gt;Material2);
   if (const auto GameInstance = Cast&lt;UUS_GameInstance&gt;(GetGameInstance()))
   {
    GameInstance-&gt;SkinIndex = NewIndex;
   }
  }
 }</pre>
<p>As you can see, we <a id="_idIndexMarker758"/>are retrieving all the data rows from the table reference and, after checking that there is at least one item in the table, we get a random row and set the pawn mesh materials to its included data. This will update the pawn shown in the level. After that, we retrieve the game instance as a <code>UUS_GameInstance</code> type and assign the previously randomized index to the <code>SkinIndex</code> property.</p>
<p>As a<a id="_idIndexMarker759"/> last step, we will be adding the randomization call when the game is started. So, in the <code>BeginPlay()</code> method, add the following code:</p>
<pre class="source-code">
if(IsLocallyControlled())
{
 RandomizeCharacterSkin();
}</pre>
<p>We now need to set the data table from the Blueprint, so let’s switch back to the Unreal Engine Editor.</p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor267"/>Updating the BP_MainMenuPawn Blueprint</h2>
<p>Now that<a id="_idIndexMarker760"/> the <code>Pawn</code> class is ready, you just have to assign the previously created data table to the Pawn Blueprint. To do so, open <code>BP_MainMenuPawn</code> and do the following:</p>
<ol>
<li>In the <strong class="bold">Details</strong> panel, look for the <strong class="bold">Character Skin Data </strong><strong class="bold">Table</strong> property.</li>
<li>From its drop-down menu, select <strong class="bold">DT_CharacterSkins</strong>, as shown in <em class="italic">Figure 13</em><em class="italic">.7</em>:</li>
</ol>
<div><div><img alt="Figure 13.7 – The character skin data table property" src="img/Figure_13_07_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – The character skin data table property</p>
<ol>
<li value="3">If you test the game, you will get a randomized skin for each of the characters, as depicted in <em class="italic">Figure 13</em><em class="italic">.8</em>:</li>
</ol>
<div><div><img alt="Figure 13.8 – The starting skin randomization" src="img/Figure_13_08_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – The starting skin randomization</p>
<p>The <a id="_idIndexMarker761"/>character randomization is complete; to take full advantage of it, we just need to retrieve the data from the game level side and assign it to the playing character.</p>
<h2 id="_idParaDest-267"><a id="_idTextAnchor268"/>Updating the US_Character class</h2>
<p>In this <a id="_idIndexMarker762"/>subsection, you will be retrieving the skin index data from the game instance and setting it to the player character. This process is quite straightforward once you remember that the game instance is persistent across levels and is not replicated (that is, each client has its own dedicated one).</p>
<p>Start by opening the <code>US_Character.h</code> header file from your programming IDE and declare the needed data table properties in the implicit <code>private</code> section:</p>
<pre class="source-code">
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Character Data", meta = (AllowPrivateAccess = "true"))
UDataTable* CharacterSkinDataTable;
struct FUS_CharacterSkins* CharacterSkin;</pre>
<p>I know you are already familiar with the previous declarations, so I won’t waste your time by explaining them again.</p>
<p>Next, in <a id="_idIndexMarker763"/>the <code>protected</code> section, you need to add the following declarations. These will handle the skin update:</p>
<pre class="source-code">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, ReplicatedUsing="OnRep_SkinChanged", Category = "Skin")
int32 SkinIndex = 0;
UFUNCTION()
void OnRep_SkinChanged(int32 OldValue);
UFUNCTION(Server, Reliable)
void SetSkinIndex_Server(int32 Value);
UFUNCTION()
void UpdateCharacterSkin();</pre>
<p>And in the <code>public</code> section, add the following code:</p>
<pre class="source-code">
FORCEINLINE FUS_CharacterSkins* GetCharacterSkins() const { return CharacterSkin; }
virtual void GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const override;</pre>
<p>As you may remember from <a href="B18203_06.xhtml#_idTextAnchor125"><em class="italic">Chapter 6</em></a>, <em class="italic">Replicating Properties Over the Network</em>, whenever you need to replicate a property, you can use the <code>ReplicatedUsing</code> property specifier to notify all clients that the property value has changed. In this case, we will replicate the <code>SkinIndex</code> variable to let all of the clients update their character skins once they join a session.</p>
<p>Additionally, always keep in mind that, to replicate a property, it should be initialized inside the <code>GetLifetimeReplicatedProps()</code> method through the <code>DOREPLIFETIME</code> macro, which is why we declared that method.</p>
<p>To<a id="_idIndexMarker764"/> implement all the replication logic and skin update, open the <code>US_Character.cpp</code> file and start by adding the needed <code>include</code> declarations:</p>
<pre class="source-code">
#include "US_GameInstance.h"
#include "US_CharacterSkins.h"
#include "Net/UnrealNetwork.h"</pre>
<p>Then, add the <code>GetLifetimeReplicatedProps()</code> method implementation to implement the property replication:</p>
<pre class="source-code">
void AUS_Character::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const
{
 Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 DOREPLIFETIME(AUS_Character, SkinIndex);
}</pre>
<p>Next, add the <code>OnRep_SkinChanged()</code> method. This will be executed every time the <code>SkinIndex</code> value is updated from the server to the clients:</p>
<pre class="source-code">
void AUS_Character::OnRep_SkinChanged(int32 OldValue)
{
 UpdateCharacterSkin();
}</pre>
<p>Then, implement the skin index update from the server side by adding the <code>SetSkinIndex_Server_Implementation()</code> method:</p>
<pre class="source-code">
void AUS_Character::SetSkinIndex_Server_Implementation(const int32 Value)
{
 SkinIndex = Value;
 UpdateCharacterSkin();
}</pre>
<p>Note that we are calling the <code>UpdateCharacerSkin()</code> event from the server side; this is mandatory if you are using a listen server because the previous method will be called only on the clients and, in that case, the server will not update the skin.</p>
<p>The <a id="_idIndexMarker765"/>fourth method, <code>UpdateCharacterSkin()</code>, will take care of retrieving the data from the game instance and updating the character mesh materials. To do so, add the following implementation:</p>
<pre class="source-code">
void AUS_Character::UpdateCharacterSkin()
{
 if(CharacterSkinDataTable)
 {
  TArray&lt;FUS_CharacterSkins*&gt; CharacterSkinsRows;
  CharacterSkinDataTable-&gt;GetAllRows&lt;FUS_CharacterSkins&gt;(TEXT("US_Character"), CharacterSkinsRows);
  if(CharacterSkinsRows.Num() &gt; 0)
  {
   const auto Index = FMath::Clamp(SkinIndex, 0, CharacterSkinsRows.Num() - 1);
   CharacterSkin = CharacterSkinsRows[Index];
   GetMesh()-&gt;SetMaterial(4, CharacterSkin-&gt;Material4);
   GetMesh()-&gt;SetMaterial(0, CharacterSkin-&gt;Material0);
   GetMesh()-&gt;SetMaterial(1, CharacterSkin-&gt;Material1);
   GetMesh()-&gt;SetMaterial(2, CharacterSkin-&gt;Material2);
  }
 }
}</pre>
<p>What we<a id="_idIndexMarker766"/> are doing here is almost identical to the main menu Pawn class; we are getting a row from the skin data table and assigning the materials to the character mesh. The only difference is that we are not setting the skin index to the game instance, and we are getting a replicated version of it instead.</p>
<p>As a last step, you will need to add the following code at the end of the <code>BeginPlay()</code> method’s implementation:</p>
<pre class="source-code">
if(IsLocallyControlled())
{
 if(const auto GameInstanceCast = Cast&lt;UUS_GameInstance&gt;(GetWorld()-&gt;GetGameInstance()); GameInstanceCast != nullptr)
 {
  SetSkinIndex_Server(GameInstanceCast-&gt;SkinIndex);
 }
}</pre>
<p>This portion of the code checks that the instance of this class is locally controlled (that is, it is a player-owned character) and gets the skin index from the game instance. Then, it calls the <code>SetSkinIndex()</code> server function to notify all the clients that they should update this character look.</p>
<p>As for the main menu Pawn class, you now need to update the corresponding Blueprint to declare the skin data table.</p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor269"/>Updating the BP_Character Blueprint</h2>
<p>Now that <a id="_idIndexMarker767"/>the character class is ready, you just have to assign the previously created data table to the corresponding Blueprint. To do so, follow these steps:</p>
<ol>
<li>Open <strong class="bold">BP_Character</strong>.</li>
<li>In the <strong class="bold">Details</strong> panel, look for the <strong class="bold">Character Skin Data </strong><strong class="bold">Table</strong> property.</li>
<li>From its drop-down menu, select <strong class="bold">DT_CharacterSkins</strong>, as shown in <em class="italic">Figure 13</em><em class="italic">.9</em>:</li>
</ol>
<div><div><img alt="Figure 13.9 – The character skin data table property" src="img/Figure_13_09_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – The character skin data table property</p>
<p>If you test the game now, you will be able to get a randomized skin for each of the characters and keep that skin once a session is joined, as depicted in <em class="italic">Figure 13</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 13.10 – Gameplay with skinned characters" src="img/Figure_13_10_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10 – Gameplay with skinned characters</p>
<p>In this <a id="_idIndexMarker768"/>section, you learned how to keep data when creating or joining a session. You did this by using the game instance as a sort of data bridge to create a skinning feature; this will make each character unique and even more appealing to the players, helping you give them a killer makeover that will make the Lichlord quake in his boots!</p>
<p>In the upcoming section, I won’t be introducing any new topics; instead, I’ll give you some additional ideas to help you better manage your game sessions.</p>
<h1 id="_idParaDest-269"><a id="_idTextAnchor270"/>Making further improvements</h1>
<p>In the previous sections, you<a id="_idIndexMarker769"/> did a great job of understanding how to pass data between sessions to make your multiplayer game even more engaging. Now, it’s time to make your game even better by adding some additional functionalities. In this section, I’ll offer some tips to help you add some excitement to your project. As always, don’t be afraid to add your personal touch and make it truly yours.</p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor271"/>Leaving and destroying sessions</h2>
<p>In this<a id="_idIndexMarker770"/> chapter and the previous one, you have used three out of four session commands – <strong class="bold">Create Session</strong>, <strong class="bold">Join Session</strong>, and <strong class="bold">Find Session</strong> – but the <strong class="bold">Destroy Session</strong> command has been left unused. Use the <strong class="bold">Destroy Session</strong> command node to let the player leave a playing session.</p>
<p>This will be <a id="_idIndexMarker771"/>implemented in the game level (and not in the main menu one) as the player will need to leave the session after joining one. To implement this feature, you may want to create a dedicated user interface that will let players leave the game whenever they decide to do so.</p>
<p>As a side note, keep in mind that clients and the server behave differently regarding a session, so you will have to manage two kinds of session destruction: the one from the client – which will be almost painless – and, in the case of a client/server host, the server one – which will have to destroy all sessions from all clients (that is, all clients should leave the session as the server is not functional anymore).</p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor272"/>Handling player death</h2>
<p>At the <a id="_idIndexMarker772"/>moment, whenever a player is captured by a Lichlord minion, nothing will happen – you will get just a screen message and the player will keep on playing.</p>
<p>You can manage a player’s death in many ways, but here are a couple of ideas for you:</p>
<ul>
<li>Destroy the player session and reload the main menu level to let the player join a new session. Just keep in mind that, if the player that is defeated is the server host, all other players will be immediately removed from the session.</li>
<li>Use a respawn method, where the character will be placed in an available spawn point without the need to rejoin the session.</li>
</ul>
<h2 id="_idParaDest-272"><a id="_idTextAnchor273"/>Selecting the player skin</h2>
<p>In this <a id="_idIndexMarker773"/>chapter, you developed a random skin generator, but wouldn’t be cool to let the players choose their own skin? You may add a user interface in the main menu level that will let the players do the following:</p>
<ul>
<li>Randomize the skin again if it does not suit their needs</li>
<li>Select the desired skin from the full set using a dedicated selection method</li>
</ul>
<p>Well, this<a id="_idIndexMarker774"/> could be the tip of the iceberg when it comes to creating a skin system that works like a charm and gets envious stares from your competitors. Who knows? Implementing your in-game purchases might even make games such as Fortnite weak in the knees!</p>
<h1 id="_idParaDest-273"><a id="_idTextAnchor274"/>Summary</h1>
<p>In this chapter, you developed a fully functional system to pass data from one level to another during a game session. In this case, you focused on a skin system for the player character, but the use cases for this feature are almost endless.</p>
<p>As you may have noticed, session handling is a huge topic – it took two chapters to properly explain its main functionalities – and to succeed in the multiplayer world, it is imperative to have a strong grasp of it. If you want to ride the wave of success, then mastering this skill is a non-negotiable topic!</p>
<p>In the next chapter, I will guide you through a brand new topic: how to properly package your game. Get ready to dive into the exciting world of project packaging so that you can deploy your game like a boss on both server and client ends! Are you ready for this adventure?</p>
</div>
</body></html>