<html><head></head><body>
<div id="_idContainer230">
<h1 class="chapter-number" id="_idParaDest-254"><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-255"><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.2.1">Handling Data During a Session</span></h1>
<p><span class="koboSpan" id="kobo.3.1">To work on a multiplayer game, you need a solid system in place to manage the flow of data between levels. </span><span class="koboSpan" id="kobo.3.2">This means tracking variables – such as character inventory or health – to keep players up to date with the information they need. </span><span class="koboSpan" id="kobo.3.3">In short, an effective multiplayer game requires careful management of data to ensure a smooth, engaging experience for </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">all players.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, you’ll be adding the final touches to the previous chapter’s session system by creating a system that will serve as an entry point for the players. </span><span class="koboSpan" id="kobo.5.2">This means working on a new level that will let the player create a session – if they’re starting the game as a server – or look for available sessions in the network – if they’re playing as </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">a client.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Additionally, you will learn how to customize the player character – by adding skin variants – and how to send this data from the session selection level to the actual game level. </span><span class="koboSpan" id="kobo.7.2">This will make your character special and even more cool and colorful </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">than before!</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">By the end of the chapter, you will be able to host a local network game session with a computer acting as a listen server and other PCs connecting to it as clients and have different skins for every player in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">the game.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, I will guide you through the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following sections:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Creating the main </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">menu level</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Handling data during </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">a session</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Making </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">further improvements</span></span></li>
</ul>
<h1 id="_idParaDest-256"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">To follow the topics presented in this chapter, you should have completed </span><a href="B18203_12.xhtml#_idTextAnchor239"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.21.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.22.1">, </span><em class="italic"><span class="koboSpan" id="kobo.23.1">Managing Multiplayer Sessions</span></em><span class="koboSpan" id="kobo.24.1">, and understood </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">its content.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">Additionally, if you would prefer to begin with the code from the companion repository for this book, you can download the </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">.zip</span></strong><span class="koboSpan" id="kobo.28.1"> project files provided in this book’s companion project </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">repository: </span></span><a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5"><span class="No-Break"><span class="koboSpan" id="kobo.30.1">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.31.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">You can download the files that are up to date with the end of the previous chapter by clicking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">Unreal Shadows – </span></strong><a href="B18203_12.xhtml#_idTextAnchor239"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.34.1">Chapter 12</span></em></span></a><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">End</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.36.1"> link.</span></span></p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.37.1">Creating the main menu level</span></h1>
<p><span class="koboSpan" id="kobo.38.1">In this section, you’ll be</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.39.1"> working on creating a new level that will serve as a starting point for creating a game session or joining one. </span><span class="koboSpan" id="kobo.39.2">You’ll be leveraging the power and flexibility of the previously created user interface by adding the needed Gameplay Framework classes, such as a dedicated GameMode and a </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">player Pawn.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">First things first, let’s open up your programming IDE and start writing </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">some code!</span></span></p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.43.1">Creating the Pawn</span></h2>
<p><span class="koboSpan" id="kobo.44.1">In this </span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.45.1">subsection, you’ll be creating a Pawn that will show the character model and activate the user interface through its controller. </span><span class="koboSpan" id="kobo.45.2">This Actor will also be used to show the character model when the player enters the main </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">menu level.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">So, from the Unreal Engine Editor, create a new C++ class extending from </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">Pawn</span></strong><span class="koboSpan" id="kobo.49.1"> and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">US_MainMenuPawn</span></strong><span class="koboSpan" id="kobo.51.1">. </span><span class="koboSpan" id="kobo.51.2">Once the class has been created, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">US_MainMenuPawn.h</span></strong><span class="koboSpan" id="kobo.53.1"> header file and add the following code just after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">GENERATED_BODY()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.55.1"> macro:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.56.1">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Arrow", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UArrowComponent&gt; Arrow;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Camera", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UCameraComponent&gt; Camera;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Camera", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;USkeletalMeshComponent&gt; Mesh;</span></pre>
<p><span class="koboSpan" id="kobo.57.1">Then, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">protected</span></strong><span class="koboSpan" id="kobo.59.1"> section, add the corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">getter functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.61.1">
FORCEINLINE UArrowComponent* GetArrow() const { return Arrow; }
FORCEINLINE UCameraComponent* GetCamera() const { return Camera; }
FORCEINLINE USkeletalMeshComponent* GetMesh() const { return Mesh; }</span></pre>
<p><span class="koboSpan" id="kobo.62.1">All of the </span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.63.1">previous code is quite straightforward, and you should already be familiar with it from the previous chapters; we are declaring the needed components – an arrow, a camera, and a mesh – and then we are exposing the corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">getter methods.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">Next, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">US_MainMenuPawn.cpp</span></strong><span class="koboSpan" id="kobo.67.1"> file and add the needed </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">include</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.69.1"> declarations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.70.1">
#include "Camera/CameraComponent.h"
#include "Components/ArrowComponent.h"</span></pre>
<p><span class="koboSpan" id="kobo.71.1">Then, locate the constructor and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.73.1">
Arrow = CreateDefaultSubobject&lt;UArrowComponent&gt;(TEXT("Arrow"));
RootComponent = Arrow;
Camera = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT("Camera"));
Camera-&gt;SetupAttachment(RootComponent);
Camera-&gt;SetRelativeLocation(FVector(450.f, 90.f, 160.f));
Camera-&gt;SetRelativeRotation(FRotator(-10.f, 180.f, 0.f));
Mesh = CreateDefaultSubobject&lt;USkeletalMeshComponent&gt;(TEXT("Mesh"));
Mesh-&gt;SetupAttachment(RootComponent);
Camera-&gt;SetRelativeLocation(FVector(0.f, -30.f, 90.f));
static ConstructorHelpers::FObjectFinder&lt;USkeletalMesh&gt; SkeletalMeshAsset(TEXT("/Game/KayKit/Characters/rogue"));
if (SkeletalMeshAsset.Succeeded())
{
 Mesh-&gt;SetSkeletalMesh(SkeletalMeshAsset.Object);
}</span></pre>
<p><span class="koboSpan" id="kobo.74.1">We are </span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.75.1">not adding anything new here. </span><span class="koboSpan" id="kobo.75.2">As normal, we are just adding a list of components for the Actor, including a utility arrow element, the mesh, and </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">the camera.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">Now that the basic </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">Pawn</span></strong><span class="koboSpan" id="kobo.79.1"> class has been created, it’s time to implement a Blueprint from it and add the previously created user interface. </span><span class="koboSpan" id="kobo.79.2">So, return to the Unreal Engine Editor and, in the </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">Blueprints</span></strong><span class="koboSpan" id="kobo.81.1"> folder, create a new Blueprint class extending from </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">US_MainMenuPawn</span></strong><span class="koboSpan" id="kobo.83.1"> and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">BP_MainMenuPawn</span></strong><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">Then, open the Blueprint and, in the Event Graph, complete the </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.87.1">Add a </span><strong class="bold"><span class="koboSpan" id="kobo.88.1">Get Player </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.89.1">Controller</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.90.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.91.1">Add a </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">Create Widget</span></strong><span class="koboSpan" id="kobo.93.1"> node to the graph and connect its incoming execution pin to the outgoing execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.94.1">Event </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.95.1">BeginPlay</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.96.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.97.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.98.1">Class</span></strong><span class="koboSpan" id="kobo.99.1"> drop-down menu, select the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.100.1">WB_MainMenu</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.101.1"> class.</span></span></li>
<li><span class="koboSpan" id="kobo.102.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.103.1">Owning Player</span></strong><span class="koboSpan" id="kobo.104.1"> pin to the </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">Return</span></strong><span class="koboSpan" id="kobo.106.1"> value of the </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">Get Player </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.108.1">Controller</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.109.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.110.1">From </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.111.1">the outgoing execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">Create Widget</span></strong><span class="koboSpan" id="kobo.113.1"> node, click and drag to add an </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">Add to Viewport</span></strong><span class="koboSpan" id="kobo.115.1"> node. </span><span class="koboSpan" id="kobo.115.2">Then, connect the </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">Target</span></strong><span class="koboSpan" id="kobo.117.1"> pin to </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">Return Value</span></strong><span class="koboSpan" id="kobo.119.1"> of the </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">Create </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.121.1">Widget</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.122.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.123.1">Click and drag from </span><strong class="bold"><span class="koboSpan" id="kobo.124.1">Return Value</span></strong><span class="koboSpan" id="kobo.125.1"> of the </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">Get Player Controller</span></strong><span class="koboSpan" id="kobo.127.1"> node to add </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">Set Show Mouse Cursor</span></strong><span class="koboSpan" id="kobo.129.1">. </span><span class="koboSpan" id="kobo.129.2">Then, tick the </span><strong class="bold"><span class="koboSpan" id="kobo.130.1">Show Mouse Cursor</span></strong><span class="koboSpan" id="kobo.131.1"> checkbox and connect the incoming execution pin to the outgoing execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">Add to </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.133.1">Viewport</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.134.1"> node.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.135.1">The final graph is depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.136.1">Figure 13</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.137.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer220">
<span class="koboSpan" id="kobo.139.1"><img alt="Figure 13.1 – The final graph for the BP_MainMenuPawn Blueprint" src="image/Figure_13_01_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.140.1">Figure 13.1 – The final graph for the BP_MainMenuPawn Blueprint</span></p>
<p><span class="koboSpan" id="kobo.141.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">BP_MainMenuPawn</span></strong><span class="koboSpan" id="kobo.143.1"> Blueprint is complete and ready to go, so we can now move on to working on the </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">GameMode class.</span></span></p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.145.1">Creating the GameMode</span></h2>
<p><span class="koboSpan" id="kobo.146.1">It’s now time </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.147.1">to create the GameMode that will handle the main menu level. </span><span class="koboSpan" id="kobo.147.2">In the </span><strong class="bold"><span class="koboSpan" id="kobo.148.1">Blueprints</span></strong><span class="koboSpan" id="kobo.149.1"> folder, create a new Blueprint class extending from </span><strong class="bold"><span class="koboSpan" id="kobo.150.1">GameMode</span></strong><span class="koboSpan" id="kobo.151.1"> and call </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">BP_MainMenuGameMode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">Next, open the Blueprint. </span><span class="koboSpan" id="kobo.155.2">Then, in the </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">Details</span></strong><span class="koboSpan" id="kobo.157.1"> panel, locate the </span><strong class="bold"><span class="koboSpan" id="kobo.158.1">Classes</span></strong><span class="koboSpan" id="kobo.159.1"> category and, in the </span><strong class="bold"><span class="koboSpan" id="kobo.160.1">Default Pawn Class</span></strong><span class="koboSpan" id="kobo.161.1"> drop-down menu, select </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">BP_MainMenuPawn</span></strong><span class="koboSpan" id="kobo.163.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.164.1">Figure 13</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.165.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer221">
<span class="koboSpan" id="kobo.167.1"><img alt="Figure 13.2 – The BP_MainMenuGameMode settings" src="image/Figure_13_02_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.168.1">Figure 13.2 – The BP_MainMenuGameMode settings</span></p>
<p><span class="koboSpan" id="kobo.169.1">The GameMode </span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.170.1">is now ready; we just need to create a new level and use it to show the session </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">user interface.</span></span></p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.172.1">Creating the level</span></h2>
<p><span class="koboSpan" id="kobo.173.1">Creating the</span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.174.1"> main menu level is </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">quite straightforward:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.176.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">Content</span></strong><span class="koboSpan" id="kobo.178.1"> | </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">Maps</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.180.1"> folder.</span></span></li>
<li><span class="koboSpan" id="kobo.181.1">From the main menu, select </span><strong class="bold"><span class="koboSpan" id="kobo.182.1">File</span></strong><span class="koboSpan" id="kobo.183.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.184.1">New Level</span></strong><span class="koboSpan" id="kobo.185.1">, select the </span><strong class="bold"><span class="koboSpan" id="kobo.186.1">Basic</span></strong><span class="koboSpan" id="kobo.187.1"> template, and call </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">Level_MainMenu</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.191.1">Open the level and, in the </span><strong class="bold"><span class="koboSpan" id="kobo.192.1">Worlds Settings</span></strong><span class="koboSpan" id="kobo.193.1"> panel, locate </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">GameMode Override</span></strong><span class="koboSpan" id="kobo.195.1">. </span><span class="koboSpan" id="kobo.195.2">In the corresponding drop-down menu, </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.197.1">BP_MainMenuGameMode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.199.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">Editor</span></strong><span class="koboSpan" id="kobo.201.1"> main menu, select </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">Edit</span></strong><span class="koboSpan" id="kobo.203.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">Project Settings</span></strong><span class="koboSpan" id="kobo.205.1"> and, in the newly opened window, locate the </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">Maps &amp; Modes</span></strong><span class="koboSpan" id="kobo.207.1"> section. </span><span class="koboSpan" id="kobo.207.2">Then, from the </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">Editor Template Map Overrides</span></strong><span class="koboSpan" id="kobo.209.1"> drop-down menu, </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.211.1">Level_MainMenu</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.213.1">Congratulations, you’ve </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.214.1">made it through this section and built your game’s starting level! </span><span class="koboSpan" id="kobo.214.2">With this, your players can now create and host game sessions like a boss on their LAN or join in on the action as a client. </span><span class="koboSpan" id="kobo.214.3">Let’s start testing these features by playing </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">the game.</span></span></p>
<h2 id="_idParaDest-261"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.216.1">Testing the session system</span></h2>
<p><span class="koboSpan" id="kobo.217.1">To start </span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.218.1">testing a game session, open the </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">Level_MainMenu</span></strong><span class="koboSpan" id="kobo.220.1"> map and play with </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">these settings:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.222.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.223.1">Net Mode</span></strong><span class="koboSpan" id="kobo.224.1"> set to </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.225.1">Play Standalone</span></strong></span></li>
<li><span class="koboSpan" id="kobo.226.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.227.1">Number of Players</span></strong><span class="koboSpan" id="kobo.228.1"> set </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">3</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.231.1"> You will see the user interface you’ve created so far, as depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.232.1">Figure 13</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.233.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer222">
<span class="koboSpan" id="kobo.235.1"><img alt="Figure 13.3 – The user interface" src="image/Figure_13_03_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.236.1">Figure 13.3 – The user interface</span></p>
<p><span class="koboSpan" id="kobo.237.1">From this interface, you will be able to create a session, </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">like so:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.239.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">Max Players</span></strong><span class="koboSpan" id="kobo.241.1"> spinner, set the maximum number of players to </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">3</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.243.1">or more.</span></span></li>
<li><span class="koboSpan" id="kobo.244.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.245.1">Create</span></strong><span class="koboSpan" id="kobo.246.1"> button; you will start the game and see the </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">game level.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.248.1">Then, to join a session, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.250.1">Select </span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.251.1">one of the other opened clients and click the </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">Find Session</span></strong><span class="koboSpan" id="kobo.253.1"> button; this operation will start the server search and, after a while, you should see the list of available servers in the LAN, along with the number of players already connected. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.254.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.255.1">.4</span></em><span class="koboSpan" id="kobo.256.1"> shows a game where there is a player already connected (that is, the listen server) with a maximum of </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">3 players:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer223">
<span class="koboSpan" id="kobo.258.1"><img alt="Figure 13.4 – The session search result" src="image/Figure_13_04_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.259.1">Figure 13.4 – The session search result</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.260.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.261.1">Join Session</span></strong><span class="koboSpan" id="kobo.262.1"> button to, well... </span><span class="koboSpan" id="kobo.262.2">join the session. </span><span class="koboSpan" id="kobo.262.3">Your character will be teleported to the game level and you will be able to </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">start playing.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.264.1">In this section, you </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.265.1">were introduced to session management and learned how to create, search for, and join sessions in a </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">multiplayer game.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">Brace yourself because, in the upcoming section, you’ll be spicing up your game with an extra dose of customization. </span><span class="koboSpan" id="kobo.267.2">That’s right – get ready to add skin variants that will make each player’s character truly one of a kind. </span><span class="koboSpan" id="kobo.267.3">It’s time to get creative and let your imagination </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">run wild!</span></span></p>
<h1 id="_idParaDest-262"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.269.1">Handling data during a session</span></h1>
<p><span class="koboSpan" id="kobo.270.1">In this section, you’ll </span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.271.1">be working on a new topic: passing data from one level to another when joining a session. </span><span class="koboSpan" id="kobo.271.2">You already possess almost all the knowledge necessary to perform this task – you just need to put </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">things together.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">What we need to do here is create a skin system for the character model that will do </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.275.1">Select a random skin in the main menu level from a list of </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">possible variants</span></span></li>
<li><span class="koboSpan" id="kobo.277.1">Store this data while joining </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">a session</span></span></li>
<li><span class="koboSpan" id="kobo.279.1">Update the character skin variant once the session has </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">been joined</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.281.1">In the following steps, you will be working on a class that has remained inactive until this point, but that will prove to be incredibly useful moving forward. </span><span class="koboSpan" id="kobo.281.2">So, get ready to put the </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">US_GameInstance</span></strong><span class="koboSpan" id="kobo.283.1"> class to work and see what it </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">can do!</span></span></p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.285.1">Updating the US_GameInstance class</span></h2>
<p><span class="koboSpan" id="kobo.286.1">You may </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.287.1">have forgotten but, at the beginning of this project, you created the </span><strong class="bold"><span class="koboSpan" id="kobo.288.1">US_GameInstance</span></strong><span class="koboSpan" id="kobo.289.1"> class. </span><span class="koboSpan" id="kobo.289.2">This class offers a couple of </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">interesting peculiarities:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.291.1">It is persistent </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">across levels</span></span></li>
<li><span class="koboSpan" id="kobo.293.1">It is unique for each client (that is, it is not replicated over </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">the network)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.295.1">These features make it an awesome candidate for transporting data between levels while keeping them locally. </span><span class="koboSpan" id="kobo.295.2">You can use it to pass things such as the experience points gained by a player or their actual equipment. </span><span class="koboSpan" id="kobo.295.3">In our case, we will be using it to store a really </span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.296.1">simple piece of information: an index of the selected skin of the character (we’ll be implementing the skin list later in </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">this chapter).</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">US_GameInstance.h</span></strong><span class="koboSpan" id="kobo.300.1"> header file and, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">public</span></strong><span class="koboSpan" id="kobo.302.1"> section, add </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">this declaration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
UPROPERTY(BlueprintReadWrite)
int32 SkinIndex;</span></pre>
<p><span class="koboSpan" id="kobo.305.1">As easy as it may seem, it’s all we need to pass the skin selection from one level </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">to another!</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">In the next few steps, we will be creating a data structure to handle the character </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">skin variants.</span></span></p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.309.1">Adding the CharacterSkins data</span></h2>
<p><span class="koboSpan" id="kobo.310.1">In this </span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.311.1">subsection, you’ll be creating a data structure similar to the one you created in </span><a href="B18203_06.xhtml#_idTextAnchor125"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.312.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.313.1">, </span><em class="italic"><span class="koboSpan" id="kobo.314.1">Replicating Properties </span></em><em class="italic"><span class="koboSpan" id="kobo.315.1">O</span></em><em class="italic"><span class="koboSpan" id="kobo.316.1">ver the Network</span></em><span class="koboSpan" id="kobo.317.1">, but this time, you will be storing just material references that will be used to change the character’s </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">mesh colors.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">The character model has six materials, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.320.1">Figure 13</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.321.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer224">
<span class="koboSpan" id="kobo.323.1"><img alt="Figure 13.5 – The character model materials" src="image/Figure_13_05_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.324.1">Figure 13.5 – The character model materials</span></p>
<p><span class="koboSpan" id="kobo.325.1">For the </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.326.1">character customization, we will only need four of them - specifically, </span><strong class="bold"><span class="koboSpan" id="kobo.327.1">Element 0</span></strong><span class="koboSpan" id="kobo.328.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.329.1">Element 1</span></strong><span class="koboSpan" id="kobo.330.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">Element 2</span></strong><span class="koboSpan" id="kobo.332.1">, all of which will change the character’s hair and clothes, and </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">Element 4</span></strong><span class="koboSpan" id="kobo.334.1">, which will change the </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">character’s skin.</span></span></p>
<h3><span class="koboSpan" id="kobo.336.1">Creating the structure</span></h3>
<p><span class="koboSpan" id="kobo.337.1">To create</span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.338.1"> the structure that will contain the skin data, open your programming IDE and create a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">US_CharacterSkins.h</span></strong><span class="koboSpan" id="kobo.340.1">. </span><span class="koboSpan" id="kobo.340.2">Then, inside that file, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.342.1">
#pragma once
#include "CoreMinimal.h"
#include "Engine/DataTable.h"
#include "US_CharacterSkins.generated.h"
USTRUCT(BlueprintType)
struct UNREALSHADOWS_LOTL_API FUS_CharacterSkins : public FTableRowBase
{
 GENERATED_BODY()
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 UMaterialInterface *Material4;
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 UMaterialInterface *Material0;
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 UMaterialInterface *Material1;
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 UMaterialInterface *Material2;
};</span></pre>
<p><span class="koboSpan" id="kobo.343.1">As you </span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.344.1">can see, we are creating a data structure from </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">FTableRowBase</span></strong><span class="koboSpan" id="kobo.346.1"> – the structure that will let us create data tables – and then we are declaring the four material references. </span><span class="koboSpan" id="kobo.346.2">As a side note, remember that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">UNREALSHADOWS_LOTL_API API </span></strong><span class="koboSpan" id="kobo.348.1">identifier may change, depending on your </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">project name.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">In the next steps, you will be creating the actual skin data out of this structure by generating a </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">data table.</span></span></p>
<h3><span class="koboSpan" id="kobo.352.1">Creating the data table</span></h3>
<p><span class="koboSpan" id="kobo.353.1">Now that you </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.354.1">have created a data structure, you are ready to create the actual data from it. </span><span class="koboSpan" id="kobo.354.2">To create your skin data table, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.356.1">Open your </span><strong class="bold"><span class="koboSpan" id="kobo.357.1">Blueprints</span></strong><span class="koboSpan" id="kobo.358.1"> folder in the Content Browser, right-click, and select </span><strong class="bold"><span class="koboSpan" id="kobo.359.1">Miscellaneous</span></strong><span class="koboSpan" id="kobo.360.1"> | </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.361.1">Data Table</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.363.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">Pick Row Structure</span></strong><span class="koboSpan" id="kobo.365.1"> pop-up window, select </span><strong class="bold"><span class="koboSpan" id="kobo.366.1">US_CharacterSkins</span></strong><span class="koboSpan" id="kobo.367.1"> from the </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">drop-down menu.</span></span></li>
<li><span class="koboSpan" id="kobo.369.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.370.1">OK</span></strong><span class="koboSpan" id="kobo.371.1"> button to generate the data table and name </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">DT_CharacterSkins</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.375.1">Double-click on the newly created asset to open it. </span><span class="koboSpan" id="kobo.375.2">You will get an empty dataset; create your character skin rows by using any material from the project (or create </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">custom materials!).</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.377.1">During the development phase, I like to create debug skins that will help me identify each unique character. </span><span class="koboSpan" id="kobo.377.2">In this case, I used a single color for all the elements in a row set (that is, all green, all red, or all blue), as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.378.1">Figure 13</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.379.1">.6</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer225">
<span class="koboSpan" id="kobo.381.1"><img alt="Figure 13.6 – The Skins data table" src="image/Figure_13_06_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.382.1">Figure 13.6 – The Skins data table</span></p>
<p><span class="koboSpan" id="kobo.383.1">Once you are </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.384.1">satisfied with the skin system and you have battle-tested it, you will need some more realistic skins for your thief character; this process will be as easy as creating a new data table with the skin colors of your choice and setting this table as the selected one in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.385.1">Pawn</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.386.1"> variable.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">Now that you have a skin catalog asset, you can start adding code to the main menu </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">Pawn</span></strong><span class="koboSpan" id="kobo.389.1"> class to set its skins </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">at runtime.</span></span></p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.391.1">Updating the US_MainMenuPawn class</span></h2>
<p><span class="koboSpan" id="kobo.392.1">In this </span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.393.1">section, you’ll be enhancing your character’s appearance by assigning a random skin. </span><span class="koboSpan" id="kobo.393.2">Every time players connect to the main menu level, their character will be allotted a unique set of colors for their skin, taken from the previously created data table. </span><span class="koboSpan" id="kobo.393.3">So, get ready to see a little more variety in </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">your game!</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">As I mentioned previously, you dealt with this in </span><a href="B18203_06.xhtml#_idTextAnchor125"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.396.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.397.1">, </span><em class="italic"><span class="koboSpan" id="kobo.398.1">Replicating Properties Over the Network</span></em><span class="koboSpan" id="kobo.399.1">, but as the old saying goes, practice </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">makes perfect!</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">With</span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.402.1"> your programming IDE, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">US_MainMenuPawn.h</span></strong><span class="koboSpan" id="kobo.404.1"> header file and, in the implicit </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">private</span></strong><span class="koboSpan" id="kobo.406.1"> section, add the data table and </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">skin declarations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.408.1">
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Character Data", meta = (AllowPrivateAccess = "true"))
class UDataTable* CharacterSkinDataTable;
struct FUS_CharacterSkins* CharacterSkin;</span></pre>
<p><span class="koboSpan" id="kobo.409.1">Next, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">public</span></strong><span class="koboSpan" id="kobo.411.1"> section, add the getter method for the selected </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">character skin:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.413.1">
FORCEINLINE FUS_CharacterSkins* GetCharacterSkin() const { return CharacterSkin; }</span></pre>
<p><span class="koboSpan" id="kobo.414.1">And in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">protected</span></strong><span class="koboSpan" id="kobo.416.1"> section, declare a function that will handle the skin </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">randomization process:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.418.1">
void RandomizeCharacterSkin();</span></pre>
<p><span class="koboSpan" id="kobo.419.1">Now, you can open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">US_MainMenuPawn.cpp</span></strong><span class="koboSpan" id="kobo.421.1"> file to start adding the skin handling implementation. </span><span class="koboSpan" id="kobo.421.2">First of all, declare the </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">needed includes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.423.1">
#include "US_CharacterSkins.h"
#include "US_GameInstance.h"</span></pre>
<p><span class="koboSpan" id="kobo.424.1">Then, add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">RandomizeCharacterSkin()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.426.1"> implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.427.1">
void AUS_MainMenuPawn::RandomizeCharacterSkin()
{
 if(CharacterSkinDataTable)
 {
  TArray&lt;FUS_CharacterSkins*&gt; CharacterSkinsRows;
  CharacterSkinDataTable-&gt;GetAllRows&lt;FUS_CharacterSkins&gt;(TEXT("US_Character"), CharacterSkinsRows);
  if(CharacterSkinsRows.Num() &gt; 0)
  {
   const auto NewIndex = FMath::RandRange(0, CharacterSkinsRows.Num() - 1);
   CharacterSkin = CharacterSkinsRows [NewIndex];
   Mesh-&gt;SetMaterial(4, CharacterSkinsRows[NewIndex]-&gt;Material4);
   Mesh-&gt;SetMaterial(0, CharacterSkinsRows[NewIndex]-&gt;Material0);
   Mesh-&gt;SetMaterial(1, CharacterSkinsRows[NewIndex]-&gt;Material1);
   Mesh-&gt;SetMaterial(2, CharacterSkinsRows[NewIndex]-&gt;Material2);
   if (const auto GameInstance = Cast&lt;UUS_GameInstance&gt;(GetGameInstance()))
   {
    GameInstance-&gt;SkinIndex = NewIndex;
   }
  }
 }</span></pre>
<p><span class="koboSpan" id="kobo.428.1">As you can see, we </span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.429.1">are retrieving all the data rows from the table reference and, after checking that there is at least one item in the table, we get a random row and set the pawn mesh materials to its included data. </span><span class="koboSpan" id="kobo.429.2">This will update the pawn shown in the level. </span><span class="koboSpan" id="kobo.429.3">After that, we retrieve the game instance as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">UUS_GameInstance</span></strong><span class="koboSpan" id="kobo.431.1"> type and assign the previously randomized index to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">SkinIndex</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.433.1"> property.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">As a</span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.435.1"> last step, we will be adding the randomization call when the game is started. </span><span class="koboSpan" id="kobo.435.2">So, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">BeginPlay()</span></strong><span class="koboSpan" id="kobo.437.1"> method, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.439.1">
if(IsLocallyControlled())
{
 RandomizeCharacterSkin();
}</span></pre>
<p><span class="koboSpan" id="kobo.440.1">We now need to set the data table from the Blueprint, so let’s switch back to the Unreal </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">Engine Editor.</span></span></p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.442.1">Updating the BP_MainMenuPawn Blueprint</span></h2>
<p><span class="koboSpan" id="kobo.443.1">Now that</span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.444.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">Pawn</span></strong><span class="koboSpan" id="kobo.446.1"> class is ready, you just have to assign the previously created data table to the Pawn Blueprint. </span><span class="koboSpan" id="kobo.446.2">To do so, open </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">BP_MainMenuPawn</span></strong><span class="koboSpan" id="kobo.448.1"> and do </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.450.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.451.1">Details</span></strong><span class="koboSpan" id="kobo.452.1"> panel, look for the </span><strong class="bold"><span class="koboSpan" id="kobo.453.1">Character Skin Data </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.454.1">Table</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.455.1"> property.</span></span></li>
<li><span class="koboSpan" id="kobo.456.1">From its drop-down menu, select </span><strong class="bold"><span class="koboSpan" id="kobo.457.1">DT_CharacterSkins</span></strong><span class="koboSpan" id="kobo.458.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.459.1">Figure 13</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.460.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer226">
<span class="koboSpan" id="kobo.462.1"><img alt="Figure 13.7 – The character skin data table property" src="image/Figure_13_07_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.463.1">Figure 13.7 – The character skin data table property</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.464.1">If you test the game, you will get a randomized skin for each of the characters, as depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.465.1">Figure 13</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.466.1">.8</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer227">
<span class="koboSpan" id="kobo.468.1"><img alt="Figure 13.8 – The starting skin randomization" src="image/Figure_13_08_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.469.1">Figure 13.8 – The starting skin randomization</span></p>
<p><span class="koboSpan" id="kobo.470.1">The </span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.471.1">character randomization is complete; to take full advantage of it, we just need to retrieve the data from the game level side and assign it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">playing character.</span></span></p>
<h2 id="_idParaDest-267"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.473.1">Updating the US_Character class</span></h2>
<p><span class="koboSpan" id="kobo.474.1">In this </span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.475.1">subsection, you will be retrieving the skin index data from the game instance and setting it to the player character. </span><span class="koboSpan" id="kobo.475.2">This process is quite straightforward once you remember that the game instance is persistent across levels and is not replicated (that is, each client has its own </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">dedicated one).</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">Start by opening the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">US_Character.h</span></strong><span class="koboSpan" id="kobo.479.1"> header file from your programming IDE and declare the needed data table properties in the implicit </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">private</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.481.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.482.1">
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Character Data", meta = (AllowPrivateAccess = "true"))
UDataTable* CharacterSkinDataTable;
struct FUS_CharacterSkins* CharacterSkin;</span></pre>
<p><span class="koboSpan" id="kobo.483.1">I know you are already familiar with the previous declarations, so I won’t waste your time by explaining </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">them again.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">Next, in </span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.486.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">protected</span></strong><span class="koboSpan" id="kobo.488.1"> section, you need to add the following declarations. </span><span class="koboSpan" id="kobo.488.2">These will handle the </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">skin update:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.490.1">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, ReplicatedUsing="OnRep_SkinChanged", Category = "Skin")
int32 SkinIndex = 0;
UFUNCTION()
void OnRep_SkinChanged(int32 OldValue);
UFUNCTION(Server, Reliable)
void SetSkinIndex_Server(int32 Value);
UFUNCTION()
void UpdateCharacterSkin();</span></pre>
<p><span class="koboSpan" id="kobo.491.1">And in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">public</span></strong><span class="koboSpan" id="kobo.493.1"> section, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.495.1">
FORCEINLINE FUS_CharacterSkins* GetCharacterSkins() const { return CharacterSkin; }
virtual void GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const override;</span></pre>
<p><span class="koboSpan" id="kobo.496.1">As you may remember from </span><a href="B18203_06.xhtml#_idTextAnchor125"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.497.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.498.1">, </span><em class="italic"><span class="koboSpan" id="kobo.499.1">Replicating Properties Over the Network</span></em><span class="koboSpan" id="kobo.500.1">, whenever you need to replicate a property, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">ReplicatedUsing</span></strong><span class="koboSpan" id="kobo.502.1"> property specifier to notify all clients that the property value has changed. </span><span class="koboSpan" id="kobo.502.2">In this case, we will replicate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">SkinIndex</span></strong><span class="koboSpan" id="kobo.504.1"> variable to let all of the clients update their character skins once they join </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">a session.</span></span></p>
<p><span class="koboSpan" id="kobo.506.1">Additionally, always keep in mind that, to replicate a property, it should be initialized inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">GetLifetimeReplicatedProps()</span></strong><span class="koboSpan" id="kobo.508.1"> method through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">DOREPLIFETIME</span></strong><span class="koboSpan" id="kobo.510.1"> macro, which is why we declared </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">that method.</span></span></p>
<p><span class="koboSpan" id="kobo.512.1">To</span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.513.1"> implement all the replication logic and skin update, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">US_Character.cpp</span></strong><span class="koboSpan" id="kobo.515.1"> file and start by adding the needed </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">include</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.517.1"> declarations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.518.1">
#include "US_GameInstance.h"
#include "US_CharacterSkins.h"
#include "Net/UnrealNetwork.h"</span></pre>
<p><span class="koboSpan" id="kobo.519.1">Then, add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">GetLifetimeReplicatedProps()</span></strong><span class="koboSpan" id="kobo.521.1"> method implementation to implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">property replication:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.523.1">
void AUS_Character::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const
{
 Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 DOREPLIFETIME(AUS_Character, SkinIndex);
}</span></pre>
<p><span class="koboSpan" id="kobo.524.1">Next, add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">OnRep_SkinChanged()</span></strong><span class="koboSpan" id="kobo.526.1"> method. </span><span class="koboSpan" id="kobo.526.2">This will be executed every time the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">SkinIndex</span></strong><span class="koboSpan" id="kobo.528.1"> value is updated from the server to </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">the clients:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.530.1">
void AUS_Character::OnRep_SkinChanged(int32 OldValue)
{
 UpdateCharacterSkin();
}</span></pre>
<p><span class="koboSpan" id="kobo.531.1">Then, implement the skin index update from the server side by adding the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">SetSkinIndex_Server_Implementation()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.533.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
void AUS_Character::SetSkinIndex_Server_Implementation(const int32 Value)
{
 SkinIndex = Value;
 UpdateCharacterSkin();
}</span></pre>
<p><span class="koboSpan" id="kobo.535.1">Note that we are calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">UpdateCharacerSkin()</span></strong><span class="koboSpan" id="kobo.537.1"> event from the server side; this is mandatory if you are using a listen server because the previous method will be called only on the clients and, in that case, the server will not update </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">the skin.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">The </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.540.1">fourth method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">UpdateCharacterSkin()</span></strong><span class="koboSpan" id="kobo.542.1">, will take care of retrieving the data from the game instance and updating the character mesh materials. </span><span class="koboSpan" id="kobo.542.2">To do so, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">following implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.544.1">
void AUS_Character::UpdateCharacterSkin()
{
 if(CharacterSkinDataTable)
 {
  TArray&lt;FUS_CharacterSkins*&gt; CharacterSkinsRows;
  CharacterSkinDataTable-&gt;GetAllRows&lt;FUS_CharacterSkins&gt;(TEXT("US_Character"), CharacterSkinsRows);
  if(CharacterSkinsRows.Num() &gt; 0)
  {
   const auto Index = FMath::Clamp(SkinIndex, 0, CharacterSkinsRows.Num() - 1);
   CharacterSkin = CharacterSkinsRows[Index];
   GetMesh()-&gt;SetMaterial(4, CharacterSkin-&gt;Material4);
   GetMesh()-&gt;SetMaterial(0, CharacterSkin-&gt;Material0);
   GetMesh()-&gt;SetMaterial(1, CharacterSkin-&gt;Material1);
   GetMesh()-&gt;SetMaterial(2, CharacterSkin-&gt;Material2);
  }
 }
}</span></pre>
<p><span class="koboSpan" id="kobo.545.1">What we</span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.546.1"> are doing here is almost identical to the main menu Pawn class; we are getting a row from the skin data table and assigning the materials to the character mesh. </span><span class="koboSpan" id="kobo.546.2">The only difference is that we are not setting the skin index to the game instance, and we are getting a replicated version of </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">it instead.</span></span></p>
<p><span class="koboSpan" id="kobo.548.1">As a last step, you will need to add the following code at the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">BeginPlay()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.550.1">method’s implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.551.1">
if(IsLocallyControlled())
{
 if(const auto GameInstanceCast = Cast&lt;UUS_GameInstance&gt;(GetWorld()-&gt;GetGameInstance()); GameInstanceCast != nullptr)
 {
  SetSkinIndex_Server(GameInstanceCast-&gt;SkinIndex);
 }
}</span></pre>
<p><span class="koboSpan" id="kobo.552.1">This portion of the code checks that the instance of this class is locally controlled (that is, it is a player-owned character) and gets the skin index from the game instance. </span><span class="koboSpan" id="kobo.552.2">Then, it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">SetSkinIndex()</span></strong><span class="koboSpan" id="kobo.554.1"> server function to notify all the clients that they should update this </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">character look.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">As for the main menu Pawn class, you now need to update the corresponding Blueprint to declare the skin </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">data table.</span></span></p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.558.1">Updating the BP_Character Blueprint</span></h2>
<p><span class="koboSpan" id="kobo.559.1">Now that </span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.560.1">the character class is ready, you just have to assign the previously created data table to the corresponding Blueprint. </span><span class="koboSpan" id="kobo.560.2">To do so, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">these steps:</span></span></p>
<ol>
<li><span class="No-Break"><span class="koboSpan" id="kobo.562.1">Open </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.563.1">BP_Character</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.565.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.566.1">Details</span></strong><span class="koboSpan" id="kobo.567.1"> panel, look for the </span><strong class="bold"><span class="koboSpan" id="kobo.568.1">Character Skin Data </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.569.1">Table</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.570.1"> property.</span></span></li>
<li><span class="koboSpan" id="kobo.571.1">From its drop-down menu, select </span><strong class="bold"><span class="koboSpan" id="kobo.572.1">DT_CharacterSkins</span></strong><span class="koboSpan" id="kobo.573.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.574.1">Figure 13</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.575.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer228">
<span class="koboSpan" id="kobo.577.1"><img alt="Figure 13.9 – The character skin data table property" src="image/Figure_13_09_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.578.1">Figure 13.9 – The character skin data table property</span></p>
<p><span class="koboSpan" id="kobo.579.1">If you test the game now, you will be able to get a randomized skin for each of the characters and keep that skin once a session is joined, as depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.580.1">Figure 13</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.581.1">.10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer229">
<span class="koboSpan" id="kobo.583.1"><img alt="Figure 13.10 – Gameplay with skinned characters" src="image/Figure_13_10_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.584.1">Figure 13.10 – Gameplay with skinned characters</span></p>
<p><span class="koboSpan" id="kobo.585.1">In this </span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.586.1">section, you learned how to keep data when creating or joining a session. </span><span class="koboSpan" id="kobo.586.2">You did this by using the game instance as a sort of data bridge to create a skinning feature; this will make each character unique and even more appealing to the players, helping you give them a killer makeover that will make the Lichlord quake in </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">his boots!</span></span></p>
<p><span class="koboSpan" id="kobo.588.1">In the upcoming section, I won’t be introducing any new topics; instead, I’ll give you some additional ideas to help you better manage your </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">game sessions.</span></span></p>
<h1 id="_idParaDest-269"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.590.1">Making further improvements</span></h1>
<p><span class="koboSpan" id="kobo.591.1">In the previous sections, you</span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.592.1"> did a great job of understanding how to pass data between sessions to make your multiplayer game even more engaging. </span><span class="koboSpan" id="kobo.592.2">Now, it’s time to make your game even better by adding some additional functionalities. </span><span class="koboSpan" id="kobo.592.3">In this section, I’ll offer some tips to help you add some excitement to your project. </span><span class="koboSpan" id="kobo.592.4">As always, don’t be afraid to add your personal touch and make it </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">truly yours.</span></span></p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.594.1">Leaving and destroying sessions</span></h2>
<p><span class="koboSpan" id="kobo.595.1">In this</span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.596.1"> chapter and the previous one, you have used three out of four session commands – </span><strong class="bold"><span class="koboSpan" id="kobo.597.1">Create Session</span></strong><span class="koboSpan" id="kobo.598.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.599.1">Join Session</span></strong><span class="koboSpan" id="kobo.600.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.601.1">Find Session</span></strong><span class="koboSpan" id="kobo.602.1"> – but the </span><strong class="bold"><span class="koboSpan" id="kobo.603.1">Destroy Session</span></strong><span class="koboSpan" id="kobo.604.1"> command has been left unused. </span><span class="koboSpan" id="kobo.604.2">Use the </span><strong class="bold"><span class="koboSpan" id="kobo.605.1">Destroy Session</span></strong><span class="koboSpan" id="kobo.606.1"> command node to let the player leave a </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">playing session.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">This will be </span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.609.1">implemented in the game level (and not in the main menu one) as the player will need to leave the session after joining one. </span><span class="koboSpan" id="kobo.609.2">To implement this feature, you may want to create a dedicated user interface that will let players leave the game whenever they decide to </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">do so.</span></span></p>
<p><span class="koboSpan" id="kobo.611.1">As a side note, keep in mind that clients and the server behave differently regarding a session, so you will have to manage two kinds of session destruction: the one from the client – which will be almost painless – and, in the case of a client/server host, the server one – which will have to destroy all sessions from all clients (that is, all clients should leave the session as the server is not </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">functional anymore).</span></span></p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.613.1">Handling player death</span></h2>
<p><span class="koboSpan" id="kobo.614.1">At the </span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.615.1">moment, whenever a player is captured by a Lichlord minion, nothing will happen – you will get just a screen message and the player will keep </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">on playing.</span></span></p>
<p><span class="koboSpan" id="kobo.617.1">You can manage a player’s death in many ways, but here are a couple of ideas </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">for you:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.619.1">Destroy the player session and reload the main menu level to let the player join a new session. </span><span class="koboSpan" id="kobo.619.2">Just keep in mind that, if the player that is defeated is the server host, all other players will be immediately removed from </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">the session.</span></span></li>
<li><span class="koboSpan" id="kobo.621.1">Use a respawn method, where the character will be placed in an available spawn point without the need to rejoin </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">the session.</span></span></li>
</ul>
<h2 id="_idParaDest-272"><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.623.1">Selecting the player skin</span></h2>
<p><span class="koboSpan" id="kobo.624.1">In this </span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.625.1">chapter, you developed a random skin generator, but wouldn’t be cool to let the players choose their own skin? </span><span class="koboSpan" id="kobo.625.2">You may add a user interface in the main menu level that will let the players do </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.627.1">Randomize the skin again if it does not suit </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">their needs</span></span></li>
<li><span class="koboSpan" id="kobo.629.1">Select the desired skin from the full set using a dedicated </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">selection method</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.631.1">Well, this</span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.632.1"> could be the tip of the iceberg when it comes to creating a skin system that works like a charm and gets envious stares from your competitors. </span><span class="koboSpan" id="kobo.632.2">Who knows? </span><span class="koboSpan" id="kobo.632.3">Implementing your in-game purchases might even make games such as Fortnite weak in </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">the knees!</span></span></p>
<h1 id="_idParaDest-273"><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.634.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.635.1">In this chapter, you developed a fully functional system to pass data from one level to another during a game session. </span><span class="koboSpan" id="kobo.635.2">In this case, you focused on a skin system for the player character, but the use cases for this feature are </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">almost endless.</span></span></p>
<p><span class="koboSpan" id="kobo.637.1">As you may have noticed, session handling is a huge topic – it took two chapters to properly explain its main functionalities – and to succeed in the multiplayer world, it is imperative to have a strong grasp of it. </span><span class="koboSpan" id="kobo.637.2">If you want to ride the wave of success, then mastering this skill is a </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">non-negotiable topic!</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">In the next chapter, I will guide you through a brand new topic: how to properly package your game. </span><span class="koboSpan" id="kobo.639.2">Get ready to dive into the exciting world of project packaging so that you can deploy your game like a boss on both server and client ends! </span><span class="koboSpan" id="kobo.639.3">Are you ready for </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">this adventure?</span></span></p>
</div>
</body></html>