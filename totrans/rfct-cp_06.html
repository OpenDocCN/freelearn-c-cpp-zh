<html><head></head><body>
<div id="_idContainer011">
<h1 class="chapter-number" id="_idParaDest-93"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.2.1">Utilizing a Rich Static Type System in C++</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In modern software development, the notion of “type” has </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.4.1">transcended its primitive definition, evolving into a rich and expressive language feature that encapsulates more than just data representation. </span><span class="koboSpan" id="kobo.4.2">In C++, a language renowned for its performance and flexibility, the static type system serves as a powerful tool, enabling developers to write code that’s not only robust and efficient but also self-documenting </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">and maintainable.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">The significance of types in C++ extends beyond the mere categorization of data. </span><span class="koboSpan" id="kobo.6.2">By enforcing strict compile-time checks, the language’s type system reduces runtime errors, improves readability, and fosters a more intuitive understanding of code. </span><span class="koboSpan" id="kobo.6.3">With the advent of modern C++ standards, the opportunities to leverage types have further expanded, bringing forth elegant solutions to common </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">programming challenges.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">However, these powerful features can often be underutilized. </span><span class="koboSpan" id="kobo.8.2">Primitive data types such as integers are frequently misused to represent concepts such as time durations, leading to code that lacks expressiveness and can be prone to errors. </span><span class="koboSpan" id="kobo.8.3">Pointers, although flexible, can lead to null dereferencing issues, making the code </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">base fragile.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">In this chapter, we’ll explore the rich landscape of C++’s static type system, focusing on advanced and modern techniques that help to mitigate these problems. </span><span class="koboSpan" id="kobo.10.2">From using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.11.1">&lt;chrono&gt;</span></strong><span class="koboSpan" id="kobo.12.1"> library to represent time durations to employing </span><strong class="source-inline"><span class="koboSpan" id="kobo.13.1">not_null</span></strong><span class="koboSpan" id="kobo.14.1"> wrappers and </span><strong class="source-inline"><span class="koboSpan" id="kobo.15.1">std::optional</span></strong><span class="koboSpan" id="kobo.16.1"> for safer pointer handling, we’ll delve into practices that embody the essence of </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">strong typing.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">We’ll also look at external libraries such as Boost, which offer additional utilities to enhance type safety. </span><span class="koboSpan" id="kobo.18.2">Throughout the chapter, real-world examples will illustrate how these tools and techniques can be seamlessly integrated into your code, empowering you to harness the full potential of C++’s </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">type system.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">By the end of this chapter, you’ll gain a deep understanding of how to utilize types to write more robust, readable, and expressive code, tapping into the true power </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">of C++.</span></span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.22.1">Utilizing Chrono for time duration</span></h1>
<p><span class="koboSpan" id="kobo.23.1">One of </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.24.1">the best examples of how C++’s type system can be leveraged to write more robust code is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">&lt;chrono&gt;</span></strong><span class="koboSpan" id="kobo.26.1"> library. </span><span class="koboSpan" id="kobo.26.2">Introduced in C++11, this header provides a set of utilities to represent time durations and points in time, as well as perform </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">time-related operations.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">Managing </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.29.1">time-related functions using plain integers or structures such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">timespec</span></strong><span class="koboSpan" id="kobo.31.1"> can be a bug-prone approach, especially when dealing with different units of time. </span><span class="koboSpan" id="kobo.31.2">Imagine a function that takes an integer representing a timeout </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">in seconds:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.33.1">
void wait_for_data(int timeout_seconds) {
    sleep(timeout_seconds); // Sleeps for timeout_seconds seconds
}</span></pre>
<p><span class="koboSpan" id="kobo.34.1">This approach lacks flexibility and can lead to confusion when handling various time units. </span><span class="koboSpan" id="kobo.34.2">For example, if a caller mistakenly passes milliseconds instead of seconds, it can cause </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">unexpected behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">By contrast, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">&lt;chrono&gt;</span></strong><span class="koboSpan" id="kobo.38.1"> to define the same function makes the code more robust </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">and expressive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.40.1">
#include &lt;chrono&gt;
#include &lt;thread&gt;
void wait_for_data(std::chrono::seconds timeout) {
    std::this_thread::sleep_for(timeout); // Sleeps for the specified timeout
}</span></pre>
<p><span class="koboSpan" id="kobo.41.1">The caller can now pass the timeout using a strongly-typed duration, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">std::chrono::seconds(5)</span></strong><span class="koboSpan" id="kobo.43.1">, and the compiler ensures that the correct unit is used. </span><span class="koboSpan" id="kobo.43.2">Moreover, </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">&lt;chrono&gt;</span></strong><span class="koboSpan" id="kobo.45.1"> provides seamless conversion between different time units, allowing the caller to specify the timeout in seconds, milliseconds, or any other unit, without ambiguity. </span><span class="koboSpan" id="kobo.45.2">The following snippet illustrates the usage with </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">different units:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.47.1">
wait_for_data(std::chrono::milliseconds(150));</span></pre>
<p><span class="koboSpan" id="kobo.48.1">By embracing the strong typing offered by </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">&lt;chrono&gt;</span></strong><span class="koboSpan" id="kobo.50.1">, the code becomes clearer, more maintainable, and less susceptible to common bugs related to </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">time representation.</span></span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.52.1">Improving Pointer Safety with not_null and std::optional</span></h1>
<p><span class="koboSpan" id="kobo.53.1">In C++, pointers are a</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.54.1"> fundamental part of the language, allowing direct memory access and manipulation. </span><span class="koboSpan" id="kobo.54.2">However, the flexibility that pointers offer comes with certain risks and challenges. </span><span class="koboSpan" id="kobo.54.3">Here, we’ll explore how modern C++ techniques can enhance </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">pointer safety.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.56.1">The pitfalls of raw pointers</span></h2>
<p><span class="koboSpan" id="kobo.57.1">Raw pointers, while </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.58.1">powerful, can be a double-edged sword. </span><span class="koboSpan" id="kobo.58.2">They provide no information about the ownership of the object they point to, and they can easily become “dangling” pointers, pointing to memory that has been deallocated. </span><span class="koboSpan" id="kobo.58.3">Dereferencing a null or dangling pointer leads to undefined behavior, which can result in </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">hard-to-diagnose bugs.</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.60.1">Using not_null from the Guidelines Support Library</span></h2>
<p><span class="koboSpan" id="kobo.61.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">not_null</span></strong><span class="koboSpan" id="kobo.63.1"> wrapper</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.64.1"> provided by the </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">Guidelines Support Library</span></strong><span class="koboSpan" id="kobo.66.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.67.1">GSL</span></strong><span class="koboSpan" id="kobo.68.1">) aims to overcome the challenges associated with raw pointers. </span><span class="koboSpan" id="kobo.68.2">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">not_null</span></strong><span class="koboSpan" id="kobo.70.1">, you can clearly signal that a pointer should never </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">be null:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.72.1">
#include &lt;gsl/gsl&gt;
void process_data(gsl::not_null&lt;int*&gt; data) {
    // Data is guaranteed not to be null here
}</span></pre>
<p><span class="koboSpan" id="kobo.73.1">If a user passes a null pointer to this function as follows, the application will </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">be terminated:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.75.1">
int main() {
    int* p = nullptr;
    process_data(p); // this will terminate the program
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.76.1">However, if </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.77.1">the pointer is passed as </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">process_data(nullptr)</span></strong><span class="koboSpan" id="kobo.79.1">, the application will fail in </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">compile time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.81.1">
source&gt;: In function 'int main()':
&lt;source&gt;:9:16: error: use of deleted function 'gsl::not_null&lt;T&gt;::not_null(std::nullptr_t) [with T = int*; std::nullptr_t = std::nullptr_t]'
    9 |     process_data(nullptr);
      |     ~~~~~~~~~~~^~~~~~~~~
In file included from &lt;source&gt;:1:
/opt/compiler-explorer/libs/GSL/trunk/include/gsl/pointers:131:5: note: declared here
  131 |     not_null(std::nullptr_t) = delete;
      |     ^~~~~~~~</span></pre>
<p><span class="koboSpan" id="kobo.82.1">This promotes robust code by catching potential null pointer errors early, thus reducing </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">runtime errors.</span></span></p>
<h3><span class="koboSpan" id="kobo.84.1">Extending not_null to smart pointers</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">gsl::not_null</span></strong><span class="koboSpan" id="kobo.86.1"> is not</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.87.1"> limited to raw pointers; it can also be used with smart pointers such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.89.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.91.1">. </span><span class="koboSpan" id="kobo.91.2">This allows you to combine the benefits of modern memory management with the additional safety guarantees that </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">not_null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.93.1"> provides.</span></span></p>
<h3><span class="koboSpan" id="kobo.94.1">With std::unique_ptr</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.96.1"> ensures</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.97.1"> that the ownership of a dynamically allocated object is unique, and it automatically deletes the object when it is no longer needed. </span><span class="koboSpan" id="kobo.97.2">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">not_null</span></strong><span class="koboSpan" id="kobo.99.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">unique_ptr</span></strong><span class="koboSpan" id="kobo.101.1">, you can also ensure that the pointer is </span><a id="_idIndexMarker228"/><span class="No-Break"><span class="koboSpan" id="kobo.102.1">never null:</span></span></p>
<pre class="source-code">
<strong class="source-inline"><span class="koboSpan" id="kobo.103.1">#include &lt;gsl/gsl&gt;</span></strong>
<strong class="source-inline"><span class="koboSpan" id="kobo.104.1">#include &lt;memory&gt;</span></strong><span class="koboSpan" id="kobo.105.1">
void process_data(gsl::not_null&lt;std::unique_ptr&lt;int&gt;&gt; data) {
    // Data is guaranteed not to be null here
}
int main() {
    auto data = std::make_unique&lt;int&gt;(42);
    process_data(std::move(data)); // Safely passed to the function
}</span></pre>
<h3><span class="koboSpan" id="kobo.106.1">With std::shared_ptr</span></h3>
<p><span class="koboSpan" id="kobo.107.1">Similarly, </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">gsl::not_null</span></strong><span class="koboSpan" id="kobo.109.1"> can be used with </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.111.1">, which enables shared </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.112.1">ownership of an object. </span><span class="koboSpan" id="kobo.112.2">This allows you to write functions that accept shared pointers without having to worry </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">about nullity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
#include &lt;gsl/gsl&gt;
#include &lt;memory&gt;
void process_data(gsl::not_null&lt;std::shared_ptr&lt;int&gt;&gt; data) {
    // Data is guaranteed not to be null here
}
int main() {
    auto data = std::make_shared&lt;int&gt;(42);
    process_data(data); // Safely passed to the function
}</span></pre>
<p><span class="koboSpan" id="kobo.115.1">These </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.116.1">examples demonstrate how </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">not_null</span></strong><span class="koboSpan" id="kobo.118.1"> can seamlessly integrate with modern C++ memory management techniques. </span><span class="koboSpan" id="kobo.118.2">By enforcing that a pointer (whether raw or smart) cannot be null, you further reduce the potential for runtime errors and make code more robust </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">and expressive.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.120.1">Utilizing std::optional for optional values</span></h2>
<p><span class="koboSpan" id="kobo.121.1">Sometimes, a</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.122.1"> pointer is used to indicate an optional value, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">nullptr</span></strong><span class="koboSpan" id="kobo.124.1"> signifies the absence of a value. </span><span class="koboSpan" id="kobo.124.2">C++17 introduced </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">std::optional</span></strong><span class="koboSpan" id="kobo.126.1">, which provides a type-safe way to represent </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">optional values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.128.1">
#include &lt;optional&gt;
std::optional&lt;int&gt; fetch_data() {
    if (/* some condition */)
        return 42;
    else
        return std::nullopt;
}</span></pre>
<p><span class="koboSpan" id="kobo.129.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">std::optional</span></strong><span class="koboSpan" id="kobo.131.1"> provides clear semantics and avoids the pitfalls associated with using pointers for </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">this purpose.</span></span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.133.1">A comparison between raw pointers and nullptr</span></h2>
<p><span class="koboSpan" id="kobo.134.1">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">not_null</span></strong><span class="koboSpan" id="kobo.136.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">std::optional</span></strong><span class="koboSpan" id="kobo.138.1"> offer advantages over raw pointers. </span><span class="koboSpan" id="kobo.138.2">While raw pointers can be</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.139.1"> null or dangling, leading to undefined behavior, </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">not_null</span></strong><span class="koboSpan" id="kobo.141.1"> prevents null pointer errors at compile time, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">std::optional</span></strong><span class="koboSpan" id="kobo.143.1"> provides a clear way to represent </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">optional values.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">Consider the following example using </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">raw pointers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.147.1">
int* findValue() {
    // ...
</span><span class="koboSpan" id="kobo.147.2">    return nullptr; // No value found
}</span></pre>
<p><span class="koboSpan" id="kobo.148.1">This code</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.149.1"> might lead to confusion and bugs, especially if the caller forgets to check for </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">nullptr</span></strong><span class="koboSpan" id="kobo.151.1">. </span><span class="koboSpan" id="kobo.151.2">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">not_null</span></strong><span class="koboSpan" id="kobo.153.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">std::optional</span></strong><span class="koboSpan" id="kobo.155.1">, you can make the code more expressive and </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">less error-prone.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.157.1">Leveraging std::expected for expected results and errors</span></h2>
<p><span class="koboSpan" id="kobo.158.1">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">std::optional</span></strong><span class="koboSpan" id="kobo.160.1"> elegantly represents an optional value, sometimes you need to convey </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.161.1">more information about why a value might be missing. </span><span class="koboSpan" id="kobo.161.2">In such cases, </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">std::expected</span></strong><span class="koboSpan" id="kobo.163.1"> provides a way to return either a value or an error code, making code more expressive and the error handling </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">more robust.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">Consider a scenario where you have a function that retrieves a value from a network, and you want to handle network errors. </span><span class="koboSpan" id="kobo.165.2">You might define an enumeration for the various </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">network errors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.167.1">
enum class NetworkError {
    Timeout,
    ConnectionLost,
    UnknownError
};</span></pre>
<p><span class="koboSpan" id="kobo.168.1">You can then use </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">std::expected</span></strong><span class="koboSpan" id="kobo.170.1"> to define a function that returns either an </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">int</span></strong><span class="koboSpan" id="kobo.172.1"> value </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">NetworkError</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.176.1">
#include &lt;expected&gt;
#include &lt;iostream&gt;
std::expected&lt;int, NetworkError&gt; fetch_data_from_network() {
    // Simulating network operation...
</span><span class="koboSpan" id="kobo.176.2">    if (/* network timeout */) {
        return std::unexpected(NetworkError::Timeout);
    }
    if (/* connection lost */) {
        return std::unexpected(NetworkError::ConnectionLost);
    }
    return 42; // Successfully retrieved value
}
int main() {
    auto result = fetch_data_from_network();
    if (result) {
        std::cout &lt;&lt; "Value retrieved: " &lt;&lt; *result &lt;&lt; '\n';
    } else {
        std::cout &lt;&lt; "Network error: ";
        switch(result.error()) {
            case NetworkError::Timeout:
                std::cout &lt;&lt; "Timeout\n";
                break;
            case NetworkError::ConnectionLost:
                std::cout &lt;&lt; "Connection Lost\n";
                break;
            case NetworkError::UnknownError:
                std::cout &lt;&lt; "Unknown Error\n";
                break;
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.177.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">std::expected</span></strong><span class="koboSpan" id="kobo.179.1"> captures both the successful case and various error scenarios, allowing</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.180.1"> for clear and type-safe error handling. </span><span class="koboSpan" id="kobo.180.2">This example illustrates how modern C++ types such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">std::expected</span></strong><span class="koboSpan" id="kobo.182.1"> enhance expressiveness and safety, allowing you to write code that more accurately models </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">complex operations.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">By embracing these modern C++ tools, you can enhance pointer safety in your code, reducing bugs and making your </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">intentions clear.</span></span></p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.186.1">Strong typing with enum class and scoped enumerations</span></h1>
<p><span class="koboSpan" id="kobo.187.1">Strong typing is a cornerstone of robust, maintainable software, and C++ provides several </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.188.1">mechanisms to facilitate it. </span><span class="koboSpan" id="kobo.188.2">Among these, </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">enum class</span></strong><span class="koboSpan" id="kobo.190.1">, introduced in C++11, is a particularly effective tool for creating strongly typed enumerations that can make your programs both more robust and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">to understand.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.192.1">A review of enum class</span></h2>
<p><span class="koboSpan" id="kobo.193.1">Traditional</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.194.1"> enumerations in C++ suffer from a few limitations – they can implicitly convert to integers, potentially causing errors if misused, and their enumerators are introduced into the enclosing scope, leading to name clashes. </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">enum class</span></strong><span class="koboSpan" id="kobo.196.1">, also known as scoped enumerations, addresses </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">these limitations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.198.1">
// Traditional enum
enum ColorOld { RED, GREEN, BLUE };
int color = RED; // Implicit conversion to int
// Scoped enum (enum class)
enum class Color { Red, Green, Blue };
// int anotherColor = Color::Red; // Compilation error: no implicit conversion</span></pre>
<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.199.1">The benefits over traditional enums</span></h2>
<p><span class="koboSpan" id="kobo.200.1">Scoped </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.201.1">enumerations offer </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">several advantages:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.203.1">Strong typing</span></strong><span class="koboSpan" id="kobo.204.1">: There are no implicit conversions between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">enum class</span></strong><span class="koboSpan" id="kobo.206.1"> type and integers, ensuring that you can’t accidentally misuse an enumerator as </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">an integer</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.208.1">Scoped names</span></strong><span class="koboSpan" id="kobo.209.1">: Enumerators are scoped to </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">enum class</span></strong><span class="koboSpan" id="kobo.211.1">, reducing the likelihood of </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">name collisions</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.213.1">An explicit underlying type</span></strong><span class="koboSpan" id="kobo.214.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">enum class</span></strong><span class="koboSpan" id="kobo.216.1"> allows you to explicitly specify the underlying type, giving you precise control over the </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">data representation:</span></span><pre class="source-code">
<strong class="source-inline"><span class="koboSpan" id="kobo.218.1">enum class StatusCode : uint8_t { Ok, Error, Pending };</span></strong></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.219.1">The ability to specify the underlying type is particularly useful for serializing data to binary formats. </span><span class="koboSpan" id="kobo.219.2">It ensures that you have fine-grained control over how the data is represented at the byte level, facilitating easier data interchange with systems that may have specific binary </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">format requirements.</span></span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.221.1">Real-world scenarios</span></h2>
<p><span class="koboSpan" id="kobo.222.1">The </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.223.1">advantages of </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">enum class</span></strong><span class="koboSpan" id="kobo.225.1"> make it a powerful tool for </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">various scenarios:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.227.1">State machines</span></strong><span class="koboSpan" id="kobo.228.1">: When modeling system states, </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">enum class</span></strong><span class="koboSpan" id="kobo.230.1"> provides a type-safe, expressive way to represent various </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">possible states</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.232.1">Option sets</span></strong><span class="koboSpan" id="kobo.233.1">: Many functions have multiple behavior options, which can be neatly and safely encapsulated using </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">scoped enumerations</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.235.1">The return status</span></strong><span class="koboSpan" id="kobo.236.1">: Functions that return status codes can benefit from the type-safety and scoping rules provided by </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">enum class</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.239.1">
enum class NetworkStatus { Connected, Disconnected, Error };</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.240.1">
NetworkStatus check_connection() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.241.1">
    // Implementation</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.242.1">
}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.243.1">By </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.244.1">using </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">enum class</span></strong><span class="koboSpan" id="kobo.246.1"> to create strongly typed, scoped enumerations, you can write code that is not only easier to understand but also less prone to errors. </span><span class="koboSpan" id="kobo.246.2">This feature represents another step forward in C++’s ongoing evolution toward a language that combines high performance with modern programming conveniences. </span><span class="koboSpan" id="kobo.246.3">Whether you’re defining a complex state machine or simply trying to represent multiple options or statuses, </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">enum class</span></strong><span class="koboSpan" id="kobo.248.1"> offers a robust, </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">type-safe solution.</span></span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.250.1">Leveraging the standard library’s type utilities</span></h1>
<p><span class="koboSpan" id="kobo.251.1">Modern C++ offers a</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.252.1"> rich set of type utilities within the Standard library that enables developers to write more expressive, type-safe, and maintainable code. </span><span class="koboSpan" id="kobo.252.2">Two prominent examples are </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">std::variant</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.254.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">std::any</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.257.1">std::variant – a type-safe union</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">std::variant</span></strong><span class="koboSpan" id="kobo.259.1"> provides</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.260.1"> a type-safe way to represent</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.261.1"> a value that can be one of several possible types. </span><span class="koboSpan" id="kobo.261.2">Unlike a traditional </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">union</span></strong><span class="koboSpan" id="kobo.263.1">, which allows the programmer to treat the stored value as any of its member types, leading to potential undefined behavior, </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">std::variant</span></strong><span class="koboSpan" id="kobo.265.1"> tracks the currently</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.266.1"> held type and ensures </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">proper handling:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
#include &lt;variant&gt;
#include &lt;iostream&gt;
std::variant&lt;int, double, std::string&gt; value = 42;
// Using std::get with an index:
int intValue = std::get&lt;0&gt;(value); // Retrieves the int value
// Using std::get with a type:
try {
    double doubleValue = std::get&lt;double&gt;(value); // Throws std::bad_variant_access
} catch (const std::bad_variant_access&amp; e) {
    std::cerr &lt;&lt; "Bad variant access: " &lt;&lt; e.what() &lt;&lt; '\n';
}
// Using std::holds_alternative:
if (std::holds_alternative&lt;int&gt;(value)) {
    std::cout &lt;&lt; "Holding int\n";
} else {
    std::cout &lt;&lt; "Not holding int\n";
}</span></pre>
<h3><span class="koboSpan" id="kobo.269.1">The benefits over traditional unions</span></h3>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.270.1">Type safety</span></strong><span class="koboSpan" id="kobo.271.1">: With</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.272.1"> traditional unions, it’s up to the programmer to track the currently held type, and misuse can lead to undefined behavior. </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">std::variant</span></strong><span class="koboSpan" id="kobo.274.1">, conversely, keeps track of the current type and provides safe access through functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">std::get</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.276.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">std::holds_alternative</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.279.1">Automatic construction and destruction</span></strong><span class="koboSpan" id="kobo.280.1">: Unlike unions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">std::variant</span></strong><span class="koboSpan" id="kobo.282.1"> automatically constructs and destroys the held object when you assign a new value, managing the object’s </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">lifetime correctly.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.284.1">Exception handling</span></strong><span class="koboSpan" id="kobo.285.1">: When attempting to access a type not currently held by the variant using </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">std::get</span></strong><span class="koboSpan" id="kobo.287.1">, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">std::bad_variant_access</span></strong><span class="koboSpan" id="kobo.289.1"> exception is thrown, making error handling more transparent and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">to manage.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.291.1">Standard library integration</span></strong><span class="koboSpan" id="kobo.292.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">std::variant</span></strong><span class="koboSpan" id="kobo.294.1"> can be used with standard library functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">std::visit</span></strong><span class="koboSpan" id="kobo.296.1">, providing elegant ways to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">various types.</span></span></li>
</ul>
<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.298.1">std::any – type-safe containers for any type</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">std::any</span></strong><span class="koboSpan" id="kobo.300.1"> is a </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.301.1">container that can hold any type but</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.302.1"> maintains type safety by requiring explicit casting to the correct type. </span><span class="koboSpan" id="kobo.302.2">This allows for flexible handling of data without sacrificing </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">type integrity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
#include &lt;any&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
std::any value = 42;
try {
    std::cout &lt;&lt; std::any_cast&lt;int&gt;(value); // Outputs 42
    std::cout &lt;&lt; std::any_cast&lt;double&gt;(value); // Throws std::bad_any_cast
} catch(const std::bad_any_cast&amp; e) {
    std::cerr &lt;&lt; "Bad any_cast: " &lt;&lt; e.what();
}</span></pre>
<p><span class="koboSpan" id="kobo.305.1">The </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.306.1">advantages of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">std::any</span></strong><span class="koboSpan" id="kobo.308.1"> include </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.310.1">Flexibility</span></strong><span class="koboSpan" id="kobo.311.1">: It can store any type, making it suitable for heterogeneous collections or </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">flexible APIs</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.313.1">Type safety</span></strong><span class="koboSpan" id="kobo.314.1">: Requires explicit casting, preventing accidental misinterpretation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">contained value</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.316.1">Encapsulation</span></strong><span class="koboSpan" id="kobo.317.1">: Allows you to pass around values without exposing their concrete types, supporting more modular and </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">maintainable code</span></span></li>
</ul>
<h2 id="_idParaDest-109"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.319.1">Advanced type techniques</span></h2>
<p><span class="koboSpan" id="kobo.320.1">As you delve </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.321.1">deeper into C++, you’ll find</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.322.1"> that the language offers an array of advanced techniques for enhancing type safety, readability, and maintainability. </span><span class="koboSpan" id="kobo.322.2">In this section, we’ll explore a few of these advanced concepts, providing practical examples </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">for each.</span></span></p>
<h3><span class="koboSpan" id="kobo.324.1">Templates – specializing for type safety</span></h3>
<p><span class="koboSpan" id="kobo.325.1">Templates </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.326.1">are a powerful feature in C++, but you may want to impose certain constraints or specializations based on types. </span><span class="koboSpan" id="kobo.326.2">One way to do this is via template specialization, which allows you to define custom behavior for </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">certain types.</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">For example, let’s say you have a generic function to find the maximum element in </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">an array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.330.1">
template &lt;typename T&gt;
T find_max(const std::vector&lt;T&gt;&amp; arr) {
    // generic implementation
    return *std::max_element(arr.begin(), arr.end());
}</span></pre>
<p><span class="koboSpan" id="kobo.331.1">Now, let’s </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.332.1">say you want to provide a specialized implementation for </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">std::string</span></strong><span class="koboSpan" id="kobo.334.1"> that </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">is case-insensitive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.336.1">
template &lt;&gt;
std::string find_max(const std::vector&lt;std::string&gt;&amp; arr) {
    return *std::max_element(arr.begin(), arr.end(),
                              [](const std::string&amp; a, const std::string&amp; b) {
                                  return strcasecmp(a.c_str(), b.c_str()) &lt; 0;
                              });
}</span></pre>
<p><span class="koboSpan" id="kobo.337.1">With this specialized version, calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">find_max</span></strong><span class="koboSpan" id="kobo.339.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">std::string</span></strong><span class="koboSpan" id="kobo.341.1"> will use a </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">case-insensitive comparison.</span></span></p>
<h3><span class="koboSpan" id="kobo.343.1">Creating custom type traits</span></h3>
<p><span class="koboSpan" id="kobo.344.1">Sometimes, the</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.345.1"> standard type traits may not be sufficient for your needs. </span><span class="koboSpan" id="kobo.345.2">You can create your own custom type traits to encapsulate type-based logic. </span><span class="koboSpan" id="kobo.345.3">For instance, you might want a type trait to identify whether a class has a specific </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">member function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
template &lt;typename T, typename = void&gt;
struct has_custom_method : std::false_type {};
template &lt;typename T&gt;
struct has_custom_method&lt;T, std::void_t&lt;decltype(&amp;T::customMethod)&gt;&gt; : std::true_type {};</span></pre>
<p><span class="koboSpan" id="kobo.348.1">You can use this custom trait like any other </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">type trait:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.350.1">
static_assert(has_custom_method&lt;MyClass&gt;::value, "MyClass must have a customMethod");</span></pre>
<h3><span class="koboSpan" id="kobo.351.1">Type aliases for readability and maintainability</span></h3>
<p><span class="koboSpan" id="kobo.352.1">Type aliases </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.353.1">can improve the readability and maintainability of your code by providing meaningful names for complex types. </span><span class="koboSpan" id="kobo.353.2">For example, instead of writing out </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">std::unordered_map&lt;std::string, std::vector&lt;int&gt;&gt;</span></strong><span class="koboSpan" id="kobo.355.1"> repeatedly, you could create a </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">type alias:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.357.1">
using StringToIntVectorMap = std::unordered_map&lt;std::string, std::vector&lt;int&gt;&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.358.1">Now, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">StringToIntVectorMap</span></strong><span class="koboSpan" id="kobo.360.1"> in your code, making it more readable and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">to maintain:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.362.1">
StringToIntVectorMap myMap;</span></pre>
<p><span class="koboSpan" id="kobo.363.1">Type aliases can also be templated, allowing for even </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">more flexibility:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.365.1">
template &lt;typename Value&gt;
using StringToValueMap = std::unordered_map&lt;std::string, Value&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.366.1">By employing these advanced type techniques, you add another layer of safety, readability, and maintainability to your C++ code. </span><span class="koboSpan" id="kobo.366.2">These methods give you more control over how types behave in templates, how they’re checked, and how they’re represented, ensuring that you can write code that’s as robust as it </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">is efficient.</span></span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.368.1">Avoiding common pitfalls in advanced type usage</span></h1>
<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.369.1">Writing robust code with type checks</span></h2>
<p><span class="koboSpan" id="kobo.370.1">Type-checking</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.371.1"> is one of the pillars that contributes to the robustness and safety of a program. </span><span class="koboSpan" id="kobo.371.2">While C++ is strongly typed, it does allow for some flexibility (or leniency, depending on your perspective) that can lead to errors if not carefully managed. </span><span class="koboSpan" id="kobo.371.3">Here are some techniques and best practices to write robust C++ code by leveraging </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">type checks.</span></span></p>
<h3><span class="koboSpan" id="kobo.373.1">Using type traits for compile-time checks</span></h3>
<p><span class="koboSpan" id="kobo.374.1">The </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.375.1">C++ Standard library offers a set of type traits in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">&lt;type_traits&gt;</span></strong><span class="koboSpan" id="kobo.377.1"> header, which allows</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.378.1"> you to inspect and make decisions based on types at compile time. </span><span class="koboSpan" id="kobo.378.2">For example, if you have a generic function that should only accept unsigned integral types, you can enforce this </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">static_assert</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.382.1">
#include &lt;type_traits&gt;
template &lt;typename T&gt;
void foo(T value) {
    static_assert(std::is_unsigned&lt;T&gt;::value, "foo() requires an unsigned integral type");
    // ... </span><span class="koboSpan" id="kobo.382.2">function body
}</span></pre>
<h3><span class="koboSpan" id="kobo.383.1">Leveraging constexpr if</span></h3>
<p><span class="koboSpan" id="kobo.384.1">C++17 introduced </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">constexpr if</span></strong><span class="koboSpan" id="kobo.386.1">, enabling you to write conditional code that’s evaluated </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.387.1">at compile time. </span><span class="koboSpan" id="kobo.387.2">This can be very useful for type-specific operations in </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">template code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.389.1">
template &lt;typename T&gt;
void bar(T value) {
    if constexpr (std::is_floating_point&lt;T&gt;::value) {
        // Handle floating-point types
    } else if constexpr (std::is_integral&lt;T&gt;::value) {
        // Handle integral types
    }
}</span></pre>
<h3><span class="koboSpan" id="kobo.390.1">Strong types for function arguments</span></h3>
<p><span class="koboSpan" id="kobo.391.1">C++ allows </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.392.1">type aliases, which can sometimes make it difficult to understand the purpose of a function argument. </span><span class="koboSpan" id="kobo.392.2">For example, a function declared as </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">void process(int, int);</span></strong><span class="koboSpan" id="kobo.394.1"> is not very informative. </span><span class="koboSpan" id="kobo.394.2">Is the first integer a length? </span><span class="koboSpan" id="kobo.394.3">Is the second one an index? </span><span class="koboSpan" id="kobo.394.4">One way to mitigate this is by using strong type definitions, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
struct Length { int value; };
struct Index { int value; };
void process(Length l, Index i);</span></pre>
<p><span class="koboSpan" id="kobo.397.1">Now, the</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.398.1"> function signature provides semantic meaning, making it less likely for the developer to swap the </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">arguments accidentally.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.400.1">Implicit conversions and type coercion</span></h2>
<h3><span class="koboSpan" id="kobo.401.1">A case of accidental file creation</span></h3>
<p><span class="koboSpan" id="kobo.402.1">In C++ development, it’s </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.403.1">common to define classes with constructors that accept various argument types for flexibility. </span><span class="koboSpan" id="kobo.403.2">However, this comes with the risk of unintentional implicit conversions. </span><span class="koboSpan" id="kobo.403.3">To illustrate this point, consider the following code snippet involving a </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">File</span></strong><span class="koboSpan" id="kobo.405.1"> class and a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">clean</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.407.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.408.1">
#include &lt;iostream&gt;
class File {
public:
    File(const std::string&amp; path) : path_{path} {
        auto file = fopen(path_.c_str(), "w");
        // check if file is valid
        // handle errors, etc
        std::cout &lt;&lt; "File ctor\n";
    }
    auto&amp; path() const {
        return path_;
    }
    // other ctors, dtor, etc
private:
    FILE* file_ = nullptr;
    std::string path_;
};
void clean(const File&amp; file) {
    std::cout &lt;&lt; "Removing the file: " &lt;&lt; file.path() &lt;&lt; std::endl;
}
int main() {
    auto random_string = std::string{"blabla"};
    clean(random_string);
}</span></pre>
<p><span class="koboSpan" id="kobo.409.1">The output demonstrates the </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">issue clearly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.411.1">
File ctor
Removing the file: blabla</span></pre>
<p><span class="koboSpan" id="kobo.412.1">The compiler automatically converts </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">std::string</span></strong><span class="koboSpan" id="kobo.414.1"> to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">File</span></strong><span class="koboSpan" id="kobo.416.1"> object due to the absence of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">explicit</span></strong><span class="koboSpan" id="kobo.418.1"> keyword in the constructor, thereby triggering an unintended side-effect – the creation of a </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">new file.</span></span></p>
<h3><span class="koboSpan" id="kobo.420.1">The utility of explicit</span></h3>
<p><span class="koboSpan" id="kobo.421.1">To </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.422.1">mitigate such risks, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">explicit</span></strong><span class="koboSpan" id="kobo.424.1"> keyword </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.425.1">can be employed. </span><span class="koboSpan" id="kobo.425.2">By marking a constructor as </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">explicit</span></strong><span class="koboSpan" id="kobo.427.1">, you instruct the compiler to disallow implicit conversions for that constructor. </span><span class="koboSpan" id="kobo.427.2">Here’s how the corrected </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">File</span></strong><span class="koboSpan" id="kobo.429.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">would look:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.431.1">
class File {
public:
    explicit File(const std::string&amp; path) : path_{path} {
        auto file = fopen(path_.c_str(), "w");
        // check if file is valid
        // handle errors, etc
        std::cout &lt;&lt; "File ctor\n";
    }
    // ... </span><span class="koboSpan" id="kobo.431.2">rest of the class
};</span></pre>
<p><span class="koboSpan" id="kobo.432.1">With this change, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">clean(random_string);</span></strong><span class="koboSpan" id="kobo.434.1"> line would result in a compilation error, effectively preventing accidental </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">file creation.</span></span></p>
<h3><span class="koboSpan" id="kobo.436.1">A light-hearted caveat</span></h3>
<p><span class="koboSpan" id="kobo.437.1">While our example might be somewhat simplified for educational purposes (yes, there’s no need to roll your own </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">File</span></strong><span class="koboSpan" id="kobo.439.1"> class – we have libraries for that!), it serves to underline a critical aspect of type safety in C++. </span><span class="koboSpan" id="kobo.439.2">A seemingly innocuous constructor can lead to unexpected behavior if not explicitly guarded against </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">implicit conversions.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">So, remember, when</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.442.1"> you’re defining constructors, it pays to be explicit about your intentions. </span><span class="koboSpan" id="kobo.442.2">You never know when you might accidentally start a “file party” you never intended </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">to host.</span></span></p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.444.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.445.1">As we’ve traversed the vast landscape of C++’s rich static type system, it’s worth taking a moment to reflect on how far we’ve come. </span><span class="koboSpan" id="kobo.445.2">From the earliest days of C++, where raw pointers and loosely typed arrays reigned supreme, to the modern era of </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">std::optional</span></strong><span class="koboSpan" id="kobo.447.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">std::variant</span></strong><span class="koboSpan" id="kobo.449.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">enum class</span></strong><span class="koboSpan" id="kobo.451.1">, the language has evolved substantially in its approach to </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">type safety.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">The real power of these advances shines through when we consider how they improve not just individual code snippets but also entire software systems. </span><span class="koboSpan" id="kobo.453.2">Embracing C++’s robust type constructs can help us write safer, more readable, and ultimately, more maintainable code. </span><span class="koboSpan" id="kobo.453.3">Features such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">std::optional</span></strong><span class="koboSpan" id="kobo.455.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">not_null</span></strong><span class="koboSpan" id="kobo.457.1"> wrappers reduce the chance of null pointer errors. </span><span class="koboSpan" id="kobo.457.2">Advanced techniques such as template specialization and custom type traits offer unprecedented control over type behavior. </span><span class="koboSpan" id="kobo.457.3">These are not just academic exercises; they are practical tools for the everyday </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">C++ programmer.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">Looking ahead, the trajectory of C++ suggests an increasingly nuanced and powerful type system. </span><span class="koboSpan" id="kobo.459.2">As the language continues to evolve, who knows what innovative type-related features may lie on the horizon? </span><span class="koboSpan" id="kobo.459.3">Perhaps future versions of C++ will offer even more dynamic type checking, or maybe they’ll introduce new constructs that we can’t </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">yet imagine.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">In the next chapter, we’ll pivot from the nitty-gritty of types to the grand architecture of classes, objects, and object-oriented programming in C++. </span><span class="koboSpan" id="kobo.461.2">While types give us the building blocks, it’s these larger constructs that help us assemble those blocks into towering structures of sustainable software design. </span><span class="koboSpan" id="kobo.461.3">Until then, may your types be strong, your pointers never null, and your code </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">forever robust.</span></span></p>
</div>
</body></html>