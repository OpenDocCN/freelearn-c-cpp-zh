<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-93"><a id="_idTextAnchor092"/>6</h1>
<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/>Utilizing a Rich Static Type System in C++</h1>
<p>In modern software development, the notion of “type” has <a id="_idIndexMarker219"/>transcended its primitive definition, evolving into a rich and expressive language feature that encapsulates more than just data representation. In C++, a language renowned for its performance and flexibility, the static type system serves as a powerful tool, enabling developers to write code that’s not only robust and efficient but also self-documenting and maintainable.</p>
<p>The significance of types in C++ extends beyond the mere categorization of data. By enforcing strict compile-time checks, the language’s type system reduces runtime errors, improves readability, and fosters a more intuitive understanding of code. With the advent of modern C++ standards, the opportunities to leverage types have further expanded, bringing forth elegant solutions to common programming challenges.</p>
<p>However, these powerful features can often be underutilized. Primitive data types such as integers are frequently misused to represent concepts such as time durations, leading to code that lacks expressiveness and can be prone to errors. Pointers, although flexible, can lead to null dereferencing issues, making the code base fragile.</p>
<p>In this chapter, we’ll explore the rich landscape of C++’s static type system, focusing on advanced and modern techniques that help to mitigate these problems. From using the <code>&lt;chrono&gt;</code> library to represent time durations to employing <code>not_null</code> wrappers and <code>std::optional</code> for safer pointer handling, we’ll delve into practices that embody the essence of strong typing.</p>
<p>We’ll also look at external libraries such as Boost, which offer additional utilities to enhance type safety. Throughout the chapter, real-world examples will illustrate how these tools and techniques can be seamlessly integrated into your code, empowering you to harness the full potential of C++’s type system.</p>
<p>By the end of this chapter, you’ll gain a deep understanding of how to utilize types to write more robust, readable, and expressive code, tapping into the true power of C++.</p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/>Utilizing Chrono for time duration</h1>
<p>One of <a id="_idIndexMarker220"/>the best examples of how C++’s type system can be leveraged to write more robust code is the <code>&lt;chrono&gt;</code> library. Introduced in C++11, this header provides a set of utilities to represent time durations and points in time, as well as perform time-related operations.</p>
<p>Managing <a id="_idIndexMarker221"/>time-related functions using plain integers or structures such as <code>timespec</code> can be a bug-prone approach, especially when dealing with different units of time. Imagine a function that takes an integer representing a timeout in seconds:</p>
<pre class="source-code">
void wait_for_data(int timeout_seconds) {
    sleep(timeout_seconds); // Sleeps for timeout_seconds seconds
}</pre>
<p>This approach lacks flexibility and can lead to confusion when handling various time units. For example, if a caller mistakenly passes milliseconds instead of seconds, it can cause unexpected behavior.</p>
<p>By contrast, using <code>&lt;chrono&gt;</code> to define the same function makes the code more robust and expressive:</p>
<pre class="source-code">
#include &lt;chrono&gt;
#include &lt;thread&gt;
void wait_for_data(std::chrono::seconds timeout) {
    std::this_thread::sleep_for(timeout); // Sleeps for the specified timeout
}</pre>
<p>The caller can now pass the timeout using a strongly-typed duration, such as <code>std::chrono::seconds(5)</code>, and the compiler ensures that the correct unit is used. Moreover, <code>&lt;chrono&gt;</code> provides seamless conversion between different time units, allowing the caller to specify the timeout in seconds, milliseconds, or any other unit, without ambiguity. The following snippet illustrates the usage with different units:</p>
<pre class="source-code">
wait_for_data(std::chrono::milliseconds(150));</pre>
<p>By embracing the strong typing offered by <code>&lt;chrono&gt;</code>, the code becomes clearer, more maintainable, and less susceptible to common bugs related to time representation.</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Improving Pointer Safety with not_null and std::optional</h1>
<p>In C++, pointers are a<a id="_idIndexMarker222"/> fundamental part of the language, allowing direct memory access and manipulation. However, the flexibility that pointers offer comes with certain risks and challenges. Here, we’ll explore how modern C++ techniques can enhance pointer safety.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/>The pitfalls of raw pointers</h2>
<p>Raw pointers, while <a id="_idIndexMarker223"/>powerful, can be a double-edged sword. They provide no information about the ownership of the object they point to, and they can easily become “dangling” pointers, pointing to memory that has been deallocated. Dereferencing a null or dangling pointer leads to undefined behavior, which can result in hard-to-diagnose bugs.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>Using not_null from the Guidelines Support Library</h2>
<p>The <code>not_null</code> wrapper<a id="_idIndexMarker224"/> provided by the <code>not_null</code>, you can clearly signal that a pointer should never be null:</p>
<pre class="source-code">
#include &lt;gsl/gsl&gt;
void process_data(gsl::not_null&lt;int*&gt; data) {
    // Data is guaranteed not to be null here
}</pre>
<p>If a user passes a null pointer to this function as follows, the application will be terminated:</p>
<pre class="source-code">
int main() {
    int* p = nullptr;
    process_data(p); // this will terminate the program
    return 0;
}</pre>
<p>However, if <a id="_idIndexMarker225"/>the pointer is passed as <code>process_data(nullptr)</code>, the application will fail in compile time:</p>
<pre class="source-code">
source&gt;: In function 'int main()':
&lt;source&gt;:9:16: error: use of deleted function 'gsl::not_null&lt;T&gt;::not_null(std::nullptr_t) [with T = int*; std::nullptr_t = std::nullptr_t]'
    9 |     process_data(nullptr);
      |     ~~~~~~~~~~~^~~~~~~~~
In file included from &lt;source&gt;:1:
/opt/compiler-explorer/libs/GSL/trunk/include/gsl/pointers:131:5: note: declared here
  131 |     not_null(std::nullptr_t) = delete;
      |     ^~~~~~~~</pre>
<p>This promotes robust code by catching potential null pointer errors early, thus reducing runtime errors.</p>
<h3>Extending not_null to smart pointers</h3>
<p><code>gsl::not_null</code> is not<a id="_idIndexMarker226"/> limited to raw pointers; it can also be used with smart pointers such as <code>std::unique_ptr</code> and <code>std::shared_ptr</code>. This allows you to combine the benefits of modern memory management with the additional safety guarantees that <code>not_null</code> provides.</p>
<h3>With std::unique_ptr</h3>
<p><code>std::unique_ptr</code> ensures<a id="_idIndexMarker227"/> that the ownership of a dynamically allocated object is unique, and it automatically deletes the object when it is no longer needed. By using <code>not_null</code> with <code>unique_ptr</code>, you can also ensure that the pointer is <a id="_idIndexMarker228"/>never null:</p>
<pre class="source-code">
<code>#include &lt;gsl/gsl&gt;</code>
<code>#include &lt;memory&gt;</code>
void process_data(gsl::not_null&lt;std::unique_ptr&lt;int&gt;&gt; data) {
    // Data is guaranteed not to be null here
}
int main() {
    auto data = std::make_unique&lt;int&gt;(42);
    process_data(std::move(data)); // Safely passed to the function
}</pre>
<h3>With std::shared_ptr</h3>
<p>Similarly, <code>gsl::not_null</code> can be used with <code>std::shared_ptr</code>, which enables shared <a id="_idIndexMarker229"/>ownership of an object. This allows you to write functions that accept shared pointers without having to worry about nullity:</p>
<pre class="source-code">
#include &lt;gsl/gsl&gt;
#include &lt;memory&gt;
void process_data(gsl::not_null&lt;std::shared_ptr&lt;int&gt;&gt; data) {
    // Data is guaranteed not to be null here
}
int main() {
    auto data = std::make_shared&lt;int&gt;(42);
    process_data(data); // Safely passed to the function
}</pre>
<p>These <a id="_idIndexMarker230"/>examples demonstrate how <code>not_null</code> can seamlessly integrate with modern C++ memory management techniques. By enforcing that a pointer (whether raw or smart) cannot be null, you further reduce the potential for runtime errors and make code more robust and expressive.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Utilizing std::optional for optional values</h2>
<p>Sometimes, a<a id="_idIndexMarker231"/> pointer is used to indicate an optional value, where <code>nullptr</code> signifies the absence of a value. C++17 introduced <code>std::optional</code>, which provides a type-safe way to represent optional values:</p>
<pre class="source-code">
#include &lt;optional&gt;
std::optional&lt;int&gt; fetch_data() {
    if (/* some condition */)
        return 42;
    else
        return std::nullopt;
}</pre>
<p>Using <code>std::optional</code> provides clear semantics and avoids the pitfalls associated with using pointers for this purpose.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>A comparison between raw pointers and nullptr</h2>
<p>Both <code>not_null</code> and <code>std::optional</code> offer advantages over raw pointers. While raw pointers can be<a id="_idIndexMarker232"/> null or dangling, leading to undefined behavior, <code>not_null</code> prevents null pointer errors at compile time, and <code>std::optional</code> provides a clear way to represent optional values.</p>
<p>Consider the following example using raw pointers:</p>
<pre class="source-code">
int* findValue() {
    // ...
    return nullptr; // No value found
}</pre>
<p>This code<a id="_idIndexMarker233"/> might lead to confusion and bugs, especially if the caller forgets to check for <code>nullptr</code>. By using <code>not_null</code> and <code>std::optional</code>, you can make the code more expressive and less error-prone.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>Leveraging std::expected for expected results and errors</h2>
<p>While <code>std::optional</code> elegantly represents an optional value, sometimes you need to convey <a id="_idIndexMarker234"/>more information about why a value might be missing. In such cases, <code>std::expected</code> provides a way to return either a value or an error code, making code more expressive and the error handling more robust.</p>
<p>Consider a scenario where you have a function that retrieves a value from a network, and you want to handle network errors. You might define an enumeration for the various network errors:</p>
<pre class="source-code">
enum class NetworkError {
    Timeout,
    ConnectionLost,
    UnknownError
};</pre>
<p>You can then use <code>std::expected</code> to define a function that returns either an <code>int</code> value or <code>NetworkError</code>:</p>
<pre class="source-code">
#include &lt;expected&gt;
#include &lt;iostream&gt;
std::expected&lt;int, NetworkError&gt; fetch_data_from_network() {
    // Simulating network operation...
    if (/* network timeout */) {
        return std::unexpected(NetworkError::Timeout);
    }
    if (/* connection lost */) {
        return std::unexpected(NetworkError::ConnectionLost);
    }
    return 42; // Successfully retrieved value
}
int main() {
    auto result = fetch_data_from_network();
    if (result) {
        std::cout &lt;&lt; "Value retrieved: " &lt;&lt; *result &lt;&lt; '\n';
    } else {
        std::cout &lt;&lt; "Network error: ";
        switch(result.error()) {
            case NetworkError::Timeout:
                std::cout &lt;&lt; "Timeout\n";
                break;
            case NetworkError::ConnectionLost:
                std::cout &lt;&lt; "Connection Lost\n";
                break;
            case NetworkError::UnknownError:
                std::cout &lt;&lt; "Unknown Error\n";
                break;
        }
    }
}</pre>
<p>Here, <code>std::expected</code> captures both the successful case and various error scenarios, allowing<a id="_idIndexMarker235"/> for clear and type-safe error handling. This example illustrates how modern C++ types such as <code>std::expected</code> enhance expressiveness and safety, allowing you to write code that more accurately models complex operations.</p>
<p>By embracing these modern C++ tools, you can enhance pointer safety in your code, reducing bugs and making your intentions clear.</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/>Strong typing with enum class and scoped enumerations</h1>
<p>Strong typing is a cornerstone of robust, maintainable software, and C++ provides several <a id="_idIndexMarker236"/>mechanisms to facilitate it. Among these, <code>enum class</code>, introduced in C++11, is a particularly effective tool for creating strongly typed enumerations that can make your programs both more robust and easier to understand.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>A review of enum class</h2>
<p>Traditional<a id="_idIndexMarker237"/> enumerations in C++ suffer from a few limitations – they can implicitly convert to integers, potentially causing errors if misused, and their enumerators are introduced into the enclosing scope, leading to name clashes. <code>enum class</code>, also known as scoped enumerations, addresses these limitations:</p>
<pre class="source-code">
// Traditional enum
enum ColorOld { RED, GREEN, BLUE };
int color = RED; // Implicit conversion to int
// Scoped enum (enum class)
enum class Color { Red, Green, Blue };
// int anotherColor = Color::Red; // Compilation error: no implicit conversion</pre>
<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/>The benefits over traditional enums</h2>
<p>Scoped <a id="_idIndexMarker238"/>enumerations offer several advantages:</p>
<ul>
<li><code>enum class</code> type and integers, ensuring that you can’t accidentally misuse an enumerator as an integer</li>
<li><code>enum class</code>, reducing the likelihood of name collisions</li>
<li><code>enum class</code> allows you to explicitly specify the underlying type, giving you precise control over the data representation:<pre class="source-code">
<code>enum class StatusCode : uint8_t { Ok, Error, Pending };</code></pre></li>
</ul>
<p>The ability to specify the underlying type is particularly useful for serializing data to binary formats. It ensures that you have fine-grained control over how the data is represented at the byte level, facilitating easier data interchange with systems that may have specific binary format requirements.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>Real-world scenarios</h2>
<p>The <a id="_idIndexMarker239"/>advantages of <code>enum class</code> make it a powerful tool for various scenarios:</p>
<ul>
<li><code>enum class</code> provides a type-safe, expressive way to represent various possible states</li>
<li><strong class="bold">Option sets</strong>: Many functions have multiple behavior options, which can be neatly and safely encapsulated using scoped enumerations</li>
<li><code>enum class</code>:<pre class="source-code">
enum class NetworkStatus { Connected, Disconnected, Error };</pre><pre class="source-code">
NetworkStatus check_connection() {</pre><pre class="source-code">
    // Implementation</pre><pre class="source-code">
}</pre></li>
</ul>
<p>By <a id="_idIndexMarker240"/>using <code>enum class</code> to create strongly typed, scoped enumerations, you can write code that is not only easier to understand but also less prone to errors. This feature represents another step forward in C++’s ongoing evolution toward a language that combines high performance with modern programming conveniences. Whether you’re defining a complex state machine or simply trying to represent multiple options or statuses, <code>enum class</code> offers a robust, type-safe solution.</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>Leveraging the standard library’s type utilities</h1>
<p>Modern C++ offers a<a id="_idIndexMarker241"/> rich set of type utilities within the Standard library that enables developers to write more expressive, type-safe, and maintainable code. Two prominent examples are <code>std::variant</code> and <code>std::any</code>.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>std::variant – a type-safe union</h2>
<p><code>std::variant</code> provides<a id="_idIndexMarker242"/> a type-safe way to represent<a id="_idIndexMarker243"/> a value that can be one of several possible types. Unlike a traditional <code>union</code>, which allows the programmer to treat the stored value as any of its member types, leading to potential undefined behavior, <code>std::variant</code> tracks the currently<a id="_idIndexMarker244"/> held type and ensures proper handling:</p>
<pre class="source-code">
#include &lt;variant&gt;
#include &lt;iostream&gt;
std::variant&lt;int, double, std::string&gt; value = 42;
// Using std::get with an index:
int intValue = std::get&lt;0&gt;(value); // Retrieves the int value
// Using std::get with a type:
try {
    double doubleValue = std::get&lt;double&gt;(value); // Throws std::bad_variant_access
} catch (const std::bad_variant_access&amp; e) {
    std::cerr &lt;&lt; "Bad variant access: " &lt;&lt; e.what() &lt;&lt; '\n';
}
// Using std::holds_alternative:
if (std::holds_alternative&lt;int&gt;(value)) {
    std::cout &lt;&lt; "Holding int\n";
} else {
    std::cout &lt;&lt; "Not holding int\n";
}</pre>
<h3>The benefits over traditional unions</h3>
<ul>
<li><code>std::variant</code>, conversely, keeps track of the current type and provides safe access through functions such as <code>std::get</code> and <code>std::holds_alternative</code>.</li>
<li><code>std::variant</code> automatically constructs and destroys the held object when you assign a new value, managing the object’s lifetime correctly.</li>
<li><code>std::get</code>, a <code>std::bad_variant_access</code> exception is thrown, making error handling more transparent and easier to manage.</li>
<li><code>std::variant</code> can be used with standard library functions such as <code>std::visit</code>, providing elegant ways to handle various types.</li>
</ul>
<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>std::any – type-safe containers for any type</h2>
<p><code>std::any</code> is a <a id="_idIndexMarker246"/>container that can hold any type but<a id="_idIndexMarker247"/> maintains type safety by requiring explicit casting to the correct type. This allows for flexible handling of data without sacrificing type integrity:</p>
<pre class="source-code">
#include &lt;any&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
std::any value = 42;
try {
    std::cout &lt;&lt; std::any_cast&lt;int&gt;(value); // Outputs 42
    std::cout &lt;&lt; std::any_cast&lt;double&gt;(value); // Throws std::bad_any_cast
} catch(const std::bad_any_cast&amp; e) {
    std::cerr &lt;&lt; "Bad any_cast: " &lt;&lt; e.what();
}</pre>
<p>The <a id="_idIndexMarker248"/>advantages of using <code>std::any</code> include the following:</p>
<ul>
<li><strong class="bold">Flexibility</strong>: It can store any type, making it suitable for heterogeneous collections or flexible APIs</li>
<li><strong class="bold">Type safety</strong>: Requires explicit casting, preventing accidental misinterpretation of the contained value</li>
<li><strong class="bold">Encapsulation</strong>: Allows you to pass around values without exposing their concrete types, supporting more modular and maintainable code</li>
</ul>
<h2 id="_idParaDest-109"><a id="_idTextAnchor108"/>Advanced type techniques</h2>
<p>As you delve <a id="_idIndexMarker249"/>deeper into C++, you’ll find<a id="_idIndexMarker250"/> that the language offers an array of advanced techniques for enhancing type safety, readability, and maintainability. In this section, we’ll explore a few of these advanced concepts, providing practical examples for each.</p>
<h3>Templates – specializing for type safety</h3>
<p>Templates <a id="_idIndexMarker251"/>are a powerful feature in C++, but you may want to impose certain constraints or specializations based on types. One way to do this is via template specialization, which allows you to define custom behavior for certain types.</p>
<p>For example, let’s say you have a generic function to find the maximum element in an array:</p>
<pre class="source-code">
template &lt;typename T&gt;
T find_max(const std::vector&lt;T&gt;&amp; arr) {
    // generic implementation
    return *std::max_element(arr.begin(), arr.end());
}</pre>
<p>Now, let’s <a id="_idIndexMarker252"/>say you want to provide a specialized implementation for <code>std::string</code> that is case-insensitive:</p>
<pre class="source-code">
template &lt;&gt;
std::string find_max(const std::vector&lt;std::string&gt;&amp; arr) {
    return *std::max_element(arr.begin(), arr.end(),
                              [](const std::string&amp; a, const std::string&amp; b) {
                                  return strcasecmp(a.c_str(), b.c_str()) &lt; 0;
                              });
}</pre>
<p>With this specialized version, calls to <code>find_max</code> with <code>std::string</code> will use a case-insensitive comparison.</p>
<h3>Creating custom type traits</h3>
<p>Sometimes, the<a id="_idIndexMarker253"/> standard type traits may not be sufficient for your needs. You can create your own custom type traits to encapsulate type-based logic. For instance, you might want a type trait to identify whether a class has a specific member function:</p>
<pre class="source-code">
template &lt;typename T, typename = void&gt;
struct has_custom_method : std::false_type {};
template &lt;typename T&gt;
struct has_custom_method&lt;T, std::void_t&lt;decltype(&amp;T::customMethod)&gt;&gt; : std::true_type {};</pre>
<p>You can use this custom trait like any other type trait:</p>
<pre class="source-code">
static_assert(has_custom_method&lt;MyClass&gt;::value, "MyClass must have a customMethod");</pre>
<h3>Type aliases for readability and maintainability</h3>
<p>Type aliases <a id="_idIndexMarker254"/>can improve the readability and maintainability of your code by providing meaningful names for complex types. For example, instead of writing out <code>std::unordered_map&lt;std::string, std::vector&lt;int&gt;&gt;</code> repeatedly, you could create a type alias:</p>
<pre class="source-code">
using StringToIntVectorMap = std::unordered_map&lt;std::string, std::vector&lt;int&gt;&gt;;</pre>
<p>Now, you can use <code>StringToIntVectorMap</code> in your code, making it more readable and easier to maintain:</p>
<pre class="source-code">
StringToIntVectorMap myMap;</pre>
<p>Type aliases can also be templated, allowing for even more flexibility:</p>
<pre class="source-code">
template &lt;typename Value&gt;
using StringToValueMap = std::unordered_map&lt;std::string, Value&gt;;</pre>
<p>By employing these advanced type techniques, you add another layer of safety, readability, and maintainability to your C++ code. These methods give you more control over how types behave in templates, how they’re checked, and how they’re represented, ensuring that you can write code that’s as robust as it is efficient.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>Avoiding common pitfalls in advanced type usage</h1>
<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>Writing robust code with type checks</h2>
<p>Type-checking<a id="_idIndexMarker255"/> is one of the pillars that contributes to the robustness and safety of a program. While C++ is strongly typed, it does allow for some flexibility (or leniency, depending on your perspective) that can lead to errors if not carefully managed. Here are some techniques and best practices to write robust C++ code by leveraging type checks.</p>
<h3>Using type traits for compile-time checks</h3>
<p>The <a id="_idIndexMarker256"/>C++ Standard library offers a set of type traits in the <code>&lt;type_traits&gt;</code> header, which allows<a id="_idIndexMarker257"/> you to inspect and make decisions based on types at compile time. For example, if you have a generic function that should only accept unsigned integral types, you can enforce this using <code>static_assert</code>:</p>
<pre class="source-code">
#include &lt;type_traits&gt;
template &lt;typename T&gt;
void foo(T value) {
    static_assert(std::is_unsigned&lt;T&gt;::value, "foo() requires an unsigned integral type");
    // ... function body
}</pre>
<h3>Leveraging constexpr if</h3>
<p>C++17 introduced <code>constexpr if</code>, enabling you to write conditional code that’s evaluated <a id="_idIndexMarker258"/>at compile time. This can be very useful for type-specific operations in template code:</p>
<pre class="source-code">
template &lt;typename T&gt;
void bar(T value) {
    if constexpr (std::is_floating_point&lt;T&gt;::value) {
        // Handle floating-point types
    } else if constexpr (std::is_integral&lt;T&gt;::value) {
        // Handle integral types
    }
}</pre>
<h3>Strong types for function arguments</h3>
<p>C++ allows <a id="_idIndexMarker259"/>type aliases, which can sometimes make it difficult to understand the purpose of a function argument. For example, a function declared as <code>void process(int, int);</code> is not very informative. Is the first integer a length? Is the second one an index? One way to mitigate this is by using strong type definitions, such as the following:</p>
<pre class="source-code">
struct Length { int value; };
struct Index { int value; };
void process(Length l, Index i);</pre>
<p>Now, the<a id="_idIndexMarker260"/> function signature provides semantic meaning, making it less likely for the developer to swap the arguments accidentally.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>Implicit conversions and type coercion</h2>
<h3>A case of accidental file creation</h3>
<p>In C++ development, it’s <a id="_idIndexMarker261"/>common to define classes with constructors that accept various argument types for flexibility. However, this comes with the risk of unintentional implicit conversions. To illustrate this point, consider the following code snippet involving a <code>File</code> class and a <code>clean</code> function:</p>
<pre class="source-code">
#include &lt;iostream&gt;
class File {
public:
    File(const std::string&amp; path) : path_{path} {
        auto file = fopen(path_.c_str(), "w");
        // check if file is valid
        // handle errors, etc
        std::cout &lt;&lt; "File ctor\n";
    }
    auto&amp; path() const {
        return path_;
    }
    // other ctors, dtor, etc
private:
    FILE* file_ = nullptr;
    std::string path_;
};
void clean(const File&amp; file) {
    std::cout &lt;&lt; "Removing the file: " &lt;&lt; file.path() &lt;&lt; std::endl;
}
int main() {
    auto random_string = std::string{"blabla"};
    clean(random_string);
}</pre>
<p>The output demonstrates the issue clearly:</p>
<pre class="source-code">
File ctor
Removing the file: blabla</pre>
<p>The compiler automatically converts <code>std::string</code> to a <code>File</code> object due to the absence of the <code>explicit</code> keyword in the constructor, thereby triggering an unintended side-effect – the creation of a new file.</p>
<h3>The utility of explicit</h3>
<p>To <a id="_idIndexMarker262"/>mitigate such risks, the <code>explicit</code> keyword <a id="_idIndexMarker263"/>can be employed. By marking a constructor as <code>explicit</code>, you instruct the compiler to disallow implicit conversions for that constructor. Here’s how the corrected <code>File</code> class would look:</p>
<pre class="source-code">
class File {
public:
    explicit File(const std::string&amp; path) : path_{path} {
        auto file = fopen(path_.c_str(), "w");
        // check if file is valid
        // handle errors, etc
        std::cout &lt;&lt; "File ctor\n";
    }
    // ... rest of the class
};</pre>
<p>With this change, the <code>clean(random_string);</code> line would result in a compilation error, effectively preventing accidental file creation.</p>
<h3>A light-hearted caveat</h3>
<p>While our example might be somewhat simplified for educational purposes (yes, there’s no need to roll your own <code>File</code> class – we have libraries for that!), it serves to underline a critical aspect of type safety in C++. A seemingly innocuous constructor can lead to unexpected behavior if not explicitly guarded against implicit conversions.</p>
<p>So, remember, when<a id="_idIndexMarker264"/> you’re defining constructors, it pays to be explicit about your intentions. You never know when you might accidentally start a “file party” you never intended to host.</p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor112"/>Summary</h1>
<p>As we’ve traversed the vast landscape of C++’s rich static type system, it’s worth taking a moment to reflect on how far we’ve come. From the earliest days of C++, where raw pointers and loosely typed arrays reigned supreme, to the modern era of <code>std::optional</code>, <code>std::variant</code>, and <code>enum class</code>, the language has evolved substantially in its approach to type safety.</p>
<p>The real power of these advances shines through when we consider how they improve not just individual code snippets but also entire software systems. Embracing C++’s robust type constructs can help us write safer, more readable, and ultimately, more maintainable code. Features such as the <code>std::optional</code> and <code>not_null</code> wrappers reduce the chance of null pointer errors. Advanced techniques such as template specialization and custom type traits offer unprecedented control over type behavior. These are not just academic exercises; they are practical tools for the everyday C++ programmer.</p>
<p>Looking ahead, the trajectory of C++ suggests an increasingly nuanced and powerful type system. As the language continues to evolve, who knows what innovative type-related features may lie on the horizon? Perhaps future versions of C++ will offer even more dynamic type checking, or maybe they’ll introduce new constructs that we can’t yet imagine.</p>
<p>In the next chapter, we’ll pivot from the nitty-gritty of types to the grand architecture of classes, objects, and object-oriented programming in C++. While types give us the building blocks, it’s these larger constructs that help us assemble those blocks into towering structures of sustainable software design. Until then, may your types be strong, your pointers never null, and your code forever robust.</p>
</div>
</body></html>