- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding Behavior and Interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Chapter 9*! In the previous chapter, we took a deeper look into
    collision detection. After a discussion about the complexity of finding colliding
    instances in the virtual world, we explored ways to speed up the collision search
    by adding world partitioning and model simplifications. Then, we implemented a
    quadtree to split up the world into smaller areas, and we added bounding boxes
    and bounding spheres for the instances. Finally, we used both the quadtree and
    the instance boundaries to detect a collision between instances.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will add some sort of “real-life” behavior to the instances,
    giving them the ability to walk around the virtual world by themselves and react
    to events like the collisions we added in the previous chapter. First, we will
    take a brief look at behavior trees and state machines and how both works. Then,
    we will add a visual editor to visually represent the state machines of the instances
    themselves. At the end of the chapter, we will extend the code to execute the
    behavior changes from the created node trees, and we will add interaction as an
    additional form of behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Structures to control instance behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a visual node editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the code to support behavior changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding interaction between instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example code can be found in the folder `chapter09`, in the subfolder `01_opengl_behavior`
    for OpenGL and `02_vulkan_behavior` for Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: Structures to control instance behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the early days of computer games, the behavior of enemies and other **non-player
    characters** (**NPCs**) was rather simple. Based on only the game state or a few
    properties, like *The player has eaten a large dot, I must stay away from them!*
    (Pac-Man) or *I saw the player, so I will attack them!* (many first-person shooters),
    the computer counterparts were acting only with a small set of rules.
  prefs: []
  type: TYPE_NORMAL
- en: Later, control structures like “plain” state machines, hierarchical state machines,
    and behavior trees changed the **artificial intelligence** (**AI**) in games a
    lot, since it became easy to model complex tasks for enemies and NPCs. Now, it
    is possible to not only create more alternatives for behavior choices but also
    let computer-controlled world inhabitants act more like intelligent beings. Spotting
    the player may lead to a handful of different outcomes from NPCs, based on world
    factors, their own properties, and a bit of randomness.
  prefs: []
  type: TYPE_NORMAL
- en: A behavior tree simplifies creating behaviors for NPCs and helps reasoning about
    the states the NPC will be in at any given time. Still, a behavior tree is only
    an enhanced finite state machine with nodes and links between nodes. The current
    state of the tree is memorized by the behavior subsystem, and based on configured
    factors in the nodes, state changes to subsequent nodes in the tree are executed.
    Without huge complexity, behavior trees are easy to implement but still powerful
    in games.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common way to create a behavior tree is by using specialized nodes, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: Selectors, choosing one among a set of options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequences, running tasks in a specific order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditions, using the outcome of previous nodes to choose the next node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops, which repeat a part of the tree several times until a condition is met
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions, which affect the character state or perform an action, like attacking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: World perception, changing behavior based on events or world properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using special nodes helps a lot in building a flexible behavior tree. The enemy
    or NPC can gather information about the world and other objects in it and choose
    a different path on the next tree execution if the world around it changes, leading
    to a more reactive, believable, and less robotic behavior by not doing the same
    moves and actions repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.1* shows a simple idea for an NPC behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: A simple behavior plan'
  prefs: []
  type: TYPE_NORMAL
- en: Even though the plan looks straightforward, it encapsulates sophisticated behavior.
    Considering the enemy’s distance and health status while scanning the plan for
    the desired behavior should result in fairly impressive NPC actions. By switching,
    with random variations, between taking cover and a range attack, directly attacking
    approaching enemies, or just trying to hide or run away as the last option, watching
    a group of these NPCs fighting incoming enemies would be entertaining.
  prefs: []
  type: TYPE_NORMAL
- en: We will add a simple state machine to control the behavior of the instances
    in this chapter. Also, to simplify creating and controlling the behavior with
    the state machine, we will add a tool to create nodes and links. So, let’s go
    on a short detour and add a visual node editor to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a visual node editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like in the previous chapters, we will use an open-source tool to build our
    visual node editor instead of building our own solutions by hand. There are several
    ImGui-based node editors available. You can find a curated list in the *Additional
    resources* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the extension called **imnodes** by Johann “Nelarius”
    Muszynski. The source code for imnodes is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/Nelarius/imnodes](https://github.com/Nelarius/imnodes)'
  prefs: []
  type: TYPE_NORMAL
- en: Like in the previous chapters, we will use CMake to fetch imnodes for us.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating imnodes by using CMake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To let CMake manage imnodes as a dependency, add a new `FetchContent` block
    to the file `CMakeLists.txt` in the project root between the `FetchContent` block
    for `stbi` and the `WIN32`-only area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will use the Git tag `v0.5` here to avoid problems introduced by new commits
    to the `master` branch, resulting in not finding the ImGui source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we make the imnodes code available and let CMake populate the variable
    for the source folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we append the source directory variable for imnodes to the list of already
    existing external source files and include directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As a last step, we add a compiler definition to the existing `add_definitions`
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By setting `IMGUI_DEFINE_MATH_OPERATORS`, ImGui exposes some of the internal
    mathematical operations to external modules like imnodes.
  prefs: []
  type: TYPE_NORMAL
- en: After running CMake, which most IDEs will perform automatically after saving
    the `CMakeLists.txt` file, imnodes is available and can be included in the user
    interface. Now, let us learn how to work with imnodes.
  prefs: []
  type: TYPE_NORMAL
- en: Using imnodes to create UI elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since imnodes is based on ImGui, imnodes function calls are like ImGui calls,
    with imnodes acting as a container to enclose the UI elements in a graphical node
    representation. A graphical node, like the wait node shown in *Figure 9.2*, can
    be added and removed dynamically to a node editor window, and links between input
    and output pins can be created.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: The elements of a simple imnodes wait node'
  prefs: []
  type: TYPE_NORMAL
- en: Elements of a node are the title bar and an arbitrary number of input pins,
    output pins, and static elements. In the title bar, a descriptive name to identify
    the node type is shown, like the word **Wait** in *Figure 9.2*. The input pin
    of the wait node is used to connect parent node(s) to this specific node, and
    on the output pin, one or more child nodes can be connected. All user controls
    are built using static elements, such as the slider for the time to wait, or the
    text field showing the time running toward 0 if the wait node was activated.
  prefs: []
  type: TYPE_NORMAL
- en: But imnodes only maintains the nodes and links. We must implement the logic
    behind the node editor according to our needs. To get a better impression of how
    much – or how little – effort is needed to create such a node editor, we will
    walk through the steps needed to draw a node like in *Figure 9.2* to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the imnodes context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like ImGui, imnodes needs a basic set of data about the current session, that
    is, the context. The imnodes context must be created after ImGui’s context, as
    imnodes relies on data from ImGui. So, the `init()` method of the `UserInterface`
    class will be extended by the `CreateContext()` call of imnodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'imnodes’ context needs to be destroyed before ImGui’s context. To do that,
    we call `DestroyContext()` of imnodes before ImGui’s `DestroyContext()` in the
    `cleanup()` method of the `UserInterface` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With the context ready, we can start to use the function calls to imnodes. Similar
    to the `ImGui` namespace, the `ImNodes` namespace will be used as a prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Setting default values for imnodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Choosing a global color style can be done exactly like in ImGui. For instance,
    to set the “light” color style for ImGui and imnodes, use the following lines
    in the `init()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Another call in the `init()` method of the `UserInterface` class can be made
    to set the modifier key used to detach links from a node. By default, imnodes
    uses the `Alt` key to detach a link. With the following two lines, we can set
    the key binding to use the `Control` key instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After we change the defaults (or not), the node editor window itself will be
    created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the node editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like any other ImGui element, the node editor must be created inside an ImGui
    window. We call `BeginNodeEditor()` right after the start of a new ImGui window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now you should see a window with a visible grid – the node editor. All imnodes
    and ImGui calls are available in this context, although it is not possible to
    draw ImGui elements directly onto the node editor as they will overlay the node
    editor elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To end the node editor and the ImGui window, we call `EndNodeEditor()` just
    before ending the ImGui window. If we want to have a transparent mini map of the
    entire node editor window shown on the top left of the window, we can call `MiniMap()`
    before ending the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the node editor window will look like *Figure 9.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: A fresh node editor window'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the node editor window, new nodes can be created. For a small example,
    we will hardcode all properties into the node. In the section *Extending the node
    editor*, a context menu will be added, allowing us to create and delete nodes
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a simple node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A new node can be started by calling `BeginNode()`, using an `int` value as
    the unique identification for the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Like in ImGui itself, all imnodes UI elements must have a unique ID set to be
    distinguishable by ImGui. Internally, imnodes uses the `ImGui::PushID()` call
    to set the ID for the group containing the node data. We only need to take care
    that all elements in the node editor have unique identifications set.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the node, we can use all ImGui elements to create control elements. Some
    ImGui elements may behave unexpectedly. For instance, an `ImGui::Separator()`
    call draws a line up to the right end of the node editor. But the usual elements,
    like text, buttons, or sliders, are working as expected. Calling `BeginDisable()`
    and `EndDisable()` also works normally, allowing us to make parts of the node
    unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when disabling ImGui elements in a node
  prefs: []
  type: TYPE_NORMAL
- en: While it may seem tempting to completely remove unneeded ImGui elements from
    the node by enclosing them in `if` statements, be aware that imnodes calculates
    the position of input and output pins from the IDs given to the attributes. If
    you want to remove attributes or ImGui elements, make sure to keep the same IDs
    for the attributes and elements remaining visible, or else the links will be attached
    at the wrong places.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.4* shows the result of the previously found lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_09_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: The sample node'
  prefs: []
  type: TYPE_NORMAL
- en: Besides being movable by holding the left mouse button, our new node is not
    useful. So, let us add some elements to the node, called “attributes” in imnodes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating imnodes attributes and ImGui elements in a node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All attributes for a node must be defined between `BeginNode()` and `EndNode()`.
    Make sure to skip the `ImGui::Text()` line from the section *Adding a simple node*
    as it will destroy the layout of the node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first imnodes attribute we add is a node title, by using `BeginNodeTitleBar()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The title is shown in a separate area at the top of the node and shows if it
    is unselected, hovered over, or selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create an input pin by calling `BeginInputAttribute()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: An input node definition creates a “magnetic” dot on the left side of the node,
    allowing us later to connect links. A node can have from zero to virtually unlimited
    input pins, but most probably, only a few pins will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the input pin, we use `BeginStaticAttribute()` to create a static attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Static attributes have no input or output connectors on the sides of the node.
    You can use a static attribute just like every other control element in an ImGui
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we add an output pin with `BeginOutputAttribute()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Like input pins, output pins create a connector to dock links. But for output
    pins, this connector is on the right side of the node.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 9.5*, the resulting node created by the code lines in this section
    is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: The updated example node'
  prefs: []
  type: TYPE_NORMAL
- en: The updated node already looks great. We have a title, input and output pins,
    and a checkbox controlled by a stateful variable – all in just about twenty lines
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting nodes with links is also simple, as we will see now.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining links between nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Links in imnodes have three properties: a unique link ID, a start pin ID, and
    an end pin ID. The unique link ID is needed to identify and draw the link itself,
    and the pin IDs are taken from the output pin of the parent (or source) node respective
    to the input pin of the child (or destination) node.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By combining these three IDs, links in imnodes are best managed as pairs of
    pin IDs in a map of link IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The inner `std::pair` stores the IDs of the start pin (output) and the end pin
    (input) of a link, in that order. With the outer `std::map`, we create a connection
    between the link ID and the pair of pin IDs.
  prefs: []
  type: TYPE_NORMAL
- en: Output first, input second
  prefs: []
  type: TYPE_NORMAL
- en: It is noteworthy to say that imnodes strictly follows this order. The first
    reported pin is always the output pin of the parent node, and the second pin is
    the input pin of the child node. Following this rule makes it easy to use nodes
    and links to create a finite state machine, maintaining the state of the node
    tree with a bunch of simple rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drawing the existing nodes can be done by calling `Link()` with exactly the
    three link properties mentioned earlier in the section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: All links in the map are now drawn as lines with curves at both ends, connecting
    the output pin of the parent node (first element of the pair) and the input pin
    of the child node (second element of the pair).
  prefs: []
  type: TYPE_NORMAL
- en: New nodes are signaled from imnodes *after* the editor has been ended by calling
    `EndNodeEditor()`. Then, two imnodes calls can be used to create or delete links.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether or not a new link was created in the editor in the current frame can
    be requested by calling `IsLinkCreated()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If `IsLinkCreated()` returns true, the user made a new link between two nodes,
    and we can save the new link to the map. How `findNextFreeLinkId()` searches for
    a new link ID depends on the needs of the application. You can check out the example
    code, a simple implementation that reuses IDs from deleted links.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an existing link was disconnected and then dropped, `IsLinkDestroyed()`
    returns true, giving back the ID of the dropped link as an output parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: imnodes has some other functions enabling custom link management, but for our
    node editor, `IsLinkCreated()` and `IsLinkDestroyed()` will be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Duplicating the code for our example node (remember to use unique IDs for every
    attribute) and adding a link between the output pin ID of the first node and the
    input ID of the second node will result in something similar to *Figure 9.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_09_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: Two example nodes connected by a link'
  prefs: []
  type: TYPE_NORMAL
- en: You will have to move the nodes apart since all new nodes are created in the
    same spot by default. Next to setting the initial position when creating a node,
    imnodes allows us to store the positions of all nodes in the current editor session
    by using `SaveCurrentEditorStateToIniString()`. Restoring the positions can be
    achieved later by calling `LoadCurrentEditorStateFromIniString()`.
  prefs: []
  type: TYPE_NORMAL
- en: Having the nodes in the same place when reopening the editor helps to create
    a great user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored how to manage the graphical part of the node editor
    using imnodes, we need to create a class to store state information and the imnodes
    draw calls. These new classes are the building blocks for the finite state machine
    driving the instance behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Creating graph node classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic element of node tree classes is an abstract class called `GraphNodeBase`,
    located in the new folder `graphnodes`. All other node classes will inherit from
    the base class, adding attributes and logic for specific tasks that the node has
    to take care of.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to a *full-featured* behavior tree, our simplified version will
    store the state of nodes in the nodes itself. Maintaining the node state in a
    separate part of the code would make the implementation more complex and harder
    to understand. The only drawback of using an integrated state is to make a copy
    of the entire node tree for every instance, as the node tree itself is used as
    the finite state machine. But node objects are small; adding a few nodes per instance
    creates a negligible overhead in memory space and compute time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive into more details, here is a list of all the node types created
    in the example code for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Root Node**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root node is the starting point of every node tree, created by default.
    It is not possible to remove the root node as it’s the starting point of the entire
    tree. At the start of the execution of the finite state machine, the root node
    is activated first. Also, when no other nodes are active, the root node is triggered
    again to start over. Since there is no need to trigger the root node by some other
    node, the root node has only an output pin but no input pin.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Node**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test node helps develop and debug node trees. Like the root node, only an
    output pin is available, plus a button to activate the output pin.
  prefs: []
  type: TYPE_NORMAL
- en: '**DebugLog Node**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is another node to help build a node tree. Currently, node trees attached
    to an instance cannot be loaded into the editor for a live-debugging session.
    A task for implementing the ability to load an existing node tree into the editor
    window is available in the *Practical sessions* section. To watch specific actions,
    a debug log node can be added, printing a line to the system console when activated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Wait Node**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The wait node was already shown as an example in *Figure 9.2*. The node will
    delay the execution between two other nodes by a configurable time.
  prefs: []
  type: TYPE_NORMAL
- en: '**RandomWait Node**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is like the wait node, but an upper and lower limit can be set to the delay
    time, enabling a bit more random behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**Selector Node**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The selector node also has a fixed delay, and after the delay time is up, a
    random output pin is activated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequence Node**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sequence node activates the output pins one after the other, starting with
    pin number one. As an extra feature, the sequence node will wait for the child
    node on the active output to finish. Waiting for a child is currently only implemented
    for the two wait node types; more types or a cascade with grandchild nodes can
    be added. See the section *Practical sessions* for ideas.
  prefs: []
  type: TYPE_NORMAL
- en: '**Action Node**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added actions in [*Chapter 7*](Chapter_7.xhtml). An action node allows us
    to trigger actions just like we did in [*Chapter 7*](Chapter_7.xhtml) while controlling
    the instance with a keyboard and mouse, enabling the instances to not just walk
    around but jump, roll, punch, or wave, based on the state of the node tree.
  prefs: []
  type: TYPE_NORMAL
- en: '**Event Node**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event node is triggered by an external event sent to the instance, for instance,
    when a collision happens. The event node also has a cooldown timer to ignore the
    same event for a small amount of time, avoiding erratic behavior by doing the
    same action on every update of the tree again if the event keeps being sent to
    the instance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Instance Movement Node**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instance node allows us to control movement state and movement direction,
    instance speed, and instance rotation within the node tree. Using an instance
    node is required to change between the main movement states, like idle, walking,
    and running. In addition, both speed and rotation can be randomized within the
    upper and lower limits to enable a more nondeterministic behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 9.7*, all these nodes are shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_09_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: An overview of all nodes created for the example code'
  prefs: []
  type: TYPE_NORMAL
- en: The number next to the node type is the numerical node ID. In case of errors,
    or when using a DebugLog node, having the node ID at hand may be beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s check the most important parts of the `GraphNodeBase` class.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the base class for graph nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To ensure derived node classes are implementing a minimum set of functionalities,
    the `GraphNodeBase` class has several pure virtual methods declared in the header
    file `GraphNodeBase.h` in the folder `graphnodes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first method, `update()`, is used to alter the internal state of the node
    depending on the time difference between two frames. For instance, all nodes with
    a delay will decrease the internal counter, triggering the output pin once the
    time reaches 0.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `draw()` method, the appearance of the node is set. We created an
    example node starting with the section *Adding a simple node*. The `draw()` call
    contains all commands tailored to the visuals of the specific node type.
  prefs: []
  type: TYPE_NORMAL
- en: When the internal timer of the timing nodes reaches 0, or when a node connected
    to an input pin of the current node has finished its execution, `activate()` will
    be triggered. Here, the main logic of the node’s functionality is set.
  prefs: []
  type: TYPE_NORMAL
- en: When a node tree controlling the behavior of an instance should be removed from
    that instance, we can make sure to stop all nodes by calling `deactivate()`. Not
    stopping the finite state machine for the current instance could lead to interesting
    side effects and unwanted behavior if a node sets values for properties like speed
    or movement state. The parameter `informParentNodes` is used to distinguish between
    an ordered shutdown of a node, i.e., notifying a parent node of type Sequence
    that the child node has finished execution, and a *full stop*, when all further
    actions should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: By using `isActive()`, the controlling code of the finite state machine can
    check if at least one node is still actively doing something, like waiting for
    a timer to reach 0\. As soon as no active node is left, the root node will be
    triggered.
  prefs: []
  type: TYPE_NORMAL
- en: The `clone()` method is needed to create a copy of the current instance of a
    node, containing all settings. Since we are using inheritance, using a copy constructor
    to achieve the same result would be hard due to missing access to `private` members.
    A virtual cloning method makes our lives much easier, resulting in a 1:1 copy.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `exportData()` and `importData()` are used to get and set the current
    state of any node instance with any values set that are worth saving and restoring.
    Internally, the values of a node type are stored in a `std::string` map, avoiding
    more than one data type in the map. Also, using simple strings inside the YAML
    parser removes any conversion when interacting with the raw text data on disk.
    The graph node types know how to encode and decode the data, moving the node-specific
    save and load logic away from the YAML parser.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the pure virtual methods, a small number of non-pure virtual
    functions are declared and defined in the `GraphNodeBase.h` header. These methods
    are only useful for a small subset of node types. So, forcing all node types to
    implement the functionality makes no sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first three methods, `addOutputPin`, `delOutputPin`, and `getNumOutputPins`,
    are used to handle the dynamic number of output pins on the Sequence and Selector
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'All three method names speak for themselves. Only the return value of `delOutputPin()`
    may need an explanation: when removing an output pin from a node, we must check
    if any links were connected to that pin. By returning the pin ID of the just-deleted
    output pin, all connected links can be removed by searching the map of links for
    the specific output node and deleting all affected links from the link map.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other three virtual methods, `childFinishedExecution`, `listensToEvent`,
    and `handleEvent`, are even more special:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The Sequence node type waits for the child node(s) connected to its output pins
    to report that they have finished execution. Both the `Wait` and `RandomWait`
    nodes will inform their parent node about a status change by calling `childFinishedExecution()`.
  prefs: []
  type: TYPE_NORMAL
- en: Only the event node implements the last two methods, `listensToEvent()` and
    `handleEvent()`. Both method names should be self-explanatory. The split into
    two separate methods can be useful if some preparations need to be done between
    checking if a node would handle an event and the real event execution.
  prefs: []
  type: TYPE_NORMAL
- en: As an example for a derived class, we will check some implementation details
    of the wait node.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the wait node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When constructing a new wait node, some defaults are set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We are using a predefined range of attribute IDs here to simplify further coding
    and help debug issues. By multiplying the node ID by `1000`, each node creates
    space for up to 1000 IDs per node, usable for input and output pins, or static
    elements like sliders and buttons. The number of nodes per tree is only limited
    by the storage capacity of an `int`, and we also recycle deleted node IDs – that’s
    more than enough for nodes and pins, even for very large node trees. In addition,
    by simply doing an integer division of any pin ID by 1000, we get the node ID
    containing that specific pin. This is the perfect solution to identify the node
    when sending signals to the pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloning the wait node requires only a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This kind of virtual cloning is widely used and enables us to make an exact
    copy of that wait node, including all node-specific settings.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw()` method code can be skipped since we just use a slider as the control
    element instead of the checkbox. Most of the `draw()` code is identical to the
    code in the sections *Adding a simple node* and *Creating imnodes attributes and
    ImGui elements in a node*, so we can skip the details here.
  prefs: []
  type: TYPE_NORMAL
- en: 'A call to `activate()` starts the wait timer. The `private` Boolean member
    variable `mActive` is set to true, and another `private` Boolean called `mFired`
    is set to false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We use `mFired` only to change the color of the output pin from white to green,
    signaling in the editor window that the wait node has notified any node connected
    to the output pin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `mAcive` is set to true, the `update()` method starts decrementing the
    wait time in `mCurrentTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After the wait time is below 0, trigger signals for both the input and the
    output pin are sent out, the wait time is reset, the node is deactivated, and
    the color of the output pin changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for triggering the input pin was discussed in the section *Creating
    graph node classes*: if the wait node is a child of a sequence node, the parent
    sequence node needs to know that the wait node is no longer active.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, exporting and importing data is done by the two methods, `exportData()`
    and `importData()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Both methods are straightforward. We just store the `float` in a `std::string`
    on exporting and read back the `float` value on importing.
  prefs: []
  type: TYPE_NORMAL
- en: All other specialized nodes are created in a similar way, implementing the required
    methods and enhancing the other virtual methods if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Another well-known coding style from the application is using callbacks to call
    methods in other classes. `GraphNodeBase` uses two callbacks to handle events.
  prefs: []
  type: TYPE_NORMAL
- en: Using callbacks to propagate changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By activating the first callback, a node informs the finite state machine that
    it has finished its execution, and the control should be given to the nodes connected
    to the output pin(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The method that handles this callback is the main part of the state management
    when advancing the status of the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Real behavior changes happen in the method executed by the second callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This callback is used by the instance and action node types, informing, after
    quite a long callback cascade, the renderer class to manipulate a single property
    of the instance owning the node tree that started the callback.
  prefs: []
  type: TYPE_NORMAL
- en: Here is where all the magic happens, letting the instance mode change the movement
    state to walk or run, or start an action like jumping or waving the hand.
  prefs: []
  type: TYPE_NORMAL
- en: We will now take a closer look at more code that will make use of both callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a behavior struct and a storage class for the instances
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To store nodes, links, and the action callback, the new `struct` `BehaviorData`
    will be used, residing in the file `BehaviorData.h` in the `model` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Nodes and links are stored in basic STL containers, and we also store the editor
    setting string in the `struct`, enabling us to save and restore the node positions
    in the node editor window. The `nodeActionCallback` callback is only needed in
    an intermediate fashion to create a link chain between the callbacks in the nodes
    and the class storing the behavior data `struct` itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new class `SingleInstanceBehavior` is used to collect all data and methods
    for the behavior control of a single instance. Here, we create the chain for the
    `nodeActionCallback` callback by setting the callback function of the `BehaviorData`
    `struct` to the local method `nodeActionCallback()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever nodes of types are created that need to change instance data, the
    `nodeActionCallback` of the `BehaviorData` `struct` is set in the new node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `nodeActionCallback()` method, the incoming data is transformed
    to include the instance ID, and another callback function is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The callback chain decouples the internal instance and animation state from
    the state machine controlling it. By decoupling the states, it is possible for
    a node of the instance movement or action type to request a property change for
    the instance where this node resides in one of the behaviors without any knowledge
    of which instance the node is.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining parts of the node actions will be implemented in the section *Extending
    the code to support behavior changes*, completing the chain from a single node
    in a node tree all the way up to the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second callback function, a lambda in the `SingleInstanceBehavior`
    class is used to connect the state update request to a local method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Inside `updateNodeStatus()`, some simple logic changes the active state of the
    nodes by using the `pinId` given as a parameter. Following the rule “output first,
    input second” for the link IDs of imnodes and the integer division of the pin
    ID, we could detect if the signal came from an input or output pin and even find
    the node that called `updateNodeStatus()`.
  prefs: []
  type: TYPE_NORMAL
- en: If `updateNodeStatus()` receives a call with an output pin ID as a parameter,
    all connected child nodes will be activated. If no connected child node is found
    on the output pin, we inform the parent node about a finished execution. This
    special handling is only relevant for a sequence node right now, enabling us to
    skip output pins without a connection.
  prefs: []
  type: TYPE_NORMAL
- en: For an input pin as a parameter, the corresponding node connected to that input
    pin will be informed. This is only needed at the end of the execution of a child
    node of a sequence node right now, but the functionality can be extended for new
    node types.
  prefs: []
  type: TYPE_NORMAL
- en: Without logging calls and comments, the entire `updateNodeStatus()` method is
    just about forty lines short, but it still does the main job of the entire behavior
    tree implementation.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the creation of new nodes, we will use the factory pattern. A node
    factory encloses all the logic needed to create a new node of a specified type
    in one place. Plus, we will enhance the editor with a context menu and the ability
    to switch between different node trees.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a node factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The factory pattern is a nice solution to create objects of classes derived
    from a single base class, keeping all parts of the creation logic in a single
    place.
  prefs: []
  type: TYPE_NORMAL
- en: The factory class `GraphNodeFactory` in the `graphnodes` folder is small and
    simple, similar to other factory classes. At the creation time of a factory object,
    the appropriate `fireNodeOutputCallback` is injected into the constructor, helping
    us to add the right callback destination to all new nodes. The constructor also
    adds a mapping between all node types and the names in the title area of the nodes.
    This name mapping frees us from adding the node name at node creation time; we
    only need the node type and a unique node ID to build a new node.
  prefs: []
  type: TYPE_NORMAL
- en: The `makeNode()` method does all the work by creating a new derived class according
    to the given node type, adding the callback, the mapped node name, and the node
    type of the chosen derived class. Like in all factories, the returned smart pointer
    is of the base class type, allowing us to store all new nodes in STL containers
    of the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the node editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For better node handling, we create a context menu in the editor. The context
    menu can be opened by pressing the right mouse button in the node editor window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, we create two different context menus. Which menu is shown depends
    on if we are hovering over a node or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If no existing node is hovered over when pressing the right mouse button, an
    ImGui pop-up window to add a new node will be created, listing all available node
    types (all but the root node, which only exists once). If a node is hovered over,
    a different ImGui pop-up window is shown, containing actions that could be executed
    on the hovered-over node.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.8* shows both context menus next to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_09_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: The two context menus of the editor'
  prefs: []
  type: TYPE_NORMAL
- en: Which options in the **Change Node** menu are shown depends on the node type.
    For sequence and selector nodes, the number of output pins can be changed dynamically,
    so these two options appear, while for all other nodes, only **Deactivate** and
    **Delete** are shown. The availability to deactivate and delete a node is based
    on the active state of the node. For instance, you cannot delete an active wait
    node until the wait time has expired.
  prefs: []
  type: TYPE_NORMAL
- en: 'To edit an existing node tree into the existing editor window, a new method
    called `loadData()` is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Inside `loadData()`, both a new `SingleInstanceBehavior` and a new `GraphNodeFactory`
    object are created to allow editing the node tree the same way as a fresh node
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The editor also has an `update()` method to behave like a running node tree,
    updating the properties of all nodes depending on their state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we add a flag called `mShowEditor` to control the visibility of the
    editor. When a new node tree is created, or an existing tree is edited, the window
    appears on screen. By clicking on the close button of the editor, or when the
    currently edited node tree is deleted, we hide the editor window.
  prefs: []
  type: TYPE_NORMAL
- en: The last step to complete the implementation of the imnodes-based visual node
    editor is adding all required data to the `YamlParser` class. We do not want to
    start over with an empty editor every time the application is started.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading a node tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating the required templates and overloads for the new behavior data is not
    much different from what we did in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add behavior data to the YAML file, an overload of the output stream operator
    in the file `YamlParser.cpp` is needed. The file can be found in the `tools` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the code can be copied from the previously defined overloads. Having
    a map of strings created by `exportData()` makes it easy to save the state of
    the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: By using `std::optional` in the return value for `exportData()`, we can easily
    skip the entire section in the YAML file if the node has no state to save. Without
    the `optional` keyword, we would need an additional check to determine if the
    node state needs to be saved or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the loading part of the new behavior data, we must add a new `convert`
    template in the file `YamlParserTypes.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the extended version of the `BehaviorData` `struct` since we only
    store the type of a node, and the YAML parser is the wrong place to create new
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Node recreation will happen in the renderer class when loading a saved file,
    like the creation of models, instances, and cameras.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the `convert` code can be taken from previously implemented templates.
    But there is one caveat to the `decode()` method. Instead of the data type of
    the node data, a `std::map` of strings, the `yaml-cpp` library requires us to
    use a vector of maps, containing a single entry for every line in the node data.
    The following code shows how the parsing is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'All vector entries will be added to the `nodeProperties` variable of the intermediate
    `PerNodeImportData` `struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the renderer, we restore the behavior node tree by creating a new `SingleInstanceBehavior`
    instance, a new `BehaviorData` `struct`, and new nodes of the saved type and ID,
    as well as loading back the saved properties. After the links are recreated and
    links and editor settings are imported to the new `BehaviorData`, the node tree
    is in the same state as when it was saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restore order: Behavior before instances'
  prefs: []
  type: TYPE_NORMAL
- en: We must restore the behavior node tree data before restoring the instances,
    since the behavior data will be copied to an instance if we had set a behavior
    before saving the configuration data.
  prefs: []
  type: TYPE_NORMAL
- en: Once the node editor itself is ready, we need to connect the node trees and
    instances. So, let’s add the missing pieces to have the instances come alive.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the code to support behavior changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A few steps are left to fully support computer-controlled behavior in the instances.
    First, we need a copy of a node tree in every instance.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a node tree copy for every instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We cannot just copy the nodes since the original and copy would access the same
    node behind the shared pointer. Reusing the same nodes for multiple instances
    would lead to chaos, since collision events from all instances would be triggered,
    resulting in the same steps executed for all instances sharing the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: To create a copy of the node tree for one of the instances, a custom copy constructor
    for the `SingleInstanceBehavior` class has been created. The copy constructor
    sets the required callbacks, copies the links, and loops through the vector of
    existing nodes to create a clone of every node. For nodes that change instance
    behavior, the additional node action callback will be set.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the callback chain to the renderer must be completed. Right now, only
    the `SingleInstanceBehavior` class objects are informed that a node wants to send
    a property change request to an instance.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting SingleInstanceBehavior and the renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Managing the copies of the instance behaviors will be done by the new `BehaviorManager`
    class, located in the `model` folder. The `BehaviorManager` class maintains a
    mapping between the instance IDs and the copy of the node tree the specific instance
    uses. Also, we have a new callback to keep the renderer in the loop to update
    instance properties of a node of the node tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To update the state of all node trees for the instances, an `update()` method
    exists in the `BehaviorManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We just loop over all instances and call the `update()` method of the `SingleInstanceBehavior`
    object, which updates all nodes of the node tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the renderer, a `private` member named `mBehaviorManager` is added and initialized
    during the `init()` method of the renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A model instance can be added by handing over the instance ID and the node
    tree to the `addInstance()` method of the `BehaviorManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the `addInstance()` method, we copy all nodes in the tree, set the callback
    to the renderer, and add the instance ID to the `SingleInstanceBehavior` object.
  prefs: []
  type: TYPE_NORMAL
- en: Now, any instance or action node inside the node tree of that instance can call
    the function bound to its `nodeActionCallback` member. The request goes up the
    callback chain and ends in the `updateInstanceSettings()` method of the renderer,
    containing all information for the renderer to change the instance property.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we must define all events we want to send to instances, plus where
    to place the code firing these events.
  prefs: []
  type: TYPE_NORMAL
- en: Adding events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To support events, a new `enum` `class` called `nodeEvent` is created in the
    file `Enums.h` located in the `opengl` folder (or the `vulkan` folder for Vulkan):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: To start, we define two values called `instanceToInstanceCollision` and `instanceToEdgeCollision`,
    used to inform an instance that a collision with another instance or a collision
    to the world boundaries has occurred. The first value, `none`, is used to ignore
    events in an event node, and the `NUM` value is needed to loop over all values
    in a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ModelInstanceCamData` `struct`, a mapping called `micNodeUpdateMap`
    is added to translate a `nodeEvent` value to a readable string for the events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The renderer not only adds the strings during the `init()` method but also,
    all calls firing an event are sent from the renderer to the node trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This new `micNodeEventCallbackFunction` callback is bound to the `addBehaviorEvent()`
    method of the renderer, and after chaining the request to existing objects, the
    call ends in the `SingleInstanceBehavior` class. There, all requested events are
    added to a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Events are handled in the `update()` call of the `SingleInstanceBehavior` class,
    calling the `handleEvent()` method of the node. The `handleEvent()` method was
    introduced in the section *Exploring the base class for graph nodes*. It simply
    activates all event nodes in the graph of the specified instance that are listening
    to this event type.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example node tree containing events is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_09_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: An overview of the node tree for the woman’s model'
  prefs: []
  type: TYPE_NORMAL
- en: We have split this image of the node tree into two parts, in *Figures 9.10 and
    9.11*, for better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.10* shows the default path in the node tree, beginning with the root
    node.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_09_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: Default path in the node tree for the woman’s model'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.11* shows the event nodes plus the reaction to events.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_09_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: Events in the node tree for the woman’s model'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 9.12*, the resulting behavior of the tree in *Figure 9.9* for the
    woman’s model and a similar tree for the man’s model is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_09_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: Instances living their virtual life'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the models are walking around, reacting to collisions with other
    instances by rotating a bit. After a collision with the world boundaries, the
    instances turn around. After a random time, the instances stop moving, and a random
    animation clip is played. At this point, the normal execution ends, and the root
    node is triggered again.
  prefs: []
  type: TYPE_NORMAL
- en: Although the node editor looks really cool, and we can add nodes of different
    types, create links, and save and load the state, some limits of the current implementation
    should be noted.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of the current implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our basic implementation lacks some features of other behavior trees.
  prefs: []
  type: TYPE_NORMAL
- en: First, states are stored directly in the nodes. For the use case of the application
    we are creating, storing state data in the nodes is sufficient. But for larger
    trees, separate state storage becomes handy, mostly because we no longer need
    to copy the node data to the instances.
  prefs: []
  type: TYPE_NORMAL
- en: Also, changes to the node tree in the editor session are not automatically copied
    to the instances. You need to select an instance or model and apply the current
    state after every change.
  prefs: []
  type: TYPE_NORMAL
- en: Since only the original node tree data of the editor session is saved to the
    YAML file and not the tree data of the individual instances, restarting the application
    or reloading the configuration applies the editor state to all instances that
    use the specific node tree.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the nodes cannot access data from their instance or other data of the
    virtual world. Reacting to properties like position or rotation, or seeing if
    you are the primary or secondary candidate of a collision to adjust the rotation
    angle, is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: Many of these limits can be removed with some effort and additional coding.
    See the *Practical sessions* section for ideas.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last section of this chapter, we will use the code we have added up
    until now to create a new feature: interaction between instances.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding interaction between instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already have an action called **Interaction**, starting the interaction animation
    clip for the man’s model (and doing nothing visible for the woman’s model, as
    the model does not have an animation clip to show some kind of interaction).
  prefs: []
  type: TYPE_NORMAL
- en: This *interaction* action will be extended to send an event to a nearby instance,
    stating that we want to interact with the instance. A possible reaction to the
    interaction request could be the replay of the waving animation clip for the man’s
    model on the nearby instance, visually confirming that the event has been processed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating interaction control properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The renderer needs some variables and a bit of code to support interaction.
    We add these new variables in the `OGLRenderData` `struct` in the `OGLRenderData.h`
    in the `opengl` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As always, for Vulkan, the variables have to be added to the `VkRenderData`
    `struct` in the `VkRenderData.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: With these new variables, we can switch interaction on and off, as well as set
    a minimum and maximum scan range for other instances and a field-of-view angle
    that the peer instances need to be in. The field of view allows us to select only
    instances we are looking at, and instances that are looking toward us.
  prefs: []
  type: TYPE_NORMAL
- en: In the `std::set` of `int` values, we store all instances in the configured
    range and with the correct view angle. Finally, we store the instance we have
    chosen to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: The interaction candidate selection is handled in `findInteractionInstances()`
    in the renderer. Like collision detection, we drill down from all instances to
    a single instance by narrowing down the selection properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple algorithm is used to find the instance suitable for interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: A `BoundingBox2D` object with the max size is used, and the `query()` method
    of the quadtree is called. Now we have all instances in that area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All instances within the minimum range are sorted out, including ourselves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using the dot product between our own rotation angle and the distance vector
    between us and the remaining instances from step 2, all instances with the incorrect
    facing are removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The distances between us and all instances left in step 3 are sorted in ascending
    order, and the nearest instance is set to be the interaction instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any step returns no valid candidates, the interaction request will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the handling code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thanks to all our preparations, adding a new event is now extremely simple.
    First, we extend the `nodeEvent` `enum` by the new interaction value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we send the interaction event to the central behavior class when the
    interaction key is pressed, and our model plays the interaction animation clip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we create a new event node in the node tree for the man’s model, setting
    the wave action. The new wave action is surrounded by two other actions setting
    the idle state for the instance to have a smooth animation blending, and two wait
    nodes allowing us to finish the animations (we have no feedback yet from the instance
    to the node tree).
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting part of the node tree can be seen in *Figure 9.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_09_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: Reacting to an interaction event by playing the waving animation'
  prefs: []
  type: TYPE_NORMAL
- en: That’s all! Switching to view mode and pressing the *U* key near another man’s
    instance will instruct that instance to stop and wave its hand back to us. After
    the wave animation, the portion of the node tree will end, resuming the normal
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing debug information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with all previous additions, getting a new feature to work without proper
    debug information could be exhausting. For the interaction, we can utilize the
    AABB drawing code to draw a bounding box around the instance candidates, and we
    can use the line mesh to draw a square on the ground, showing the dimensions of
    the minimum and maximum search area.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.14* shows an example of the debug lines, captured with a first-person
    camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/figure_09_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: Interaction between the user and another instance'
  prefs: []
  type: TYPE_NORMAL
- en: With behavior and interaction in place, the virtual world looks and feels more
    alive than ever. The instances are walking around alone, reacting to collisions,
    and doing various actions at random times. And we can even greet some of the instances
    – and they greet us back. It is a lot of fun to just fly around in the virtual
    world, watching the instances.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a simple form of NPCs in our virtual world. We started
    by exploring the basic nature of behavior trees and state machines, and to have
    a tool for creating the state machine controlling the behavior available, we added
    an ImGui-based visual node editor. Then, we added classes for different node types
    and integrated these new classes into the existing code, including a node factory
    and node editor extensions. Finally, we added interactions with other instances
    in the virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will go back to the animation side of things: we will
    add additive blending in the form of morph animations to create facial animations.
    First, we will discuss what morph animations are, and which constraints we must
    take care of. Then, we will import existing morph animations in the glTF models
    and offload the animation work to the GPU, similar to the other animations. As
    the last step, we will combine facial animations and interactions, creating instances
    that can show if they agree or disagree with us.'
  prefs: []
  type: TYPE_NORMAL
- en: Practical sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some additions you could make to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the undo/redo functionality to the node trees.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the existing undo/redo operations, add code to support reverting
    and re-reverting any operations in node trees. It would be helpful to be able
    to undo accidental changes, like deleting a connection or node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an **Apply changes** button for updating the instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a simpler way to update the copies of a changed node tree for all
    instances that are using this tree.
  prefs: []
  type: TYPE_NORMAL
- en: Load node trees from a running instance into the editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a good idea for debugging purposes, but probably also fun to watch what
    happens in real time in the node tree of an instance.
  prefs: []
  type: TYPE_NORMAL
- en: Add a real-time debug visualization of the loaded node tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual debugging could help a lot with understanding what happens in a node
    tree. You could start by highlighting the currently active node in the graph of
    the selected instance (see the previous task) and later also highlight the currently
    active output pin plus the outgoing connections to other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: React to the creation of new links in imnodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of having to create a new node and then place a link, add the context
    menu to create a node when a new link is created but not attached. Connect the
    dangling link directly to the input or output pin of the new node.
  prefs: []
  type: TYPE_NORMAL
- en: Let the sequence node also wait for grandchildren.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could add a cascade of notifications about entire sub-sequences having finished
    execution, not just wait and RandomWait nodes – maybe with an extra checkbox to
    control which child node in the chain is the last one to wait for.
  prefs: []
  type: TYPE_NORMAL
- en: Add condition and loop nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable more control. The condition node needs access to data it should react
    on, either from the instance, the world, or from other nodes. The loop node must
    also wait for the child nodes to finish.
  prefs: []
  type: TYPE_NORMAL
- en: Allow renaming and copy/paste for entire node trees, or between editor windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend the current implementation by adding the ability to rename existing node
    trees. Creating a copy of an entire node tree may become handy to duplicate and
    adjust existing behavior, and a copy/paste operation of nodes or entire selections
    between two editor sessions would be a blast.
  prefs: []
  type: TYPE_NORMAL
- en: Show more than one tree node in the editor window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either by using dockable ImGui windows or just opening more editor windows,
    let the user work on multiple node trees at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Caveat: If more than one window is shown, the internal ImGui IDs must be unique
    among all UI elements in the windows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enhanced difficulty: Integrate a full C++ behavior tree library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of this small and hand-crafted node tree version, add a full-featured
    behavior tree from a third-party library and add imnodes support for the tree
    management.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Introduction to behavior trees: [https://robohub.org/introduction-to-behavior-trees/](https://robohub.org/introduction-to-behavior-trees/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Behavior Trees: Breaking the Cycle of Misuse: [https://takinginitiative.net/wp-content/uploads/2020/01/behaviortrees_breaking-the-cycle-of-misuse.pdf](https://takinginitiative.net/wp-content/uploads/2020/01/behaviortrees_breaking-the-cycle-of-misuse.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A simple C++ behavior tree example: [https://lisyarus.github.io/blog/posts/behavior-trees.html](https://lisyarus.github.io/blog/posts/behavior-trees.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Node Graph Editors with ImGui: [https://github.com/ocornut/imgui/issues/306](https://github.com/ocornut/imgui/issues/306)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'imnodes extension for ImGui: [https://github.com/Nelarius/imnodes](https://github.com/Nelarius/imnodes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/QR_code_Discord.png)'
  prefs: []
  type: TYPE_IMG
