- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Adding Behavior and Interaction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加行为和交互
- en: Welcome to *Chapter 9*! In the previous chapter, we took a deeper look into
    collision detection. After a discussion about the complexity of finding colliding
    instances in the virtual world, we explored ways to speed up the collision search
    by adding world partitioning and model simplifications. Then, we implemented a
    quadtree to split up the world into smaller areas, and we added bounding boxes
    and bounding spheres for the instances. Finally, we used both the quadtree and
    the instance boundaries to detect a collision between instances.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到**第9章**！在前一章中，我们深入探讨了碰撞检测。在讨论了在虚拟世界中找到碰撞实例的复杂性之后，我们探索了通过添加世界分区和模型简化来加速碰撞搜索的方法。然后，我们实现了一个四叉树来将世界分割成更小的区域，并为实例添加了边界框和边界球。最后，我们使用四叉树和实例边界来检测实例之间的碰撞。
- en: In this chapter, we will add some sort of “real-life” behavior to the instances,
    giving them the ability to walk around the virtual world by themselves and react
    to events like the collisions we added in the previous chapter. First, we will
    take a brief look at behavior trees and state machines and how both works. Then,
    we will add a visual editor to visually represent the state machines of the instances
    themselves. At the end of the chapter, we will extend the code to execute the
    behavior changes from the created node trees, and we will add interaction as an
    additional form of behavior.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为实例添加一些“现实生活”的行为，使它们能够自己绕着虚拟世界行走，并对之前章节中添加的碰撞等事件做出反应。首先，我们将简要了解行为树和状态机以及它们是如何工作的。然后，我们将添加一个可视化编辑器来直观地表示实例自身的状态机。本章结束时，我们将扩展代码以执行从创建的节点树中产生的行为变化，并将交互添加为行为的一种附加形式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Structures to control instance behavior
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制实例行为的结构
- en: Adding a visual node editor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加可视化节点编辑器
- en: Extending the code to support behavior changes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展代码以支持行为变化
- en: Adding interaction between instances
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实例之间添加交互
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example code can be found in the folder `chapter09`, in the subfolder `01_opengl_behavior`
    for OpenGL and `02_vulkan_behavior` for Vulkan.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码可以在文件夹`chapter09`中找到，对于OpenGL在子文件夹`01_opengl_behavior`中，对于Vulkan在子文件夹`02_vulkan_behavior`中。
- en: Structures to control instance behavior
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制实例行为的结构
- en: In the early days of computer games, the behavior of enemies and other **non-player
    characters** (**NPCs**) was rather simple. Based on only the game state or a few
    properties, like *The player has eaten a large dot, I must stay away from them!*
    (Pac-Man) or *I saw the player, so I will attack them!* (many first-person shooters),
    the computer counterparts were acting only with a small set of rules.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机游戏初期，敌人和其他**非玩家角色**（**NPC**）的行为相当简单。基于仅游戏状态或几个属性，例如“玩家吃了一个大点，我必须远离他们！”（吃豆人）或“我看到玩家，所以我将攻击他们！”（许多第一人称射击游戏），计算机对手仅通过一小套规则行事。
- en: Later, control structures like “plain” state machines, hierarchical state machines,
    and behavior trees changed the **artificial intelligence** (**AI**) in games a
    lot, since it became easy to model complex tasks for enemies and NPCs. Now, it
    is possible to not only create more alternatives for behavior choices but also
    let computer-controlled world inhabitants act more like intelligent beings. Spotting
    the player may lead to a handful of different outcomes from NPCs, based on world
    factors, their own properties, and a bit of randomness.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，像“普通”状态机、分层状态机和行为树这样的控制结构在很大程度上改变了游戏中的**人工智能**（**AI**）。因为现在可以轻松地为敌人和NPC建模复杂任务。现在，不仅可以为行为选择创建更多替代方案，还可以让由计算机控制的世界居民表现得更加像智能生物。根据世界因素、它们自身的属性以及一点随机性，发现玩家可能导致NPC出现多种不同的结果。
- en: A behavior tree simplifies creating behaviors for NPCs and helps reasoning about
    the states the NPC will be in at any given time. Still, a behavior tree is only
    an enhanced finite state machine with nodes and links between nodes. The current
    state of the tree is memorized by the behavior subsystem, and based on configured
    factors in the nodes, state changes to subsequent nodes in the tree are executed.
    Without huge complexity, behavior trees are easy to implement but still powerful
    in games.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 行为树简化了NPC行为的创建，并有助于推理NPC在任何给定时间可能处于的状态。然而，行为树只是一个具有节点和节点之间链接的增强型有限状态机。行为子系统会记住树当前的状态，并根据节点中配置的因素，执行状态到树中后续节点的变化。行为树没有巨大的复杂性，易于实现，但在游戏中仍然非常强大。
- en: 'A common way to create a behavior tree is by using specialized nodes, for instance:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建行为树的一种常见方法是使用专用节点，例如：
- en: Selectors, choosing one among a set of options
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择器，从一组选项中选择一个
- en: Sequences, running tasks in a specific order
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列，按特定顺序执行任务
- en: Conditions, using the outcome of previous nodes to choose the next node
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件，使用先前节点的结果来选择下一个节点
- en: Loops, which repeat a part of the tree several times until a condition is met
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环，重复树的一部分，直到满足条件
- en: Actions, which affect the character state or perform an action, like attacking
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作，影响角色状态或执行动作，如攻击
- en: World perception, changing behavior based on events or world properties
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 世界感知，根据事件或世界属性改变行为
- en: Using special nodes helps a lot in building a flexible behavior tree. The enemy
    or NPC can gather information about the world and other objects in it and choose
    a different path on the next tree execution if the world around it changes, leading
    to a more reactive, believable, and less robotic behavior by not doing the same
    moves and actions repeatedly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特殊节点在构建灵活的行为树中非常有帮助。敌人或NPC可以收集关于世界及其中的其他对象的信息，并在周围环境发生变化时，在下一次树执行中选择不同的路径，从而通过不重复相同的动作和行动，实现更反应灵敏、更可信、更少机械的行为。
- en: '*Figure 9.1* shows a simple idea for an NPC behavior:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.1*展示了NPC行为的简单想法：'
- en: '![](img/figure_09_01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_09_01.png)'
- en: 'Figure 9.1: A simple behavior plan'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：简单的行为计划
- en: Even though the plan looks straightforward, it encapsulates sophisticated behavior.
    Considering the enemy’s distance and health status while scanning the plan for
    the desired behavior should result in fairly impressive NPC actions. By switching,
    with random variations, between taking cover and a range attack, directly attacking
    approaching enemies, or just trying to hide or run away as the last option, watching
    a group of these NPCs fighting incoming enemies would be entertaining.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管计划看起来很简单，但它封装了复杂的行为。在扫描计划以寻找所需行为时，考虑到敌人的距离和健康状况，应该会产生相当令人印象深刻的NPC行动。通过随机变化，在躲避和远程攻击之间切换，直接攻击接近的敌人，或者作为最后的手段尝试隐藏或逃跑，观看这些NPC群体对抗来犯敌人将会很有趣。
- en: We will add a simple state machine to control the behavior of the instances
    in this chapter. Also, to simplify creating and controlling the behavior with
    the state machine, we will add a tool to create nodes and links. So, let’s go
    on a short detour and add a visual node editor to the application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为本章中的实例添加一个简单的状态机来控制行为。为了简化使用状态机创建和控制行为，我们还将添加一个创建节点和链接的工具。因此，让我们短暂偏离一下，为应用程序添加一个可视化的节点编辑器。
- en: Adding a visual node editor
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加可视化节点编辑器
- en: Like in the previous chapters, we will use an open-source tool to build our
    visual node editor instead of building our own solutions by hand. There are several
    ImGui-based node editors available. You can find a curated list in the *Additional
    resources* section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，我们将使用开源工具来构建我们的可视化节点编辑器，而不是手动构建自己的解决方案。有几个基于ImGui的节点编辑器可用。你可以在*附加资源*部分找到精选列表。
- en: 'In this chapter, we will use the extension called **imnodes** by Johann “Nelarius”
    Muszynski. The source code for imnodes is available on GitHub:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Johann “Nelarius” Muszynski扩展的**imnodes**。imnodes的源代码可在GitHub上找到：
- en: '[https://github.com/Nelarius/imnodes](https://github.com/Nelarius/imnodes)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Nelarius/imnodes](https://github.com/Nelarius/imnodes)'
- en: Like in the previous chapters, we will use CMake to fetch imnodes for us.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，我们将使用CMake为我们获取imnodes。
- en: Integrating imnodes by using CMake
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过使用CMake集成imnodes
- en: 'To let CMake manage imnodes as a dependency, add a new `FetchContent` block
    to the file `CMakeLists.txt` in the project root between the `FetchContent` block
    for `stbi` and the `WIN32`-only area:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让CMake将imnodes作为一个依赖项管理，在项目根目录中的`CMakeLists.txt`文件中添加一个新的`FetchContent`块，位于`stbi`的`FetchContent`块和`WIN32`-only区域之间：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will use the Git tag `v0.5` here to avoid problems introduced by new commits
    to the `master` branch, resulting in not finding the ImGui source code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将使用Git标签`v0.5`，以避免`master`分支上的新提交引入的问题，导致找不到ImGui源代码。
- en: 'Next, we make the imnodes code available and let CMake populate the variable
    for the source folder:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使imnodes代码可用，并让CMake填充源文件夹变量：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we append the source directory variable for imnodes to the list of already
    existing external source files and include directories:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将imnodes的源目录变量追加到已存在的外部源文件和包含目录列表中：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As a last step, we add a compiler definition to the existing `add_definitions`
    line:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们在现有的`add_definitions`行中添加一个编译器定义：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By setting `IMGUI_DEFINE_MATH_OPERATORS`, ImGui exposes some of the internal
    mathematical operations to external modules like imnodes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`IMGUI_DEFINE_MATH_OPERATORS`，ImGui将一些内部数学运算暴露给外部模块，如imnodes。
- en: After running CMake, which most IDEs will perform automatically after saving
    the `CMakeLists.txt` file, imnodes is available and can be included in the user
    interface. Now, let us learn how to work with imnodes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行CMake之后，大多数IDE在保存`CMakeLists.txt`文件后都会自动执行此操作，imnodes就可用，并可以包含在用户界面中。现在，让我们学习如何使用imnodes。
- en: Using imnodes to create UI elements
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用imnodes创建UI元素
- en: Since imnodes is based on ImGui, imnodes function calls are like ImGui calls,
    with imnodes acting as a container to enclose the UI elements in a graphical node
    representation. A graphical node, like the wait node shown in *Figure 9.2*, can
    be added and removed dynamically to a node editor window, and links between input
    and output pins can be created.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于imnodes基于ImGui，imnodes函数调用类似于ImGui调用，其中imnodes充当一个容器，将UI元素封装在图形节点表示中。如图*图9.2*中所示的图形节点，可以动态地添加和删除到节点编辑器窗口中，并且可以在输入和输出引脚之间创建链接。
- en: '![](img/figure_09_02.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/figure_09_02.png)'
- en: 'Figure 9.2: The elements of a simple imnodes wait node'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：简单imnodes等待节点的元素
- en: Elements of a node are the title bar and an arbitrary number of input pins,
    output pins, and static elements. In the title bar, a descriptive name to identify
    the node type is shown, like the word **Wait** in *Figure 9.2*. The input pin
    of the wait node is used to connect parent node(s) to this specific node, and
    on the output pin, one or more child nodes can be connected. All user controls
    are built using static elements, such as the slider for the time to wait, or the
    text field showing the time running toward 0 if the wait node was activated.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的元素包括标题栏和任意数量的输入引脚、输出引脚和静态元素。在标题栏中，显示一个描述性名称以识别节点类型，如*图9.2*中的单词**等待**。等待节点的输入引脚用于将父节点连接到这个特定的节点，而在输出引脚上，可以连接一个或多个子节点。所有用户控件都是使用静态元素构建的，例如等待时间的滑块，或者如果等待节点被激活，显示时间向0运行的文本字段。
- en: But imnodes only maintains the nodes and links. We must implement the logic
    behind the node editor according to our needs. To get a better impression of how
    much – or how little – effort is needed to create such a node editor, we will
    walk through the steps needed to draw a node like in *Figure 9.2* to the screen.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但是imnodes只维护节点和链接。我们必须根据我们的需求实现节点编辑器背后的逻辑。为了更好地了解创建这样一个节点编辑器需要多少——或者多少的——努力，我们将逐步展示如何在屏幕上绘制类似于*图9.2*中的节点。
- en: Creating the imnodes context
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建imnodes上下文
- en: 'Like ImGui, imnodes needs a basic set of data about the current session, that
    is, the context. The imnodes context must be created after ImGui’s context, as
    imnodes relies on data from ImGui. So, the `init()` method of the `UserInterface`
    class will be extended by the `CreateContext()` call of imnodes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与ImGui一样，imnodes需要一个关于当前会话的基本数据集，即上下文。imnodes上下文必须在ImGui上下文之后创建，因为imnodes依赖于ImGui的数据。因此，`UserInterface`类的`init()`方法将通过imnodes的`CreateContext()`调用进行扩展：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'imnodes’ context needs to be destroyed before ImGui’s context. To do that,
    we call `DestroyContext()` of imnodes before ImGui’s `DestroyContext()` in the
    `cleanup()` method of the `UserInterface` class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: imnodes的上下文需要在ImGui的上下文之前被销毁。为此，我们在`UserInterface`类的`cleanup()`方法中调用imnodes的`DestroyContext()`，在ImGui的`DestroyContext()`之前：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the context ready, we can start to use the function calls to imnodes. Similar
    to the `ImGui` namespace, the `ImNodes` namespace will be used as a prefix.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文准备就绪后，我们可以开始使用对imnodes的函数调用。类似于`ImGui`命名空间，`ImNodes`命名空间将用作前缀。
- en: Setting default values for imnodes
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为imnodes设置默认值
- en: 'Choosing a global color style can be done exactly like in ImGui. For instance,
    to set the “light” color style for ImGui and imnodes, use the following lines
    in the `init()` method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 选择全局颜色样式可以像在ImGui中一样进行。例如，要在`init()`方法中设置ImGui和imnodes的“light”颜色样式，使用以下行：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another call in the `init()` method of the `UserInterface` class can be made
    to set the modifier key used to detach links from a node. By default, imnodes
    uses the `Alt` key to detach a link. With the following two lines, we can set
    the key binding to use the `Control` key instead:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`UserInterface`类的`init()`方法中再次调用，以设置用于从节点断开链接的修改键。默认情况下，imnodes使用`Alt`键来断开链接。通过以下两行，我们可以将键绑定设置为使用`Control`键：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After we change the defaults (or not), the node editor window itself will be
    created.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更改默认值（或未更改）之后，节点编辑器窗口本身将被创建。
- en: Creating the node editor
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建节点编辑器
- en: 'Like any other ImGui element, the node editor must be created inside an ImGui
    window. We call `BeginNodeEditor()` right after the start of a new ImGui window:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他ImGui元素一样，节点编辑器必须在ImGui窗口内部创建。我们会在新的ImGui窗口开始后立即调用`BeginNodeEditor()`：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now you should see a window with a visible grid – the node editor. All imnodes
    and ImGui calls are available in this context, although it is not possible to
    draw ImGui elements directly onto the node editor as they will overlay the node
    editor elements.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该会看到一个带有可见网格的窗口——节点编辑器。所有imnodes和ImGui调用都在此上下文中可用，尽管无法直接在节点编辑器上绘制ImGui元素，因为它们将覆盖节点编辑器元素。
- en: 'To end the node editor and the ImGui window, we call `EndNodeEditor()` just
    before ending the ImGui window. If we want to have a transparent mini map of the
    entire node editor window shown on the top left of the window, we can call `MiniMap()`
    before ending the editor:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要结束节点编辑器和ImGui窗口，我们在结束ImGui窗口之前调用`EndNodeEditor()`。如果我们想在窗口的左上角显示整个节点编辑器窗口的透明迷你图，我们可以在结束编辑器之前调用`MiniMap()`：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this point, the node editor window will look like *Figure 9.3*:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，节点编辑器窗口将看起来像*图9.3*：
- en: '![](img/figure_09_03.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_09_03.png)'
- en: 'Figure 9.3: A fresh node editor window'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：一个全新的节点编辑器窗口
- en: Inside the node editor window, new nodes can be created. For a small example,
    we will hardcode all properties into the node. In the section *Extending the node
    editor*, a context menu will be added, allowing us to create and delete nodes
    at runtime.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点编辑器窗口内部，可以创建新的节点。作为一个简单的例子，我们将所有属性硬编码到节点中。在*扩展节点编辑器*部分，将添加一个上下文菜单，允许我们在运行时创建和删除节点。
- en: Adding a simple node
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个简单的节点
- en: 'A new node can be started by calling `BeginNode()`, using an `int` value as
    the unique identification for the node:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用`BeginNode()`来开始一个新的节点，使用一个`int`值作为节点的唯一标识：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Like in ImGui itself, all imnodes UI elements must have a unique ID set to be
    distinguishable by ImGui. Internally, imnodes uses the `ImGui::PushID()` call
    to set the ID for the group containing the node data. We only need to take care
    that all elements in the node editor have unique identifications set.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在ImGui本身中一样，所有imnodes UI元素都必须设置一个唯一的ID，以便ImGui可以区分。内部，imnodes使用`ImGui::PushID()`调用为包含节点数据的组设置ID。我们只需要确保节点编辑器中的所有元素都设置了唯一的标识。
- en: Inside the node, we can use all ImGui elements to create control elements. Some
    ImGui elements may behave unexpectedly. For instance, an `ImGui::Separator()`
    call draws a line up to the right end of the node editor. But the usual elements,
    like text, buttons, or sliders, are working as expected. Calling `BeginDisable()`
    and `EndDisable()` also works normally, allowing us to make parts of the node
    unavailable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点内部，我们可以使用所有ImGui元素来创建控制元素。一些ImGui元素可能会出现意外的行为。例如，`ImGui::Separator()`调用会在节点编辑器的右端绘制一条线。但通常的元素，如文本、按钮或滑块，都按预期工作。调用`BeginDisable()`和`EndDisable()`也正常工作，允许我们使节点的一部分不可用。
- en: Be careful when disabling ImGui elements in a node
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点中禁用ImGui元素时要小心
- en: While it may seem tempting to completely remove unneeded ImGui elements from
    the node by enclosing them in `if` statements, be aware that imnodes calculates
    the position of input and output pins from the IDs given to the attributes. If
    you want to remove attributes or ImGui elements, make sure to keep the same IDs
    for the attributes and elements remaining visible, or else the links will be attached
    at the wrong places.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能很有诱惑力，但通过在 `if` 语句中包围它们来完全删除节点中不需要的 ImGui 元素，但请注意，imnodes 从分配给属性的 ID 计算输入和输出引脚的位置。如果您想删除属性或
    ImGui 元素，请确保保留属性和剩余可见元素相同的 ID，否则链接将连接到错误的位置。
- en: '*Figure 9.4* shows the result of the previously found lines of code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9.4* 显示了之前找到的代码行的结果：'
- en: '![](img/figure_09_04.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/figure_09_04.png)'
- en: 'Figure 9.4: The sample node'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：示例节点
- en: Besides being movable by holding the left mouse button, our new node is not
    useful. So, let us add some elements to the node, called “attributes” in imnodes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以通过按住左鼠标按钮移动之外，我们的新节点并没有什么用处。因此，让我们向节点添加一些元素，在 imnodes 中称为“属性”。
- en: Creating imnodes attributes and ImGui elements in a node
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在节点中创建 imnodes 属性和 ImGui 元素
- en: All attributes for a node must be defined between `BeginNode()` and `EndNode()`.
    Make sure to skip the `ImGui::Text()` line from the section *Adding a simple node*
    as it will destroy the layout of the node.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的所有属性必须在 `BeginNode()` 和 `EndNode()` 之间定义。确保跳过 *添加简单节点* 部分的 `ImGui::Text()`
    行，因为它将破坏节点的布局。
- en: 'The first imnodes attribute we add is a node title, by using `BeginNodeTitleBar()`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加的第一个 imnodes 属性是一个节点标题，通过使用 `BeginNodeTitleBar()`：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The title is shown in a separate area at the top of the node and shows if it
    is unselected, hovered over, or selected.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的标题显示在节点顶部的独立区域，并显示它是否未选中、悬停或选中。
- en: 'Next, we create an input pin by calling `BeginInputAttribute()`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用 `BeginInputAttribute()` 创建一个输入引脚：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: An input node definition creates a “magnetic” dot on the left side of the node,
    allowing us later to connect links. A node can have from zero to virtually unlimited
    input pins, but most probably, only a few pins will be used.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输入节点定义在节点的左侧创建一个“磁性”点，允许我们稍后连接链接。一个节点可以有从零到几乎无限的输入引脚，但最可能的情况是，只有少数引脚会被使用。
- en: 'After the input pin, we use `BeginStaticAttribute()` to create a static attribute:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入引脚之后，我们使用 `BeginStaticAttribute()` 创建一个静态属性：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Static attributes have no input or output connectors on the sides of the node.
    You can use a static attribute just like every other control element in an ImGui
    window.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 静态属性在节点的两侧没有输入或输出连接器。您可以使用静态属性就像在 ImGui 窗口中使用其他任何控件元素一样。
- en: 'Finally, we add an output pin with `BeginOutputAttribute()`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `BeginOutputAttribute()` 添加一个输出引脚：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Like input pins, output pins create a connector to dock links. But for output
    pins, this connector is on the right side of the node.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与输入引脚一样，输出引脚创建一个连接器以停靠链接。但对于输出引脚，这个连接器位于节点的右侧。
- en: 'In *Figure 9.5*, the resulting node created by the code lines in this section
    is shown:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 9.5* 中，显示了本节中代码行创建的结果节点：
- en: '![](img/figure_09_05.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/figure_09_05.png)'
- en: 'Figure 9.5: The updated example node'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5：更新的示例节点
- en: The updated node already looks great. We have a title, input and output pins,
    and a checkbox controlled by a stateful variable – all in just about twenty lines
    of code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的节点看起来已经很好了。我们有一个标题、输入和输出引脚，以及由状态变量控制的复选框——所有这些都在大约二十行代码中完成。
- en: Connecting nodes with links is also simple, as we will see now.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用链接连接节点也很简单，正如我们现在将看到的。
- en: Maintaining links between nodes
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 维护节点之间的链接
- en: 'Links in imnodes have three properties: a unique link ID, a start pin ID, and
    an end pin ID. The unique link ID is needed to identify and draw the link itself,
    and the pin IDs are taken from the output pin of the parent (or source) node respective
    to the input pin of the child (or destination) node.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: imnodes 中的链接有三个属性：一个唯一的链接 ID、一个起始引脚 ID 和一个结束引脚 ID。唯一的链接 ID 用于识别和绘制链接本身，而引脚 ID
    来自父节点（或源节点）的输出引脚相对于子节点（或目标节点）的输入引脚。
- en: 'By combining these three IDs, links in imnodes are best managed as pairs of
    pin IDs in a map of link IDs:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合这三个 ID，imnodes 中的链接最好作为链接 ID 映射中引脚 ID 的对来管理：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The inner `std::pair` stores the IDs of the start pin (output) and the end pin
    (input) of a link, in that order. With the outer `std::map`, we create a connection
    between the link ID and the pair of pin IDs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 内部的 `std::pair` 存储了链接的起始引脚（输出）和结束引脚（输入）的 ID，顺序如下。通过外部的 `std::map`，我们创建了一个连接，将链接
    ID 与引脚 ID 对连接起来。
- en: Output first, input second
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先输出，然后输入
- en: It is noteworthy to say that imnodes strictly follows this order. The first
    reported pin is always the output pin of the parent node, and the second pin is
    the input pin of the child node. Following this rule makes it easy to use nodes
    and links to create a finite state machine, maintaining the state of the node
    tree with a bunch of simple rules.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，imnodes 严格遵循此顺序。第一个报告的引脚始终是父节点的输出引脚，第二个引脚是子节点的输入引脚。遵循此规则使得使用节点和链接创建有限状态机变得容易，并通过一些简单的规则维护节点树的状态。
- en: 'Drawing the existing nodes can be done by calling `Link()` with exactly the
    three link properties mentioned earlier in the section:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `Link()` 并使用本节前面提到的确切三个链接属性来绘制现有节点：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All links in the map are now drawn as lines with curves at both ends, connecting
    the output pin of the parent node (first element of the pair) and the input pin
    of the child node (second element of the pair).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在映射中的所有链接都绘制为两端带有曲线的线条，连接父节点（对的第一元素）的输出引脚和子节点（对的第二元素）的输入引脚。
- en: New nodes are signaled from imnodes *after* the editor has been ended by calling
    `EndNodeEditor()`. Then, two imnodes calls can be used to create or delete links.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 新节点在通过调用 `EndNodeEditor()` 结束编辑器后由 imnodes 通知。然后，可以使用两个 imnodes 调用来创建或删除链接。
- en: 'Whether or not a new link was created in the editor in the current frame can
    be requested by calling `IsLinkCreated()`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用 `IsLinkCreated()` 来请求当前帧中编辑器是否创建了新的链接：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If `IsLinkCreated()` returns true, the user made a new link between two nodes,
    and we can save the new link to the map. How `findNextFreeLinkId()` searches for
    a new link ID depends on the needs of the application. You can check out the example
    code, a simple implementation that reuses IDs from deleted links.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `IsLinkCreated()` 返回 true，则用户在两个节点之间创建了一个新的链接，并且我们可以将新的链接保存到映射中。`findNextFreeLinkId()`
    如何搜索新的链接 ID 取决于应用程序的需求。您可以查看示例代码，这是一个简单的实现，它重新使用已删除链接的 ID。
- en: 'If an existing link was disconnected and then dropped, `IsLinkDestroyed()`
    returns true, giving back the ID of the dropped link as an output parameter:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个现有的链接被断开然后删除，`IsLinkDestroyed()` 返回 true，并将删除的链接的 ID 作为输出参数返回：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: imnodes has some other functions enabling custom link management, but for our
    node editor, `IsLinkCreated()` and `IsLinkDestroyed()` will be sufficient.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: imnodes 有一些其他函数可以启用自定义链接管理，但对我们节点的编辑器来说，`IsLinkCreated()` 和 `IsLinkDestroyed()`
    将足够使用。
- en: 'Duplicating the code for our example node (remember to use unique IDs for every
    attribute) and adding a link between the output pin ID of the first node and the
    input ID of the second node will result in something similar to *Figure 9.6*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 复制我们示例节点的代码（请记住为每个属性使用唯一的 ID），并在第一个节点的输出引脚 ID 和第二个节点的输入 ID 之间添加一个链接，将得到类似于 *图
    9.6* 的结果：
- en: '![](img/figure_09_06.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_09_06.png)'
- en: 'Figure 9.6: Two example nodes connected by a link'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：通过链接连接的两个示例节点
- en: You will have to move the nodes apart since all new nodes are created in the
    same spot by default. Next to setting the initial position when creating a node,
    imnodes allows us to store the positions of all nodes in the current editor session
    by using `SaveCurrentEditorStateToIniString()`. Restoring the positions can be
    achieved later by calling `LoadCurrentEditorStateFromIniString()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有新节点默认情况下都创建在相同的位置，因此您必须将节点分开。在创建节点时设置初始位置旁边，imnodes 允许我们使用 `SaveCurrentEditorStateToIniString()`
    将当前编辑器会话中所有节点的位置存储起来。可以通过调用 `LoadCurrentEditorStateFromIniString()` 在以后恢复位置。
- en: Having the nodes in the same place when reopening the editor helps to create
    a great user experience.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新打开编辑器时，将节点放在相同的位置有助于创建出色的用户体验。
- en: Now that we have explored how to manage the graphical part of the node editor
    using imnodes, we need to create a class to store state information and the imnodes
    draw calls. These new classes are the building blocks for the finite state machine
    driving the instance behavior.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何使用 imnodes 管理节点编辑器的图形部分，我们需要创建一个类来存储状态信息和 imnodes 绘图调用。这些新类是驱动实例行为的有限状态机的构建块。
- en: Creating graph node classes
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建图节点类
- en: The basic element of node tree classes is an abstract class called `GraphNodeBase`,
    located in the new folder `graphnodes`. All other node classes will inherit from
    the base class, adding attributes and logic for specific tasks that the node has
    to take care of.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 节点树类的基本元素是一个名为 `GraphNodeBase` 的抽象类，位于新的文件夹 `graphnodes` 中。所有其他节点类都将从基类继承，为节点必须处理的特定任务添加属性和逻辑。
- en: In contrast to a *full-featured* behavior tree, our simplified version will
    store the state of nodes in the nodes itself. Maintaining the node state in a
    separate part of the code would make the implementation more complex and harder
    to understand. The only drawback of using an integrated state is to make a copy
    of the entire node tree for every instance, as the node tree itself is used as
    the finite state machine. But node objects are small; adding a few nodes per instance
    creates a negligible overhead in memory space and compute time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与功能齐全的行为树相比，我们的简化版本将在节点本身中存储节点状态。在代码的单独部分维护节点状态会使实现更加复杂且难以理解。使用集成状态的唯一缺点是，对于每个实例，都需要复制整个节点树，因为节点树本身用作有限状态机。但节点对象很小；每个实例添加几个节点在内存空间和计算时间上只会产生微不足道的开销。
- en: 'Before we dive into more details, here is a list of all the node types created
    in the example code for this chapter:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入更多细节之前，这里是一个列表，列出了本章示例代码中创建的所有节点类型：
- en: '**Root Node**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根节点**'
- en: The root node is the starting point of every node tree, created by default.
    It is not possible to remove the root node as it’s the starting point of the entire
    tree. At the start of the execution of the finite state machine, the root node
    is activated first. Also, when no other nodes are active, the root node is triggered
    again to start over. Since there is no need to trigger the root node by some other
    node, the root node has only an output pin but no input pin.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点是每个节点树的起点，默认创建。由于它是整个树的起点，因此无法删除根节点。在有限状态机的执行开始时，首先激活根节点。此外，当没有其他节点处于活动状态时，根节点会再次触发以重新开始。由于不需要其他节点触发根节点，因此根节点只有一个输出引脚而没有输入引脚。
- en: '**Test Node**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试节点**'
- en: The test node helps develop and debug node trees. Like the root node, only an
    output pin is available, plus a button to activate the output pin.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 测试节点有助于开发和调试节点树。与根节点一样，只有一个输出引脚，还有一个按钮来激活输出引脚。
- en: '**DebugLog Node**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试日志节点**'
- en: This is another node to help build a node tree. Currently, node trees attached
    to an instance cannot be loaded into the editor for a live-debugging session.
    A task for implementing the ability to load an existing node tree into the editor
    window is available in the *Practical sessions* section. To watch specific actions,
    a debug log node can be added, printing a line to the system console when activated.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个帮助构建节点树的另一个节点。目前，附加到实例的节点树无法加载到编辑器中进行实时调试会话。在“实践会话”部分中有一个任务，是实现将现有节点树加载到编辑器窗口的能力。要观察特定操作，可以添加一个调试日志节点，当激活时，会在系统控制台打印一行。
- en: '**Wait Node**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等待节点**'
- en: The wait node was already shown as an example in *Figure 9.2*. The node will
    delay the execution between two other nodes by a configurable time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 等待节点已在*图9.2*中作为示例展示。该节点将通过可配置的时间延迟在两个其他节点之间延迟执行。
- en: '**RandomWait Node**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机等待节点**'
- en: This is like the wait node, but an upper and lower limit can be set to the delay
    time, enabling a bit more random behavior.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于等待节点，但可以设置延迟时间的上限和下限，从而实现更随机的行为。
- en: '**Selector Node**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择节点**'
- en: The selector node also has a fixed delay, and after the delay time is up, a
    random output pin is activated.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 选择节点也有一个固定的延迟，延迟时间过后，会激活一个随机的输出引脚。
- en: '**Sequence Node**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序节点**'
- en: A sequence node activates the output pins one after the other, starting with
    pin number one. As an extra feature, the sequence node will wait for the child
    node on the active output to finish. Waiting for a child is currently only implemented
    for the two wait node types; more types or a cascade with grandchild nodes can
    be added. See the section *Practical sessions* for ideas.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序节点依次激活输出引脚，从引脚编号一开始。作为一个额外功能，顺序节点将等待活动输出上的子节点完成。目前，等待子节点仅实现了两种等待节点类型；可以添加更多类型或与孙节点一起级联。有关想法，请参阅“实践会话”部分。
- en: '**Action Node**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作节点**'
- en: We added actions in [*Chapter 7*](Chapter_7.xhtml). An action node allows us
    to trigger actions just like we did in [*Chapter 7*](Chapter_7.xhtml) while controlling
    the instance with a keyboard and mouse, enabling the instances to not just walk
    around but jump, roll, punch, or wave, based on the state of the node tree.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第7章*](Chapter_7.xhtml)中添加了动作。动作节点允许我们在使用键盘和鼠标控制实例的同时触发动作，就像我们在[*第7章*](Chapter_7.xhtml)中所做的那样，使实例不仅能够四处走动，还能根据节点树的状态跳跃、翻滚、出拳或挥手。
- en: '**Event Node**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件节点**'
- en: An event node is triggered by an external event sent to the instance, for instance,
    when a collision happens. The event node also has a cooldown timer to ignore the
    same event for a small amount of time, avoiding erratic behavior by doing the
    same action on every update of the tree again if the event keeps being sent to
    the instance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 事件节点由发送到实例的外部事件触发，例如，当发生碰撞时。事件节点还有一个冷却计时器，以忽略相同事件的一小段时间，避免由于在树的每次更新中重复执行相同动作而导致的异常行为。
- en: '**Instance Movement Node**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例移动节点**'
- en: The instance node allows us to control movement state and movement direction,
    instance speed, and instance rotation within the node tree. Using an instance
    node is required to change between the main movement states, like idle, walking,
    and running. In addition, both speed and rotation can be randomized within the
    upper and lower limits to enable a more nondeterministic behavior.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实例节点允许我们在节点树中控制移动状态和移动方向、实例速度和实例旋转。使用实例节点是改变主移动状态（如空闲、行走和跑步）所必需的。此外，速度和旋转可以在上限和下限内随机化，以实现更非确定性行为。
- en: 'In *Figure 9.7*, all these nodes are shown:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图9.7* 中，显示了所有这些节点：
- en: '![](img/figure_09_07.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_09_07.png)'
- en: 'Figure 9.7: An overview of all nodes created for the example code'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：示例代码创建的所有节点的概述
- en: The number next to the node type is the numerical node ID. In case of errors,
    or when using a DebugLog node, having the node ID at hand may be beneficial.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 节点类型旁边的数字是数值节点ID。在出现错误或使用 DebugLog 节点时，拥有节点ID可能会有所帮助。
- en: Now let’s check the most important parts of the `GraphNodeBase` class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查 `GraphNodeBase` 类最重要的部分。
- en: Exploring the base class for graph nodes
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索图节点的基础类
- en: 'To ensure derived node classes are implementing a minimum set of functionalities,
    the `GraphNodeBase` class has several pure virtual methods declared in the header
    file `GraphNodeBase.h` in the folder `graphnodes`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保派生节点类实现最小功能集，`GraphNodeBase` 类在 `graphnodes` 文件夹中的头文件 `GraphNodeBase.h`
    中声明了几个纯虚方法：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first method, `update()`, is used to alter the internal state of the node
    depending on the time difference between two frames. For instance, all nodes with
    a delay will decrease the internal counter, triggering the output pin once the
    time reaches 0.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法，`update()`，用于根据两个帧之间的时间差来改变节点的内部状态。例如，所有具有延迟的节点都会减少内部计数器，一旦时间达到0，就会触发输出引脚。
- en: Inside the `draw()` method, the appearance of the node is set. We created an
    example node starting with the section *Adding a simple node*. The `draw()` call
    contains all commands tailored to the visuals of the specific node type.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `draw()` 方法内部，设置节点的外观。我们创建了一个示例节点，从 *添加简单节点* 这一部分开始。`draw()` 调用包含所有针对特定节点类型视觉的所有命令。
- en: When the internal timer of the timing nodes reaches 0, or when a node connected
    to an input pin of the current node has finished its execution, `activate()` will
    be triggered. Here, the main logic of the node’s functionality is set.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当计时节点的内部计时器达到0，或者当连接到当前节点输入引脚的节点完成其执行时，将触发 `activate()`。在这里，设置节点功能的主要逻辑。
- en: When a node tree controlling the behavior of an instance should be removed from
    that instance, we can make sure to stop all nodes by calling `deactivate()`. Not
    stopping the finite state machine for the current instance could lead to interesting
    side effects and unwanted behavior if a node sets values for properties like speed
    or movement state. The parameter `informParentNodes` is used to distinguish between
    an ordered shutdown of a node, i.e., notifying a parent node of type Sequence
    that the child node has finished execution, and a *full stop*, when all further
    actions should be avoided.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要从实例中移除控制实例行为的节点树时，我们可以通过调用 `deactivate()` 确保停止所有节点。如果不停止当前实例的有限状态机，如果节点为速度或移动状态等属性设置了值，可能会导致有趣的副作用和不受欢迎的行为。参数
    `informParentNodes` 用于区分节点的有序关闭，即通知父节点（类型为Sequence）子节点已完成执行，以及*完全停止*，此时应避免所有进一步的操作。
- en: By using `isActive()`, the controlling code of the finite state machine can
    check if at least one node is still actively doing something, like waiting for
    a timer to reach 0\. As soon as no active node is left, the root node will be
    triggered.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `isActive()`，有限状态机的控制代码可以检查是否至少有一个节点仍在积极地进行某些操作，例如等待计时器达到0。一旦没有活跃的节点，根节点将被触发。
- en: The `clone()` method is needed to create a copy of the current instance of a
    node, containing all settings. Since we are using inheritance, using a copy constructor
    to achieve the same result would be hard due to missing access to `private` members.
    A virtual cloning method makes our lives much easier, resulting in a 1:1 copy.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用 `clone()` 方法来创建当前节点实例的副本，包含所有设置。由于我们正在使用继承，使用复制构造函数来实现相同的结果会很难，因为无法访问 `private`
    成员。一个虚拟复制方法使我们的生活变得更加容易，从而实现1:1的复制。
- en: Finally, `exportData()` and `importData()` are used to get and set the current
    state of any node instance with any values set that are worth saving and restoring.
    Internally, the values of a node type are stored in a `std::string` map, avoiding
    more than one data type in the map. Also, using simple strings inside the YAML
    parser removes any conversion when interacting with the raw text data on disk.
    The graph node types know how to encode and decode the data, moving the node-specific
    save and load logic away from the YAML parser.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`exportData()` 和 `importData()` 用于获取和设置任何节点实例的当前状态，这些实例设置了值得保存和恢复的任何值。内部，节点类型的值存储在
    `std::string` 映射中，避免了映射中超过一个数据类型。此外，在 YAML 解析器中使用简单的字符串可以消除与磁盘上的原始文本数据交互时的任何转换。图节点类型知道如何编码和解码数据，将节点特定的保存和加载逻辑从
    YAML 解析器中移除。
- en: In addition to the pure virtual methods, a small number of non-pure virtual
    functions are declared and defined in the `GraphNodeBase.h` header. These methods
    are only useful for a small subset of node types. So, forcing all node types to
    implement the functionality makes no sense.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了纯虚拟方法之外，在 `GraphNodeBase.h` 头文件中还声明和定义了一些非纯虚拟函数。这些方法仅对节点类型的一个小子集有用。因此，强迫所有节点类型实现该功能是没有意义的。
- en: 'The first three methods, `addOutputPin`, `delOutputPin`, and `getNumOutputPins`,
    are used to handle the dynamic number of output pins on the Sequence and Selector
    nodes:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个方法，`addOutputPin`、`delOutputPin` 和 `getNumOutputPins`，用于处理序列和选择节点上输出引脚的动态数量：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All three method names speak for themselves. Only the return value of `delOutputPin()`
    may need an explanation: when removing an output pin from a node, we must check
    if any links were connected to that pin. By returning the pin ID of the just-deleted
    output pin, all connected links can be removed by searching the map of links for
    the specific output node and deleting all affected links from the link map.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个方法名都一目了然。只有 `delOutputPin()` 的返回值可能需要解释：当从节点中删除输出引脚时，我们必须检查是否有任何链接连接到该引脚。通过返回刚删除的输出引脚的引脚ID，可以通过搜索链接映射中的特定输出节点并删除所有受影响的链接来删除所有连接的链接。
- en: 'The other three virtual methods, `childFinishedExecution`, `listensToEvent`,
    and `handleEvent`, are even more special:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三个虚拟方法，`childFinishedExecution`、`listensToEvent` 和 `handleEvent`，更是特别：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Sequence node type waits for the child node(s) connected to its output pins
    to report that they have finished execution. Both the `Wait` and `RandomWait`
    nodes will inform their parent node about a status change by calling `childFinishedExecution()`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 序列节点类型等待连接到其输出引脚的子节点报告它们已完成执行。`Wait` 和 `RandomWait` 节点将通过调用 `childFinishedExecution()`
    来通知其父节点状态变化。
- en: Only the event node implements the last two methods, `listensToEvent()` and
    `handleEvent()`. Both method names should be self-explanatory. The split into
    two separate methods can be useful if some preparations need to be done between
    checking if a node would handle an event and the real event execution.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 只有事件节点实现了最后两个方法，`listensToEvent()` 和 `handleEvent()`。这两个方法名应该很容易理解。如果需要在检查节点是否会处理事件和实际事件执行之间进行一些准备工作，将它们分成两个单独的方法可能很有用。
- en: As an example for a derived class, we will check some implementation details
    of the wait node.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 作为派生类的示例，我们将检查等待节点的某些实现细节。
- en: Creating the wait node
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建等待节点
- en: 'When constructing a new wait node, some defaults are set:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个新的等待节点时，会设置一些默认值：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We are using a predefined range of attribute IDs here to simplify further coding
    and help debug issues. By multiplying the node ID by `1000`, each node creates
    space for up to 1000 IDs per node, usable for input and output pins, or static
    elements like sliders and buttons. The number of nodes per tree is only limited
    by the storage capacity of an `int`, and we also recycle deleted node IDs – that’s
    more than enough for nodes and pins, even for very large node trees. In addition,
    by simply doing an integer division of any pin ID by 1000, we get the node ID
    containing that specific pin. This is the perfect solution to identify the node
    when sending signals to the pins.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用预定义的属性 ID 范围来简化进一步的编码并帮助调试问题。通过将节点 ID 乘以 `1000`，每个节点为每个节点创建最多 1000 个
    ID 的空间，可用于输入和输出引脚，或静态元素，如滑块和按钮。每个树中的节点数量仅受 `int` 的存储容量的限制，我们还回收删除的节点 ID - 这对于节点和引脚来说已经足够多了，即使对于非常大的节点树也是如此。此外，通过简单地对任何引脚
    ID 进行 1000 的整数除法，我们可以得到包含该特定引脚的节点 ID。这是在向引脚发送信号时识别节点的完美解决方案。
- en: 'Cloning the wait node requires only a single line of code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆等待节点只需要一行代码：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This kind of virtual cloning is widely used and enables us to make an exact
    copy of that wait node, including all node-specific settings.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种虚拟克隆被广泛使用，并使我们能够精确复制该等待节点，包括所有节点特定的设置。
- en: The `draw()` method code can be skipped since we just use a slider as the control
    element instead of the checkbox. Most of the `draw()` code is identical to the
    code in the sections *Adding a simple node* and *Creating imnodes attributes and
    ImGui elements in a node*, so we can skip the details here.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()` 方法代码可以跳过，因为我们只是使用滑块作为控制元素，而不是复选框。大多数的 `draw()` 代码与 *添加简单节点* 和 *在节点中创建
    imnodes 属性和 ImGui 元素* 部分的代码相同，因此我们在这里可以跳过细节。'
- en: 'A call to `activate()` starts the wait timer. The `private` Boolean member
    variable `mActive` is set to true, and another `private` Boolean called `mFired`
    is set to false:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `activate()` 开始等待计时器。将 `private` 布尔成员变量 `mActive` 设置为 true，并将另一个名为 `mFired`
    的 `private` 布尔设置为 false：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We use `mFired` only to change the color of the output pin from white to green,
    signaling in the editor window that the wait node has notified any node connected
    to the output pin.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅使用 `mFired` 来改变输出引脚的颜色，从白色变为绿色，在编辑器窗口中指示等待节点已通知连接到输出引脚的任何节点。
- en: 'Once `mAcive` is set to true, the `update()` method starts decrementing the
    wait time in `mCurrentTime`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将 `mAcive` 设置为 true，`update()` 方法开始递减 `mCurrentTime` 中的等待时间：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After the wait time is below 0, trigger signals for both the input and the
    output pin are sent out, the wait time is reset, the node is deactivated, and
    the color of the output pin changes:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当等待时间低于 0 时，触发输入和输出引脚的信号被发送出去，等待时间被重置，节点被停用，输出引脚的颜色发生变化：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The reason for triggering the input pin was discussed in the section *Creating
    graph node classes*: if the wait node is a child of a sequence node, the parent
    sequence node needs to know that the wait node is no longer active.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *创建图节点类* 部分中讨论了触发输入引脚的原因：如果等待节点是序列节点的子节点，父序列节点需要知道等待节点不再活跃。
- en: 'Finally, exporting and importing data is done by the two methods, `exportData()`
    and `importData()`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过 `exportData()` 和 `importData()` 这两个方法完成数据的导出和导入：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Both methods are straightforward. We just store the `float` in a `std::string`
    on exporting and read back the `float` value on importing.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都很直接。我们只是在导出时将 `float` 存储在 `std::string` 中，并在导入时读取 `float` 值。
- en: All other specialized nodes are created in a similar way, implementing the required
    methods and enhancing the other virtual methods if needed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他专用节点都是以类似的方式创建的，实现所需的方法，并在需要时增强其他虚拟方法。
- en: Another well-known coding style from the application is using callbacks to call
    methods in other classes. `GraphNodeBase` uses two callbacks to handle events.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中另一个著名的编码风格是使用回调来调用其他类的函数。`GraphNodeBase` 使用两个回调来处理事件。
- en: Using callbacks to propagate changes
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用回调来传播变化
- en: 'By activating the first callback, a node informs the finite state machine that
    it has finished its execution, and the control should be given to the nodes connected
    to the output pin(s):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过激活第一个回调，节点通知有限状态机它已完成其执行，并且控制权应交给连接到输出引脚（s）的节点：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The method that handles this callback is the main part of the state management
    when advancing the status of the nodes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 处理此回调的方法是管理节点状态进度的状态管理的主要部分。
- en: 'Real behavior changes happen in the method executed by the second callback:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的行为变化发生在第二个回调执行的方法中：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This callback is used by the instance and action node types, informing, after
    quite a long callback cascade, the renderer class to manipulate a single property
    of the instance owning the node tree that started the callback.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调由实例和动作节点类型使用，在经过相当长的回调级联之后，通知渲染器类操作拥有节点树的实例的单个属性。
- en: Here is where all the magic happens, letting the instance mode change the movement
    state to walk or run, or start an action like jumping or waving the hand.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生所有的魔法，允许实例模式改变移动状态为行走或奔跑，或者开始跳跃或挥手等动作。
- en: We will now take a closer look at more code that will make use of both callbacks.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更详细地查看将使用两个回调的更多代码。
- en: Creating a behavior struct and a storage class for the instances
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建行为 `struct` 和实例存储类
- en: 'To store nodes, links, and the action callback, the new `struct` `BehaviorData`
    will be used, residing in the file `BehaviorData.h` in the `model` folder:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储节点、链接和动作回调，将使用新的 `struct` `BehaviorData`，它位于 `model` 文件夹中的 `BehaviorData.h`
    文件中：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Nodes and links are stored in basic STL containers, and we also store the editor
    setting string in the `struct`, enabling us to save and restore the node positions
    in the node editor window. The `nodeActionCallback` callback is only needed in
    an intermediate fashion to create a link chain between the callbacks in the nodes
    and the class storing the behavior data `struct` itself.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 节点和链接存储在基本的 STL 容器中，我们还在 `struct` 中存储编辑设置字符串，使我们能够在节点编辑器窗口中保存和恢复节点位置。`nodeActionCallback`
    回调仅在中间形式下需要，以在节点中的回调和存储行为数据的 `struct` 类本身之间的回调之间创建链接链。
- en: 'The new class `SingleInstanceBehavior` is used to collect all data and methods
    for the behavior control of a single instance. Here, we create the chain for the
    `nodeActionCallback` callback by setting the callback function of the `BehaviorData`
    `struct` to the local method `nodeActionCallback()`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类 `SingleInstanceBehavior` 用于收集单个实例的行为控制的所有数据和方法。在这里，我们通过将 `BehaviorData`
    `struct` 的回调函数设置为本地方法 `nodeActionCallback()` 来创建 `nodeActionCallback` 回调的链：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Whenever nodes of types are created that need to change instance data, the
    `nodeActionCallback` of the `BehaviorData` `struct` is set in the new node:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建需要更改实例数据的类型节点时，将 `BehaviorData` `struct` 的 `nodeActionCallback` 设置在新的节点中：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, in the `nodeActionCallback()` method, the incoming data is transformed
    to include the instance ID, and another callback function is executed:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `nodeActionCallback()` 方法中，传入的数据被转换以包含实例 ID，并执行另一个回调函数：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The callback chain decouples the internal instance and animation state from
    the state machine controlling it. By decoupling the states, it is possible for
    a node of the instance movement or action type to request a property change for
    the instance where this node resides in one of the behaviors without any knowledge
    of which instance the node is.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 回调链将内部实例和动画状态与其控制的状态机解耦。通过解耦状态，节点运动或动作类型的节点可以请求更改位于某个行为中的实例的属性，而无需了解该节点是哪个实例。
- en: The remaining parts of the node actions will be implemented in the section *Extending
    the code to support behavior changes*, completing the chain from a single node
    in a node tree all the way up to the renderer.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 节点动作的其余部分将在 *扩展代码以支持行为变化* 的部分实现，完成从节点树中的单个节点到渲染器的链。
- en: 'For the second callback function, a lambda in the `SingleInstanceBehavior`
    class is used to connect the state update request to a local method:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个回调函数，`SingleInstanceBehavior` 类中使用了一个 lambda 表达式来将状态更新请求连接到本地方法：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Inside `updateNodeStatus()`, some simple logic changes the active state of the
    nodes by using the `pinId` given as a parameter. Following the rule “output first,
    input second” for the link IDs of imnodes and the integer division of the pin
    ID, we could detect if the signal came from an input or output pin and even find
    the node that called `updateNodeStatus()`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `updateNodeStatus()` 方法内部，一些简单的逻辑通过使用作为参数提供的 `pinId` 来改变节点的活动状态。遵循“先输出，后输入”的规则以及
    imnodes 的链接 ID 和 pin ID 的整数除法，我们可以检测信号是否来自输入或输出引脚，甚至找到调用 `updateNodeStatus()`
    的节点。
- en: If `updateNodeStatus()` receives a call with an output pin ID as a parameter,
    all connected child nodes will be activated. If no connected child node is found
    on the output pin, we inform the parent node about a finished execution. This
    special handling is only relevant for a sequence node right now, enabling us to
    skip output pins without a connection.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`updateNodeStatus()`方法接收到一个带有输出引脚ID的参数的调用，所有连接的子节点将被激活。如果在输出引脚上找不到连接的子节点，我们将通知父节点执行已完成。这种特殊处理目前只与序列节点相关，使我们能够跳过没有连接的输出引脚。
- en: For an input pin as a parameter, the corresponding node connected to that input
    pin will be informed. This is only needed at the end of the execution of a child
    node of a sequence node right now, but the functionality can be extended for new
    node types.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个输入引脚作为参数，将通知连接到该输入引脚的相应节点。目前这仅适用于序列节点子节点的执行结束时，但该功能可以扩展到新的节点类型。
- en: Without logging calls and comments, the entire `updateNodeStatus()` method is
    just about forty lines short, but it still does the main job of the entire behavior
    tree implementation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 没有日志调用和注释，整个`updateNodeStatus()`方法大约只有四十行，但它仍然完成了整个行为树实现的主要工作。
- en: To simplify the creation of new nodes, we will use the factory pattern. A node
    factory encloses all the logic needed to create a new node of a specified type
    in one place. Plus, we will enhance the editor with a context menu and the ability
    to switch between different node trees.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化新节点的创建，我们将使用工厂模式。节点工厂封装了创建指定类型新节点所需的所有逻辑。此外，我们还将通过上下文菜单和在不同节点树之间切换的能力来增强编辑器。
- en: Adding a node factory
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加节点工厂
- en: The factory pattern is a nice solution to create objects of classes derived
    from a single base class, keeping all parts of the creation logic in a single
    place.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是创建从单个基类派生出的对象的一个很好的解决方案，它将所有创建逻辑保持在单一位置。
- en: The factory class `GraphNodeFactory` in the `graphnodes` folder is small and
    simple, similar to other factory classes. At the creation time of a factory object,
    the appropriate `fireNodeOutputCallback` is injected into the constructor, helping
    us to add the right callback destination to all new nodes. The constructor also
    adds a mapping between all node types and the names in the title area of the nodes.
    This name mapping frees us from adding the node name at node creation time; we
    only need the node type and a unique node ID to build a new node.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`graphnodes`文件夹中的工厂类`GraphNodeFactory`小巧简单，类似于其他工厂类。在创建工厂对象时，适当的`fireNodeOutputCallback`被注入到构造函数中，帮助我们为所有新节点添加正确的回调目标。构造函数还添加了所有节点类型与节点标题区域中名称之间的映射。这种名称映射使我们免去了在节点创建时添加节点名称的需要；我们只需要节点类型和一个唯一的节点ID来构建一个新节点。'
- en: The `makeNode()` method does all the work by creating a new derived class according
    to the given node type, adding the callback, the mapped node name, and the node
    type of the chosen derived class. Like in all factories, the returned smart pointer
    is of the base class type, allowing us to store all new nodes in STL containers
    of the base class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeNode()`方法通过根据给定的节点类型创建一个新的派生类来完成所有工作，添加回调、映射的节点名称和所选派生类的节点类型。像所有工厂一样，返回的智能指针是基类类型，允许我们将所有新节点存储在基类类型的STL容器中。'
- en: Extending the node editor
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展节点编辑器
- en: 'For better node handling, we create a context menu in the editor. The context
    menu can be opened by pressing the right mouse button in the node editor window:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地处理节点，我们在编辑器中创建了一个上下文菜单。可以通过在节点编辑器窗口中按下鼠标右键来打开上下文菜单：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In fact, we create two different context menus. Which menu is shown depends
    on if we are hovering over a node or not:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们创建了两个不同的上下文菜单。显示哪个菜单取决于我们是否悬停在节点上：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If no existing node is hovered over when pressing the right mouse button, an
    ImGui pop-up window to add a new node will be created, listing all available node
    types (all but the root node, which only exists once). If a node is hovered over,
    a different ImGui pop-up window is shown, containing actions that could be executed
    on the hovered-over node.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在按下鼠标右键时没有悬停在现有节点上，将创建一个ImGui弹出窗口以添加新节点，列出所有可用的节点类型（除了仅存在一次的根节点）。如果悬停在节点上，将显示不同的ImGui弹出窗口，其中包含可以对悬停节点执行的操作。
- en: '*Figure 9.8* shows both context menus next to each other:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.8*显示了并排的两个上下文菜单：'
- en: '![](img/figure_09_08.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/figure_09_08.png)'
- en: 'Figure 9.8: The two context menus of the editor'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：编辑器的两个上下文菜单
- en: Which options in the **Change Node** menu are shown depends on the node type.
    For sequence and selector nodes, the number of output pins can be changed dynamically,
    so these two options appear, while for all other nodes, only **Deactivate** and
    **Delete** are shown. The availability to deactivate and delete a node is based
    on the active state of the node. For instance, you cannot delete an active wait
    node until the wait time has expired.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**更改节点**菜单中显示哪些选项取决于节点类型。对于序列和选择节点，输出引脚的数量可以动态更改，因此这两个选项出现，而对于所有其他节点，只显示**停用**和**删除**。停用和删除节点的可用性基于节点的活动状态。例如，在等待时间到期之前，你不能删除一个活动等待节点。'
- en: 'To edit an existing node tree into the existing editor window, a new method
    called `loadData()` is added:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要将现有的节点树编辑到现有的编辑器窗口中，我们添加了一个名为`loadData()`的新方法：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Inside `loadData()`, both a new `SingleInstanceBehavior` and a new `GraphNodeFactory`
    object are created to allow editing the node tree the same way as a fresh node
    tree.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loadData()`内部，创建了一个新的`SingleInstanceBehavior`和一个新的`GraphNodeFactory`对象，以便以相同的方式编辑节点树，就像一个全新的节点树一样。
- en: 'The editor also has an `update()` method to behave like a running node tree,
    updating the properties of all nodes depending on their state:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器还有一个`update()`方法，使其表现得像一个正在运行的节点树，根据节点的状态更新所有节点的属性：
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, we add a flag called `mShowEditor` to control the visibility of the
    editor. When a new node tree is created, or an existing tree is edited, the window
    appears on screen. By clicking on the close button of the editor, or when the
    currently edited node tree is deleted, we hide the editor window.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个名为`mShowEditor`的标志来控制编辑器的可见性。当创建一个新的节点树或编辑现有的树时，窗口会出现在屏幕上。通过点击编辑器的关闭按钮，或者当当前编辑的节点树被删除时，我们隐藏编辑器窗口。
- en: The last step to complete the implementation of the imnodes-based visual node
    editor is adding all required data to the `YamlParser` class. We do not want to
    start over with an empty editor every time the application is started.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 完成基于imnodes的视觉节点编辑器的实现最后一步是向`YamlParser`类添加所有必要的数据。我们不希望在每次应用程序启动时都从一个空编辑器开始。
- en: Saving and loading a node tree
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存和加载节点树
- en: Creating the required templates and overloads for the new behavior data is not
    much different from what we did in the previous chapters.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为新行为数据创建所需的模板和重载与我们在前面的章节中所做的大致相同。
- en: 'To add behavior data to the YAML file, an overload of the output stream operator
    in the file `YamlParser.cpp` is needed. The file can be found in the `tools` folder:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要将行为数据添加到YAML文件中，需要在`YamlParser.cpp`文件中添加一个输出流操作符的重载。该文件位于`tools`文件夹中：
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Most of the code can be copied from the previously defined overloads. Having
    a map of strings created by `exportData()` makes it easy to save the state of
    the nodes:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码可以复制自之前定义的重载。通过`exportData()`创建的字符串映射使得保存节点的状态变得容易：
- en: '[PRE40]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: By using `std::optional` in the return value for `exportData()`, we can easily
    skip the entire section in the YAML file if the node has no state to save. Without
    the `optional` keyword, we would need an additional check to determine if the
    node state needs to be saved or not.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`exportData()`的返回值中使用`std::optional`，我们可以轻松地跳过YAML文件中没有任何状态要保存的整个部分。如果没有`optional`关键字，我们需要额外的检查来确定节点状态是否需要保存。
- en: 'For the loading part of the new behavior data, we must add a new `convert`
    template in the file `YamlParserTypes.h`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新行为数据的加载部分，我们必须在`YamlParserTypes.h`文件中添加一个新的`convert`模板：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We are using the extended version of the `BehaviorData` `struct` since we only
    store the type of a node, and the YAML parser is the wrong place to create new
    nodes:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`BehaviorData` `struct`的扩展版本，因为我们只存储节点类型，而YAML解析器不是创建新节点的正确地方：
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Node recreation will happen in the renderer class when loading a saved file,
    like the creation of models, instances, and cameras.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载保存的文件时，节点将在渲染器类中重新创建，就像创建模型、实例和相机一样。
- en: 'Most of the `convert` code can be taken from previously implemented templates.
    But there is one caveat to the `decode()` method. Instead of the data type of
    the node data, a `std::map` of strings, the `yaml-cpp` library requires us to
    use a vector of maps, containing a single entry for every line in the node data.
    The following code shows how the parsing is done:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分的`convert`代码可以来自之前实现的模板。但`decode()`方法有一个需要注意的地方。与节点数据的类型（字符串映射）不同，`yaml-cpp`库要求我们使用包含每行节点数据单个条目的向量映射。以下代码展示了如何进行解析：
- en: '[PRE43]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'All vector entries will be added to the `nodeProperties` variable of the intermediate
    `PerNodeImportData` `struct`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 所有向量条目都将添加到中间`PerNodeImportData` `struct`的`nodeProperties`变量中：
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the renderer, we restore the behavior node tree by creating a new `SingleInstanceBehavior`
    instance, a new `BehaviorData` `struct`, and new nodes of the saved type and ID,
    as well as loading back the saved properties. After the links are recreated and
    links and editor settings are imported to the new `BehaviorData`, the node tree
    is in the same state as when it was saved.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器中，我们通过创建一个新的`SingleInstanceBehavior`实例、一个新的`BehaviorData` `struct`以及保存类型和ID的新节点，以及重新加载保存的属性来恢复行为节点树。在重新创建链接并将链接和编辑设置导入新的`BehaviorData`之后，节点树的状态与保存时相同。
- en: 'Restore order: Behavior before instances'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复顺序：行为在实例之前
- en: We must restore the behavior node tree data before restoring the instances,
    since the behavior data will be copied to an instance if we had set a behavior
    before saving the configuration data.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在恢复实例之前，我们必须恢复行为节点树数据，因为如果在保存配置数据之前设置了行为，行为数据将被复制到实例中。
- en: Once the node editor itself is ready, we need to connect the node trees and
    instances. So, let’s add the missing pieces to have the instances come alive.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦节点编辑器本身准备就绪，我们需要连接节点树和实例。因此，让我们添加缺失的部分，让实例变得活跃起来。
- en: Extending the code to support behavior changes
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展代码以支持行为变化
- en: A few steps are left to fully support computer-controlled behavior in the instances.
    First, we need a copy of a node tree in every instance.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全支持在实例中实现计算机控制的行为，还有一些步骤要做。首先，我们需要每个实例中都有一个节点树的副本。
- en: Creating a node tree copy for every instance
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为每个实例创建节点树副本
- en: We cannot just copy the nodes since the original and copy would access the same
    node behind the shared pointer. Reusing the same nodes for multiple instances
    would lead to chaos, since collision events from all instances would be triggered,
    resulting in the same steps executed for all instances sharing the nodes.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能只是复制节点，因为原始副本会访问共享指针后面的相同节点。对于多个实例重用相同的节点会导致混乱，因为所有实例的碰撞事件都会被触发，导致所有共享节点的实例执行相同的步骤。
- en: To create a copy of the node tree for one of the instances, a custom copy constructor
    for the `SingleInstanceBehavior` class has been created. The copy constructor
    sets the required callbacks, copies the links, and loops through the vector of
    existing nodes to create a clone of every node. For nodes that change instance
    behavior, the additional node action callback will be set.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要为实例之一创建节点树的副本，已经为`SingleInstanceBehavior`类创建了一个自定义的复制构造函数。复制构造函数设置了所需的回调，复制了链接，并通过遍历现有节点的向量来创建每个节点的克隆。对于改变实例行为的节点，将设置额外的节点操作回调。
- en: Next, the callback chain to the renderer must be completed. Right now, only
    the `SingleInstanceBehavior` class objects are informed that a node wants to send
    a property change request to an instance.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，必须完成到渲染器的回调链。目前，只有`SingleInstanceBehavior`类对象被告知一个节点想要向实例发送属性更改请求。
- en: Connecting SingleInstanceBehavior and the renderer
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接SingleInstanceBehavior和渲染器
- en: 'Managing the copies of the instance behaviors will be done by the new `BehaviorManager`
    class, located in the `model` folder. The `BehaviorManager` class maintains a
    mapping between the instance IDs and the copy of the node tree the specific instance
    uses. Also, we have a new callback to keep the renderer in the loop to update
    instance properties of a node of the node tree:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 实例行为的副本将由位于`model`文件夹中的新`BehaviorManager`类来管理。`BehaviorManager`类维护实例ID与其使用的节点树副本之间的映射。此外，我们还有一个新的回调来保持渲染器在循环中更新节点树的节点属性：
- en: '[PRE45]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To update the state of all node trees for the instances, an `update()` method
    exists in the `BehaviorManager` class:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新实例的所有节点树的状态，`BehaviorManager`类中存在一个`update()`方法：
- en: '[PRE46]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We just loop over all instances and call the `update()` method of the `SingleInstanceBehavior`
    object, which updates all nodes of the node tree.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是遍历所有实例并调用`SingleInstanceBehavior`对象的`update()`方法，该方法更新节点树的所有节点。
- en: 'In the renderer, a `private` member named `mBehaviorManager` is added and initialized
    during the `init()` method of the renderer:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器中，在渲染器的`init()`方法中添加并初始化了一个名为`mBehaviorManager`的`private`成员：
- en: '[PRE47]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A model instance can be added by handing over the instance ID and the node
    tree to the `addInstance()` method of the `BehaviorManager` class:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过传递实例ID和节点树到`BehaviorManager`类的`addInstance()`方法来添加模型实例：
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the `addInstance()` method, we copy all nodes in the tree, set the callback
    to the renderer, and add the instance ID to the `SingleInstanceBehavior` object.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addInstance()`方法中，我们复制树中的所有节点，将回调设置为渲染器，并将实例ID添加到`SingleInstanceBehavior`对象中。
- en: Now, any instance or action node inside the node tree of that instance can call
    the function bound to its `nodeActionCallback` member. The request goes up the
    callback chain and ends in the `updateInstanceSettings()` method of the renderer,
    containing all information for the renderer to change the instance property.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何实例或动作节点都可以调用绑定到其`nodeActionCallback`成员的函数。请求沿着回调链向上传递，最终结束于渲染器的`updateInstanceSettings()`方法，其中包含所有用于渲染器更改实例属性的信息。
- en: Finally, we must define all events we want to send to instances, plus where
    to place the code firing these events.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须定义所有我们想要发送到实例的事件，以及触发这些事件的代码放置位置。
- en: Adding events
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加事件
- en: 'To support events, a new `enum` `class` called `nodeEvent` is created in the
    file `Enums.h` located in the `opengl` folder (or the `vulkan` folder for Vulkan):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持事件，在`opengl`文件夹（或Vulkan的`vulkan`文件夹）中的`Enums.h`文件中创建了一个新的`enum`类`nodeEvent`：
- en: '[PRE49]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To start, we define two values called `instanceToInstanceCollision` and `instanceToEdgeCollision`,
    used to inform an instance that a collision with another instance or a collision
    to the world boundaries has occurred. The first value, `none`, is used to ignore
    events in an event node, and the `NUM` value is needed to loop over all values
    in a `for` loop.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义两个值，称为`instanceToInstanceCollision`和`instanceToEdgeCollision`，用于通知实例发生了与其他实例或世界边界的碰撞。第一个值`none`用于忽略事件节点中的事件，而`NUM`值在`for`循环中需要遍历所有值。
- en: 'In the `ModelInstanceCamData` `struct`, a mapping called `micNodeUpdateMap`
    is added to translate a `nodeEvent` value to a readable string for the events:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ModelInstanceCamData`结构体中，添加了一个名为`micNodeUpdateMap`的映射，用于将`nodeEvent`值转换为可读的字符串，用于事件：
- en: '[PRE50]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The renderer not only adds the strings during the `init()` method but also,
    all calls firing an event are sent from the renderer to the node trees:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器不仅会在`init()`方法中添加字符串，而且所有触发事件的调用都会从渲染器发送到节点树：
- en: '[PRE51]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This new `micNodeEventCallbackFunction` callback is bound to the `addBehaviorEvent()`
    method of the renderer, and after chaining the request to existing objects, the
    call ends in the `SingleInstanceBehavior` class. There, all requested events are
    added to a vector:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`micNodeEventCallbackFunction`回调绑定到渲染器的`addBehaviorEvent()`方法，并在将请求链接到现有对象后，调用结束于`SingleInstanceBehavior`类。在那里，所有请求的事件都被添加到一个向量中：
- en: '[PRE52]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Events are handled in the `update()` call of the `SingleInstanceBehavior` class,
    calling the `handleEvent()` method of the node. The `handleEvent()` method was
    introduced in the section *Exploring the base class for graph nodes*. It simply
    activates all event nodes in the graph of the specified instance that are listening
    to this event type.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 事件在`SingleInstanceBehavior`类的`update()`调用中处理，调用节点的`handleEvent()`方法。`handleEvent()`方法在*探索图节点基类*部分中引入。它只是激活指定实例图中所有监听此事件类型的节点事件。
- en: 'An example node tree containing events is shown here:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 包含事件的示例节点树如下所示：
- en: '![](img/figure_09_09.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_09_09.png)'
- en: 'Figure 9.9: An overview of the node tree for the woman’s model'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：女性模型的节点树概述
- en: We have split this image of the node tree into two parts, in *Figures 9.10 and
    9.11*, for better understanding.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将节点树的这个图像分成了两部分，在*图9.10和图9.11*中，以便更好地理解。
- en: '*Figure 9.10* shows the default path in the node tree, beginning with the root
    node.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.10*显示了节点树中的默认路径，从根节点开始。'
- en: '![](img/figure_09_10.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_09_10.png)'
- en: 'Figure 9.10: Default path in the node tree for the woman’s model'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：女性模型节点树中的默认路径
- en: '*Figure 9.11* shows the event nodes plus the reaction to events.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.11*显示了事件节点以及事件反应。'
- en: '![](img/figure_09_11.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_09_11.png)'
- en: 'Figure 9.11: Events in the node tree for the woman’s model'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：女性模型节点树中的事件
- en: 'In *Figure 9.12*, the resulting behavior of the tree in *Figure 9.9* for the
    woman’s model and a similar tree for the man’s model is shown:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.12*中，展示了*图9.9*中女性模型的树形结构以及男性模型类似树形结构的结果行为：
- en: '![](img/figure_09_12.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_09_12.png)'
- en: 'Figure 9.12: Instances living their virtual life'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：生活在虚拟生活中的实例
- en: By default, the models are walking around, reacting to collisions with other
    instances by rotating a bit. After a collision with the world boundaries, the
    instances turn around. After a random time, the instances stop moving, and a random
    animation clip is played. At this point, the normal execution ends, and the root
    node is triggered again.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，模型正在四处走动，通过稍微旋转来响应与其他实例的碰撞。在与世界边界碰撞后，实例会转身。经过随机时间后，实例停止移动，并播放一个随机的动画片段。此时，正常执行结束，并再次触发根节点。
- en: Although the node editor looks really cool, and we can add nodes of different
    types, create links, and save and load the state, some limits of the current implementation
    should be noted.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然节点编辑器看起来真的很酷，我们可以添加不同类型的节点，创建链接，并保存和加载状态，但应该注意当前实现的某些限制。
- en: Limitations of the current implementation
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当前实现的限制
- en: Our basic implementation lacks some features of other behavior trees.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本实现缺少其他行为树的一些功能。
- en: First, states are stored directly in the nodes. For the use case of the application
    we are creating, storing state data in the nodes is sufficient. But for larger
    trees, separate state storage becomes handy, mostly because we no longer need
    to copy the node data to the instances.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，状态直接存储在节点中。对于我们所创建的应用程序的使用案例，在节点中存储状态数据是足够的。但对于更大的树，单独的状态存储变得方便，主要是因为我们不再需要将节点数据复制到实例中。
- en: Also, changes to the node tree in the editor session are not automatically copied
    to the instances. You need to select an instance or model and apply the current
    state after every change.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，编辑会话中节点树的变化不会自动复制到实例中。您需要选择一个实例或模型，并在每次更改后应用当前状态。
- en: Since only the original node tree data of the editor session is saved to the
    YAML file and not the tree data of the individual instances, restarting the application
    or reloading the configuration applies the editor state to all instances that
    use the specific node tree.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只将编辑会话的原节点树数据保存到YAML文件中，而不是各个实例的节点树数据，因此重新启动应用程序或重新加载配置会将编辑状态应用到使用特定节点树的所有实例。
- en: Finally, the nodes cannot access data from their instance or other data of the
    virtual world. Reacting to properties like position or rotation, or seeing if
    you are the primary or secondary candidate of a collision to adjust the rotation
    angle, is not possible.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，节点无法访问其实例或其他虚拟世界的数据。对位置或旋转等属性做出反应，或查看您是否是碰撞的主要或次要候选者以调整旋转角度，是不可能的。
- en: Many of these limits can be removed with some effort and additional coding.
    See the *Practical sessions* section for ideas.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些限制可以通过一些努力和额外的编码来消除。请参阅*实践课程*部分以获取想法。
- en: 'In the last section of this chapter, we will use the code we have added up
    until now to create a new feature: interaction between instances.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将使用到目前为止添加的代码来创建一个新功能：实例之间的交互。
- en: Adding interaction between instances
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实例之间添加交互
- en: We already have an action called **Interaction**, starting the interaction animation
    clip for the man’s model (and doing nothing visible for the woman’s model, as
    the model does not have an animation clip to show some kind of interaction).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个名为**Interaction**的动作，用于启动男性模型的交互动画片段（而对于女性模型，由于模型没有显示某种交互的动画片段，因此对女性模型没有可见的操作）。
- en: This *interaction* action will be extended to send an event to a nearby instance,
    stating that we want to interact with the instance. A possible reaction to the
    interaction request could be the replay of the waving animation clip for the man’s
    model on the nearby instance, visually confirming that the event has been processed.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个**交互**动作将被扩展，向附近的实例发送一个事件，表示我们想要与该实例交互。对交互请求的可能反应可以是附近实例上男性模型 waving动画片段的重放，从而在视觉上确认事件已被处理。
- en: Creating interaction control properties
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建交互控制属性
- en: 'The renderer needs some variables and a bit of code to support interaction.
    We add these new variables in the `OGLRenderData` `struct` in the `OGLRenderData.h`
    in the `opengl` folder:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器需要一些变量和一些代码来支持交互。我们在`opengl`文件夹中的`OGLRenderData.h` `struct`中添加了这些新变量：
- en: '[PRE53]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As always, for Vulkan, the variables have to be added to the `VkRenderData`
    `struct` in the `VkRenderData.h` file.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，对于Vulkan，变量必须添加到`VkRenderData` `struct`中，该`struct`位于`VkRenderData.h`文件中。
- en: With these new variables, we can switch interaction on and off, as well as set
    a minimum and maximum scan range for other instances and a field-of-view angle
    that the peer instances need to be in. The field of view allows us to select only
    instances we are looking at, and instances that are looking toward us.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些新变量，我们可以开启和关闭交互，以及为其他实例设置最小和最大扫描范围和一个对等实例需要在其中的视场角。视场角允许我们仅选择我们正在看的实例，以及朝向我们看的实例。
- en: In the `std::set` of `int` values, we store all instances in the configured
    range and with the correct view angle. Finally, we store the instance we have
    chosen to interact with.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在`std::set`的`int`值中，我们存储所有在配置范围内的实例和正确的视角。最后，我们存储我们选择与之交互的实例。
- en: The interaction candidate selection is handled in `findInteractionInstances()`
    in the renderer. Like collision detection, we drill down from all instances to
    a single instance by narrowing down the selection properties.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 交互候选者选择在渲染器的`findInteractionInstances()`中处理。像碰撞检测一样，我们通过缩小选择属性从所有实例钻取到单个实例。
- en: 'A simple algorithm is used to find the instance suitable for interaction:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个简单的算法来找到适合交互的实例：
- en: A `BoundingBox2D` object with the max size is used, and the `query()` method
    of the quadtree is called. Now we have all instances in that area.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最大尺寸的`BoundingBox2D`对象，并调用quadtree的`query()`方法。现在我们有了该区域的所有实例。
- en: All instances within the minimum range are sorted out, including ourselves.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有在最小范围内的实例都被筛选出来，包括我们自己。
- en: By using the dot product between our own rotation angle and the distance vector
    between us and the remaining instances from step 2, all instances with the incorrect
    facing are removed.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用我们自己的旋转角度与第2步中我们与剩余实例之间的距离向量的点积，移除所有朝向不正确的实例。
- en: The distances between us and all instances left in step 3 are sorted in ascending
    order, and the nearest instance is set to be the interaction instance.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第3步中留下的所有实例与我们之间的距离按升序排序，最近的实例被设置为交互实例。
- en: If any step returns no valid candidates, the interaction request will be ignored.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何步骤没有返回有效的候选者，交互请求将被忽略。
- en: Extending the handling code
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展处理代码
- en: 'Thanks to all our preparations, adding a new event is now extremely simple.
    First, we extend the `nodeEvent` `enum` by the new interaction value:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了我们的所有准备工作，添加新事件现在变得极其简单。首先，我们通过新的交互值扩展`nodeEvent` `enum`：
- en: '[PRE54]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, we send the interaction event to the central behavior class when the
    interaction key is pressed, and our model plays the interaction animation clip:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当按下交互键时，我们将交互事件发送到中央行为类，并且我们的模型播放交互动画片段：
- en: '[PRE55]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Finally, we create a new event node in the node tree for the man’s model, setting
    the wave action. The new wave action is surrounded by two other actions setting
    the idle state for the instance to have a smooth animation blending, and two wait
    nodes allowing us to finish the animations (we have no feedback yet from the instance
    to the node tree).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在人的模型节点树中创建一个新的事件节点，设置波浪动作。新的波浪动作被两个其他动作包围，这两个动作设置实例的空闲状态，以便实现平滑的动画混合，以及两个等待节点，使我们能够完成动画（我们还没有从实例到节点树的反馈）。
- en: 'The resulting part of the node tree can be seen in *Figure 9.13*:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 节点树的结果部分可以在*图9.13*中看到：
- en: '![](img/figure_09_13.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13](img/figure_09_13.png)'
- en: 'Figure 9.13: Reacting to an interaction event by playing the waving animation'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：通过播放挥手动画对交互事件做出反应
- en: That’s all! Switching to view mode and pressing the *U* key near another man’s
    instance will instruct that instance to stop and wave its hand back to us. After
    the wave animation, the portion of the node tree will end, resuming the normal
    behavior.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！切换到查看模式并按另一个人的实例附近的*U*键将指示该实例停止并挥手向我们。在挥手动画之后，节点树的这部分将结束，恢复正常行为。
- en: Drawing debug information
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制调试信息
- en: As with all previous additions, getting a new feature to work without proper
    debug information could be exhausting. For the interaction, we can utilize the
    AABB drawing code to draw a bounding box around the instance candidates, and we
    can use the line mesh to draw a square on the ground, showing the dimensions of
    the minimum and maximum search area.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有之前的添加一样，在没有适当的调试信息的情况下使新功能工作可能会非常耗时。对于交互，我们可以利用AABB绘制代码在实例候选者周围绘制边界框，并且我们可以使用线网格在地面绘制一个正方形，显示最小和最大搜索区域的尺寸。
- en: '*Figure 9.14* shows an example of the debug lines, captured with a first-person
    camera:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.14*显示了调试线的示例，使用第一人称摄像机捕获：'
- en: '![](img/figure_09_14.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/figure_09_14.png)'
- en: 'Figure 9.14: Interaction between the user and another instance'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：用户与另一个实例的交互
- en: With behavior and interaction in place, the virtual world looks and feels more
    alive than ever. The instances are walking around alone, reacting to collisions,
    and doing various actions at random times. And we can even greet some of the instances
    – and they greet us back. It is a lot of fun to just fly around in the virtual
    world, watching the instances.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在行为和交互到位后，虚拟世界看起来和感觉比以往任何时候都更加生动。实例独自四处走动，对碰撞做出反应，并在随机时间执行各种动作。我们甚至可以问候一些实例——它们也会向我们问候。在虚拟世界中飞翔，观看实例，非常有趣。
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we created a simple form of NPCs in our virtual world. We started
    by exploring the basic nature of behavior trees and state machines, and to have
    a tool for creating the state machine controlling the behavior available, we added
    an ImGui-based visual node editor. Then, we added classes for different node types
    and integrated these new classes into the existing code, including a node factory
    and node editor extensions. Finally, we added interactions with other instances
    in the virtual world.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在虚拟世界中创建了一种简单的NPC形式。我们首先探索了行为树和状态机的基本性质，为了有一个创建控制行为的状态机的工具，我们添加了一个基于ImGui的可视节点编辑器。然后，我们添加了不同节点类型的类，并将这些新类集成到现有代码中，包括节点工厂和节点编辑器扩展。最后，我们添加了与其他虚拟世界实例的交互。
- en: 'In the next chapter, we will go back to the animation side of things: we will
    add additive blending in the form of morph animations to create facial animations.
    First, we will discuss what morph animations are, and which constraints we must
    take care of. Then, we will import existing morph animations in the glTF models
    and offload the animation work to the GPU, similar to the other animations. As
    the last step, we will combine facial animations and interactions, creating instances
    that can show if they agree or disagree with us.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到动画方面：我们将添加形态动画形式的加法混合来创建面部动画。首先，我们将讨论什么是形态动画，以及我们必须注意哪些约束。然后，我们将导入glTF模型中的现有形态动画，并将动画工作卸载到GPU上，类似于其他动画。最后一步，我们将结合面部动画和交互，创建可以显示它们是否同意或不同意我们的实例。
- en: Practical sessions
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践课程
- en: 'Here are some additions you could make to the code:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些你可以添加到代码中的改进：
- en: Extend the undo/redo functionality to the node trees.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将撤销/重做功能扩展到节点树。
- en: In addition to the existing undo/redo operations, add code to support reverting
    and re-reverting any operations in node trees. It would be helpful to be able
    to undo accidental changes, like deleting a connection or node.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了现有的撤销/重做操作外，添加代码以支持在节点树中回滚和重新回滚任何操作。能够撤销意外更改，例如删除一个连接或节点，将会很有帮助。
- en: Create an **Apply changes** button for updating the instances.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**应用更改**按钮以更新实例。
- en: Implement a simpler way to update the copies of a changed node tree for all
    instances that are using this tree.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一种更简单的方法来更新使用此树的所有实例中更改的节点树的副本。
- en: Load node trees from a running instance into the editor.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从运行实例中加载节点树到编辑器中。
- en: This is a good idea for debugging purposes, but probably also fun to watch what
    happens in real time in the node tree of an instance.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于调试目的来说是个好主意，但也许也很有趣，可以实时观察实例的节点树中发生了什么。
- en: Add a real-time debug visualization of the loaded node tree.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加加载的节点树的实时调试可视化。
- en: Visual debugging could help a lot with understanding what happens in a node
    tree. You could start by highlighting the currently active node in the graph of
    the selected instance (see the previous task) and later also highlight the currently
    active output pin plus the outgoing connections to other nodes.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 可视调试可以帮助理解节点树中发生了什么。你可以从突出显示所选实例的图中当前活动的节点开始（参见上一个任务），稍后也可以突出显示当前活动的输出引脚以及指向其他节点的输出连接。
- en: React to the creation of new links in imnodes.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对imnodes中创建的新链接做出反应。
- en: Instead of having to create a new node and then place a link, add the context
    menu to create a node when a new link is created but not attached. Connect the
    dangling link directly to the input or output pin of the new node.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是创建一个新的节点然后放置一个链接，当创建一个新链接但未连接时添加上下文菜单以创建节点。将悬空链接直接连接到新节点的输入或输出引脚。
- en: Let the sequence node also wait for grandchildren.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让序列节点也等待孙子节点。
- en: You could add a cascade of notifications about entire sub-sequences having finished
    execution, not just wait and RandomWait nodes – maybe with an extra checkbox to
    control which child node in the chain is the last one to wait for.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加关于整个子序列执行完成的通知级联，而不仅仅是等待和随机等待节点——也许可以添加一个额外的复选框来控制链中哪个子节点是最后一个等待的。
- en: Add condition and loop nodes.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加条件和循环节点。
- en: Enable more control. The condition node needs access to data it should react
    on, either from the instance, the world, or from other nodes. The loop node must
    also wait for the child nodes to finish.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 增加更多控制。条件节点需要访问它应该对其做出反应的数据，无论是来自实例、世界还是来自其他节点。循环节点也必须等待子节点完成。
- en: Allow renaming and copy/paste for entire node trees, or between editor windows.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许重命名和复制/粘贴整个节点树，或者在不同编辑器窗口之间进行。
- en: Extend the current implementation by adding the ability to rename existing node
    trees. Creating a copy of an entire node tree may become handy to duplicate and
    adjust existing behavior, and a copy/paste operation of nodes or entire selections
    between two editor sessions would be a blast.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加重命名现有节点树的能力来扩展当前实现。创建整个节点树的副本可能有助于复制和调整现有行为，并且两个编辑器会话之间的节点或整个选择复制/粘贴操作将非常方便。
- en: Show more than one tree node in the editor window.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编辑器窗口中显示多个树节点。
- en: Either by using dockable ImGui windows or just opening more editor windows,
    let the user work on multiple node trees at the same time.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 要么通过使用可停靠的 ImGui 窗口，要么只是打开更多的编辑器窗口，让用户能够同时处理多个节点树。
- en: 'Caveat: If more than one window is shown, the internal ImGui IDs must be unique
    among all UI elements in the windows.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果显示多个窗口，则内部 ImGui IDs 必须在所有窗口的 UI 元素中是唯一的。
- en: 'Enhanced difficulty: Integrate a full C++ behavior tree library.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强难度：集成完整的 C++ 行为树库。
- en: Instead of this small and hand-crafted node tree version, add a full-featured
    behavior tree from a third-party library and add imnodes support for the tree
    management.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是这个小型且手工制作的节点树版本，添加一个功能齐全的行为树库，并为树管理添加 imnodes 支持。
- en: Additional resources
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'Introduction to behavior trees: [https://robohub.org/introduction-to-behavior-trees/](https://robohub.org/introduction-to-behavior-trees/)'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为树简介：[https://robohub.org/introduction-to-behavior-trees/](https://robohub.org/introduction-to-behavior-trees/)
- en: 'Behavior Trees: Breaking the Cycle of Misuse: [https://takinginitiative.net/wp-content/uploads/2020/01/behaviortrees_breaking-the-cycle-of-misuse.pdf](https://takinginitiative.net/wp-content/uploads/2020/01/behaviortrees_breaking-the-cycle-of-misuse.pdf)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为树：打破误用的循环：[https://takinginitiative.net/wp-content/uploads/2020/01/behaviortrees_breaking-the-cycle-of-misuse.pdf](https://takinginitiative.net/wp-content/uploads/2020/01/behaviortrees_breaking-the-cycle-of-misuse.pdf)
- en: 'A simple C++ behavior tree example: [https://lisyarus.github.io/blog/posts/behavior-trees.html](https://lisyarus.github.io/blog/posts/behavior-trees.html)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的 C++ 行为树示例：[https://lisyarus.github.io/blog/posts/behavior-trees.html](https://lisyarus.github.io/blog/posts/behavior-trees.html)
- en: 'Node Graph Editors with ImGui: [https://github.com/ocornut/imgui/issues/306](https://github.com/ocornut/imgui/issues/306)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 ImGui 的节点图编辑器：[https://github.com/ocornut/imgui/issues/306](https://github.com/ocornut/imgui/issues/306)
- en: 'imnodes extension for ImGui: [https://github.com/Nelarius/imnodes](https://github.com/Nelarius/imnodes)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ImGui 的 imnodes 扩展：[https://github.com/Nelarius/imnodes](https://github.com/Nelarius/imnodes)
- en: Join our community on Discord
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：[https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/QR_code_Discord.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色方块的二维码 AI 生成的内容可能不正确。](img/QR_code_Discord.png)'
