["```cpp\nUCLASS()\nclass GOLDENEGG_API AMonster : public ACharacter\n{\n  GENERATED_UCLASS_BODY()\n\n  // How fast he is\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)\n  float Speed;\n\n  // The hitpoints the monster has\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)\n  float HitPoints;\n\n  // Experience gained for defeating\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)\n  int32 Experience;\n\n  // Blueprint of the type of item dropped by the monster\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)\n  UClass* BPLoot;\n\n  // The amount of damage attacks do\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)\n  float BaseAttackDamage;\n\n  // Amount of time the monster needs to rest in seconds\n  // between attacking\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)\n  float AttackTimeout;\n\n  // Time since monster's last strike, readable in blueprints\n  UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =  MonsterProperties)\n  float TimeSinceLastStrike;\n\n  // Range for his sight\n  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  Collision)\n  USphereComponent* SightSphere;\n\n  // Range for his attack. Visualizes as a sphere in editor,\n  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  Collision)\n  USphereComponent* AttackRangeSphere;\n};\n```", "```cpp\nAMonster::AMonster(const class FObjectInitializer& PCIP) : Super(PCIP)\n{\n  Speed = 20;\n  HitPoints = 20;\n  Experience = 0;\n  BPLoot = NULL;\n  BaseAttackDamage = 1;\n  AttackTimeout = 1.5f;\n  TimeSinceLastStrike = 0;\n\n  SightSphere = PCIP.CreateDefaultSubobject<USphereComponent> (this, TEXT(\"SightSphere\"));\n  SightSphere->AttachTo( RootComponent );\n\n  AttackRangeSphere = PCIP.CreateDefaultSubobject <USphereComponent>(this, TEXT(\"AttackRangeSphere\"));\n  AttackRangeSphere->AttachTo( RootComponent );\n}\n```", "```cpp\nvirtual void Tick(float DeltaSeconds) override;\n```", "```cpp\nvoid AMonster::Tick(float DeltaSeconds)\n{\n  Super::Tick( DeltaSeconds );\n\n  // basic intel: move the monster towards the player\n  AAvatar *avatar = Cast<AAvatar>(  UGameplayStatics::GetPlayerPawn(GetWorld(), 0) );\n  if( !avatar ) return;\n\n  FVector toPlayer = avatar->GetActorLocation() -  GetActorLocation();\n  toPlayer.Normalize();\t// reduce to unit vector\n\n  // Actually move the monster towards the player a bit\n  AddMovementInput(toPlayer, Speed*DeltaSeconds);\n\n  // At least face the target\n  // Gets you the rotator to turn something\n  // that looks in the `toPlayer` direction\n  FRotator toPlayerRotation = toPlayer.Rotation();\n  toPlayerRotation.Pitch = 0; // 0 off the pitch\n  RootComponent->SetWorldRotation( toPlayerRotation );\n}\n```", "```cpp\nvoid AMonster::Tick(float DeltaSeconds)\n{\n  Super::Tick( DeltaSeconds );\n  AAvatar *avatar = Cast<AAvatar>(  UGameplayStatics::GetPlayerPawn(GetWorld(), 0) );\n  if( !avatar ) return;\n    FVector toPlayer = avatar->GetActorLocation() -  GetActorLocation();\n  float distanceToPlayer = toPlayer.Size();\n  // If the player is not in the SightSphere of the monster,\n  // go back\n  if( distanceToPlayer > SightSphere->GetScaledSphereRadius() )\n  {\n    // If the player is out of sight,\n    // then the enemy cannot chase\n    return;\n  }\n\n  toPlayer /= distanceToPlayer;  // normalizes the vector\n  // Actually move the monster towards the player a bit\n  AddMovementInput(toPlayer, Speed*DeltaSeconds);\n  // (rest of function same as before (rotation))\n}\n```", "```cpp\ninline bool isInSightRange( float d )\n{ return d < SightSphere->GetScaledSphereRadius(); }\ninline bool isInAttackRange( float d )\n{ return d < AttackRangeSphere->GetScaledSphereRadius(); }\n```", "```cpp\nclass AMonster;\n\nUCLASS()\nclass GOLDENEGG_API AMeleeWeapon : public AActor\n{\n  GENERATED_UCLASS_BODY()\n\n  // The amount of damage attacks by this weapon do\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MeleeWeapon)\n  float AttackDamage;\n\n  // A list of things the melee weapon already hit this swing\n  // Ensures each thing sword passes thru only gets hit once\n  TArray<AActor*> ThingsHit;\n\n  // prevents damage from occurring in frames where\n  // the sword is not swinging\n  bool Swinging;\n\n  // \"Stop hitting yourself\" - used to check if the \n  // actor holding the weapon is hitting himself\n  AMonster *WeaponHolder;\n\n  // bounding box that determines when melee weapon hit\n  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  MeleeWeapon)\n  UBoxComponent* ProxBox;\n\n  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  MeleeWeapon)\n  UStaticMeshComponent* Mesh;\n\n  UFUNCTION(BlueprintNativeEvent, Category = Collision)\n  void Prox( AActor* OtherActor, UPrimitiveComponent* OtherComp,  int32 OtherBodyIndex, bool bFromSweep, const FHitResult &  SweepResult );\n  void Swing();\n  void Rest();\n};\n```", "```cpp\nAMeleeWeapon::AMeleeWeapon(const class FObjectInitializer& PCIP) :  Super(PCIP)\n{\n  AttackDamage = 1;\n  Swinging = false;\n  WeaponHolder = NULL;\n\n  Mesh = PCIP.CreateDefaultSubobject<UStaticMeshComponent>(this,  TEXT(\"Mesh\"));\n  RootComponent = Mesh;\n\n  ProxBox = PCIP.CreateDefaultSubobject<UBoxComponent>(this,  TEXT(\"ProxBox\"));\n  ProxBox->OnComponentBeginOverlap.AddDynamic( this,  &AMeleeWeapon::Prox );\n  ProxBox->AttachTo( RootComponent );\n}\n\nvoid AMeleeWeapon::Prox_Implementation( AActor* OtherActor,  UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool  bFromSweep, const FHitResult & SweepResult )\n{\n  // don't hit non root components\n  if( OtherComp != OtherActor->GetRootComponent() )\n  {\n    return;\n  }\n\n  // avoid hitting things while sword isn't swinging,\n  // avoid hitting yourself, and\n  // avoid hitting the same OtherActor twice\n  if( Swinging && OtherActor != WeaponHolder &&  !ThingsHit.Contains(OtherActor) )\n  {\n    OtherActor->TakeDamage( AttackDamage + WeaponHolder- >BaseAttackDamage, FDamageEvent(), NULL, this );\n    ThingsHit.Add( OtherActor );\n  }\n}\nvoid AMeleeWeapon::Swing()\n{\n  ThingsHit.Empty();  // empty the list\n  Swinging = true;\n}\nvoid AMeleeWeapon::Rest()\n{\n  ThingsHit.Empty();\n  Swinging = false;\n}\n```", "```cpp\n// The MeleeWeapon class the monster uses\n// If this is not set, he uses a melee attack\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)\nUClass* BPMeleeWeapon;\n\n// The MeleeWeapon instance (set if the character is using\n// a melee weapon)\nAActor* MeleeWeapon;\n```", "```cpp\nvirtual void PostInitializeComponents() override;\n```", "```cpp\nvoid AMonster::PostInitializeComponents()\n{\n  Super::PostInitializeComponents();\n\n  // instantiate the melee weapon if a bp was selected\n  if( BPMeleeWeapon )\n  {\n    MeleeWeapon = GetWorld()->SpawnActor<AMeleeWeapon>(\n      BPMeleeWeapon, FVector(), FRotator() );\n\n    if( MeleeWeapon )\n    {\n      const USkeletalMeshSocket *socket = Mesh->GetSocketByName(  \"RightHandSocket\" ); // be sure to use correct\n                           // socket name!\n      socket->AttachActor( MeleeWeapon, Mesh );\n    }\n  }\n}\n```", "```cpp\nif( Monster.isInAttackRangeOfPlayer() )\n{\n  Monster.Animation = The Attack Animation;\n}\n```", "```cpp\n// in Monster.h:\nUFUNCTION( BlueprintCallable, Category = Collision )\nvoid SwordSwung();\n```", "```cpp\n// in Monster.cpp\nvoid AMonster::SwordSwung()\n{\n  if( MeleeWeapon )\n  {\n    MeleeWeapon->Swing();\n  }\n}\n```", "```cpp\nUCLASS()\nclass GOLDENEGG_API ABullet : public AActor\n{\n  GENERATED_UCLASS_BODY()\n\n  // How much damage the bullet does.\n  UPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  Properties)\n  float Damage;\n\n  // The visible Mesh for the component, so we can see\n  // the shooting object\n  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  Collision)\n  UStaticMeshComponent* Mesh;\n\n  // the sphere you collide with to do impact damage\n  UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category =  Collision)\n  USphereComponent* ProxSphere;\n\n  UFUNCTION(BlueprintNativeEvent, Category = Collision)\n  void Prox( AActor* OtherActor, UPrimitiveComponent* OtherComp,  int32 OtherBodyIndex, bool bFromSweep, const FHitResult &  SweepResult );\n};\n```", "```cpp\nABullet::ABullet(const class FObjectInitializer& PCIP) : Super(PCIP)\n{\n  Mesh = PCIP.CreateDefaultSubobject<UStaticMeshComponent>(this,  TEXT(\"Mesh\"));\n  RootComponent = Mesh;\n\n  ProxSphere = PCIP.CreateDefaultSubobject<USphereComponent>(this,  TEXT(\"ProxSphere\"));\n  ProxSphere->AttachTo( RootComponent );\n\n  ProxSphere->OnComponentBeginOverlap.AddDynamic( this,  &ABullet::Prox );\n  Damage = 1;\n}\n```", "```cpp\nvoid ABullet::Prox_Implementation( AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult & SweepResult )\n{\n  if( OtherComp != OtherActor->GetRootComponent() )\n  {\n    // don't collide w/ anything other than\n    // the actor's root component\n    return;\n  }\n\n  OtherActor->TakeDamage( Damage, FDamageEvent(), NULL, this );\n  Destroy();\n}\n```", "```cpp\n// The blueprint of the bullet class the monster uses\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)\nUClass* BPBullet;\n// Thrust behind bullet launches\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category =  MonsterProperties)\nfloat BulletLaunchImpulse;\n```", "```cpp\nvoid AMonster::Tick(float DeltaSeconds)\n{\n  Super::Tick( DeltaSeconds );\n\n  // move the monster towards the player\n  AAvatar *avatar = Cast<AAvatar>(  UGameplayStatics::GetPlayerPawn(GetWorld(), 0) );\n  if( !avatar ) return;\n\n  FVector playerPos = avatar->GetActorLocation();\n  FVector toPlayer = playerPos - GetActorLocation();\n  float distanceToPlayer = toPlayer.Size();\n\n  // If the player is not the SightSphere of the monster,\n  // go back\n  if( distanceToPlayer > SightSphere->GetScaledSphereRadius() )\n  {\n    // If the player is OS, then the enemy cannot chase\n    return;\n  }\n\n  toPlayer /= distanceToPlayer;  // normalizes the vector\n\n  // At least face the target\n  // Gets you the rotator to turn something\n  // that looks in the `toPlayer` direction\n  FRotator toPlayerRotation = toPlayer.Rotation();\n  toPlayerRotation.Pitch = 0; // 0 off the pitch\n  RootComponent->SetWorldRotation( toPlayerRotation );\n\n  if( isInAttackRange(distanceToPlayer) )\n  {\n    // Perform the attack\n    if( !TimeSinceLastStrike )\n    {\n      Attack(avatar);\n    }\n\n    TimeSinceLastStrike += DeltaSeconds;\n    if( TimeSinceLastStrike > AttackTimeout )\n    {\n      TimeSinceLastStrike = 0;\n    }\n\n    return;  // nothing else to do\n  }\n  else\n  {\n    // not in attack range, so walk towards player\n    AddMovementInput(toPlayer, Speed*DeltaSeconds);\n  }\n}\n```", "```cpp\nvoid AMonster::Attack(AActor* thing);\n```", "```cpp\nvoid AMonster::Attack(AActor* thing)\n{\n  if( MeleeWeapon )\n  {\n    // code for the melee weapon swing, if \n    // a melee weapon is used\n    MeleeWeapon->Swing();\n  }\n  else if( BPBullet )\n  {\n    // If a blueprint for a bullet to use was assigned,\n    // then use that. Note we wouldn't execute this code\n    // bullet firing code if a MeleeWeapon was equipped\n    FVector fwd = GetActorForwardVector();\n    FVector nozzle = GetMesh()->GetBoneLocation( \"RightHand\" );\n    nozzle += fwd * 155;// move it fwd of the monster so it  doesn't\n    // collide with the monster model\n    FVector toOpponent = thing->GetActorLocation() - nozzle;\n    toOpponent.Normalize();\n    ABullet *bullet = GetWorld()->SpawnActor<ABullet>(  BPBullet, nozzle, RootComponent->GetComponentRotation());\n\n    if( bullet )\n    {\n      bullet->Firer = this;\n      bullet->ProxSphere->AddImpulse( \n        fwd*BulletLaunchImpulse );\n    }\n    else\n    {\n      GEngine->AddOnScreenDebugMessage( 0, 5.f, \n      FColor::Yellow, \"monster: no bullet actor could be spawned.  is the bullet overlapping something?\" );\n    }\n  }\n}\n```", "```cpp\nABullet *bullet = GetWorld()->SpawnActor<ABullet>(BPBullet,  nozzle, RootComponent->GetComponentRotation() );\n```", "```cpp\nFVector knockback; // in class AAvatar\n```", "```cpp\nfloat AAvatar::TakeDamage(float Damage, struct FDamageEvent const&  DamageEvent, AController* EventInstigator, AActor* DamageCauser)\n{\n  // add some knockback that gets applied over a few frames\n  knockback = GetActorLocation() - DamageCauser- >GetActorLocation();\n  knockback.Normalize();\n  knockback *= Damage * 500; // knockback proportional to damage\n}\n```", "```cpp\nvoid AAvatar::Tick( float DeltaSeconds )\n{\n  Super::Tick( DeltaSeconds );\n\n  // apply knockback vector\n  AddMovementInput( knockback, 1.f );\n\n  // half the size of the knockback each frame\n  knockback *= 0.5f;\n}\n```"]