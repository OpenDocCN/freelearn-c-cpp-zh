<html><head></head><body>
		<div><p><a id="_idTextAnchor017"/></p>
			<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor018"/>1</h1>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor019"/>Setting up a Server</h1>
			<p>Welcome to <em class="italic">The Essential Guide to Creating Multiplayer Games with Godot 4.0</em>. In this hands-on book, you are going to learn the core concepts used to create online multiplayer games using the Godot Engine 4.0 Network API.</p>
			<p>Firstly, we are going to understand some fundamental aspects of how computers communicate through a network and the main protocols, including which ones are more relevant for making online multiplayer games.</p>
			<p>After that, we will understand how Godot Engine 4.0 uses and provides both low- and high-level implementations for networking using its network API. We’ll understand some core classes that we can use to pass data around to multiple computers on the same network. And then we’ll focus on the high-level API known as <code>ENetMultiplayerPeer</code>.</p>
			<p>With the fundamentals in place, we’ll use the knowledge we just learned to turn local gameplay features into online gameplay features. To do that, we will develop five game projects:</p>
			<ul>
				<li>An online quiz game</li>
				<li>Checkers</li>
				<li>Pong</li>
				<li>A co-op platformer</li>
				<li>A top-down adventure</li>
			</ul>
			<p>Then, we’ll learn some techniques we can use to improve our players’ experience by optimizing how their game sends, receives, and processes network data. We’ll understand that we don’t need constant updates and that we can do most of the gameplay with small bits of data and let the clients’ computers fill the gaps on their own.</p>
			<p>Throughout each chapter, you’re going to do a role play of a network engineer working for a fictional, independent game development studio. In each chapter, you will apply your recently learned knowledge to a fictional problem presented by your studio’s peers. You’ll focus on the network aspect of each project they present, so you don’t waste your precious time trying to understand unnecessary aspects.</p>
			<p>In this chapter, you are going to learn the most important aspect of establishing a network of computers: to connect them all together. You’ll see how this process happens, the reason for doing this, what’s required to establish this connection, and how we can do that using the API that Godot Engine provides.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introduction to a network</li>
				<li>Understanding the Godot Engine Network API</li>
				<li>Setting up the client side</li>
				<li>Setting up the server side</li>
				<li>Making your first handshake</li>
			</ul>
			<p>By the end of the chapter, you’ll have a client and server version of an application that establishes the connection of two or more computers. This is the very core of everything that we are going to see throughout the book, and with that knowledge, you’ll understand how you can start making computers communicate within a network, which is exactly what you need to do in online multiplayer games.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor020"/>Technical requirements</h1>
			<p>Godot Engine has its own standalone text editor, which is what we are going to use to code all our practical lessons.</p>
			<p>As mentioned earlier, in this book you will do a role play of a network engineer of a fictional indie game studio. So, we will provide pre-made projects with all the non-network-related work ready. You can find them in the book’s GitHub repository: <a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</a>.</p>
			<p>With the project properly added to your Godot Engine’s project manager, open the project and move on to the <code>res://01.setting-up-a-server</code> folder. Here, you'll find what you need to follow this chapter (later part).</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor021"/>Introduction to a network</h1>
			<p>Making a network of connected computers is quite a task. In this chapter, we’ll understand the core concepts of online networks. We’ll also cover how Godot Engine provides solutions to each of the problems we may face in our quest to make online multiplayer games.</p>
			<p>A <strong class="bold">network</strong> is<a id="_idIndexMarker000"/> a collection of interconnected devices that communicate with each other. In this communication, these devices exchange information and share resources with each other. You can have a local network, such as in a house or office, or a global network, such as the internet. The idea is the same.</p>
			<p>For these devices to communicate they need to perform what we call a <strong class="bold">handshake</strong>. A handshake<a id="_idIndexMarker001"/> is how one device recognizes another device and establishes their communication protocols. This way, they know what they can request, what they expect to get, and what they need to send to one another.</p>
			<p>A handshake begins with one device sending a message to another device. We call this message<a id="_idIndexMarker002"/> a <em class="italic">handshake request</em>. The devices use this message to start the handshake process. The one that sent the request waits for a message from the one that received it. We call this<a id="_idIndexMarker003"/> second message a <em class="italic">handshake response</em>.</p>
			<div><div><img alt="Figure 1.1 – The handshake procedure" src="img/Figure_01.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – The handshake procedure</p>
			<p>When the requested device sends the confirmation through the handshake response, they establish their communication. After that, the devices start exchanging data. This wraps up the<a id="_idIndexMarker004"/> handshake process. We usually call the device that requests data the <em class="italic">client</em>. As for the one that provides data, we call<a id="_idIndexMarker005"/> it the <em class="italic">server</em>.</p>
			<p>Note that we use these names for the very first interaction. After this first interaction, it is common that these roles change. In that sense, communication is <em class="italic">dynamic</em>. The server may request data from the client, and the client may provide data to the server.</p>
			<p>In this chapter, we are going to make our first handshake<a id="_idIndexMarker006"/> using the Godot Engine Network API. We’ll also create and synchronize players’ data across the network. So, hold tight, as you’ll learn the following:</p>
			<ul>
				<li>What the ENet library is and why we use it for games</li>
				<li>How we can make a handshake using the <code>ENetMultiplayerPeer</code> class</li>
			</ul>
			<p>For that, you’ll create a Godot project that lists connected players and allows them to edit and sync a line of text. It’s a simple but elegant project that covers the basics of setting up an online multiplayer environment in Godot En<a id="_idTextAnchor022"/>gine.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor023"/>Understanding the ENetMultiplayerPeer class</h1>
			<p>One of the Godot Engine Network API’s core features<a id="_idIndexMarker007"/> is the <code>ENetMultiplayerPeer</code> class. By using this class, we can perform a handshake between our game server and clients.</p>
			<p>The <code>ENetMultiplayerPeer</code> class is a high-level implementation of the ENet library. Let’s understand this library and why we use it in online multiplayer <a id="_idTextAnchor024"/>games.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor025"/>What is the ENet library?</h2>
			<p><strong class="bold">ENet</strong> is a<a id="_idIndexMarker008"/> lightweight, open source networking library that is widely used in the game development industry. It is designed to be a high-performance, reliable, and easy-to-use library for creating multiplayer games and other networked applications. One advantage of the ENet library is that it’s cross-platform and written<a id="_idIndexMarker009"/> in <strong class="bold">C</strong>. So, it’s efficient with a small footprint and low overhead.</p>
			<p>The library provides a simple and easy-to-use API that makes it easy for developers to create and manage network connections, send and receive packets, and handle network events such as disconnections and packet loss.</p>
			<p><strong class="bold">Packets</strong>, in this<a id="_idIndexMarker010"/> context, are small units of data that servers and clients transmit over the network. We use them to transmit information such as game state, player input, and other types of data between different devices on the network.</p>
			<p>The ENet<a id="_idIndexMarker011"/> library offers support for multiple channels that allow us to easily create multiple streams of data, such as voice and video, within a single connection. This is excellent for many multiplayer games.</p>
			<p>Another reason to use ENet in multiplayer games is its easy-to-use networking library that is based on the UDP protocol. This is a good chance to understand one of the main network protocols, so le<a id="_idTextAnchor026"/>t’s do it.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor027"/>What is the UDP protocol?</h1>
			<p>The <strong class="bold">UDP protocol</strong> is a<a id="_idIndexMarker012"/> connectionless protocol that is well suited for real-time, high-bandwidth applications such as online gaming. This is because it has low latency and is able to handle high throughput. Just so we are on the same page, in the world of network terms, latency refers to the time between the transmission and receiving of data through the network.</p>
			<p>For instance, it’s very common to talk about lag in online multiplayer games: the time between the player performing an action and the game reacting to it. The next figure illustrates how latency<a id="_idIndexMarker013"/> works and is calculated:</p>
			<div><div><img alt="Figure 1.2 – Visual demonstration of latency" src="img/Figure_01.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Visual demonstration of latency</p>
			<p>It’s basically how much time it takes for data to cross the network, be properly handled by the server, and to provide a response to the client.</p>
			<p>Throughput<a id="_idIndexMarker014"/> refers to how much data we can send through a given network route within a time period before it gets overwhelmed. For instance, this is a fundamental concept when we talk about <strong class="bold">DDoS attacks</strong>, where <a id="_idIndexMarker015"/>hackers overwhelm the server with an immense number of unsolved requests, preventing other clients from accessing the service. In the following figure, you can see a visual representation of the throughput concept:</p>
			<div><div><img alt="Figure 1.3 – Visual demonstration of throughput" src="img/Figure_01.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Visual demonstration of throughput</p>
			<p>The bandwidth<a id="_idIndexMarker016"/> is how big the available channel of communication in the network is. You can think of it as a pipe that streams data. A bigger pipe allows a lot of data, and big data, to be transmitted at any given time, while a small pipe may not even allow any data, of any size, to be transmitted. You can see this concept illustrated in the following figure:</p>
			<div><div><img alt="Figure 1.4 – Visual demonstration of bandwidth" src="img/Figure_01.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Visual demonstration of bandwidth</p>
			<p>Unlike the more<a id="_idIndexMarker017"/> commonly used <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>), <strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>) does not establish a dedicated connection between two devices <a id="_idIndexMarker018"/>before transmitting data. Instead, it simply sends packets of data to a specified destination address without ensuring that the packets have been received or acknowledged.</p>
			<p>Sounds… bad, right? But it’s quite the opposite.</p>
			<p>This lack of reliability is often seen as a drawback of UDP, but in the context of online multiplayer games, it can actually be an advantage. In games, where responsiveness and low latency are critical, the overhead of establishing and maintaining a connection can be a significant bottleneck.</p>
			<p>By not requiring a dedicated connection, UDP allows for faster and more efficient transmission of data. Additionally, since UDP does not require the receiver to acknowledge receipt of packets, it is less affected by network congestion or delays, which can be critical for maintaining a stable and responsive connection in a high-bandwidth, high-latency environment such as online gaming.</p>
			<p>Furthermore, the lack of reliability of <a id="_idIndexMarker019"/>UDP can actually be beneficial in the context of online multiplayer games. In games, where a small amount of packet loss or delay can have a large impact on the players’ experience, it’s important that the game can adapt to these types of network conditions. By not providing guarantees on packet delivery, UDP allows the game to handle packet loss and delay in a way that is most appropriate for the specific game and its mechanics.</p>
			<p>Think about the following situation.</p>
			<p>We establish a connection. In this connection, we update all players in the network about all other player avatars’ positions in the world. This way, everyone shares the same world state.</p>
			<p>If we use a<a id="_idIndexMarker020"/> TCP protocol, everyone will have to wait for every other player to send their position and confirm that they have received every change in every other player’s position, while also trying to maintain the correct chronological order in which the positions have changed.</p>
			<p>So, in this example, if a player moves five units to the left and sends 15 packets with all the movement data, including being idle, all other players must confirm that they have received all those 15 packets.</p>
			<p>Using UDP, players can ignore every update but the latest one, which is the only relevant piece of information in real-time experience: what is the game-world state <em class="italic">now</em>? It doesn’t matter how it gets to this point; it only matters that it is there at this very moment.</p>
			<p>We are going to see that this causes some trouble as well. But we can create methods and understand techniques to mitigate those issues. We are going to talk about that in f<a id="_idTextAnchor028"/>urther chapters.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor029"/>How does this connection happen?</h1>
			<p>To establish<a id="_idIndexMarker021"/> a UDP connection, we need two core things:</p>
			<ul>
				<li>The IP address of the peers, mainly the server</li>
				<li>The port over which they will exchange data</li>
			</ul>
			<p>For test purposes, on all our projects we are going to use the <code>localhost</code> IP address. This is a shortcut to your local IP address mask. An IP address<a id="_idIndexMarker022"/> is like a house or apartment address. It is the exact location to which a given packet should be delivered and represents the address of the computer in the network. A port<a id="_idIndexMarker023"/> is essentially a specific channel in which the host allows a given communication to be established; we’ll use the <code>9999</code> as our default port. There’s nothing special about this one; it’s just an arbitrary pick.</p>
			<p>With this in mind, let’s see for the first time the <code>ENetMultiplayerPeer</code> class in action. As you can imagine, this setup requires a two-sided approach. We need to set up a game architecture for our server and a different architecture for our client.</p>
			<p>Let’s start with the s<a id="_idTextAnchor030"/>erver architecture.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor031"/>Creating the server</h2>
			<p>The <code>ENetMultiplayerPeer</code> class in the Godot Engine provides a convenient way to create and manage network connections for online multiplayer games. One of the most important methods of this <a id="_idIndexMarker024"/>class is the <code>create_server()</code> method, which is used to create a new server that can accept connections from clients. This method is simple to use and, besides having five arguments, it only requires one to get started:</p>
			<ul>
				<li>The first argument of the <code>ENetMultiplayerPeer.create_server()</code> method is the port on which the server will listen for incoming connections. This is the port number that clients will use to connect to the server. For example, if you want the server to listen on port <code>9999</code>, you would call <code>ENetMultiplayerPeer.create_server(9999)</code>. This is the only mandatory argument to call this method.</li>
				<li>The second argument is <code>max_clients</code>, which is the maximum number of clients that the server will allow to connect at the same time. This argument is optional, and if not specified, the server will allow up to 4,095 clients to connect.</li>
				<li>The third argument is <code>max_channels</code>, which is the maximum number of channels we allow the server to use per client. Channels are used to separate different types of data, such as voice and video, and are useful for creating multiple streams of data within a single connection. This argument is optional, and if not specified, the server will allow an unlimited number of channels.</li>
				<li>The fourth argument is <code>in_bandwidth</code>, which is the maximum incoming bandwidth that the server will allow per client. This argument is optional, and if not specified, the server will allow unlimited incoming bandwidth.</li>
				<li>The fifth argument is <code>out_bandwidth</code>, which is the maximum outgoing bandwidth that the server will allow per client. This argument is optional, and if not specified, the server will allow unlimited outgoing bandwidth.</li>
			</ul>
			<p>Let’s create our <a id="_idIndexMarker025"/>server in Godot Engine. Open up the project provided in the GitHub link given previously. After opening the project, execute the following steps:</p>
			<ol>
				<li>Create a new scene and use a <code>Node</code> instance as the root.</li>
				<li>Attach a new <code>Server.gd</code>.</li>
				<li>Save the scene and open the script.</li>
				<li>Define a constant called <code>PORT</code> and set it to our default port number so the server can listen to it:<pre class="source-code">
const PORT = 9999</pre></li>				<li>Create a new <code>ENetMultiplayerPeer</code> using the <code>new()</code> constructor. Let’s store it in a variable called <code>peer</code>:<pre class="source-code">
var peer = ENetMultiplayerPeer.new()</pre></li>				<li>In the <code>_ready()</code> function, call the <code>create_server()</code> method on the <code>peer</code> variable, passing in the <code>PORT</code> constant as an argument:<pre class="source-code">
func _ready():
    peer.create_server(PORT)</pre></li>				<li>Still in the <code>_ready()</code> callback, assign the <code>peer</code> variable to the built-in <code>multiplayer</code> member variable of this node:<pre class="source-code">
    multiplayer.multiplayer_peer = peer</pre></li>				<li>Connect the <code>peer_connected</code> signal of the <code>multiplayer</code> variable to a function called <code>_on_peer_connected</code>. We’ll create this callback method next:<pre class="source-code">
multiplayer.peer_connected.connect(_on_peer_connected)</pre></li>				<li>Create a new method called <code>_on_peer_connected()</code>, which should receive <code>peer_id</code> as the argument:<pre class="source-code">
func _on_peer_connected(peer_id):</pre></li>				<li>In the <code>_on_peer_connected()</code> function, use <code>print()</code> to print the passed <code>peer_id</code> argument<a id="_idIndexMarker026"/> on the console:<pre class="source-code">
  print(peer_id)</pre><p class="list-inset">The complete script should look like this:</p><pre class="source-code">extends Node
const PORT = 9999
var peer = ENetMultiplayerPeer.new()
func _ready():
    var error = peer.create_server(PORT)
    multiplayer.multiplayer_peer = peer
    multiplayer.peer_connected.connect
        (_on_peer_connected)
func _on_peer_connected(peer_id):
    print(peer_id)</pre></li>			</ol>
			<p>It’s important to note that this script uses the built-in <code>multiplayer</code> member variable that every <code>Node</code> instance <a id="_idIndexMarker027"/>has on Godot Engine 4.0 Network API, which is an instance of the <code>MultiplayerAPI</code> class.</p>
			<p>Done: we have our server ready. Told <a id="_idTextAnchor032"/>you it would be simple!</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor033"/>Creating the client</h2>
			<p>Next up, let’s create our client. The<a id="_idIndexMarker028"/> process is quite similar. The major difference is that the client needs the server IP address to find it on the network.</p>
			<p>We use the <code>ENetMultiplayerPeer.create_client()</code> method to connect a client to a server. This method is very simple to use and requires only two arguments to work:</p>
			<ul>
				<li>The first argument of the <code>create_client()</code> method is the address of the server. This can be either the server’s IP or hostname. For instance, if you want the client to connect to a server with the IP address <code>192.168.1.1</code>, you would call <code>create_client("192.168.1.1")</code>. But to make things simpler, we’ll use <code>"localhost"</code>, which is a shortcut to our own IP address mask.</li>
				<li>The second argument of the <code>create_client()</code> method is the port on which the server is listening for incoming connections. This is the port number that the client will use to connect to the server. For example, if the server is listening on port <code>9999</code>, you would call <code>create_client("192.168.1.1", 9999)</code>.</li>
				<li>The third argument of the <code>create_client()</code> method is <code>channel_count</code>, which is the number of channels that the client will use to communicate with the server. Channels are used to separate different types of data, such as voice and video, and are useful for creating multiple streams of data within a single connection. This argument is optional, and if not specified, the client will use a default value of <code>1</code> channel.</li>
				<li>The fourth argument of the <code>create_client()</code> method is <code>in_bandwidth</code>, which is the maximum incoming bandwidth that the client will allow per connection. This argument is optional, and if not specified, the client will use a default value of <code>0</code>, allowing an unlimited incoming bandwidth.</li>
				<li>The fifth argument of the <code>create_client()</code> method is <code>out_bandwidth</code>, which is the maximum outgoing bandwidth that the client will allow per connection. This argument is optional, and if not specified, the client will use a default value of <code>0</code>, allowing an unlimited outgoing bandwidth.</li>
				<li>The sixth argument of the <code>create_client()</code> method is <code>local_port</code>, which is the local port that the client will bind to. This argument is optional, and if not specified, the client will use a default value of <code>0</code>.</li>
			</ul>
			<p>Now, let’s see how we can<a id="_idIndexMarker029"/> create the <em class="italic">client</em> side of this connection so it can connect with our <em class="italic">server</em> and establish their handshake:</p>
			<ol>
				<li>Create a new scene and add a <code>Node</code> instance as the root.</li>
				<li>Attach a new script to it.</li>
				<li>Save the script as <code>Client.gd</code>.</li>
				<li>In the script, define a constant called <code>ADDRESS</code> and set it to the server’s IP. In this case, we are going to use <code>"localhost"</code>:<pre class="source-code">
const ADDRESS = "localhost"</pre></li>				<li>Define a constant called <code>PORT</code> and set it to be our default port number. It’s very important that this matches the number we used in <code>Server.gd</code>, otherwise these peers won’t be able to find each other:<pre class="source-code">
const PORT = 9999</pre></li>				<li>Create a new <code>ENetMultiplayerPeer</code> using the <code>new()</code> constructor and store it in a variable called <code>peer</code>:<pre class="source-code">
var peer = ENetMultiplayerPeer.new()</pre></li>				<li>In the <code>_ready()</code> callback, call the <code>create_client()</code> method on the <code>peer</code> variable, passing in the <code>ADDRESS</code> and <code>PORT</code> constants as arguments:<pre class="source-code">
func _ready():
  peer.create_client(ADDRESS, PORT)</pre></li>				<li>Assign the <code>peer</code> variable to the built-in <code>multiplayer</code> member variable of the node:<pre class="source-code">
multiplayer.multiplayer_peer = peer</pre><p class="list-inset">The complete <a id="_idIndexMarker030"/>script should look like this:</p><pre class="source-code">extends Node
const ADDRESS = "localhost"
const PORT = 9999
var peer = ENetMultiplayerPeer.new()
func _ready():
    peer.create_client(ADDRESS, PORT)
    multiplayer.multiplayer_peer = peer</pre></li>			</ol>
			<p>Alright, we have our server and our client ready.<a id="_idTextAnchor034"/> Now, how do we test them?</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor035"/>Testing our handshake</h2>
			<p>Godot Engine 4.0 has a useful feature for<a id="_idIndexMarker031"/> debugging: the ability to open multiple independent instances of the game. This feature allows us to test different scenes at the same time, making the debugging process much easier and faster.</p>
			<p>To open multiple instances of the game, we need to select one option from up to four options in the <strong class="bold">Debug</strong> | <strong class="bold">Run Multiple </strong><strong class="bold">Instances</strong> menu.</p>
			<div><div><img alt="Figure 1.5 – The Run Multiple Instances menu" src="img/Figure_01.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – The Run Multiple Instances menu</p>
			<p>Then, as soon as we press the <strong class="bold">Run Project</strong> or <strong class="bold">Run Current Scene</strong> button, Godot will launch the instances we’ve set previously. Let’s stick with two instances for this project.</p>
			<p>This feature is incredibly useful for testing online multiplayer games, as it allows us to open a server and a client in the same run. But, as you can see, it’s not very straightforward. When we run the project, it actually opens two instances of the same scene.</p>
			<p>Let’s create a minimal menu <a id="_idIndexMarker032"/>where we can select whether we are a client or a server:</p>
			<ol>
				<li>Create a new scene and use <code>Control</code> as the root and name it <code>MainMenu</code>.</li>
				<li>Add a <code>Label</code> node as a child of the root node.</li>
				<li>Add two <code>Button</code> nodes as children of the root node.</li>
				<li>Give the first <code>Button</code> the name <code>ClientButton</code> and the second one <code>ServerButton</code>:</li>
			</ol>
			<div><div><img alt="Figure 1.6 – MainMenu’s Scene tree structure" src="img/Figure_01.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – MainMenu’s Scene tree structure</p>
			<ol>
				<li value="5">Set the <code>Button</code> nodes’ <code>text</code> properties to <strong class="bold">I’m a client</strong> and <strong class="bold">I’m a server</strong> respectively and position <a id="_idIndexMarker033"/>them side by side in the middle of the screen.</li>
				<li>Set the <code>Label</code> node’s <code>text</code> property to <strong class="bold">Are you a…</strong> and position it in the middle of the screen.</li>
			</ol>
			<div><div><img alt="Figure 1.7 – MainMenu’s scene UI" src="img/Figure_01.07_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – MainMenu’s scene UI</p>
			<ol>
				<li value="7">Attach a new <code>MainMenu</code> node and open it.</li>
				<li>Connect the <code>_on_client_button_pressed</code>.</li>
			</ol>
			<div><div><img alt="Figure 1.8 – ClientButton’s pressed signal connection" src="img/Figure_01.08_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – ClientButton’s pressed signal connection</p>
			<ol>
				<li value="9">Connect the pressed<a id="_idIndexMarker034"/> signal of the <code>_on_server_button_pressed</code>.</li>
				<li>In the <code>_on_client_button_pressed()</code> callback, let’s call the <code>change_scene_to_file()</code> method on the <code>get_tree()</code> instance, passing in <code>"res://Client.tscn"</code> as the argument:<pre class="source-code">
extends Control
func _on_client_pressed():
    get_tree().change_scene_to_file
        ("res://Client.tscn")</pre></li>				<li>In the <code>_on_server_button_pressed()</code> callback, do the same as before, passing <code>"</code><code>res://Server.tscn"</code> instead.<p class="list-inset">The complete script should look like this:</p><pre class="source-code">
extends Control
func _on_client_pressed():
    get_tree().change_scene_to_file
        ("res://Client.tscn")
func _on_server_pressed():
    get_tree().change_scene_to_file("res://Server.tscn")</pre></li>			</ol>
			<p>Now, let’s make sure <a id="_idIndexMarker035"/>we save the scene before we test it. After that, all we need to do is hit the <strong class="bold">Run Current Scene</strong> button and watch the scene come to life. All the hard work has been done, and now all that’s left is to appreciate the results.</p>
			<p>Once we have the two debug instances running, we need to pick one to be the server first. For that, we can press <code>Server.tscn</code> scene and start listening for incoming connections.</p>
			<p>Then, in the other instance, we need to press <code>Client.tscn</code> scene and try to connect to the server. If everything goes as expected, we should get <code>peer_id</code> printed in the console of the server instance.</p>
			<p>This means that the client and the server have successfully established a connection and are now ready to start exchanging messages. Congratulations, you’ve just created your first handshake!</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor036"/>Summary</h1>
			<p>In this chapter, we went through the fundamentals of network connections, which is to establish the connection through a procedure known as the handshake.</p>
			<p>The handshake ensures that two computers recognize each other in a network and establish the protocols of this communication. This is important to understand, as it is the core of all our further endeavors. Without this at our disposal, our players and our server would be disconnected. One would be sending data to the void, while the other would be infinitely waiting for something to arrive.</p>
			<p>Talking about sending data, now that we have our computers connected and open to receive and send data back and forth, it’s time to see how to do that. Throughout this chapter, you saw how you can properly establish a connection using the ENet library and how Godot Engine provides a high-level approach to handshaking, to the point that we can barely see if there was an actual handshake or not.</p>
			<p>In the next chapter, we are going to use the UDP protocol to also establish a connection between client and server. But this time, we are going to dig a bit further and actually send data both from the client to the server and the other way around.</p>
			<p>It’s important to use the UDP protocol to understand what might be happening under the hood when we finally start to get used to the Godot Engine <code>ENetMultiplayer</code> API.</p>
			<p>Now let’s see the dirty and messy world of low-level data transmission in the next chapter, so we can understand later how much easier our lives are made with the new high-level network API!</p>
		</div>
	</body></html>