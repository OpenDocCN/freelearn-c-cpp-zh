<html><head></head><body>
		<div id="_idContainer018">
			<p><a id="_idTextAnchor017"/></p>
			<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor018"/>1</h1>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor019"/>Setting up a Server</h1>
			<p>Welcome to <em class="italic">The Essential Guide to Creating Multiplayer Games with Godot 4.0</em>. In this hands-on book, you are going to learn the core concepts used to create online multiplayer games using the Godot Engine 4.0 <span class="No-Break">Network API.</span></p>
			<p>Firstly, we are going to understand some fundamental aspects of how computers communicate through a network and the main protocols, including which ones are more relevant for making online <span class="No-Break">multiplayer games.</span></p>
			<p>After that, we will understand how Godot Engine 4.0 uses and provides both low- and high-level implementations for networking using its network API. We’ll understand some core classes that we can use to pass data around to multiple computers on the same network. And then we’ll focus on the high-level API known <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">ENetMultiplayerPeer</strong></span><span class="No-Break">.</span></p>
			<p>With the fundamentals in place, we’ll use the knowledge we just learned to turn local gameplay features into online gameplay features. To do that, we will develop five <span class="No-Break">game projects:</span></p>
			<ul>
				<li>An online <span class="No-Break">quiz game</span></li>
				<li><span class="No-Break">Checkers</span></li>
				<li><span class="No-Break">Pong</span></li>
				<li>A <span class="No-Break">co-op platformer</span></li>
				<li>A <span class="No-Break">top-down adventure</span></li>
			</ul>
			<p>Then, we’ll learn some techniques we can use to improve our players’ experience by optimizing how their game sends, receives, and processes network data. We’ll understand that we don’t need constant updates and that we can do most of the gameplay with small bits of data and let the clients’ computers fill the gaps on <span class="No-Break">their own.</span></p>
			<p>Throughout each chapter, you’re going to do a role play of a network engineer working for a fictional, independent game development studio. In each chapter, you will apply your recently learned knowledge to a fictional problem presented by your studio’s peers. You’ll focus on the network aspect of each project they present, so you don’t waste your precious time trying to understand <span class="No-Break">unnecessary aspects.</span></p>
			<p>In this chapter, you are going to learn the most important aspect of establishing a network of computers: to connect them all together. You’ll see how this process happens, the reason for doing this, what’s required to establish this connection, and how we can do that using the API that Godot <span class="No-Break">Engine provides.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Introduction to <span class="No-Break">a network</span></li>
				<li>Understanding the Godot Engine <span class="No-Break">Network API</span></li>
				<li>Setting up the <span class="No-Break">client side</span></li>
				<li>Setting up the <span class="No-Break">server side</span></li>
				<li>Making your <span class="No-Break">first handshake</span></li>
			</ul>
			<p>By the end of the chapter, you’ll have a client and server version of an application that establishes the connection of two or more computers. This is the very core of everything that we are going to see throughout the book, and with that knowledge, you’ll understand how you can start making computers communicate within a network, which is exactly what you need to do in online <span class="No-Break">multiplayer games.</span></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor020"/>Technical requirements</h1>
			<p>Godot Engine has its own standalone text editor, which is what we are going to use to code all our <span class="No-Break">practical lessons.</span></p>
			<p>As mentioned earlier, in this book you will do a role play of a network engineer of a fictional indie game studio. So, we will provide pre-made projects with all the non-network-related work ready. You can find them in the book’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0"><span class="No-Break">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</span></a><span class="No-Break">.</span></p>
			<p>With the project properly added to your Godot Engine’s project manager, open the project and move on to the <strong class="source-inline">res://01.setting-up-a-server</strong> folder. Here, you'll find what you need to follow this chapter (<span class="No-Break">later part).</span></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor021"/>Introduction to a network</h1>
			<p>Making a network of connected computers is quite a task. In this chapter, we’ll understand the core concepts of online networks. We’ll also cover how Godot Engine provides solutions to each of the problems we may face in our quest to make online <span class="No-Break">multiplayer games.</span></p>
			<p>A <strong class="bold">network</strong> is<a id="_idIndexMarker000"/> a collection of interconnected devices that communicate with each other. In this communication, these devices exchange information and share resources with each other. You can have a local network, such as in a house or office, or a global network, such as the internet. The idea is <span class="No-Break">the same.</span></p>
			<p>For these devices to communicate they need to perform what we call a <strong class="bold">handshake</strong>. A handshake<a id="_idIndexMarker001"/> is how one device recognizes another device and establishes their communication protocols. This way, they know what they can request, what they expect to get, and what they need to send to <span class="No-Break">one another.</span></p>
			<p>A handshake begins with one device sending a message to another device. We call this message<a id="_idIndexMarker002"/> a <em class="italic">handshake request</em>. The devices use this message to start the handshake process. The one that sent the request waits for a message from the one that received it. We call this<a id="_idIndexMarker003"/> second message a <span class="No-Break"><em class="italic">handshake response</em></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer010">
					<img alt="Figure 1.1 – The handshake procedure" src="image/Figure_01.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – The handshake procedure</p>
			<p>When the requested device sends the confirmation through the handshake response, they establish their communication. After that, the devices start exchanging data. This wraps up the<a id="_idIndexMarker004"/> handshake process. We usually call the device that requests data the <em class="italic">client</em>. As for the one that provides data, we call<a id="_idIndexMarker005"/> it <span class="No-Break">the </span><span class="No-Break"><em class="italic">server</em></span><span class="No-Break">.</span></p>
			<p>Note that we use these names for the very first interaction. After this first interaction, it is common that these roles change. In that sense, communication is <em class="italic">dynamic</em>. The server may request data from the client, and the client may provide data to <span class="No-Break">the server.</span></p>
			<p>In this chapter, we are going to make our first handshake<a id="_idIndexMarker006"/> using the Godot Engine Network API. We’ll also create and synchronize players’ data across the network. So, hold tight, as you’ll learn <span class="No-Break">the following:</span></p>
			<ul>
				<li>What the ENet library is and why we use it <span class="No-Break">for games</span></li>
				<li>How we can make a handshake using the <span class="No-Break"><strong class="source-inline">ENetMultiplayerPeer</strong></span><span class="No-Break"> class</span></li>
			</ul>
			<p>For that, you’ll create a Godot project that lists connected players and allows them to edit and sync a line of text. It’s a simple but elegant project that covers the basics of setting up an online multiplayer environment in <span class="No-Break">Godot En<a id="_idTextAnchor022"/>gine.</span></p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor023"/>Understanding the ENetMultiplayerPeer class</h1>
			<p>One of the Godot Engine Network API’s core features<a id="_idIndexMarker007"/> is the <strong class="source-inline">ENetMultiplayerPeer</strong> class. By using this class, we can perform a handshake between our game server <span class="No-Break">and clients.</span></p>
			<p>The <strong class="source-inline">ENetMultiplayerPeer</strong> class is a high-level implementation of the ENet library. Let’s understand this library and why we use it in online <span class="No-Break">multiplayer <a id="_idTextAnchor024"/>games.</span></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor025"/>What is the ENet library?</h2>
			<p><strong class="bold">ENet</strong> is a<a id="_idIndexMarker008"/> lightweight, open source networking library that is widely used in the game development industry. It is designed to be a high-performance, reliable, and easy-to-use library for creating multiplayer games and other networked applications. One advantage of the ENet library is that it’s cross-platform and written<a id="_idIndexMarker009"/> in <strong class="bold">C</strong>. So, it’s efficient with a small footprint and <span class="No-Break">low overhead.</span></p>
			<p>The library provides a simple and easy-to-use API that makes it easy for developers to create and manage network connections, send and receive packets, and handle network events such as disconnections and <span class="No-Break">packet loss.</span></p>
			<p><strong class="bold">Packets</strong>, in this<a id="_idIndexMarker010"/> context, are small units of data that servers and clients transmit over the network. We use them to transmit information such as game state, player input, and other types of data between different devices on <span class="No-Break">the network.</span></p>
			<p>The ENet<a id="_idIndexMarker011"/> library offers support for multiple channels that allow us to easily create multiple streams of data, such as voice and video, within a single connection. This is excellent for many <span class="No-Break">multiplayer games.</span></p>
			<p>Another reason to use ENet in multiplayer games is its easy-to-use networking library that is based on the UDP protocol. This is a good chance to understand one of the main network protocols, so le<a id="_idTextAnchor026"/>t’s <span class="No-Break">do it.</span></p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor027"/>What is the UDP protocol?</h1>
			<p>The <strong class="bold">UDP protocol</strong> is a<a id="_idIndexMarker012"/> connectionless protocol that is well suited for real-time, high-bandwidth applications such as online gaming. This is because it has low latency and is able to handle high throughput. Just so we are on the same page, in the world of network terms, latency refers to the time between the transmission and receiving of data through <span class="No-Break">the network.</span></p>
			<p>For instance, it’s very common to talk about lag in online multiplayer games: the time between the player performing an action and the game reacting to it. The next figure illustrates how latency<a id="_idIndexMarker013"/> works and <span class="No-Break">is calculated:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer011">
					<img alt="Figure 1.2 – Visual demonstration of latency" src="image/Figure_01.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Visual demonstration of latency</p>
			<p>It’s basically how much time it takes for data to cross the network, be properly handled by the server, and to provide a response to <span class="No-Break">the client.</span></p>
			<p>Throughput<a id="_idIndexMarker014"/> refers to how much data we can send through a given network route within a time period before it gets overwhelmed. For instance, this is a fundamental concept when we talk about <strong class="bold">DDoS attacks</strong>, where <a id="_idIndexMarker015"/>hackers overwhelm the server with an immense number of unsolved requests, preventing other clients from accessing the service. In the following figure, you can see a visual representation of the <span class="No-Break">throughput concept:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer012">
					<img alt="Figure 1.3 – Visual demonstration of throughput" src="image/Figure_01.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Visual demonstration of throughput</p>
			<p>The bandwidth<a id="_idIndexMarker016"/> is how big the available channel of communication in the network is. You can think of it as a pipe that streams data. A bigger pipe allows a lot of data, and big data, to be transmitted at any given time, while a small pipe may not even allow any data, of any size, to be transmitted. You can see this concept illustrated in the <span class="No-Break">following figure:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer013">
					<img alt="Figure 1.4 – Visual demonstration of bandwidth" src="image/Figure_01.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Visual demonstration of bandwidth</p>
			<p>Unlike the more<a id="_idIndexMarker017"/> commonly used <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>), <strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>) does not establish a dedicated connection between two devices <a id="_idIndexMarker018"/>before transmitting data. Instead, it simply sends packets of data to a specified destination address without ensuring that the packets have been received <span class="No-Break">or acknowledged.</span></p>
			<p>Sounds… bad, right? But it’s quite <span class="No-Break">the opposite.</span></p>
			<p>This lack of reliability is often seen as a drawback of UDP, but in the context of online multiplayer games, it can actually be an advantage. In games, where responsiveness and low latency are critical, the overhead of establishing and maintaining a connection can be a <span class="No-Break">significant bottleneck.</span></p>
			<p>By not requiring a dedicated connection, UDP allows for faster and more efficient transmission of data. Additionally, since UDP does not require the receiver to acknowledge receipt of packets, it is less affected by network congestion or delays, which can be critical for maintaining a stable and responsive connection in a high-bandwidth, high-latency environment such as <span class="No-Break">online gaming.</span></p>
			<p>Furthermore, the lack of reliability of <a id="_idIndexMarker019"/>UDP can actually be beneficial in the context of online multiplayer games. In games, where a small amount of packet loss or delay can have a large impact on the players’ experience, it’s important that the game can adapt to these types of network conditions. By not providing guarantees on packet delivery, UDP allows the game to handle packet loss and delay in a way that is most appropriate for the specific game and <span class="No-Break">its mechanics.</span></p>
			<p>Think about the <span class="No-Break">following situation.</span></p>
			<p>We establish a connection. In this connection, we update all players in the network about all other player avatars’ positions in the world. This way, everyone shares the same <span class="No-Break">world state.</span></p>
			<p>If we use a<a id="_idIndexMarker020"/> TCP protocol, everyone will have to wait for every other player to send their position and confirm that they have received every change in every other player’s position, while also trying to maintain the correct chronological order in which the positions <span class="No-Break">have changed.</span></p>
			<p>So, in this example, if a player moves five units to the left and sends 15 packets with all the movement data, including being idle, all other players must confirm that they have received all those <span class="No-Break">15 packets.</span></p>
			<p>Using UDP, players can ignore every update but the latest one, which is the only relevant piece of information in real-time experience: what is the game-world state <em class="italic">now</em>? It doesn’t matter how it gets to this point; it only matters that it is there at this <span class="No-Break">very moment.</span></p>
			<p>We are going to see that this causes some trouble as well. But we can create methods and understand techniques to mitigate those issues. We are going to talk about that in <span class="No-Break">f<a id="_idTextAnchor028"/>urther chapters.</span></p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor029"/>How does this connection happen?</h1>
			<p>To establish<a id="_idIndexMarker021"/> a UDP connection, we need two <span class="No-Break">core things:</span></p>
			<ul>
				<li>The IP address of the peers, mainly <span class="No-Break">the server</span></li>
				<li>The port over which they will <span class="No-Break">exchange data</span></li>
			</ul>
			<p>For test purposes, on all our projects we are going to use the <strong class="source-inline">localhost</strong> IP address. This is a shortcut to your local IP address mask. An IP address<a id="_idIndexMarker022"/> is like a house or apartment address. It is the exact location to which a given packet should be delivered and represents the address of the computer in the network. A port<a id="_idIndexMarker023"/> is essentially a specific channel in which the host allows a given communication to be established; we’ll use the <strong class="source-inline">9999</strong> as our default port. There’s nothing special about this one; it’s just an <span class="No-Break">arbitrary pick.</span></p>
			<p>With this in mind, let’s see for the first time the <strong class="source-inline">ENetMultiplayerPeer</strong> class in action. As you can imagine, this setup requires a two-sided approach. We need to set up a game architecture for our server and a different architecture for <span class="No-Break">our client.</span></p>
			<p>Let’s start with the <span class="No-Break">s<a id="_idTextAnchor030"/>erver architecture.</span></p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor031"/>Creating the server</h2>
			<p>The <strong class="source-inline">ENetMultiplayerPeer</strong> class in the Godot Engine provides a convenient way to create and manage network connections for online multiplayer games. One of the most important methods of this <a id="_idIndexMarker024"/>class is the <strong class="source-inline">create_server()</strong> method, which is used to create a new server that can accept connections from clients. This method is simple to use and, besides having five arguments, it only requires one to <span class="No-Break">get started:</span></p>
			<ul>
				<li>The first argument of the <strong class="source-inline">ENetMultiplayerPeer.create_server()</strong> method is the port on which the server will listen for incoming connections. This is the port number that clients will use to connect to the server. For example, if you want the server to listen on port <strong class="source-inline">9999</strong>, you would call <strong class="source-inline">ENetMultiplayerPeer.create_server(9999)</strong>. This is the only mandatory argument to call <span class="No-Break">this method.</span></li>
				<li>The second argument is <strong class="source-inline">max_clients</strong>, which is the maximum number of clients that the server will allow to connect at the same time. This argument is optional, and if not specified, the server will allow up to 4,095 clients <span class="No-Break">to connect.</span></li>
				<li>The third argument is <strong class="source-inline">max_channels</strong>, which is the maximum number of channels we allow the server to use per client. Channels are used to separate different types of data, such as voice and video, and are useful for creating multiple streams of data within a single connection. This argument is optional, and if not specified, the server will allow an unlimited number <span class="No-Break">of channels.</span></li>
				<li>The fourth argument is <strong class="source-inline">in_bandwidth</strong>, which is the maximum incoming bandwidth that the server will allow per client. This argument is optional, and if not specified, the server will allow unlimited <span class="No-Break">incoming bandwidth.</span></li>
				<li>The fifth argument is <strong class="source-inline">out_bandwidth</strong>, which is the maximum outgoing bandwidth that the server will allow per client. This argument is optional, and if not specified, the server will allow unlimited <span class="No-Break">outgoing bandwidth.</span></li>
			</ul>
			<p>Let’s create our <a id="_idIndexMarker025"/>server in Godot Engine. Open up the project provided in the GitHub link given previously. After opening the project, execute the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Create a new scene and use a <strong class="source-inline">Node</strong> instance as <span class="No-Break">the root.</span></li>
				<li>Attach a new <strong class="bold">GDScript</strong> to this node, and name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">Server.gd</strong></span><span class="No-Break">.</span></li>
				<li>Save the scene and open <span class="No-Break">the script.</span></li>
				<li>Define a constant called <strong class="source-inline">PORT</strong> and set it to our default port number so the server can listen <span class="No-Break">to it:</span><pre class="source-code">
const PORT = 9999</pre></li>				<li>Create a new <strong class="source-inline">ENetMultiplayerPeer</strong> using the <strong class="source-inline">new()</strong> constructor. Let’s store it in a variable <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">peer</strong></span><span class="No-Break">:</span><pre class="source-code">
var peer = ENetMultiplayerPeer.new()</pre></li>				<li>In the <strong class="source-inline">_ready()</strong> function, call the <strong class="source-inline">create_server()</strong> method on the <strong class="source-inline">peer</strong> variable, passing in the <strong class="source-inline">PORT</strong> constant as <span class="No-Break">an argument:</span><pre class="source-code">
func _ready():
    peer.create_server(PORT)</pre></li>				<li>Still in the <strong class="source-inline">_ready()</strong> callback, assign the <strong class="source-inline">peer</strong> variable to the built-in <strong class="source-inline">multiplayer</strong> member variable of <span class="No-Break">this node:</span><pre class="source-code">
    multiplayer.multiplayer_peer = peer</pre></li>				<li>Connect the <strong class="source-inline">peer_connected</strong> signal of the <strong class="source-inline">multiplayer</strong> variable to a function called <strong class="source-inline">_on_peer_connected</strong>. We’ll create this callback <span class="No-Break">method next:</span><pre class="source-code">
multiplayer.peer_connected.connect(_on_peer_connected)</pre></li>				<li>Create a new method called <strong class="source-inline">_on_peer_connected()</strong>, which should receive <strong class="source-inline">peer_id</strong> as <span class="No-Break">the argument:</span><pre class="source-code">
func _on_peer_connected(peer_id):</pre></li>				<li>In the <strong class="source-inline">_on_peer_connected()</strong> function, use <strong class="source-inline">print()</strong> to print the passed <strong class="source-inline">peer_id</strong> argument<a id="_idIndexMarker026"/> on <span class="No-Break">the console:</span><pre class="source-code">
  print(peer_id)</pre><p class="list-inset">The complete script should look <span class="No-Break">like this:</span></p><pre class="source-code">extends Node
const PORT = 9999
var peer = ENetMultiplayerPeer.new()
func _ready():
    var error = peer.create_server(PORT)
    multiplayer.multiplayer_peer = peer
    multiplayer.peer_connected.connect
        (_on_peer_connected)
func _on_peer_connected(peer_id):
    print(peer_id)</pre></li>			</ol>
			<p>It’s important to note that this script uses the built-in <strong class="source-inline">multiplayer</strong> member variable that every <strong class="source-inline">Node</strong> instance <a id="_idIndexMarker027"/>has on Godot Engine 4.0 Network API, which is an instance of the <span class="No-Break"><strong class="source-inline">MultiplayerAPI</strong></span><span class="No-Break"> class.</span></p>
			<p>Done: we have our server ready. Told <a id="_idTextAnchor032"/>you it would <span class="No-Break">be simple!</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor033"/>Creating the client</h2>
			<p>Next up, let’s create our client. The<a id="_idIndexMarker028"/> process is quite similar. The major difference is that the client needs the server IP address to find it on <span class="No-Break">the network.</span></p>
			<p>We use the <strong class="source-inline">ENetMultiplayerPeer.create_client()</strong> method to connect a client to a server. This method is very simple to use and requires only two arguments <span class="No-Break">to work:</span></p>
			<ul>
				<li>The first argument of the <strong class="source-inline">create_client()</strong> method is the address of the server. This can be either the server’s IP or hostname. For instance, if you want the client to connect to a server with the IP address <strong class="source-inline">192.168.1.1</strong>, you would call <strong class="source-inline">create_client("192.168.1.1")</strong>. But to make things simpler, we’ll use <strong class="source-inline">"localhost"</strong>, which is a shortcut to our own IP <span class="No-Break">address mask.</span></li>
				<li>The second argument of the <strong class="source-inline">create_client()</strong> method is the port on which the server is listening for incoming connections. This is the port number that the client will use to connect to the server. For example, if the server is listening on port <strong class="source-inline">9999</strong>, you would call <span class="No-Break"><strong class="source-inline">create_client("192.168.1.1", 9999)</strong></span><span class="No-Break">.</span></li>
				<li>The third argument of the <strong class="source-inline">create_client()</strong> method is <strong class="source-inline">channel_count</strong>, which is the number of channels that the client will use to communicate with the server. Channels are used to separate different types of data, such as voice and video, and are useful for creating multiple streams of data within a single connection. This argument is optional, and if not specified, the client will use a default value of <span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break"> channel.</span></li>
				<li>The fourth argument of the <strong class="source-inline">create_client()</strong> method is <strong class="source-inline">in_bandwidth</strong>, which is the maximum incoming bandwidth that the client will allow per connection. This argument is optional, and if not specified, the client will use a default value of <strong class="source-inline">0</strong>, allowing an unlimited <span class="No-Break">incoming bandwidth.</span></li>
				<li>The fifth argument of the <strong class="source-inline">create_client()</strong> method is <strong class="source-inline">out_bandwidth</strong>, which is the maximum outgoing bandwidth that the client will allow per connection. This argument is optional, and if not specified, the client will use a default value of <strong class="source-inline">0</strong>, allowing an unlimited <span class="No-Break">outgoing bandwidth.</span></li>
				<li>The sixth argument of the <strong class="source-inline">create_client()</strong> method is <strong class="source-inline">local_port</strong>, which is the local port that the client will bind to. This argument is optional, and if not specified, the client will use a default value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Now, let’s see how we can<a id="_idIndexMarker029"/> create the <em class="italic">client</em> side of this connection so it can connect with our <em class="italic">server</em> and establish <span class="No-Break">their handshake:</span></p>
			<ol>
				<li>Create a new scene and add a <strong class="source-inline">Node</strong> instance as <span class="No-Break">the root.</span></li>
				<li>Attach a new script <span class="No-Break">to it.</span></li>
				<li>Save the script <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">Client.gd</strong></span><span class="No-Break">.</span></li>
				<li>In the script, define a constant called <strong class="source-inline">ADDRESS</strong> and set it to the server’s IP. In this case, we are going to <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">"localhost"</strong></span><span class="No-Break">:</span><pre class="source-code">
const ADDRESS = "localhost"</pre></li>				<li>Define a constant called <strong class="source-inline">PORT</strong> and set it to be our default port number. It’s very important that this matches the number we used in <strong class="source-inline">Server.gd</strong>, otherwise these peers won’t be able to find <span class="No-Break">each other:</span><pre class="source-code">
const PORT = 9999</pre></li>				<li>Create a new <strong class="source-inline">ENetMultiplayerPeer</strong> using the <strong class="source-inline">new()</strong> constructor and store it in a variable <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">peer</strong></span><span class="No-Break">:</span><pre class="source-code">
var peer = ENetMultiplayerPeer.new()</pre></li>				<li>In the <strong class="source-inline">_ready()</strong> callback, call the <strong class="source-inline">create_client()</strong> method on the <strong class="source-inline">peer</strong> variable, passing in the <strong class="source-inline">ADDRESS</strong> and <strong class="source-inline">PORT</strong> constants <span class="No-Break">as arguments:</span><pre class="source-code">
func _ready():
  peer.create_client(ADDRESS, PORT)</pre></li>				<li>Assign the <strong class="source-inline">peer</strong> variable to the built-in <strong class="source-inline">multiplayer</strong> member variable of <span class="No-Break">the node:</span><pre class="source-code">
multiplayer.multiplayer_peer = peer</pre><p class="list-inset">The complete <a id="_idIndexMarker030"/>script should look <span class="No-Break">like this:</span></p><pre class="source-code">extends Node
const ADDRESS = "localhost"
const PORT = 9999
var peer = ENetMultiplayerPeer.new()
func _ready():
    peer.create_client(ADDRESS, PORT)
    multiplayer.multiplayer_peer = peer</pre></li>			</ol>
			<p>Alright, we have our server and our client ready.<a id="_idTextAnchor034"/> Now, how do we <span class="No-Break">test them?</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor035"/>Testing our handshake</h2>
			<p>Godot Engine 4.0 has a useful feature for<a id="_idIndexMarker031"/> debugging: the ability to open multiple independent instances of the game. This feature allows us to test different scenes at the same time, making the debugging process much easier <span class="No-Break">and faster.</span></p>
			<p>To open multiple instances of the game, we need to select one option from up to four options in the <strong class="bold">Debug</strong> | <strong class="bold">Run Multiple </strong><span class="No-Break"><strong class="bold">Instances</strong></span><span class="No-Break"> menu.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer014">
					<img alt="Figure 1.5 – The Run Multiple Instances menu" src="image/Figure_01.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – The Run Multiple Instances menu</p>
			<p>Then, as soon as we press the <strong class="bold">Run Project</strong> or <strong class="bold">Run Current Scene</strong> button, Godot will launch the instances we’ve set previously. Let’s stick with two instances for <span class="No-Break">this project.</span></p>
			<p>This feature is incredibly useful for testing online multiplayer games, as it allows us to open a server and a client in the same run. But, as you can see, it’s not very straightforward. When we run the project, it actually opens two instances of the <span class="No-Break">same scene.</span></p>
			<p>Let’s create a minimal menu <a id="_idIndexMarker032"/>where we can select whether we are a client or <span class="No-Break">a server:</span></p>
			<ol>
				<li>Create a new scene and use <strong class="source-inline">Control</strong> as the root and name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">MainMenu</strong></span><span class="No-Break">.</span></li>
				<li>Add a <strong class="source-inline">Label</strong> node as a child of the <span class="No-Break">root node.</span></li>
				<li>Add two <strong class="source-inline">Button</strong> nodes as children of the <span class="No-Break">root node.</span></li>
				<li>Give the first <strong class="source-inline">Button</strong> the name <strong class="source-inline">ClientButton</strong> and the second <span class="No-Break">one </span><span class="No-Break"><strong class="source-inline">ServerButton</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer015">
					<img alt="Figure 1.6 – MainMenu’s Scene tree structure" src="image/Figure_01.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – MainMenu’s Scene tree structure</p>
			<ol>
				<li value="5">Set the <strong class="source-inline">Button</strong> nodes’ <strong class="source-inline">text</strong> properties to <strong class="bold">I’m a client</strong> and <strong class="bold">I’m a server</strong> respectively and position <a id="_idIndexMarker033"/>them side by side in the middle of <span class="No-Break">the screen.</span></li>
				<li>Set the <strong class="source-inline">Label</strong> node’s <strong class="source-inline">text</strong> property to <strong class="bold">Are you a…</strong> and position it in the middle of <span class="No-Break">the screen.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer016">
					<img alt="Figure 1.7 – MainMenu’s scene UI" src="image/Figure_01.07_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – MainMenu’s scene UI</p>
			<ol>
				<li value="7">Attach a new <strong class="bold">GDScript</strong> instance to the <strong class="source-inline">MainMenu</strong> node and <span class="No-Break">open it.</span></li>
				<li>Connect the <strong class="bold">ClientButton</strong>’s pressed signal to a function <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">_on_client_button_pressed</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer017">
					<img alt="Figure 1.8 – ClientButton’s pressed signal connection" src="image/Figure_01.08_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – ClientButton’s pressed signal connection</p>
			<ol>
				<li value="9">Connect the pressed<a id="_idIndexMarker034"/> signal of the <strong class="bold">ServerButton</strong> to a function <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">_on_server_button_pressed</strong></span><span class="No-Break">.</span></li>
				<li>In the <strong class="source-inline">_on_client_button_pressed()</strong> callback, let’s call the <strong class="source-inline">change_scene_to_file()</strong> method on the <strong class="source-inline">get_tree()</strong> instance, passing in <strong class="source-inline">"res://Client.tscn"</strong> as <span class="No-Break">the argument:</span><pre class="source-code">
extends Control
func _on_client_pressed():
    get_tree().change_scene_to_file
        ("res://Client.tscn")</pre></li>				<li>In the <strong class="source-inline">_on_server_button_pressed()</strong> callback, do the same as before, passing <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">res://Server.tscn"</strong></span><span class="No-Break"> instead.</span><p class="list-inset">The complete script should look <span class="No-Break">like this:</span></p><pre class="source-code">
extends Control
func _on_client_pressed():
    get_tree().change_scene_to_file
        ("res://Client.tscn")
func _on_server_pressed():
    get_tree().change_scene_to_file("res://Server.tscn")</pre></li>			</ol>
			<p>Now, let’s make sure <a id="_idIndexMarker035"/>we save the scene before we test it. After that, all we need to do is hit the <strong class="bold">Run Current Scene</strong> button and watch the scene come to life. All the hard work has been done, and now all that’s left is to appreciate <span class="No-Break">the results.</span></p>
			<p>Once we have the two debug instances running, we need to pick one to be the server first. For that, we can press <strong class="bold">ServerButton</strong>. This will launch our <strong class="source-inline">Server.tscn</strong> scene and start listening for <span class="No-Break">incoming connections.</span></p>
			<p>Then, in the other instance, we need to press <strong class="bold">ClientButton</strong>. This will launch the <strong class="source-inline">Client.tscn</strong> scene and try to connect to the server. If everything goes as expected, we should get <strong class="source-inline">peer_id</strong> printed in the console of the <span class="No-Break">server instance.</span></p>
			<p>This means that the client and the server have successfully established a connection and are now ready to start exchanging messages. Congratulations, you’ve just created your <span class="No-Break">first handshake!</span></p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor036"/>Summary</h1>
			<p>In this chapter, we went through the fundamentals of network connections, which is to establish the connection through a procedure known as <span class="No-Break">the handshake.</span></p>
			<p>The handshake ensures that two computers recognize each other in a network and establish the protocols of this communication. This is important to understand, as it is the core of all our further endeavors. Without this at our disposal, our players and our server would be disconnected. One would be sending data to the void, while the other would be infinitely waiting for something <span class="No-Break">to arrive.</span></p>
			<p>Talking about sending data, now that we have our computers connected and open to receive and send data back and forth, it’s time to see how to do that. Throughout this chapter, you saw how you can properly establish a connection using the ENet library and how Godot Engine provides a high-level approach to handshaking, to the point that we can barely see if there was an actual handshake <span class="No-Break">or not.</span></p>
			<p>In the next chapter, we are going to use the UDP protocol to also establish a connection between client and server. But this time, we are going to dig a bit further and actually send data both from the client to the server and the other <span class="No-Break">way around.</span></p>
			<p>It’s important to use the UDP protocol to understand what might be happening under the hood when we finally start to get used to the Godot Engine <span class="No-Break"><strong class="source-inline">ENetMultiplayer</strong></span><span class="No-Break"> API.</span></p>
			<p>Now let’s see the dirty and messy world of low-level data transmission in the next chapter, so we can understand later how much easier our lives are made with the new high-level <span class="No-Break">network API!</span></p>
		</div>
	</body></html>