["```cpp\nvoid parray(int * a);  // loses size information\n```", "```cpp\ntemplate<typename T>\nvoid pspan(span<T> s) {\n    cout << format(\"number of elements: {}\\n\", s.size());\n    cout << format(\"size of span: {}\\n\", s.size_bytes());\n    for(auto e : s) cout << format(\"{} \", e);\n    cout << \"\\n\";\n}\n```", "```cpp\nint main() {\n    int carray[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    pspan<int>(carray);\n}\n```", "```cpp\nnumber of elements: 10\nnumber of bytes: 40\n1 2 3 4 5 6 7 8 9 10 \n```", "```cpp\ntemplate<typename T, size_t Extent = std::dynamic_extent>\nclass span {\n    T * data;\n    size_t count;\npublic:\n    ... \n};\n```", "```cpp\nthings_pair<int,int> { 47, 9 };\nauto [this, that] = things_pair;\ncout << format(\"{} {}\\n\", this, that);\n```", "```cpp\n47 9\n```", "```cpp\n    int nums[] { 1, 2, 3, 4, 5 };\n    auto [ a, b, c, d, e ] = nums;\n    cout << format(\"{} {} {} {} {}\\n\", a, b, c, d, e);\n    ```", "```cpp\n1 2 3 4 5\n```", "```cpp\n    array<int,5> nums { 1, 2, 3, 4, 5 };\n    auto [ a, b, c, d, e ] = nums;\n    cout << format(\"{} {} {} {} {}\\n\", a, b, c, d, e);\n    ```", "```cpp\n1 2 3 4 5\n```", "```cpp\n    tuple<int, double, string> nums{ 1, 2.7, \"three\" };\n    auto [ a, b, c ] = nums;\n    cout << format(\"{} {} {}\\n\", a, b, c);\n    ```", "```cpp\n1 2.7 three\n```", "```cpp\n    struct Things { int i{}; double d{}; string s{}; };\n    Things nums{ 1, 2.7, \"three\" };\n    auto [ a, b, c ] = nums;\n    cout << format(\"{} {} {}\\n\", a, b, c);\n    ```", "```cpp\n1 2.7 three\n```", "```cpp\n    array<int,5> nums { 1, 2, 3, 4, 5 };\n    auto& [ a, b, c, d, e ] = nums;\n    cout << format(\"{} {}\\n\", nums[2], c);\n    c = 47;\n    cout << format(\"{} {}\\n\", nums[2], c);\n    ```", "```cpp\n3 3\n47 47\n```", "```cpp\n    const array<int,5> nums { 1, 2, 3, 4, 5 };\n    auto& [ a, b, c, d, e ] = nums;\n    c = 47;    // this is now an error \n    ```", "```cpp\narray<int,5> nums { 1, 2, 3, 4, 5 };\nconst auto& [ a, b, c, d, e ] = nums;\nc = 47;    // this is also an error \n```", "```cpp\n    array<int,5> nums { 1, 2, 3, 4, 5 };\n    int [ a, b, c, d, e ] = nums;\n    ```", "```cpp\nerror: structured binding declaration cannot have type 'int'\nnote: type must be cv-qualified 'auto' or reference to cv-qualified 'auto'\n```", "```cpp\n    struct div_result {\n        long quo;\n        long rem;\n    };\n    div_result int_div(const long & num, const long & denom) {\n        struct div_result r{};\n        r.quo = num / denom;\n        r.rem = num % denom;\n        return r;\n    }\n    int main() {\n        auto [quo, rem] = int_div(47, 5);\n        cout << format(\"quotient: {}, remainder {}\\n\",\n          quo, rem);\n    }\n    ```", "```cpp\nquotient: 9, remainder 2\n```", "```cpp\n    map<string, uint64_t> inhabitants {\n        { \"humans\",   7000000000 },\n        { \"pokemon\", 17863376 },\n        { \"klingons\",   24246291 },\n        { \"cats\",    1086881528 }\n    };\n    // I like commas\n    string make_commas(const uint64_t num) {\n        string s{ std::to_string(num) };\n        for(int l = s.length() - 3; l > 0; l -= 3) {\n            s.insert(l, \",\");\n        }\n        return s;\n    }\n    int main() {\n        for(const auto & [creature, pop] : inhabitants) {\n            cout << format(\"there are {} {}\\n\", \n                make_commas(pop), creature);\n        }\n    }\n    ```", "```cpp\nthere are 1,086,881,528 cats\nthere are 7,000,000,000 humans\nthere are 24,246,291 klingons\nthere are 17,863,376 pokemon\n```", "```cpp\nconst string artist{ \"Jimi Hendrix\" };\nsize_t pos{ artist.find(\"Jimi\") };\nif(pos != string::npos) {\n    cout << \"found\\n\";\n} else {\n    cout << \"not found\\n\";\n}\n```", "```cpp\nif(size_t pos{ artist.find(\"Jimi\") }; pos != string::npos) {\n    cout << \"found\\n\";\n} else {\n    cout << \"not found\\n\";\n}\n```", "```cpp\n    if(auto var{ init_value }; condition) {\n        // var is visible \n    } else {\n        // var is visible \n    } \n    // var is NOT visible \n    ```", "```cpp\n    switch(auto var{ init_value }; var) {\n    case 1: ...\n    case 2: ...\n    case 3: ...\n    ...\n    Default: ...\n    }\n    // var is NOT visible \n    ```", "```cpp\nif (lock_guard<mutex> lg{ my_mutex }; condition) { \n    // interesting things happen here \n}\n```", "```cpp\nif(\n    sqlite3_stmt** stmt, \n    auto rc = sqlite3_prepare_v2(db, sql, -1, &_stmt,\n        nullptr);\n    !rc) {\n          // do SQL things\n} else {  // handle the error \n    // use the error code \n    return 0;\n}\n```", "```cpp\n    template<typename T>\n    const char * f(const T a) {\n        return typeid(T).name();\n    }\n    int main() {\n        cout << format(\"T is {}\\n\", f(47));\n        cout << format(\"T is {}\\n\", f(47L));\n        cout << format(\"T is {}\\n\", f(47.0));\n        cout << format(\"T is {}\\n\", f(\"47\"));\n        cout << format(\"T is {}\\n\", f(\"47\"s));\n    }\n    ```", "```cpp\nT is int\nT is long\nT is double\nT is char const *\nT is class std::basic_string<char...\n```", "```cpp\n    template<typename T1, typename T2>\n    string f(const T1 a, const T2 b) {\n        return format(\"{} {}\", typeid(T1).name(), \n            typeid(T2).name());\n    }\n    int main() {\n        cout << format(\"T1 T2: {}\\n\", f(47, 47L));\n        cout << format(\"T1 T2: {}\\n\", f(47L, 47.0));\n        cout << format(\"T1 T2: {}\\n\", f(47.0, \"47\"));\n    }\n    ```", "```cpp\nT1 T2: int long\nT1 T2: long double\nT1 T2: double char const *\n```", "```cpp\n    template<typename T>\n    const char * f(const T& a) {\n        return typeid(T).name();\n    }\n    int main() {\n        int x{47};\n        f(47);  // this will not compile \n        f(x);   // but this will \n    }\n    ```", "```cpp\n    pair p(47, 47.0);     // deduces to pair<int, double>\n    tuple t(9, 17, 2.5);  // deduces to tuple<int, int, double>\n    ```", "```cpp\ntemplate<typename T1, typename T2, typename T3>\nclass Thing {\n    T1 v1{};\n    T2 v2{};\n    T3 v3{};\npublic:\n    explicit Thing(T1 p1, T2 p2, T3 p3)\n    : v1{p1}, v2{p2}, v3{p3} {}\n    string print() {\n        return format(\"{}, {}, {}\\n\",\n            typeid(v1).name(),\n            typeid(v2).name(),\n            typeid(v3).name()\n        );\n    }\n};\n```", "```cpp\nThings<int, double, string> thing1{1, 47.0, \"three\" }\n```", "```cpp\nThings thing1{1, 47.0, \"three\" }\n```", "```cpp\ncout << thing1.print();\n```", "```cpp\nint, double, char const *\n```", "```cpp\ntemplate<typename T1, typename T2, typename T3>\nThings<T1, T2, T3> make_things(T1 p1, T2 p2, T3 p3) {\n    return Things<T1, T2, T3>(p1, p2, p3);\n}\n...\nauto thing1(make_things(1, 47.0, \"three\"));\ncout << thing1.print();\n```", "```cpp\nint, double, char const *\n```", "```cpp\ntemplate <typename T>\nclass Sum {\n    T v{};\npublic:\n    template <typename... Ts>\n    Sum(Ts&& ... values) : v{ (values + ...) } {}\n    const T& value() const { return v; }\n};\n```", "```cpp\nSum s1 { 1u, 2.0, 3, 4.0f };  // unsigned, double, int, \n                              // float\nSum s2 { \"abc\"s, \"def\" };     // std::sring, c-string\n```", "```cpp\ncannot deduce template arguments for 'Sum'\n```", "```cpp\ntemplate <typename... Ts>\nSum(Ts&& ... ts) -> Sum<std::common_type_t<Ts...>>;\n```", "```cpp\nSum s1 { 1u, 2.0, 3, 4.0f };  // unsigned, double, int, \n                              // float\nSum s2 { \"abc\"s, \"def\" };     // std::sring, c-string\nauto v1 = s1.value();\nauto v2 = s2.value();\ncout << format(\"s1 is {} {}, s2 is {} {}\",\n        typeid(v1).name(), v1, typeid(v2).name(), v2);\n```", "```cpp\ns1 is double 10, s2 is class std::string abcdef\n```", "```cpp\ntemplate<typename T>\nauto value_of(const T v) {\n    if constexpr (std::is_pointer_v<T>) {\n        return *v;  // dereference the pointer\n    } else {\n        return v;   // return the value\n    }\n}\nint main() {\n    int x{47};\n    int* y{&x};\n    cout << format(\"value is {}\\n\", value_of(x));  // value\n    cout << format(\"value is {}\\n\", value_of(y));  \n                                                // pointer\n    return 0;\n}\n```", "```cpp\nvalue is 47\nvalue is 47\n```", "```cpp\nif constexpr (std::is_pointer_v<T>) {\n    return *v;  // dereference the pointer\n} else {\n        return v;   // return the value\n    }\n```"]