- en: Connectivity with Qt Bluetooth LE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will learn about using Qt Bluetooth **Low Energy** (**LE**) to build connectivity
    to devices that have LE Bluetooth radios. Bluetooth is more than mice, keyboards,
    and audio. Device discovery, data exchange, and other tasks involving Bluetooth
    Low Energy will be examined. We will use the `QBluetoothUuid`, `QBluetoothCharacteristic`,
    `QLowEnergyController`, and `QLowEnergyService` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Bluetooth Low Energy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering and connecting with devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advertising services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving sensor data from remote device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Bluetooth Low Energy?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Bluetooth Low Energy** (**BLE**), or Bluetooth Smart as it is also called,
    was originally developed by Nokia under the name Wibree and was originally released
    in 2006\. It was integrated into the Bluetooth 4.0 specification and released
    in 2010.'
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth is a wireless connection technology that operates in the 2,400-2,483.5
    MHz range of the 2.4 GHz frequency band. There are 79 data channels it can choose
    for transmitting packets. BLE limits the data channels to 40.
  prefs: []
  type: TYPE_NORMAL
- en: BLE is targeted at mobile and embedded devices that require lower power consumption.
    Unlike Bluetooth, BLE is designed for devices that exchange small amounts of data
    periodically, as opposed to regular Bluetooth that was designed for continuous
    data streams. Most importantly, BLE has a sleep mode that it uses to conserve
    power.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt has support for BLE in the Qt Connectivity module alongside **Near-field
    Communication** (NFC). BLE has a number of profiles and services:'
  prefs: []
  type: TYPE_NORMAL
- en: Alerts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Battery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fitness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generic Attribute** (**GATT**) is used to store profiles, services, characteristics,
    and other data. Each entry is a unique 16-bit ID. The BLE connection is exclusive
    in that it can only connect to one computer at a time. The BLE peripheral device
    is known as the GATT server, and the computer it connects to is the GATT client.'
  prefs: []
  type: TYPE_NORMAL
- en: Each profile can have a number of services. Each service can have a number of
    characteristics. A profile is just the collection of pre-defined services in the
    specification.
  prefs: []
  type: TYPE_NORMAL
- en: A service is just a group of characteristics defined by a unique 16 or 128-bit
    ID. A characteristic is a single data point, which may contain an array of data,
    such as with an accelerometer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know a little bit of the background, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a BLE GATT server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I guess we really need a BLE server now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you have an embedded device that has a few environmental sensors
    attached, such as humidity and temperature. You need to send this data over Bluetooth
    to another handheld device once in a while. On the embedded sensor device, you
    need to setup the device. The basic procedure to set up the BLE server is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Supply advertisement data (`QLowEnergyAdvertisingData`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Supply characteristic data (`QLowEnergyCharacteristicData`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the service data (`QLowEnergyServiceData`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start advertising and listening for connections
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: QLowEnergyAdvertisingData
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QLowEnergyAdvertisingData` is the class you use to tell the server what and
    how the data is going to be presented.'
  prefs: []
  type: TYPE_NORMAL
- en: Here's how we would use `QLowEnergyAdvertisingData.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Construct a `QLowEnergyAdvertisingData` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Set `Discoverability` options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a `Name` for our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a list of services we are interested it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The source code can be found on the Git repository under the `Chapter06-1` directory,
    in the `cp6` branch.
  prefs: []
  type: TYPE_NORMAL
- en: We need to create some characteristic data now. Let's create a `Characteristic`
    that handles temperature, so we set its `uuid` to `TemperatureMearurement`. We
    need to also let it be configurable for notifications.
  prefs: []
  type: TYPE_NORMAL
- en: QLowEnergyCharacteristicData
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QLowEnergyCharacteristicData` represents a **Generic Attribute Profile** (**GATT**)
    characteristic, which defines a single data point in the Bluetooth transfer. You
    use it to set up service data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: QLowEnergyServiceData
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we set up the `Temperature` service data as a `Primary` service, and
    add `Characteristic` to `service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s supply the temperature data. We construct `QLowEnergyCharacteristic`
    with the `TemperatureMeasurement` type, and supply to it some data. The first
    bit specifies that we are supplying the `temperature` unit in Celsius:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We are all set up now, and all we need is to start `Advertising` to listen
    for connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Discovery and Pair-ity – search and connect for BLE devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you need to do is search for devices, which is called discovery.
    It entails putting the Bluetooth device into search, or discovery mode. You then
    receive a list of devices address with which you can connect or pair to be able
    to access and share data.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how that is done in Qt using `QBluetoothDeviceDiscoveryAgent`.
  prefs: []
  type: TYPE_NORMAL
- en: QBluetoothDeviceDiscoveryAgent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `QBluetoothDeviceDiscoveryAgent` class is responsible for the device discovery
    search. It will emit the `deviceDiscovered` signal when any Bluetooth is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The source code can be found on the Git repository under the `Chapter06-1a` directory,
    in the `cp6` branch.
  prefs: []
  type: TYPE_NORMAL
- en: The call to `start()` will initiate the discovery process. The `QBluetoothDeviceDiscoveryAgent::LowEnergyMethod` argument will
    set a filter to only discover `LowEnergy` devices. Once you find the device you
    want, you can call `stop()` to stop the device search.
  prefs: []
  type: TYPE_NORMAL
- en: You can wait for errors by connecting to the error (`QBluetoothDeviceDiscoveryAgent::Error
    error`) signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `error` signal in the `QBluetoothDeviceDiscoveryAgent` class is overloaded,
    so special care needs to happen in order to connect to the signal. Qt provides `QOverload` and
    can be implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would rather get a list of devices all at one time, connect to the `Finished`
    signal and use the `discoveryDevices()` call, which returns `QList <QBluetoothDeviceInfo>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa9c6ddf-5c99-47b2-a1af-e024d5852294.png)'
  prefs: []
  type: TYPE_IMG
- en: You might want to check for the remote devices pairing status, so call `pairingStatus`
    of `QLocalBluetoothDevice`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pair with a device by then calling the `requestPairing` function of `QBluetoothLocalDevice`,
    with `QBluetoothAddress` of the remote Bluetooth device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our example app asks to pair the device before we execute the `requestPairing`
    procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02444217-bc7a-4b09-84bd-a389e3f211f8.png)'
  prefs: []
  type: TYPE_IMG
- en: You can then call `requestPairing` on `QBluetoothLocalDevice` with the `QBluetoothAddress`
    of the device you wish to pair with. Let's take a look at `QBluetoothLocalDevice`
  prefs: []
  type: TYPE_NORMAL
- en: QBluetoothLocalDevice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QBluetoothLocalDevice` represents the Bluetooth on your device. You use this
    class to initiate pairing to another device, but also to handle pairing requests
    from remote Bluetooth devices. It has a few signals to help with that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pairingDisplayConfirmation`: This is a signal the remote device requests to
    show user a PIN and ask whether it is the same on both devices. You must call
    `pairingConfirmation` with `true` or `false` on `QBluetoothLocalDevice`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pairingDisplayPinCode`: This is a request to enter a PIB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pairingFinished`: Pairing is completed successfully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then connect to these signals, if the user allows it when they click on
    the OK button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When the remote device only needs a PIN confirmation, the `pairingDisplayConfirmation`
    signal is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When the remote device needs user to enter a PIN, the `pairingDisplayPinCode`
    signal is called with a PIN to be displayed and entered on the remote device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other side, to receive pairing, you need to put `QBluetoothLocalDevice`
    into the `Discoverable` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The device can then be seen by other devices that are in the Bluetooth `Discovery`
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying and getting client data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have connected to a BLE device peripheral, you need to discover its
    characteristics to be able to read and write them. You do that by using `QLowEnergyController`.
    Let's take a look at what `QLowEnergyController` is.
  prefs: []
  type: TYPE_NORMAL
- en: QLowEnergyController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QLowEnergyController` is the central place to access BLE devices both local
    and remote.'
  prefs: []
  type: TYPE_NORMAL
- en: The local `QLowEnergyController` can be created by using the static `QLowEnergyController::createPeripheral(QObject
    *parent)` function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `QLowEnergyController` object that represents the remote device is
    done by calling the static class `QLowEnergyController::createCentral` using the `QBluetoothDeviceInfo` object
    that you receive when you discover remote devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `QLowEnergyController` object has several signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '`discoveryFinished`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serviceDiscovered`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connected`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disconnected`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Connect to the `connected` signal and start connecting by calling `connectToDevice()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once the device is connected, it's time to discover its services, so we connect
    to the `serviceDiscovered` signal and initiate the service discovery by calling `discoverServices()`.
  prefs: []
  type: TYPE_NORMAL
- en: QLowEnergyService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also connect to the `discoveryFinished()` signal, which returns a list
    of discovered services by calling `services()`. With either of these, you will
    get the `QBluetoothUuid` that belongs to that service, with which you can then
    create a `QLowEnergyService` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a `QLowEnergyService` object, which gives us details about it.
    We can only read its service details when its state becomes `ServiceDiscovered`,
    so now call the `discoverDetails()` function of the service to start the discovery
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let's have a look at `QLowEnergyCharacteristic`.
  prefs: []
  type: TYPE_NORMAL
- en: QLowEnergyCharacteristic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the service details or `characteristics` are discovered, we can perform
    actions with `QLowEnergyCharacteristic`, such as enabling notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using `QLowEnergyCharacteristic`, we can get a `QLowEnergyDescriptor` that we
    use to enable or disable notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, a `characteristic` on the remote device needs to be written to as
    well, such as enabling a specific sensor. In this case, you need to use the `writeCharacteristic`
    function of the service with `characteristic` as the first argument and the value
    to be written as the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Writing to `QLowEnergyDescriptor` is just as easy; let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: QLowEnergyDescriptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the Bluetooth specifications, a descriptor is defined as attributes that
    describe a characteristic value. It contains additional information about a characteristic.
    `QLowEnergyDescriptor` encapsulates a GATT descriptor. Descriptors and characteristics
    can have notifications when changes happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable notifications, we might need to write a value to the descriptor.
    Here are some possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **GATT term** | **Description** | **Value** | **Qt constant** |'
  prefs: []
  type: TYPE_TB
- en: '| Broadcast | Permits broadcast | `0x01`  | `QLowEnergyCharacteristic::Broadcasting`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Read | Permits reading  | `0x02`  | `QLowEnergyCharacteristic::Read` |'
  prefs: []
  type: TYPE_TB
- en: '| Write without response | Permits writing with any response  | `0x04` | `QLowEnergyCharacteristic::WriteNoResponse`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Write | Permits writing with a response  | `0x08` | `QLowEnergyCharacteristic::Write`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Notify | Permits notifications  | `0x10` | `QLowEnergyCharacteristic::Notify`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Indicate | Permits notification with client confirmation required | `0x20`
    | `QLowEnergyCharacteristic::Indicate` |'
  prefs: []
  type: TYPE_TB
- en: '| Authenticated signed writes | Permits signed writes  | `0x40` | `QLowEnergyCharacteristic::WriteSigned`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Extended properties | Queued writes and writable auxiliaries  | `0x80` |
    `QLowEnergyCharacteristic::ExtendedProperty` |'
  prefs: []
  type: TYPE_TB
- en: The difference between notifications and indications is that, with indications,
    the server requires the client to confirm that it has received the message, whereas
    with a notification, the server doesn't care whether the client receives it.
  prefs: []
  type: TYPE_NORMAL
- en: Qt does not currently have support to use authenticated signed writes (`0x40`) with
    Qt, nor does it have support to use indications (`0x20`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to be notified when the characteristic values change. To enable this,
    we need to write a value of `0x10` or `QLowEnergyCharacteristic::Notify` to `descriptor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can use the predefined `QLowEnergyCharacteristic::Notify`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can finally get values out of our Bluetooth LE device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Bluetooth QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are Bluetooth QML components you can use as a client to scan and connect
    to Bluetooth devices as well. They are simple but functional.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter06-2` directory,
    in the `cp6` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `bluetooth` module to your `pro` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In your `qml` file, use the `QtBluetooth` import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The most important element is `BluetoothDiscoveryModel`.
  prefs: []
  type: TYPE_NORMAL
- en: BluetoothDiscoveryModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`BluetoothDiscoveryModel` provides a data model of available Bluetooth devices
    nearby. You can use it in various model-based Qt Quick components, such as `GridView`,
    `ListView`, and `PathView`. Setting the `discoveryMode` property tells the local
    Bluetooth device the level of service discovery, which is one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FullServiceDiscovery`: Discovers all services of all devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MinimalServiceDiscovery`: Minimal discovery only includes device and UUID
    information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeviceDiscovery`: Discovers only devices and no services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The discovery process will take various amounts of time according to the number
    of services that need to be discovered. To speed up the discovery of a specific
    device, you can set the `discoveryMode` property to `BluetoothDiscoveryModel.DeviceDiscovery`,
    which will allow you to discover the target device address. In the following example,
    I have commented out the device''s target Bluetooth address so it will at least
    show some devices when you run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To discover all services of all nearby devices, set `discoveryMode` to `BluetoothDiscoveryModel.FullServiceDiscovery`.
    If you set the `remoteAddress` property with a device address, you can target
    that one specific device. You will then have to toggle the `running` property
    off and then on to start a new scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a basic data model, but we need somewhere to display it. Qt Quick has
    a few options for viewing model data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GridView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathView` is best written with Qt Creator QML designer, as you can visually
    adjust its path.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s choose a `ListView` for simplicity although I really wanted to use `PathView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s not going to show anything without defining `delegate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Scanning for devices can take a while to complete sometimes, so I want to add
    a busy indicator. Qt Quick Control 2 has `BusyIndicator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When you discover remote services, you will get a `BluetoothService` object.
  prefs: []
  type: TYPE_NORMAL
- en: BluetoothService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you specify `BluetoothDiscoveryModel.FullServiceDiscovery` for a discovery
    scan and when `BluetoothDiscoveryModel` locates a new service, the `serviceDiscovered`
    signal will be emitted. When we connect to that signal, we will receive the `BluetoothService`
    object in the slot.
  prefs: []
  type: TYPE_NORMAL
- en: We can the get the **universal unique identifier** (**uuid**), device and service
    name, service description, and other details. You can use this `BluetoothService`
    to connect to `BluetoothSocket`.
  prefs: []
  type: TYPE_NORMAL
- en: BluetoothSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BluetoothSocket` component can be used to send and receive `String` messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this component, at it''s simplest would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`BluetoothSocket` does not handle binary data. For that, you will have to use
    the C++ `QBluetoothSocket` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `BluetoothDiscoveryModel`, handle the `serviceDiscovered` signal. You will
    get a `BluetoothService` object named `service`. You can then set `Socket` to
    use the service with the `setService` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you might want to handle the `stateChanged` signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect to the service, write `true` to the `connected` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `socketState` property is `Connected`, you can transmit a message
    or string data using the `stringData` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Qt Quick offers a simple way to send string messages over Bluetooth.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bluetooth Low Energy is meant to have lower energy requirements for mobile and
    embedded devices. Qt offers both C++ and QML classes and components to use it.
    You should now be able to discover and connect to a Bluetooth Low Energy device.
  prefs: []
  type: TYPE_NORMAL
- en: Advertising GATT services so users and clients can receive and send data was
    also covered.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go over some of the main components for the **Internet
    of Things** (**IoT**), such as sensors and automation communication protocols.
  prefs: []
  type: TYPE_NORMAL
