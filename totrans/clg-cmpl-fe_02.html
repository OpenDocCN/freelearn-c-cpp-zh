<html><head></head><body>
<div><div><h1 data-number="1.1" class="calibre5">1</h1>
<h1 id="sigil_toc_id_10" class="calibre5"><a id="x1-150001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Environment Setup</h1>
<p class="hidden">In this chapter, we will discuss the basic steps of setting up the environment for future experiments with Clang <a id="dx1-15001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>. The setup is appropriate for Unix-based systems such as Linux and Mac OS (Darwin). In addition, you will get important information on how to download, configure, and build the LLVM source code. We will continue with a short session that explains how to build and use the <strong class="calibre12">LLVM debugger (LLDB</strong> <a id="dx1-15002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>), which will be used as the primary tool for code investigation throughout the book. Finally, we will finish with a simple Clang tool that can check C/C++ files for compilation errors. We will use LLDB for a simple debug session for the created tool and clang internal. We will cover the following topics:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">Prerequisites</p></li>
<li class="calibre14"><p class="calibre15">Getting to know LLVM</p></li>
<li class="calibre14"><p class="calibre15">Source code compilation</p></li>
<li class="calibre14"><p class="calibre15">How to create a custom Clang tool</p></li>
</ul>
<p class="hidden"><a id="x1-15003r1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h2 data-number="1.1.1" id="sigil_toc_id_11" class="likechapterhead">1.1  <a id="x1-160001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Technical requirements</h2>
<p class="hidden">Downloading and building LLVM code is very easy and does not require any paid tools. You will require the following:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">Unix-based OS (Linux, Darwin)</p></li>
<li class="calibre14"><p class="calibre15">Command line git</p></li>
<li class="calibre14"><p class="calibre15">Build tools: CMake and Ninja</p></li>
</ul>
<p class="hidden">We will use the debugger as the source investigation tool. LLVM has its own debugger, LLDB. We will build it as our first tool from LLVM monorepo: <a href="https://github.com/llvm/llvm-project.git" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://github.com/llvm/llvm-project.git</a>.</p>
<p class="hidden">Any build process consists of two steps. The first one is the project configuration and the last one is the build itself. LLVM uses CMake as a project configuration tool. It also can use a wide range of build tools, such as Unix Makefiles, and Ninja. It can also generate project files for popular IDEs such as Visual Studio and XCode. We are going to use Ninja as the build tool because it speeds up the build process, and most LLVM developers use it. You can find additional information about the tools here: <a href="https://llvm.org/docs/GettingStarted.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://llvm.org/docs/GettingStarted.html</a>.</p>
<p class="hidden">The source code for this chapter is located in the <code class="calibre13">chapter1 </code>folder of the book’s GitHub repository: <a href="https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter1</a> <a id="x1-16001r1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h3 data-number="1.1.1.1" id="sigil_toc_id_12" class="likesectionhead">1.1.1  <a id="x1-170001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>CMake as project configuration tool</h3>
<p class="hidden">CMake is an source, cross-platform build system generator. It has been used as the primary build system for LLVM since version 3.3, which was released in 2013.</p>
<p class="hidden">Before LLVM began using CMake, it used autoconf, a tool that generates a configure script that can be used to build and install software on a wide range of Unix-like systems. However, autoconf has several limitations, such as being difficult to use and maintain and having poor support for cross-platform builds. CMake was chosen as an alternative to autoconf because it addresses these limitations and is easier to use and maintain.</p>
<p class="hidden">In addition to being used as the build system for LLVM, CMake is also used for many other software projects, including Qt, OpenCV, and Google Test. <a id="x1-17001r17" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="1.1.1.2" id="sigil_toc_id_13" class="likesectionhead">1.1.2  <a id="x1-180002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Ninja as build tool</h3>
<p class="hidden">Ninja is a small build system with a focus on speed. It is designed to be used in conjunction with a build generator, such as CMake, which generates a build file that describes the build rules for a project.</p>
<p class="hidden">One of the main advantages of <a id="dx1-18001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Ninja is its speed. It is able to execute builds much faster than other build systems, such as Unix Makefiles, by only rebuilding the minimum set of files necessary to complete the build. This is because it keeps track of the dependencies between build targets and only rebuilds targets that are out of date.</p>
<p class="hidden">Additionally, Ninja is simple and easy to use. It has a small and straightforward command-line interface, and the build files it uses are simple text files that are easy to read and understand.</p>
<p class="hidden">Overall, Ninja is a good choice for build systems when speed is a concern, and when a simple and easy-to-use tool is desired.</p>
<p class="hidden">One of the most useful Ninja option is <code class="calibre13">-j </code>. This option allows you to specify the number of threads to be run in parallel. You may want to specify the <a id="dx1-18002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>number depending on the hardware you are using.</p>
<p class="hidden">Our next goal is to download the LLVM code and investigate the project structure. We also need to set up the necessary utilities for the build process and establish the environment for our future experiments with LLVM code. This will ensure that we have the tools and dependencies in place to proceed with our work efficiently. <a id="x1-18003r16" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>



<h2 data-number="1.1.2" id="sigil_toc_id_14" class="likechapterhead">1.2  <a id="x1-190002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Getting to know LLVM</h2>
<p class="hidden">Let’s begin by covering <a id="dx1-19001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>some foundational information about LLVM, including the project history as well as its structure. <a id="x1-19002r18" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h3 data-number="1.1.2.1" id="sigil_toc_id_15" class="likesectionhead">1.2.1  <a id="x1-200001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Short LLVM history</h3>
<p class="hidden">The Clang <a id="dx1-20001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>compiler is a part of the LLVM project. The project was started in 2000 by Chris Lattner and Vikram Adve as their project at the University of Illinois at Urbana–Champaign [<a href="B19722_Bib.xhtml#XLLVM_CGO04" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">26</a>].</p>
<p class="hidden">LLVM was originally designed to be a next-generation code generation infrastructure that could be used to build optimizing compilers for <a id="dx1-20002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>many programming languages. However, it has since evolved into a full-featured platform that can be used to build a wide variety of tools, including debuggers, profilers, and static analysis tools.</p>
<p class="hidden">LLVM has been widely adopted in the software industry and is used by many companies and organizations to build a variety of tools and applications. It is also used in academic research and teaching and has inspired the development of similar projects in other fields.</p>
<p class="hidden">The project received an additional boost when Apple hired Chris Lattner in 2005 and formed a team to work on LLVM. LLVM became an <a id="dx1-20003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>integral part of the development tools created by Apple (XCode).</p>
<p class="hidden">Initially, <strong class="calibre12">GNU Compile Collection (GCC) </strong>was used as the C/C++ frontend for LLVM. But that had some problems. One of them <a id="dx1-20004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>was related to GNU <strong class="calibre12">General Public License (GPL</strong>) that prevented the frontend usage at some proprietary projects. Another disadvantage was the limited support for Objective-C in GCC at the time, which was important for Apple. The Clang project was started by Chris Lattner in 2006 to address the issues.</p>
<p class="hidden">Clang was originally designed as a unified parser for the C family of languages, including C, Objective-C, C++, and Objective-C++. This unification was intended to simplify maintenance by using a single frontend implementation for multiple languages, rather than maintaining multiple implementations for each language. The project became successful very quickly. One of the primary reasons for the success of Clang <a id="dx1-20005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>and LLVM was their modularity. Everything in LLVM is a library, including Clang <a id="dx1-20006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>. It opened the opportunity to create a lot of amazing tools based on Clang <a id="dx1-20007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>and LLVM, such as clang-tidy and clangd, which will be covered later in the book (<a href="B19722_05.xhtml#x1-990005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Chapter</em><em class="calibre11"> 5</em></a><em class="calibre11">, Clang-Tidy Linter Framework</em> and <a href="B19722_08.xhtml#x1-1520008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Chapter</em><em class="calibre11"> 8</em></a><em class="calibre11">, IDE</em> <em class="calibre11">Support and Clangd</em>).</p>
<p class="hidden">LLVM and Clang <a id="dx1-20008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>have a very <a id="dx1-20009" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>clear architecture and are written in C++. That makes it possible to be investigated and used by any C++ developer. We can see the huge community created around LLVM and the extremely fast growth of its usage. <a id="x1-20010r20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="1.1.2.2" id="sigil_toc_id_16" class="likesectionhead">1.2.2  <a id="x1-210002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>OS support</h3>
<p class="hidden">We are planning to focus on OS for <a id="dx1-21001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>personal computers here, such as Linux, Darwin, and Windows. On the other hand, Clang <a id="dx1-21002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>is not limited by personal computers but can also be used to compile code for mobile platforms such as iOS and different embedded systems.</p>

<h4 data-number="1.1.2.2.1" class="sigil_not_in_toc"><a id="x1-220002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Linux</h4>
<p class="hidden">The GCC is the default set of <a id="dx1-22001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>dev tools on Linux, especially <code class="calibre13">gcc </code>(for C programs) and <code class="calibre13">g++ </code>(for C++ programs) being the default compilers. Clang <a id="dx1-22002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>can also be used to compile source code on Linux. Moreover, it mimics to <code class="calibre13">gcc </code>and supports most of its options. LLVM support might be limited for some GNU tools, however; for instance, GNU Emacs does not support LLDB <a id="dx1-22003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>as a debugger. But despite this, Linux is the most suitable OS for LLVM development and investigation, thus we will mainly use this OS (Fedora 39) for future examples.</p>


<h4 data-number="1.1.2.2.2" class="sigil_not_in_toc"><a id="x1-230002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Darwin (macOS)</h4>
<p class="hidden">Clang <a id="dx1-23001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>is considered the main <a id="dx1-23002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>build tool for Darwin. The entire build infrastructure is based on LLVM, and Clang <a id="dx1-23003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>is the default C/C++ compiler. The developer tools, such as the debugger (LLDB <a id="dx1-23004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>), also come from LLVM. You can get the primary developer utilities from XCode, which are based on LLVM. However, you may need to install additional command-line tools, such as CMake and Ninja, either as separate packages or through package systems such as MacPorts or Homebrew.</p>
<p class="hidden">For example, you can get CMake using Homebrew as follows:</p>
<pre id="verbatim-2" class="console">$ brew install cmake</pre>
<p class="hidden">or for MacPorts:</p>
<pre id="verbatim-3" class="console">$ sudo port install cmake</pre>


<h4 data-number="1.1.2.2.3" class="sigil_not_in_toc"><a id="x1-240002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Windows</h4>
<p class="hidden">On Windows, Clang <a id="dx1-24001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>can be <a id="dx1-24002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>used as a command-line compiler or as part of a larger development environment such as Visual Studio. Clang <a id="dx1-24003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>on Windows includes <a id="dx1-24004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>support for the <strong class="calibre12">Microsoft Visual C++ (MSVC) </strong>ABI, so you can use Clang <a id="dx1-24005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>to compile <a id="dx1-24006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>programs that use the <strong class="calibre12">Microsoft C runtime</strong> <strong class="calibre12">library (CRT) </strong>and the C++ <strong class="calibre12">Standard Template Library (STL)</strong>. Clang <a id="dx1-24007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>also <a id="dx1-24008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>supports many of the same language features as GCC, so it can be used as a drop-in replacement for GCC on Windows in many cases.</p>
<p class="hidden">It’s worth mentioning <code class="calibre13">clang-cl </code>[<a href="B19722_Bib.xhtml#Xllvm_clangcl" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">9</a>]. It is a command-line compiler driver for Clang <a id="dx1-24009" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>that is <a id="dx1-24010" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>designed to be used as a drop-in replacement for the MSVC compiler, <code class="calibre13">cl.exe </code>. It was introduced as part of the Clang <a id="dx1-24011" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>compiler, and is created to be used with the LLVM toolchain.</p>
<p class="hidden">Like <code class="calibre13">cl.exe </code>, <code class="calibre13">clang-cl </code>is designed to be <a id="dx1-24012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>used as part of the build process for Windows programs, and it supports many of the same command-line options as the MSVC compiler. It can be used to compile C, C++, and Objective-C code on Windows, and it can also be <a id="dx1-24013" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>used to link object files and libraries to create executable programs or <strong class="calibre12">dynamic link libraries</strong> <strong class="calibre12">(DLLs)</strong>.</p>
<p class="hidden">The development process for Windows is different from that of Unix-like systems, which require additional specifics that might make the book material quite complicated. To avoid this complexity, our primary goal is to focus on Unix-based systems, such as Linux and Darwin, and we will omit Windows-specific examples in this book. <a id="x1-24014r21" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>



<h3 data-number="1.1.2.3" id="sigil_toc_id_17" class="likesectionhead">1.2.3  <a id="x1-250003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>LLVM/Clang project structure</h3>
<p class="hidden">The Clang <a id="dx1-25001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>source is a <a id="dx1-25002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>part of the LLVM <strong class="calibre12">monolithic repository</strong> <strong class="calibre12">(monorepo)</strong>. LLVM started to use the monorepo in 2019 as a part of its transition to Git [<a href="B19722_Bib.xhtml#Xllvm_llvm2git" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">4</a>]. The decision was <a id="dx1-25003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>driven by several factors, such as <a id="dx1-25004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>better code reuse, improved efficiency, and collaboration. Thus you can find all the LLVM projects in one place. As mentioned in the <a href="B19722_Preface.xhtml#x1-5000doc" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Preface</a>, we will be using LLVM version 18.x in this book. The following command will allow you to download it:</p>
<pre id="verbatim-4" class="console">$ git clone https://github.com/llvm/llvm-project.git -b release/18.x
$ cd llvm-project</pre>
<p class="hidden"><a id="x1-25005r1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-25006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.1</strong>: Getting the LLVM code base </p>

<p class="hidden">Important note</p>

<p class="hidden">The release 18 is the latest version of LLVM, expected to be released in March 2024. This book is based on the version from January 23, 2024, when the release branch was created.</p>

<p class="hidden">The most important parts of the <strong class="calibre12">llvm-project </strong>that will be used in the book are shown in <a href="#x1-25007r2" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.2</a>.</p>
<div><img src="img/Figure1.2_B19722.png" alt="Figure 1.2: LLVM project tree " class="calibre17"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 1.2</strong>: LLVM project tree </p>
<p class="hidden">There are:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><code class="calibre13">lld </code>: The LLVM linker tool. You may want to <a id="dx1-25009" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>use it as a replacement <a id="dx1-25010" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>for standard linker tools, such as GNU <code class="calibre13">ld</code></p></li>
<li class="calibre14"><p class="calibre15"><code class="calibre13">llvm </code>: Common libraries for LLVM projects</p></li>
<li class="calibre14"><p class="calibre15"><code class="calibre13">clang </code>: The clang driver and frontend</p></li>
<li class="calibre14"><p class="calibre15"><code class="calibre13">clang-tools-extra </code>: These are different clang tools that will be covered in the second part of the book</p></li>
</ul>
<p class="hidden">Most projects have the structure shown in <a href="#x1-25011r3" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.3</a>.</p>
<div><img src="img/Figure1.3_B19722.png" alt="Figure 1.3: Typical LLVM project structure " class="calibre18"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 1.3</strong>: Typical LLVM project structure </p>
<p class="hidden">LLVM projects, such as <code class="calibre13">clang </code>or <code class="calibre13">llvm </code>, typically contain two primary folders: <code class="calibre13">include </code>and <code class="calibre13">lib </code>. The <code class="calibre13">include </code>folder contains the project interfaces (header files), while the <code class="calibre13">lib </code>folder contains the implementation. Each LLVM project has a <a id="dx1-25013" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>variety of different tests, which can be divided into two primary groups: unit tests located in the <code class="calibre13">unittests </code>folder and implemented <a id="dx1-25014" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>using the Google Test framework, and end-to-end tests implemented using the <strong class="calibre12">LLVM Integrated Tester (LIT</strong> <a id="dx1-25015" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/><strong class="calibre12">) </strong>framework. You can get more info about LLVM/Clang <a id="dx1-25016" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>testing in <a href="B19722_04.xhtml#x1-830002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 4.5.2</em></a><em class="calibre11">, LLVM test</em> <em class="calibre11">framework</em>.</p>
<p class="hidden">The most important <a id="dx1-25017" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>projects for us are <code class="calibre13">clang </code>and <code class="calibre13">clang-tools-extra </code>. The <code class="calibre13">clang </code>folder contains the frontend and driver.</p>

<p class="hidden">Important note</p>

<p class="hidden">The compiler driver is used to run different stages of compilation (parsing, optimization, link, and so on.). You can get more info about it at <a href="B19722_02.xhtml#x1-410003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 2.3</em></a><em class="calibre11">, Clang driver overview</em>.</p>

<p class="hidden">For instance, the lexer implementation is located in the <code class="calibre13">clang/lib/Lex </code>folder. You can also see the <code class="calibre13">clang/test </code>folder, which contains end-to-end tests, and the <code class="calibre13">clang/unittest </code>folder, which contains unit tests for the frontend and the driver.</p>
<p class="hidden">Another important folder is <code class="calibre13">clang-tools-extra </code>. It contains some tools based on different Clang libraries. They are as follows:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><code class="calibre13">clang-tools-extra/clangd </code>: A language server that provides navigation info for IDEs such as VSCode</p></li>
<li class="calibre14"><p class="calibre15"><code class="calibre13">clang-tools-extra/clang-tidy </code>: A powerful lint framework with several hundred different checks</p></li>
<li class="calibre14"><p class="calibre15"><code class="calibre13">clang-tools-extra/clang-format </code>: A code formatting tool</p></li>
</ul>
<p class="hidden">After obtaining the source code and setting up build tools, we are ready to compile the LLVM source code. <a id="x1-25018r19" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>



<h2 data-number="1.1.3" id="sigil_toc_id_18" class="likechapterhead">1.3  <a id="x1-260003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Source code compilation</h2>
<p class="hidden">We are compiling our <a id="dx1-26001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>source code in debug mode to make it suitable for future investigations with a debugger. We are using LLDB <a id="dx1-26002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>as the debugger. We will start with an overview of the build process and finish building the LLDB <a id="dx1-26003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>as a concrete example. <a id="x1-26004r25" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h3 data-number="1.1.3.1" id="sigil_toc_id_19" class="likesectionhead">1.3.1  <a id="x1-270001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Configuration with CMake</h3>
<p class="hidden">Create a build folder where the compiler and related tools will be built:</p>
<pre id="verbatim-5" class="console">$ mkdir build
$ cd build</pre>
<p class="hidden">The minimal configuration command looks like this:</p>
<pre id="verbatim-6" class="console">$ cmake -DCMAKE_BUILD_TYPE=Debug ../llvm</pre>
<p class="hidden">The command requires the build type to be specified (e.g. <code class="calibre13">Debug </code>in our case) as well as the primary argument that points to a folder with the <a id="dx1-27001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>build configuration file. The configuration file is stored as <code class="calibre13">CMakeLists.txt </code>and is located in the <code class="calibre13">llvm </code>folder, which explains the <code class="calibre13">../llvm </code>argument usage. The command generates <code class="calibre13">Makefile </code>located in the build folder, thus you can use the simple <code class="calibre13">make</code> command to start the build process.</p>
<p class="hidden">We will use more <a id="dx1-27002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>advanced configuration commands in the book. One of the commands looks like this:</p>
<pre id="listing-2" class="source-code">cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=../install -DLLVM_TARGETS_TO_BUILD="X86" -DLLVM_ENABLE_PROJECTS="lldb;clang;clang-tools-extra" -DLLVM_USE_SPLIT_DWARF=ON ../llvm</pre>
<p class="hidden"><a id="x1-27004r4" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-27005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.4</strong>: Basic CMake configuration </p>
<p class="hidden">The are several LLVM/cmake options specified:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><code class="calibre13">-G Ninja </code>specifies Ninja as the build generator, otherwise it will use make (which is slow).</p></li>
<li class="calibre14"><p class="calibre15"><code class="calibre13">-DCMAKE</code><code class="calibre13">_BUILD</code><code class="calibre13">_TYPE=Debug </code>sets the build mode. The build with debug info will be created. There is a primary build configuration for Clang <a id="dx1-27006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>internals investigations.</p></li>
<li class="calibre14"><p class="calibre15"><code class="calibre13">-DCMAKE</code><code class="calibre13">_INSTALL</code><code class="calibre13">_PREFIX=../install </code>specifies the installation folder.</p></li>
<li class="calibre14"><p class="calibre15"><code class="calibre13">-DLLVM</code><code class="calibre13">_TARGETS</code><code class="calibre13">_TO</code><code class="calibre13">_BUILD="X86" </code>sets exact targets to be build. It will avoid building unnecessary targets.</p></li>
<li class="calibre14"><p class="calibre15"><code class="calibre13">-DLLVM</code><code class="calibre13">_ENABLE</code><code class="calibre13">_PROJECTS="lldb;clang;clang-tools-extra"</code> specifies the LLVM projects we want to build.</p></li>
<li class="calibre14"><p class="calibre15"><code class="calibre13">-DLLVM</code><code class="calibre13">_USE</code><code class="calibre13">_SPLIT</code><code class="calibre13">_DWARF=ON </code>splits debug information into separate files. This option saves disk space as well as memory consumption during the LLVM build.</p></li>
</ul>
<p class="hidden">We used <code class="calibre13">-DLLVM</code><code class="calibre13">_USE</code><code class="calibre13">_SPLIT</code><code class="calibre13">_DWARF=ON </code>to save some space on the disk. For instance, the Clang build (<code class="calibre13">ninja clang </code>build command) with the option enabled takes up 20 GB, but it takes up 27 GB space with the option disabled. Note that the option requires a compiler used for the build to support it. You might also notice that we create the <a id="dx1-27007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>build for one specific architecture: <code class="calibre13">X86 </code>. This option also saved some space for us because otherwise, all supported architecture will be <a id="dx1-27008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>built and the required space will also increase from 20 GB to 27 GB.</p>

<p class="hidden">Important note</p>

<p class="hidden">You might want to avoid using the <code class="calibre13">-DLLVM</code><code class="calibre13">_TARGETS</code><code class="calibre13">_TO</code><code class="calibre13">_BUILD="X86"</code> setting if your host platform is different from X86, for instance, ARM. For ARM, you can use the following configuration: <code class="calibre13">-DLLVM</code><code class="calibre13">_TARGETS</code><code class="calibre13">_TO</code><code class="calibre13">_BUILD="ARM;X86;AArch64" </code>[<a href="B19722_Bib.xhtml#Xllvm_arm_build" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">15</a>]. The full list of supported platforms can be found in [<a href="B19722_Bib.xhtml#Xllvm_build" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">7</a>] and includes (as of March 2023) 19 different targets.</p>
<p class="hidden">You can also use the default settings and not specify the <code class="calibre13">LLVM</code><code class="calibre13">_TARGETS</code><code class="calibre13">_TO</code><code class="calibre13">_BUILD </code>configuration setting. Be prepared for both an increase in build time and the amount of space used.</p>

<p class="hidden">You can save more space if you use dynamic libraries instead of static ones. The configuration setting <code class="calibre13">-DBUILD</code><code class="calibre13">_SHARED</code><code class="calibre13">_LIBS=ON </code>will build each LLVM component as a shared library. The space used will be 14 GB, and the overall config command will look like this:</p>
<pre id="listing-3" class="source-code">cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=../install -DLLVM_TARGETS_TO_BUILD="X86" -DLLVM_ENABLE_PROJECTS="lldb;clang;clang-tools-extra" -DLLVM_USE_SPLIT_DWARF=ON -DBUILD_SHARED_LIBS=ON ../llvm</pre>
<p class="hidden"><a id="x1-27010r5" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-27011" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.5</strong>: CMake configuration that enables shared libraries instead of static ones </p>
<p class="hidden">For performance purposes, on Linux, you might want to use the <code class="calibre13">gold </code>linker instead of the default one. The <code class="calibre13">gold </code>linker is an alternative to the GNU Linker, which was developed as part of the GNU Binary Utilities (binutils) package. It is designed to be faster and more efficient than the GNU Linker, especially when linking large projects. One way it achieves this is by using a more efficient algorithm for symbol resolution and a more compact file format for the resulting executable. It can be enabled with the <code class="calibre13">-DLLVM</code><code class="calibre13">_USE</code><code class="calibre13">_LINKER=gold </code>option. The result configuration command will look like this:</p>
<pre id="listing-4" class="source-code">cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=../install -DLLVM_TARGETS_TO_BUILD="X86" -DLLVM_ENABLE_PROJECTS="lldb;clang;clang-tools-extra" -DLLVM_USE_LINKER=gold -DLLVM_USE_SPLIT_DWARF=ON -DBUILD_SHARED_LIBS=ON ../llvm</pre>
<p class="hidden"><a id="x1-27013r6" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-27014" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.6</strong>: CMake configuration that uses gold linker </p>
<p class="hidden">The debug build can be very slow, so you may want to consider an alternative. A good compromise between debuggability and performance is the release build with debug information. To obtain this build, you can change the <code class="calibre13">CMAKE</code><code class="calibre13">_BUILD</code><code class="calibre13">_TYPE </code>flag to <code class="calibre13">RelWithDebInfo </code>in your overall configuration command. The command will then look like this:</p>
<pre id="listing-5" class="source-code">cmake -G Ninja -DCMAKE_BUILD_TYPE=RelWithDebInfo _DCMAKE_INSTALL_PREFIX=../install -DLLVM_TARGETS_TO_BUILD="X86" -DLLVM_ENABLE_PROJECTS="lldb;clang;clang-tools-extra" -DLLVM_USE_SPLIT_DWARF=ON ../llvm</pre>
<p class="hidden"><a id="x1-27016r7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-27017" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.7</strong>: CMake configuration that uses RelWithDebInfo build type </p>
<p class="hidden">The following <a id="dx1-27018" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>table keeps the list of <a id="dx1-27019" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>some popular options ( <a href="https://llvm.org/docs/CMake.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://llvm.org/docs/CMake.html</a>).</p>
<div><div><table id="TBL-1" class="tabular">
<tbody class="calibre19">
<tr class="odd">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-1-1-" class="even">
<td id="TBL-1-1-1" class="td">Option</td>
<td id="TBL-1-1-2" class="td">Description</td>
</tr>
<tr class="odd">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-1-2-" class="even">
<td id="TBL-1-2-1" class="td"><code class="calibre22">CMAKE</code><code class="calibre22">_BUILD</code><code class="calibre22">_TYPE </code></td>
<td id="TBL-1-2-2" class="td">Specifies the build configuration.</td>
</tr>
<tr id="TBL-1-3-" class="odd">
<td id="TBL-1-3-1" class="td"/>
<td id="TBL-1-3-2" class="td">Possible values are <code class="calibre13">Release|Debug|RelWithDebInfo|MinSizeRel </code>.</td>
</tr>
<tr id="TBL-1-4-" class="even">
<td id="TBL-1-4-1" class="td"/>
<td id="TBL-1-4-2" class="td"><code class="calibre22">Release </code>and <code class="calibre22">RelWithDebInfo </code>are optimized for performance, while</td>
</tr>
<tr id="TBL-1-5-" class="odd">
<td id="TBL-1-5-1" class="td"/>
<td id="TBL-1-5-2" class="td"><code class="calibre13">MinSizeRel </code>is optimized for size.</td>
</tr>
<tr class="even">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-1-6-" class="odd">
<td id="TBL-1-6-1" class="td"><code class="calibre13">CMAKE</code><code class="calibre13">_INSTALL</code><code class="calibre13">_PREFIX </code></td>
<td id="TBL-1-6-2" class="td">Installation prefix</td>
</tr>
<tr class="even">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-1-7-" class="odd">
<td id="TBL-1-7-1" class="td"><code class="calibre13">CMAKE</code><code class="calibre13">_C,CXX</code><code class="calibre13">_FLAGS </code></td>
<td id="TBL-1-7-2" class="td">Extra C/C++ flags be used for compilation</td>
</tr>
<tr class="even">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-1-8-" class="odd">
<td id="TBL-1-8-1" class="td"><code class="calibre13">CMAKE</code><code class="calibre13">_C,CXX</code><code class="calibre13">_COMPILER </code></td>
<td id="TBL-1-8-2" class="td">C/C++ compiler be used for compilation.</td>
</tr>
<tr id="TBL-1-9-" class="even">
<td id="TBL-1-9-1" class="td"/>
<td id="TBL-1-9-2" class="td">You might want to specify a non-default compiler to use some</td>
</tr>
<tr id="TBL-1-10-" class="odd">
<td id="TBL-1-10-1" class="td"/>
<td id="TBL-1-10-2" class="td">options that are not available or not supported by the default compiler.</td>
</tr>
<tr class="even">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-1-11-" class="odd">
<td id="TBL-1-11-1" class="td"><code class="calibre13">LLVM</code><code class="calibre13">_ENABLE</code><code class="calibre13">_PROJECTS </code></td>
<td id="TBL-1-11-2" class="td">The projects to be enabled. We will use <code class="calibre13">clang;clang-tools-extra </code>.</td>
</tr>
<tr class="even">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-1-12-" class="odd">
<td id="TBL-1-12-1" class="td"><code class="calibre13">LLVM</code><code class="calibre13">_USE</code><code class="calibre13">_LINKER </code></td>
<td id="TBL-1-12-2" class="td">Specifies the linker to be used.</td>
</tr>
<tr id="TBL-1-13-" class="even">
<td id="TBL-1-13-1" class="td"/>
<td id="TBL-1-13-2" class="td">There are several options, including <code class="calibre22">gold </code>and <code class="calibre22">lld </code>.</td>
</tr>
<tr class="odd">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-1-14-" class="even">
<td id="TBL-1-14-1" class="td"/>
<td class="calibre20"/>
</tr>
</tbody>
</table>
</div>
<a id="x1-27020r1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-27021" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>
<p class="hidden"><strong class="calibre12">Table 1.1: </strong>Configuration options </p>
</div>
<p class="hidden"><a id="x1-27022r30" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="1.1.3.2" id="sigil_toc_id_20" class="likesectionhead">1.3.2  <a id="x1-280002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Build</h3>
<p class="hidden">We need to call Ninja to <a id="dx1-28001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>build the projects. If you want to build all specified projects, you can run Ninja without arguments:</p>
<pre id="verbatim-7" class="console">$ ninja</pre>
<p class="hidden">The command for the Clang <a id="dx1-28002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>build will look like this:</p>
<pre id="verbatim-8" class="console">$ ninja clang</pre>
<p class="hidden">You can also run unit and end-to-end tests for the compiler with the following:</p>
<pre id="verbatim-9" class="console">$ ninja check-clang</pre>
<p class="hidden">The compiler binary is <code class="calibre13">bin/clang </code>and can be found in the <code class="calibre13">build </code>folder.</p>
<p class="hidden">You can also install the <a id="dx1-28003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>binaries into the folder specified in the <code class="calibre13">-DCMAKE</code><code class="calibre13">_INSTALL</code><code class="calibre13">_PREFIX </code>option. It can be done as follows:</p>
<pre id="verbatim-10" class="console">$ ninja install</pre>
<p class="hidden">The <code class="calibre13">../install </code>folder (specified as the installation folder in <a href="#x1-27004r4" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.4</a>) will have the following structure:</p>
<pre id="verbatim-11" class="console">$ ls ../install
bin  include  lib  libexec  share</pre>
<p class="hidden"><a id="x1-28004r36" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="1.1.3.3" id="sigil_toc_id_21" class="likesectionhead">1.3.3  <a id="x1-290003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>The LLVM debugger, its build, and usage</h3>
<p class="hidden">The LLVM debugger, LLDB <a id="dx1-29001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>, has been created with a look at the GNU debugger (GDB <a id="dx1-29002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>). Some of its commands repeat the counterparts from GDB <a id="dx1-29003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>. You may ask ”Why do we need a new debugger if we have a good one?” The answer can be found in the different architecture <a id="dx1-29004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>solutions used by GCC and LLVM. LLVM uses a modular architecture, and different <a id="dx1-29005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>parts of the compiler can be reused. For example, the Clang <a id="dx1-29006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>frontend can be reused in the debugger, resulting in support for modern C/C++ features. For example, the print command in <code class="calibre13">lldb </code>can specify any valid language constructions, and you can use some modern C++ features with the <code class="calibre13">lldb </code>print command.</p>
<p class="hidden">In contrast, GCC uses a <a id="dx1-29007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>monolithic architecture, and it’s hard to separate the C/C++ frontend from other parts. Therefore, GDB <a id="dx1-29008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>has to implement language features separately, which may take some time before modern language features implemented in GCC become available in GDB <a id="dx1-29009" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>.</p>
<p class="hidden">You may find some info about LLDB <a id="dx1-29010" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>build and a typical usage scenario in the following example. We are going to create a separate folder for the release build:</p>
<pre id="verbatim-12" class="console">$ cd llvm-project
$ mkdir release
$ cd release</pre>
<p class="hidden"><a id="x1-29011r8" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-29012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.8</strong>: Release build for LLVM </p>
<p class="hidden">We configure our project in release mode and specify the <code class="calibre13">lldb </code>and <code class="calibre13">clang</code> projects only:</p>
<pre id="listing-6" class="source-code">cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=../install -DLLVM_TARGETS_TO_BUILD="X86" -DLLVM_ENABLE_PROJECTS="lldb;clang" ../llvm</pre>
<p class="hidden"><a id="x1-29014r9" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-29015" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.9</strong>: CMake configuration that uses Release build type </p>
<p class="hidden">We are going to build both Clang <a id="dx1-29016" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>and LLDB <a id="dx1-29017" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>using the maximum threads available in the system:</p>
<pre id="verbatim-13" class="console">$ ninja clang lldb -j $(nproc)</pre>
<p class="hidden">You can install the created executables with the following command:</p>
<pre id="verbatim-14" class="console">$ ninja install-clang install-lldb</pre>
<p class="hidden">The binary will be installed into the folder specified via the <code class="calibre13">-DCMAKE</code><code class="calibre13">_INSTALL</code><code class="calibre13">_PREFIX</code> config command argument.</p>
<p class="hidden">We will use the following simple C++ program for the example debugger session:</p>
<pre class="source-code">1 int main() { 
 
2   return 0; 
 
3 }</pre>
<p class="hidden"><a id="x1-29022r10" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-29023" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.10</strong>: Test C++ program: main.cpp </p>
<p class="hidden">The program can be <a id="dx1-29024" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>compiled using the following command (<code class="calibre13">&lt;...&gt; </code>was used to refer the folder where llvm-project was cloned):</p>
<pre id="verbatim-15" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang main.cpp -o main -g -O0</pre>
<p class="hidden">As you may have noticed, we don’t use optimization (the <code class="calibre13">-O0 </code>option) and store debug info in the binary (with the <code class="calibre13">-g </code>option).</p>
<p class="hidden">A typical debug <a id="dx1-29025" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>session for the created executable is shown in <a href="#listing-7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.11</a>.</p>
<pre id="listing-7" class="source-code">1$ &lt;...&gt;/llvm-project/install/bin/lldb main 
 

2 (lldb) target create "./main" 
 
3 ... 
 
4 (lldb) b main 
 

5 Breakpoint 1: where = main‘main + 11 at main.cpp:2:3,... 
 

6 (lldb) r 
 
7 Process 1443051 launched: ... 
 

8 Process 1443051 stopped 
 
9 * thread #1, name = ’main’, stop reason = breakpoint 1.1 
 

10    frame #0: 0x000055555555513b main‘main at main.cpp:2:3 
 

11    1    int main() { 
 
12 -&gt; 2     return 0; 
 
13    3    } 
 

14 (lldb) q</pre>
<p class="hidden"><a id="x1-29042r11" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-29043" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.11</strong>: LLDB <a id="dx1-29045" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>session example </p>
<p class="hidden">Several actions are taken:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">Run the debug session with <code class="calibre13">&lt;...&gt;/llvm-project/install/bin/lldb</code> <code class="calibre13">main </code>, where <code class="calibre13">main </code>is the executable we want to debug. See <a href="#listing-7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.11</a>, <em class="calibre11">Line 1</em>.</p></li>
<li class="calibre14"><p class="calibre15">We set a breakpoint in the <code class="calibre13">main </code>function. See <a href="#listing-7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.11</a>, <em class="calibre11">Line 4</em>.</p></li>
<li class="calibre14"><p class="calibre15">Run the session with <code class="calibre13">"r" </code>command. See <a href="#listing-7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.11</a>, <em class="calibre11">Line 6</em>.</p></li>
<li class="calibre14"><p class="calibre15">We can see that the process is interrupted at the breakpoint. See <a href="#listing-7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.11</a>, <em class="calibre11">Lines 8, 12</em>.</p></li>
<li class="calibre14"><p class="calibre15">We finish the session with the <code class="calibre13">"q" </code>command. See <a href="#listing-7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.11</a>, <em class="calibre11">Line 14</em>.</p></li>
</ul>
<p class="hidden">We are going to use LLDB <a id="dx1-29046" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>as one of <a id="dx1-29047" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>our tools for the Clang <a id="dx1-29048" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/><a id="dx1-29049" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>internal investigation. We will use the same sequence of commands that is shown in <a href="#listing-7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.11</a>. You can also use another debugger, such as GDB <a id="dx1-29050" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>, that has a similar set of commands as LLDB <a id="dx1-29051" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>. <a id="x1-29052r29" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>



<h2 data-number="1.1.4" id="sigil_toc_id_22" class="likechapterhead">1.4  <a id="x1-300004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Test project – syntax check with a Clang tool</h2>
<p class="hidden">For our first test project, we will create a simple Clang tool that runs the compiler and checks the syntax for the provided source file. We will <a id="dx1-30001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>create a so-called out-of-tree LLVM project, that is, a project that will use LLVM but will be located outside the main LLVM source tree.</p>
<p class="hidden">Several actions are required to create the project:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">The required LLVM libraries and headers have to be built and installed</p></li>
<li class="calibre14"><p class="calibre15">We have to create a build configuration file for our test project</p></li>
<li class="calibre14"><p class="calibre15">The source code that uses LLVM has to be created</p></li>
</ul>
<p class="hidden">We will start with the first step and install the Clang support libraries and headers. We will use the following configuration command for CMake:</p>
<pre id="listing-8" class="source-code">cmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=../install -DLLVM_TARGETS_TO_BUILD="X86" -DLLVM_ENABLE_PROJECTS="clang" -DLLVM_USE_LINKER=gold -DLLVM_USE_SPLIT_DWARF=ON -DBUILD_SHARED_LIBS=ON ../llvm</pre>
<p class="hidden"><a id="x1-30003r12" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-30004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.12</strong>: LLVM CMake configuration for a simple syntax checking Clang tool </p>
<p class="hidden">As you may have noticed, we enabled only one project: <code class="calibre13">clang</code>. All other options are standard for our debug build. The command has to be run from a created <code class="calibre13">build </code>folder inside the LLVM source tree, as was suggested in <a href="#x1-270001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 1.3.1</em></a><em class="calibre11">,</em> <em class="calibre11">Configuration with CMake</em>.</p>

<p class="hidden">Important note</p>

<p class="hidden">The configuration specified in <a href="#x1-30003r12" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.12</a> will be the default build configuration used throughout the book.</p>
<p class="hidden">The configuration with shared libraries, in addition to the reduced size, has the advantage of simplifying the specification of dependencies. You only need to specify the shared libraries that your project directly depends on, and the dynamic linker takes care of the rest.</p>

<p class="hidden">The required libraries and headers <a id="dx1-30005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>can be installed with the following command:</p>
<pre id="verbatim-16" class="console">$ ninja install</pre>
<p class="hidden">The libraries and headers will be installed into <code class="calibre13">install </code>folder, as was specified by the <code class="calibre13">CMAKE_INSTALL_PREFIX</code> option.</p>
<p class="hidden">We have to create two files for our project:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><code class="calibre13">CMakeLists.txt</code>: The project configuration file</p></li>
<li class="calibre14"><p class="calibre15"><code class="calibre13">TestProject.cpp</code>: The project source code</p></li>
</ul>
<p class="hidden">The project configuration file, <code class="calibre13">CMakeLists.txt </code>, will accept a path to the LLVM install folder via the <code class="calibre13">LLVM_HOME</code> environment variable. The file is as follows:</p>
<pre class="source-code">1 cmake_minimum_required(VERSION 3.16) 
 

2 project("syntax-check") 
 
3  
 
4 if ( NOT DEFINED ENV{LLVM_HOME}) 
 

5   message(FATAL_ERROR "$LLVM_HOME is not defined") 
 

6 else() 
 
7   message(STATUS "$LLVM_HOME found: $ENV{LLVM_HOME}") 
 

8   set(LLVM_HOME $ENV{LLVM_HOME} CACHE PATH "Root of LLVM installation") 
 

9   set(LLVM_LIB ${LLVM_HOME}/lib)
                                                                     

                                                                     </pre>
<pre id="listing-9" class="source-code">10  set(LLVM_DIR ${LLVM_LIB}/cmake/llvm) 
 

11   find_package(LLVM REQUIRED CONFIG) 
 

12   include_directories(${LLVM_INCLUDE_DIRS}) 
 

13   link_directories(${LLVM_LIBRARY_DIRS}) 
 

14   set(SOURCE_FILES SyntaxCheck.cpp) 
 

15   add_executable(syntax-check ${SOURCE_FILES}) 
 

16   set_target_properties(syntax-check PROPERTIES COMPILE_FLAGS "-fno-rtti") 
 

17   target_link_libraries(syntax-check 
 
18    LLVMSupport 
 

19    clangBasic 
 
20    clangFrontend 
 
21    clangSerialization 
 

22    clangTooling 
 
23   ) 
 
24 endif()</pre>
<p class="hidden"><a id="x1-30031r13" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-30032" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.13</strong>: CMake file for simple syntax check Clang Tool </p>
<p class="hidden">The most important <a id="dx1-30033" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>parts of the file are as follows:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><em class="calibre11">Line 2</em>: We specify the project name (syntax-check). That is also the name of our executable.</p></li>
<li class="calibre14"><p class="calibre15"><em class="calibre11">Lines 4-7</em>: Test for the <code class="calibre13">LLVM_HOME</code> environment variable.</p></li>
<li class="calibre14"><p class="calibre15"><em class="calibre11">Line 10</em>: We set a path to the LLVM CMake helpers.</p></li>
<li class="calibre14"><p class="calibre15"><em class="calibre11">Line 11</em>: We load the LLVM CMake package from the paths specified on <em class="calibre11">Line 10</em>.</p></li>
<li class="calibre14"><p class="calibre15"><em class="calibre11">Line 14</em>: We specify our source file that should be compiled.</p></li>
<li class="calibre14"><p class="calibre15"><em class="calibre11">Line 16</em>: We set up an additional flag for compilation: <code class="calibre13">-fno-rtti</code>. The flag is required as soon as LLVM is built without RTTI. This is done in an effort to reduce code and executable size [<a href="B19722_Bib.xhtml#Xllvm_coding_standards" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">11</a>].</p></li>
<li class="calibre14"><p class="calibre15"><em class="calibre11">Lines 18-22 </em>We specify the required libraries to be linked to our program.</p></li>
</ul>
<p class="hidden">The source code for our <a id="dx1-30034" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>tool is as follows:</p>
<pre class="source-code">1 #include "clang/Frontend/FrontendActions.h" // clang::SyntaxOnlyAction 
 

2 #include "clang/Tooling/CommonOptionsParser.h" 
 




3 #include "clang/Tooling/Tooling.h" 
 

4 #include "llvm/Support/CommandLine.h" // llvm::cl::extrahelp 
 

5  
 
6 namespace { 
 
7 llvm::cl::OptionCategory TestCategory("Test project"); 
 

8 llvm::cl::extrahelp 
 
9     CommonHelp(clang::tooling::CommonOptionsParser::HelpMessage); 
 

10 } // namespace 
 
11  
 
12 int main(int argc, const char **argv) { 
 

13   llvm::Expected&lt;clang::tooling::CommonOptionsParser&gt; OptionsParser = 
 

14       clang::tooling::CommonOptionsParser::create(argc, argv, TestCategory); 
 

15   if (!OptionsParser) { 
 
16     llvm::errs() &lt;&lt; OptionsParser.takeError(); 
 

17     return 1; 
 
18   } 
 
19   clang::tooling::ClangTool Tool(OptionsParser-&gt;getCompilations(), 
 

20                                  OptionsParser-&gt;getSourcePathList()); 
 

21   return Tool.run( 
 
22       clang::tooling::newFrontendActionFactory&lt;clang::SyntaxOnlyAction&gt;() 
 

23           .get()); 
 
24 }</pre>
<p class="hidden"><a id="x1-30060r14" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-30061" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.14</strong>: SyntaxCheck.cpp </p>
<p class="hidden">The most important part of the file are as follows:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><em class="calibre11">Lines 7-9</em>: The majority of compiler tools have the same set of command line arguments. The LLVM command-line library [<a href="B19722_Bib.xhtml#Xllvm_commandline_library" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">12</a>] provides some APIs to process compiler command options. We set up the library on <em class="calibre11">Line 7</em>. We also set up additional help messages on lines 8-10.</p></li>
<li class="calibre14"><p class="calibre15"><em class="calibre11">Lines 13-18</em>: We parse command-line arguments.</p></li>
<li class="calibre14"><p class="calibre15"><em class="calibre11">Lines 19-24</em>: We create and run our Clang tool.</p></li>
<li class="calibre14"><p class="calibre15"><em class="calibre11">Lines 22-23</em>: We use the <code class="calibre13">clang::SyntaxOnlyAction </code>frontend action, which will run syntax and semantic checks on the input file. You can get more info about frontend actions in <a href="B19722_02.xhtml#x1-480001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 2.4.1</em></a><em class="calibre11">, Frontend action</em>.</p></li>
</ul>
<p class="hidden">We have to specify a path to the LLVM <code class="calibre13">install </code>folder to <a id="dx1-30062" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>build our tool. As was mentioned earlier, the path has to be specified via the <code class="calibre13">LLVM_HOME</code> environment variable. Our configuration command (see <a href="#x1-30003r12" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.12</a>) specifies the path as the <code class="calibre13">install</code> folder inside the LLVM project source tree. Thus we can build our tool as follows:</p>
<pre id="verbatim-17" class="console">export LLVM_HOME=&lt;...&gt;/llvm-project/install
mkdir build
cd build
cmake -G Ninja ..
ninja</pre>
<p class="hidden"><a id="x1-30063r15" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-30064" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.15</strong>: The syntax-check build commands </p>
<p class="hidden">We can run the tool as follows:</p>
<pre id="verbatim-18" class="console">$ cd build
$ ./syntax-check --help
USAGE: syntax-check [options] &lt;source0&gt; [... &lt;sourceN&gt;]
...</pre>
<p class="hidden"><a id="x1-30065r16" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-30066" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.16</strong>: The syntax-check –help output </p>
<p class="hidden">The program will successively terminate if we run it on a valid C++ source file, but it will produce an error message if it’s run on a broken C++ file:</p>
<pre id="verbatim-19" class="console">$ ./syntax-check mainbroken.cpp -- -std=c++17
mainbroken.cpp:2:11: error: expected ’;’ after return statement
  return 0
          ^
          ;
1  error generated.
Error while processing mainbroken.cpp.</pre>
<p class="hidden"><a id="x1-30067r17" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-30068" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.17</strong>: The syntax-check run on a file with a syntax error </p>
<p class="hidden">We used ’- -’ to pass additional arguments to the compiler in <a href="#x1-30067r17" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.17</a>, specifically indicating that we want to use C++17 with the option ’-std=c++17’.</p>
<p class="hidden">We can also run our tool with the LLDB debugger:</p>
<pre id="verbatim-20" class="console">$  &lt;...&gt;/llvm-project/install/bin/lldb \
                        ./syntax-check \
                        --           \
                        main.cpp     \
                        -- -std=c++17</pre>
<p class="hidden"><a id="x1-30069r18" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-30070" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.18</strong>: The syntax-check run under debugger </p>
<p class="hidden">We run <code class="calibre13">syntax-check </code>as the <a id="dx1-30071" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>primary binary and set <code class="calibre13">main.cpp </code>source file as an argument for the tool (<a href="#x1-30069r18" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.18</a>). We also pass additional compilation flags (-std=c++17) to the syntax-check executable.</p>
<p class="hidden">We can set a breakpoint and run the program as follows:</p>
<pre id="listing-10" class="source-code">1(lldb) b clang::ParseAST 
 
2 ... 
 
3 (lldb) r 
 
4 ... 
 

5 Running without flags. 
 
6 Process 608249 stopped 
 

7 * thread #1, name = ’syntax-check’, stop reason = breakpoint 1.1 
 

8    frame #0: ... clang::ParseAST(...) at ParseAST.cpp:117:3 
 

9    114 
 
10    115  void clang::ParseAST(Sema &amp;S, bool PrintStats, bool SkipFunctionBodies) { 
 

11    116    // Collect global stats on Decls/Stmts (until we have a module streamer). 
 

12 -&gt; 117    if (PrintStats) { 
 
13    118     Decl::EnableStatistics(); 
 

14    119     Stmt::EnableStatistics(); 
 

15    120    } 
 
16 (lldb) c 
 
17 Process 608249 resuming 
 

18 Process 608249 exited with status = 0 (0x00000000) 
 

19 (lldb)</pre>
<p class="hidden"><a id="x1-30091r19" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-30092" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 1.19</strong>: LLDB session for Clang Tool test project </p>
<p class="hidden">We set a breakpoint in the <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">ParseAST</code> function (<a href="#x1-30091r19" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.19</a>, line 1). The function is the primary entry point for source code parsing. We run the program on <em class="calibre11">Line 3 </em>and continue the execution after the breakpoint on <em class="calibre11">Line</em> <em class="calibre11">16</em>.</p>
<p class="hidden">We will use the same debugging techniques later in the book when we investigate Clang’s source code. <a id="x1-30093r43" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h2 data-number="1.1.5" id="sigil_toc_id_23" class="likechapterhead">1.5  <a id="x1-310005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Summary</h2>
<p class="hidden">In this chapter, we covered the history of the LLVM project, obtained the source code for LLVM, and explored its internal structure. We learned about the tools used to build LLVM, such as CMake and Ninja. We studied the various configuration options for building LLVM and how they can be used to optimize resources, including disk space. We built Clang <a id="dx1-31001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>and LLDB <a id="dx1-31002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>in debug and release modes and used the resulting tools to compile a basic program and run it with the debugger. We also created a simple Clang tool and ran it with the LLDB debugger.</p>
<p class="hidden">The next chapter will introduce you to the compiler design architecture and explain how it appears in the context of Clang <a id="dx1-31003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>. We will primarily focus on the Clang <a id="dx1-31004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>frontend, but we will also cover the important concept of the Clang <a id="dx1-31005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>driver – the backbone that manages all stages of the compilation process, from parsing to linking. <a id="x1-31006r54" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h2 data-number="1.1.6" id="sigil_toc_id_24" class="likechapterhead">1.6  <a id="x1-320006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Further reading</h2>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">Getting Started with the LLVM System: <a href="https://llvm.org/docs/GettingStarted.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://llvm.org/docs/GettingStarted.html</a></p></li>
<li class="calibre14"><p class="calibre15">Building LLVM with CMake: <a href="https://llvm.org/docs/CMake.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://llvm.org/docs/CMake.html</a></p></li>
<li class="calibre14"><p class="calibre15">Clang Compiler User’s Manual: <a href="https://clang.llvm.org/docs/UsersManual.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://clang.llvm.org/docs/UsersManual.html</a></p></li>
</ul>
<p class="hidden"><a id="x1-32001r15" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


</div>
</div>
</body></html>