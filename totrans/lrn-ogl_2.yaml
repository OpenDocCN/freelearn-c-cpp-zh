- en: Drawing Shapes and Applying Textures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter was all about setting up our project to use different types
    of libraries, such as GLFW, GLEW, SMFL, and SDL. In this chapter, we'll go beyond
    the setup part and learn to implement some really cool OpenGL stuff. We'll learn
    about shaders and how to use them to create various shapes. Then, we'll move on
    to learn how to create a separate shader file and reference that in our code.
    We'll also discuss how to apply different textures to shapes using the SOIL library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics in detail:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Learning to draw a triangle using a shader
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a separate shader file and referencing it in the main code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a rectangle and applying textures to it using the SOIL library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will initiate you into OpenGL coding and you'll learn a lot of
    concepts related to it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Before we get started with coding, there a few things that we need to understand.
    Firstly, the code we’ll be writing from now on is platform- and framework-independent.
    So, it doesn’t matter if you are using Xcode on Mac or Visual Studio on Windows,
    the OpenGL code on any platform will be the same, as OpenGL is a platform-independent
    programming language. Secondly, for this chapter, we’ll be using the GLFW library.
    As we won’t be writing any GLFW-specific code, the code in this chapter will be
    relevant for SFML, SDL, or any other library that you wish to use.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to all the code files for this chapter in the `Chapter02` folder
    on GitHub. The GitHub link can be found in the preface of the book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a triangle
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we’ll be looking at how to draw a triangle in OpenGL using
    the GLFW library. To begin with, let’s go to the file in which we wrote code to
    create an OpenGL rendering window using the GLFW library in the previous chapter,
    and make the necessary changes to it. Let''s take a look at the following steps
    to understand the code required to draw a triangle:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by including the essential header files in our code:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To create shapes in modern OpenGL, we need to create shaders. So, let’s begin
    by adding some shaders to our code. Firstly, we’ll add a constant, `GLchar *`,
    and we’ll call it `vertexShaderSource`. This is going to be a string and its version
    will be `330 core` :'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `330 core` defines the core shader language version for OpenGL version 3.3\.
    If you're using OpenGL version 4.0, then the shader language version won't necessarily
    be `440`; it could be something different. By looking for it on the internet,
    you can get an idea of which shader version you should be using.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vertexShaderSource` that we mentioned in the preceding line of code is
    just going to handle the **location** and **positioning** of our triangle, which
    we’ll define as follows:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And in the following code, we’ll have another shader source that is the `fragmentShaderSource`.
    This will handle the **color** and **texture** of our triangle. At the moment,
    we are explicitly setting only the color value in our shader, in the `vec4` variable:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To the variable `vec4` in the preceding code, we've assigned the values `1.0f`,
    `0.5f`, `0.2f`, and `1.0f`, which are the red, green, blue, and alpha values.
    The colors that we have defined here have ranges between 0 and 1, with 0 being
    off and 1 being full intensity; this is very similar to RGB color values ranging
    between 0 and 255.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the following lines of code, we will define our rendering window as
    discussed in the previous chapter, just take a look at the following code for
    review:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, before the `while` loop, we''ll add a line of code to define our shader.
    Let''s begin by adding the following code to our program:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding lines of code, we created a variable for `vertexShader` and
    defined the source of the shader with `glShaderSource()`. And for that function,
    we passed the parameters, number `1` as a reference to the `vertexShaderSource`,
    and for the final parameter, we passed `NULL` for now.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to compile the shader using `glCompileShader()`, and in
    there we''ll pass `vertexShader`. Then, we''re going to check for any compilation
    errors using `GLint success`. We''ll display these compilation errors to the developers
    in the form of a log. Therefore, we define a `char` variable, `infoLog`, and it''s
    going to be an array of 512 items:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we''ll add `glGetShaderiv()` function to our code. Which will return
    in params the values of parameter for our shader object. For that function, we''ll
    pass the parameters like `vertexShader`, the status of compilation `GL_COMPILE_STATUS`
    and then pass `&success`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, we'll check whether our shader has successfully compiled with the help
    of an `if` statement. If it hasn't been successfully compiled, a shader log will
    be generated and it will let the developer know about the compilation errors.
    To display the errors, we'll add `glGetShaderInfoLog()` function and in it, we'll
    pass the parameters as `vertexShader`, `512`, `NULL`, and `infoLog`, and then
    add
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"` and log out the
    `infoLog` so we can see it in more depth:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we''ll do the same for the fragment shader, take a look at the following
    highlighted lines of code, to understand the changes made for the fragment shader:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then, we are going to link the shaders. For that, we'll create a variable called
    `shaderProgram` and reference it in `glCreateProgram();`. The `glCreateProgram()`
    creates an empty program object and returns a non-zero value by which it can be
    referenced. A **program object** is an object to which shader objects can be attached.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we''ll define `glAttachShader();` function to attach our shaders. In
    there we''re going to pass the `shaderProgram`, which is the variable that we
    just created in the previous step. And then we''ll pass the shaders that we''re
    attaching to it. So, the first one we''ll pass is `vertexShader` and then we''ll
    attach the `fragmentShader`. Then, we''ll define the function `glLinkProgram();`,
    and we''ll link the `shaderProgram` to it. Take a look at the following code to
    understand the description:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将定义`glAttachShader();`函数来附加我们的着色器。在那里，我们将传递`shaderProgram`，这是我们之前步骤中刚刚创建的变量。然后我们将传递要附加到其上的着色器。所以，第一个我们将传递的是`vertexShader`，然后我们将附加`fragmentShader`。然后，我们将定义`glLinkProgram();`函数，并将`shaderProgram`链接到它。看看以下代码以了解描述：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next thing we''re going to do is check for any linking errors, always remember
    to check for any errors in your code. We''ll check the error as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将检查任何链接错误，始终记得检查你代码中的任何错误。我们将如下检查错误：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding line of code, we defined `glGetProgramiv();` and referenced
    our `shaderProgram` to it as we'll be checking whether there are any errors present
    in the code. Then, we'll check for the link status and assign its result to success.
    Next, we checked whether the linking of the shaders was successful. If the linking
    was not successful, we do essentially the same as we did in the previous lines
    of code; that is we'll generate the error log.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，我们定义了`glGetProgramiv();`并引用了我们的`shaderProgram`，因为我们将会检查代码中是否存在任何错误。然后，我们将检查链接状态并将结果分配给成功。接下来，我们检查着色器的链接是否成功。如果链接不成功，我们将基本上与之前几行代码做相同的事情；也就是说，我们将生成错误日志。
- en: We define `glGetProgramInfoLog ();`function and in there we pass the parameters
    such as `shaderProgram`, because that's what we're checking in the errors for.
    Then we pass in `512` for the number of items and `NULL` array and the `infoLog`,
    because this is what we're going to assign any error logs to. Then we enter the
    error message that need to be displayed for the developer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`glGetProgramInfoLog ();`函数，并在其中传递了参数，例如`shaderProgram`，因为这是我们检查错误时需要检查的内容。然后我们传递了`512`作为项目数量，`NULL`数组以及`infoLog`，因为这是我们打算分配任何错误日志的地方。然后我们输入了需要显示给开发者的错误信息。
- en: So, now that we've checked for any errors while linking our shader program,
    we can actually delete the vertex and fragment shaders because we'll no longer
    be using them as they're part of our shader program now. So, we typed `glDeleteShader();`function
    and reference the vertex and fragment shaders to it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经检查了在链接着色器程序时是否有任何错误，我们实际上可以删除顶点和片段着色器，因为我们将不再使用它们，因为它们现在是我们的着色器程序的一部分。所以，我们输入了`glDeleteShader();`函数并引用了顶点和片段着色器。
- en: 'Next, what we''re going to do is define the vertex data so that we can actually
    draw the triangle in terms of position:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要做的是定义顶点数据，以便我们能够根据位置实际绘制三角形：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, if you wanted draw a quadrilateral, you would have to
    define four vertices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果你想绘制一个四边形，你必须定义四个顶点。
- en: In the preceding lines of code, we began by defining a float array, `vertices[]`,
    and in it we defined our left, right, and the top coordinates.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，我们首先定义了一个浮点数组`vertices[]`，并在其中定义了我们的左、右和顶部坐标。
- en: For the coordinates that we defined, in OpenGL by default if you don't explicitly
    set them, the values of your screen range between `-1` and `1`. So, that the value`0`
    is in the middle and `0.5` is 25% of the away from the middle, or 75% is the away
    from the left-hand side. In later sections, we will look at changing that system
    so it's actually using more of the screen.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们定义的坐标，在OpenGL中默认情况下，如果你没有明确设置它们，你的屏幕值范围在`-1`和`1`之间。所以，值`0`位于中间，`0.5`是中间的25%，或者75%是远离左侧。在后面的章节中，我们将探讨如何更改该系统，使其实际上使用更多的屏幕。
- en: Now that we've got the `vertices[]` array created, what we need to do is create
    the **vertex buffer object** (**VBO**) and the **vertex array object** (**VAO**).
    We'll begin by defining `GLuint` variables `VBO`, `VAO`. Then, we're going to
    generate the vertex array by simply typing `glGenVertexArrays();`, and in this
    function, we'll pass `1` and a reference to VAO. Next, we'll generate the buffers
    by defining the function `glGenBuffers();` and to that, we'll pass `1` and pass
    reference `VBO` to it.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we''ll bind the vertex array object and then bind and set the vertex
    buffers, so let''s get on with that. We''ll add `glBindVertexArray();`function
    and pass `VAO` to it. Then, we''ll add `glBindBuffer();` function and pass `GL_ARRAY_BUFFER`
    and `VBO` to it. Next, we''ll add `glBufferData();` function and pass `GL_ARRAY_BUFFER`
    and `size()`. As we''ll be checking the size of our vertices in a dynamic way
    that is the reason we passed the function `size()` and to this function we''ll
    pass in the vertices that we are drawing, and then finally we''re going pass `GL_STATIC_DRAW`.
    So, this is just the buffer data that we''ll be using to draw our good stuff:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, we'll create the vertex pointer, so we'll add the function `glVertexAttribPointer()`and
    to this function, we'll pass the parameters as highlighted in the following code.
    Then, we'll enable the vertex array by typing `glEnableVertexAttribArray()` function
    and we'll pass `0` to it.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we''ll bind the buffer, adding `glBindBuffer()`function to our code.
    This is going to take two values: `GL_ARRAY_BUFFER` and `0.`'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then to the next line, we''ll add `glBindVertexArray()` function and this is
    going to be `0`. As we are unbinding the vertex array object over here. It''s
    always a good thing to unbind any buffers or arrays to prevent strange bugs. Take
    a look at the following code:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding code to draw the shape
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing we are going to do is add code to draw the triangle:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: We are going to draw the shape within our while loop. We'll want to draw it
    after the `glClear()` function. So, once the screen's been cleared and before
    the screen buffers have been swapped, we'll add function `glUseProgram()`. This
    will indicate what shader program we're using, and for our project, it is `shaderProgram`
    that we have linked our vertex and fragment shaders to.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we'll add `glBindVertexArray();` function and we bind the VAO to it.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll want to call `glDrawArrays();` function as this will finally draw
    our triangle. In the first thing that we'll pass in the `glDrawArrays();` function
    is the mode, that is `GL_TRIANGLES` or `GL_QUAD` or `GL_LINE`. Depending on how
    many vertices you have and what sort of object or shape you're trying to achieve,
    this will vary—we'll be covering it in more depth later in this chapter. The second
    parameter that we'll pass to `glDrawArrays();` function is `0` and the final parameter
    that we pass is `3`, as we've put how many vertices are there in our shape as
    it's a triangle.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, add `glBindVertexArray()` function and to it we pass `0`. We are just
    unbinding it.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, there''s literally one last thing to do: cleaning up. We''ll de-allocate
    all the resources once we''ve finished using them. So, outside of the loop, add
    `glDeleteVertexArrays()` function and assign `1` , `&VAO` and then add `glDeleteBuffers()`
    function to delete the buffers. Take a look at the following code to understand
    the preceding code description, also observe the highlighted terms in the code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we are ready to run our code. Once it gets complied without any errors,
    you will get the following triangle as the output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9b89358-4600-4127-abaf-3c8acccaa246.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: Abstracting the shaders
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at shaders in this section, even though we've looked at shaders
    in the previous section while creating the triangle and using a shader to color
    it. What we're going to do in this section is to abstract the shader code into
    a vertex shader file and a fragment shader file so that it's a lot neater and
    more reusable. And, we're also going to abstract out the loading of the shader,
    as once we've abstracted that out, we probably won't need to change it at all,
    or at least there won't be too many changes to it. Further, in our projects, we'll
    just use these files to load the shaders in our code, which will make it easy
    to use.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Creating the shader files
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create the files:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin by creating two new empty files in our project IDE and name those
    two files `core.vs` and `core.frag`. Here, `vs` stands for vector shader file
    and `frag` stands for fragment shader file.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It doesn't actually matter what you name these as long as you refer to the exact
    name and the extension when you refer to them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, open your `core.vs` file and cut and paste the `VectorShaderSource` code
    that we had added in the previous section. Make the highlighted changes shown
    in the following code:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's save this file and our vector shader file is created. Next, we're going
    to do essentially the same for the fragment shader file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s open up `core.frag` in our IDE and cut and paste `fragmentShaderSource`
    code from the code in the previous section. Once pasted, make changes to it as
    highlighted in the following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Save this file and we've now created the fragment shader file too. Let's move
    on to create the Shader.h file for abstracting the loading of shader code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Shader.h header file
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we''ll also create the shader loading file that is `Shader.h` and use
    that to load our shader into the code. Follow these steps to create the `Shader.h`
    file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: So, let's create an empty header file in our project and name that file `Shader.h`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once this file is created, open it and cut and paste the shader loading code
    from the code that we had mentioned in the previous section.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we're actually going to do is cut everything just after the `glViewport(
    0, 0, screenWidth, screenHeight );` code and above the vertices array `GLfloat
    vertices[]` code. As the code that we cut was actually loading our shaders.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实际上要做的就是剪切`glViewport( 0, 0, screenWidth, screenHeight );`代码之后的全部内容，以及顶点数组`GLfloat
    vertices[]`代码之上的内容。因为我们剪切出的代码实际上是加载我们的着色器。
- en: 'Then, make the changes shown in the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照以下代码进行更改：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So, what we've got in the preceding lines of code is just some simple `#ifndef`
    and `#define` preventing it from being included multiple times. We're just including
    the stream and string headers because they're what we're going to be loading our
    files into, so we need the correct headers to load it. Then, we need GLEW obviously,
    which assumes you've got GLEW set up.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在前面几行代码中，我们只是使用简单的`#ifndef`和`#define`来防止它被多次包含。我们只是包含流和字符串头文件，因为它们是我们将要加载文件的地方，所以我们需要正确的头文件来加载它。然后，显然我们需要GLEW，这假设你已经设置了GLEW。
- en: 'After that, we''ve got the `GLuint` program, and we''ve got some comments right
    there. We''ll construct the shader on the fly:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们有了`GLuint`程序，并且那里有一些注释。我们将实时构建着色器：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following variables are used to store and load the code and the shader
    file:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下变量用于存储和加载代码和着色器文件：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the following code, we''re just handling some exceptions:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，我们只是在处理一些异常：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the following code we are using the string stream, what we''re going to
    do is open the file so we''ve got the vertex and the fragment path. Using the
    string streams, we''re reading the file into the actual stream itself. And then,
    because we don''t need it anymore, we can just close it. Then, we''ll load it
    into our strings and catch any errors there. It''s very simple stuff if you''ve
    done C++ before, which we recommend you should be familiar with:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们使用了字符串流，我们要做的是打开文件，以便我们获取顶点和片段路径。使用字符串流，我们将文件读取到实际的流中。然后，因为我们不再需要它了，我们可以直接关闭它。然后，我们将它加载到我们的字符串中，并捕获任何错误。如果你之前做过C++，这很简单，我们建议你应该熟悉C++：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that, we''re just getting the C string. Then, we''re just compiling the
    shaders, which we''ve already done. So, after those first two lines of code, we''re
    sort of done:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们只是获取C字符串。然后，我们只是编译着色器，这我们已经做了。所以，在代码的前两行之后，我们基本上就完成了：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And then here''s a lower line, just saying to use the program:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后这里有一条低行，只是说使用程序：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So, what we've done in the preceding code is make our shader code a bit more
    dynamic. Next, we're going to go to our `main.cpp` and carry out some changes
    to it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在前面的代码中使我们的着色器代码变得更加动态。接下来，我们将进入`main.cpp`并对其进行一些更改。
- en: Making changes to the draw triangle code
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改绘制三角形的代码
- en: 'As we created our shader files and the `Shader.h` header file in the preceding
    sections, we''ll now load those files into our triangle code. To do this, we''ll
    have to make certain changes to the triangle code that we wrote earlier. Check
    out the below mentioned steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在前面的章节中创建了着色器文件和`Shader.h`头文件，我们现在将加载这些文件到我们的三角形代码中。为此，我们必须对我们之前编写的三角形代码进行一些更改。请查看以下步骤：
- en: 'We''ll begin by including the `Shader.h` header file, because without that
    we can''t actually use the `Shader` class:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先包括`Shader.h`头文件，因为没有它，我们实际上无法使用`Shader`类：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, before defining our vertices, we''ll add the following line of highlighted
    code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在我们定义顶点之前，我们将添加以下高亮显示的代码：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For Xcode, this highlighted code will be replaced with the following line of
    code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Xcode，这个高亮显示的代码将被以下行代码替换：
- en: '`Shader ourShader( "resources/shaders/core.vs", "resources/shaders/core.frag"
    );`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shader ourShader( "resources/shaders/core.vs", "resources/shaders/core.frag"
    );`'
- en: If you execute our triangle code without adding this line on Mac you will get
    an error and the triangle won't be generated in your output window.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在Mac上添加这一行执行我们的三角形代码，你将得到一个错误，并且三角形不会在输出窗口中生成。
- en: 'The reason this happens is there are executable files in your project folder,
    but we don''t have any resource files. So, we''ll have to add those file to our
    project:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 发生这种情况的原因是项目文件夹中有可执行文件，但我们没有资源文件。所以，我们必须将这些文件添加到我们的项目中：
- en: What we want to do is go to our project folder in Xcode, right-click on it,
    go to New Folder, and create a folder called `resources`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要做的是在Xcode的项目文件夹中，右键单击它，转到新建文件夹，创建一个名为`resources`的文件夹。
- en: Inside the `resources` folder, we'll create another folder called `shaders`.
    And then in there, we create a folder that's called `images`/`videos` whenever
    we need those particular file types. So, this is going to be good for the future
    as well.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources`文件夹内，我们将创建另一个名为`shaders`的文件夹。然后在那里，当我们需要这些特定文件类型时，我们创建一个名为`images`/`videos`的文件夹。所以，这对未来也会很有好处。
- en: Next, what we'll do is move our shader files, `core.vs` and `core.frag`, into
    the `shader` folder.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将把我们的着色器文件`core.vs`和`core.frag`移动到`shader`文件夹中。
- en: Then, go to your project, go to Build Phases, and then click on + and click
    on the New Copy Files Phase option.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到你的项目，转到构建阶段，然后点击加号，并点击新建复制文件阶段选项。
- en: Once you've clicked that, you'll have a new section, Copy Files (0 items). Open
    that and make sure Destination is set to Resources, and then click on the + sign
    below it.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击之后，你会看到一个新部分，复制文件（0项）。打开它，确保目标设置为Resources，然后点击其下的加号。
- en: Then, select the `resources` folder and click on the Add button.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择`resources`文件夹，并点击添加按钮。
- en: 'Furthermore, there are a few changes that we want to make to our `vertices
    []` array. As you may remember when we created `core.vs`, what we did was we actually
    created an input for the color as well. So, instead of just explicitly setting
    the color, we''re going to allow some sort of color input. And to do that, we''re
    going to expand out the vertices array as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还想对我们的`vertices []`数组做一些修改。你可能记得当我们创建`core.vs`时，我们实际上创建了一个颜色输入。所以，我们不是直接设置颜色，我们将允许某种颜色输入。为此，我们将扩展顶点数组如下：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding lines of code, what we actually did was added the color by
    putting the values for red, green, and blue color. This is going to be really
    exciting because we're assigning a color to each of the vertices, and what's going
    to happen is, it will blend the colors together and this will create a really
    amazing effect on our triangle.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码行中，我们实际上是通过放置红色、绿色和蓝色的值来添加颜色的。这将非常令人兴奋，因为我们正在为每个顶点分配一个颜色，接下来会发生的事情是，颜色将混合在一起，这将在我们三角形上产生一个非常惊人的效果。
- en: 'Next, we''ll go to our position attribute and color attribute code, and replace
    those with the following code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将进入我们的位置属性和颜色属性代码，并用以下代码替换它们：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding lines of code will define the position and color attributes of
    the triangle. In the `vertices []` as we''ve six values now: 3 for position coordinates
    and other 3 for color coordinates. That is the reason why we''ve put 6 in the
    preceding code because we''ve got `6` so we''ve got two values for each vertex
    and we''ve added color, so we need to add `6` to our code.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行将定义三角形的定位和颜色属性。在`vertices []`中，我们现在有六个值：3个用于位置坐标，另外3个用于颜色坐标。这就是为什么我们在前面的代码中放置了6，因为我们有`6`，所以每个顶点有两个值，我们添加了颜色，因此我们需要在代码中添加`6`。
- en: 'Next, we''ll get rid of:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将删除：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We''ll then move on to our while loop and replace the `glUseProgram( shaderProgram
    )`with the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将进入while循环，并将`glUseProgram( shaderProgram )`替换为以下代码：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With this preceding last minor change to our code, we are now ready to run
    our program. Once it''s successfully complied without any errors, you will get
    the following colorful triangle as output on your screen:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对代码进行上述最后微小的修改，我们现在可以运行我们的程序了。一旦成功编译且没有错误，你将在屏幕上得到以下彩色三角形的输出：
- en: '![](img/b60a45ae-1411-4d36-9474-986fb34cd6f4.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b60a45ae-1411-4d36-9474-986fb34cd6f4.png)'
- en: 'As we''ve added a color to each one of the vertices in the code. The color
    in the output triangle has blended together. That''s what OpenGL does: it blends
    the colors together. Chances are if you''ve Googled OpenGL before, or just in
    general if you''re into game development, you would have come across some sort
    of similar triangle like this. This is almost a rite of passage in OpenGL equivalent
    to the Hello World code in other programming languages.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们已经为每个顶点添加了颜色。输出三角形的颜色已经混合在一起。这就是OpenGL所做的事情：它将颜色混合在一起。如果你之前搜索过OpenGL，或者你一般对游戏开发感兴趣，你可能会遇到一些类似这样的三角形。这几乎是OpenGL的一个入门仪式，相当于其他编程语言中的Hello
    World代码。
- en: Loading and applying textures to the shape
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载并将纹理应用到形状上
- en: In this section, we'll look how to load textures in our code and learn to apply
    these textures to our objects. Textures is an image which is used add detail to
    an object. Imagine object such as cube and if we apply wooden texture to it, then
    it will look like a wooden box in our game world.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: For this section, our object will be a rectangle. So first we'll learn how to
    draw rectangle shape in OpenGL and then understand how to apply textures to it.
    To apply texture to the shape, we'll prefer when using SOIL library, which is
    the Simple OpenGL Image Library. If you wish, you can use other libraries such
    as libpng which, as the name suggests, just supports PNG format images. But in
    this section, we'll only learn about SOIL, actually about SOIL2.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: SOIL is a cross-platform library and it's supported on Android and iOS as part
    of game development. GLFW doesn't have any image loading methods built in, that
    is the reason why we are going to use SOIL library to load our textures. Also,
    SOIL helps in making our code as dynamic as possible across various platforms,
    and it's really easy to use as well.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: So, first let's understand how to set up our project to use the SOIL library
    on Windows and Mac platform.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project to use SOIL on Windows
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll understand how to set up our project to use the SOIL
    library on a Windows platform. So, we'll begin by downloading the SOIL library
    and Premake. You must be wondering, what is Premake? Premake is a command line
    tool used to generate project files for platforms such as Visual Studio, Xcode,
    and so on.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to understand the set up process:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Open up your web browser and go to the following link [https://bitbucket.org/SpartanJ](https://bitbucket.org/SpartanJ).
    In the Repositories section click on the SOIL2 option and open the webpage, and
    select the first fork under Introduction for the latest version of SOIL library.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reason we are downloading the SOIL2 library is beacuse the original SOIL
    library is actually very old and hasn't been updated for a very long time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve downloaded that, just search for Premake on Google or visit the
    following link: [https://premake.github.io/](https://premake.github.io/). Then,
    click on the Download option. It is recommended that you download the latest stable
    branch, so download the 4.4 version, which is currently stable (at the time of
    writing this book).'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to the location where you've downloaded the files and extract both
    of the zipped folders.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, go to the `Premake` folder and copy and paste `premake4.exe` into the
    `SOIL` folder, which we just extracted.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up the command prompt and in here you may want to change the directory
    path to the location where you downloaded and extracted your `SOIL` folder. Suppose
    the `C:` drive is the drive where all your files get downloaded and you have downloaded
    and extracted your `SOIL` folder to that drive, then all you have to do is type
    `cd` in command prompt and then just drag and drop your `SOIL` folder into it.
    It will automatically enter the path where the `SOIL` folder is located.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it's any other drive that your downloads go to, then what you have to do
    is first tell command prompt to change it to that particular drive. To do that,
    just type the actual letter of the drive then type `:` and hit *Enter*, and then
    you can follow the previous drag-and-drop process.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Next, in Command Prompt, type in `premake4.exe`—or whatever the executable is
    called—followed by `vs2017` and then hit *Enter*. This will generate our Visual
    Studio project.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're using an older version, such as 2010, you can use 2010 in the `vs`
    command. It doesn't have a command for newer versions of Visual Studio, but if
    you enter that, it will prompt you to upgrade some of the properties, so don't
    worry about that.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Now let's go to our `SOIL` folder, open the `make` folder present inside it
    and then open up the `Windows` folder.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `Windows` folder, you'll get a `SOIL2.sln` file. Double-click on
    it and once that has opened in Visual Studio, you might get an upgrade the compiler,
    and libraries pop window. Just click on the OK button.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, in the Visual Studio, on the right-hand side, you'll see a filenames.
    The only one that we're concerned with is `soil2-static-lib`. Right-click on that
    file and then click on Build option. This will build our project. You can then
    close Visual Studio.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, if you go back to the `SOIL` folder, there'll be some more folders generated.
    The one we're interested in is the `lib` folder.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `lib` folder, there's a `Windows` folder which consists of the `.lib`
    file, which is what we need.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy that `.lib` file and go to the location where you have your OpenGL project
    created. What we'll do there is, the location where `.sln` file is present, we'll
    make a new folder and name it as `External Libraries`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `External Libraries` folder we will create a sub folder called `SOIL2`,
    and inside that, we'll create a folder called `lib`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, in the `lib` folder that we created just now, paste the `soil2-debug.lib`
    file. So, this way we're going to use relative linking to link our SOIL library.
    If you are aware of the absolute linking process and wants to use it, you can
    use that.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And now, what we need to do is go back to the `SOIL` folder and copy the files
    present within the `SOIL2` folder and paste that in the `OpenGL_VisualStudio`
    folder which is present inside the `OpenGL` folder
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, once you've got all of these steps sorted, the one last thing to do is link
    up the `soil2-debug.lib` to our project. To link up the `.lib` file to our Visual
    Studio project with the relative linking, you can refer to the *Linking of GLFW
    and GLEW libraries with relative linking* section in the previous chapter.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, we have set up our project to use the SOIL library on Visual Studio.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project to use SOIL on Mac
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll understand how to set up our project to use the SOIL
    library on a Mac platform. Let''s take a look at the following steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up your web browser and go to the following link: [https://bitbucket.org/SpartanJ](https://bitbucket.org/SpartanJ).'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Repositories section click on the SOIL2 option and open the webpage,
    and select the first fork under Introduction for the latest version of SOIL library.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to the location where you've downloaded the files and extract them.
    Once extracted, go to the `src` folder and in it go to the `SOIL2` folder. Then
    just copy and paste that folder into your project directory in your system, which
    also contains your `main.cpp` and `shader` file.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, just add the library to our triangle project as you normally would. So,
    what we will do is right-click on the project in Xcode, go to the Add Files option,
    click on SOIL, and then click on the Add button.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, once we've got that included, that's it for the setup part. And now, we'll
    go back to our the code from the previous section and make modification to it
    so as to add textures to our shape.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Applying texture to our shape
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''re all set up to use the SOIL library, let''s go to our triangle
    code and make the necessary changes to load our shape and apply texture to it.
    Follow these steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''ll first include the SOIL library into our code; for that, type in
    the following line at the start of your code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we have typed `SOIL2/SOIL2.h` because our library is inside the `SOIL2`
    folder.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we''re going to do is enable the alpha support for images with
    extension such as PNG. To do that, type in the following lines of code after we
    have defined out `glViewport()` :'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding lines of code, the `glEnable( GL_BLEND )` function will help
    in blending the image in our shape. Then we used `glBlendFunc()` and to it we
    passed two parameters `GL_SRC_ALPHA` and `GL_ONE_MINUS_SRC_ALPHA`. This is how
    we enabled the alpha support.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll have to modify our vertices as we''ll be using a rectangular shape
    to apply our texture, and also we''ll have to add coordinates for our texture
    too. So take a look at the following vertices array and make the necessary changes
    to your code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As we''re going to draw a rectangle, we need four different vertices: bottom
    left, bottom right, top left, and top right. In the preceding code, the values
    that we''ve added don''t actually range between -1 and 1; these values range between
    0 and 1 so are know as normalized values. You might hear this term in computer
    graphics quite a lot. Normalized values basically means the values ranged between
    0 and 1\. So, for example, if you had an image that has a width of 1280 x 1280,
    and the normalized version was 0 to 1, if you were to set a value of 0.5, it would
    be at 640 because it''s halfway along and halfway between 0 and 1280 is 640\.
    This is just a very basic overview of normalization. If you want to know a bit
    more about it, feel free to Google it.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we''re going to create is another array for indices. Take a
    look at the following code and let''s try to understand it:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The reason we''ve defined two triangles in the preceding array is, as we''re
    drawing a quadrilateral in this section, our rectangle shape actually requires
    two triangle indices to be defined. Take a look at the following image to understand
    the concept:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47de2a46-2347-4650-a95c-a7b8d7498a2d.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: The preceding image shows defining of the triangle coordinates with and without
    indexing. So, let's have a look at the without indexing part. Without indexing,
    to draw a quadrilateral you'll need six different vertices, as seen in the image.
    Even though there are two pairs of similar coordinates that are shared between
    the two triangles, the vertices are not being efficiently defined. With indexing
    approach, however, we can share the vertices. So, as in the with indexing image,
    the two triangles share the same pair of vertices. So we'll reuse those and as
    a result, we'll be defining only four vertices. Ignore the numbering shown in
    the image; it's slightly different to our situation, but the principle still applies.
    And if you try and draw it out on paper and apply the numbers that we got in our
    indices array to the actual triangle or quadrilateral from the two, it will make
    a lot more sense. It might not be obvious why you would want to do this at the
    moment, and that's because we're only drawing a quadrilateral. But, imagine when
    you have a game and you've got thousands if not millions of triangles, and triangles
    forming various complex shapes. Thus this with indexing approach really becomes
    handy and increase the efficiency of your code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in our `GLuint` section below our indices, we want to create another
    buffer called `EBO`, so make the change to the code as highlighted in the following
    line:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We need to generate the buffers for the Element Buffer Objects (EBO), so type
    in the following highlighted lines of code and then we also need to bind that
    buffer :'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we''ll modify our position and the color attributes, and we''ll add one
    more attribute that is the texture coordinate attribute. Let''s check out the
    following highlighted code and try to understand the modifications done to it:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For the position and the color attributes in the preceding code, we have replaced
    `6` with `8`, as we have eight coordinates in our vertices array: three for the
    position, three for the colors, and two for the texture coordinates. And then,
    we created another vertex attribute pointer as the texture coordinate attribute.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're going to add the texture loading code. In our main code, after we've
    unbinded our vertex array and before the start of `while` loop, we'll add the
    texture loading code.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Firstly we'll need to create an `GLuint` `texture` variable as this will hold
    our reference to the texture.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll create `int` variables as `width` and `height`. This will define
    the width and the height of our texture.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we'll need to add `glGenTextures()` function and for this, we specify the
    `size` as `1` and put a reference to our texture variable.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll then bind the texture using `glBindTexture()` funtion. Take a look at
    the following highlighted code:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And then, we are going to set our texture parameters. For that, we''re going
    to add function `glTexParameteri ()` and to this function, we''ll pass the following
    parameter:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter that we're going to set is `GL_TEXTURE_2D`
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then for the `name` we're going to set the type of wrapping that we'll be using
    `GL_TEXTURE_WRAP_S`.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: And for the wrapping, we're going to add `GL_REPEAT`.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended you have a look at different wrapping techniques. You can
    find more information about this in the OpenGL API guides and if you look at [learnopengl.com](https://learnopengl.com/)
    and [open.gl](https://open.gl/), you will get to read a lot more information about
    all the lines of code that we have written.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what we''re going to do next is duplicate the previous line of code and
    make the following changes as highlighted in the code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we''re going to set the texture filtering. Check out the following code
    for it:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we are going to add the actual texture loading code to the main code.
    For that, we''re going to create unsigned char variable `*image` and this will
    hold the reference to the function `SOIL_load_image()`. And to this function we
    pass the following parameters:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First parameter will be the path of the actual image that we're going to use
    as texture for our object. Therefore, we'll put `res/images/image1.jpg`.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter will be the refrence to the width and the height of our
    image.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then for the third parameter, we're just going to pass it as `0`.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the fourth parameter we're going to set the loading method so will add `SOIL_LOAD_RGBA`.
    Even if it's a JPEG image, you always want to load it as an alpha image. The reason
    for that is, it allows the code that we're writing now to be more dynamic. So
    if we swap the JPEG image for a PNG image, it'll still work. If you put in a different
    type of alpha image, or an image without alpha, as long as that type is supported
    by SOIL, the code will work fine.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we''ll specify a two-dimensional texture image adding the function `glTexImage2d()`
    and to this function we are going to pass the highlighted parameters in the following
    code:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We'll generate the mipmaps, so we're going to put `glGenerateMipmap()` funtion.
    And for this function, we specify `GL_TEXTURE_2D` as it's a 2D texture that we
    are using.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we're going to free our image data, as it's always good to clean up. So,
    we'll add `SOIL_free_image_data()` function for that we merely specify our image
    character array.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we''re going to unbind the texture using `glBindTexture()` function and
    to that function we''ll pass `GL_TEXTURE_2D`, and we''ll unbind the texture by
    passing `0`. Have a look at the following code for a clear understanding:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You might be thinking what is a mipmap? A mipmap is essentially a level of detail
    scheme for texture image. It's a way of creating a bunch of small images by a
    factor of 2 of the original image, and then loading the one that is the closest
    to the actual texture being displayed at any given point, depending on the distance
    from the viewer. So if something's further away, the texture required isn't as
    big. Whereas if it's nearer, it requires a bigger texture. So, it just helps in
    loading the texture properly. It is recommended to have a quick check on the internet
    to understand mipmapping a bit more.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: We're not done with our code yet. So, we'll move on to our while loop now
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the while loop
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the below mentioned steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In the while loop we'll put some code between the point where we're using the
    shader and where we're binding the vertex array. What we want to do here is add
    `glActiveTexture()`function. This function will help us activating the texture
    that we specify.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we'll add function `glBindTexture()`. And for this function, we pass `GL_TEXTURE_2D`
    and `texture`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we just add `glUniform1i()` function and pass to it the following highlighted
    parameters.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then we''ll add the code to draw our container:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And the last thing that we need to do is just delete the buffer for the element
    buffer object. So, we''ll add `glDeleteBuffers( 1, &EBO );` to our code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And now, if we run our code. There will be some error in the compilation of
    the code and you will get the output similar to the following image:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0898dfef-fc48-41c6-87d2-e2a4133820bb.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: This is not what we intended; this is obviously not what we wanted to load in
    our shape. So, let's try to understand the reason behind this. The only reason
    we are getting the wrong output is because we have not updated our vertex and
    fragment shaders for loading the texture. So let's update it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Updating the shader files to integrate texture coordinates
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to carry out the modifications in your shader files:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s go to the vertex shader, our `core.vs` file, and make the changes
    highlighted in the following code:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You might be wondering what are we doing here in `TexCoord = vec2(texCoord.x,
    1.0 - texCoord.y);`. Well, what we're doing is swapping the y axis by subtracting
    our coordinates from `1`, and this is done simply because most images have the
    top y-axis inverted in OpenGL.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go to the fragment shader, `core.frag`, and make the following highlighted
    modifications:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And now, if we save the updated shader file and run our program, we will get
    the following output:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c4c10d5-abb9-4730-93e0-6867b3ef2cd9.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Check whether your image fit are spot on with the ratio. If it looks a bit squashed,
    that's simply because of the coordinates that we have defined for the vertices.
    It's nothing to do with the texture loading. In later chapters, we'll be learning
    to use logical coordinates, so that any image that you load can fit in properly.
    So, that is it for texture loading.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to draw various shapes using shaders. We began
    by drawing a triangle and adding color to it. Then, we used the triangle concept
    to draw our quadrilateral and learned how to apply texture to it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll learn how to apply transformations such as translation
    and rotation to our shape, and learn to draw a cube and apply texture to it. We''ll
    also explore the concepts of projections: Perspective and Orthographic, and how
    to implement those in our world.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
