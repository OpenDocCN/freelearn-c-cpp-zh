- en: Drawing Shapes and Applying Textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter was all about setting up our project to use different types
    of libraries, such as GLFW, GLEW, SMFL, and SDL. In this chapter, we'll go beyond
    the setup part and learn to implement some really cool OpenGL stuff. We'll learn
    about shaders and how to use them to create various shapes. Then, we'll move on
    to learn how to create a separate shader file and reference that in our code.
    We'll also discuss how to apply different textures to shapes using the SOIL library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning to draw a triangle using a shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a separate shader file and referencing it in the main code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a rectangle and applying textures to it using the SOIL library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will initiate you into OpenGL coding and you'll learn a lot of
    concepts related to it.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get started with coding, there a few things that we need to understand.
    Firstly, the code we’ll be writing from now on is platform- and framework-independent.
    So, it doesn’t matter if you are using Xcode on Mac or Visual Studio on Windows,
    the OpenGL code on any platform will be the same, as OpenGL is a platform-independent
    programming language. Secondly, for this chapter, we’ll be using the GLFW library.
    As we won’t be writing any GLFW-specific code, the code in this chapter will be
    relevant for SFML, SDL, or any other library that you wish to use.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to all the code files for this chapter in the `Chapter02` folder
    on GitHub. The GitHub link can be found in the preface of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a triangle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we’ll be looking at how to draw a triangle in OpenGL using
    the GLFW library. To begin with, let’s go to the file in which we wrote code to
    create an OpenGL rendering window using the GLFW library in the previous chapter,
    and make the necessary changes to it. Let''s take a look at the following steps
    to understand the code required to draw a triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by including the essential header files in our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To create shapes in modern OpenGL, we need to create shaders. So, let’s begin
    by adding some shaders to our code. Firstly, we’ll add a constant, `GLchar *`,
    and we’ll call it `vertexShaderSource`. This is going to be a string and its version
    will be `330 core` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `330 core` defines the core shader language version for OpenGL version 3.3\.
    If you're using OpenGL version 4.0, then the shader language version won't necessarily
    be `440`; it could be something different. By looking for it on the internet,
    you can get an idea of which shader version you should be using.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vertexShaderSource` that we mentioned in the preceding line of code is
    just going to handle the **location** and **positioning** of our triangle, which
    we’ll define as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the following code, we’ll have another shader source that is the `fragmentShaderSource`.
    This will handle the **color** and **texture** of our triangle. At the moment,
    we are explicitly setting only the color value in our shader, in the `vec4` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To the variable `vec4` in the preceding code, we've assigned the values `1.0f`,
    `0.5f`, `0.2f`, and `1.0f`, which are the red, green, blue, and alpha values.
    The colors that we have defined here have ranges between 0 and 1, with 0 being
    off and 1 being full intensity; this is very similar to RGB color values ranging
    between 0 and 255.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the following lines of code, we will define our rendering window as
    discussed in the previous chapter, just take a look at the following code for
    review:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, before the `while` loop, we''ll add a line of code to define our shader.
    Let''s begin by adding the following code to our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding lines of code, we created a variable for `vertexShader` and
    defined the source of the shader with `glShaderSource()`. And for that function,
    we passed the parameters, number `1` as a reference to the `vertexShaderSource`,
    and for the final parameter, we passed `NULL` for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to compile the shader using `glCompileShader()`, and in
    there we''ll pass `vertexShader`. Then, we''re going to check for any compilation
    errors using `GLint success`. We''ll display these compilation errors to the developers
    in the form of a log. Therefore, we define a `char` variable, `infoLog`, and it''s
    going to be an array of 512 items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll add `glGetShaderiv()` function to our code. Which will return
    in params the values of parameter for our shader object. For that function, we''ll
    pass the parameters like `vertexShader`, the status of compilation `GL_COMPILE_STATUS`
    and then pass `&success`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll check whether our shader has successfully compiled with the help
    of an `if` statement. If it hasn't been successfully compiled, a shader log will
    be generated and it will let the developer know about the compilation errors.
    To display the errors, we'll add `glGetShaderInfoLog()` function and in it, we'll
    pass the parameters as `vertexShader`, `512`, `NULL`, and `infoLog`, and then
    add
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"` and log out the
    `infoLog` so we can see it in more depth:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll do the same for the fragment shader, take a look at the following
    highlighted lines of code, to understand the changes made for the fragment shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Then, we are going to link the shaders. For that, we'll create a variable called
    `shaderProgram` and reference it in `glCreateProgram();`. The `glCreateProgram()`
    creates an empty program object and returns a non-zero value by which it can be
    referenced. A **program object** is an object to which shader objects can be attached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we''ll define `glAttachShader();` function to attach our shaders. In
    there we''re going to pass the `shaderProgram`, which is the variable that we
    just created in the previous step. And then we''ll pass the shaders that we''re
    attaching to it. So, the first one we''ll pass is `vertexShader` and then we''ll
    attach the `fragmentShader`. Then, we''ll define the function `glLinkProgram();`,
    and we''ll link the `shaderProgram` to it. Take a look at the following code to
    understand the description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we''re going to do is check for any linking errors, always remember
    to check for any errors in your code. We''ll check the error as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, we defined `glGetProgramiv();` and referenced
    our `shaderProgram` to it as we'll be checking whether there are any errors present
    in the code. Then, we'll check for the link status and assign its result to success.
    Next, we checked whether the linking of the shaders was successful. If the linking
    was not successful, we do essentially the same as we did in the previous lines
    of code; that is we'll generate the error log.
  prefs: []
  type: TYPE_NORMAL
- en: We define `glGetProgramInfoLog ();`function and in there we pass the parameters
    such as `shaderProgram`, because that's what we're checking in the errors for.
    Then we pass in `512` for the number of items and `NULL` array and the `infoLog`,
    because this is what we're going to assign any error logs to. Then we enter the
    error message that need to be displayed for the developer.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we've checked for any errors while linking our shader program,
    we can actually delete the vertex and fragment shaders because we'll no longer
    be using them as they're part of our shader program now. So, we typed `glDeleteShader();`function
    and reference the vertex and fragment shaders to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, what we''re going to do is define the vertex data so that we can actually
    draw the triangle in terms of position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, if you wanted draw a quadrilateral, you would have to
    define four vertices.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding lines of code, we began by defining a float array, `vertices[]`,
    and in it we defined our left, right, and the top coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: For the coordinates that we defined, in OpenGL by default if you don't explicitly
    set them, the values of your screen range between `-1` and `1`. So, that the value`0`
    is in the middle and `0.5` is 25% of the away from the middle, or 75% is the away
    from the left-hand side. In later sections, we will look at changing that system
    so it's actually using more of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've got the `vertices[]` array created, what we need to do is create
    the **vertex buffer object** (**VBO**) and the **vertex array object** (**VAO**).
    We'll begin by defining `GLuint` variables `VBO`, `VAO`. Then, we're going to
    generate the vertex array by simply typing `glGenVertexArrays();`, and in this
    function, we'll pass `1` and a reference to VAO. Next, we'll generate the buffers
    by defining the function `glGenBuffers();` and to that, we'll pass `1` and pass
    reference `VBO` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll bind the vertex array object and then bind and set the vertex
    buffers, so let''s get on with that. We''ll add `glBindVertexArray();`function
    and pass `VAO` to it. Then, we''ll add `glBindBuffer();` function and pass `GL_ARRAY_BUFFER`
    and `VBO` to it. Next, we''ll add `glBufferData();` function and pass `GL_ARRAY_BUFFER`
    and `size()`. As we''ll be checking the size of our vertices in a dynamic way
    that is the reason we passed the function `size()` and to this function we''ll
    pass in the vertices that we are drawing, and then finally we''re going pass `GL_STATIC_DRAW`.
    So, this is just the buffer data that we''ll be using to draw our good stuff:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll create the vertex pointer, so we'll add the function `glVertexAttribPointer()`and
    to this function, we'll pass the parameters as highlighted in the following code.
    Then, we'll enable the vertex array by typing `glEnableVertexAttribArray()` function
    and we'll pass `0` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll bind the buffer, adding `glBindBuffer()`function to our code.
    This is going to take two values: `GL_ARRAY_BUFFER` and `0.`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then to the next line, we''ll add `glBindVertexArray()` function and this is
    going to be `0`. As we are unbinding the vertex array object over here. It''s
    always a good thing to unbind any buffers or arrays to prevent strange bugs. Take
    a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Adding code to draw the shape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing we are going to do is add code to draw the triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to draw the shape within our while loop. We'll want to draw it
    after the `glClear()` function. So, once the screen's been cleared and before
    the screen buffers have been swapped, we'll add function `glUseProgram()`. This
    will indicate what shader program we're using, and for our project, it is `shaderProgram`
    that we have linked our vertex and fragment shaders to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we'll add `glBindVertexArray();` function and we bind the VAO to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll want to call `glDrawArrays();` function as this will finally draw
    our triangle. In the first thing that we'll pass in the `glDrawArrays();` function
    is the mode, that is `GL_TRIANGLES` or `GL_QUAD` or `GL_LINE`. Depending on how
    many vertices you have and what sort of object or shape you're trying to achieve,
    this will vary—we'll be covering it in more depth later in this chapter. The second
    parameter that we'll pass to `glDrawArrays();` function is `0` and the final parameter
    that we pass is `3`, as we've put how many vertices are there in our shape as
    it's a triangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, add `glBindVertexArray()` function and to it we pass `0`. We are just
    unbinding it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, there''s literally one last thing to do: cleaning up. We''ll de-allocate
    all the resources once we''ve finished using them. So, outside of the loop, add
    `glDeleteVertexArrays()` function and assign `1` , `&VAO` and then add `glDeleteBuffers()`
    function to delete the buffers. Take a look at the following code to understand
    the preceding code description, also observe the highlighted terms in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to run our code. Once it gets complied without any errors,
    you will get the following triangle as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9b89358-4600-4127-abaf-3c8acccaa246.png)'
  prefs: []
  type: TYPE_IMG
- en: Abstracting the shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at shaders in this section, even though we've looked at shaders
    in the previous section while creating the triangle and using a shader to color
    it. What we're going to do in this section is to abstract the shader code into
    a vertex shader file and a fragment shader file so that it's a lot neater and
    more reusable. And, we're also going to abstract out the loading of the shader,
    as once we've abstracted that out, we probably won't need to change it at all,
    or at least there won't be too many changes to it. Further, in our projects, we'll
    just use these files to load the shaders in our code, which will make it easy
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the shader files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create the files:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin by creating two new empty files in our project IDE and name those
    two files `core.vs` and `core.frag`. Here, `vs` stands for vector shader file
    and `frag` stands for fragment shader file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It doesn't actually matter what you name these as long as you refer to the exact
    name and the extension when you refer to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, open your `core.vs` file and cut and paste the `VectorShaderSource` code
    that we had added in the previous section. Make the highlighted changes shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let's save this file and our vector shader file is created. Next, we're going
    to do essentially the same for the fragment shader file.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s open up `core.frag` in our IDE and cut and paste `fragmentShaderSource`
    code from the code in the previous section. Once pasted, make changes to it as
    highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Save this file and we've now created the fragment shader file too. Let's move
    on to create the Shader.h file for abstracting the loading of shader code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Shader.h header file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we''ll also create the shader loading file that is `Shader.h` and use
    that to load our shader into the code. Follow these steps to create the `Shader.h`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: So, let's create an empty header file in our project and name that file `Shader.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once this file is created, open it and cut and paste the shader loading code
    from the code that we had mentioned in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we're actually going to do is cut everything just after the `glViewport(
    0, 0, screenWidth, screenHeight );` code and above the vertices array `GLfloat
    vertices[]` code. As the code that we cut was actually loading our shaders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, make the changes shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So, what we've got in the preceding lines of code is just some simple `#ifndef`
    and `#define` preventing it from being included multiple times. We're just including
    the stream and string headers because they're what we're going to be loading our
    files into, so we need the correct headers to load it. Then, we need GLEW obviously,
    which assumes you've got GLEW set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we''ve got the `GLuint` program, and we''ve got some comments right
    there. We''ll construct the shader on the fly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following variables are used to store and load the code and the shader
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we''re just handling some exceptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code we are using the string stream, what we''re going to
    do is open the file so we''ve got the vertex and the fragment path. Using the
    string streams, we''re reading the file into the actual stream itself. And then,
    because we don''t need it anymore, we can just close it. Then, we''ll load it
    into our strings and catch any errors there. It''s very simple stuff if you''ve
    done C++ before, which we recommend you should be familiar with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we''re just getting the C string. Then, we''re just compiling the
    shaders, which we''ve already done. So, after those first two lines of code, we''re
    sort of done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And then here''s a lower line, just saying to use the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So, what we've done in the preceding code is make our shader code a bit more
    dynamic. Next, we're going to go to our `main.cpp` and carry out some changes
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Making changes to the draw triangle code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we created our shader files and the `Shader.h` header file in the preceding
    sections, we''ll now load those files into our triangle code. To do this, we''ll
    have to make certain changes to the triangle code that we wrote earlier. Check
    out the below mentioned steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by including the `Shader.h` header file, because without that
    we can''t actually use the `Shader` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, before defining our vertices, we''ll add the following line of highlighted
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For Xcode, this highlighted code will be replaced with the following line of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Shader ourShader( "resources/shaders/core.vs", "resources/shaders/core.frag"
    );`'
  prefs: []
  type: TYPE_NORMAL
- en: If you execute our triangle code without adding this line on Mac you will get
    an error and the triangle won't be generated in your output window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason this happens is there are executable files in your project folder,
    but we don''t have any resource files. So, we''ll have to add those file to our
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: What we want to do is go to our project folder in Xcode, right-click on it,
    go to New Folder, and create a folder called `resources`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `resources` folder, we'll create another folder called `shaders`.
    And then in there, we create a folder that's called `images`/`videos` whenever
    we need those particular file types. So, this is going to be good for the future
    as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, what we'll do is move our shader files, `core.vs` and `core.frag`, into
    the `shader` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, go to your project, go to Build Phases, and then click on + and click
    on the New Copy Files Phase option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've clicked that, you'll have a new section, Copy Files (0 items). Open
    that and make sure Destination is set to Resources, and then click on the + sign
    below it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, select the `resources` folder and click on the Add button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Furthermore, there are a few changes that we want to make to our `vertices
    []` array. As you may remember when we created `core.vs`, what we did was we actually
    created an input for the color as well. So, instead of just explicitly setting
    the color, we''re going to allow some sort of color input. And to do that, we''re
    going to expand out the vertices array as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding lines of code, what we actually did was added the color by
    putting the values for red, green, and blue color. This is going to be really
    exciting because we're assigning a color to each of the vertices, and what's going
    to happen is, it will blend the colors together and this will create a really
    amazing effect on our triangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll go to our position attribute and color attribute code, and replace
    those with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding lines of code will define the position and color attributes of
    the triangle. In the `vertices []` as we''ve six values now: 3 for position coordinates
    and other 3 for color coordinates. That is the reason why we''ve put 6 in the
    preceding code because we''ve got `6` so we''ve got two values for each vertex
    and we''ve added color, so we need to add `6` to our code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll get rid of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll then move on to our while loop and replace the `glUseProgram( shaderProgram
    )`with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With this preceding last minor change to our code, we are now ready to run
    our program. Once it''s successfully complied without any errors, you will get
    the following colorful triangle as output on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b60a45ae-1411-4d36-9474-986fb34cd6f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we''ve added a color to each one of the vertices in the code. The color
    in the output triangle has blended together. That''s what OpenGL does: it blends
    the colors together. Chances are if you''ve Googled OpenGL before, or just in
    general if you''re into game development, you would have come across some sort
    of similar triangle like this. This is almost a rite of passage in OpenGL equivalent
    to the Hello World code in other programming languages.'
  prefs: []
  type: TYPE_NORMAL
- en: Loading and applying textures to the shape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look how to load textures in our code and learn to apply
    these textures to our objects. Textures is an image which is used add detail to
    an object. Imagine object such as cube and if we apply wooden texture to it, then
    it will look like a wooden box in our game world.
  prefs: []
  type: TYPE_NORMAL
- en: For this section, our object will be a rectangle. So first we'll learn how to
    draw rectangle shape in OpenGL and then understand how to apply textures to it.
    To apply texture to the shape, we'll prefer when using SOIL library, which is
    the Simple OpenGL Image Library. If you wish, you can use other libraries such
    as libpng which, as the name suggests, just supports PNG format images. But in
    this section, we'll only learn about SOIL, actually about SOIL2.
  prefs: []
  type: TYPE_NORMAL
- en: SOIL is a cross-platform library and it's supported on Android and iOS as part
    of game development. GLFW doesn't have any image loading methods built in, that
    is the reason why we are going to use SOIL library to load our textures. Also,
    SOIL helps in making our code as dynamic as possible across various platforms,
    and it's really easy to use as well.
  prefs: []
  type: TYPE_NORMAL
- en: So, first let's understand how to set up our project to use the SOIL library
    on Windows and Mac platform.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project to use SOIL on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll understand how to set up our project to use the SOIL
    library on a Windows platform. So, we'll begin by downloading the SOIL library
    and Premake. You must be wondering, what is Premake? Premake is a command line
    tool used to generate project files for platforms such as Visual Studio, Xcode,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to understand the set up process:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up your web browser and go to the following link [https://bitbucket.org/SpartanJ](https://bitbucket.org/SpartanJ).
    In the Repositories section click on the SOIL2 option and open the webpage, and
    select the first fork under Introduction for the latest version of SOIL library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reason we are downloading the SOIL2 library is beacuse the original SOIL
    library is actually very old and hasn't been updated for a very long time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve downloaded that, just search for Premake on Google or visit the
    following link: [https://premake.github.io/](https://premake.github.io/). Then,
    click on the Download option. It is recommended that you download the latest stable
    branch, so download the 4.4 version, which is currently stable (at the time of
    writing this book).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to the location where you've downloaded the files and extract both
    of the zipped folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, go to the `Premake` folder and copy and paste `premake4.exe` into the
    `SOIL` folder, which we just extracted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up the command prompt and in here you may want to change the directory
    path to the location where you downloaded and extracted your `SOIL` folder. Suppose
    the `C:` drive is the drive where all your files get downloaded and you have downloaded
    and extracted your `SOIL` folder to that drive, then all you have to do is type
    `cd` in command prompt and then just drag and drop your `SOIL` folder into it.
    It will automatically enter the path where the `SOIL` folder is located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it's any other drive that your downloads go to, then what you have to do
    is first tell command prompt to change it to that particular drive. To do that,
    just type the actual letter of the drive then type `:` and hit *Enter*, and then
    you can follow the previous drag-and-drop process.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in Command Prompt, type in `premake4.exe`—or whatever the executable is
    called—followed by `vs2017` and then hit *Enter*. This will generate our Visual
    Studio project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're using an older version, such as 2010, you can use 2010 in the `vs`
    command. It doesn't have a command for newer versions of Visual Studio, but if
    you enter that, it will prompt you to upgrade some of the properties, so don't
    worry about that.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's go to our `SOIL` folder, open the `make` folder present inside it
    and then open up the `Windows` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `Windows` folder, you'll get a `SOIL2.sln` file. Double-click on
    it and once that has opened in Visual Studio, you might get an upgrade the compiler,
    and libraries pop window. Just click on the OK button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, in the Visual Studio, on the right-hand side, you'll see a filenames.
    The only one that we're concerned with is `soil2-static-lib`. Right-click on that
    file and then click on Build option. This will build our project. You can then
    close Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, if you go back to the `SOIL` folder, there'll be some more folders generated.
    The one we're interested in is the `lib` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `lib` folder, there's a `Windows` folder which consists of the `.lib`
    file, which is what we need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy that `.lib` file and go to the location where you have your OpenGL project
    created. What we'll do there is, the location where `.sln` file is present, we'll
    make a new folder and name it as `External Libraries`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `External Libraries` folder we will create a sub folder called `SOIL2`,
    and inside that, we'll create a folder called `lib`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, in the `lib` folder that we created just now, paste the `soil2-debug.lib`
    file. So, this way we're going to use relative linking to link our SOIL library.
    If you are aware of the absolute linking process and wants to use it, you can
    use that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And now, what we need to do is go back to the `SOIL` folder and copy the files
    present within the `SOIL2` folder and paste that in the `OpenGL_VisualStudio`
    folder which is present inside the `OpenGL` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, once you've got all of these steps sorted, the one last thing to do is link
    up the `soil2-debug.lib` to our project. To link up the `.lib` file to our Visual
    Studio project with the relative linking, you can refer to the *Linking of GLFW
    and GLEW libraries with relative linking* section in the previous chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, we have set up our project to use the SOIL library on Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project to use SOIL on Mac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll understand how to set up our project to use the SOIL
    library on a Mac platform. Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up your web browser and go to the following link: [https://bitbucket.org/SpartanJ](https://bitbucket.org/SpartanJ).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Repositories section click on the SOIL2 option and open the webpage,
    and select the first fork under Introduction for the latest version of SOIL library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to the location where you've downloaded the files and extract them.
    Once extracted, go to the `src` folder and in it go to the `SOIL2` folder. Then
    just copy and paste that folder into your project directory in your system, which
    also contains your `main.cpp` and `shader` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, just add the library to our triangle project as you normally would. So,
    what we will do is right-click on the project in Xcode, go to the Add Files option,
    click on SOIL, and then click on the Add button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, once we've got that included, that's it for the setup part. And now, we'll
    go back to our the code from the previous section and make modification to it
    so as to add textures to our shape.
  prefs: []
  type: TYPE_NORMAL
- en: Applying texture to our shape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''re all set up to use the SOIL library, let''s go to our triangle
    code and make the necessary changes to load our shape and apply texture to it.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''ll first include the SOIL library into our code; for that, type in
    the following line at the start of your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have typed `SOIL2/SOIL2.h` because our library is inside the `SOIL2`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we''re going to do is enable the alpha support for images with
    extension such as PNG. To do that, type in the following lines of code after we
    have defined out `glViewport()` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding lines of code, the `glEnable( GL_BLEND )` function will help
    in blending the image in our shape. Then we used `glBlendFunc()` and to it we
    passed two parameters `GL_SRC_ALPHA` and `GL_ONE_MINUS_SRC_ALPHA`. This is how
    we enabled the alpha support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll have to modify our vertices as we''ll be using a rectangular shape
    to apply our texture, and also we''ll have to add coordinates for our texture
    too. So take a look at the following vertices array and make the necessary changes
    to your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''re going to draw a rectangle, we need four different vertices: bottom
    left, bottom right, top left, and top right. In the preceding code, the values
    that we''ve added don''t actually range between -1 and 1; these values range between
    0 and 1 so are know as normalized values. You might hear this term in computer
    graphics quite a lot. Normalized values basically means the values ranged between
    0 and 1\. So, for example, if you had an image that has a width of 1280 x 1280,
    and the normalized version was 0 to 1, if you were to set a value of 0.5, it would
    be at 640 because it''s halfway along and halfway between 0 and 1280 is 640\.
    This is just a very basic overview of normalization. If you want to know a bit
    more about it, feel free to Google it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we''re going to create is another array for indices. Take a
    look at the following code and let''s try to understand it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason we''ve defined two triangles in the preceding array is, as we''re
    drawing a quadrilateral in this section, our rectangle shape actually requires
    two triangle indices to be defined. Take a look at the following image to understand
    the concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47de2a46-2347-4650-a95c-a7b8d7498a2d.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image shows defining of the triangle coordinates with and without
    indexing. So, let's have a look at the without indexing part. Without indexing,
    to draw a quadrilateral you'll need six different vertices, as seen in the image.
    Even though there are two pairs of similar coordinates that are shared between
    the two triangles, the vertices are not being efficiently defined. With indexing
    approach, however, we can share the vertices. So, as in the with indexing image,
    the two triangles share the same pair of vertices. So we'll reuse those and as
    a result, we'll be defining only four vertices. Ignore the numbering shown in
    the image; it's slightly different to our situation, but the principle still applies.
    And if you try and draw it out on paper and apply the numbers that we got in our
    indices array to the actual triangle or quadrilateral from the two, it will make
    a lot more sense. It might not be obvious why you would want to do this at the
    moment, and that's because we're only drawing a quadrilateral. But, imagine when
    you have a game and you've got thousands if not millions of triangles, and triangles
    forming various complex shapes. Thus this with indexing approach really becomes
    handy and increase the efficiency of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in our `GLuint` section below our indices, we want to create another
    buffer called `EBO`, so make the change to the code as highlighted in the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to generate the buffers for the Element Buffer Objects (EBO), so type
    in the following highlighted lines of code and then we also need to bind that
    buffer :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll modify our position and the color attributes, and we''ll add one
    more attribute that is the texture coordinate attribute. Let''s check out the
    following highlighted code and try to understand the modifications done to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For the position and the color attributes in the preceding code, we have replaced
    `6` with `8`, as we have eight coordinates in our vertices array: three for the
    position, three for the colors, and two for the texture coordinates. And then,
    we created another vertex attribute pointer as the texture coordinate attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're going to add the texture loading code. In our main code, after we've
    unbinded our vertex array and before the start of `while` loop, we'll add the
    texture loading code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Firstly we'll need to create an `GLuint` `texture` variable as this will hold
    our reference to the texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll create `int` variables as `width` and `height`. This will define
    the width and the height of our texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we'll need to add `glGenTextures()` function and for this, we specify the
    `size` as `1` and put a reference to our texture variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll then bind the texture using `glBindTexture()` funtion. Take a look at
    the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we are going to set our texture parameters. For that, we''re going
    to add function `glTexParameteri ()` and to this function, we''ll pass the following
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter that we're going to set is `GL_TEXTURE_2D`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then for the `name` we're going to set the type of wrapping that we'll be using
    `GL_TEXTURE_WRAP_S`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: And for the wrapping, we're going to add `GL_REPEAT`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended you have a look at different wrapping techniques. You can
    find more information about this in the OpenGL API guides and if you look at [learnopengl.com](https://learnopengl.com/)
    and [open.gl](https://open.gl/), you will get to read a lot more information about
    all the lines of code that we have written.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what we''re going to do next is duplicate the previous line of code and
    make the following changes as highlighted in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''re going to set the texture filtering. Check out the following code
    for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to add the actual texture loading code to the main code.
    For that, we''re going to create unsigned char variable `*image` and this will
    hold the reference to the function `SOIL_load_image()`. And to this function we
    pass the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First parameter will be the path of the actual image that we're going to use
    as texture for our object. Therefore, we'll put `res/images/image1.jpg`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter will be the refrence to the width and the height of our
    image.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then for the third parameter, we're just going to pass it as `0`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the fourth parameter we're going to set the loading method so will add `SOIL_LOAD_RGBA`.
    Even if it's a JPEG image, you always want to load it as an alpha image. The reason
    for that is, it allows the code that we're writing now to be more dynamic. So
    if we swap the JPEG image for a PNG image, it'll still work. If you put in a different
    type of alpha image, or an image without alpha, as long as that type is supported
    by SOIL, the code will work fine.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll specify a two-dimensional texture image adding the function `glTexImage2d()`
    and to this function we are going to pass the highlighted parameters in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We'll generate the mipmaps, so we're going to put `glGenerateMipmap()` funtion.
    And for this function, we specify `GL_TEXTURE_2D` as it's a 2D texture that we
    are using.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we're going to free our image data, as it's always good to clean up. So,
    we'll add `SOIL_free_image_data()` function for that we merely specify our image
    character array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we''re going to unbind the texture using `glBindTexture()` function and
    to that function we''ll pass `GL_TEXTURE_2D`, and we''ll unbind the texture by
    passing `0`. Have a look at the following code for a clear understanding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You might be thinking what is a mipmap? A mipmap is essentially a level of detail
    scheme for texture image. It's a way of creating a bunch of small images by a
    factor of 2 of the original image, and then loading the one that is the closest
    to the actual texture being displayed at any given point, depending on the distance
    from the viewer. So if something's further away, the texture required isn't as
    big. Whereas if it's nearer, it requires a bigger texture. So, it just helps in
    loading the texture properly. It is recommended to have a quick check on the internet
    to understand mipmapping a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: We're not done with our code yet. So, we'll move on to our while loop now
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the below mentioned steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the while loop we'll put some code between the point where we're using the
    shader and where we're binding the vertex array. What we want to do here is add
    `glActiveTexture()`function. This function will help us activating the texture
    that we specify.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we'll add function `glBindTexture()`. And for this function, we pass `GL_TEXTURE_2D`
    and `texture`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we just add `glUniform1i()` function and pass to it the following highlighted
    parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll add the code to draw our container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And the last thing that we need to do is just delete the buffer for the element
    buffer object. So, we''ll add `glDeleteBuffers( 1, &EBO );` to our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, if we run our code. There will be some error in the compilation of
    the code and you will get the output similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0898dfef-fc48-41c6-87d2-e2a4133820bb.png)'
  prefs: []
  type: TYPE_IMG
- en: This is not what we intended; this is obviously not what we wanted to load in
    our shape. So, let's try to understand the reason behind this. The only reason
    we are getting the wrong output is because we have not updated our vertex and
    fragment shaders for loading the texture. So let's update it.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the shader files to integrate texture coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to carry out the modifications in your shader files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s go to the vertex shader, our `core.vs` file, and make the changes
    highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering what are we doing here in `TexCoord = vec2(texCoord.x,
    1.0 - texCoord.y);`. Well, what we're doing is swapping the y axis by subtracting
    our coordinates from `1`, and this is done simply because most images have the
    top y-axis inverted in OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go to the fragment shader, `core.frag`, and make the following highlighted
    modifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, if we save the updated shader file and run our program, we will get
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c4c10d5-abb9-4730-93e0-6867b3ef2cd9.png)'
  prefs: []
  type: TYPE_IMG
- en: Check whether your image fit are spot on with the ratio. If it looks a bit squashed,
    that's simply because of the coordinates that we have defined for the vertices.
    It's nothing to do with the texture loading. In later chapters, we'll be learning
    to use logical coordinates, so that any image that you load can fit in properly.
    So, that is it for texture loading.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to draw various shapes using shaders. We began
    by drawing a triangle and adding color to it. Then, we used the triangle concept
    to draw our quadrilateral and learned how to apply texture to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll learn how to apply transformations such as translation
    and rotation to our shape, and learn to draw a cube and apply texture to it. We''ll
    also explore the concepts of projections: Perspective and Orthographic, and how
    to implement those in our world.'
  prefs: []
  type: TYPE_NORMAL
