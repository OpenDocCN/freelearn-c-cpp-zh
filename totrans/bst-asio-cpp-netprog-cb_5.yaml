- en: Chapter 5. HTTP and SSL/TLS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：HTTP和SSL/TLS
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Implementing the HTTP client application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现HTTP客户端应用程序
- en: Implementing the HTTP server application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现HTTP服务器应用程序
- en: Adding SSL/TLS support to client applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为客户端应用程序添加SSL/TLS支持
- en: Adding SSL/TLS support to server applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为服务器应用程序添加SSL/TLS支持
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter covers two major topics. The first one is HTTP protocol implementation.
    The second is the usage of SSL/TLS protocol. Let's briefly examine each of them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖两个主要主题。第一个是HTTP协议的实现。第二个是SSL/TLS协议的使用。让我们简要地考察每个主题。
- en: The **HTTP protocol** is an application layer protocol operating on the top
    of TCP protocol. It is widely used on the Internet, allowing client applications
    to request particular resources from the servers, and servers to transmit the
    requested resources back to the clients. Besides, HTTP allows clients to upload
    data and send commands to the server.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP协议**是一个运行在TCP协议之上的应用层协议。它在互联网上被广泛使用，允许客户端应用程序从服务器请求特定资源，并允许服务器将请求的资源传输回客户端。此外，HTTP还允许客户端上传数据和向服务器发送命令。'
- en: 'The HTTP protocol assumes several models or **methods** of communication, each
    designed for a specific purpose. The simplest method called `GET` assumes the
    following flow of events:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议假设几种通信模型或**方法**，每个方法都针对特定目的而设计。最简单的方法称为`GET`，它假设以下事件流程：
- en: The HTTP client application (for example, a web browser) generates a request
    message containing information about a particular resource (residing on the server)
    to be requested and sends it to the HTTP server application (for example, a web
    server) using TCP as a transport level protocol.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP客户端应用程序（例如，网页浏览器）生成一个包含有关特定资源（位于服务器上）信息的需求消息，并使用TCP作为传输层协议将其发送到HTTP服务器应用程序（例如，Web服务器）。
- en: The HTTP server application, having received a request from the client, parses
    it, extracts the requested resource from the storage (for example, from a file
    system or a database), and sends it back to the client as a part of a HTTP response
    message.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当HTTP服务器应用程序收到客户端的请求后，它会解析该请求，从存储（例如，从文件系统或数据库）中提取请求的资源，并将其作为HTTP响应消息的一部分发送回客户端。
- en: The format of both the request and response messages is defined by HTTP protocol.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和响应消息的格式由HTTP协议定义。
- en: Several other methods are defined by HTTP protocol, allowing client application
    to actively send data or upload resources to the server, delete resources located
    on the server, and perform other operations. In the recipes of this chapter, we
    will consider implementation of the `GET` method. Because HTTP protocol methods
    are similar in principle, implementation of one of them gives a good hint about
    how to implement others.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议定义了其他几种方法，允许客户端应用程序主动发送数据或上传资源到服务器，删除服务器上的资源，并执行其他操作。在本章的食谱中，我们将考虑`GET`方法的实现。因为HTTP协议的方法在原则上相似，实现其中一种方法可以为其他方法的实现提供很好的提示。
- en: 'Another topic covered in this chapter is **SSL and TLS protocols**. **Secure
    Socket Layer** (**SSL**)and **Transport Layer Security** (**TLS**) protocols operate
    on the top of TCP protocol and are aimed at achieving two main goals as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还涉及另一个主题：**SSL和TLS协议**。**安全套接字层**（**SSL**）和**传输层安全性**（**TLS**）协议在TCP协议之上运行，旨在实现以下两个主要目标：
- en: Providing a way to authenticate each communication participant using digital
    certificate
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种使用数字证书验证每个通信参与者的方式
- en: Securing data being transmitted over the underlying TCP protocol
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护通过底层TCP协议传输的数据安全
- en: The SSL and TLS protocols are widespread, especially in the Web. Most web servers
    to which its potential clients may send sensitive data (passwords, credit card
    numbers, personal data, and so on) support SSL/TLS-enabled communication. In this
    case, the so called HTTPS (HTTP over SSL) protocol is used to allow the client
    to authenticate the server (sometimes servers may want to authenticate the client,
    though this is rarely the case) and to secure transmitted data by encrypting it,
    making this data useless for the culprit even if intercepted.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SSL和TLS协议在Web上广泛使用，尤其是在Web服务器中。大多数可能向其发送敏感数据（密码、信用卡号码、个人信息等）的Web服务器都支持SSL/TLS启用通信。在这种情况下，所谓的HTTPS（通过SSL的HTTP）协议被用来允许客户端验证服务器（有时服务器可能需要验证客户端，尽管这种情况很少见），并通过加密传输的数据来确保数据安全，即使被截获，对犯罪分子来说这些数据也是无用的。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Boost.Asio does not contain the implementation of SSL/TLS protocols. Instead,
    it relies on the OpenSSL library, Boost.Asio provides a set of classes, functions,
    and data structures that facilitate the usage of functionality provided by OpenSSL,
    making the code of the application more uniformed and object-oriented.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Asio不包含SSL/TLS协议的实现。相反，它依赖于OpenSSL库，Boost.Asio提供了一套类、函数和数据结构，这些结构简化了OpenSSL提供的功能的用法，使应用程序的代码更加统一和面向对象。
- en: In this chapter, we will not consider the details of the OpenSSL library or
    SSL/TLS protocols. These topics are not in the scope of this book. Instead, we
    will touch upon specific tools provided by the Boost.Asio that rely on OpenSSL
    library and allow to implement support of SSL/TLS protocol in a network application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会考虑OpenSSL库或SSL/TLS协议的细节。这些主题不在此书的范围之内。相反，我们将简要介绍Boost.Asio提供的特定工具，这些工具依赖于OpenSSL库，并允许在网络应用程序中实现SSL/TLS协议的支持。
- en: The two recipes demonstrate how to build client and server applications that
    secure their communication using SSL/TLS protocols. To make SSL/TLS-related aspects
    of the applications more vivid and clear, all other aspects of considered applications
    were made as simple as possible. Both client and server applications are synchronous
    and based on recipes found in other chapters of this book. This allows us to compare
    a basic TCP client or server application with their advanced versions supporting
    SSL/TLS and to better understand what it takes to add SSL/TLS support to a distributed
    application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个配方演示了如何构建客户端和服务器应用程序，它们使用SSL/TLS协议来确保其通信的安全性。为了使应用程序的SSL/TLS相关方面更加生动和清晰，考虑的应用程序的其他方面都被尽可能地简化。客户端和服务器应用程序都是同步的，并基于本书其他章节中的配方。这使我们能够比较基本的TCP客户端或服务器应用程序及其支持SSL/TLS的高级版本，并更好地理解向分布式应用程序添加SSL/TLS支持需要做什么。
- en: Implementing the HTTP client application
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现HTTP客户端应用程序
- en: HTTP clients constitute important class of distributed software and are represented
    by many applications. Web browsers are prominent representatives of this class.
    They use HTTP protocols to request web pages from web servers. However, today
    HTTP protocol is used not only in the web. Many distributed applications use this
    protocol to exchange custom data of any kind. Often, when designing a distributed
    application, choosing HTTP as a communication protocol is a much better idea than
    developing custom one.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP客户端是分布式软件的一个重要类别，由许多应用程序表示。网络浏览器是这个类的一个突出代表。它们使用HTTP协议从网络服务器请求网页。然而，今天HTTP协议不仅用于网络。许多分布式应用程序使用此协议来交换任何类型的自定义数据。在设计分布式应用程序时，选择HTTP作为通信协议通常比开发自定义协议要好得多。
- en: 'In this recipe, we will consider an implementation of HTTP client using Boost.Asio
    that satisfies the following basic requirements:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将考虑使用Boost.Asio实现HTTP客户端，该客户端满足以下基本要求：
- en: Supports the HTTP `GET` request method
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持HTTP `GET`请求方法
- en: Executes requests asynchronously
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步执行请求
- en: Supports request canceling
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持请求取消
- en: Let's move on to the implementation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到实现部分。
- en: How to do it…
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Because one of the requirements of our client application is to support canceling
    requests that have been initiated but have not been completed yet, we need to
    make sure that canceling is enabled on all target platforms. Therefore, we begin
    our client application by configuring Boost.Asio library so that request canceling
    is enabled. More details on issues related to asynchronous operation canceling
    are provided in the *Cancelling asynchronous operations* recipe in [Chapter 2](ch02.html
    "Chapter 2. I/O Operations"), *I/O Operations*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们客户应用程序的一个要求是支持取消尚未完成但已启动的请求，我们需要确保所有目标平台都启用了取消功能。因此，我们首先配置Boost.Asio库，以便启用请求取消。有关异步操作取消相关问题的更多详细信息，请参阅[第2章](ch02.html
    "第2章。I/O操作")中的*取消异步操作*配方，*I/O操作*：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we include Boost.Asio library headers and also headers of some components
    of standard C++ libraries that we will need to implement our application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们包含Boost.Asio库的头文件，以及我们将需要实现应用程序的一些标准C++库组件的头文件：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, before we can jump to implementing classes and functions constituting our
    client application, we have to make one more preparation related to error representation
    and handling.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们能够跳转到实现构成我们客户端应用程序的类和函数之前，我们必须进行一项与错误表示和处理相关的准备工作。
- en: When implementing the HTTP client application, we need to deal with three classes
    of errors. The first class is represented by numerous errors that may occur when
    executing Boost.Asio functions and classes' methods. For example, if we call the
    `write_some()` method on an object representing a socket that has not been opened,
    the method will return operating system dependent error code (either by throwing
    an exception or by the means of an out argument depending on the method overload
    used), designating the fact that an invalid operation has been executed on a non-opened
    socket.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 HTTP 客户端应用程序时，我们需要处理三类错误。第一类是由执行 Boost.Asio 函数和类方法时可能发生的许多错误表示的。例如，如果我们对一个表示尚未打开的套接字的对象的
    `write_some()` 方法进行调用，该方法将返回操作系统依赖的错误代码（通过抛出异常或通过方法重载使用的输出参数，具体取决于所使用的方法重载），表示在未打开的套接字上执行了无效操作。
- en: The second class includes both erroneous and non-erroneous statuses defined
    by HTTP protocol. For example, the status code 200 returned by the server as a
    response to particular request made by the client, designates the fact that a
    client's request has been fulfilled successfully. On the other hand, the status
    code 500 designates that while performing the requested operation, an error occurred
    on the server that led to the request not being fulfilled.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个类包括由 HTTP 协议定义的既错误又非错误的状态。例如，服务器作为对客户端特定请求的响应返回的状态码 200，表示客户端的请求已成功完成。另一方面，状态码
    500 表示在执行请求操作时，服务器发生了错误，导致请求未能完成。
- en: The third class includes errors related to the HTTP protocol itself. In case
    a server sends a message, as a response to correct the request made by a client
    and this message is not a properly structured HTTP response, the client application
    should have means to represent this fact in terms of error code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个类包括与 HTTP 协议本身相关的错误。如果服务器发送一条消息作为对客户端请求的正确响应，并且这条消息不是一个正确结构的 HTTP 响应，客户端应用程序应该有方法来用错误代码表示这一事实。
- en: Error code for the first class of errors are defined in the sources of Boost.Asio
    libraries. Status codes of the second class are defined by HTTP protocol. The
    third class is not defined anywhere and we should define corresponding error codes
    by ourselves in our application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类错误的错误代码定义在 Boost.Asio 库的源代码中。第二类的状态码由 HTTP 协议定义。第三类在别处没有定义，我们应该在我们的应用程序中自行定义相应的错误代码。
- en: 'We define a single error code that represents quite a general error designating
    the fact that the message received from the server is not a correct HTTP response
    message and therefore, the client cannot parse it. Let''s name this error code
    as `invalid_response`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个单一的错误代码，它代表一个相当通用的错误，表明从服务器接收到的消息不是一个正确的 HTTP 响应消息，因此客户端无法解析它。让我们将这个错误代码命名为
    `invalid_response`：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we define a class representing an error category, which includes the
    `invalid_response` error code defined above. Let''s name this category as `http_errors_category`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个表示错误类别的类，它包括上面定义的 `invalid_response` 错误代码。让我们将这个类别命名为 `http_errors_category`：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we define a static object of this class, a function returning an instance
    of the object, and the overload for the `make_error_code()` function accepting
    error codes of our custom type `http_error_codes`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义这个类的静态对象、返回对象实例的函数以及接受我们自定义类型 `http_error_codes` 的错误代码的 `make_error_code()`
    函数的重载：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The last step we need to perform before we can use our new error code in our
    application is to allow Boost library to *know* that the members of the `http_error_codes`
    enumeration should be treated as error codes. To do this, we include the following
    structure definition into the `boost::system` namespace:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在应用程序中使用新的错误代码之前，我们需要执行的最后一个步骤是让 Boost 库知道 `http_error_codes` 枚举的成员应该被视为错误代码。为此，我们将以下结构定义包含到
    `boost::system` 命名空间中：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Because our HTTP client application is going to be asynchronous, the user of
    the client when initiating a request, will need to provide a pointer to a callback
    function, which will be invoked when the request completes. We need to define
    a type representing a pointer to such a callback function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 HTTP 客户端应用程序将是异步的，当客户端在发起请求时，将需要提供一个指向回调函数的指针，该函数将在请求完成时被调用。我们需要定义一个表示此类回调函数指针的类型。
- en: 'A callback function when called, would need to be passed arguments that clearly
    designate three things:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当回调函数被调用时，需要传递一些参数，这些参数清楚地指明了以下三件事：
- en: Which request has completed
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个请求已经完成
- en: What is the response
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应是什么
- en: Whether the request completed successfully and if not, the error code designating
    the error that occurred
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求是否成功完成，如果没有，则表示发生的错误的错误代码
- en: 'Note that, later, we will define the `HTTPRequest` and `HTTPResponse` classes
    representing the HTTP request and HTTP response correspondingly, but now we use
    forward declarations. Here is how the callback function pointer type declaration
    looks:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，稍后我们将定义代表 HTTP 请求和 HTTP 响应的 `HTTPRequest` 和 `HTTPResponse` 类，但现在我们使用前置声明。以下是回调函数指针类型声明的样子：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The HTTPResponse class
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTPResponse 类
- en: 'Now, we can define a class representing a HTTP response message sent to the
    client as a response to the request:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一个类来表示作为对请求的响应发送给客户端的 HTTP 响应消息：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `HTTPResponse` class is quite simple. Its private data members represent
    parts of HTTP response such as the response status code and status message, and
    response headers and body. Its public interface contains methods that return the
    values of corresponding data members, while private methods allow setting those
    values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPResponse` 类相当简单。它的私有数据成员代表 HTTP 响应的各个部分，如响应状态码和状态消息，以及响应头和主体。它的公共接口包含返回相应数据成员值的函数，而私有方法允许设置这些值。'
- en: The `HTTPRequest` class representing a HTTP request, which will be defined next,
    is declared as a friend to `HTTPResponse`. We will see how the objects of the
    `HTTPRequest` class use the private methods of the `HTTPResponse` class to set
    values of its data members when a response message arrives.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将要定义的表示 HTTP 请求的 `HTTPRequest` 类被声明为 `HTTPResponse` 的朋友。我们将看到 `HTTPRequest`
    类的实例如何使用 `HTTPResponse` 类的私有方法在收到响应消息时设置其数据成员的值。
- en: The HTTPRequest class
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTPRequest 类
- en: Next, we define a class representing a HTTP request containing functionality
    that constructs the HTTP request message based on information provided by the
    class user, sends it to the server, and then receives and parses the HTTP response
    message.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个类来表示包含基于用户提供的类信息构建 HTTP 请求消息、将其发送到服务器以及接收和解析 HTTP 响应消息的功能的 HTTP 请求。
- en: This class is at the center of our application because it contains most of its
    functionalities.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是我们应用程序的核心，因为它包含了大部分的功能。
- en: 'Later, we will define the `HTTPClient` class representing an HTTP client, responsibilities
    of which will be limited to maintaining a single instance of the `asio::io_service`
    class common to all the `HTTPRequest` objects and acting as a factory of the `HTTPRequest`
    objects. Therefore, we declare the `HTTPClient` class as a friend to the `HTTPRequest`
    class and make the `HTTPRequest` class'' constructor private:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义一个代表 HTTP 客户端的 `HTTPClient` 类，其职责将限于维护所有 `HTTPRequest` 对象共有的单个 `asio::io_service`
    类的实例，并作为 `HTTPRequest` 对象的工厂。因此，我们将 `HTTPClient` 类声明为 `HTTPRequest` 类的朋友，并将 `HTTPRequest`
    类的构造函数设为私有：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The constructor accepts two arguments: a reference to an object of the `asio::io_service`
    class and an unsigned integer named `id`. The latter contains a unique identifier
    of a request, which is assigned by the user of the class and allows distinguishing
    request objects one from another.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受两个参数：一个指向 `asio::io_service` 类对象的引用和一个名为 `id` 的无符号整数。后者包含请求的唯一标识符，由类的用户分配，允许区分不同的请求对象。
- en: 'Then, we define methods constituting the public interface of the class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义构成类公共接口的方法：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The public interface includes methods that allow the class' user to set and
    get HTTP request parameters such as the DNS name of the host running the server,
    protocol port number, and URI of the requested resource. Besides, there is a method
    that allows setting a pointer to a callback function that will be called when
    the request completes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 公共接口包括允许类用户设置和获取 HTTP 请求参数的方法，例如运行服务器的 DNS 名称、协议端口号和请求资源的 URI。此外，还有一个方法允许设置一个回调函数指针，当请求完成时将被调用。
- en: The `execute()` method initiates the execution of the request. Also, the `cancel()`
    method allows canceling the initiated request before it completes. We will consider
    how these methods work in the next section of the recipe.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute()` 方法启动请求的执行。此外，`cancel()` 方法允许在请求完成之前取消已启动的请求。我们将在食谱的下一部分考虑这些方法的工作原理。'
- en: 'Now, we define a set of private methods that contain most of the implementation
    details. Firstly, we define a method that is used as a callback for an asynchronous
    DNS name resolution operation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义一组私有方法，其中包含大部分实现细节。首先，我们定义一个用于异步DNS名称解析操作回调的方法：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we define a method used as a callback for an asynchronous connection
    operation, which is initiated in the `on_host_name_resolved()` method just defined:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个用于异步连接操作回调的方法，该操作是在刚刚定义的`on_host_name_resolved()`方法中启动的：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next method we define—`on_request_sent()`—is a callback, which is called
    after the request message is sent to the server:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的下一个方法——`on_request_sent()`——是一个回调，在将请求消息发送到服务器后被调用：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we need another callback method, which is called when the first portion
    of the response message, namely, **status line**, is received from the server:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要另一个回调方法，当从服务器接收到响应消息的第一部分，即**状态行**时，该方法会被调用：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we define a method that serves as a callback, which is called when the
    next portion of the response message—**the** **response headers block**—arrives
    from the server. We will name it as `on_headers_received()`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义一个作为回调的方法，当从服务器接收到响应消息的下一段——**响应头块**时，该方法会被调用。我们将它命名为`on_headers_received()`：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Besides, we need a method that will handle the last part of the response—**the
    response body**. The following method is used as a callback, which is called after
    the response body arrives from the server:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要一个处理响应最后一部分——**响应体**的方法。以下方法用作回调，在从服务器接收到响应体后被调用：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we define the `on_finish()` method that serves as a final point of
    all execution paths (including erroneous) that start in the `execute()` method.
    This method is called when the request completes (either successfully or not)
    and its purpose is to call the callback provided by the `HTTPRequest` class''
    user to notify it about the completion of the request:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了`on_finish()`方法，它作为所有从`execute()`方法开始执行路径（包括错误路径）的最终点。当请求完成时（无论是成功还是失败），该方法会被调用，其目的是调用`HTTPRequest`类用户提供的回调，通知它请求已完成：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will need some data fields associated with each instance of the `HTTPRequest`
    class. Here, we declare the class'' corresponding data members:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些与`HTTPRequest`类的每个实例相关联的数据字段。在这里，我们声明类的对应数据成员：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The last thing to add is the closing bracket to designate the end of the `HTTPRequest`
    class definition:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加的最后一项是关闭括号，以指定`HTTPRequest`类定义的结束：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The HTTPClient class
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTPClient类
- en: 'The last class that we need in our application is the one that would be responsible
    for the following three functions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用中需要添加的最后一个类是负责以下三个功能的类：
- en: To establish a threading policy
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了建立线程策略
- en: To spawn and destroy threads in a pool of threads running the Boost.Asio event
    loop and delivering asynchronous operations' completion events
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Boost.Asio事件循环的线程池中创建和销毁线程，以执行异步操作的完成事件
- en: To act as a factory of the `HTTPRequest` objects
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为`HTTPRequest`对象的工厂
- en: 'We will name this class as `HTTPClient`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个类命名为`HTTPClient`：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The callback and the main() entry point function
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回调和main()入口点函数
- en: 'At this point, we have the basic HTTP client that comprises three classes and
    several supplementary data types. Now we will define two functions that are not
    parts of the client, but demonstrate how to use it to communicate with the server
    using the HTTP protocol. The first function will be used as a callback, which
    will be called when the request completes. Its signature must correspond to the
    function pointer type `Callback` defined earlier. Let''s name our callback function
    as `handler()`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了包含三个类和几个补充数据类型的基本HTTP客户端。现在我们将定义两个不是客户端部分，但演示如何使用HTTP协议与服务器通信的函数。第一个函数将用作回调，当请求完成时会被调用。它的签名必须与之前定义的`Callback`函数指针类型相匹配。让我们将我们的回调函数命名为`handler()`：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second and the last function we need to define is the `main()` application
    entry point function that uses the HTTP client to send HTTP requests to the server:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义的第二个和最后一个函数是`main()`应用程序入口点函数，它使用HTTP客户端向服务器发送HTTP请求：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Now let's consider how our HTTP client works. The application consists of five
    components, among which are the three classes such as `HTTPClient`, `HTTPRequest`,
    and `HTTPResponse`, and two functions such as the `handler()` callback function
    and the `main()` application entry point function. Let's consider how each component
    works separately.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们考虑我们的 HTTP 客户端是如何工作的。应用程序由五个组件组成，其中包含 `HTTPClient`、`HTTPRequest` 和 `HTTPResponse`
    等三个类，以及 `handler()` 回调函数和 `main()` 应用程序入口点函数等两个函数。让我们分别考虑每个组件是如何工作的。 '
- en: The HTTPClient class
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`HTTPClient` 类'
- en: A class' constructor begins with creating an instance of the `asio::io_service::work`
    object in order to make sure that threads running the event loop do not exit this
    loop when there are no pending asynchronous operations. Then, a thread of control
    is spawned and added to the pool by calling the `run()` method on the `m_ios`
    object. This is where the `HTTPClient` class performs its first and part of the
    second functions, namely, establishing threading policy and adding threads to
    the pool.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类的构造函数从创建 `asio::io_service::work` 对象的实例开始，以确保在没有任何挂起的异步操作时，运行事件循环的线程不会退出此循环。然后，通过在
    `m_ios` 对象上调用 `run()` 方法，生成一个控制线程并将其添加到池中。这就是 `HTTPClient` 类执行其第一个和第二个部分功能的地方，即建立线程策略并将线程添加到池中。
- en: The third function of the `HTTPClient` class—to act as a factory of the object
    representing HTTP requests—is performed in its `create_request()` public method.
    This method creates an instance of the `HTTPRequest` class in the free memory
    and returns a shared pointer object pointing to it. As its input argument, the
    method accepts an integer value that represents the unique identifier to be assigned
    to the newly created request object. This identifier is used to distinguish between
    different request objects.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPClient` 类的第三个功能——作为表示 HTTP 请求的对象的工厂——在其 `create_request()` 公共方法中执行。此方法在空闲内存中创建
    `HTTPRequest` 类的实例，并返回一个指向它的共享指针对象。该方法接受一个整数值作为输入参数，该值代表要分配给新创建的请求对象的唯一标识符。此标识符用于区分不同的请求对象。'
- en: The `close()` method from the class' public interface destroys the `asio::io_service::work`
    object, allowing threads to exit the event loop just as soon as all pending operations
    complete. The method blocks until all threads exit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类的公共接口中的 `close()` 方法销毁 `asio::io_service::work` 对象，允许线程在所有挂起的操作完成时立即退出事件循环。该方法会阻塞，直到所有线程退出。
- en: The HTTPRequest class
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`HTTPRequest` 类'
- en: 'Let''s begin considering the `HTTPRequest` class'' behavior by inspecting its
    data members and their purpose. The `HTTPRequest` class contains 12 data members,
    among which are the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查其数据成员及其用途开始，来考虑 `HTTPRequest` 类的行为。`HTTPRequest` 类包含 12 个数据成员，其中包含以下内容：
- en: 'Request parameters:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求参数：
- en: '[PRE22]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A unique identifier of the request:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求的唯一标识符：
- en: '[PRE23]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A pointer to the callback function provided by the class'' user to be called
    when a request completes:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向用户提供的类回调函数的指针，当请求完成时调用：
- en: '[PRE24]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A string buffer used to store the HTTP request message:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储 HTTP 请求消息的字符串缓冲区：
- en: '[PRE25]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A socket object used to communicate with the server:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于与服务器通信的套接字对象：
- en: '[PRE26]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A resolver object used to resolve the DNS name of the server host provided
    by the user:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于解析用户提供的服务器主机 DNS 名称的解析器对象：
- en: '[PRE27]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'An instance of the `HTTPResponse` class that represents the response received
    from the server:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示从服务器接收到的响应的 `HTTPResponse` 类的实例：
- en: '[PRE28]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A boolean flag and a `mutex` object supporting the request canceling functionality
    (which will be explained later):'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔标志和一个支持请求取消功能的 `mutex` 对象（稍后将解释）：
- en: '[PRE29]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Also, a reference to an instance of the `asio::io_service` class required by
    resolver and socket objects. The single instance of the `asio::io_service` class
    is maintained by an object of the `HTTPClient` class:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，一个引用到由解析器和套接字对象所需的 `asio::io_service` 类的实例。`asio::io_service` 类的单个实例由 `HTTPClient`
    类的对象维护：
- en: '[PRE30]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: An instance of the `HTTPRequest` object represents a single HTTP `GET` request.
    The class is designed so that in order to send a request, two steps need to be
    performed. Firstly, the parameters of the request and the callback function to
    be called when the request completes are set by calling the corresponding setter
    methods on the object. Then, as a second step, the `execute()` method is invoked
    to initiate the request execution. When the request completes, the callback function
    is called.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPRequest` 对象的一个实例代表一个单独的 HTTP `GET` 请求。该类设计得如此，以便发送请求需要执行两个步骤。首先，通过在对象上调用相应的设置方法来设置请求的参数和请求完成时调用的回调函数。然后，作为第二步，调用
    `execute()` 方法来启动请求执行。当请求完成时，调用回调函数。'
- en: The `set_host()`, `set_port()`, `set_uri()`, and `set_callback()` setter methods
    allow setting a server host DNS name and port number, URI of the requested resource,
    and a callback function to be called when the request completes. Each of these
    methods accepts one argument and stores its value in the corresponding `HTTPRequest`
    object's data member.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_host()`、`set_port()`、`set_uri()` 和 `set_callback()` 设置方法允许设置服务器主机 DNS
    名称和端口号、请求资源的 URI 以及在请求完成时调用的回调函数。这些方法中的每一个都接受一个参数，并将其值存储在相应的 `HTTPRequest` 对象的数据成员中。'
- en: The `get_host()`, `get_port()`, and `get_uri()` getter methods return values
    set by corresponding setter methods. The `get_id()` getter method returns a request
    object's unique identifier, which is passed to the object's constructor on instantiation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_host()`、`get_port()` 和 `get_uri()` 获取器方法返回由相应的设置方法设置的值。`get_id()` 获取器方法返回请求对象的唯一标识符，该标识符在实例化时传递给对象的构造函数。'
- en: The `execute()` method begins the execution of a request by initiating a sequence
    of asynchronous operations. Each asynchronous operation performs one step of request
    execution procedure.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute()` 方法通过启动一系列异步操作来开始请求的执行。每个异步操作执行请求执行过程的一个步骤。'
- en: Because a server host in the request object is represented with a DNS name (rather
    than with an IP address), before sending the request message to the server, the
    specified DNS name must be resolved and transformed into an IP address. Therefore,
    the first step in the request execution is DNS name resolution. The `execute()`
    method begins with preparing the resolving query and then calls the resolver object's
    `async_resolve()` method, specifying the `HTTPRequest` class' `on_host_name_resolve()`
    private method as an operation completion callback.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于请求对象中的服务器主机用 DNS 名称（而不是用 IP 地址）表示，因此在将请求消息发送到服务器之前，必须解析指定的 DNS 名称并将其转换为 IP
    地址。因此，请求执行的第一步是 DNS 名称解析。`execute()` 方法从准备解析查询开始，然后调用解析器对象的 `async_resolve()`
    方法，指定 `HTTPRequest` 类的 `on_host_name_resolve()` 私有方法作为操作完成回调。
- en: 'When the server host DNS name is resolved, the `on_host_name_resolved()` method
    is called. This method is passed two arguments: the first of which is an error
    code, designating the status of the operation, and the second one is the iterator
    that can be used to iterate through a list of endpoints resulting from a resolution
    process.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器主机 DNS 名称解析时，调用 `on_host_name_resolved()` 方法。此方法传递两个参数：第一个是一个错误代码，指定操作的状态，第二个是可以用于遍历解析过程产生的端点列表的迭代器。
- en: The `on_host_name_resolved()` method initiates the next asynchronous operation
    in a sequence, namely socket connection, by calling `asio::async_connect()` free
    function passing socket object `m_sock` and iterator parameter to it so that it
    connects the socket to the first valid endpoint. The `on_connection_established()`
    method is specified as an asynchronous connection operation completion callback.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_host_name_resolved()` 方法通过调用 `asio::async_connect()` 自由函数来启动序列中的下一个异步操作，即套接字连接，传递套接字对象
    `m_sock` 和迭代器参数给它，以便将套接字连接到第一个有效的端点。`on_connection_established()` 方法被指定为异步连接操作完成回调。'
- en: When an asynchronous connection operation completes, the `on_connection_established()`
    method is invoked. The first argument passed to it is named `ec` that designates
    the operation completion status. If its value is equal to zero, it means that
    the socket was successfully connected to one of the endpoints. The `on_connection_established()`
    method constructs the HTTP `GET` request message using request parameters stored
    in the corresponding data members of the `HTTPRequest` object. Then, the `asio::async_write()`
    free function is called to asynchronously send a constructed HTTP request message
    to the server. The class' private method `on_request_sent()` is specified as a
    callback to be called when the `asio::async_write()` operation completes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当异步连接操作完成时，会调用`on_connection_established()`方法。传递给它的第一个参数命名为`ec`，它指定了操作完成的状态。如果其值等于零，则表示套接字已成功连接到端点之一。`on_connection_established()`方法使用存储在`HTTPRequest`对象相应数据成员中的请求参数构建HTTP
    `GET`请求消息。然后，调用`asio::async_write()`自由函数以异步方式将构建的HTTP请求消息发送到服务器。将类中的私有方法`on_request_sent()`指定为在`asio::async_write()`操作完成时调用的回调。
- en: After a request is sent, and if it is sent successfully, the client application
    has to let the server know that the full request is sent and the client is not
    going to send anything else by shutting down the send part of the socket. Then,
    the client has to wait for the response message from the server. And this is what
    the `on_request_sent()` method does. Firstly, it calls the socket object's `shutdown()`
    method, specifying that the send part should be closed by the passing value `asio::ip::tcp::socket::shutdown_send`
    to the method as an argument. Then, it calls the `asio::async_read_until()` free
    function to receive a response from the server.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请求发送后，如果发送成功，客户端应用程序必须让服务器知道完整的请求已发送，并且客户端不会发送任何其他内容，通过关闭套接字的发送部分来实现。然后，客户端必须等待来自服务器的响应消息。这正是`on_request_sent()`方法所做的事情。首先，它调用套接字对象的`shutdown()`方法，指定通过将`asio::ip::tcp::socket::shutdown_send`作为参数传递给方法来关闭发送部分。然后，它调用`asio::async_read_until()`自由函数以接收来自服务器的响应。
- en: Because the response may be potentially very big and we do not know its size
    beforehand, we do not want to read it all at once. We first want to read the **HTTP
    response status line** only; then, having analyzed it, either continue reading
    the rest of the response (if we think we need it) or discard it. Therefore, we
    pass the `\r\n` symbols sequence, designating the end of the HTTP response status
    line as a delimiter argument to the `asio::async_read_until()` method. The `on_status_line_received()`
    method is specified as an operation completion callback.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因为响应可能非常大，而且我们事先不知道其大小，所以我们不想一次性读取它。我们首先只想读取**HTTP响应状态行**；然后，分析它后，要么继续读取响应的其余部分（如果我们认为需要的话），要么丢弃它。因此，我们将表示HTTP响应状态行结束的`\r\n`符号序列作为分隔符参数传递给`asio::async_read_until()`方法。将`on_status_line_received()`方法指定为操作完成回调。
- en: When the status line is received, the `on_status_line_received()` method is
    invoked. This method performs parsing of the status line, extracting values designating
    the HTTP protocol version, response status code, and response status message from
    it. Each value is analyzed for correctness. We expect the HTTP version to be 1.1,
    otherwise the response is considered incorrect and the request execution is interrupted.
    The status code should be an integer value. If the string-to-integer conversion
    fails, the response is considered incorrect and its further processing is interrupted
    too. If the response status line is correct, the request execution continues.
    The extracted status code and status message are stored in the `m_response` member
    object, and the next asynchronous operation in the request execution operation
    sequence is initiated. Now, we want to read the response headers block.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到状态行时，会调用`on_status_line_received()`方法。此方法对状态行进行解析，从中提取指定HTTP协议版本、响应状态码和响应状态消息的值。每个值都会进行分析以确保正确性。我们期望HTTP版本为1.1，否则认为响应不正确，并中断请求执行。状态码应该是一个整数值。如果字符串到整数的转换失败，则认为响应不正确，并中断其进一步处理。如果响应状态行正确，则请求执行继续。提取的状态码和状态消息存储在`m_response`成员对象中，并启动请求执行操作序列中的下一个异步操作。现在，我们想要读取响应头块。
- en: According to the HTTP protocol, the response headers block ends with the `\r\n\r\n`
    symbols sequence. Therefore, in order to read it, we call the `asio::async_read_until()`
    free function one more time, specifying the string `\r\n\r\n` as a delimiter.
    The `on_headers_received()` method is specified as a callback.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 HTTP 协议，响应头块以 `\r\n\r\n` 符号序列结束。因此，为了读取它，我们再次调用 `asio::async_read_until()`
    自由函数，指定字符串 `\r\n\r\n` 作为分隔符。将 `on_headers_received()` 方法指定为回调。
- en: When the response headers block is received, the `on_headers_received()` method
    is invoked. In this method, the response headers block is parsed and broken into
    separate name-value pairs and stored in the `m_response` member object as a part
    of the response.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到响应头块时，会调用 `on_headers_received()` 方法。在这个方法中，响应头块被解析并分解成单独的名字-值对，并作为响应的一部分存储在
    `m_response` 成员对象中。
- en: Having received and parsed the headers, we want to read the last part of the
    response—the response body. To do this, an asynchronous reading operation is initiated
    by calling the `asio::async_read()` free function. The `on_response_body_received()`
    method is specified as a callback.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接收并解析了头部信息后，我们想要读取响应的最后部分——响应体。为此，通过调用 `asio::async_read()` 自由函数启动异步读取操作。将 `on_response_body_received()`
    方法指定为回调。
- en: Eventually, the `on_response_body_received()` method is invoked notifying us
    of the fact that the whole response message has been received. Because the HTTP
    server may shutdown the send part of its socket just after it sends the last part
    of the response message, on the client side, the last reading operation may complete
    with an error code equal to the `asio::error::eof` value. This should not be treated
    as an actual error, but rather as a normal event. Therefore, if the `on_response_body_received()`
    method is called with the `ec` argument equal to `asio::error::eof`, we pass the
    default constructed object of the `boost::system::error_code` class to the `on_finish()`
    method in order to designate that the request execution is completed successfully.
    Otherwise, the `on_finish()` method is called with an argument representing the
    original error code. The `on_finish()` method in its turn calls the callback provided
    by the client of the `HTTPRequest` class object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，会调用 `on_response_body_received()` 方法，通知我们整个响应消息已经接收完毕。因为 HTTP 服务器可能在发送响应消息的最后部分后立即关闭其套接字的发送部分，所以在客户端，最后的读取操作可能以等于
    `asio::error::eof` 的错误代码完成。这不应被视为实际错误，而应视为一个正常事件。因此，如果 `on_response_body_received()`
    方法以等于 `asio::error::eof` 的 `ec` 参数被调用，我们将默认构造的 `boost::system::error_code` 类对象传递给
    `on_finish()` 方法，以指定请求执行已成功完成。否则，`on_finish()` 方法会以表示原始错误代码的参数被调用。`on_finish()`
    方法反过来会调用 `HTTPRequest` 类对象客户端提供的回调。
- en: When the callback returns, request processing is considered finished.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当回调返回时，认为请求处理已完成。
- en: The HTTPResponse class
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`HTTPResponse` 类'
- en: The `HTTPResponse` class does not provide much functionality. It is more like
    a plain data structure containing data members representing different parts of
    a response, with getter and setter methods defined, allowing getting and setting
    corresponding data member values.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPResponse` 类不提供很多功能。它更像是一个包含表示响应不同部分的数据成员的普通数据结构，定义了获取和设置相应数据成员值的获取器和设置器方法。'
- en: All setter methods are private and only the objects of the `HTTPRequest` class
    has access to them (recall that the `HTTPRequest` class is declared as the `HTTPResponse`
    class' friend). Each object of the `HTTPRequest` class has a data member that
    is an instance of the `HTTPResponse` class. The object of the `HTTPRequest` class
    sets values of its member object of `HTTPResponse` class as it receives and parses
    the response received from a HTTP server.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有设置方法都是私有的，只有 `HTTPRequest` 类的对象可以访问它们（回想一下，`HTTPRequest` 类被声明为 `HTTPResponse`
    类的朋友）。`HTTPRequest` 类的每个对象都有一个数据成员，它是 `HTTPResponse` 类的一个实例。当 `HTTPRequest` 类的对象接收并解析从
    HTTP 服务器接收到的响应时，它会设置其 `HTTPResponse` 类成员对象中的值。
- en: Callback and the main() entry point functions
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回调和 `main()` 入口点函数
- en: These functions demonstrate how to use the `HTTPClient` and `HTTPRequest` classes
    in order to send the `GET` HTTP requests to the HTTP server and then how to use
    the `HTTPResponse` class to obtain the response.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数演示了如何使用 `HTTPClient` 和 `HTTPRequest` 类来向 HTTP 服务器发送 `GET` HTTP 请求，然后如何使用
    `HTTPResponse` 类来获取响应。
- en: The `main()` function first creates an instance of the `HTTPClient` class and
    then uses it to create two instances of the `HTTPRequest` class, each representing
    a separate `GET` HTTP request. Both request objects are provided with request
    parameters and then executed. However, just after the second request has been
    executed, the first one is canceled by invoking its `cancel()` method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数首先创建`HTTPClient`类的一个实例，然后使用它创建两个`HTTPRequest`类的实例，每个实例代表一个单独的`GET`
    HTTP请求。这两个请求对象都提供了请求参数，然后执行。然而，在第二个请求执行后，第一个请求通过调用其`cancel()`方法被取消。'
- en: The `handler()` function, which is used as a completion callback for both request
    objects created in the `main()` function, is invoked when each request completes
    regardless of whether it succeeded, failed, or was canceled. The `handler()` function
    analyses the error code and the request and response objects passed to it as arguments
    and output corresponding messages to the standard output stream.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`handler()`函数，作为在`main()`函数中创建的请求对象的完成回调，无论请求成功、失败或被取消，每次请求完成时都会被调用。`handler()`函数分析传递给它的错误代码和请求以及响应对象，并将相应的消息输出到标准输出流。'
- en: See also
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Implementing asynchronous TCP client* recipe from [Chapter 3](ch03.html
    "Chapter 3. Implementing Client Applications"), *Implementing Client Applications*,
    provides more information on how to implement an asynchronous TCP client.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第3章](ch03.html "第3章。实现客户端应用程序")的*实现异步TCP客户端*配方提供了关于如何实现异步TCP客户端的更多信息。
- en: The *Using timers* recipe from [Chapter 6](ch06.html "Chapter 6. Other Topics"),
    *Other Topics*, demonstrates how to use timers provided by Boost.Asio. Timers
    can be used to implement an asynchronous operation timeout mechanism.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第6章](ch06.html "第6章。其他主题")的*使用定时器*配方，*其他主题*，展示了如何使用Boost.Asio提供的定时器。定时器可以用来实现异步操作超时机制。
- en: Implementing the HTTP server application
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现HTTP服务器应用程序
- en: Nowadays, there are plenty of HTTP server applications available in the market.
    However, sometimes there is a need to implement a custom one. This could be a
    small and simple server, supporting a specific subset of HTTP protocol possibly
    with custom extensions, or maybe not an HTTP server but a server supporting a
    communication protocol, which is similar to HTTP or is based on it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，市场上有很多HTTP服务器应用程序。然而，有时需要实现一个定制的应用程序。这可能是一个小型简单的服务器，支持HTTP协议的特定子集，可能带有自定义扩展，或者可能不是一个HTTP服务器，而是一个支持类似HTTP或基于HTTP的通信协议的服务器。
- en: 'In this recipe, we will consider the implementation of basic HTTP server application
    using Boost.Asio. Here is the set of requirements that our application must satisfy:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将考虑使用Boost.Asio实现基本HTTP服务器应用程序。以下是我们的应用程序必须满足的一组要求：
- en: It should support the HTTP 1.1 protocol
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该支持HTTP 1.1协议
- en: It should support the `GET` method
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该支持`GET`方法
- en: It should be able to process multiple requests in parallel, that is, it should
    be an asynchronous parallel server
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该能够并行处理多个请求，也就是说，它应该是一个异步并行服务器
- en: In fact, we have already considered the implementation of the server application
    that partially fulfils specified requirements. In [Chapter 4](ch04.html "Chapter 4. Implementing
    Server Applications"), *Implementing Server Applications*, the recipe named *Implementing
    an asynchronous TCP server* demonstrates how to implement an asynchronous parallel
    TCP server, which communicates with clients according to a dummy application layer
    protocol. All the communication functionality and protocol details are encapsulated
    in a single class named `Service`. All other classes and functions defined in
    that recipe are infrastructural in their purpose and isolated from the protocol
    details. Therefore, the current recipe will be based on the one from [Chapter
    4](ch04.html "Chapter 4. Implementing Server Applications"), *Implementing Server
    Applications*, and here we will only consider the implementation of the `Service`
    class as all other components stay the same.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们已经在考虑实现部分满足指定要求的服务器应用程序。在[第4章](ch04.html "第4章。实现服务器应用程序")中，名为*实现服务器应用程序*的配方展示了如何实现一个异步并行TCP服务器，该服务器根据一个虚拟的应用层协议与客户端进行通信。所有的通信功能以及协议细节都被封装在一个名为`Service`的单个类中。在该配方中定义的其他所有类和函数在目的上都是基础设施性的，并且与协议细节隔离。因此，当前的配方将基于[第4章](ch04.html
    "第4章。实现服务器应用程序")中的配方，在这里我们只考虑`Service`类的实现，因为其他组件保持不变。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, in this recipe, we do not consider the security aspect of the application.
    Make sure the server is protected before making it available to the public, where
    though operating correctly and in accordance with HTTP protocol, it could be compromised
    by the culprits due to security breaches.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在本配方中，我们不考虑应用程序的安全性。在将服务器公开之前，请确保服务器受到保护，尽管它按照HTTP协议正确运行，但由于安全漏洞，它可能被犯罪分子所利用。
- en: Now let's move on to the implementation of the HTTP server application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续实现HTTP服务器应用程序。
- en: Getting ready…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中…
- en: Because the application demonstrated in this recipe is based on other applications
    demonstrated in the recipe named *Implementing asynchronous TCP server* from [Chapter
    4](ch04.html "Chapter 4. Implementing Server Applications"), *Implementing Server
    Applications*, it is necessary to get acquainted with that recipe before proceeding
    with this one.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因为本配方中演示的应用程序基于[第4章](ch04.html "第4章。实现服务器应用程序")中名为*实现异步TCP服务器*的配方中的其他应用程序，所以在继续进行本配方之前，有必要熟悉那个配方。
- en: How to do it…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We begin our application by including header files containing declarations
    and definitions of data types and functions that we will use:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始我们的应用程序，通过包含包含我们将要使用的数据类型和函数的声明和定义的头文件：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we start defining the `Service` class that provides the implementation
    of the HTTP protocol. Firstly, we declare a static constant table containing HTTP
    status codes and status messages. The definition of the table will be given after
    the `Service` class'' definition:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始定义提供HTTP协议实现的`Service`类。首先，我们声明一个静态常量表，包含HTTP状态码和状态消息。表的定义将在`Service`类定义之后给出：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The class'' constructor accepts a single parameter—shared pointer pointing
    to an instance of a socket connected to a client. Here''s the definition of the
    constructor:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 类的构造函数接受一个参数——指向连接到客户端的套接字实例的共享指针。以下是构造函数的定义：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we define a single method constituting the `Service` class'' public interface.
    This method initiates an asynchronous communication session with the client connected
    to the socket, pointer to which was passed to the `Service` class'' constructor:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个构成`Service`类公共接口的单个方法。该方法通过将指向连接到套接字的客户端实例的指针传递给`Service`类的构造函数，启动与套接字连接的客户端的异步通信会话：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we define a set of private methods that perform receiving and processing
    of the request sent by the client, parse and execute the request, and send the
    response back. Firstly, we define a method that processes the **HTTP request line**:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一组私有方法，这些方法执行接收和处理客户端发送的请求，解析和执行请求，并将响应发送回去。首先，我们定义一个处理**HTTP请求行**的方法：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we define a method intended to process and store the **request headers
    block**, containing the request headers:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个旨在处理和存储包含请求头的**请求头块**的方法：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Besides, we need a method that can perform the actions needed to fulfill the
    request sent by the client. We define the `process_request()` method, whose purpose
    is to read the contents of the requested resource from the file system and store
    it in the buffer, ready to be sent back to the client:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要一个可以执行满足客户端发送的请求所需操作的方法。我们定义了`process_request()`方法，其目的是从文件系统中读取请求资源的内容并将其存储在缓冲区中，以便将其发送回客户端：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we define a method that composes a response message and send it to
    the client:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义一个方法来组合响应消息并将其发送到客户端：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When the response sending is complete, we need to shut down the socket to let
    the client know that a full response has been sent and no more data will be sent
    by the server. We define the `on_response_sent()` method for this purpose:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当响应发送完成时，我们需要关闭套接字，让客户端知道已经发送了完整的响应，并且服务器将不再发送更多数据。为此，我们定义了`on_response_sent()`方法：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The last method we need to define is the one that performs cleanup and deletes
    an instance of the `Service` object, when the communication session is finished
    and the object is not needed anymore is not needed anymore:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义的最后一个方法是执行清理并删除`Service`对象实例的方法，当通信会话完成且对象不再需要时：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Of course, we will need some data members in our class. We declare the following
    data members:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在我们的类中我们需要一些数据成员。我们声明以下数据成员：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The last thing we need to do to complete the definition of the class representing
    a service is to define the `http_status_table` static member declared before and
    fill it with data—HTTP status code and corresponding status messages:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成表示服务的类的定义，我们需要做的最后一件事是定义之前声明的静态成员`http_status_table`并填充数据——HTTP状态码和相应的状态消息：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Our `Service` class is now ready.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Service`类现在就准备好了。
- en: How it works…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s begin with considering the `Service` class'' data members and then switch
    to its functionality. The `Service` class contains the following non-static data
    members:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从考虑`Service`类的数据成员开始，然后转向其功能。`Service`类包含以下非静态数据成员：
- en: '`std::shared_ptr<boost::asio::ip::tcp::socket> m_sock`: This is a shared pointer
    to a TCP socket object connected to the client'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shared_ptr<boost::asio::ip::tcp::socket> m_sock`：这是一个指向连接到客户端的TCP套接字对象的共享指针'
- en: '`boost::asio::streambuf m_request`: This is a buffer into which the request
    message is read'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::asio::streambuf m_request`：这是一个缓冲区，请求消息被读取到其中'
- en: '`std::map<std::string, std::string> m_request_headers`: This is a map where
    request headers are put when the HTTP request headers block is parsed'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map<std::string, std::string> m_request_headers`：这是一个映射，当解析HTTP请求头块时，请求头会被放入其中'
- en: '`std::string m_requested_resource`: This is the URI of the resource requested
    by the client'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::string m_requested_resource`：这是客户端请求的资源URI'
- en: '`std::unique_ptr<char[]> m_resource_buffer`: This is a buffer where the contents
    of a requested resource is stored before being sent to the client as a part of
    the response message'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unique_ptr<char[]> m_resource_buffer`：这是一个缓冲区，在将请求资源的内容作为响应消息的一部分发送到客户端之前，存储请求资源的内容'
- en: '`unsigned int m_response_status_code`: This is the HTTP response status code'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned int m_response_status_code`：这是HTTP响应状态码'
- en: '`std::size_t m_resource_size_bytes`: This is the size of the contents of the
    requested resource'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::size_t m_resource_size_bytes`：这是请求资源的内容的尺寸'
- en: '`std::string m_response_headers`: This is a string containing a properly formatted
    response headers block'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::string m_response_headers`：这是一个包含正确格式化的响应头块的字符串'
- en: '`std::string m_response_status_line`: This contains a response status line'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::string m_response_status_line`：这包含一个响应状态行'
- en: Now that we know the purpose of the `Service` class' data members, let's trace
    how it works. Here, we will only consider how the `Service` class works. The description
    of all other components of the server application and how they work is given in
    the recipe named *Implementing an asynchronous TCP server* in [Chapter 4](ch04.html
    "Chapter 4. Implementing Server Applications"), *Implementing Server Applications*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了`Service`类数据成员的目的，让我们追踪它是如何工作的。在这里，我们只考虑`Service`类的工作方式。关于服务器应用程序的所有其他组件及其工作方式的描述，请参阅第4章中名为*实现异步TCP服务器*的配方，*实现服务器应用程序*。
- en: When a client sends a TCP connection request and this request is accepted on
    the server (this happens in the `Acceptor` class, which is not considered in this
    recipe), an instance of the `Service` class is created and its constructor is
    passed a shared pointer pointing to the TCP socket object, connected to that client.
    The pointer to the socket is stored in the `Service` object's data member `m_sock`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端发送TCP连接请求并且该请求在服务器上被接受（这发生在`Acceptor`类中，在本食谱中不予考虑）时，会创建`Service`类的一个实例，并将指向连接到该客户端的TCP套接字对象的共享指针传递给其构造函数。套接字指针存储在`Service`对象的数据成员`m_sock`中。
- en: Besides, during the construction of the `Service` object, the `m_request` stream
    buffer member is initialized with the value of 4096, which sets the maximum size
    of the buffer in bytes. Limiting the size of the request buffer is a security
    measure, which helps to protect the server from malicious clients that may try
    to send very long dummy request messages exhausting all memory at the disposal
    of the server application. For the correct request, a buffer of 4096 bytes in
    size is more than enough.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在构造`Service`对象期间，`m_request`流缓冲区成员变量被初始化为4096，这设置了缓冲区的最大字节数。限制请求缓冲区的大小是一种安全措施，有助于保护服务器免受可能尝试发送非常长的虚拟请求消息并耗尽服务器应用程序可用内存的恶意客户端。对于正确的请求，4096字节的缓冲区大小绰绰有余。
- en: After an instance of the `Service` class has been constructed, its `start_handling()`
    method is called by the `Acceptor` class. From this method, the sequence of asynchronous
    method invocations begins, which performs request receiving, processing, and response
    sending. The `start_handling()` method immediately initiates an asynchronous reading
    operation calling the `asio::async_read_until()` function in order to receive
    the HTTP request line sent by the client. The `on_request_line_received()` method
    is specified as a callback.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造`Service`类的一个实例之后，`Acceptor`类会调用其`start_handling()`方法。从这个方法开始，异步方法调用的序列开始执行，该序列执行请求接收、处理和响应发送。`start_handling()`方法立即启动一个异步读取操作，调用`asio::async_read_until()`函数以接收客户端发送的HTTP请求行。`on_request_line_received()`方法被指定为回调。
- en: When the `on_request_line_received()` method is invoked, we first check the
    error code specifying the operation completion status. If the status code is not
    equal to zero, we consider two options. The first option—when the error code is
    equal to the `asio::error::not_found` value—means that more bytes have been received
    from the client than the size of the buffer and the delimiter of the HTTP request
    line (the `\r\n` symbol sequence) has not been encountered. This case is described
    by the HTTP status code 413\. We set the value of the `m_response_status_code`
    member variable to 413 and call the `send_response()` method that initiates the
    operation that sends a response designating the error back to the client. We will
    consider the `send_response()` method later in this section. At this point, the
    request processing is finished.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`on_request_line_received()`方法时，我们首先检查指定操作完成状态的错误代码。如果状态码不等于零，我们考虑两种选项。第一种选项——当错误代码等于`asio::error::not_found`值时——意味着从客户端接收的字节数超过了缓冲区的大小和HTTP请求行（`\r\n`符号序列）的分隔符尚未遇到。这种情况由HTTP状态码413描述。我们将`m_response_status_code`成员变量的值设置为413，并调用`send_response()`方法，该方法启动向客户端发送指定错误响应的操作。我们将在本节稍后考虑`send_response()`方法。此时，请求处理已完成。
- en: If the error code neither designates success nor is equal to `asio::error::not_found`,
    it means that some other error has occurred from which we cannot recover, therefore,
    we just output the information about the error and do not reply to the client
    at all. The `on_finish()` method is called to perform the cleanup, and the communication
    with the client is interrupted.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误代码既不表示成功也不等于`asio::error::not_found`，这意味着发生了其他我们无法恢复的错误，因此，我们只是输出有关错误的信息，并且根本不向客户端回复。调用`on_finish()`方法进行清理，并中断与客户端的通信。
- en: Finally, if receiving of the HTTP request line succeeds, it is parsed to extract
    the HTTP request method, the URI identifying the requested resource and the HTTP
    protocol version. Because our sample server only supports the `GET` method, if
    the method specified in the request line is different from `GET`, further request
    processing is interrupted and the response containing the error code 501 is sent
    to the client to inform it that the method specified in the request is not supported
    by the server.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果 HTTP 请求行的接收成功，它将被解析以提取 HTTP 请求方法、标识请求资源的 URI 以及 HTTP 协议版本。因为我们的示例服务器只支持
    `GET` 方法，如果请求行中指定的方法与 `GET` 不同，则进一步请求处理将被中断，并向客户端发送包含错误代码 501 的响应，告知客户端请求中指定的方法不被服务器支持。
- en: Likewise, the HTTP protocol version specified by the client in the HTTP request
    line is checked to be the one supported by the server. Because our server application
    supports only version 1.1, if the version specified by the client is different,
    the response with the HTTP status code 505 is sent to the client and the request
    processing is interrupted.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，客户端在 HTTP 请求行中指定的 HTTP 协议版本将被检查，以确保它被服务器支持。因为我们的服务器应用程序只支持版本 1.1，如果客户端指定的版本不同，则向客户端发送包含
    HTTP 状态代码 505 的响应，并中断请求处理。
- en: A URI string extracted from the HTTP request line is stored in the `m_requested_resource`
    data member and will be used later.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从 HTTP 请求行中提取的 URI 字符串存储在 `m_requested_resource` 数据成员中，并将随后使用。
- en: When the HTTP request line is received and parsed, we continue reading the request
    message in order to read the request headers block. To do this, the `asio::async_read_until()`
    function is called. Because the request headers block ends with the `\r\n\r\n`
    symbol sequence, this symbol sequence is passed to the function as a delimiter
    argument. The `on_headers_received()` method is specified as an operation completion
    callback.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到并解析 HTTP 请求行时，我们继续读取请求消息，以便读取请求头部块。为此，调用 `asio::async_read_until()` 函数。因为请求头部块以
    `\r\n\r\n` 符号序列结束，所以这个符号序列被作为分隔符参数传递给函数。指定 `on_headers_received()` 方法作为操作完成回调。
- en: The `on_headers_received()` method performs error checking similar to the one
    that is performed in the `on_request_line_received()` method. In case of an error,
    request processing interrupts. In the case of success, the HTTP request headers
    block is parsed and broken into separate name-value pairs, which are then stored
    in the `m_request_headers` member map. After the headers block has been parsed,
    the `process_request()` and `send_response()` methods are called consequently.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_headers_received()` 方法执行类似于 `on_request_line_received()` 方法中执行的错误检查。在出现错误的情况下，请求处理中断。在成功的情况下，解析
    HTTP 请求头部块并将其分解为单独的名称-值对，然后存储在 `m_request_headers` 成员映射中。在解析头部块之后，依次调用 `process_request()`
    和 `send_response()` 方法。'
- en: The purpose of the `process_request()` method is to read the file specified
    in the request as the URI and put its content to the buffer, from which the contents
    will be sent to the client as a part of the response message. If the specified
    file is not found in the server root directory, the HTTP status code 404 (page
    not found) code is sent to the client as a part of the response message and the
    request processing interrupts.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_request()` 方法的目的是读取请求中指定的作为 URI 的文件，并将其内容放入缓冲区，然后从该缓冲区发送内容到客户端，作为响应消息的一部分。如果指定的文件在服务器根目录中找不到，则将
    HTTP 状态代码 404（页面未找到）作为响应消息的一部分发送给客户端，并中断请求处理。'
- en: However, if the requested file is found, its size is first calculated and then
    the buffer of the corresponding size is allocated in the free memory and the file
    contents are read in that buffer.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果找到请求的文件，首先计算其大小，然后在空闲内存中分配相应大小的缓冲区，并在该缓冲区中读取文件内容。
- en: After this, an HTTP header named *content-length* specifying the size of the
    response body is added to the `m_response_headers` string data member. This data
    member represents the response headers block and its value will later be used
    as a part of the response message.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，将一个名为 *content-length* 的 HTTP 头部添加到 `m_response_headers` 字符串数据成员中，该头部指定了响应体的尺寸。此数据成员代表响应头部块，其值将随后作为响应消息的一部分使用。
- en: At this point, all ingredients required to construct the HTTP response message
    are available and we can move on to preparing and sending the response to the
    client. This is done in the `send_response()` method.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，构建HTTP响应消息所需的所有成分都已可用，我们可以继续准备并发送响应给客户端。这是在`send_response()`方法中完成的。
- en: The `send_response()` method starts with shutting down the receive side of the
    socket letting the client know that the server will not read any data from it
    anymore. Then, it extracts the response status message corresponding to the status
    code stored in the `m_response_status_code` member variable from the `http_status_table`
    static table.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_response()`方法从关闭套接字的接收端开始，让客户端知道服务器将不再从它那里读取任何数据。然后，它从`http_status_table`静态表中提取与存储在`m_response_status_code`成员变量中的状态代码相对应的响应状态消息。'
- en: Next, the HTTP response status line is constructed and the headers block is
    appended with the delimiting symbol sequence `\r\n` according to the HTTP protocol.
    At this point, all the components of the response message—the response status
    line, response headers block, and response body—are ready to be sent to the client.
    The components are combined in the form of a vector of buffers, each represented
    with an instance of the `asio::const_buffer` class and containing one component
    of the response message. A vector of buffers embodies a composite buffer consisting
    of three parts. When this composite buffer is constructed, it is passed to the
    `asio::async_write()` function to be sent to the client. The `Service` class'
    `on_response_sent()` method is specified as a callback.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，构建HTTP响应状态行，并根据HTTP协议将头部块附加带有分隔符号序列`\r\n`。到这一点，响应消息的所有组件——响应状态行、响应头部块和响应体——都已准备好发送给客户端。这些组件以缓冲区向量的形式组合，每个缓冲区由`asio::const_buffer`类的实例表示，并包含响应消息的一个组件。缓冲区向量体现了一个由三部分组成的复合缓冲区。当这个复合缓冲区构建时，它被传递给`asio::async_write()`函数以发送给客户端。`Service`类的`on_response_sent()`方法被指定为回调。
- en: When the response message is sent and the `on_response_sent()` callback method
    is invoked, it first checks the error code and outputs the log message if the
    operation fails; then, it shuts down the socket and calls the `on_finish()` method.
    The `on_finish()` method in its turn deletes the instance of the `Service` object
    in the context of which it is called.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当响应消息发送并且调用`on_response_sent()`回调方法时，它首先检查错误代码，如果操作失败则输出日志消息；然后关闭套接字并调用`on_finish()`方法。`on_finish()`方法反过来删除在调用它的上下文中`Service`对象的实例。
- en: At this point, client handling is finished.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，客户端处理已经完成。
- en: See also
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Implementing an asynchronous TCP server* recipe from [Chapter 4](ch04.html
    "Chapter 4. Implementing Server Applications"), *Implementing Server Applications*,
    provides more information on how to implement the asynchronous TCP server used
    as a base for this recipe.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第4章](ch04.html "第4章。实现服务器应用程序")的*实现异步TCP服务器*配方，*实现服务器应用程序*，提供了更多关于如何实现作为本配方基础的异步TCP服务器的信息。
- en: The *Using timers* recipe from [Chapter 6](ch06.html "Chapter 6. Other Topics"),
    *Other Topics*, demonstrates how to use timers provided by Boost.Asio. Timers
    can be used to implement an asynchronous operation timeout mechanism.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第6章](ch06.html "第6章。其他主题")的*使用定时器*配方，*其他主题*，展示了如何使用Boost.Asio提供的定时器。定时器可以用来实现异步操作超时机制。
- en: Adding SSL/TLS support to client applications
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为客户端应用程序添加SSL/TLS支持
- en: Client applications usually use SSL/TLS protocol to send sensitive data such
    as passwords, credit card numbers, personal data. SSL/TLS protocol allows clients
    to authenticate the server and encrypt the data. The authentication of the server
    allows the client to make sure that the data will be sent to the expected addressee
    (and not to a malicious one). Data encryption guarantees that even if the transmitted
    data is intercepted somewhere on its way to the server, the interceptor will not
    be able to use it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序通常使用SSL/TLS协议发送敏感数据，如密码、信用卡号码、个人信息。SSL/TLS协议允许客户端验证服务器并加密数据。服务器的验证允许客户端确保数据将被发送到预期的接收者（而不是恶意者）。数据加密保证即使传输的数据在途中被拦截，拦截者也无法使用它。
- en: This recipe demonstrates how to implement a synchronous TCP client application
    supporting SSL/TLS protocol using the Boost.Asio and OpenSSL libraries. The TCP
    client application demonstrated in the recipe named *Implementing synchronous
    TCP client* from [Chapter 3](ch03.html "Chapter 3. Implementing Client Applications"),
    *Implementing Client Applications*, is taken as a base for this recipe, and some
    code changes and additions are made to it in order to add support for SSL/TLS
    protocol. The code that differs from that of the base implementation of the synchronous
    TCP client is *highlighted* so that the code directly related to SSL/TLS support
    is better distinguished from the rest of the code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱演示了如何使用 Boost.Asio 和 OpenSSL 库实现一个支持 SSL/TLS 协议的同步 TCP 客户端应用程序。本食谱中演示的 TCP
    客户端应用程序名为 *实现同步 TCP 客户端*，来自 [第 3 章](ch03.html "第 3 章。实现客户端应用程序")，*实现客户端应用程序*，将其作为本食谱的基础，并对它进行了某些代码更改和添加，以便添加对
    SSL/TLS 协议的支持。与同步 TCP 客户端的基础实现不同的代码被 *突出显示*，以便与 SSL/TLS 支持相关的代码能更好地与其他代码区分开来。
- en: Getting ready…
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: Before setting out to this recipe, OpenSSL library must be installed and the
    project must be linked against it. Procedures related to the installation of the
    library or linking the project against it are beyond the scope of this book. Refer
    to the OpenSSL library documentation for more information.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本食谱之前，必须安装 OpenSSL 库，并将项目链接到它。有关库安装或项目链接的步骤超出了本书的范围。有关更多信息，请参阅 OpenSSL 库文档。
- en: Besides, because this recipe is based on another recipe named *Implementing
    a synchronous TCP Client* from [Chapter 3](ch03.html "Chapter 3. Implementing
    Client Applications"), *Implementing Client Applications*, it is highly advised
    to get acquainted with it before proceeding to this one.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于本食谱基于另一个名为 *实现同步 TCP 客户端* 的食谱，来自 [第 3 章](ch03.html "第 3 章。实现客户端应用程序")，*实现客户端应用程序*，强烈建议在继续之前熟悉它。
- en: How to do it…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: The following code sample demonstrates the possible implementation of a synchronous
    TCP client application supporting SSL/TLS protocol to authenticate the server
    and encrypt the data being transmitted.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了支持 SSL/TLS 协议以验证服务器并加密传输数据的同步 TCP 客户端应用程序的可能实现。
- en: 'We begin our application by adding the `include` and `using` directives:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从添加 `include` 和 `using` 指令开始我们的应用程序：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `<boost/asio/ssl.hpp>` header contains types and functions providing integration
    with OpenSSL library.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`<boost/asio/ssl.hpp>` 头文件包含提供与 OpenSSL 库集成的类型和函数。'
- en: 'Next, we define a class that plays the role of the synchronous SSL/TLS-enabled
    TCP client:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个扮演同步 SSL/TLS 启用 TCP 客户端角色的类：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we implement the `main()` application entry point function that uses the
    `SyncSSLClient` class to authenticate the server and securely communicate with
    it using SSL/TLS protocol:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们实现 `main()` 应用程序入口点函数，它使用 `SyncSSLClient` 类通过 SSL/TLS 协议验证服务器并与其安全通信：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The sample client application consists of two main components: the `SyncSSLClient`
    class and a `main()` application entry point function that uses the `SyncSSLClient`
    class to communicate with the server application over SSL/TLS protocol. Let''s
    consider how each component works separately.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 示例客户端应用程序由两个主要组件组成：`SyncSSLClient` 类和 `main()` 应用程序入口点函数，后者使用 `SyncSSLClient`
    类通过 SSL/TLS 协议与服务器应用程序通信。让我们分别考虑每个组件的工作原理。
- en: The SyncSSLClient class
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SyncSSLClient 类
- en: The `SyncSSLClient` class is the key component in our application. It implements
    the communication functionality.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`SyncSSLClient` 类是我们应用程序中的关键组件。它实现了通信功能。'
- en: 'The class has four private data members as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有四个私有数据成员，如下所示：
- en: '`asio::io_service m_ios`: This is an object providing access to the operating
    system''s communication services that are used by the socket object.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asio::io_service m_ios`：这是一个提供对操作系统通信服务的对象，这些服务由套接字对象使用。'
- en: '`asio::ip::tcp::endpoint m_ep`: This is an endpoint designating the server
    application.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asio::ip::tcp::endpoint m_ep`：这是一个指定服务器应用程序的端点。'
- en: '`asio::ssl::context m_ssl_context`: This is an object representing SSL context;
    basically, this is a wrapper around the `SSL_CTX` data structure defined by OpenSSL
    library. This object contains global settings and parameters used by other objects
    and functions involved in the process of communication using SSL/TLS protocol.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asio::ssl::context m_ssl_context`：这是一个表示SSL上下文的对象；基本上，这是一个围绕OpenSSL库中定义的`SSL_CTX`数据结构包装的包装器。此对象包含用于通过SSL/TLS协议进行通信的其他对象和函数的全球设置和参数。'
- en: '`asio::ssl::stream<asio::ip::tcp::socket> m_ssl_stream`: This represents a
    stream that wraps a TCP socket object and implements all SSL/TLS communication
    operations.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asio::ssl::stream<asio::ip::tcp::socket> m_ssl_stream`：这表示一个包装TCP套接字对象的流，并实现了所有SSL/TLS通信操作。'
- en: Each object of the class is intended to communicate with a single server. Therefore,
    the class' constructor accepts an IP address and a protocol port number designating
    the server application as its input arguments. These values are used to instantiate
    the `m_ep` data member in the constructor's initialization list.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的每个对象都旨在与单个服务器进行通信。因此，类的构造函数接受一个IP地址和一个协议端口号作为输入参数，指定服务器应用程序。这些值用于在构造函数的初始化列表中实例化`m_ep`数据成员。
- en: Next, the `m_ssl_context` and `m_ssl_stream` members of the `SyncSSLClient`
    class are instantiated. We pass the `asio::ssl::context::sslv23_client` value
    to the `m_ssl_context` object's constructor to designate that the context will
    be used by the application playing a role of a *client* only and that we want
    to support multiple secure protocols including multiple versions of SSL and TLS.
    This value defined by Boost.Asio corresponds to a value representing a connection
    method returned by the `SSLv23_client_method()` function defined by OpenSSL library.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实例化`SyncSSLClient`类的`m_ssl_context`和`m_ssl_stream`成员。我们将`asio::ssl::context::sslv23_client`值传递给`m_ssl_context`对象的构造函数，以指定上下文将仅由充当*客户端*的应用程序使用，并且我们希望支持包括SSL和TLS多个版本的多个安全协议。此由Boost.Asio定义的值对应于OpenSSL库中定义的`SSLv23_client_method()`函数返回的连接方法表示的值。
- en: The SSL stream object `m_ssl_stream` is set up in the `SyncSSLClient` class'
    constructor. Firstly, the peer verification mode is set to `asio::ssl::verify_peer`,
    which means that we want to perform peer verification during a handshake. Then,
    we set a verification callback method that will be called when certificates arrive
    from the server. The callback is invoked once for each certificate in the certificates
    chain sent by the server.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: SSL流对象`m_ssl_stream`在`SyncSSLClient`类的构造函数中设置。首先，将对方验证模式设置为`asio::ssl::verify_peer`，这意味着我们希望在握手过程中执行对方验证。然后，我们设置一个验证回调方法，该方法将在从服务器收到证书时被调用。对于服务器发送的证书链中的每个证书，回调都会被调用一次。
- en: The class' `on_peer_verify()` method that is set as a peer verification callback
    is a dummy in our application. The certificate verification process lies beyond
    the scope of this book. Therefore, the function simply always returns the `true`
    constant, meaning that the certificate verification succeeded without performing
    the actual verification.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 类的`on_peer_verify()`方法被设置为对方验证回调是一个虚拟的。证书验证过程超出了本书的范围。因此，该函数简单地始终返回`true`常量，这意味着证书验证成功，而没有执行实际的验证。
- en: 'The three public methods comprise the interface of the `SyncSSLClient` class.
    The method named `connect()` performs two operations. Firstly, the TCP socket
    is connected to the server. The socket underlying the SSL stream is returned by
    the method of the SSL stream object `lowest_layer()`. Then, the `connect()` method
    is called on the socket with `m_ep` being passed as an argument designating the
    endpoint to be connected to:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 三个公共方法构成了`SyncSSLClient`类的接口。名为`connect()`的方法执行两个操作。首先，将TCP套接字连接到服务器。SSL流对象底层的套接字由SSL流对象的`lowest_layer()`方法返回。然后，使用`m_ep`作为参数（指定要连接的端点）调用套接字上的`connect()`方法：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After the TCP connection is established, the `handshake()` method is called
    on the SSL stream object, which leads to the initiation of the handshake process.
    This method is synchronous and does not return until the handshake completes or
    an error occurs:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP连接建立后，在SSL流对象上调用`handshake()`方法，这将导致握手过程的启动。此方法是同步的，直到握手完成或发生错误才返回：
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: After the `handshake()` method returns, both TCP and SSL (or TLS, depending
    on which protocol was agreed upon during the handshake process) connections are
    established and the effective communication can be performed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `handshake()` 方法返回后，TCP和SSL（或TLS，具体取决于握手过程中商定的协议）连接都建立，并且可以执行有效通信。
- en: The `close()` method shuts down the SSL connection by calling the `shutdown()`
    method on the SSL stream object. The `shutdown()` method is synchronous and blocks
    until the SSL connection is shut down or an error occurs. After this method returns,
    the corresponding SSL stream object cannot be used to transmit the data anymore.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`close()` 方法通过在SSL流对象上调用 `shutdown()` 方法来关闭SSL连接。`shutdown()` 方法是同步的，并且会阻塞，直到SSL连接关闭或发生错误。在此方法返回后，相应的SSL流对象不能再用于传输数据。'
- en: The third interface method is `emulate_long_computation_op(unsigned int duration_sec)`.
    This method is where the I/O operations are performed. It begins with preparing
    the request string according to the application layer protocol. Then, the request
    is passed to the class' `send_request(const std::string& request)` private method,
    which sends it to the server. When the request is sent and the `send_request()`
    method returns, the `receive_response()` method is called to receive the response
    from the server. When the response is received, the `receive_response()` method
    returns the string containing the response. After this, the `emulate_long_computation_op()`
    method returns the response message to its caller.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个接口方法是 `emulate_long_computation_op(unsigned int duration_sec)`。这个方法是在这里执行I/O操作的地方。它从根据应用层协议准备请求字符串开始。然后，请求被传递到类的
    `send_request(const std::string& request)` 私有方法，该方法将其发送到服务器。当请求发送并且 `send_request()`
    方法返回时，调用 `receive_response()` 方法从服务器接收响应。当收到响应时，`receive_response()` 方法返回包含响应的字符串。之后，`emulate_long_computation_op()`
    方法将响应消息返回给其调用者。
- en: Note that the `emulate_long_computation_op()`, `send_request()`, and `receive_response()`
    methods are almost identical to the corresponding methods defined in the `SyncTCPClient`
    class, which is a part of the synchronous TCP client application demonstrated
    in [Chapter 3](ch03.html "Chapter 3. Implementing Client Applications"), *Implementing
    Client Applications*, which we used as a base for `SyncSSLClient` class. The only
    difference is that in `SyncSSLClient`, an *SSL stream object* is passed to the
    corresponding Boost.Asio I/O functions, while in the `SyncTCPClient` class, a
    *socket object* is passed to those functions. Other aspects of the mentioned methods
    are identical.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`emulate_long_computation_op()`、`send_request()` 和 `receive_response()` 方法几乎与在
    `SyncTCPClient` 类中定义的相应方法相同，`SyncTCPClient` 类是同步TCP客户端应用程序的一部分，该应用程序在[第3章](ch03.html
    "第3章。实现客户端应用程序")，*实现客户端应用程序*中演示，我们将其用作 `SyncSSLClient` 类的基础。唯一的区别是，在 `SyncSSLClient`
    中，将 *SSL流对象* 传递给相应的Boost.Asio I/O函数，而在 `SyncTCPClient` 类中，将这些函数传递给 *套接字对象*。提到的其他方法方面是相同的。
- en: The main() entry point function
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`main()` 入口点函数'
- en: This function acts as a user of the `SyncSSLClient` class. Having obtained the
    server IP address and protocol port number, it instantiates and uses the object
    of the `SyncSSLClient` class to authenticate and securely communicate with the
    server in order to consume its service, namely, to emulate an operation on the
    server by performing dummy calculations for 10 seconds. The code of this function
    is simple and self-explanatory; thus, requires no additional comments.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数充当 `SyncSSLClient` 类的用户。在获取服务器IP地址和协议端口号后，它实例化并使用 `SyncSSLClient` 类的对象来验证并安全地与服务器通信，以使用其服务，即通过执行10秒的虚拟计算来模拟服务器上的操作。此函数的代码简单且易于理解；因此，不需要额外的注释。
- en: See also
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Implementing a synchronous TCP client* recipe from [Chapter 3](ch03.html
    "Chapter 3. Implementing Client Applications"), *Implementing Client Applications*,
    provides more information on how to implement a synchronous TCP client used as
    a base for this recipe.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。实现客户端应用程序")，*实现客户端应用程序*中的*实现同步TCP客户端*配方提供了有关如何实现作为本配方基础的同步TCP客户端的更多信息。'
- en: Adding SSL/TLS support to server applications
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为服务器应用程序添加SSL/TLS支持
- en: SSL/TLS protocol support is usually added to the server application when the
    services it provides assumes transmission of sensitive data such as passwords,
    credit card numbers, personal data, and so on, by the client to the server. In
    this case, adding SSL/TLS protocol support to the server allows clients to authenticate
    the server and establish a secure channel to make sure that the sensitive data
    is protected while being transmitted.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器提供的服务假设客户端将敏感数据（如密码、信用卡号、个人信息等）传输到服务器时，通常会在服务器应用程序中添加 SSL/TLS 协议支持。在这种情况下，向服务器添加
    SSL/TLS 协议支持允许客户端验证服务器，并建立一个安全通道，以确保在传输过程中敏感数据得到保护。
- en: Sometimes, a server application may want to use SSL/TLS protocol to authenticate
    the client; however, this is rarely the case and usually other methods are used
    to ensure the authenticity of the client (for example, username and password are
    specified when logging into a mail server).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，服务器应用程序可能想使用 SSL/TLS 协议来验证客户端；然而，这种情况很少见，通常使用其他方法来确保客户端的真实性（例如，在登录邮件服务器时指定用户名和密码）。
- en: This recipe demonstrates how to implement a synchronous iterative TCP server
    application supporting SSL/TLS protocol using the Boost.Asio and OpenSSL libraries.
    The synchronous iterative TCP server application demonstrated in the recipe named
    *Implementing a synchronous iterative TCP server* from [Chapter 4](ch04.html "Chapter 4. Implementing
    Server Applications"), *Implementing Server Applications*, is taken as a base
    for this recipe and some code changes and additions are made to it in order to
    add support for SSL/TLS protocol. The code that differs from that of the base
    implementation of the synchronous iterative TCP server is *highlighted* so that
    the code directly related to SSL/TLS support is better distinguished from the
    rest of the code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱演示了如何使用 Boost.Asio 和 OpenSSL 库实现一个支持 SSL/TLS 协议的同步迭代 TCP 服务器应用程序。菜谱中演示的同步迭代
    TCP 服务器应用程序名为 *实现同步迭代 TCP 服务器*，来自 [第 4 章](ch04.html "第 4 章。实现服务器应用程序")，*实现服务器应用程序*，本菜谱以此为基础，并对它进行了一些代码更改和添加，以便添加对
    SSL/TLS 协议的支持。与同步迭代 TCP 服务器的基础实现不同的代码被 *突出显示*，以便与代码的其他部分更好地区分开来，直接相关的代码与 SSL/TLS
    支持相关。
- en: Getting ready…
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: Before setting out to this recipe, OpenSSL library must be installed and the
    project must be linked against it. Procedures related to the installation of the
    library or linking the project against it are beyond the scope of this book. Refer
    to the official OpenSSL documentation for more information.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本菜谱之前，必须安装 OpenSSL 库，并将项目链接到它。有关库安装或项目链接的步骤超出了本书的范围。有关更多信息，请参阅官方 OpenSSL
    文档。
- en: Besides, because this recipe is based on another recipe named *Implementing
    a synchronous iterative TCP server*, from [Chapter 4](ch04.html "Chapter 4. Implementing
    Server Applications"), *Implementing Server Applications*, it is highly advised
    to get acquainted with it before proceeding to this one.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为本菜谱基于另一个名为 *实现同步迭代 TCP 服务器* 的菜谱，来自 [第 4 章](ch04.html "第 4 章。实现服务器应用程序")，*实现服务器应用程序*，所以在继续之前，强烈建议熟悉它。
- en: How to do it…
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: The following code sample demonstrates the possible implementation of a synchronous
    TCP server application supporting SSL/TLS protocol to allow client applications
    to authenticate the server and protect the data being transmitted.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了支持 SSL/TLS 协议的同步 TCP 服务器应用程序的可能实现，允许客户端验证服务器并保护传输中的数据。
- en: 'We begin our application by including Boost.Asio library headers and headers
    of some components of standard C++ libraries that we will need to implement in
    our application:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从包含 Boost.Asio 库头文件以及我们将需要在应用程序中实现的一些标准 C++ 库组件的头文件开始我们的应用程序：
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `<boost/asio/ssl.hpp>` header contains types and functions providing integration
    with OpenSSL library.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`<boost/asio/ssl.hpp>` 头文件包含提供与 OpenSSL 库集成的类型和函数。'
- en: 'Next, we define a class responsible for handling a single client by reading
    the request message, processing it, and then sending back the response message.
    This class represents a single service provided by the server application and
    is named correspondingly—`Service`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个类，该类通过读取请求消息、处理它，然后发送响应消息来处理单个客户端。这个类代表服务器应用程序提供的一个单一服务，并相应地命名为 `Service`：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we define another class that represents a high-level *acceptor* concept
    (as compared to the low-level acceptor represented by the `asio::ip::tcp::acceptor`
    class). This class is responsible for accepting connection requests arriving from
    clients and instantiating objects of the `Service` class, which will provide the
    service to connected clients. This class is called `Acceptor`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们定义另一个代表高级 *接受者* 概念的类（与由`asio::ip::tcp::acceptor`类表示的低级接受者相比）。这个类负责接受来自客户端的连接请求并实例化`Service`类的对象，该对象将为连接的客户端提供服务。这个类被称为`Acceptor`:'
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now we define a class that represents the server itself. The class is named
    correspondingly—`Server`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们定义一个代表服务器本身的类。这个类被相应地命名为—`Server`:'
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Eventually, we implement the `main()` application entry point function that
    demonstrates how to use the `Server` class. This function is identical to the
    one defined in the recipe from [Chapter 4](ch04.html "Chapter 4. Implementing
    Server Applications"), *Implementing Server Applications*, that we took as a base
    for this recipe:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们实现了`main()`应用程序入口点函数，该函数演示了如何使用`Server`类。此函数与我们在[第4章](ch04.html "第4章. 实现服务器应用程序")中定义的配方中的函数相同：
- en: '[PRE52]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that the last two components of the server application, namely, the `Server`
    class and the `main()` application entry point function are identical to the corresponding
    components defined in the recipe from [Chapter 4](ch04.html "Chapter 4. Implementing
    Server Applications"), *Implementing Server Applications*, that we took as a base
    for this recipe.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，服务器应用程序的最后两个组件，即`Server`类和`main()`应用程序入口点函数，与我们在[第4章](ch04.html "第4章. 实现服务器应用程序")中定义的相应组件相同，该组件是我们为这个配方所采用的基。
- en: How it works…
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The sample server application consists of four components: the `Service`, `Acceptor`,
    and `Server` classes and the `main()`, application entry point function, which
    demonstrates how to use the `Server` class. Because the source code and the purpose
    of the `Server` class and the `main()` entry point function are identical to those
    of the corresponding components defined in the recipe from [Chapter 4](ch04.html
    "Chapter 4. Implementing Server Applications"), *Implementing Server Applications*,
    that we took as a base for this recipe, we will not discuss them here. We will
    only consider the `Service` and `Acceptor` classes that were updated to provide
    support for SSL/TLS protocol.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 示例服务器应用程序由四个组件组成：`Service`、`Acceptor`和`Server`类以及`main()`应用程序入口点函数，它演示了如何使用`Server`类。由于`Server`类和`main()`入口点函数的源代码和目的与我们在[第4章](ch04.html
    "第4章. 实现服务器应用程序")中定义的相应组件相同，该组件是我们为这个配方所采用的基，我们在这里将不讨论它们。我们只考虑更新以支持SSL/TLS协议的`Service`和`Acceptor`类。
- en: The Service class
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务类
- en: The `Service` class is the key functional component in the application. While
    other components are infrastructural in their purpose, this class implements the
    actual function (or service) required by the clients.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`Service`类是应用程序中的关键功能组件。虽然其他组件在其目的上是基础设施性的，但这个类实现了客户端所需的实际功能（或服务）。'
- en: The `Service` class is quite simple and consists of a single method `handle_client()`.
    As its input argument, this method accepts a reference to an object representing
    an SSL stream that wraps a TCP socket connected to a particular client.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Service`类相当简单，仅包含一个方法`handle_client()`。作为其输入参数，此方法接受一个表示封装了连接到特定客户端的TCP套接字的SSL流对象的引用。'
- en: The method begins with performing an SSL/TLS **handshake** by invoking the `handshake()`
    method on the `ssl_stream` object. This method is synchronous and does not return
    until the handshake completes or an error occurs.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 方法从通过在`ssl_stream`对象上调用`handshake()`方法执行SSL/TLS **握手**开始。此方法是同步的，直到握手完成或发生错误，它不会返回。
- en: After the handshake has completed, a request message is synchronously read from
    the SSL stream until a new line ASCII symbol `\n` is encountered. Then, the request
    is processed. In our sample application, request processing is trivial and dummy
    and consists in running a loop performing one million increment operations and
    then putting the thread to sleep for half a second. After this, the response message
    is prepared and sent back to the client.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在握手完成之后，从 SSL 流中同步读取一个请求消息，直到遇到新的换行 ASCII 符号 `\n`。然后，处理请求。在我们的示例应用程序中，请求处理非常简单且是模拟的，包括运行一个循环执行一百万次递增操作，然后让线程休眠半秒钟。之后，准备响应消息并发送回客户端。
- en: Exceptions that may be thrown by the Boost.Asio functions and methods are caught
    and handled in the `handle_client()` method and are not propagated to the method's
    caller so that, if handling of one client fails, the server continues working.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Asio 函数和方法可能抛出的异常在 `handle_client()` 方法中被捕获和处理，不会传播到方法的调用者，这样，如果处理一个客户端失败，服务器仍然可以继续工作。
- en: Note that the `handle_client()` method is very similar to the corresponding
    method defined in the recipe *Implementing a synchronous iterative TCP server*,
    from [Chapter 4](ch04.html "Chapter 4. Implementing Server Applications"), *Implementing
    Server Applications*, that we took as a base for this recipe. The difference consists
    in the fact that in this recipe, the `handle_client()` method operates on an object
    representing an SSL stream as opposed to an object representing a TCP socket being
    operated on in the base implementation of the method. Besides, an additional operation—an
    SSL/TLS handshake—is performed in the method defined in this recipe.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`handle_client()` 方法与我们在本章作为此菜谱基础的 [第 4 章](ch04.html "第 4 章。实现服务器应用程序") 中定义的
    *实现一个同步迭代 TCP 服务器* 菜谱中定义的相应方法非常相似。不同之处在于，在这个菜谱中，`handle_client()` 方法操作一个代表 SSL
    流的对象，而不是在方法的基本实现中操作代表 TCP 套接字的对象。此外，在这个菜谱中定义的方法还执行了一个额外的操作——SSL/TLS 握手。
- en: The Acceptor class
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接受者类
- en: The `Acceptor` class is a part of the server application infrastructure. Each
    object of this class owns an instance of the `asio::ssl::context` class named
    `m_ssl_context`. This member represents an **SSL context**. Basically, the `asio::ssl::contex`
    class is a wrapper around the `SSL_CTX` data structure defined by OpenSSL library.
    Objects of this class contain global settings and parameters used by other objects
    and functions involved in the process of communication using SSL/TLS protocol.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`Acceptor` 类是服务器应用程序基础设施的一部分。这个类的每个对象都拥有一个名为 `m_ssl_context` 的 `asio::ssl::context`
    类的实例。这个成员代表一个 **SSL 上下文**。基本上，`asio::ssl::context` 类是 OpenSSL 库中定义的 `SSL_CTX`
    数据结构的包装器。这个类的对象包含用于 SSL/TLS 协议通信过程中其他对象和函数的全局设置和参数。'
- en: The `m_ssl_context` object, when instantiated, is passed a `asio::ssl::context::sslv23_server`
    value to its constructor to designate that the SSL context will be used by the
    application playing a role of a *server* only and that multiple secure protocols
    should be supported, including multiple versions of SSL and TLS. This value defined
    by Boost.Asio corresponds to a value representing a connection method returned
    by the `SSLv23_server_method()` function defined by OpenSSL library.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `m_ssl_context` 对象被实例化时，其构造函数传入一个 `asio::ssl::context::sslv23_server` 值，以指定
    SSL 上下文仅由充当 *服务器* 角色的应用程序使用，并且应该支持多个安全协议，包括 SSL 和 TLS 的多个版本。这个由 Boost.Asio 定义的值对应于
    OpenSSL 库中定义的 `SSLv23_server_method()` 函数返回的连接方法值。
- en: The SSL context is configured in the `Acceptor` class' constructor. The context
    options, password callback and files containing digital certificates, and private
    keys and Diffie-Hellman protocol parameters, are specified there.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: SSL 上下文在 `Acceptor` 类的构造函数中进行配置。上下文选项、密码回调以及包含数字证书、私钥和 Diffie-Hellman 协议参数的文件都在那里指定。
- en: After SSL context has been configured, the `listen()` method is called on the
    acceptor object in the `Acceptor` class' constructor to start listening for connection
    requests from the clients.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置 SSL 上下文之后，在 `Acceptor` 类的构造函数中调用 `listen()` 方法，以便开始监听来自客户端的连接请求。
- en: The `Acceptor` class exposes a single `accept()` public method. This method,
    when called, first instantiates an object of the `asio::ssl::stream<asio::ip::tcp::socket>`
    class named `ssl_stream`, representing an SSL/TLS communication channel with the
    underlying TCP socket. Then, the `accept()` method is called on the `m_acceptor`
    acceptor object to accept a connection. The TCP socket object owned by `ssl_stream`,
    returned by its `lowest_layer()` method, is passed to the `accept()` method as
    an input argument. When a new connection is established, an instance of the `Service`
    class is created and its `handle_client()` method is called, which performs communication
    with the client and request handling.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`Acceptor` 类公开了一个单一的 `accept()` 公共方法。当调用此方法时，首先实例化一个名为 `ssl_stream` 的 `asio::ssl::stream<asio::ip::tcp::socket>`
    类的对象，代表与底层 TCP 套接字的 SSL/TLS 通信通道。然后，在 `m_acceptor` 接收器对象上调用 `accept()` 方法以接受一个连接。`ssl_stream`
    的 `lowest_layer()` 方法返回的拥有 TCP 套接字的对象作为输入参数传递给 `accept()` 方法。当建立新的连接时，创建 `Service`
    类的一个实例，并调用其 `handle_client()` 方法，该方法执行与客户端的通信和请求处理。'
- en: See also
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Implementing synchronous iterative TCP server* recipe from [Chapter 4](ch04.html
    "Chapter 4. Implementing Server Applications"), *Implementing Server Applications*,
    provides more information on how to implement a synchronous TCP server used as
    a base for this recipe.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 [第 4 章](ch04.html "第 4 章。实现服务器应用程序") 的 *实现同步迭代 TCP 服务器* 菜谱，*实现服务器应用程序*，提供了更多关于如何实现作为本菜谱基础的同步
    TCP 服务器的信息。
