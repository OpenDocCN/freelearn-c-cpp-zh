- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Logging and Debugging Asynchronous Software
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步软件的日志和调试
- en: There is no way to ensure that a software product is free from bugs, so from
    time to time, bugs can appear. This is when logging and debugging are indispensable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 没有办法确保软件产品完全没有错误，所以有时会出现错误。这时，日志和调试是必不可少的。
- en: Logging and debugging are essential for identifying and diagnosing issues in
    software systems. They provide visibility into the runtime behavior of code, helping
    developers trace errors, monitor performance, and understand the flow of execution.
    By using logging and debugging effectively, developers can detect bugs, resolve
    unexpected behavior, and improve overall system stability and maintainability.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 日志和调试对于识别和诊断软件系统中的问题至关重要。它们提供了对代码运行时行为的可见性，帮助开发者追踪错误、监控性能以及理解执行流程。通过有效地使用日志和调试，开发者可以检测到错误、解决意外行为，并提高整体系统的稳定性和可维护性。
- en: While writing this chapter, we assume you are already familiar with using a
    debugger to debug C++ programs and know some basic debugger commands and terminology,
    such as breakpoints, watchers, frames, or stack traces. To brush up on that knowledge,
    you can refer to the references provided in the *Further reading* section at the
    end of the chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本章时，我们假设你已经熟悉使用调试器调试C++程序，并了解一些基本的调试器命令和术语，例如断点、监视器、帧或堆栈跟踪。为了复习这些知识，你可以参考章节末尾的*进一步阅读*部分提供的参考资料。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: How to use logging to spot bugs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用日志来查找错误
- en: How to debug asynchronous software
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何调试异步软件
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we will need to install third-party libraries to compile examples.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们需要安装第三方库来编译示例。
- en: The **spdlog** and **{fmt}** libraries need to be installed to compile the example
    in the logging section. Please check their documentation ( **spdlog** ’s documentation
    is available at [https://github.com/gabime/spdlog](https://github.com/gabime/spdlog)
    and **{fmt}** ’s documentation is available at [https://github.com/fmtlib/fmt](https://github.com/fmtlib/fmt)
    ) and follow the installation steps suitable for your platform.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译日志部分中的示例，需要安装**spdlog**和**{fmt}**库。请检查它们的文档（**spdlog**的文档可在[https://github.com/gabime/spdlog](https://github.com/gabime/spdlog)找到，**{fmt}**的文档可在[https://github.com/fmtlib/fmt](https://github.com/fmtlib/fmt)找到），并按照适合您平台的安装步骤进行操作。
- en: Some examples need a compiler supporting C++20. Therefore, check the technical
    requirements section in [*Chapter 3*](B22219_03.xhtml#_idTextAnchor051) , which
    has some guidance on how to install GCC 13 and Clang 8 compilers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例需要支持C++20的编译器。因此，请检查[*第3章*](B22219_03.xhtml#_idTextAnchor051)中的技术要求部分，其中提供了一些关于如何安装GCC
    13和Clang 8编译器的指导。
- en: 'You can find all the complete code in the following GitHub repository:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下GitHub仓库中找到所有完整的代码：
- en: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
- en: 'The examples for this chapter are located under the **Chapter_11** folder.
    All source code files can be compiled using CMake as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例位于**Chapter_11**文件夹下。所有源代码文件都可以使用以下命令使用CMake编译：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Executable binaries will be generated under the **bin** directory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行二进制文件将在**bin**目录下生成。
- en: How to use logging to spot bugs
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用日志来查找错误
- en: Let’s start with a trivial but useful method for understanding what a software
    program does while executing – logging.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从理解软件程序在执行时做了什么的简单但有用方法开始——日志。
- en: '**Logging** is the process of keeping a log of events that occur in a program,
    storing information by using messages to record how a program executes, tracking
    its flow, and helping with identifying issues and bugs.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志**是记录程序中发生的事件的过程，通过使用消息记录程序如何执行，跟踪其流程，并帮助识别问题和错误。'
- en: Most Unix-based logging systems use the standard protocol, **syslog** , created
    by Eric Altman back in 1980 as part of the Sendmail project. This standard protocol
    defines the boundaries between the software generating the log messages, the system
    storing them, and the software reporting and analyzing these log events.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于Unix的日志系统使用由Eric Altman在1980年作为Sendmail项目一部分创建的标准协议**syslog**。这个标准协议定义了生成日志消息的软件、存储它们的系统和报告和分析这些日志事件的软件之间的边界。
- en: Each log message includes a facility code and a severity level. The facility
    code identifies the type of system that originated a specific log message (user-level,
    kernel, system, network, etc.), and the severity level describes the condition
    of the system, indicating the urgency of dealing with a specific issue, the severity
    levels being emergency, alert, critical, error, warning, notice, info, and debug.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每条日志消息都包含一个设施代码和严重级别。设施代码标识了产生特定日志消息的系统类型（用户级、内核、系统、网络等），严重级别描述了系统的状态，表明处理特定问题的紧迫性，严重级别包括紧急、警报、关键、错误、警告、通知、信息和调试。
- en: 'Most logging systems or loggers provide various destinations or sinks for log
    messages: console, files that can later be opened and analyzed, remote syslog
    servers, or relays, among other destinations.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数日志系统或日志记录器都提供了各种日志消息的目的地或接收器：控制台、可以稍后打开和分析的文件、远程syslog服务器或中继，以及其他目的地。
- en: Logging is useful where debuggers are not, as we will see later, especially
    in distributed, multithreaded, real-time, scientific, or event-centric applications,
    where inspecting data or following the program flow using the debugger can become
    a tedious task.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试器无法使用的地方，日志非常有用，正如我们稍后将看到的，特别是在分布式、多线程、实时、科学或以事件为中心的应用程序中，使用调试器检查数据或跟踪程序流程可能变得是一项繁琐的任务。
- en: Logging libraries usually also provide a thread-safe singleton class that allows
    multithreading and asynchronous writing to log files, helps with log rotation,
    avoids large log files by creating new ones on the fly without losing log events,
    and time stamping, for better tracking when a log event happens.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 日志库通常还提供一个线程安全的单例类，允许多线程和异步写入日志文件，有助于日志轮转，通过动态创建新文件而不丢失日志事件来避免大型日志文件，并添加时间戳，以便更好地跟踪日志事件发生的时间。
- en: Instead of implementing our own multithreaded logging system, a better approach
    is to use some well-tested and documented production-ready libraries.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是实现我们自己的多线程日志系统，更好的方法是使用一些经过良好测试和文档化的生产就绪库。
- en: How to select a third-party library
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何选择第三方库
- en: 'When selecting a logging library (or any other library), we need to investigate
    the following points before integrating it into our software to avoid future issues:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在将日志库（或任何其他库）集成到我们的软件之前，我们需要调查以下问题，以避免未来出现的问题：
- en: '**Support** : Is the library updated and upgraded regularly? Is there a community
    or active ecosystem around the library that can help with any questions that can
    arise? Is the community happy using the library?'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持**：库是否定期更新和升级？是否有社区或活跃的生态系统围绕该库，可以帮助解决可能出现的任何问题？社区是否对使用该库感到满意？'
- en: '**Quality** : Is there a public bugs report system? Are bug reports dealt with
    promptly, providing solutions and fixing bugs in the library? Does it support
    recent compiler versions and support latest C++ features?'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量**：是否存在公开的缺陷报告系统？缺陷报告是否得到及时处理，提供解决方案并修复库中的缺陷？它是否支持最近的编译器版本并支持最新的C++特性？'
- en: '**Security** : Does the library, or any of its dependent libraries, have any
    vulnerabilities reported?'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：库或其任何依赖库是否有已报告的漏洞？'
- en: '**License** : Is the library license aligned with our development and product
    needs? Is the cost affordable?'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**许可证**：库的许可证是否与我们的开发和产品需求一致？成本是否可承受？'
- en: For complex systems, it may be worth considering centralized systems to collect
    and generate logging reports or dashboards, such as **Sentry** ( [https://sentry.io](https://sentry.io)
    ) or **Logstash** ( [https://www.elastic.co/logstash](https://www.elastic.co/logstash)
    ), that can collect, parse, and transform logs, and can be integrated with other
    tools, such as **Graylog** (https://graylog.org), **Grafana** (https://grafana.com),
    or **Kibana** ( https://www.elastic.co/kibana ).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂系统，考虑集中式系统来收集和生成日志报告或仪表板可能是值得的，例如 **Sentry** ([https://sentry.io](https://sentry.io))
    或 **Logstash** ([https://www.elastic.co/logstash](https://www.elastic.co/logstash))，它们可以收集、解析和转换日志，并且可以与其他工具集成，如
    **Graylog** ([https://graylog.org](https://graylog.org))、**Grafana** ([https://grafana.com](https://grafana.com))
    或 **Kibana** ([https://www.elastic.co/kibana](https://www.elastic.co/kibana))。
- en: The next section describes some interesting logging libraries.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将描述一些有趣的日志库。
- en: Some relevant logging libraries
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些相关的日志库
- en: There are many logging libraries in the market, each covering some specific
    software requirements. Depending on the program constraints and needs, one of
    the following libraries might be more suitable than others.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有许多日志库，每个库都覆盖了一些特定的软件需求。根据程序约束和需求，以下库中的一些可能比其他库更适合。
- en: In [*Chapter 9*](B22219_09.xhtml#_idTextAnchor184) , we explored **Boost.Asio**
    . Boost also provides another library, **Boost.Log** ( [https://github.com/boostorg/log](https://github.com/boostorg/log)
    ), a powerful and configurable logging library.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 9 章*](B22219_09.xhtml#_idTextAnchor184) 中，我们探讨了 **Boost.Asio**。Boost 还提供了另一个库，**Boost.Log**（[https://github.com/boostorg/log](https://github.com/boostorg/log)），这是一个强大且可配置的日志库。
- en: Google also provides many open source libraries, including **glog** , the Google
    logging library ( [https://github.com/google/glog](https://github.com/google/glog)
    ), which is a C++14 library that provides C++-style streams APIs and helper macros.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Google 也提供了许多开源库，包括 **glog**，Google 日志库（[https://github.com/google/glog](https://github.com/google/glog)），这是一个
    C++14 库，提供了 C++ 风格的流 API 和辅助宏。
- en: If the developer is familiar with Java, an excellent choice could be Apache
    **Log4cxx** ( [https://logging.apache.org/log4cxx](https://logging.apache.org/log4cxx)
    ), based on **Log4j** ( [https://logging.apache.org/log4j](https://logging.apache.org/log4j)
    ), a versatile, industrial-grade, Java logging framework.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者熟悉 Java，一个不错的选择可能是基于 **Log4j**（[https://logging.apache.org/log4j](https://logging.apache.org/log4j)）的
    Apache **Log4cxx**（[https://logging.apache.org/log4cxx](https://logging.apache.org/log4cxx)），这是一个多才多艺、工业级、Java
    日志框架。
- en: 'Other logging libraries worth considering are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 值得考虑的其他日志库如下：
- en: '**spdlog** ( [https://github.com/gabime/spdlog](https://github.com/gabime/spdlog)
    ) is an interesting logging library that we can use with the **{fmt}** library.
    Also, the program can start logging messages and queuing them since startup, even
    before the log output file name is specified.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**spdlog**（[https://github.com/gabime/spdlog](https://github.com/gabime/spdlog)）是一个有趣的日志库，我们可以与
    **{fmt}** 库一起使用。此外，程序可以从启动时开始记录消息并将它们排队，甚至在指定日志输出文件名之前。'
- en: '**Quill** (https://github.com/odygrd/quill) is an asynchronous low-latency
    C++ logging library.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Quill**（[https://github.com/odygrd/quill](https://github.com/odygrd/quill)）是一个异步低延迟的
    C++ 日志库。'
- en: '**NanoLog** (https://github.com/PlatformLab/NanoLog) is a nanosecond scale
    logging system with **printf** -like APIs.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NanoLog**（[https://github.com/PlatformLab/NanoLog](https://github.com/PlatformLab/NanoLog)）是一个具有类似
    **printf** API 的纳秒级日志系统。'
- en: '**lwlog** (https://github.com/ChristianPanov/lwlog) is an amazingly fast asynchronous
    C++17 logging library.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**lwlog**（[https://github.com/ChristianPanov/lwlog](https://github.com/ChristianPanov/lwlog)）是一个惊人的快速异步
    C++17 日志库。'
- en: '**XTR** (https://github.com/choll/xtr) is a fast and convenient C++ logging
    library for low-latency and real-time environments.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XTR**（[https://github.com/choll/xtr](https://github.com/choll/xtr)）是一个适用于低延迟和实时环境的快速便捷的
    C++ 日志库。'
- en: '**Reckless** (https://github.com/mattiasflodin/reckless) is a low-latency and
    high-throughput logging library.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reckless**（[https://github.com/mattiasflodin/reckless](https://github.com/mattiasflodin/reckless)）是一个低延迟和高吞吐量的日志库。'
- en: '**uberlog** (https://github.com/IMQS/uberlog) is a cross-platform and multi-process
    C++ logging system.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**uberlog**（[https://github.com/IMQS/uberlog](https://github.com/IMQS/uberlog)）是一个跨平台和多进程的
    C++ 日志系统。'
- en: '**Easylogging++** (https://github.com/abumq/easyloggingpp) is a single-header
    C++ logging library with the ability to write our own sinks and track performance.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Easylogging++**（[https://github.com/abumq/easyloggingpp](https://github.com/abumq/easyloggingpp)）是一个单头文件
    C++ 日志库，具有编写自定义存储和跟踪性能的能力。'
- en: '**tracetool** (https://github.com/froglogic/tracetool) is a logging and tracing
    shared library.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tracetool**（[https://github.com/froglogic/tracetool](https://github.com/froglogic/tracetool)）是一个日志和跟踪共享库。'
- en: 'As a guideline, depending on the system to develop, we might choose one of
    the following libraries:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为指导，根据要开发的系统，我们可能会选择以下库之一：
- en: '**For low-latency or real-time systems** : Quill, XTR, or Reckless'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于低延迟或实时系统**：Quill、XTR 或 Reckless'
- en: '**For high performance at nanosecond scale** **logging** : NanoLog'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于纳秒级性能的日志**：NanoLog'
- en: '**For asynchronous logging** : Quill or **lwlog**'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于异步日志**：Quill 或 **lwlog**'
- en: '**For cross-platform, multi-process** **applications** : **uberlog**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于跨平台、多进程 **应用程序**：**uberlog**'
- en: '**For simple and flexible logging** : Easylogging++ or glog'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于简单灵活的日志**：Easylogging++ 或 glog'
- en: '**For familiarity with Java** **logging** : Log4cxx'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于熟悉 Java **日志**：Log4cxx'
- en: 'All libraries have advantages but also disadvantages that need to be investigated
    prior to selecting a library to include in your system. The following table summarizes
    these points:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有库都有优点，但也存在需要在使用前调查的缺点。以下表格总结了这些要点：
- en: '| **Library** | **Advantages** | **Disadvantages** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **库** | **优点** | **缺点** |'
- en: '| --- | --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **spdlog** | Easy integration, performance-focused, customizable | Lacks
    some advanced features for extreme low-latency needs |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **spdlog** | 简单集成，性能导向，可定制 | 缺乏一些针对极低延迟需求的高级功能 |'
- en: '| Quill | High performance in low-latency systems | More complex setup compared
    to simpler, synchronous loggers |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| Quill | 在低延迟系统中性能高 | 相比于更简单的同步日志记录器，设置更复杂 |'
- en: '| NanoLog | Best in class for speed, optimized for performance | Limited in
    features; suited for specialized use cases |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| NanoLog | 在速度上表现最佳，针对性能优化 | 功能有限；适用于专用用例 |'
- en: '| **lwlog** | Lightweight, good for quick integration | Less mature and feature-rich
    than alternatives |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **lwlog** | 轻量级，适合快速集成 | 相比于其他替代方案，成熟度和功能较少 |'
- en: '| XTR | Very efficient, user-friendly interface | More suited for specific
    real-time applications |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| XTR | 非常高效，用户界面友好 | 更适合特定的实时应用 |'
- en: '| Reckless | Highly optimized for throughput and low latency | Limited flexibility
    compared to more general-purpose loggers |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| Reckless | 高度优化吞吐量和低延迟 | 相比于更通用的日志记录器，灵活性有限 |'
- en: '| **uberlog** | Great for multi-process and distributed systems | Not as fast
    as specialized low-latency loggers |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **uberlog** | 适用于多进程和分布式系统 | 不如专门的低延迟日志记录器快 |'
- en: '| Easylogging++ | Easy to use, customizable output sinks | Less performance-optimized
    than some other libraries |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| Easylogging++ | 使用简单，可自定义输出目标 | 性能优化不如一些其他库 |'
- en: '| **tracetool** | Combines logging and tracing in one library | Not focused
    on low-latency or high-throughput |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **tracetool** | 将日志和跟踪结合在一个库中 | 不专注于低延迟或高吞吐量 |'
- en: '| Boost.Log | Versatile, integrates well with Boost libraries | Higher complexity;
    can be overkill for simple logging needs |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| Boost.Log | 通用性强，与 Boost 库集成良好 | 复杂度较高；对于简单的日志需求可能过于复杂 |'
- en: '| glog | Simple to use, good for projects requiring easy APIs | Not as feature-rich
    for advanced customization |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| glog | 使用简单，适合需要简单 API 的项目 | 对于高级定制功能不如其他库丰富 |'
- en: '| Log4cxx | Robust, time-tested, industrial-strength logging | More complex
    to set up, especially for smaller projects |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| Log4cxx | 稳定，经过时间考验，工业级日志 | 设置较为复杂，特别是对于小型项目 |'
- en: 'Table 11.1: Advantages and disadvantages of various libraries'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1：各种库的优点和缺点
- en: Please visit the logging libraries’ websites to understand better what features
    they provide and compare performance between them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问日志库的网站以更好地了解它们提供的功能，并比较它们之间的性能。
- en: As **spdlog** is the most forked and starred C++ logging library repository
    in GitHub, in the next section, we will implement an example of using this library
    to catch a race condition.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **spdlog** 是 GitHub 上被分叉和星标最多的 C++ 日志库仓库，在下一节中，我们将实现一个使用此库来捕获竞态条件的示例。
- en: Logging a deadlock – an example
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录死锁 - 示例
- en: Before implementing this example, we need to install the **spdlog** and **{fmt}**
    libraries. **{fmt}** (https://github.com/fmtlib/fmt) is an open source formatting
    library providing a fast and safe alternative to C++ IOStreams.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现此示例之前，我们需要安装 **spdlog** 和 **{fmt}** 库。**{fmt}** (https://github.com/fmtlib/fmt)
    是一个开源格式化库，提供了一种快速且安全的 C++ IOStreams 替代方案。
- en: Please check their documentation and follow the installation steps depending
    on your platform.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请检查它们的文档，并根据您的平台遵循安装步骤。
- en: Let’s implement an example where a deadlock is happening. As we learned in [*Chapter
    4*](B22219_04.xhtml#_idTextAnchor074) , a deadlock can happen when two or more
    threads need to acquire more than one mutex to perform their work. If mutexes
    are not acquired in the same order, a thread can acquire a mutex and wait forever
    for another mutex acquired by another thread.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个发生死锁的示例。正如我们在 [*第 4 章*](B22219_04.xhtml#_idTextAnchor074) 中所学，当两个或更多线程需要获取多个互斥锁以执行其工作时会发生死锁。如果互斥锁不是以相同的顺序获取，一个线程可以获取一个互斥锁并永远等待另一个线程获取的互斥锁。
- en: In this example, two threads need to acquire two mutexes, **mtx1** and **mtx2**
    , to increase the value of the **counter1** and **counter2** counters and swap
    their values. As the mutexes are acquired in different order by the threads, a
    deadlock can happen.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，两个线程需要获取两个互斥锁，**mtx1** 和 **mtx2**，以增加 **counter1** 和 **counter2** 计数器的值并交换它们。由于线程以不同的顺序获取互斥锁，可能会发生死锁。
- en: 'Let’s start by including the required libraries:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先包含所需的库：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the **main()** function, we define the counters and mutexes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **main()** 函数中，我们定义了计数器和互斥锁：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Before spawning the threads, let’s set up a **multi-sink logger** , a logger
    that can write log messages into the console and a log file simultaneously. We
    will also set up its log level to debug, making the logger publish all log messages
    with a severity level greater than debug, and the format for each log line consisting
    of the timestamp, the thread identifier, the log level, and the log message:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成线程之前，让我们设置一个**多目标记录器**，这是一种可以将日志消息写入控制台和日志文件的记录器。我们还将设置其日志级别为调试，使记录器发布所有严重性级别大于调试的日志消息，每行日志的格式包括时间戳、线程标识符、日志级别和日志消息：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also declare an **increase_and_swap** lambda function that increases the
    values of both counters and swaps them:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了一个**increase_and_swap** lambda 函数，该函数增加两个计数器的值并交换它们：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Two worker lambda functions, **worker1** and **worker2** , acquire both mutexes
    and call **increase_and_swap()** before exiting. As lock guard ( **std::lock_guard**
    ) objects are used, the mutexes are released when leaving the worker lambda functions
    during their destruction:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 两个工作 lambda 函数**worker1**和**worker2**获取两个互斥锁，并在退出前调用**increase_and_swap()**。由于使用了锁保护（**std::lock_guard**）对象，因此在销毁工作
    lambda 函数时释放互斥锁：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Both worker lambda functions are similar but with a small difference: **worker1**
    acquires **mutex1** and then **mutex2** , and **worker2** follows the opposite
    order, first acquiring **mutex2** and then **mutex1** . There is a sleep period
    between both mutexes’ acquisition to let the other thread acquire its mutex, therefore,
    provoking a deadlock as **worker1** will acquire **mutex1** and **worker2** will
    acquire **mutex2** .'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 两个工作 lambda 函数**worker1**和**worker2**相似，但有一个小差异：**worker1**先获取**mutex1**然后获取**mutex2**，而**worker2**则相反，先获取**mutex2**然后获取**mutex1**。在获取两个互斥锁之间有一个睡眠期，以便其他线程获取其互斥锁，因此，这会导致死锁，因为**worker1**将获取**mutex1**而**worker2**将获取**mutex2**。
- en: Then, after sleeping, **worker1** will try to acquire **mutex2** and **worker2**
    will try the same with **mutex1** , but none of them will succeed, blocking forever
    in a deadlock.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在睡眠之后，**worker1**将尝试获取**mutex2**，而**worker2**将尝试获取**mutex1**，但它们都不会成功，永远在死锁中阻塞。
- en: 'The following is the output when running this code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在运行此代码时的输出：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first symptom to note when inspecting the logs is that the program never
    finishes and therefore probably is deadlocked.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查日志时，首先要注意的症状是程序从未完成，因此很可能处于死锁状态。
- en: From the logger output, we can see that **t1** (thread **38985** ) is running
    **worker1** and **t2** (thread **38986** ) is running **worker2** . As soon as
    **t1** enters **worker1** , it acquires **mtx1** . The **mtx2** mutex is acquired
    by **t2** though, as soon as **worker2** starts. Then, both threads wait for 100
    ms and try to acquire the other mutex, but none succeed, and the program remains
    blocked.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从记录器输出中，我们可以看到**t1**（线程**38985**）正在运行**worker1**，而**t2**（线程**38986**）正在运行**worker2**。一旦**t1**进入**worker1**，它就获取**mtx1**。然而，**mtx2**互斥锁是由**t2**获取的，因为**worker2**一启动就获取了。然后，两个线程等待100毫秒并尝试获取另一个互斥锁，但都没有成功，程序保持阻塞。
- en: Logging is indispensable in production systems but imposes some performance
    penalty if abused, and most of the time requires human intervention to investigate
    an issue. As a compromise between log verbosity and performance penalty, one might
    choose to implement different logging levels and log only major events during
    normal operation, while still retaining the ability to provide extremely detailed
    logs if opted for, when the situation needs it. A more automated way to detect
    errors in code early in the development cycle is by using testing and code sanitizers,
    which we will learn about in the next chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 记录在生产系统中是必不可少的，但如果过度使用，则会对性能造成一些惩罚，并且大多数时候需要人工干预来调查问题。作为日志详细程度和性能惩罚之间的折衷方案，一个人可能会选择实现不同的日志级别，在正常操作期间仅记录主要事件，同时仍然保留在需要时提供极其详细日志的能力。在开发周期早期自动检测代码中的错误的一种更自动化的方法是使用测试和代码清理器，我们将在下一章中学习这些内容。
- en: Not all bugs can be detected, so usually using a debugger is the way to track
    down and fix bugs in software. Let’s learn next how to debug multithreading and
    asynchronous code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有错误都可以检测到，因此通常使用调试器是跟踪和修复软件中的错误的方法。让我们接下来学习如何调试多线程和异步代码。
- en: How to debug asynchronous software
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何调试异步软件
- en: '**Debugging** is the process of finding and fixing errors in computer programs.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试**是查找和修复计算机程序中的错误的过程。'
- en: In this section, we will explore several techniques to debug multithreading
    and asynchronous software. You must have some previous knowledge of how to use
    debuggers, such as **GDB** (the GNU project debugger) or **LLDB** (the LLVM low-level
    debugger), and the terminology of the debugging process, such as breakpoints,
    watchers, backtraces, frames, and crash reports.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨几种调试多线程和异步软件的技术。您必须具备一些使用调试器的先验知识，例如 **GDB**（GNU 项目调试器）或 **LLDB**（LLVM
    低位调试器），以及调试过程的术语，如断点、观察者、回溯、帧和崩溃报告。
- en: Both GDB and LLDB are excellent debuggers with most of their commands being
    the same and only a few ones that differ. LLDB might be preferred if the program
    is being debugged on macOS or for large code bases. On the other hand, GDB has
    an established legacy, being familiar to many developers, and supporting a broader
    range of architectures and platforms. In this section, we will use GDB 15.1 just
    because it is part of the GNU framework and was designed to work alongside the
    **g++** compiler, but most commands shown later can also be used with LLDB when
    debugging programs compiled with **clang++** .
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 和 LLDB 都是优秀的调试器，它们的大多数命令都是相同的，只有少数命令不同。如果程序是在 macOS 上调试或针对大型代码库，LLDB 可能更受欢迎。另一方面，GDB
    拥有稳定的传统，许多开发者都熟悉它，并支持更广泛的架构和平台。在本节中，我们将使用 GDB 15.1，因为它属于 GNU 框架，并且被设计为与 **g++**
    编译器协同工作，但随后显示的大多数命令也可以在用 **clang++** 编译的程序上使用 LLDB 进行调试。
- en: As some debugger features that deal with multithreading and asynchronous code
    are still in development, always update the debuggers to the latest versions to
    include up-to-date features and fixes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一些处理多线程和异步代码的调试器功能仍在开发中，请始终更新调试器到最新版本，以包括最新的功能和修复。
- en: Some useful GDB commands
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些有用的 GDB 命令
- en: Let’s start with some GDB commands that are useful when debugging any kind of
    program and acquire a foundation for the next sections.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些在调试任何类型程序时都很有用的 GDB 命令开始，并为下一节打下基础。
- en: 'When debugging a program, we can start the debugger and pass the program as
    an argument. Extra arguments that the program might need can be passed with the
    **--** **args** option:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试程序时，我们可以启动调试器并将程序作为参数传递。程序可能需要的额外参数可以通过 **--** **args** 选项传递：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or, we can attach the debugger to a running program by using its **process**
    **identifier** ( **PID** ):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过使用其 **进程** **标识符**（**PID**）来将调试器附加到正在运行的程序：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once inside the debugger, we can run the program (with the **run** command)
    or start it (with the **start** command). Running means that the program executes
    until reaching a breakpoint or finishing. **start** just places a temporary breakpoint
    at the beginning of the **main()** function and runs the program, stopping the
    execution at the beginning of the program.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入调试器，我们可以运行程序（使用 **run** 命令）或启动它（使用 **start** 命令）。运行意味着程序执行直到达到断点或完成。**start**
    仅在 **main()** 函数的开始处放置一个临时断点并运行程序，在程序开始处停止执行。
- en: If, for instance, we want to debug a program that has already crashed, we can
    use the core dump file that the crash generated, which might be stored in a specific
    location in the system (usually **/var/lib/apport/coredump/** on Linux systems,
    but please check for the exact location in your system by visiting the official
    documentation). Also, note that typically, core dumps are disabled by default,
    requiring the **ulimit -c unlimited** command to be run prior to, and in the same
    shell as, the program crashing. The **unlimited** argument can be changed to some
    arbitrary limit if we are dealing with an exceptionally large program or the system
    is short on disk space.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想调试已经崩溃的程序，我们可以使用由崩溃生成的 core dump 文件，该文件可能存储在系统中的特定位置（通常在 Linux 系统上是
    **/var/lib/apport/coredump/**，但请通过访问官方文档来检查您系统中的确切位置）。此外，请注意，通常 core dump 默认是禁用的，需要运行
    **ulimit -c unlimited** 命令，在程序崩溃之前和同一 shell 中执行。如果处理的是特别大的程序或系统磁盘空间不足，可以将 **unlimited**
    参数更改为某个任意限制。
- en: 'After the **coredump** file is generated, just copy it to the location where
    the program binary is located and use the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成 **coredump** 文件后，只需将其复制到程序二进制文件所在的目录，并使用以下命令：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that all binaries must have debugging symbols, thus compiled with the **–g**
    option. In production systems, release binaries usually have symbols stripped
    and stored in separate files. There are GDB commands to include those symbols
    and command-line tools to inspect them, but this topic is beyond the scope of
    this book.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有二进制文件都必须有调试符号，因此必须使用**–g**选项编译。在生产系统中，发布二进制文件通常移除了符号并存储在单独的文件中。有GDB命令可以包含这些符号，以及命令行工具可以检查它们，但这个主题超出了本书的范围。
- en: 'Once the debugger starts, we can use GDB commands to navigate through the code
    or check variables. Some useful commands are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调试器开始运行，我们可以使用GDB命令在代码中导航或检查变量。一些有用的命令如下：
- en: '**info args** : This shows information about arguments used to call the current
    function.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**info args**：这会显示用于调用当前函数的参数信息。'
- en: '**info locals** : This shows local variables in the current scope.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**info locals**：这会显示当前作用域中的局部变量。'
- en: '**whatis** : This shows the type of the given variable or expression.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**whatis**：这会显示给定变量或表达式的类型。'
- en: '**return** : This returns from the current function without executing the rest
    of the instructions. A return value can be specified.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**return**：这会从当前函数返回，而不执行其余的指令。可以指定返回值。'
- en: '**backtrace** : This lists all stack frames in the current call stack.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**backtrace**：这会列出当前调用栈中的所有栈帧。'
- en: '**frame** : This lets you change to a specific stack frame.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**frame**：这允许你切换到特定的栈帧。'
- en: '**up** , **down** : This moves across the call stack, toward the caller ( **up**
    ) or the callee ( **down** ) of the current function.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**up**，**down**：这会在调用栈中移动，向当前函数的调用者（**up**）或被调用者（**down**）移动。'
- en: '**print** : This evaluates and displays the value of an expression, being that
    expression a variable name, a class member, a pointer to a memory region, or directly
    a memory address. We can also define pretty printers to display our own classes.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**print**：这会评估并显示一个表达式的值，该表达式可以是变量名、类成员、指向内存区域的指针或直接是内存地址。我们还可以定义漂亮的打印器来显示我们自己的类。'
- en: Let’s finish this section with one of the most basic but also used techniques
    for debugging programs. This technique is called **printf** . Every developer
    has used **printf** or alternative commands to print the content of variables
    along the code path to show their contents in strategic code locations. In GDB,
    the **dprintf** command helps to set **printf** -style breakpoints that print
    information when those breakpoints are hit but without stopping the program execution.
    This way, we can use print statements when debugging a program without the need
    for code modifications, recompilation, and program restarts.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以调试程序最基本但也是最常用的技术之一来结束本节。这种技术被称为**printf**。每个开发者都使用过**printf**或替代命令来打印变量内容，以便在代码路径上的战略位置显示其内容。在GDB中，**dprintf**命令有助于设置在遇到断点时打印信息的**printf**样式断点，而不会停止程序执行。这样，我们可以在调试程序时使用打印语句，而无需修改代码、重新编译和重启程序。
- en: 'Its syntax is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 其语法如下：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For example, if we want to set a **printf** statement at line 25 to print the
    content of the **x** variable but only if its value is greater than **5** , this
    is the command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在第25行设置一个**printf**语句来打印**x**变量的内容，但只有当其值大于**5**时，这是命令：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have some foundations, let’s start by debugging a multithreaded
    program.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一些基础，让我们从调试一个多线程程序开始。
- en: Debugging multithreaded programs
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试多线程程序
- en: 'The example shown here will never finish as a deadlock will happen as two mutexes
    are locked in a different order by different threads, as already explained earlier
    in this chapter when introducing logging:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的示例永远不会结束，因为会发生死锁，因为不同的线程以不同的顺序锁定两个互斥锁，正如在本章介绍日志时已经解释过的：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, let’s compile this example using **g++** and add debug symbols (the **–g**
    option) and disallow code optimization (the **–O0** option), preventing the compiler
    from restructuring the binary code and making it more difficult for the debugger
    to find and show relevant information by using the **--** **fno-omit-frame-pointer**
    option.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用**g++**编译这个示例，并添加调试符号（**–g**选项）以及不允许代码优化（**–O0**选项），防止编译器重构二进制代码，使调试器更难通过使用**--fno-omit-frame-pointer**选项找到并显示相关信息。
- en: 'The following command compiles the **test.cpp** source file and generates the
    **test** binary. We can also use **clang++** with the same options:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令编译**test.cpp**源文件并生成**test**二进制文件。我们还可以使用**clang++**以相同的选项：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we run the resulting program, this will never finish:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行生成的程序，它将永远不会结束：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To debug a program that is running, let’s first retrieve its PID by using the
    **ps** Unix command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试一个正在运行的程序，我们首先使用 **ps** Unix 命令检索其 PID：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, attach the debugger by providing **pid** and start debugging the program:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过提供 **pid** 来附加调试器并开始调试程序：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Say the debugger starts with the following message:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设调试器以以下消息开始：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, just run the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需运行以下命令：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once GDB starts properly, you will be able to type commands into its prompt.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 GDB 正确启动，你将能够在其提示符中输入命令。
- en: 'The first command we can execute is the next one to check what threads are
    running:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行的第一条命令是下一个，以检查正在运行的线程：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output shows that the **0x79d1f3883740** thread with GDB identifier **1**
    is the current one. If there are many threads and we are only interested in a
    specific subset, let’s say threads 1 and 3, we can show information only for those
    threads by using the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，具有 GDB 标识符 **1** 的 **0x79d1f3883740** 线程是当前线程。如果有许多线程，而我们只对特定的子集感兴趣，比如说线程
    1 和 3，我们可以使用以下命令仅显示那些线程的信息：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running a GDB command will affect the current thread. For example, running
    the **bt** command will show the backtrace for thread 1 ( output simplified):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一个 GDB 命令将影响当前线程。例如，运行 **bt** 命令将显示线程 1 的回溯（输出已简化）：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To switch to another thread, for example, thread 2, we can use the **thread**
    command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换到另一个线程，例如线程 2，我们可以使用 **thread** 命令：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, the **bt** command will show the backtrace for thread 2 ( output simplified):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**bt** 命令将显示线程 2 的回溯（输出已简化）：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To execute a command in different threads, just use the **thread apply** command,
    in this case, executing the **bt** command on threads 1 and 3:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不同的线程中执行命令，只需使用 **thread apply** 命令，在这种情况下，在线程 1 和 3 上执行 **bt** 命令：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To execute a command in all threads, just use **thread apply** **all <command>**
    .
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要在所有线程中执行命令，只需使用 **thread apply** **all <command>** 。
- en: Note that when a breakpoint is reached in a multithreaded program, all threads
    of execution stop running, allowing the examination of the overall state of the
    program. When the execution is restarted by commands such as **continue** , **step**
    , or **next** , all threads resume. The current thread will move one statement
    forward, but that is not guaranteed for other threads, which could move forward
    several statements or even stop in the middle of a statement.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当多线程程序中的断点被达到时，所有执行线程都会停止运行，从而允许检查程序的整体状态。当通过 **continue**、**step** 或 **next**
    等命令重新启动执行时，所有线程将恢复。当前线程将向前移动一个语句，但其他线程向前移动几个语句或甚至在语句中间停止是不确定的。
- en: 'When the execution stops, the debugger will jump and show the context of the
    execution in the current thread. To avoid the debugger jumping between threads
    by locking the scheduler, we can use the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行停止时，调试器将跳转并显示当前线程的执行上下文。为了避免调试器通过锁定调度器在线程之间跳转，我们可以使用以下命令：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also use the following command to check the scheduler locking status:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下命令来检查调度器锁定状态：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that we have learned some new commands for multithreading debugging, let’s
    check what is happening with the application we attached to the debugger.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了一些用于多线程调试的新命令，让我们检查一下我们附加到调试器中的应用程序发生了什么。
- en: 'If we retrieve the backtraces in threads 2 and 3, we can see the following
    (output simplified only showing the relevant parts):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检索线程 2 和 3 的回溯，我们可以看到以下内容（仅输出简化版，仅显示相关部分）：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that, after running **std::mutex::lock()** , both threads are waiting at
    line 13 for thread 3 and at 19 for thread 2, which matches with **std::lock_guard**
    **lock2** in **std::thread** **t1** and **std::lock_guard** **lock1** in **std::thread**
    **t2** , respectively.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在运行 **std::mutex::lock()** 之后，两个线程都在第 13 行等待线程 3，在第 19 行等待线程 2，这与 **std::thread**
    **t1** 中的 **std::lock_guard** **lock2** 和 **std::thread** **t2** 中的 **std::lock_guard**
    **lock1** 相匹配。
- en: Therefore, we detected a deadlock happening in those threads at these code locations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这些代码位置检测到了这些线程中发生的死锁。
- en: Let’s now learn more about debugging multithreaded software by catching a race
    condition.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来学习更多关于通过捕获竞态条件来调试多线程软件的知识。
- en: Debugging race conditions
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试竞态条件
- en: Race conditions are one of the most difficult bugs to detect and debug because
    they usually occur sporadically and with different effects each time, and sometimes
    some expensive computation happens before the program reaches the point of failure.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件是最难检测和调试的bug之一，因为它们通常以间歇性的方式发生，每次发生时都有不同的效果，有时在程序达到失败点之前会发生一些昂贵的计算。
- en: This erratic behavior is not only caused by race conditions. Other issues related
    to incorrect memory allocation can cause similar symptoms, so it’s not possible
    to classify a bug as a race condition until there is some investigation and we
    reach a root-cause diagnosis.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不稳定的行为不仅由竞态条件引起。与不正确的内存分配相关的其他问题也可能导致类似症状，因此，在调查并达到根本原因诊断之前，无法将bug分类为竞态条件。
- en: 'One way of debugging race conditions is to use watchpoints to manually inspect
    if a variable changes its value without any statement executed in the current
    thread modifying it, or placing breakpoints in strategic locations triggered by
    specific threads when reached, as shown here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 调试竞态条件的一种方法是通过watchpoints手动检查变量是否在没有当前线程中执行的任何语句修改它的情况下更改其值，或者放置在特定线程触发的策略位置上的断点，如下所示：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For example, see the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，参见以下内容：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or, even using assertions and checking if the current value of any variable
    accessed by different threads has the expected value. This approach is followed
    in the next example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，甚至可以使用断言并检查任何由不同线程访问的变量的当前值是否具有预期的值。这种方法在下一个示例中得到了应用：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, two threads, **t1** and **t2** , are running functions that increase the
    **g_value** global variable by a random value. Each time it is increased, **g_value**
    is compared with the expected value, and if they are not equal, the assert instruction
    will stop the program.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，两个线程**t1**和**t2**正在运行增加**g_value**全局变量随机值的函数。每次增加时，都会将**g_value**与预期值进行比较，如果不相等，断言指令将停止程序。
- en: 'Compile this program and run the debugger as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式编译此程序并运行调试器：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After the debugger starts, run the program by using the **run** command. The
    program will run and, at some point, abort by receiving the **SIGABRT** signal,
    showing that the assertion was not met.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器启动后，使用**运行**命令来运行程序。程序将运行，并在某个时刻由于收到**SIGABRT**信号而终止，表明断言未满足。
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With the program stopped, we can use the **backtrace** commands to check the
    backtrace at that point and change the source code at that point of failure to
    a specific **frame** or **list** .
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 程序停止后，我们可以使用**backtrace**命令检查该点的回溯，并将该点失败处的源代码更改为特定的**帧**或**列表**。
- en: This example is quite simple, so it’s clear through checking the assertion output
    that something is going wrong with the **g_value** variable, and this is most
    probably a race condition.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子相当简单，所以通过检查断言输出，可以清楚地看出**g_value**变量出了问题，这很可能是竞态条件。
- en: But with a more elaborate program, this process of manually debugging issues
    is quite arduous, so let’s focus on another technique called reverse debugging
    that can help with that.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于更复杂的程序，手动调试问题的这个过程相当困难，所以让我们关注另一种称为反向调试的技术，它可以帮助我们解决这个问题。
- en: Reverse debugging
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向调试
- en: '**Reverse debugging** , also known as **time travel debugging** , allows a
    debugger to stop a program after failure and go back into the history of the execution
    of a program to investigate the reason for the failure. This functionality is
    achieved by logging (recording) the execution of each machine instruction of the
    program being debugged together with each change in values of memory and registers,
    and afterward, using these records to replay and rewind the program at will.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**反向调试**，也称为**时间旅行调试**，允许调试器在程序失败后停止程序，并回溯到程序执行的记录中，以调查失败的原因。此功能通过记录（记录）正在调试的程序中的每个机器指令以及内存和寄存器值的每次更改来实现，之后，使用这些记录随意回放和重放程序。'
- en: On Linux, we can use GDB (since version 7.0), **rr** (originally developed by
    Mozilla, [https://rr-project.org](https://rr-project.org) ), or **Undo’s time
    travel debugger** ( **UDB** ) ( [https://docs.undo.io](https://docs.undo.io) ).
    On Windows, we can use **Time Travel** **Debugging** ( [https://learn.microsoft.com/en-us/windows-hardware/drivers/debuggercmds/time-travel-debugging-overview](https://learn.microsoft.com/en-us/windows-hardware/drivers/debuggercmds/time-travel-debugging-overview)
    ).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，我们可以使用GDB（自7.0版本起）、**rr**（最初由Mozilla开发，[https://rr-project.org](https://rr-project.org)）或**Undo的时光旅行调试器**（**UDB**）（[https://docs.undo.io](https://docs.undo.io)）。在Windows上，我们可以使用**时光旅行调试**（[https://learn.microsoft.com/en-us/windows-hardware/drivers/debuggercmds/time-travel-debugging-overview](https://learn.microsoft.com/en-us/windows-hardware/drivers/debuggercmds/time-travel-debugging-overview)）。
- en: Reverse debugging is only supported by a limited number of GDB targets, such
    as remote target Simics, **system integration and design** ( **SID** ) simulators,
    or the **process record and replay** target for native Linux (only for **i386**
    , **amd64** , **moxie-elf** , and **arm** ). At the time of authoring this book,
    Clang’s reverse debugging feature is still under development.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 反向调试仅由有限数量的GDB目标支持，例如远程目标Simics、**系统集成和设计**（**SID**）模拟器或原生Linux的**进程记录和回放**目标（仅适用于**i386**、**amd64**、**moxie-elf**和**arm**）。在撰写本书时，Clang的反向调试功能仍在开发中。
- en: 'Therefore, due to these limitations, we decided to do a small showcase by using
    **rr** . Please follow the instructions on the project website to build and install
    the **rr** debugging tool: [https://github.com/rr-debugger/rr/wiki/Building-And-Installing](https://github.com/rr-debugger/rr/wiki/Building-And-Installing)
    .'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于这些限制，我们决定通过使用**rr**进行一个小型展示。请按照项目网站上的说明构建和安装**rr**调试工具：[https://github.com/rr-debugger/rr/wiki/Building-And-Installing](https://github.com/rr-debugger/rr/wiki/Building-And-Installing)。
- en: 'Once installed, to record and replay a program, use the following commands:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，要记录和回放程序，请使用以下命令：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For example, if we have a program called **test** , the command sequence will
    be as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个名为**test**的程序，命令序列将如下所示：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Say the following fatal error is shown instead:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果显示以下致命错误：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, use the following command to adjust the kernel variable, **kernel.perf_event_paranoid**
    :'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令调整内核变量，**kernel.perf_event_paranoid**：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once a record is available, use the **replay** command to start debugging the
    program:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有记录可用，请使用**replay**命令开始调试程序：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Or, if the program crashed and you want just to start debugging at the end
    of the recording, use the **–** **e** option:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果程序崩溃并且你只想在记录的末尾开始调试，请使用**–** **e**选项：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At this point, **rr** will use the GDB debugger to start the program and load
    its debug symbols. Then, you can use any of the following commands to reverse
    debugging:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，**rr**将使用GDB调试器启动程序并加载其调试符号。然后，你可以使用以下任何命令进行反向调试：
- en: '**reverse-continue** : Start executing the program in reverse. Execution will
    stop when a breakpoint is reached or due to a synchronous exception.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**reverse-continue**：以反向方式开始执行程序。执行将在达到断点或由于同步异常而停止。'
- en: '**reverse-next** : Run backward to the beginning of the previous line executed
    in the current stack frame.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**reverse-next**：反向运行到当前栈帧中之前执行的上一行的开始。'
- en: '**reverse-nexti** : This executes a single instruction in reverse, jumping
    those moving to inner stack frames.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**reverse-nexti**：这会反向执行一条指令，跳转到内部栈帧。'
- en: '**reverse-step** : Run the program backward until the control reaches the start
    of a new source line.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**reverse-step**：运行程序直到控制达到新源行的开始。'
- en: '**reverse-stepi** : Execute in reverse one machine instruction.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**reverse-stepi**：反向执行一条机器指令。'
- en: '**reverse-finish** : This executes until the current function invocation, that
    is, the beginning of the current function.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**reverse-finish**：这会执行到当前函数调用，即当前函数的开始处。'
- en: 'We can also reverse the direction of debugging and use regular commands for
    forward debugging (such as **next** , **step** , **continue** , and so on) in
    the opposite direction by using the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用以下命令来反转调试方向，并使用正向调试的常规命令（如**next**、**step**、**continue**等）在相反方向进行：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To set the execution direction back to forward, use the following command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要将执行方向恢复到正向，请使用以下命令：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As an exercise, install the **rr** debugger and try to debug the previous example
    using reverse debugging.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，安装**rr**调试器并尝试使用反向调试来调试前面的示例。
- en: Let’s now move on to how to debug coroutines, a challenging task due to their
    asynchronous nature.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续探讨如何调试协程，由于协程的异步特性，这是一个具有挑战性的任务。
- en: Debugging coroutines
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试协程
- en: As we have seen so far, asynchronous code can be debugged as synchronous code,
    by using breakpoints in strategic places with specific conditions, using watchpoints
    to inspect variables, and stepping into or over to walk through the code. Also,
    using techniques described earlier to select specific threads and locking the
    scheduler helps to avoid unnecessary distractions when debugging.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，异步代码可以通过在战略位置使用断点、使用观察点检查变量、进入或跳过代码来像同步代码一样进行调试。此外，使用前面描述的技术选择特定线程并锁定调度器有助于在调试时避免不必要的干扰。
- en: As we have already learned, there are complexities in asynchronous code, such
    as what thread will be used when the asynchronous code is executed, which makes
    it more difficult to debug. For C++ coroutines, debugging is even harder to master
    due to their suspend/resume nature.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所已了解，异步代码中存在复杂性，例如异步代码执行时将使用哪个线程，这使得调试更加困难。对于 C++ 协程，由于它们的挂起/恢复特性，调试甚至更难掌握。
- en: 'Clang compiles programs using coroutines in two steps: Semantic analysis is
    performed by Clang, and coroutine frames are constructed and optimized in the
    **LLVM** middle-end. As debug information is generated in the Clang frontend,
    there will be insufficient debug information as coroutine frames are generated
    later in the compilation process. GCC follows a similar approach.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 使用两步编译使用协程的程序：语义分析由 Clang 执行，协程帧在 **LLVM** 中间端构建和优化。由于调试信息是在 Clang 前端生成的，因此在编译过程中较晚生成协程帧时，将会有不足的调试信息。GCC
    采用类似的方法。
- en: Also, if the execution breaks inside a coroutine, the current frame will only
    have one variable, **frame_ptr** . In a coroutine, there are no pointer or function
    parameters. Coroutines store their state in the heap before suspending, and only
    using the stack during execution. **frame_ptr** is used to access all necessary
    information for the coroutine to run properly.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果执行在协程内部中断，当前帧将只有一个变量，**frame_ptr**。在协程中，没有指针或函数参数。协程在挂起之前将它们的状态存储在堆中，并且在执行期间只使用栈。**frame_ptr**
    用于访问协程正常运行所需的所有必要信息。
- en: 'Let’s debug the **Boost.Asio** coroutine example implemented in [*Chapter 9*](B22219_09.xhtml#_idTextAnchor184)
    . Here, we only show the relevant instructions. Please visit the *Coroutines*
    section in [*Chapter 9*](B22219_09.xhtml#_idTextAnchor184) to check the complete
    source code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调试在 [*第 9 章*](B22219_09.xhtml#_idTextAnchor184) 中实现的 **Boost.Asio** 协程示例。在这里，我们只展示相关的指令。请访问
    [*第 9 章*](B22219_09.xhtml#_idTextAnchor184) 中的 *协程* 部分，以检查完整的源代码：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As we are using Boost, let’s include the **Boost.System** library to add more
    symbols for debugging when compiling the source code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 Boost，让我们在编译源代码时包含 **Boost.System** 库，以添加更多符号以进行调试：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we start the debugger with the generated program and set breakpoints
    in lines 12 and 45, which are the locations of the first instruction inside the
    while loops on each coroutine:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用生成的程序启动调试器，并在第 12 行和第 45 行设置断点，这些是每个协程中 while 循环内第一条指令的位置：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We also enable the GDB built-in pretty printers to show readable output for
    Standard Template Library containers:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还启用了 GDB 内置的格式化打印器，以显示标准模板库容器的可读输出：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If now we run the program (the **run** command), it will reach the breakpoint
    at line 42 inside the coroutine listener before accepting connections. Using the
    **info locals** command, we can check the local variables.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行程序（**运行**命令），它将在接受连接之前到达协程监听器内的第 42 行的断点。使用 **info locals** 命令，我们可以检查局部变量。
- en: Coroutines create a state machine with several internal fields, such as promise
    objects, with attached thread, address of caller object, pending exceptions, and
    so on. Also, they store **resume** and **destroy** callbacks. These structures
    are compiler-dependent, tied to the compiler’s implementation, and accessible
    via **frame_ptr** if we are using Clang.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 协程创建了一个具有多个内部字段的状态机，例如带有线程的承诺对象、调用对象的地址、挂起的异常等。它们还存储 **resume** 和 **destroy**
    回调。这些结构是编译器依赖的，与编译器的实现相关联，并且如果我们使用 Clang，可以通过 **frame_ptr** 访问。
- en: If we continue running the program (with the **continue** command), the server
    will be waiting for a client to connect. To exit the waiting status, we use **telnet**
    , as shown in [*Chapter 9*](B22219_09.xhtml#_idTextAnchor184) , to connect a client
    to the server. At that point, the execution will be stopped because the breakpoint
    at line 12 inside the **echo()** coroutine is reached, and **info locals** show
    the variables used by each **echo** connection.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续运行程序（使用**继续**命令），服务器将等待客户端连接。要退出等待状态，我们使用**telnet**，如[*第9章*](B22219_09.xhtml#_idTextAnchor184)所示，将客户端连接到服务器。此时，执行将停止，因为达到**echo()**协程内部第12行的断点，并且**info
    locals**显示了每个**echo**连接使用的变量。
- en: Using the **backtrace** command will show a call stack that might have some
    complexities due to the coroutines’ suspend nature.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**回溯**命令将显示一个调用栈，由于协程的挂起特性，可能存在一些复杂性。
- en: 'In pure C++ routines, described in [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164)
    , there are two expressions where setting breakpoints could be interesting:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯C++例程中，如[*第8章*](B22219_08.xhtml#_idTextAnchor164)所述，有两个设置断点可能有趣的表达式：
- en: '**co_await** : The execution is suspended until the awaited operation is complete.
    Breakpoints can be set at the point where the coroutine is resumed by inspecting
    the underlying **await_suspend** , **await_resume** , or custom awaitable code.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**co_await**：执行将在等待的操作完成后挂起。可以通过检查底层的**await_suspend**、**await_resume**或自定义可等待代码来在协程恢复的点设置断点。'
- en: '**co_yield** : Suspends execution and yields a value. During debugging, step
    into the **co_yield** to observe how control flows between coroutines and their
    calling functions.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**co_yield**：挂起执行并返回一个值。在调试期间，进入**co_yield**以观察控制流如何在协程及其调用函数之间进行。'
- en: As coroutines are quite new in the C++ world and compilers are continuously
    evolving, we hope that soon debugging coroutines will be more straightforward.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于协程在C++世界中相当新颖，并且编译器持续发展，我们希望不久的将来调试协程将更加直接。
- en: Once we have found and debugged some bugs and can reproduce scenarios that lead
    to those specific bugs, it would be convenient to design some tests that cover
    those cases to avoid future changes in code that could lead to similar problems
    or incidents. Let’s learn how to test multithreaded and asynchronous code in the
    next chapter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到并调试了一些错误，并且可以重现导致这些特定错误的场景，设计一些涵盖这些情况的测试将很方便，以避免未来代码更改可能导致类似问题或事件。让我们在下一章学习如何测试多线程和异步代码。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use logging and debug asynchronous programs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用日志和调试异步程序。
- en: We started by using logging to spot issues in running software, showing its
    usefulness in detecting deadlocks by using the **spdlog** logging library. Many
    other libraries were also discussed, describing their relevant features that might
    be suitable to specific scenarios.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从使用日志来发现运行软件中的问题开始，展示了使用**spdlog**日志库检测死锁的有用性。还讨论了许多其他库，描述了它们可能适合特定场景的相关功能。
- en: However, not all bugs can be spotted by using logs, and some may only be detected
    later in the software development life cycle when some issues happen in production,
    even when dealing with program crashes and incidents. Debuggers are useful tools
    to inspect running or crashed programs, understand their code path, and find bugs.
    Several examples and debugger commands were introduced to deal with generic code,
    but also and especially with multithreaded and asynchronous software, race conditions,
    and coroutines. Also, the **rr** debugger was introduced, showing the potential
    of including reverse debugging in our developer toolbox.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有错误都可以通过使用日志来发现，有些错误可能只能在软件开发生命周期后期，当生产中出现问题时才会被发现，即使在处理程序崩溃和事件时也是如此。调试器是检查运行或崩溃程序的有用工具，了解其代码路径，并找到错误。介绍了几个示例和调试器命令来处理通用代码，但也特别针对多线程和异步软件、竞态条件和协程。还介绍了**rr**调试器，展示了将反向调试纳入我们的开发者工具箱的潜力。
- en: In the next chapter, we will learn about using sanitizers and testing techniques
    to performance and optimization techniques that can be used to improve asynchronous
    programs’ runtime and resource usage.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用 sanitizers 和测试技术来性能和优化技术，这些技术可以用来改善异步程序的运行时间和资源使用。
- en: Further reading
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Logging* : https://en.wikipedia.org/wiki/Logging_(computing)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*日志*：https://en.wikipedia.org/wiki/Logging_(computing)'
- en: '*Syslog* : https://en.wikipedia.org/wiki/Syslog'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Syslog*：https://en.wikipedia.org/wiki/Syslog'
- en: '*Google Logging* *Library* : https://github.com/google/glog'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google 日志库* : https://github.com/google/glog'
- en: '*Apache* *Log4cxx* : https://logging.apache.org/log4cxx'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Apache Log4cxx* : https://logging.apache.org/log4cxx'
- en: '*spdlog* : https://github.com/gabime/spdlog'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*spdlog* : https://github.com/gabime/spdlog'
- en: '*Quill* : https://github.com/odygrd/quill'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Quill* : https://github.com/odygrd/quill'
- en: '*xtr* : https://github.com/choll/xtr'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*xtr* : https://github.com/choll/xtr'
- en: '*lwlog* : https://github.com/ChristianPanov/lwlog'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*lwlog* : https://github.com/ChristianPanov/lwlog'
- en: '*uberlog* : https://github.com/IMQS/uberlog'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*uberlog* : https://github.com/IMQS/uberlog'
- en: '*Easylogging++* : https://github.com/abumq/easyloggingpp'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Easylogging++* : https://github.com/abumq/easyloggingpp'
- en: '*NanoLog* : https://github.com/PlatformLab/NanoLog'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NanoLog* : https://github.com/PlatformLab/NanoLog'
- en: '*Reckless Logging* *Library* : https://github.com/mattiasflodin/reckless'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Reckless 日志库* : https://github.com/mattiasflodin/reckless'
- en: '*tracetool* : [https://github.com/froglogic/tracetool](https://github.com/froglogic/tracetool)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*tracetool* : [https://github.com/froglogic/tracetool](https://github.com/froglogic/tracetool)'
- en: '*Logback* *Project* : [https://logback.qos.ch](https://logback.qos.ch)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Logback 项目* : [https://logback.qos.ch](https://logback.qos.ch)'
- en: '*Sentry* : [https://sentry.io](https://sentry.io)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Sentry* : [https://sentry.io](https://sentry.io)'
- en: '*Graylog* : [https://graylog.org](https://graylog.org)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Graylog* : [https://graylog.org](https://graylog.org)'
- en: '*Logstash* : [https://www.elastic.co/logstash](https://www.elastic.co/logstash)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Logstash* : [https://www.elastic.co/logstash](https://www.elastic.co/logstash)'
- en: '*Debugging with* *GDB* : [https://sourceware.org/gdb/current/onlinedocs/gdb.html](https://sourceware.org/gdb/current/onlinedocs/gdb.html)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 GDB 调试* : [https://sourceware.org/gdb/current/onlinedocs/gdb.html](https://sourceware.org/gdb/current/onlinedocs/gdb.html)'
- en: '*LLDB* *tutorial* : [https://lldb.llvm.org/use/tutorial.html](https://lldb.llvm.org/use/tutorial.html)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*LLDB 教程* : [https://lldb.llvm.org/use/tutorial.html](https://lldb.llvm.org/use/tutorial.html)'
- en: '*Clang Compiler User’s* *Manual* : [https://clang.llvm.org/docs/UsersManual.html](https://clang.llvm.org/docs/UsersManual.html)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Clang 编译器用户手册* : [https://clang.llvm.org/docs/UsersManual.html](https://clang.llvm.org/docs/UsersManual.html)'
- en: '*GDB* : *Running programs* *backward* : [https://www.zeuthen.desy.de/dv/documentation/unixguide/infohtml/gdb/Reverse-Execution.html#Reverse-Execution](https://www.zeuthen.desy.de/dv/documentation/unixguide/infohtml/gdb/Reverse-Execution.html#Reverse-Execution)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GDB* : *运行程序反向执行* : [https://www.zeuthen.desy.de/dv/documentation/unixguide/infohtml/gdb/Reverse-Execution.html#Reverse-Execution](https://www.zeuthen.desy.de/dv/documentation/unixguide/infohtml/gdb/Reverse-Execution.html#Reverse-Execution)'
- en: '*Reverse Debugging with* *GDB* : [https://sourceware.org/gdb/wiki/ReverseDebug](https://sourceware.org/gdb/wiki/ReverseDebug)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 GDB 进行反向调试* : [https://sourceware.org/gdb/wiki/ReverseDebug](https://sourceware.org/gdb/wiki/ReverseDebug)'
- en: '*Debugging C++* *Coroutines* : [https://clang.llvm.org/docs/DebuggingCoroutines.html](https://clang.llvm.org/docs/DebuggingCoroutines.html)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调试 C++ 协程* : [https://clang.llvm.org/docs/DebuggingCoroutines.html](https://clang.llvm.org/docs/DebuggingCoroutines.html)'
- en: '*SID Simulator User’s* *Guide* : [https://sourceware.org/sid/sid-guide/book1.html](https://sourceware.org/sid/sid-guide/book1.html)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SID 模拟器用户手册* : [https://sourceware.org/sid/sid-guide/book1.html](https://sourceware.org/sid/sid-guide/book1.html)'
- en: '*Intel Simics Simulator for Intel FPGAs: User* *Guide* : [https://www.intel.com/content/www/us/en/docs/programmable/784383/24-1/about-this-document.html](https://www.intel.com/content/www/us/en/docs/programmable/784383/24-1/about-this-document.html)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Intel Simics 模拟器用于 Intel FPGAs: 用户手册* : [https://www.intel.com/content/www/us/en/docs/programmable/784383/24-1/about-this-document.html](https://www.intel.com/content/www/us/en/docs/programmable/784383/24-1/about-this-document.html)'
- en: '*IBM Support* : *How do I enable core* *dumps* : [https://www.ibm.com/support/pages/how-do-i-enable-core-dumps](https://www.ibm.com/support/pages/how-do-i-enable-core-dumps)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IBM 支持* : *如何启用核心转储* : [https://www.ibm.com/support/pages/how-do-i-enable-core-dumps](https://www.ibm.com/support/pages/how-do-i-enable-core-dumps)'
- en: '*Core Dumps – How to enable* *them?* : [https://medium.com/@sourabhedake/core-dumps-how-to-enable-them-73856a437711](mailto:https://medium.com/@sourabhedake/core-dumps-how-to-enable-them-73856a437711)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*核心转储 – 如何启用它们？* : [https://medium.com/@sourabhedake/core-dumps-how-to-enable-them-73856a437711](mailto:https://medium.com/@sourabhedake/core-dumps-how-to-enable-them-73856a437711)'
