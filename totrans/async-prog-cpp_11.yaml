- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging and Debugging Asynchronous Software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no way to ensure that a software product is free from bugs, so from
    time to time, bugs can appear. This is when logging and debugging are indispensable.
  prefs: []
  type: TYPE_NORMAL
- en: Logging and debugging are essential for identifying and diagnosing issues in
    software systems. They provide visibility into the runtime behavior of code, helping
    developers trace errors, monitor performance, and understand the flow of execution.
    By using logging and debugging effectively, developers can detect bugs, resolve
    unexpected behavior, and improve overall system stability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: While writing this chapter, we assume you are already familiar with using a
    debugger to debug C++ programs and know some basic debugger commands and terminology,
    such as breakpoints, watchers, frames, or stack traces. To brush up on that knowledge,
    you can refer to the references provided in the *Further reading* section at the
    end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use logging to spot bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to debug asynchronous software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we will need to install third-party libraries to compile examples.
  prefs: []
  type: TYPE_NORMAL
- en: The **spdlog** and **{fmt}** libraries need to be installed to compile the example
    in the logging section. Please check their documentation ( **spdlog** ’s documentation
    is available at [https://github.com/gabime/spdlog](https://github.com/gabime/spdlog)
    and **{fmt}** ’s documentation is available at [https://github.com/fmtlib/fmt](https://github.com/fmtlib/fmt)
    ) and follow the installation steps suitable for your platform.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples need a compiler supporting C++20. Therefore, check the technical
    requirements section in [*Chapter 3*](B22219_03.xhtml#_idTextAnchor051) , which
    has some guidance on how to install GCC 13 and Clang 8 compilers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all the complete code in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples for this chapter are located under the **Chapter_11** folder.
    All source code files can be compiled using CMake as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Executable binaries will be generated under the **bin** directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to use logging to spot bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start with a trivial but useful method for understanding what a software
    program does while executing – logging.
  prefs: []
  type: TYPE_NORMAL
- en: '**Logging** is the process of keeping a log of events that occur in a program,
    storing information by using messages to record how a program executes, tracking
    its flow, and helping with identifying issues and bugs.'
  prefs: []
  type: TYPE_NORMAL
- en: Most Unix-based logging systems use the standard protocol, **syslog** , created
    by Eric Altman back in 1980 as part of the Sendmail project. This standard protocol
    defines the boundaries between the software generating the log messages, the system
    storing them, and the software reporting and analyzing these log events.
  prefs: []
  type: TYPE_NORMAL
- en: Each log message includes a facility code and a severity level. The facility
    code identifies the type of system that originated a specific log message (user-level,
    kernel, system, network, etc.), and the severity level describes the condition
    of the system, indicating the urgency of dealing with a specific issue, the severity
    levels being emergency, alert, critical, error, warning, notice, info, and debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most logging systems or loggers provide various destinations or sinks for log
    messages: console, files that can later be opened and analyzed, remote syslog
    servers, or relays, among other destinations.'
  prefs: []
  type: TYPE_NORMAL
- en: Logging is useful where debuggers are not, as we will see later, especially
    in distributed, multithreaded, real-time, scientific, or event-centric applications,
    where inspecting data or following the program flow using the debugger can become
    a tedious task.
  prefs: []
  type: TYPE_NORMAL
- en: Logging libraries usually also provide a thread-safe singleton class that allows
    multithreading and asynchronous writing to log files, helps with log rotation,
    avoids large log files by creating new ones on the fly without losing log events,
    and time stamping, for better tracking when a log event happens.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of implementing our own multithreaded logging system, a better approach
    is to use some well-tested and documented production-ready libraries.
  prefs: []
  type: TYPE_NORMAL
- en: How to select a third-party library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When selecting a logging library (or any other library), we need to investigate
    the following points before integrating it into our software to avoid future issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Support** : Is the library updated and upgraded regularly? Is there a community
    or active ecosystem around the library that can help with any questions that can
    arise? Is the community happy using the library?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quality** : Is there a public bugs report system? Are bug reports dealt with
    promptly, providing solutions and fixing bugs in the library? Does it support
    recent compiler versions and support latest C++ features?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security** : Does the library, or any of its dependent libraries, have any
    vulnerabilities reported?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**License** : Is the library license aligned with our development and product
    needs? Is the cost affordable?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For complex systems, it may be worth considering centralized systems to collect
    and generate logging reports or dashboards, such as **Sentry** ( [https://sentry.io](https://sentry.io)
    ) or **Logstash** ( [https://www.elastic.co/logstash](https://www.elastic.co/logstash)
    ), that can collect, parse, and transform logs, and can be integrated with other
    tools, such as **Graylog** (https://graylog.org), **Grafana** (https://grafana.com),
    or **Kibana** ( https://www.elastic.co/kibana ).
  prefs: []
  type: TYPE_NORMAL
- en: The next section describes some interesting logging libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Some relevant logging libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many logging libraries in the market, each covering some specific
    software requirements. Depending on the program constraints and needs, one of
    the following libraries might be more suitable than others.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B22219_09.xhtml#_idTextAnchor184) , we explored **Boost.Asio**
    . Boost also provides another library, **Boost.Log** ( [https://github.com/boostorg/log](https://github.com/boostorg/log)
    ), a powerful and configurable logging library.
  prefs: []
  type: TYPE_NORMAL
- en: Google also provides many open source libraries, including **glog** , the Google
    logging library ( [https://github.com/google/glog](https://github.com/google/glog)
    ), which is a C++14 library that provides C++-style streams APIs and helper macros.
  prefs: []
  type: TYPE_NORMAL
- en: If the developer is familiar with Java, an excellent choice could be Apache
    **Log4cxx** ( [https://logging.apache.org/log4cxx](https://logging.apache.org/log4cxx)
    ), based on **Log4j** ( [https://logging.apache.org/log4j](https://logging.apache.org/log4j)
    ), a versatile, industrial-grade, Java logging framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other logging libraries worth considering are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**spdlog** ( [https://github.com/gabime/spdlog](https://github.com/gabime/spdlog)
    ) is an interesting logging library that we can use with the **{fmt}** library.
    Also, the program can start logging messages and queuing them since startup, even
    before the log output file name is specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quill** (https://github.com/odygrd/quill) is an asynchronous low-latency
    C++ logging library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NanoLog** (https://github.com/PlatformLab/NanoLog) is a nanosecond scale
    logging system with **printf** -like APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lwlog** (https://github.com/ChristianPanov/lwlog) is an amazingly fast asynchronous
    C++17 logging library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XTR** (https://github.com/choll/xtr) is a fast and convenient C++ logging
    library for low-latency and real-time environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reckless** (https://github.com/mattiasflodin/reckless) is a low-latency and
    high-throughput logging library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**uberlog** (https://github.com/IMQS/uberlog) is a cross-platform and multi-process
    C++ logging system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easylogging++** (https://github.com/abumq/easyloggingpp) is a single-header
    C++ logging library with the ability to write our own sinks and track performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tracetool** (https://github.com/froglogic/tracetool) is a logging and tracing
    shared library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a guideline, depending on the system to develop, we might choose one of
    the following libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For low-latency or real-time systems** : Quill, XTR, or Reckless'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For high performance at nanosecond scale** **logging** : NanoLog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For asynchronous logging** : Quill or **lwlog**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For cross-platform, multi-process** **applications** : **uberlog**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For simple and flexible logging** : Easylogging++ or glog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For familiarity with Java** **logging** : Log4cxx'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All libraries have advantages but also disadvantages that need to be investigated
    prior to selecting a library to include in your system. The following table summarizes
    these points:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Library** | **Advantages** | **Disadvantages** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **spdlog** | Easy integration, performance-focused, customizable | Lacks
    some advanced features for extreme low-latency needs |'
  prefs: []
  type: TYPE_TB
- en: '| Quill | High performance in low-latency systems | More complex setup compared
    to simpler, synchronous loggers |'
  prefs: []
  type: TYPE_TB
- en: '| NanoLog | Best in class for speed, optimized for performance | Limited in
    features; suited for specialized use cases |'
  prefs: []
  type: TYPE_TB
- en: '| **lwlog** | Lightweight, good for quick integration | Less mature and feature-rich
    than alternatives |'
  prefs: []
  type: TYPE_TB
- en: '| XTR | Very efficient, user-friendly interface | More suited for specific
    real-time applications |'
  prefs: []
  type: TYPE_TB
- en: '| Reckless | Highly optimized for throughput and low latency | Limited flexibility
    compared to more general-purpose loggers |'
  prefs: []
  type: TYPE_TB
- en: '| **uberlog** | Great for multi-process and distributed systems | Not as fast
    as specialized low-latency loggers |'
  prefs: []
  type: TYPE_TB
- en: '| Easylogging++ | Easy to use, customizable output sinks | Less performance-optimized
    than some other libraries |'
  prefs: []
  type: TYPE_TB
- en: '| **tracetool** | Combines logging and tracing in one library | Not focused
    on low-latency or high-throughput |'
  prefs: []
  type: TYPE_TB
- en: '| Boost.Log | Versatile, integrates well with Boost libraries | Higher complexity;
    can be overkill for simple logging needs |'
  prefs: []
  type: TYPE_TB
- en: '| glog | Simple to use, good for projects requiring easy APIs | Not as feature-rich
    for advanced customization |'
  prefs: []
  type: TYPE_TB
- en: '| Log4cxx | Robust, time-tested, industrial-strength logging | More complex
    to set up, especially for smaller projects |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11.1: Advantages and disadvantages of various libraries'
  prefs: []
  type: TYPE_NORMAL
- en: Please visit the logging libraries’ websites to understand better what features
    they provide and compare performance between them.
  prefs: []
  type: TYPE_NORMAL
- en: As **spdlog** is the most forked and starred C++ logging library repository
    in GitHub, in the next section, we will implement an example of using this library
    to catch a race condition.
  prefs: []
  type: TYPE_NORMAL
- en: Logging a deadlock – an example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before implementing this example, we need to install the **spdlog** and **{fmt}**
    libraries. **{fmt}** (https://github.com/fmtlib/fmt) is an open source formatting
    library providing a fast and safe alternative to C++ IOStreams.
  prefs: []
  type: TYPE_NORMAL
- en: Please check their documentation and follow the installation steps depending
    on your platform.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement an example where a deadlock is happening. As we learned in [*Chapter
    4*](B22219_04.xhtml#_idTextAnchor074) , a deadlock can happen when two or more
    threads need to acquire more than one mutex to perform their work. If mutexes
    are not acquired in the same order, a thread can acquire a mutex and wait forever
    for another mutex acquired by another thread.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, two threads need to acquire two mutexes, **mtx1** and **mtx2**
    , to increase the value of the **counter1** and **counter2** counters and swap
    their values. As the mutexes are acquired in different order by the threads, a
    deadlock can happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by including the required libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the **main()** function, we define the counters and mutexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Before spawning the threads, let’s set up a **multi-sink logger** , a logger
    that can write log messages into the console and a log file simultaneously. We
    will also set up its log level to debug, making the logger publish all log messages
    with a severity level greater than debug, and the format for each log line consisting
    of the timestamp, the thread identifier, the log level, and the log message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We also declare an **increase_and_swap** lambda function that increases the
    values of both counters and swaps them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Two worker lambda functions, **worker1** and **worker2** , acquire both mutexes
    and call **increase_and_swap()** before exiting. As lock guard ( **std::lock_guard**
    ) objects are used, the mutexes are released when leaving the worker lambda functions
    during their destruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Both worker lambda functions are similar but with a small difference: **worker1**
    acquires **mutex1** and then **mutex2** , and **worker2** follows the opposite
    order, first acquiring **mutex2** and then **mutex1** . There is a sleep period
    between both mutexes’ acquisition to let the other thread acquire its mutex, therefore,
    provoking a deadlock as **worker1** will acquire **mutex1** and **worker2** will
    acquire **mutex2** .'
  prefs: []
  type: TYPE_NORMAL
- en: Then, after sleeping, **worker1** will try to acquire **mutex2** and **worker2**
    will try the same with **mutex1** , but none of them will succeed, blocking forever
    in a deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output when running this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first symptom to note when inspecting the logs is that the program never
    finishes and therefore probably is deadlocked.
  prefs: []
  type: TYPE_NORMAL
- en: From the logger output, we can see that **t1** (thread **38985** ) is running
    **worker1** and **t2** (thread **38986** ) is running **worker2** . As soon as
    **t1** enters **worker1** , it acquires **mtx1** . The **mtx2** mutex is acquired
    by **t2** though, as soon as **worker2** starts. Then, both threads wait for 100
    ms and try to acquire the other mutex, but none succeed, and the program remains
    blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Logging is indispensable in production systems but imposes some performance
    penalty if abused, and most of the time requires human intervention to investigate
    an issue. As a compromise between log verbosity and performance penalty, one might
    choose to implement different logging levels and log only major events during
    normal operation, while still retaining the ability to provide extremely detailed
    logs if opted for, when the situation needs it. A more automated way to detect
    errors in code early in the development cycle is by using testing and code sanitizers,
    which we will learn about in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Not all bugs can be detected, so usually using a debugger is the way to track
    down and fix bugs in software. Let’s learn next how to debug multithreading and
    asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: How to debug asynchronous software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Debugging** is the process of finding and fixing errors in computer programs.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore several techniques to debug multithreading
    and asynchronous software. You must have some previous knowledge of how to use
    debuggers, such as **GDB** (the GNU project debugger) or **LLDB** (the LLVM low-level
    debugger), and the terminology of the debugging process, such as breakpoints,
    watchers, backtraces, frames, and crash reports.
  prefs: []
  type: TYPE_NORMAL
- en: Both GDB and LLDB are excellent debuggers with most of their commands being
    the same and only a few ones that differ. LLDB might be preferred if the program
    is being debugged on macOS or for large code bases. On the other hand, GDB has
    an established legacy, being familiar to many developers, and supporting a broader
    range of architectures and platforms. In this section, we will use GDB 15.1 just
    because it is part of the GNU framework and was designed to work alongside the
    **g++** compiler, but most commands shown later can also be used with LLDB when
    debugging programs compiled with **clang++** .
  prefs: []
  type: TYPE_NORMAL
- en: As some debugger features that deal with multithreading and asynchronous code
    are still in development, always update the debuggers to the latest versions to
    include up-to-date features and fixes.
  prefs: []
  type: TYPE_NORMAL
- en: Some useful GDB commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with some GDB commands that are useful when debugging any kind of
    program and acquire a foundation for the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'When debugging a program, we can start the debugger and pass the program as
    an argument. Extra arguments that the program might need can be passed with the
    **--** **args** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can attach the debugger to a running program by using its **process**
    **identifier** ( **PID** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once inside the debugger, we can run the program (with the **run** command)
    or start it (with the **start** command). Running means that the program executes
    until reaching a breakpoint or finishing. **start** just places a temporary breakpoint
    at the beginning of the **main()** function and runs the program, stopping the
    execution at the beginning of the program.
  prefs: []
  type: TYPE_NORMAL
- en: If, for instance, we want to debug a program that has already crashed, we can
    use the core dump file that the crash generated, which might be stored in a specific
    location in the system (usually **/var/lib/apport/coredump/** on Linux systems,
    but please check for the exact location in your system by visiting the official
    documentation). Also, note that typically, core dumps are disabled by default,
    requiring the **ulimit -c unlimited** command to be run prior to, and in the same
    shell as, the program crashing. The **unlimited** argument can be changed to some
    arbitrary limit if we are dealing with an exceptionally large program or the system
    is short on disk space.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the **coredump** file is generated, just copy it to the location where
    the program binary is located and use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that all binaries must have debugging symbols, thus compiled with the **–g**
    option. In production systems, release binaries usually have symbols stripped
    and stored in separate files. There are GDB commands to include those symbols
    and command-line tools to inspect them, but this topic is beyond the scope of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the debugger starts, we can use GDB commands to navigate through the code
    or check variables. Some useful commands are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**info args** : This shows information about arguments used to call the current
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**info locals** : This shows local variables in the current scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**whatis** : This shows the type of the given variable or expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**return** : This returns from the current function without executing the rest
    of the instructions. A return value can be specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**backtrace** : This lists all stack frames in the current call stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**frame** : This lets you change to a specific stack frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**up** , **down** : This moves across the call stack, toward the caller ( **up**
    ) or the callee ( **down** ) of the current function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**print** : This evaluates and displays the value of an expression, being that
    expression a variable name, a class member, a pointer to a memory region, or directly
    a memory address. We can also define pretty printers to display our own classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s finish this section with one of the most basic but also used techniques
    for debugging programs. This technique is called **printf** . Every developer
    has used **printf** or alternative commands to print the content of variables
    along the code path to show their contents in strategic code locations. In GDB,
    the **dprintf** command helps to set **printf** -style breakpoints that print
    information when those breakpoints are hit but without stopping the program execution.
    This way, we can use print statements when debugging a program without the need
    for code modifications, recompilation, and program restarts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we want to set a **printf** statement at line 25 to print the
    content of the **x** variable but only if its value is greater than **5** , this
    is the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have some foundations, let’s start by debugging a multithreaded
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging multithreaded programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The example shown here will never finish as a deadlock will happen as two mutexes
    are locked in a different order by different threads, as already explained earlier
    in this chapter when introducing logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: First, let’s compile this example using **g++** and add debug symbols (the **–g**
    option) and disallow code optimization (the **–O0** option), preventing the compiler
    from restructuring the binary code and making it more difficult for the debugger
    to find and show relevant information by using the **--** **fno-omit-frame-pointer**
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command compiles the **test.cpp** source file and generates the
    **test** binary. We can also use **clang++** with the same options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the resulting program, this will never finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To debug a program that is running, let’s first retrieve its PID by using the
    **ps** Unix command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, attach the debugger by providing **pid** and start debugging the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Say the debugger starts with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once GDB starts properly, you will be able to type commands into its prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command we can execute is the next one to check what threads are
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that the **0x79d1f3883740** thread with GDB identifier **1**
    is the current one. If there are many threads and we are only interested in a
    specific subset, let’s say threads 1 and 3, we can show information only for those
    threads by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Running a GDB command will affect the current thread. For example, running
    the **bt** command will show the backtrace for thread 1 ( output simplified):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To switch to another thread, for example, thread 2, we can use the **thread**
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the **bt** command will show the backtrace for thread 2 ( output simplified):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute a command in different threads, just use the **thread apply** command,
    in this case, executing the **bt** command on threads 1 and 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To execute a command in all threads, just use **thread apply** **all <command>**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Note that when a breakpoint is reached in a multithreaded program, all threads
    of execution stop running, allowing the examination of the overall state of the
    program. When the execution is restarted by commands such as **continue** , **step**
    , or **next** , all threads resume. The current thread will move one statement
    forward, but that is not guaranteed for other threads, which could move forward
    several statements or even stop in the middle of a statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the execution stops, the debugger will jump and show the context of the
    execution in the current thread. To avoid the debugger jumping between threads
    by locking the scheduler, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the following command to check the scheduler locking status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have learned some new commands for multithreading debugging, let’s
    check what is happening with the application we attached to the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we retrieve the backtraces in threads 2 and 3, we can see the following
    (output simplified only showing the relevant parts):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that, after running **std::mutex::lock()** , both threads are waiting at
    line 13 for thread 3 and at 19 for thread 2, which matches with **std::lock_guard**
    **lock2** in **std::thread** **t1** and **std::lock_guard** **lock1** in **std::thread**
    **t2** , respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we detected a deadlock happening in those threads at these code locations.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now learn more about debugging multithreaded software by catching a race
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging race conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Race conditions are one of the most difficult bugs to detect and debug because
    they usually occur sporadically and with different effects each time, and sometimes
    some expensive computation happens before the program reaches the point of failure.
  prefs: []
  type: TYPE_NORMAL
- en: This erratic behavior is not only caused by race conditions. Other issues related
    to incorrect memory allocation can cause similar symptoms, so it’s not possible
    to classify a bug as a race condition until there is some investigation and we
    reach a root-cause diagnosis.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way of debugging race conditions is to use watchpoints to manually inspect
    if a variable changes its value without any statement executed in the current
    thread modifying it, or placing breakpoints in strategic locations triggered by
    specific threads when reached, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, even using assertions and checking if the current value of any variable
    accessed by different threads has the expected value. This approach is followed
    in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, two threads, **t1** and **t2** , are running functions that increase the
    **g_value** global variable by a random value. Each time it is increased, **g_value**
    is compared with the expected value, and if they are not equal, the assert instruction
    will stop the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile this program and run the debugger as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: After the debugger starts, run the program by using the **run** command. The
    program will run and, at some point, abort by receiving the **SIGABRT** signal,
    showing that the assertion was not met.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With the program stopped, we can use the **backtrace** commands to check the
    backtrace at that point and change the source code at that point of failure to
    a specific **frame** or **list** .
  prefs: []
  type: TYPE_NORMAL
- en: This example is quite simple, so it’s clear through checking the assertion output
    that something is going wrong with the **g_value** variable, and this is most
    probably a race condition.
  prefs: []
  type: TYPE_NORMAL
- en: But with a more elaborate program, this process of manually debugging issues
    is quite arduous, so let’s focus on another technique called reverse debugging
    that can help with that.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Reverse debugging** , also known as **time travel debugging** , allows a
    debugger to stop a program after failure and go back into the history of the execution
    of a program to investigate the reason for the failure. This functionality is
    achieved by logging (recording) the execution of each machine instruction of the
    program being debugged together with each change in values of memory and registers,
    and afterward, using these records to replay and rewind the program at will.'
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, we can use GDB (since version 7.0), **rr** (originally developed by
    Mozilla, [https://rr-project.org](https://rr-project.org) ), or **Undo’s time
    travel debugger** ( **UDB** ) ( [https://docs.undo.io](https://docs.undo.io) ).
    On Windows, we can use **Time Travel** **Debugging** ( [https://learn.microsoft.com/en-us/windows-hardware/drivers/debuggercmds/time-travel-debugging-overview](https://learn.microsoft.com/en-us/windows-hardware/drivers/debuggercmds/time-travel-debugging-overview)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Reverse debugging is only supported by a limited number of GDB targets, such
    as remote target Simics, **system integration and design** ( **SID** ) simulators,
    or the **process record and replay** target for native Linux (only for **i386**
    , **amd64** , **moxie-elf** , and **arm** ). At the time of authoring this book,
    Clang’s reverse debugging feature is still under development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, due to these limitations, we decided to do a small showcase by using
    **rr** . Please follow the instructions on the project website to build and install
    the **rr** debugging tool: [https://github.com/rr-debugger/rr/wiki/Building-And-Installing](https://github.com/rr-debugger/rr/wiki/Building-And-Installing)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, to record and replay a program, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we have a program called **test** , the command sequence will
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Say the following fatal error is shown instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the following command to adjust the kernel variable, **kernel.perf_event_paranoid**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a record is available, use the **replay** command to start debugging the
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if the program crashed and you want just to start debugging at the end
    of the recording, use the **–** **e** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, **rr** will use the GDB debugger to start the program and load
    its debug symbols. Then, you can use any of the following commands to reverse
    debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '**reverse-continue** : Start executing the program in reverse. Execution will
    stop when a breakpoint is reached or due to a synchronous exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**reverse-next** : Run backward to the beginning of the previous line executed
    in the current stack frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**reverse-nexti** : This executes a single instruction in reverse, jumping
    those moving to inner stack frames.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**reverse-step** : Run the program backward until the control reaches the start
    of a new source line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**reverse-stepi** : Execute in reverse one machine instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**reverse-finish** : This executes until the current function invocation, that
    is, the beginning of the current function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also reverse the direction of debugging and use regular commands for
    forward debugging (such as **next** , **step** , **continue** , and so on) in
    the opposite direction by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To set the execution direction back to forward, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, install the **rr** debugger and try to debug the previous example
    using reverse debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now move on to how to debug coroutines, a challenging task due to their
    asynchronous nature.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging coroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen so far, asynchronous code can be debugged as synchronous code,
    by using breakpoints in strategic places with specific conditions, using watchpoints
    to inspect variables, and stepping into or over to walk through the code. Also,
    using techniques described earlier to select specific threads and locking the
    scheduler helps to avoid unnecessary distractions when debugging.
  prefs: []
  type: TYPE_NORMAL
- en: As we have already learned, there are complexities in asynchronous code, such
    as what thread will be used when the asynchronous code is executed, which makes
    it more difficult to debug. For C++ coroutines, debugging is even harder to master
    due to their suspend/resume nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clang compiles programs using coroutines in two steps: Semantic analysis is
    performed by Clang, and coroutine frames are constructed and optimized in the
    **LLVM** middle-end. As debug information is generated in the Clang frontend,
    there will be insufficient debug information as coroutine frames are generated
    later in the compilation process. GCC follows a similar approach.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, if the execution breaks inside a coroutine, the current frame will only
    have one variable, **frame_ptr** . In a coroutine, there are no pointer or function
    parameters. Coroutines store their state in the heap before suspending, and only
    using the stack during execution. **frame_ptr** is used to access all necessary
    information for the coroutine to run properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s debug the **Boost.Asio** coroutine example implemented in [*Chapter 9*](B22219_09.xhtml#_idTextAnchor184)
    . Here, we only show the relevant instructions. Please visit the *Coroutines*
    section in [*Chapter 9*](B22219_09.xhtml#_idTextAnchor184) to check the complete
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are using Boost, let’s include the **Boost.System** library to add more
    symbols for debugging when compiling the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we start the debugger with the generated program and set breakpoints
    in lines 12 and 45, which are the locations of the first instruction inside the
    while loops on each coroutine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We also enable the GDB built-in pretty printers to show readable output for
    Standard Template Library containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If now we run the program (the **run** command), it will reach the breakpoint
    at line 42 inside the coroutine listener before accepting connections. Using the
    **info locals** command, we can check the local variables.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines create a state machine with several internal fields, such as promise
    objects, with attached thread, address of caller object, pending exceptions, and
    so on. Also, they store **resume** and **destroy** callbacks. These structures
    are compiler-dependent, tied to the compiler’s implementation, and accessible
    via **frame_ptr** if we are using Clang.
  prefs: []
  type: TYPE_NORMAL
- en: If we continue running the program (with the **continue** command), the server
    will be waiting for a client to connect. To exit the waiting status, we use **telnet**
    , as shown in [*Chapter 9*](B22219_09.xhtml#_idTextAnchor184) , to connect a client
    to the server. At that point, the execution will be stopped because the breakpoint
    at line 12 inside the **echo()** coroutine is reached, and **info locals** show
    the variables used by each **echo** connection.
  prefs: []
  type: TYPE_NORMAL
- en: Using the **backtrace** command will show a call stack that might have some
    complexities due to the coroutines’ suspend nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'In pure C++ routines, described in [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164)
    , there are two expressions where setting breakpoints could be interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '**co_await** : The execution is suspended until the awaited operation is complete.
    Breakpoints can be set at the point where the coroutine is resumed by inspecting
    the underlying **await_suspend** , **await_resume** , or custom awaitable code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**co_yield** : Suspends execution and yields a value. During debugging, step
    into the **co_yield** to observe how control flows between coroutines and their
    calling functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As coroutines are quite new in the C++ world and compilers are continuously
    evolving, we hope that soon debugging coroutines will be more straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have found and debugged some bugs and can reproduce scenarios that lead
    to those specific bugs, it would be convenient to design some tests that cover
    those cases to avoid future changes in code that could lead to similar problems
    or incidents. Let’s learn how to test multithreaded and asynchronous code in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use logging and debug asynchronous programs.
  prefs: []
  type: TYPE_NORMAL
- en: We started by using logging to spot issues in running software, showing its
    usefulness in detecting deadlocks by using the **spdlog** logging library. Many
    other libraries were also discussed, describing their relevant features that might
    be suitable to specific scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: However, not all bugs can be spotted by using logs, and some may only be detected
    later in the software development life cycle when some issues happen in production,
    even when dealing with program crashes and incidents. Debuggers are useful tools
    to inspect running or crashed programs, understand their code path, and find bugs.
    Several examples and debugger commands were introduced to deal with generic code,
    but also and especially with multithreaded and asynchronous software, race conditions,
    and coroutines. Also, the **rr** debugger was introduced, showing the potential
    of including reverse debugging in our developer toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about using sanitizers and testing techniques
    to performance and optimization techniques that can be used to improve asynchronous
    programs’ runtime and resource usage.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Logging* : https://en.wikipedia.org/wiki/Logging_(computing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Syslog* : https://en.wikipedia.org/wiki/Syslog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Google Logging* *Library* : https://github.com/google/glog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Apache* *Log4cxx* : https://logging.apache.org/log4cxx'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*spdlog* : https://github.com/gabime/spdlog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Quill* : https://github.com/odygrd/quill'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*xtr* : https://github.com/choll/xtr'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*lwlog* : https://github.com/ChristianPanov/lwlog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*uberlog* : https://github.com/IMQS/uberlog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Easylogging++* : https://github.com/abumq/easyloggingpp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NanoLog* : https://github.com/PlatformLab/NanoLog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reckless Logging* *Library* : https://github.com/mattiasflodin/reckless'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*tracetool* : [https://github.com/froglogic/tracetool](https://github.com/froglogic/tracetool)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Logback* *Project* : [https://logback.qos.ch](https://logback.qos.ch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sentry* : [https://sentry.io](https://sentry.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Graylog* : [https://graylog.org](https://graylog.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Logstash* : [https://www.elastic.co/logstash](https://www.elastic.co/logstash)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Debugging with* *GDB* : [https://sourceware.org/gdb/current/onlinedocs/gdb.html](https://sourceware.org/gdb/current/onlinedocs/gdb.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*LLDB* *tutorial* : [https://lldb.llvm.org/use/tutorial.html](https://lldb.llvm.org/use/tutorial.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clang Compiler User’s* *Manual* : [https://clang.llvm.org/docs/UsersManual.html](https://clang.llvm.org/docs/UsersManual.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GDB* : *Running programs* *backward* : [https://www.zeuthen.desy.de/dv/documentation/unixguide/infohtml/gdb/Reverse-Execution.html#Reverse-Execution](https://www.zeuthen.desy.de/dv/documentation/unixguide/infohtml/gdb/Reverse-Execution.html#Reverse-Execution)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reverse Debugging with* *GDB* : [https://sourceware.org/gdb/wiki/ReverseDebug](https://sourceware.org/gdb/wiki/ReverseDebug)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Debugging C++* *Coroutines* : [https://clang.llvm.org/docs/DebuggingCoroutines.html](https://clang.llvm.org/docs/DebuggingCoroutines.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SID Simulator User’s* *Guide* : [https://sourceware.org/sid/sid-guide/book1.html](https://sourceware.org/sid/sid-guide/book1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Intel Simics Simulator for Intel FPGAs: User* *Guide* : [https://www.intel.com/content/www/us/en/docs/programmable/784383/24-1/about-this-document.html](https://www.intel.com/content/www/us/en/docs/programmable/784383/24-1/about-this-document.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*IBM Support* : *How do I enable core* *dumps* : [https://www.ibm.com/support/pages/how-do-i-enable-core-dumps](https://www.ibm.com/support/pages/how-do-i-enable-core-dumps)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Core Dumps – How to enable* *them?* : [https://medium.com/@sourabhedake/core-dumps-how-to-enable-them-73856a437711](mailto:https://medium.com/@sourabhedake/core-dumps-how-to-enable-them-73856a437711)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
