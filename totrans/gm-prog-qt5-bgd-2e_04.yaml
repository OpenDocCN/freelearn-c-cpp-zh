- en: Custom 2D Graphics with Graphics View
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图形视图进行自定义2D图形
- en: Widgets are great for designing graphical user interfaces, but they are not
    convenient if you want to use multiple objects with custom painting and behavior
    together, such as in a 2D game. You will also run into problems if you wish to
    animate multiple widgets at the same time, by constantly moving them around in
    the application. For these situations, or generally for frequently transforming
    2D graphics, Qt offers you Graphics View. In this chapter, you will learn the
    basics of the Graphics View architecture and its items. You will also learn how
    to combine widgets with Graphics View items.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件非常适合设计图形用户界面，但如果你想要一起使用具有自定义绘制和行为的多重对象，例如在2D游戏中，它们就不太方便了。如果你希望同时动画化多个小部件，通过在应用程序中不断移动它们，你也会遇到问题。在这些情况下，或者一般来说，对于经常变换2D图形的情况，Qt为你提供了图形视图。在本章中，你将学习图形视图架构及其项目的基础知识。你还将学习如何将小部件与图形视图项目结合使用。
- en: 'The main topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题如下：
- en: Graphics View architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形视图架构
- en: Coordinate systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐标系统
- en: Standard graphics items
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准图形项目
- en: Pens and brushes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔刷和画笔
- en: Useful features of Graphics View
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形视图的有用功能
- en: Creating custom items
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义项目
- en: Event handling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理
- en: Embedding widgets in the view
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图中嵌入小部件
- en: Optimizations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化
- en: Graphics View architecture
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形视图架构
- en: 'The Graphics View Framework is part of the Qt Widgets module and provides a
    higher level of abstraction useful for custom 2D graphics. It uses software rendering
    by default, but it is very optimized and extremely convenient to use. Three components
    form the core of Graphics View, as shown:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图形视图框架是Qt小部件模块的一部分，它提供了一个更高层次的抽象，这对于自定义2D图形非常有用。它默认使用软件渲染，但它非常优化，并且使用起来非常方便。如图所示，三个组件构成了图形视图的核心：
- en: An instance of `QGraphicsView`, which is referred to as **View**
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGraphicsView`的一个实例，被称为**视图**'
- en: An instance of `QGraphicsScene`, which is referred to as **Scene**
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGraphicsScene`的一个实例，被称为**场景**'
- en: Instances of `QGraphicsItem`, which are referred to as **Items**
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGraphicsItem`的实例，被称为**项目**'
- en: 'The usual workflow is to first create a couple of items, add them to a scene,
    and then show that scene on a view:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 常规的工作流程是首先创建几个项目，将它们添加到场景中，然后在一个视图中显示该场景：
- en: '![](img/6eb777be-ab33-4d5e-811b-a337b1ab917f.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6eb777be-ab33-4d5e-811b-a337b1ab917f.png)'
- en: After that, you can manipulate items from the code and add new items, while
    the user also has the ability to interact with visible items.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你可以从代码中操作项目并添加新项目，同时用户也有能力与可见项目进行交互。
- en: Think of the **items** as Post-it notes. You take a note and write a message
    on it, paint an image on it, both write and paint on it, or, quite possibly, just
    leave it blank. Qt provides a lot of item classes, all of which inherit `QGraphicsItem`.
    You can also create your own item classes. Each class must provide an implementation
    of the `paint()` function, which performs painting of the current item, and the `boundingRect()`
    function, which must return the boundary of the area the `paint()` function paints
    on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将**项目**视为便利贴。你可以拿一张便利贴并写上一条信息，画上一个图像，或者两者兼而有之，或者，很可能是直接留白。Qt提供了大量的项目类，所有这些类都继承自`QGraphicsItem`。你也可以创建自己的项目类。每个类都必须提供一个`paint()`函数的实现，该函数负责绘制当前项目，以及一个`boundingRect()`函数的实现，该函数必须返回`paint()`函数绘制的区域的边界。
- en: What is the **scene**, then? Well, think of it as a larger sheet of paper on
    to which you attach your smaller Post-its, that is, the notes. On the scene, you
    can freely move the items around while applying funny transformations to them.
    It is the scene's responsibility to correctly display the items' position and
    any transformations applied to them. The scene further informs the items about
    any events that affect them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，**场景**是什么呢？好吧，把它想象成一张更大的纸，你可以在上面贴上你的小便利贴，也就是笔记。在场景上，你可以自由地移动项目，并对它们应用有趣的变换。正确显示项目的位置和对其应用的任何变换是场景的责任。场景还会通知项目任何影响它们的事件。
- en: Last, but not least, let's turn our attention to the **view**. Think of the
    view as an inspection window or a person who holds the paper with the notes in
    their hands. You can see the paper as a whole, or you can only look at specific
    parts. Also, as a person can rotate and shear the paper with their hands, so the
    view can rotate and shear the scene's content and do a lot more transformations
    with it. `QGraphicsView` is a widget, so you can use the view like any other widget
    and place it into layouts for creating neat graphical user interfaces.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，让我们把注意力转向 **视图**。将视图想象成一个检查窗口或一个人，他手里拿着带有笔记的纸张。你可以看到整个纸张，或者你只能看到特定的部分。此外，正如一个人可以用手旋转和剪切纸张一样，视图也可以旋转和剪切场景的内容，并对其进行更多变换。`QGraphicsView`
    是一个小部件，因此你可以像使用任何其他小部件一样使用视图，并将其放入布局中，以创建整洁的图形用户界面。
- en: You might have looked at the preceding diagram and worried about all the items
    being outside the view. Aren't they wasting CPU time? Don't you need to take care
    of them by adding a so-called *view frustum culling* mechanism (to detect which
    item not to draw/render because it is not visible)? Well, the short answer is
    "no", because Qt is already taking care of this.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看过前面的图表，并担心所有项目都在视图之外。它们不是在浪费 CPU 时间吗？你不需要通过添加所谓的 *视图视锥剔除* 机制（检测哪些项目不需要绘制/渲染因为它不可见）来照顾它们吗？嗯，简短的答案是“不”，因为
    Qt 已经在处理这个问题了。
- en: Time for action – Creating a project with a Graphics View
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践时间 - 使用图形视图创建项目
- en: Let's put all these components together in a minimalistic project. From the
    Welcome screen, click on the New Project button and select Qt Widgets Application
    again. Name the project `graphics_view_demo`, select the correct kit, uncheck
    the Generate form checkbox, and finish the wizard. We don't actually need the
    `MainWindow` class that was generated for us, so let's delete it from the project.
    In the project tree, locate `mainwindow.h` and select Remove file in the context
    menu. Enable the Delete file permanently checkbox and click on OK. This will result
    in deleting the `mainwindow.h` file from the disk and removing its name from the `graphics_view_demo.pro`
    file. If the file was open in Qt Creator, it will suggest that you close it. Repeat
    the process for `mainwindow.cpp`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有这些组件组合在一个简约的项目中。从欢迎屏幕，点击新建项目按钮，再次选择 Qt Widgets 应用程序。将项目命名为 `graphics_view_demo`，选择正确的工具包，取消选择“生成表单”复选框，完成向导。实际上我们不需要为我们生成的
    `MainWindow` 类，所以让我们从项目中删除它。在项目树中定位 `mainwindow.h`，并在上下文菜单中选择“移除文件”。启用“永久删除文件”复选框，然后点击确定。这将导致从磁盘删除
    `mainwindow.h` 文件，并从 `graphics_view_demo.pro` 文件中删除其名称。如果文件在 Qt Creator 中打开，它将建议你关闭它。为
    `mainwindow.cpp` 重复此过程。
- en: 'Open the `main.cpp` file, remove `#include "mainwindow.h"`, and write the following
    code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `main.cpp` 文件，删除 `#include "mainwindow.h"`，并编写以下代码：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you run the project, you should get the following result:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行项目时，你应该得到以下结果：
- en: '![](img/8bcc98a5-4f2e-4bc6-b1fd-c80d34c92bde.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bcc98a5-4f2e-4bc6-b1fd-c80d34c92bde.png)'
- en: What just happened?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: 'Our new project is so simple that all its code is located in the `main()` function.
    Let''s examine the code. First, we create a `QApplication` object, as in any Qt
    Widgets project. Next, we create a scene object and three instances of different
    item classes. The constructor of each item class accepts an argument that defines
    the content of the item:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新项目非常简单，所有代码都位于 `main()` 函数中。让我们检查一下代码。首先，我们创建一个 `QApplication` 对象，就像在任何
    Qt Widgets 项目中一样。接下来，我们创建一个场景对象和三个不同项目类的实例。每个项目类的构造函数接受一个参数，用于定义项目的内容：
- en: The `QGraphicsRectItem` constructor receives a `QRectF` object that contains
    the coordinates of the rectangle
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGraphicsRectItem` 构造函数接收一个 `QRectF` 对象，其中包含矩形的坐标'
- en: The `QGraphicsEllipseItem` constructor, similarly, receives a `QRectF` object
    that defines the bounding rectangle of the circle
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与此类似，`QGraphicsEllipseItem` 构造函数接收一个 `QRectF` 对象，该对象定义了圆的边界矩形
- en: The `QGraphicsSimpleTextItem` constructor receives the text to display
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGraphicsSimpleTextItem` 构造函数接收要显示的文本'
- en: '`QRectF` is basically a helpful struct with four fields that allow us to specify
    four coordinates of the rectangle''s boundaries (left, top, width, and height).
    Qt also offers `QPointF` that contains *x* and *y* coordinates of a point, `QLineF`
    that contains *x* and *y* coordinates of two ends of a line, and `QPolygonF` that
    contains a vector of points. The `F` letter stands for "floating point" and indicates
    that these classes hold real numbers. They are widely used in Graphics View, as
    it always works with floating point coordinates. The corresponding classes without
    `F` (`QPoint`, `QRect`, and so on) store integer coordinates and are more useful
    when working with widgets.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`QRectF`基本上是一个包含四个字段的实用结构，允许我们指定矩形的边界坐标（左、上、宽和高）。Qt还提供了`QPointF`，它包含点的*x*和*y*坐标，`QLineF`包含线的两个端点的*x*和*y*坐标，以及`QPolygonF`，它包含点的向量。`F`字母代表“浮点”并表明这些类包含实数。它们在图形视图中被广泛使用，因为它始终使用浮点坐标。没有`F`的对应类（如`QPoint`、`QRect`等）存储整数坐标，并且在处理小部件时更有用。'
- en: After creating each item, we use the `QGraphicsScene::addItem` function to add
    the item to the scene. Finally, we create a `QGraphicsView` object and pass the
    pointer to the scene to its constructor. The `show()` method will make the view
    visible, as it does for any `QWidget`. The program ends with an `a.exec()` call,
    necessary to start the event loop and keep the application alive.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建每个项目后，我们使用`QGraphicsScene::addItem`函数将项目添加到场景中。最后，我们创建一个`QGraphicsView`对象，并将场景的指针传递给其构造函数。`show()`方法将使视图可见，就像对任何`QWidget`一样。程序以`a.exec()`调用结束，这是必要的，以启动事件循环并保持应用程序运行。
- en: The scene takes ownership of the items, so they will be automatically deleted
    along with the scene. This also means that an item can only be added to one single
    scene. If the item was previously added to another scene, it gets removed from
    there before it is added to the new scene.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 场景会接管项目，因此它们将随着场景的删除而自动删除。这也意味着一个项目只能添加到一个场景中。如果项目之前被添加到另一个场景中，它将在添加到新场景之前从那里移除。
- en: If you want to remove an item from a scene without setting it directly to another
    scene or without deleting it, you can call `scene.removeItem(rectItem)`. Be aware,
    however, that now it is your responsibility to delete `rectItem` to free the allocated
    memory!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从场景中移除一个项目，而不直接将其设置到另一个场景或删除它，你可以调用`scene.removeItem(rectItem)`。然而，请注意，现在你有责任删除`rectItem`以释放分配的内存！
- en: 'Examine the resulting window and compare it to the coordinates of the rectangles
    in the code (the `QRectF` constructor we use accepts four arguments in the following
    order: left, top, width, height). You should be able to see that all three elements
    are positioned in a single coordinate system, where the *x* axis points to the
    right and the *y* axis points down. We didn''t specify any coordinates for the
    text item, so it''s displayed at the **origin** point (that is, the point with
    zero coordinates), next to the top-left corner of the rectangle. However, that
    (0, 0) point does not correspond to the top-left corner of the window. In fact,
    if you resize the window, you''ll note that the origin has shifted relative to
    the window, because the view tries to display the scene''s content as centered.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 检查生成的窗口并将其与代码中矩形的坐标进行比较（我们使用的`QRectF`构造函数接受以下顺序的四个参数：左、上、宽、高）。你应该能够看到所有三个元素都位于一个坐标系统中，其中*x*轴指向右，*y*轴指向下。我们没有为文本项目指定任何坐标，因此它显示在**原点**（即坐标为零的点）旁边，位于矩形的左上角。然而，这个（0，0）点并不对应于窗口的左上角。实际上，如果你调整窗口大小，你会注意到原点相对于窗口发生了偏移，因为视图试图将场景内容居中显示。
- en: Coordinate systems
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坐标系统
- en: To use Graphics View correctly, you need to understand how the coordinate systems
    in this framework work. We'll go through all the levels of hierarchy and see how
    we can change the positioning of items and the whole scene, on each level. We
    will provide examples of the code that you can paste into our demo project and
    examine the effect.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用图形视图，你需要了解这个框架中坐标系统的工作原理。我们将遍历所有层次，看看我们如何在每个层次上改变项目位置和整个场景的位置。我们将提供你可以粘贴到我们的演示项目中的代码示例，并检查其效果。
- en: The item's coordinate system
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目的坐标系
- en: Each item has its own coordinate system. In our example of Post-it notes, the
    content of each note is defined relative to the top-left corner of the note. No
    matter how you move or rotate the item, these coordinates remain the same. The
    coordinates of a drawn object can usually be passed to the constructor of the
    class, like we did in our demo project, or to a special setter function (for example, `rectItem->setRect(0,
    10, 20, 25)`). These are coordinates in the item's coordinate system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都有自己的坐标系。在我们的便签示例中，每张便签的内容是相对于便签的左上角定义的。无论你如何移动或旋转项目，这些坐标都保持不变。绘制对象的坐标通常可以传递给类的构造函数，就像我们在我们的演示项目中做的那样，或者传递给一个特殊的设置函数（例如，`rectItem->setRect(0,
    10, 20, 25)`）。这些是在项目坐标系中的坐标。
- en: Some classes, such as `QGraphicsSimpleTextItem`, do not provide the ability
    to change the coordinates of the content, so they're always positioned at the
    origin of the item's coordinate system. This is not a problem at all; as we'll
    see next, there are ways to change the visible position of the content.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类，例如 `QGraphicsSimpleTextItem`，不提供更改内容坐标的能力，因此它们始终位于项目坐标系的起点。这根本不是问题；正如我们接下来将要看到的，有方法可以更改内容的可见位置。
- en: If you try to create your own graphics item class (we'll get to it later in
    this chapter), you'll need to implement the `paint()` and `boundingRect()` functions,
    and they always operate in the item's coordinate system. That's right, when you're
    painting the content, you can just pretend that your item will never be moved
    or transformed. When that actually happens, Qt will take care of transforming
    paint operations for you. Additionally, coordinates in any events the item receives
    (for example, coordinates of a mouse button click) are expressed in the item's
    coordinate system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试创建自己的图形项目类（我们将在本章后面讨论这个问题），你需要实现 `paint()` 和 `boundingRect()` 函数，并且它们总是在项目的坐标系中操作。没错，当你绘制内容时，你只需假装你的项目永远不会移动或变换。当这实际上发生时，Qt
    会为你处理绘制操作的变换。此外，项目接收到的任何事件中的坐标（例如，鼠标按钮点击的坐标）都是以项目的坐标系表示的。
- en: The scene's coordinate system
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景的坐标系
- en: Any item can be moved in the scene using the `setPos()` function. Try to call
    `textItem->setPos(50, 50)` and verify that the text was moved in the scene. Technically,
    this operation changes the **transformation** between the item's coordinate system
    and the scene's coordinate system. A convenience function called `moveBy()` allows
    you to shift the position by specified amounts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 任何项目都可以使用 `setPos()` 函数在场景中移动。尝试调用 `textItem->setPos(50, 50)` 并验证文本是否在场景中移动。技术上，这个操作改变了项目坐标系和场景坐标系之间的**变换**。一个名为
    `moveBy()` 的便利函数允许你通过指定的量移动位置。
- en: An item can also be rotated with `setRotation()` and scaled with `setScale()`.
    Try calling `textItem->setRotation(20)` to see this in action. If you need a more
    advanced transformation, such as shearing, or you want to perform multiple translations
    in a particular order, you can create a `QTransform` object, apply the required
    transformations, and use the `setTransform()` function of the item.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 项目也可以使用 `setRotation()` 旋转，并使用 `setScale()` 缩放。尝试调用 `textItem->setRotation(20)`
    来查看这个动作。如果你需要更高级的变换，例如剪切，或者你想要以特定的顺序执行多个平移，你可以创建一个 `QTransform` 对象，应用所需的变换，并使用项目的
    `setTransform()` 函数。
- en: The `setRotation()` function accepts `qreal` as the argument value, which is
    usually a typedef for `double`. The function interprets the number as degrees
    for a clockwise rotation around the *z* coordinate. If you set a negative value,
    a counter-clockwise rotation is performed. Even if it does not make much sense,
    you can rotate an item by 450 degrees, which will result in a rotation of 90 degrees.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`setRotation()` 函数接受 `qreal` 作为参数值，这通常是对 `double` 的 typedef。该函数将数字解释为围绕 *z*
    坐标的顺时针旋转的度数。如果你设置一个负值，则执行逆时针旋转。即使这没有太多意义，你也可以通过 450 度旋转一个项目，这将导致 90 度的旋转。'
- en: The viewport's coordinate system
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视口坐标系统
- en: The view consists of the **viewport** and two scrollbars. The viewport is a
    subwidget that actually contains the content of the scene. The view performs conversion
    from the scene coordinates to the viewport coordinates based on multiple parameters.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 视图由 **视口** 和两个滚动条组成。视口是一个子小部件，实际上包含场景的内容。视图根据多个参数执行从场景坐标到视口坐标的转换。
- en: First, the view needs to know the bounding rectangle of everything we could
    want to see in the scene. It's called the **scene rect** and is measured in the
    scene's coordinate system. By default, the scene rect is the bounding rectangle
    of all items that were added at the scene since it was created. This is usually
    fine, but if you move or delete an item, that bounding rectangle will not shrink
    (because of performance reasons), so it may result in showing a lot of unwanted
    empty space. Luckily, in such cases, you can set the scene rect manually using
    the `setSceneRect` function of the scene or view.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，视图需要知道场景中我们想要看到的每一项的边界矩形。它被称为**场景矩形**，在场景坐标系中进行测量。默认情况下，场景矩形是自创建以来添加到场景的所有项的边界矩形。这通常没问题，但如果移动或删除一个项，该边界矩形不会缩小（由于性能原因），这可能会导致显示大量不想要的空白空间。幸运的是，在这种情况下，你可以使用场景或视图的`setSceneRect`函数手动设置场景矩形。
- en: The difference between `QGraphicsScene::setSceneRect` and `QGraphicsView::setSceneRect`
    is usually marginal, since you will typically have one view per scene. However,
    it is possible to have multiple views for a single scene. In this case, `QGraphicsScene::setSceneRect`
    sets the scene rect for all views, and `QGraphicsView::setSceneRect` allows you
    to override the scene rect for each view.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGraphicsScene::setSceneRect`和`QGraphicsView::setSceneRect`之间的区别通常很小，因为你通常每个场景只有一个视图。然而，对于单个场景，可能存在多个视图。在这种情况下，`QGraphicsScene::setSceneRect`为所有视图设置场景矩形，而`QGraphicsView::setSceneRect`允许你为每个视图覆盖场景矩形。'
- en: If the area corresponding to the scene rect is small enough to fit in the viewport,
    the view will align the content according to the view's `alignment` property.
    As we saw earlier, it positions the content at the center by default. For example,
    calling `view.setAlignment(Qt::AlignTop | Qt::AlignLeft)` will result in the scene
    staying in the upper-left corner of the view.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对应场景矩形的区域足够小，可以适应视口，视图将根据视图的`alignment`属性对内容进行对齐。如我们之前所见，默认情况下它将内容置于中心。例如，调用`view.setAlignment(Qt::AlignTop
    | Qt::AlignLeft)`将导致场景保持在视图的左上角。
- en: If the scene rect area is too large to fit in the viewport, the horizontal or
    vertical scrollbars appear by default. They can be used to scroll the view and
    see any point inside the scene rect (but not beyond it). The presence of scrollbars
    can also be configured using the  `horizontalScrollBarPolicy` and the `verticalScrollBarPolicy`
    properties of the view.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果场景矩形区域太大，无法适应视口，则默认会显示水平或垂直滚动条。可以使用它们来滚动视图并查看场景矩形内的任何点（但不超过它）。滚动条的存在也可以通过视图的`horizontalScrollBarPolicy`和`verticalScrollBarPolicy`属性进行配置。
- en: Try to call `scene.setSceneRect(0, 20, 100, 100)` and see how the view acts
    when resizing the window. If the window is too small, the top part of the scene
    will no longer be visible. If the window is large enough and the view has the
    default alignment, the top part of the scene will be visible, but only the defined
    scene rect will be centered, with no regard to the items outside of it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调用`scene.setSceneRect(0, 20, 100, 100)`并查看在调整窗口大小时视图的行为。如果窗口太小，场景的顶部将不再可见。如果窗口足够大且视图具有默认对齐方式，场景的顶部将可见，但只有定义的场景矩形将居中，不考虑其外的项。
- en: The view provides the ability to transform the entire scene. For example, you
    can call `view.scale(5, 5)` to make everything five times larger, `view.rotate(20)`
    to rotate the scene as a whole, or `view.shear(1, 0)` to shear it. As with items,
    you can apply a more complex transformation using `setTransform()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 视图提供了转换整个场景的能力。例如，你可以调用`view.scale(5, 5)`使一切放大五倍，`view.rotate(20)`整体旋转场景，或`view.shear(1,
    0)`进行剪切。与项目一样，你可以使用`setTransform()`方法应用更复杂的转换。
- en: You may note that Graphics View (and Qt Widgets in general) uses a **left-handed**
    coordinate system by default, where *x* axis points right and *y* axis points
    down. However, OpenGL and science-related applications usually use a **right-handed**
    or standard coordinate system, where *y* axis points up. If you need to change
    the direction of the *y* axis, the simplest solution is to transform the view
    by calling `view.scale(1, -1)`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，图形视图（以及Qt小部件通常）默认使用**左手坐标系**，其中*x*轴指向右，*y*轴指向下。然而，OpenGL和科学相关应用程序通常使用**右手**或标准坐标系，其中*y*轴向上。如果你需要改变*y*轴的方向，最简单的解决方案是通过调用`view.scale(1,
    -1)`来变换视图。
- en: Origin point of the transformation
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变换的原点
- en: 'In our next example, we will create a cross at (0, 0) point and add a rectangle
    to the scene:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个示例中，我们将在(0, 0)点创建一个十字形，并将一个矩形添加到场景中：
- en: '![](img/29c10c5a-6843-4284-88d8-08444454723b.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29c10c5a-6843-4284-88d8-08444454723b.png)'
- en: 'You can do it with the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用以下代码做到这一点：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code, we use the `addLine()` and `addRect()` convenience functions.
    This is the same as creating a `QGraphicsLineItem` or `QGraphicsRectItem` and
    adding it to the scene manually.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用了`addLine()`和`addRect()`便利函数。这相当于手动创建一个`QGraphicsLineItem`或`QGraphicsRectItem`并将其添加到场景中。
- en: 'Now, imagine that you want to rotate the rectangle by 45 degrees to produce
    the following result:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想要将矩形旋转45度以产生以下结果：
- en: '![](img/b9f23d56-4ce9-44ac-9718-77d4cfb7be27.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9f23d56-4ce9-44ac-9718-77d4cfb7be27.png)'
- en: 'A straightforward attempt to do it will use the `setRotation()` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 直接尝试这样做将使用`setRotation()`方法：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, if you try to do that, you will get the following result:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试这样做，你将得到以下结果：
- en: '![](img/de15be54-8700-4b6f-beb0-8a9516a4baf2.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de15be54-8700-4b6f-beb0-8a9516a4baf2.png)'
- en: What just happened?
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Most transformations depend on the **origin** point of the coordinate system.
    For rotation and scaling, the origin point is the only point that remains in place.
    In the preceding example, we used a rectangle with the top-left corner at (50,
    50) and the size of (50, 50). These coordinates are in the item's coordinate system.
    Since we originally didn't move the item, the item's coordinate system was the
    same as the scene's coordinate system, and the origin point is the same as the
    scene's origin (it's the point marked with the cross). The applied rotation uses
    (0, 0) as the center of rotation, thus providing an unexpected result.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数变换都依赖于坐标系的**原点**。对于旋转和缩放，原点是唯一保持不变的点。在上面的例子中，我们使用了一个左上角在(50, 50)且大小为(50,
    50)的矩形。这些坐标是在项目的坐标系中。由于我们最初没有移动项目，项目的坐标系与场景的坐标系相同，原点也与场景的原点相同（它是以十字标记的点）。应用的旋转使用(0,
    0)作为旋转中心，因此产生了意想不到的结果。
- en: 'There are multiple ways to overcome this problem. The first way is to change
    the transform''s origin point:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以克服这个问题。第一种方法是改变变换的原点：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code produces the rotation we want, because it changes the origin point
    used by the `setRotation()` and `setScale()` functions. Note that the item's coordinate
    system was not translated, and (75, 75) point continues to be the center of the
    rectangle in the item's coordinates.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生了我们想要的旋转，因为它改变了`setRotation()`和`setScale()`函数使用的原点。注意，项目的坐标系没有被平移，并且(75,
    75)点在项目的坐标系中仍然是矩形的中心。
- en: 'However, this solution has its limitations. If you use `setTransform()` instead
    of `setRotation()`, you will get the unwanted result again:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个解决方案有其局限性。如果你使用`setTransform()`而不是`setRotation()`，你将再次得到不想要的结果：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Another solution is to set up the rectangle in such a way that its center is
    in the origin of the item''s coordinate system:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是将矩形设置得使其中心位于项目坐标系的原点：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code uses completely different rectangle coordinates, but the result is
    exactly the same as in our first example. However, now, (75, 75) point in the
    scene''s coordinates corresponds to (0, 0) point in the item''s coordinates, so
    all transformations will use it as the origin:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用完全不同的矩形坐标，但结果与我们的第一个例子完全相同。然而，现在，场景坐标中的(75, 75)点对应于项目坐标中的(0, 0)点，因此所有变换都将使用它作为原点：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example shows that it is usually more convenient to set up the items so
    that their origin point corresponds to their actual location.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，通常更方便将项目设置得使其原点对应于其实际位置。
- en: Have a go hero – Applying multiple transformations
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄——应用多个变换
- en: To understand the concept of transformations and their origin point, try to
    apply `rotate()` and `scale()` to an item. Also, change the point of origin and
    see how the item will react. As a second step, use `QTransform` in conjunction
    with `setTransform()` to apply multiple transformations to an item in a specific
    order.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解变换及其原点的概念，尝试对一个项目应用`rotate()`和`scale()`。然后，改变原点并看看项目将如何反应。作为第二步，使用`QTransform`与`setTransform()`结合，以特定顺序对一个项目应用多个变换。
- en: Parent–child relationship between items
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目之间的父子关系
- en: Imagine that you need to create a graphics item that contains multiple geometric
    primitives, for example, a circle inside a rectangle. You can create both items
    and add them to the scene individually, but this solution is inconvenient. First,
    when you need to remove that combination from the scene, you would need to manually
    delete both items. However, more importantly, when you need to move or transform
    the combination, you will need to calculate positions and complex transformations
    for each graphics item.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要创建一个包含多个几何原型的图形项，例如，矩形内部的圆。您可以单独创建这两个项目并将它们添加到场景中，但这种方法不方便。首先，当您需要从场景中删除该组合时，您需要手动删除这两个项目。然而，更重要的是，当您需要移动或变换该组合时，您将需要为每个图形项计算位置和复杂的变换。
- en: 'Fortunately, graphics items do not have to be a flat list of items added directly
    into the scene. Items can be added into any other items, forming a parent–child
    relationship very similar to the relationship of `QObject` that we observed in
    the last chapter:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，图形项不必是直接添加到场景中的扁平项目列表。项目可以被添加到任何其他项目中，形成一个类似于我们在上一章中观察到的 `QObject` 关系的父子关系：
- en: '![](img/a5c4acc7-403c-40cc-a181-ea784a629bfa.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5c4acc7-403c-40cc-a181-ea784a629bfa.png)'
- en: 'Adding an item as a child of another item has the following consequences:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个项目作为另一个项目的子项具有以下后果：
- en: When the parent item is added to the scene, the child item automatically becomes
    part of that scene, so there is no need to call `QGraphicsScene::addItem()` for
    it.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当父项被添加到场景中时，子项自动成为该场景的一部分，因此不需要为它调用 `QGraphicsScene::addItem()`。
- en: When the parent item is deleted, its children are also deleted.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当父项被删除时，其子项也会被删除。
- en: When the parent item is hidden using the `hide()` or `setVisible(false)` functions,
    the child items will also be hidden.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `hide()` 或 `setVisible(false)` 函数隐藏父项时，子项也会被隐藏。
- en: Most importantly, the child's coordinate system is derived from the parent's
    coordinate system instead of the scene's. This means that when the parent is moved
    or transformed, all children are also affected. The child's position and transformations
    are relative to the parent's coordinate system.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，子项的坐标系是从父项的坐标系派生出来的，而不是从场景的坐标系。这意味着当父项被移动或变换时，所有子项也会受到影响。子项的位置和变换相对于父项的坐标系。
- en: You can always check whether an item has a parent using the `parentItem()` function,
    and check the returned `QGraphicsItem` pointer against `nullptr`, which means
    that the item does not have a parent. To figure out whether there are any children,
    call the `childItems()` function on the item. A `QList` method with the `QGraphicsItem`
    pointers to all child items is returned.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `parentItem()` 函数始终检查一个项目是否有父项，并通过比较返回的 `QGraphicsItem` 指针与 `nullptr`
    来检查，这意味着该项目没有父项。要确定是否有任何子项，请在项目上调用 `childItems()` 函数。该方法返回一个包含所有子项 `QGraphicsItem`
    指针的 `QList`。
- en: 'For a better understanding of `pos()` and the involved coordinate systems,
    think of post-it notes again. If you put a note on a larger sheet of paper and
    then had to determine its exact position, how would you do it? Probably like this:
    "The note''s upper-left corner is positioned 3 cm to the right and 5 cm to the
    bottom from the paper''s top-left edge". In the Graphics View world, this will
    correspond to a parentless item whose `pos()` function returns a position in the
    scene coordinates, since the item''s origin is directly pinned to the scene. On
    the other hand, say you put a note A on top of a (larger) note B, which is already
    pinned on a paper, and you have to determine A''s position; how would you describe
    it this time? Probably by saying that note A is placed on top of note B or "2
    cm to the right and 1 cm to the bottom from the top-left edge of note B". You
    most likely wouldn''t use the underlying paper as a reference since it is not
    the next point of reference. This is because if you move note B, A''s position
    regarding the paper will change, whereas A''s relative position to B still remains
    unchanged. To switch back to Graphics View, the equivalent situation is an item
    that has a parent item. In this case, the `pos()` function''s returned value is
    expressed in the coordinate system of its parent. So, `setPos()` and `pos()` specify
    the position of the item''s origin in relation to the next (higher) point of reference.
    This can be the scene or the item''s parent item.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解`pos()`及其涉及的坐标系，再次想想便利贴。如果你在一张更大的纸上贴上一张便利贴，然后需要确定它的确切位置，你会怎么做？可能像这样：“便利贴的左上角位于纸张左上角的右边3厘米和下面5厘米处”。在图形视图世界中，这将对应该没有父项的项，其`pos()`函数返回场景坐标中的位置，因为项的原点直接固定到场景中。另一方面，假设你在已经贴在纸上的（更大的）便利贴B的上面贴上便利贴A，你需要确定A的位置；这次你会怎么描述它？可能通过说便利贴A放在便利贴B的上面，或者“从便利贴B的左上角右边2厘米和下面1厘米处”。你很可能不会使用底下的纸张作为参考，因为它不是下一个参考点。这是因为如果你移动便利贴B，A相对于纸张的位置会改变，而A相对于B的相对位置仍然保持不变。要切换回图形视图，等效的情况是一个具有父项的项。在这种情况下，`pos()`函数返回的值是在其父项的坐标系中表达的。因此，`setPos()`和`pos()`指定了项的原点相对于下一个（更高）参考点的位置。这可以是场景或项的父项。所以，`setPos()`和`pos()`指定了项的原点相对于下一个（更高）参考点的位置。这可以是场景或项的父项。
- en: Keep in mind, however, that changing an item's position does not affect the
    item's internal coordinate system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，改变项的位置不会影响项的内部坐标系。
- en: For widgets, the child always occupies a subarea of its direct parent. For graphics
    items, such a rule does not apply by default. A child item can be displayed outside
    the bounding rectangle or visible content of the parent. In fact, a common situation
    is when the parent item does not have any visual content by itself and only serves
    as a container for a set of primitives belonging to one object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小部件，子项始终占据其直接父项的子区域。对于图形项，默认情况下不适用这样的规则。子项可以显示在父项的边界矩形或可见内容之外。实际上，一个常见的情况是父项本身没有视觉内容，而只作为属于一个对象的一组原语集合的容器。
- en: Time for action – Using child items
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使用子项
- en: 'Let''s try to make an item containing multiple children. We want to create
    a rectangle with a filled circle in each corner and be able to move and rotate
    it as a whole, like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建一个包含多个子项的项。我们想要创建一个矩形，每个角落都有一个填充的圆，并且能够作为一个整体移动和旋转，如下所示：
- en: '![](img/94aa7f68-0fd5-43ec-bd98-c60c8da3a39b.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94aa7f68-0fd5-43ec-bd98-c60c8da3a39b.png)'
- en: 'First, you need to create a function that creates a single complex rectangle,
    by using the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个函数，通过以下代码创建一个单个复杂矩形：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We start with creating a `QRectF` variable that contains the rectangle coordinates
    in the item's coordinate system. Following the tip we provided earlier, we create
    a rectangle centered at the origin point. Next, we create a rectangle graphics
    item called `parent`, as usual. The `circleBoundary` rectangle is set to contain
    the boundary rect of a single circle (again, the center is at the origin point).
    When we create a new `QGraphicsEllipseItem` for each corner, we pass `parent`
    to the constructor, so the new circle item is automatically added as a child of
    the rectangle item.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个包含矩形坐标的`QRectF`变量，这些坐标位于项目的坐标系中。按照我们之前提供的提示，我们创建一个以原点为中心的矩形。接下来，我们创建一个通常称为`parent`的矩形图形项。将`circleBoundary`矩形设置为包含单个圆的边界矩形（再次强调，中心位于原点）。当我们为每个角落创建一个新的`QGraphicsEllipseItem`时，我们将`parent`传递给构造函数，因此新的圆形项自动成为矩形项的子项。
- en: To set up a child circle, we first use the `setBrush()` function that enables
    filling of the circle. This function expects a `QBrush` object that allows you
    to specify an advanced filling style, but in our simple case, we use an implicit
    conversion from the `Qt::GlobalColor` enum to `QBrush`. You will learn more about
    brushes later in this chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置子圆，我们首先使用 `setBrush()` 函数，该函数允许填充圆。此函数期望一个 `QBrush` 对象，允许你指定高级填充样式，但在我们的简单情况下，我们使用从
    `Qt::GlobalColor` 枚举到 `QBrush` 的隐式转换。你将在本章的后面部分了解更多关于画笔的信息。
- en: Next, we select a different corner of the rectangle for each circle and call
    `setPos()` to move the circle to that corner. Finally, we return the parent item
    to the caller.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为每个圆选择矩形的不同角落，并调用 `setPos()` 将圆移动到该角落。最后，我们将父项目返回给调用者。
- en: 'You can use this function as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用此函数如下：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that when you call `setPos()`, the circles are moved along with the parent
    item, but the `pos()` values of the circles do not change. This is the consequence
    of the fact that `pos()` means the position relative to the parent item (or the
    scene's origin, if there is no parent item). When the rectangle is rotated, circles
    rotate with it, as if they were fixed to the corners. If the circles weren't children
    of the rectangle, positioning them properly, in this case, would be a more challenging
    task.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你调用 `setPos()` 时，圆会随着父项目一起移动，但圆的 `pos()` 值不会改变。这是由于 `pos()` 表示相对于父项目（或如果没有父项目，则为场景的起点）的位置的事实。当矩形旋转时，圆会随着它一起旋转，就像它们被固定在角落一样。如果圆不是矩形的子项，在这个情况下，正确定位它们将是一个更具挑战性的任务。
- en: Have a go hero – Implementing the custom rectangle as a class
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 英雄尝试一下 - 将自定义矩形作为类实现
- en: In this example, we avoided creating a class for our custom rectangle to keep
    the code as simple as possible. Following the principles of object-oriented programming,
    subclassing `QGraphicsRectItem` and creating children items in the constructor
    of the new class is a good idea. Doing this doesn't require anything you don't
    already know. For example, when subclassing `QGraphicsRectItem`, you don't need
    to implement any virtual functions, because they are all properly implemented
    in the base classes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为了避免创建自定义矩形的类，使代码尽可能简单。遵循面向对象编程的原则，在新的类的构造函数中子类化 `QGraphicsRectItem`
    并创建子项目是一个好主意。这样做不需要你不知道的任何东西。例如，当子类化 `QGraphicsRectItem` 时，你不需要实现任何虚拟函数，因为它们都在基类中得到了适当的实现。
- en: Conversions between coordinate systems
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坐标系之间的转换
- en: 'If an item is simply moved using `setPos()`, conversion from the item''s coordinates
    to the scene coordinates is as simple as `sceneCoord = itemCoord + item->pos()`.
    However, this conversion quickly becomes very complex when you use transformations
    and parent–child relationships, so you should always use dedicated functions to
    perform such conversions. `QGraphicsItem` provides the following functions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个项目仅使用 `setPos()` 移动，则从项目坐标到场景坐标的转换就像 `sceneCoord = itemCoord + item->pos()`
    那样简单。然而，当你使用变换和父子关系时，这种转换很快就会变得非常复杂，因此你应该始终使用专用函数来执行此类转换。`QGraphicsItem` 提供以下函数：
- en: '| **Function** | **Description** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '|  `mapToScene(`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '|  `mapToScene(`'
- en: '`  const QPointF &point)` | Maps the point `point` that is in the item''s coordinate
    system to the corresponding point in the scene''s coordinate system. |'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`  const QPointF &point)` | 将项目坐标系中的点 `point` 映射到场景坐标系中的对应点。|'
- en: '| `scenePos()` | Maps the item''s origin point to the scene''s coordinate system.
    This is the same as `mapToScene(0, 0)`. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `scenePos()` | 将项目的原点映射到场景坐标系。这与 `mapToScene(0, 0)` 相同。|'
- en: '| `sceneBoundingRect()` | Returns the item''s bounding rectangle in the scene''s
    coordinate system. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `sceneBoundingRect()` | 返回项目在场景坐标系中的边界矩形。|'
- en: '| `mapFromScene(` `  const QPointF &point)` | Maps the point `point` that is
    in the scene''s coordinate system to the corresponding point in the item''s coordinate
    system. This function is the reverse function to `mapToScene()`. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `mapFromScene(` `  const QPointF &point)` | 将场景坐标系中的点 `point` 映射到项目坐标系中的对应点。此函数是
    `mapToScene()` 的逆函数。|'
- en: '| `mapToParent(` `  const QPointF &point)` | Maps the point `point` that is
    in the item''s coordinate system to the corresponding point in the coordinate
    system of the item''s parent. If the item does not have a parent, this function
    behaves like `mapToScene()`; thus, it returns the corresponding point in the scene''s
    coordinate system. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `mapFromParent(` `  const QPointF &point)` 将位于项目坐标系统中的点 `point` 映射到项目父级坐标系统中的对应点。如果项目没有父级，此函数的行为类似于
    `mapToScene()`；因此，它返回场景坐标系统中的对应点。|'
- en: '| `mapFromParent(` `  const QPointF &point)` | Maps the point `point` that
    is in the coordinate system of the item''s parent to the corresponding point in
    the item''s own coordinate system. This function is the reverse function to `mapToParent()`.
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `mapFromParent(` `  const QPointF &point)` 将位于项目父级坐标系统中的点 `point` 映射到项目自身坐标系统中的对应点。此函数是
    `mapToParent()` 的逆函数。|'
- en: '| `mapToItem(` `  const QGraphicsItem *item,`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '| `mapToItem(` `  const QGraphicsItem *item,`'
- en: '` const QPointF &point)` | Maps the point `point` that is in the item''s own
    coordinate system to the corresponding point in the coordinate system of the item
    `item`. |'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '` const QPointF &point)` 将位于项目自身坐标系统中的点 `point` 映射到项目 `item` 的坐标系统中的对应点。|'
- en: '| `mapFromItem(` `  const QGraphicsItem *item,`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '| `mapFromItem(` `  const QGraphicsItem *item,`'
- en: '` const QPointF  &point)` | Maps the point `point` that is in the coordinate
    system of the item `item` to the corresponding point in the item''s own coordinate
    system. This function is the reverse function to `mapToItem()`. |'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '` const QPointF  &point)` 将位于项目 `item` 坐标系统中的点 `point` 映射到项目自身坐标系统中的对应点。此函数是
    `mapToItem()` 的逆函数。'
- en: 'What is great about these functions is that they are not only available for
    `QPointF`. The same functions are also available for `QRectF`, `QPolygonF`, and
    `QPainterPath`, not to mention that there are some convenience functions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的伟大之处在于，它们不仅适用于 `QPointF`。相同的函数也适用于 `QRectF`、`QPolygonF` 和 `QPainterPath`，更不用说还有一些便利函数：
- en: If you call these functions with two numbers of the `qreal` type, the numbers
    are interpreted as the *x* and *y* coordinates of a `QPointF` pointer
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用两个 `qreal` 类型的数字调用这些函数，这些数字被解释为 `QPointF` 指针的 *x* 和 *y* 坐标
- en: If you call the functions with four numbers, the numbers are interpreted as
    the *x* and *y* coordinates and the width and height of a `QRectF` parameter
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用四个数字调用这些函数，这些数字被解释为 *x* 和 *y* 坐标以及 `QRectF` 参数的宽度和高度
- en: The `QGraphicsView` class also contains a set of `mapToScene()` functions that
    map coordinates from the viewport's coordinate system to the scene coordinates
    and `mapFromScene()` functions that map the scene coordinates to the viewport
    coordinates.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGraphicsView` 类还包含一组 `mapToScene()` 函数，这些函数将视口坐标系统的坐标映射到场景坐标，以及 `mapFromScene()`
    函数，这些函数将场景坐标映射到视口坐标。'
- en: Overview of functionality
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能概述
- en: You should now have some understanding of Graphics View's architecture and transformation
    mechanics. We will now describe some easy-to-use functionality that you'll probably
    need when creating a Graphics View application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该对 Graphics View 的架构和转换机制有所了解。我们将现在描述一些易于使用的功能，这些功能在创建 Graphics View 应用程序时您可能会用到。
- en: Standard items
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准项目
- en: 'In order to effectively use the framework, you need to know what graphics item
    classes it provides. It''s important to identify the classes you can use to construct
    the desirable picture and resort to creating a custom item class, only if there
    is no suitable item or you need better performance. Qt comes with the following
    standard items that make your life as a developer much easier:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用框架，您需要了解它提供的图形项目类。识别您可以使用来构建所需图片的类很重要，只有在没有合适的项目或您需要更好的性能时，才应创建自定义项目类。Qt
    提供以下标准项目，使您作为开发者的生活更加轻松：
- en: '| **Standard item** | **Description** |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **标准项目** | **描述** |'
- en: '| `QGraphicsLineItem` | Draws a line. You can define the line with `setLine(const
    QLineF&)`. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsLineItem` 绘制一条线。您可以使用 `setLine(const QLineF&)` 定义线。|'
- en: '| `QGraphicsRectItem` | Draws a rectangle. You can define the rectangle''s
    geometry with `setRect(const QRectF&)`. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsRectItem` 绘制一个矩形。您可以使用 `setRect(const QRectF&)` 定义矩形的几何形状。|'
- en: '| `QGraphicsEllipseItem` | Draws an ellipse or an ellipse segment. You can
    define the rectangle within which the ellipse is being drawn with `setRect(const
    QRectF&)`. Additionally, you can define whether only a segment of the ellipse
    should be drawn by calling `setStartAngle(int)` and `setSpanAngle(int)`. The arguments
    of both functions are in sixteenths of a degree. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsEllipseItem` | 绘制椭圆或椭圆段。您可以使用 `setRect(const QRectF&)` 定义绘制椭圆的矩形。此外，您还可以通过调用
    `setStartAngle(int)` 和 `setSpanAngle(int)` 定义是否只绘制椭圆的某一段。这两个函数的参数是以十六分之一度为单位。|'
- en: '| `QGraphicsPolygonItem` | Draws a polygon. You can define the polygon with
    `setPolygon(const QPolygonF&)`. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsPolygonItem` | 绘制多边形。您可以使用 `setPolygon(const QPolygonF&)` 定义多边形。|'
- en: '| `QGraphicsPathItem` | Draws a path, that is, a set of various geometric primitives.
    You can define the path with `setPath(const QPainterPath&)`. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsPathItem` | 绘制路径，即一组各种几何原语。您可以使用 `setPath(const QPainterPath&)`
    定义路径。|'
- en: '| `QGraphicsSimpleTextItem` | Draws plain text. You can define the text with
    `setText(const QString&)` and the font with `setFont(const QFont&)`. This item
    doesn''t support rich formatting. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsSimpleTextItem` | 绘制纯文本。您可以使用 `setText(const QString&)` 定义文本，并使用
    `setFont(const QFont&)` 定义字体。此项目不支持富格式化。|'
- en: '| `QGraphicsTextItem` | Draws formatted text. Unlike `QGraphicsSimpleTextItem`,
    this item can display HTML stored in a `QTextDocument` object. You can set HTML
    with `setHtml(const QString&)` and the document with `setDocument(QTextDocument*)`.
    `QGraphicsTextItem` can even interact with the displayed text so that text editing
    or URL opening is possible. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsTextItem` | 绘制格式化文本。与 `QGraphicsSimpleTextItem` 不同，此项目可以显示存储在 `QTextDocument`
    对象中的 HTML。您可以使用 `setHtml(const QString&)` 设置 HTML，并使用 `setDocument(QTextDocument*)`
    设置文档。`QGraphicsTextItem` 甚至可以与显示的文本交互，以便进行文本编辑或打开 URL。|'
- en: '| `QGraphicsPixmapItem` | Draws a pixmap (a raster image). You can define the
    pixmap with `setPixmap(const QPixmap&)`. It''s possible to load pixmaps from local
    files or resources, similar to icons (refer to [Chapter 3](ebffc011-752f-4dbe-a383-0917a002841d.xhtml),
    *Qt GUI Programming*, for more information about resources). |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsPixmapItem` | 绘制位图（一个光栅图像）。您可以使用 `setPixmap(const QPixmap&)` 定义位图。可以从本地文件或资源加载位图，类似于图标（有关资源的信息，请参阅第
    3 章，*Qt GUI 编程*）。|'
- en: '| `QGraphicsProxyWidget` | Draws an arbitrary `QWidget` and allows you to interact
    with it. You can set the widget with `setWidget(QWidget*)`. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `QGraphicsProxyWidget` | 绘制任意 `QWidget` 并允许您与之交互。您可以使用 `setWidget(QWidget*)`
    设置小部件。|'
- en: As we already saw, you can usually pass the content of the item to the constructor
    instead of calling a setter method such as `setRect()`. However, keep in mind
    that compact code may be harder to maintain than code that sets all the variables
    through setter methods.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，您通常可以将项目的内 容传递给构造函数，而不是调用 `setRect()` 等设置器方法。然而，请记住，紧凑的代码可能比通过设置器方法设置所有变量的代码更难维护。|
- en: For most items, you can also define which pen and which brush should be used.
    The pen is set with `setPen()` and the brush with `setBrush()` (we've already
    used it for the child circles in the previous example). These two functions, however,
    do not exist for `QGraphicsTextItem`. To define the appearance of a `QGraphicsTextItem`
    item, you have to use `setDefaultTextColor()` or HTML tags supported by Qt. `QGraphicsPixmapItem`
    has no similar methods, as the concepts of pen and brush cannot be applied to
    pixmaps.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数项目，您还可以定义应使用哪种笔和哪种画刷。笔通过 `setPen()` 设置，画刷通过 `setBrush()` 设置（我们已经在之前的示例中使用了它）。然而，这两个函数在
    `QGraphicsTextItem` 中不存在。要定义 `QGraphicsTextItem` 项目的外观，您必须使用 `setDefaultTextColor()`
    或 Qt 支持的 HTML 标签。`QGraphicsPixmapItem` 没有类似的方法，因为笔和画刷的概念不能应用于位图。|
- en: Use `QGraphicsSimpleTextItem` wherever possible and try to avoid `QGraphicsTextItem,`
    if it is not absolutely necessary. The reason is that `QGraphicsTextItem` is a
    subclass of `QObject` and uses `QTextDocument`, which is basically an HTML engine
    (although quite limited). This is way heavier than an average graphics item and
    is definitely too much overhead for displaying simple text.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能使用 `QGraphicsSimpleTextItem`，并尽量避免使用 `QGraphicsTextItem`，除非绝对必要。原因是 `QGraphicsTextItem`
    是 `QObject` 的子类，并使用 `QTextDocument`，这基本上是一个 HTML 引擎（尽管相当有限）。这比平均图形项目要重得多，并且对于显示简单文本来说，绝对是一个过大的开销。|
- en: 'It is generally easier to use standard items than to implement them from scratch.
    Whenever you will use Graphics View, ask yourself these questions: Which standard
    items are suited for my specific needs? Am I re-inventing the wheel over and over
    again? However, from time to time, you need to create custom graphics items, and
    we''ll cover this topic later in this chapter.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用标准项比从头开始实现它们更容易。每次你将使用 Graphics View 时，都要问自己这些问题：哪些标准项适合我的特定需求？我是不是一次又一次地重复造轮子？然而，有时你需要创建自定义图形项，我们将在本章的后面部分介绍这个主题。
- en: Anti-aliasing
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抗锯齿
- en: If you look at the result of the previous screenshot, you can probably note
    that the drawing looks pixelated. This happens because each pixel in a line is
    completely black, and all the surrounding pixels are completely white. The physical
    display's resolution is limited, but a technique called **anti-aliasing** allows
    you to produce more smooth images with the same resolution. When drawing a line
    with anti-aliasing, some pixels will be more or less blacker than others, depending
    on how the line crosses the pixel grid.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下上一张截图的结果，你可能会注意到绘图看起来是像素化的。这是因为线条中的每个像素都是完全黑色的，而所有周围的像素都是完全白色的。物理显示器的分辨率有限，但称为
    **抗锯齿** 的技术允许你以相同的分辨率产生更平滑的图像。当使用抗锯齿绘制线条时，一些像素会比其他像素更黑或更白，这取决于线条如何穿过像素网格。
- en: 'You can easily enable anti-aliasing in Graphics View using the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码轻松地在 Graphics View 中启用抗锯齿：
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the anti-aliasing flag turned on, the painting is done much more smoothly:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当开启抗锯齿标志时，绘制过程会更加平滑：
- en: '![](img/8e604129-e7ec-41fd-83f2-046bf4eb0d4c.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e604129-e7ec-41fd-83f2-046bf4eb0d4c.png)'
- en: 'However, lines in the rectangle on the left now look thicker. This happens
    because we used lines with integer coordinates and 1 pixel width. Such a line
    is located exactly on the border between two rows of pixels, and when anti-aliased,
    both adjacent rows of pixels will be partially painted. This can be fixed by adding
    0.5 to all coordinates:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，左侧矩形中的线条现在看起来更粗。这是因为我们使用了具有整数坐标和 1 像素宽度的线条。这样的线条正好位于像素行之间的边界上，当进行抗锯齿处理时，相邻的像素行将部分被绘制。这可以通过将所有坐标加
    0.5 来修复。
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now the line is positioned right in the middle of a pixel row, so it only occupies
    a single row:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在线条位于像素行的正中间，因此它只占用单行：
- en: '![](img/fee58494-72a0-401e-b359-2751ce199ed7.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fee58494-72a0-401e-b359-2751ce199ed7.png)'
- en: Another solution is to implement a custom item class and disable anti-aliasing
    when painting a horizontal or vertical line.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是在实现自定义项类时禁用绘制水平或垂直线时的抗锯齿。
- en: '`QGraphicsView` also supports the `QPainter::TextAntialiasing` flag that enables
    anti-aliasing when drawing text, and the `QPainter::SmoothPixmapTransform` flag
    that enables smooth pixmap transformation. Note the anti-aliasing and smoothing
    impact performance of your application, so use them only when needed.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGraphicsView` 也支持 `QPainter::TextAntialiasing` 标志，该标志在绘制文本时启用抗锯齿，以及 `QPainter::SmoothPixmapTransform`
    标志，该标志启用平滑位图变换。注意抗锯齿和平滑对应用程序性能的影响，因此仅在需要时使用它们。'
- en: Pens and brushes
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 笔刷和画笔
- en: 'The pen and brush are two attributes that define how different drawing operations
    are performed. The pen (represented by the `QPen` class) defines the outline,
    and the brush  (represented by the `QBrush` class) fills the drawn shapes. Each
    of them is really a set of parameters. The most simple one is the color defined,
    either as a predefined global color enumeration value (such as `Qt::red` or `Qt::transparent`),
    or an instance of the `QColor` class. The effective color is made up of four attributes:
    three color components (red, green, and blue) and an optional alpha channel value
    that determines the transparency of the color (the larger the value, the more
    opaque the color). By default, all components are expressed as 8-bit values (0
    to 255) but can also be expressed as real values representing a percentage of
    the maximum saturation of the component; for example, 0.6 corresponds to 153 (0.6⋅255).
    For convenience, one of the `QColor` constructors accepts hexadecimal color codes
    used in HTML (with `#0000FF` being an opaque blue color) or even bare color names
    (for example, `blue`) from a predefined list of colors returned by a static function—`QColor::colorNames()`.
    Once a color object is defined using RGB components, it can be queried using different
    color spaces (for example, CMYK or HSV). Also, a set of static methods are available
    that act as constructors for colors expressed in different color spaces.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 笔和画刷是两个属性，它们定义了不同的绘图操作如何执行。笔（由 `QPen` 类表示）定义轮廓，而画刷（由 `QBrush` 类表示）填充绘制的形状。每个都是一组参数。最简单的一个是定义的颜色，可以是预定义的全局颜色枚举值（例如
    `Qt::red` 或 `Qt::transparent`），或者 `QColor` 类的实例。有效颜色由四个属性组成：三个颜色分量（红色、绿色和蓝色）以及一个可选的
    alpha 通道值，它决定了颜色的透明度（值越大，颜色越不透明）。默认情况下，所有分量都表示为 8 位值（0 到 255），但也可以表示为表示分量最大饱和度百分比的实数值；例如，0.6
    对应于 153（0.6⋅255）。为了方便，`QColor` 构造函数之一接受在 HTML 中使用的十六进制颜色代码（例如，`#0000FF` 是不透明的蓝色），甚至可以接受来自静态函数
    `QColor::colorNames()` 返回的预定义颜色列表中的裸颜色名称（例如，`blue`）。一旦使用 RGB 分量定义了颜色对象，就可以使用不同的颜色空间（例如，CMYK
    或 HSV）查询它。此外，还有一系列静态方法，它们作为在不同颜色空间中表示的颜色构造函数。
- en: 'For example, to construct a clear magenta color any of the following expressions
    can be used:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要构建一个清晰的洋红色，可以使用以下任何一种表达式：
- en: '`QColor("magenta")`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QColor("magenta")`'
- en: '`QColor("#FF00FF")`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QColor("#FF00FF")`'
- en: '`QColor(255, 0, 255)`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QColor(255, 0, 255)`'
- en: '`QColor::fromRgbF(1, 0, 1)`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QColor::fromRgbF(1, 0, 1)`'
- en: '`QColor::fromHsv(300, 255, 255)`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QColor::fromHsv(300, 255, 255)`'
- en: '`QColor::fromCmyk(0, 255, 0, 0)`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QColor::fromCmyk(0, 255, 0, 0)`'
- en: '`Qt::magenta`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt::magenta`'
- en: 'Apart from the color, `QBrush` has two additional ways of expressing the fill
    of a shape. You can use `QBrush::setTexture()` to set a pixmap that will be used
    as a stamp or `QBrush::setGradient()` to make the brush use a gradient to do the
    filling. For example, to use a gradient that goes diagonally and starts as yellow
    in the top-left corner of the shape, becomes red in the middle of the shape, and
    ends as magenta at the bottom-right corner of the shape, the following code can
    be used:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除了颜色之外，`QBrush` 还有两种表示形状填充的方法。您可以使用 `QBrush::setTexture()` 设置一个用作戳记的位图，或者使用
    `QBrush::setGradient()` 使画刷使用渐变进行填充。例如，要使用一个从形状的左上角开始为黄色，在形状中间变为红色，并在形状的右下角结束为洋红色的对角渐变，可以使用以下代码：
- en: '[PRE11]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When used with drawing a rectangle, this code will give the following output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当与绘制矩形一起使用时，此代码将产生以下输出：
- en: '![](img/507836c9-026d-43d4-a40e-2906b785ae8f.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/507836c9-026d-43d4-a40e-2906b785ae8f.png)'
- en: 'Qt can handle linear (`QLinearGradient`), radial (`QRadialGradient`), and conical
    (`QConicalGradient`) gradients. Qt provides a Gradients example (shown in the
    following screenshot) where you can see different gradients in action:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 可以处理线性 (`QLinearGradient`)、径向 (`QRadialGradient`) 和锥形 (`QConicalGradient`)
    渐变。Qt 提供了一个渐变示例（如下截图所示），您可以在其中看到不同的渐变效果：
- en: '![](img/d0639b60-4645-4d39-81b8-cbdc0c722790.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0639b60-4645-4d39-81b8-cbdc0c722790.png)'
- en: As for the pen, its main attribute is its width (expressed in pixels), which
    determines the thickness of the shape outline. A pen can, of course, have a color
    set but, in addition to that, you can use any brush as a pen. The result of such
    an operation is that you can draw thick outlines of shapes using gradients or
    textures.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 至于画笔，其主要属性是其宽度（以像素为单位），它决定了形状轮廓的厚度。画笔当然可以设置颜色，但除此之外，您还可以使用任何画刷作为画笔。这种操作的结果是，您可以使用渐变或纹理绘制形状的粗轮廓。
- en: 'There are three more important properties for a pen. The first is the pen style,
    set using `QPen::setStyle()`. It determines whether lines drawn by the pen are
    continuous or divided in some way (dashes, dots, and so on). You can see the available
    line styles here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于笔来说，有三个更重要的属性。第一个是笔的样式，通过`QPen::setStyle()`设置。它决定了笔绘制的线条是连续的还是以某种方式分割的（如虚线、点等）。您可以在以下位置查看可用的线条样式：
- en: '![](img/0f854294-e767-4d1f-a34a-ee44fb5137fa.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f854294-e767-4d1f-a34a-ee44fb5137fa.png)'
- en: 'The second attribute is the cap style, which can be flat, square, or round.
    The third attribute—the join style—is important for polyline outlines and dictates
    how different segments of the polyline are connected. You can make the joins sharp
    (with `Qt::MiterJoin` or `Qt::SvgMiterJoin`), round (`Qt::RoundJoin`), or a hybrid
    of the two (`Qt::BevelJoin`). You can see the different pen attribute configurations
    (including different join and cap styles) in action by launching the Path Stroking
    example shown in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个属性是帽子的样式，可以是平的、方的或圆的。第三个属性——连接样式——对于多段线轮廓很重要，它决定了多段线的不同部分是如何连接的。您可以使连接尖锐（使用`Qt::MiterJoin`或`Qt::SvgMiterJoin`），圆形（`Qt::RoundJoin`），或者两者的混合（`Qt::BevelJoin`）。您可以通过启动以下截图所示的路径描边示例来查看不同的笔属性配置（包括不同的连接和帽样式）：
- en: '![](img/d6804e9a-8cc2-44e2-9be5-2cbaf2cb9ff5.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d6804e9a-8cc2-44e2-9be5-2cbaf2cb9ff5.png)'
- en: Item selection
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目选择
- en: 'The scene supports the ability of selecting items, similar to how you select
    files in a file manager. To be selectable, an item must have the `QGraphicsItem::ItemIsSelectable`
    flag turned on. Try to add `parent->setFlag(QGraphicsItem::ItemIsSelectable, true)`
    to the `createComplexItem()` function we created earlier. Now, if you run the
    application and click on a rectangle, it is selected, which is indicated by dashed
    lines:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 场景支持选择项目的功能，类似于在文件管理器中选择文件的方式。为了可被选择，项目必须将`QGraphicsItem::ItemIsSelectable`标志打开。尝试将`parent->setFlag(QGraphicsItem::ItemIsSelectable,
    true)`添加到我们之前创建的`createComplexItem()`函数中。现在，如果您运行应用程序并点击一个矩形，它将被选中，这由虚线表示：
- en: '![](img/8e77e8b5-c994-4b3d-b06b-932f690e8da7.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e77e8b5-c994-4b3d-b06b-932f690e8da7.png)'
- en: You can use the *Ctrl* button to select multiple items at once. Alternatively,
    you can call `view.setDragMode(QGraphicsView::RubberBandDrag)` to activate the
    rubber band selection for the view.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用*Ctrl*按钮一次性选择多个项目。或者，您可以调用`view.setDragMode(QGraphicsView::RubberBandDrag)`来激活视图的橡皮筋选择。
- en: Another useful drag mode of the Graphics View is `ScrollHandDrag`. It allows
    you to scroll the view by dragging the scene with the left mouse button, without
    the need to use scrollbars.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图形视图的另一个有用的拖动模式是`ScrollHandDrag`。它允许您通过用左鼠标按钮拖动场景来滚动视图，而不需要使用滚动条。
- en: Besides that, there are different ways to select items programmatically. There
    is the item's `QGraphicsItem::setSelected()` function, which takes a `bool` value
    to toggle the selection state on or off, or you can call `QGraphicsScene::setSelectionArea()`
    on the scene, which takes a `QPainterPath` parameter as an argument, in which
    case all items within the area are selected.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，还有不同的方式可以通过编程选择项目。有`QGraphicsItem::setSelected()`函数，它接受一个`bool`值来切换选择状态的开或关，或者您可以在场景上调用`QGraphicsScene::setSelectionArea()`，它接受一个`QPainterPath`参数作为参数，在这种情况下，区域内的所有项目都将被选中。
- en: With the scene's `QGraphicsScene::selectedItems()` function, you can query the
    actual selected items. The function returns a `QList` holding `QGraphicsItem`
    pointers to the selected items. For example, calling `QList::count()` on that
    list will give you the number of selected items. To clear the selection, call
    `QGraphicsScene::clearSelection()`. To query the selection state of an item, use
    `QGraphicsItem::isSelected()`, which returns `true` if the item is selected and
    `false` otherwise.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用场景的`QGraphicsScene::selectedItems()`函数，您可以查询实际选中的项目。该函数返回一个包含指向选中项目的`QGraphicsItem`指针的`QList`。例如，在列表上调用`QList::count()`将给出选中项目的数量。要清除选择，请调用`QGraphicsScene::clearSelection()`。要查询项目的选择状态，请使用`QGraphicsItem::isSelected()`，如果项目被选中则返回`true`，否则返回`false`。
- en: Another interesting flag of `GraphicsItem` is `ItemIsMovable`. It enables you
    to drag the item within the scene by holding it with the left mouse button, effectively
    changing the `pos()` of the item. Try to add `parent->setFlag(QGraphicsItem::ItemIsMovable,
    true)` to our `createComplexItem` function and drag around the rectangles.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`GraphicsItem`的另一个有趣的标志是`ItemIsMovable`。它允许您通过用左鼠标按钮抓住项目在场景内拖动它，从而有效地改变项目的`pos()`。尝试将`parent->setFlag(QGraphicsItem::ItemIsMovable,
    true)`添加到我们的`createComplexItem`函数中，并拖动矩形。'
- en: Keyboard focus in graphics scene
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形场景中的键盘焦点
- en: The scene implements the concept of focus that works similar to keyboard focus
    in widgets. Only one item can have focus at a time. When the scene receives a
    keyboard event, it is dispatched to the focus item.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 该场景实现了类似于小部件中键盘焦点的工作原理的焦点概念。一次只能有一个项目拥有焦点。当场景接收到键盘事件时，它会被分发到拥有焦点的项目。
- en: 'To be focusable, an item must have the `QGraphicsItem::ItemIsFocusable` flag
    enabled:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要使项目可聚焦，项目必须启用`QGraphicsItem::ItemIsFocusable`标志：
- en: '[PRE12]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, an item can be focused by a mouse click. You can also change the focused
    item from the code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以通过鼠标点击来聚焦一个项目。你也可以从代码中更改聚焦的项目：
- en: '[PRE13]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Another way to set the focus is to use the scene's `QGraphicsScene::setFocusItem()`
    function, which expects a pointer to the item you like to focus as a parameter.
    Every time an item gains focus, the previously focused item (if any) will automatically
    lose focus.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种设置焦点的方法是使用场景的`QGraphicsScene::setFocusItem()`函数，该函数期望一个指向你想要聚焦的项目指针作为参数。每次一个项目获得焦点时，之前聚焦的项目（如果有的话）将自动失去焦点。
- en: To determine whether an item has focus, you again have two possibilities. One
    is that you can call `QGraphicsItem::hasFocus()` on an item, which returns `true`
    if the item has focus or `false` otherwise. Alternatively, you can get the actual
    focused item by calling the scene's `QGraphicsScene::focusItem()` method. On the
    other hand, if you call the item's `QGraphicsItem::focusItem()` function, the
    focused item is returned if the item itself or any descendant item has focus;
    otherwise, `nullptr` is returned. To remove focus, call `clearFocus()` on the
    focused item or click somewhere in the scene's background or on an item that cannot
    get focus.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定一个项目是否有焦点，你又有两种可能性。一种是在项目上调用`QGraphicsItem::hasFocus()`，如果项目有焦点则返回`true`，否则返回`false`。或者，你可以通过调用场景的`QGraphicsScene::focusItem()`方法来获取实际聚焦的项目。另一方面，如果你调用项目的`QGraphicsItem::focusItem()`函数，如果项目本身或任何子项目有焦点，则返回聚焦的项目；否则，返回`nullptr`。要移除焦点，请在聚焦的项目上调用`clearFocus()`或在场景的背景或无法聚焦的项目上点击。
- en: If you want a click on the scene's background not to cause the focused item
    to lose its focus, set the scene's `stickyFocus` property to `true`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望点击场景的背景不会导致聚焦的项目失去焦点，将场景的`stickyFocus`属性设置为`true`。
- en: Painter paths
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘画路径
- en: If you want to create a graphics item that consists of multiple geometric primitives,
    creating multiple `QGraphicsItem` objects seems to be tedious. Fortunately, Qt
    provides a  `QGraphicsPathItem` class that allows you to specify a number of primitives
    in a `QPainterPath` object. `QPainterPath` allows you to "record" multiple painting
    instructions (including filling, outlining, and clipping), and then efficiently
    reuse them multiple times.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个由多个几何原语组成的图形项目，创建多个`QGraphicsItem`对象似乎很繁琐。幸运的是，Qt提供了一个`QGraphicsPathItem`类，它允许你在`QPainterPath`对象中指定多个原语。`QPainterPath`允许你“记录”多个绘图指令（包括填充、轮廓和裁剪），然后高效地多次重用它们。
- en: Time for action – Adding path items to the scene
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 - 将路径项目添加到场景中
- en: 'Let''s paint a few objects consisting of a large number of lines:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制一些由大量线条组成的对象：
- en: '[PRE14]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For each item, we first create a `QPainterPath` and set the current position
    to (0, 0). Then, we use the `qrand()` function to generate random numbers, apply
    the modulus operator (`%`) to produce a number from 0 to `SIZE` (excluding `SIZE`),
    and feed them to the `lineTo()` function that strokes a line from the current
    position to the given position and sets it as the new current position. Next,
    we use the `addPath()` convenience function that creates a `QGraphicsPathItem`
    object and adds it to the scene. Finally, we use `setPos()` to move each item
    to a different position in the scene. The result looks like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个项目，我们首先创建一个`QPainterPath`并设置当前位置为(0, 0)。然后，我们使用`qrand()`函数生成随机数，应用模运算符(`%`)生成一个从0到`SIZE`（不包括`SIZE`）的数字，并将它们输入到`lineTo()`函数，该函数从当前位置绘制一条线到指定位置，并将它设置为新的当前位置。接下来，我们使用`addPath()`便利函数创建一个`QGraphicsPathItem`对象并将其添加到场景中。最后，我们使用`setPos()`将每个项目移动到场景中的不同位置。结果看起来像这样：
- en: '![](img/4ad6b1a5-f2dd-4d74-bec6-c3136354f36e.png)`QPainterPath` allows you
    to use practically every paint operation Qt supports. For example, `QGraphicsPathItem`
    is the only standard item able to draw Bezier curves in the scene, as `QPainterPath`
    supports them. Refer to the documentation of `QPainterPath` for more information.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/4ad6b1a5-f2dd-4d74-bec6-c3136354f36e.png)`QPainterPath`允许你使用Qt支持的几乎所有绘图操作。例如，`QGraphicsPathItem`是唯一能够在场景中绘制贝塞尔曲线的标准项目，因为`QPainterPath`支持它们。有关更多信息，请参阅`QPainterPath`的文档。'
- en: Using painter paths in this example is very efficient, because we avoided creating
    thousands of individual line objects on the heap. However, putting a large part
    of a scene in a single item may reduce the performance. When parts of the scene
    are separate graphics items, Qt can efficiently determine which items are not
    visible and skip drawing them.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中使用绘图路径非常高效，因为我们避免了在堆栈上创建成千上万的单个线条对象。然而，将场景的大部分内容放在单个项目中可能会降低性能。当场景的部分是独立的图形项目时，Qt可以有效地确定哪些项目是不可见的，并跳过它们的绘制。
- en: Z-order of items
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目的z-顺序
- en: 'Have you wondered what happens when multiple items are painted in the same
    area of the scene? Let''s try to do this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想过当多个项目在同一场景区域绘制时会发生什么？让我们尝试这样做：
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'By default, items are painted in the order they were added, so the last item
    will be displayed in front of the others:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，项目会按照它们被添加的顺序进行绘制，因此最后一个项目将显示在其他项目的前面：
- en: '![](img/58e6925e-58dc-4a7e-bd50-c84426f473c5.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58e6925e-58dc-4a7e-bd50-c84426f473c5.png)'
- en: 'However, you can change the **z-order** by calling the `setZValue()` function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以通过调用`setZValue()`函数来更改**z-顺序**：
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second item is now displayed in front of the others:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在第二个项目显示在其他项目的前面：
- en: '![](img/39ea5b10-7e79-4c56-ab83-06a045cf001b.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39ea5b10-7e79-4c56-ab83-06a045cf001b.png)'
- en: Items with a higher *z* value are displayed on top of the items with lower *z*
    values. The default *z* value is 0\. Negative values are also possible. If items
    have the same *z* value, the order of insertion decides the placement, and items
    added later overlap those added earlier.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*z*值较高的项目会显示在*z*值较低的项目之上。默认*z*值为0。负值也是可能的。如果项目具有相同的*z*值，则插入顺序决定位置，并且后来添加的项目会覆盖早期添加的项目。'
- en: Ability to change the z-order of items is very important when developing 2D
    games. Any scene typically consists of a number of layers that must be painted
    in a specific order. You can set a *z* value for each item based on the layer
    this item belongs to.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发2D游戏时，能够更改项目z-顺序的能力非常重要。任何场景通常都由多个必须按特定顺序绘制的层组成。你可以根据该项目所属的层为每个项目设置一个*z*值。
- en: The parent–child relationship between items also has an impact on the z-order.
    Children are displayed on top of their parent. Additionally, if an item is displayed
    in front of another item, the children of the former are also displayed in front
    of the children of the latter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的父子关系也会影响z-顺序。子项目会显示在其父项目之上。此外，如果一个项目显示在另一个项目之前，那么前者的子项目也会显示在后者的子项目之前。
- en: Ignoring transformations
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略变换
- en: If you try to zoom in on our custom rectangles scene (for example, by calling
    `view.scale(4, 4)`) , you will note that everything is scaled proportionally,
    as you would expect. However, there are situations where you don't want some elements
    to be affected by scale or other transformations. Qt provides multiple ways to
    deal with it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试放大我们的自定义矩形场景（例如，通过调用`view.scale(4, 4)`），你会注意到一切都会按比例缩放，正如你所期望的那样。然而，有些情况下你不想某些元素受到缩放或其他变换的影响。Qt提供了多种处理方法。
- en: 'If you want lines to always have the same width, regardless of the zoom, you
    need to make the pen cosmetic:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望线条始终具有相同的宽度，而不管缩放如何，你需要使画笔外观化：
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, the rectangles will always have lines with one-pixel width, regardless
    of the view's scale (anti-aliasing can still blur them, though). It's also possible
    to have cosmetic pens with any width, but using them in Graphics View is not recommended.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，矩形将始终具有一像素宽的线条，而不管视图的缩放如何（尽管抗锯齿仍然可能使它们模糊）。也可以使用任何宽度的外观化画笔，但在Graphics View中使用它们并不推荐。
- en: Another common situation where you don't want transformation to apply is displaying
    text. Rotating and shearing text usually makes it unreadable, so you'd usually
    want to make it horizontal and untransformed. Let's try to add some text to our
    project and look at how we can solve this problem.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望变换应用的其他常见情况是显示文本。旋转和剪切文本通常会使文本难以阅读，所以你通常会希望将其设置为水平且未变换。让我们尝试在我们的项目中添加一些文本并看看我们如何解决这个问题。
- en: Time for action – Adding text to a custom rectangle
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 - 向自定义矩形添加文本
- en: 'Let''s add a number to each of the corner circles:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在每个角落圆上添加一个数字：
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `QString::number(i)` function returns the string representation of number
    `i`. The text item is a child of the circle item, so its position is relative
    to the circle''s origin point (in our case, its center). As we saw earlier, the
    text is displayed to the top-left of the item''s origin, so if we want to center
    the text within the circle, we need to shift it up and right by half of the item''s
    size. Now the text is positioned and rotated along with its parent circle:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`QString::number(i)`函数返回数字`i`的字符串表示形式。文本项是圆项的子项，所以它的位置相对于圆的起点（在我们的例子中，是圆心）。正如我们之前看到的，文本显示在项的左上角，所以如果我们想在圆内居中文本，我们需要将其向上和向右移动项大小的一半。现在文本已经定位并与其父圆一起旋转：'
- en: '![](img/cce0ca8a-314d-4c25-8641-d16a88cdd8bd.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cce0ca8a-314d-4c25-8641-d16a88cdd8bd.png)'
- en: 'However, we don''t want the text to be rotated, so we need to enable the `ItemIgnoresTransformations`
    flag for the text item:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不想文本旋转，因此我们需要为文本项启用`ItemIgnoresTransformations`标志：
- en: '[PRE19]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This flag makes the item ignore any transformations of its parent items or
    the view. However, the origin of its coordinate system is still defined by the
    position of `pos()` in the parent''s coordinate system. So, the text item will
    still follow the circle, but it will no longer be scaled or rotated:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志使项忽略其父项或视图的任何变换。然而，其坐标系统的原点仍然由父坐标系统中`pos()`的位置定义。因此，文本项仍然会跟随圆，但它将不再缩放或旋转：
- en: '![](img/ed297d98-80a2-48cd-ae0d-b721952e66eb.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed297d98-80a2-48cd-ae0d-b721952e66eb.png)'
- en: 'However, now we hit another problem: the text is no longer properly centered
    in the circle. It will become more apparent if you scale the view again. Why did
    that happen? With the `ItemIgnoresTransformations` flag, our `text->setPos(...)`
    statement is no longer correct. Indeed, `pos()` uses coordinates in the parent''s
    coordinate system, but we used the result of `boundingRect()`, which uses the
    item''s coordinate system. These two coordinate systems were the same before,
    but with the `ItemIgnoresTransformations` flag enabled, they are now different.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们遇到了另一个问题：文本在圆中不再正确居中。如果你再次缩放视图，这个问题会更加明显。为什么会这样呢？当启用`ItemIgnoresTransformations`标志时，我们的`text->setPos(...)`语句就不再正确了。实际上，`pos()`使用的是父坐标系统中的坐标，但我们使用了`boundingRect()`的结果，它使用的是项的坐标系统。这两个坐标系统之前是相同的，但启用`ItemIgnoresTransformations`标志后，它们现在不同了。
- en: To elaborate on this problem, let's see what happens with the coordinates (we
    will consider only *x* coordinate, since *y* behaves the same). Let's say that
    our text item's width is eight pixels, so the `pos()` we set has `x = -4`. When
    no transformations are applied, this `pos()` results in shifting the text to the
    left by four pixels. If the `ItemIgnoresTransformations` flag is disabled and
    the view is scaled by 2, the text is shifted by eight pixels relative to the circle's
    center, but the size of the text itself is now 16 pixels, so it's still centered.
    If the `ItemIgnoresTransformations` flag is enabled, the text is still shifted
    to the left by eight pixels relative to the circle's center (because `pos()` operates
    in the parent item's coordinate system, and the circle is scaled), but the width
    of the item is now 8, because it ignores the scale and so it's no longer centered.
    When the view is rotated, the result is even more incorrect, because `setPos()`
    will shift the item in the direction that depends on the rotation. Since the text
    item itself is not rotated, we always want to shift it up and left.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细说明这个问题，让我们看看坐标发生了什么（我们只考虑*x*坐标，因为*y*的行为相同）。假设我们的文本项宽度为八个像素，所以设置的`pos()`的`x
    = -4`。如果没有应用任何变换，这个`pos()`会导致文本向左移动四个像素。如果禁用`ItemIgnoresTransformations`标志，并且视图缩放为2，文本相对于圆心的位移是八个像素，但文本本身的大小现在是16像素，所以它仍然居中。如果启用`ItemIgnoresTransformations`标志，文本相对于圆心的位移仍然是八个像素（因为`pos()`在父项的坐标系统中操作，而圆被缩放），但项的宽度现在是8，因为它忽略了缩放，所以不再居中。当视图旋转时，结果会更加不正确，因为`setPos()`会将项移动到取决于旋转方向的位置。由于文本项本身没有旋转，我们总是希望将其向上和向左移动。
- en: 'This problem would go away if the item were already centered around its origin.
    Unfortunately, `QGraphicsSimpleTextItem` can''t do this. Now, if it were  `QGraphicsRectItem`,
    doing this would be easy, but nothing stops us from adding a rectangle that ignores
    transformations and then adding text inside that rectangle! Let''s do this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目已经围绕其原点居中，这个问题就会消失。不幸的是，`QGraphicsSimpleTextItem` 无法做到这一点。现在，如果它是 `QGraphicsRectItem`，这样做会很简单，但没有任何阻止我们添加一个忽略变换的矩形，然后在其中添加文本！让我们这样做：
- en: '[PRE20]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this code, we first create a text item, but don't set its parent. Next, we
    get the bounding rect of the item that will tell us how much space the text needs.
    Then, we shift the rect so that its center is at the origin point (0, 0). Now
    we can create a rect item for this rectangle, set the circle as its parent, and
    disable transformations for the rect item. Finally, we set the rect item as the
    parent of the text item and change the position of the text item to place it inside
    the rectangle.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先创建一个文本项，但未设置其父项。然后，我们获取项目的边界矩形，这将告诉我们文本需要多少空间。然后，我们将矩形移动，使其中心位于原点（0,
    0）。现在我们可以为这个矩形创建一个矩形项，将其设置为圆的父项，并禁用矩形项的变换。最后，我们将矩形项设置为文本项的父项，并更改文本项的位置，使其位于矩形内。
- en: 'The rectangle is now properly positioned at the center of the circle, and the
    text item always follows the rectangle, as children usually do:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形现在正确地定位在圆的中心，并且文本项始终跟随矩形，就像子项通常做的那样：
- en: '![](img/1c50bcd2-4d81-4f14-9218-4cc2d2ad76d4.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c50bcd2-4d81-4f14-9218-4cc2d2ad76d4.png)'
- en: Since we didn't originally want the rectangle, we may want to hide it. We can't
    use `rectItem->hide()` in this case, because that would also result in hiding
    its child item (the text). The solution is to disable the painting of the rectangle
    by calling `rectItem->setPen(Qt::NoPen)`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们最初并不想添加矩形，我们可能想隐藏它。在这种情况下，我们不能使用 `rectItem->hide()`，因为这也会隐藏其子项（文本）。解决方案是通过调用
    `rectItem->setPen(Qt::NoPen)` 来禁用矩形的绘制。
- en: 'An alternative solution to this problem is to translate the text item''s coordinate
    system instead of using `setPos()`. `QGraphicsItem` doesn''t have a dedicated
    function for translation, so we will need to use `setTransform`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的另一种方法是翻译文本项的坐标系，而不是使用 `setPos()`。`QGraphicsItem` 没有专门用于平移的函数，因此我们需要使用
    `setTransform`：
- en: '[PRE21]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Contrary to what you would expect, `ItemIgnoresTransformations` doesn't cause
    the item to ignore its own transformations, and this code will position the text
    correctly without needing an additional rectangle item.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与你的预期相反，`ItemIgnoresTransformations` 并不会使项目忽略其自身的变换，并且这段代码将正确地定位文本，而无需额外的矩形项。
- en: Finding items by position
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过位置查找项目
- en: 'If you want to know which item is shown at a certain position, you can use
    the `QGraphicsScene::itemAt()` function that takes the position in the scene''s
    coordinate system (either a `QPointF` or two `qreal` numbers) and the device transformation
    object (`QTransform`) that can be obtained using the `QGraphicsView::transform()`
    function. The function returns the topmost item at the specified position or a
    null pointer if no item was found. The device transformation only matters if your
    scene contains items that ignore transformations. If you have no such items, you
    can use the default-constructed `QTransform` value:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道在某个特定位置显示的是哪个项目，你可以使用 `QGraphicsScene::itemAt()` 函数，该函数接受场景坐标系中的位置（一个
    `QPointF` 或两个 `qreal` 数字）和可以通过 `QGraphicsView::transform()` 函数获得的设备变换对象 (`QTransform`)。该函数返回指定位置的最顶层项目，如果没有找到项目则返回空指针。设备变换只有在你的场景包含忽略变换的项目时才有意义。如果你没有这样的项目，你可以使用默认构造的
    `QTransform` 值：
- en: '[PRE22]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If your scene contains items that ignore transformations, it may be more convenient
    to use the `QGraphicsView::itemAt()` function that automatically takes the device
    transform into account. Note that this function expects the position to be in
    the viewport's coordinate system.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的场景包含忽略变换的项目，使用 `QGraphicsView::itemAt()` 函数可能更方便，该函数会自动考虑设备变换。请注意，此函数期望位置在视口坐标系中。
- en: 'If you want all items that are located at some position, say in cases where
    multiple items are on top of each other, or if you need to search for items in
    some area, use the  `QGraphicsScene::items()` function. It will return a list
    of items defined by the specified arguments. This function has a number of overloads
    that allow you to specify a single point, a rectangle, a polygon, or a painter
    path. The `deviceTransform` argument works in the same way as for the `QGraphicsScene::itemAt()`
    function discussed earlier. The `mode` argument allows you to alter how the items
    in the area will be determined. The following table shows the different modes:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想找到位于某个位置的所有物品，例如在多个物品堆叠在一起的情况下，或者如果您需要在某个区域搜索物品，请使用`QGraphicsScene::items()`函数。它将返回由指定参数定义的物品列表。此函数有几个重载，允许您指定一个点、一个矩形、一个多边形或一个绘图路径。`deviceTransform`参数的作用方式与前面讨论的`QGraphicsScene::itemAt()`函数相同。`mode`参数允许您更改确定区域中物品的方式。下表显示了不同的模式：
- en: '| **Mode** | **Meaning** |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **含义** |'
- en: '| `Qt::ContainsItemBoundingRect` | The item''s bounding rectangle must be completely
    inside the selection area. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `Qt::ContainsItemBoundingRect` | 物品的边界矩形必须完全位于选择区域内。|'
- en: '| `Qt::IntersectsItemBoundingRect` | Similar to `Qt::ContainsItemBoundingRect`
    but also returns items whose bounding rectangles intersect with the selection
    area. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `Qt::IntersectsItemBoundingRect` | 与`Qt::ContainsItemBoundingRect`类似，但还返回与选择区域相交的物品的边界矩形。|'
- en: '| `Qt::ContainsItemShape` | The item''s shape must be completely inside the
    selection area. The shape may describe the item''s boundaries more precisely than
    the bounding rectangle, but this operation is more computationally intensive.
    |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `Qt::ContainsItemShape` | 物品的形状必须完全位于选择区域内。形状可能比边界矩形更精确地描述物品的边界，但此操作的计算量更大。|'
- en: '| `Qt::IntersectsItemShape` | Similar to `Qt::ContainsItemShape` but also returns
    items whose shapes intersect with the selection area. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `Qt::IntersectsItemShape` | 与`Qt::ContainsItemShape`类似，但还返回与选择区域相交的物品的形状。|'
- en: The `items()` function sorts items according to their stacking order. The `order`
    argument allows you to choose the order in which the results will be returned. 
    `Qt::DescendingOrder` (default) will place the topmost item at the beginning,
    and  `Qt::AscendingOrder` will result in a reversed order.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`items()`函数根据物品的堆叠顺序对物品进行排序。`order`参数允许您选择结果返回的顺序。`Qt::DescendingOrder`（默认）将最顶部的物品放在开头，而`Qt::AscendingOrder`将导致顺序相反。'
- en: The view also provides a similar `QGraphicsView::items()` function that operates
    in viewport coordinates.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 视图还提供了一个类似的`QGraphicsView::items()`函数，该函数在视口坐标中操作。
- en: Showing specific areas of the scene
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示场景的特定区域
- en: As soon as the scene's bounding rectangle exceeds the viewport's size, the view
    will show scroll bars. Besides using them with the mouse to navigate to a specific
    item or point on the scene, you can also access them by code. Since the view inherits
    `QAbstractScrollArea`, you can use all its functions for accessing the scroll
    bars; `horizontalScrollBar()` and `verticalScrollBar()` return a pointer to `QScrollBar`,
    and thus you can query their range with `minimum()` and `maximum()`. By invoking
    `value()` and `setValue()`, you get and can set the current value, which results
    in scrolling the scene.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景的边界矩形超过视口大小时，视图将显示滚动条。除了使用鼠标导航到场景中的特定物品或点之外，您还可以通过代码访问它们。由于视图继承了`QAbstractScrollArea`，您可以使用所有其函数来访问滚动条；`horizontalScrollBar()`和`verticalScrollBar()`返回一个指向`QScrollBar`的指针，因此您可以使用`minimum()`和`maximum()`查询它们的范围。通过调用`value()`和`setValue()`，您可以获取并设置当前值，这将导致场景滚动。
- en: However, normally, you do not need to control free scrolling inside the view
    from your source code. The normal task would be to scroll to a specific item.
    In order to do that, you do not need to do any calculations yourself; the view
    offers a pretty simple way to do that for you—`centerOn()`. With `centerOn()`,
    the view ensures that the item, which you have passed as an argument, is centered
    on the view unless it is too close to the scene's border or even outside. Then,
    the view tries to move it as far as possible on the center. The `centerOn()` function
    does not only take a `QGraphicsItem` item as argument; you can also center on
    a `QPointF` pointer or as a convenience on an *x* and *y* coordinate.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常你不需要从源代码中控制视图内的自由滚动。正常任务是将滚动到特定的项目。为了做到这一点，你不需要自己进行任何计算；视图提供了一个相当简单的方法为你完成这项工作——`centerOn()`。使用`centerOn()`，视图确保你传递作为参数的项目在视图中居中，除非它太靠近场景的边框甚至在外面。然后，视图会尽量将其移动到中心。`centerOn()`函数不仅接受`QGraphicsItem`项目作为参数；你也可以以`QPointF`指针或便利方式以*x*和*y*坐标为中心。
- en: If you do not care where an item is shown, you can simply call `ensureVisible()`
    with the item as an argument. Then, the view scrolls the scene as little as possible
    so that the item's center remains or becomes visible. As a second and third argument,
    you can define a horizontal and vertical margin, which are both the minimum space
    between the item's bounding rectangle and the view's border. Both values have
    50 pixels as their default value. Besides a `QGraphicsItem` item, you can also
    ensure the visibility of a `QRectF` element (of course, there is also the convenience
    function taking four `qreal` elements).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在乎一个项目显示的位置，你可以简单地传递项目作为参数调用`ensureVisible()`。然后，视图会尽可能少地滚动场景，以便项目的中心保持或变为可见。作为第二个和第三个参数，你可以定义水平和垂直边距，这两个边距都是项目边界矩形和视图边框之间的最小空间。这两个值的默认值都是50像素。除了`QGraphicsItem`项目外，你也可以确保`QRectF`元素（当然，也有接受四个`qreal`元素的便利函数）的可见性。
- en: If you need to ensure the entire visibility of an item, use `ensureVisible(item->boundingRect())`
    (since `ensureVisible(item)` only takes the item's center into account).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要确保一个项目的整个可见性，请使用`ensureVisible(item->boundingRect())`（因为`ensureVisible(item)`只考虑项目的中心）。
- en: '`centerOn()` and `ensureVisible()` only scroll the scene but do not change
    its transformation state. If you absolutely want to ensure the visibility of an
    item or a rectangle that exceeds the size of the view, you have to transform the
    scene as well. With this task, again the view will help you. By calling `fitInView()`
    with `QGraphicsItem` or a `QRectF` element as an argument, the view will scroll
    and scale the scene so that it fits in the viewport size.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`centerOn()`和`ensureVisible()`只会滚动场景，但不会改变其变换状态。如果你绝对想要确保一个项目或超过视图大小的矩形的可见性，你必须同时变换场景。在这个任务中，视图会再次帮助你。通过传递`QGraphicsItem`或`QRectF`元素作为参数调用`fitInView()`，视图会滚动并缩放场景，使其适合视口大小。'
- en: 'As a second argument, you can control how the scaling is done. You have the
    following options:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个参数，你可以控制缩放是如何进行的。你有以下选项：
- en: '| **Value** | **Description** |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| **值** | **描述** |'
- en: '| `Qt::IgnoreAspectRatio` | The scaling is done absolutely freely regardless
    of the item''s or rectangle''s aspect ratio. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `Qt::IgnoreAspectRatio` | 缩放是绝对自由进行的，不考虑项目或矩形的纵横比。|'
- en: '| `Qt::KeepAspectRatio` | The item''s or rectangle''s aspect ratio is taken
    into account while trying to expand as far as possible while respecting the viewport''s
    size. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `Qt::KeepAspectRatio` | 尝试尽可能扩展时，会考虑项目或矩形的纵横比，同时尊重视口的大小。|'
- en: '| `Qt::KeepAspectRatioByExpanding` | The item''s or rectangle''s aspect ratio
    is taken into account, but the view tries to fill the whole viewport''s size with
    the smallest overlap. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `Qt::KeepAspectRatioByExpanding` | 考虑项目或矩形的纵横比，但视图尝试用最小的重叠填充整个视口的大小。|'
- en: 'The `fitInView()` function does not only scale larger items down to fit the
    viewport, it also enlarges items to fill the whole viewport. The following diagram
    illustrates the different scaling options for an item that is enlarged (the circle
    on the left is the original item, and the black rectangle is the viewport):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`fitInView()`函数不仅将较大的项目缩小以适应视口，还将项目放大以填充整个视口。以下图表说明了放大项目的不同缩放选项（左边的圆是原始项目，黑色矩形是视口）：'
- en: '![](img/a698c68a-d4b2-49a1-acaa-0a27d1936f2c.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a698c68a-d4b2-49a1-acaa-0a27d1936f2c.png)'
- en: Saving a scene to an image file
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将场景保存到图像文件
- en: 'We''ve only displayed our scene in the view so far, but it is also possible
    to render it to an image, a printer, or any other object Qt can use for painting.
    Let''s save our scene to a PNG file:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在视图中显示了我们的场景，但也可以将其渲染到图像、打印机或其他 Qt 可以用于绘制的对象。让我们将场景保存为 PNG 文件：
- en: '[PRE23]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What just happened?
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: First, you determined the rectangle of the scene with `sceneRect()`. Since this
    returns a `QRectF` parameter and `QImage` can only handle `QRect`, you transformed
    it on the fly by calling `toAlignedRect()`. The difference between the `toRect()`
    function and `toAlignedRect()` is that the former rounds to the nearest integer,
    which may result in a smaller rectangle, whereas the latter expands to the smallest
    possible rectangle containing the original `QRectF` parameter.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您使用 `sceneRect()` 确定了场景的矩形。由于这个函数返回一个 `QRectF` 参数，而 `QImage` 只能处理 `QRect`，您通过调用
    `toAlignedRect()` 在线转换了它。`toRect()` 函数和 `toAlignedRect()` 之间的区别在于前者四舍五入到最接近的整数，这可能会导致矩形更小，而后者扩展到包含原始
    `QRectF` 参数的最小可能矩形。
- en: Then, you created a `QImage` file with the size of the aligned scene's rectangle.
    As the image is created with uninitialized data, you need to call `fill()` with
    `Qt::transparent` to receive a transparent background. You can assign any color
    you like as an argument both as a value of `Qt::GlobalColor` enumeration and an
    ordinary `QColor` object; `QColor(0, 0, 255)` will result in a blue background.
    Next, you create a `QPainter` object that points to the image. This painter object
    is then used in the scene's `render()` function to draw the scene. After that,
    all you have to do is use the `save()` function to save the image to a place of
    your choice. The format of the output file is determined by its extension. Qt
    supports a variety of formats, and Qt plugins can add support for new formats. Since
    we haven't specified a path, the image will be saved in the application's working
    directory (which is usually the build directory, unless you changed it using the
    Projects pane of Qt Creator). You can also specify an absolute path, such as `/path/to/image.png`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您创建了一个与对齐场景矩形大小相同的 `QImage` 文件。由于图像是用未初始化的数据创建的，您需要使用 `Qt::transparent` 调用
    `fill()` 以获取透明背景。您可以将任何颜色作为参数分配，无论是 `Qt::GlobalColor` 枚举的值还是一个普通的 `QColor` 对象；`QColor(0,
    0, 255)` 将导致蓝色背景。接下来，您创建了一个指向图像的 `QPainter` 对象。然后，这个绘图对象在场景的 `render()` 函数中使用来绘制场景。之后，您只需使用
    `save()` 函数将图像保存到您选择的位置。输出文件的格式由其扩展名确定。Qt 支持多种格式，Qt 插件可以添加对新格式的支持。由于我们没有指定路径，图像将被保存在应用程序的工作目录中（通常是构建目录，除非您使用
    Qt Creator 的项目面板更改了它）。您也可以指定一个绝对路径，例如 `/path/to/image.png`。
- en: Of course, you'll need to construct a path that's valid on the current system
    instead of hard-coding it in the sources. For example, you can use the `QFileDialog::getSaveFileName()`
    function to ask the user for a path.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您需要构造一个在当前系统上有效的路径，而不是在源代码中硬编码它。例如，您可以使用 `QFileDialog::getSaveFileName()`
    函数请求用户输入路径。
- en: Have a go hero – Rendering only specific parts of a scene
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄般的渲染 - 仅渲染场景的特定部分
- en: This example draws the whole scene. Of course, you can also render only specific
    parts of the scene using the other arguments of `render()`. We will not go into
    this here, but you may want to try it as an exercise.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例绘制了整个场景。当然，您也可以使用 `render()` 的其他参数仅渲染场景的特定部分。我们在这里不会深入探讨，但您可能想将其作为练习尝试。
- en: Custom items
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义项
- en: 'As we already saw, Graphics View provides a lot of useful functionality that
    covers most typical use cases. However, the real power of Qt is its extensibility,
    and Graphics View allows us to create custom subclasses of `QGraphicsItem` to
    implement items that are tailored for your application. You may want to implement
    a custom item class when you need to do the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，图形视图提供了很多有用的功能，涵盖了大多数典型用例。然而，Qt 的真正力量在于其可扩展性，图形视图允许我们创建 `QGraphicsItem`
    的自定义子类，以实现针对您的应用程序定制的项。当您需要执行以下操作时，您可能想实现一个自定义项类：
- en: Paint something that is not possible or difficult to do with standard item classes
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制标准项类无法或难以完成的事情
- en: Implement some logic related to the item, for example, add your own methods
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现与该项相关的逻辑，例如，添加您自己的方法
- en: Handle events in individual items
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单个项中处理事件
- en: In our next small project, we will create an item that can draw a graph of the
    sine function `sin(x)` and implement some event handling.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个小型项目中，我们将创建一个可以绘制正弦函数 `sin(x)` 图形的项，并实现一些事件处理。
- en: Time for action – Creating a sine graph project
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建正弦图项目
- en: Use Qt Creator to create a new Qt Widgets project and name it `sine_graph`.
    On the Class Information page of the wizard, select `QWidget` as the base class
    and input `View` as the class name. Uncheck the Generate form checkbox and finish
    the wizard.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Qt Creator 创建一个新的 Qt Widgets 项目，并将其命名为 `sine_graph`。在向导的“类信息”页面，选择 `QWidget`
    作为基类，并将类名输入为 `View`。取消选中“生成表单”复选框，然后完成向导。
- en: 'We want the `View` class to be the graphics view, so you need to change the
    base class to `QGraphicsView` (the wizard doesn''t suggest such an option). For
    this, edit the class declaration to look like `class View : public QGraphicsView
    ...` and the constructor implementation to look like `View::View(QWidget *parent)
    : QGraphicsView(parent) ...`.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '我们希望 `View` 类成为图形视图，所以你需要将基类更改为 `QGraphicsView`（向导没有建议这样的选项）。为此，编辑类声明使其看起来像
    `class View : public QGraphicsView ...`，并编辑构造函数实现使其看起来像 `View::View(QWidget *parent)
    : QGraphicsView(parent) ...`。'
- en: 'Next, edit the `View` constructor to enable anti-aliasing and set a new graphics
    scene for our view:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑 `View` 构造函数以启用抗锯齿并为我们视图设置一个新的图形场景：
- en: '[PRE24]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The view doesn''t delete the associated scene on destruction (because you may
    have multiple views for the same scene), so you should delete the scene manually
    in the destructor:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 视图在销毁时不会删除关联的场景（因为你可能对同一个场景有多个视图），所以你应该在析构函数中手动删除场景：
- en: '[PRE25]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can try to run the application and check that it displays an empty view.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试运行应用程序并检查它是否显示了一个空视图。
- en: Time for action – Creating a graphics item class
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建图形项目类
- en: Ask Qt Creator to add a new C++ class to the project. Input `SineItem` as the
    class name, leave <Custom> in the Base class drop-down list, and input `QGraphicsItem`
    in the field below it. Finish the wizard and open the created `sineitem.h` file.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 请求 Qt Creator 向项目中添加一个新的 C++ 类。输入 `SineItem` 作为类名，将下拉列表中的 <Custom> 保持不变，并在其下方的字段中输入
    `QGraphicsItem`。完成向导并打开创建的 `sineitem.h` 文件。
- en: 'Set the text cursor inside `QGraphicsItem` in the class declaration and press
    *Alt* + *Enter*. At first; Qt Creator will suggest that you Add `#include <QGraphicsItem>`.
    Confirm that and press *Alt* + *Enter* on `QGraphicsItem` again. Now, Qt Creator
    should suggest that you select Insert Virtual Functions of Base Classes. When
    you select this option, a special dialog will appear:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明中设置文本光标在 `QGraphicsItem` 内，然后按 *Alt* + *Enter*。一开始，Qt Creator 会建议你添加 `#include
    <QGraphicsItem>`。确认后，再次在 `QGraphicsItem` 上按 *Alt* + *Enter*。现在，Qt Creator 应该会建议你选择插入基类的虚拟函数。当你选择这个选项时，会出现一个特殊的对话框：
- en: '![](img/22622853-aad8-4b25-99fe-2631b66ffda4.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22622853-aad8-4b25-99fe-2631b66ffda4.png)'
- en: The function list contains all virtual functions of the base class. The pure
    virtual functions (which must be implemented if you want to create objects of
    the class) are enabled by default. Check that everything is set as in the preceding
    screenshot, and then click on OK. This convenient operation adds declaration and
    implementation of the selected virtual functions to the source files of our class.
    You can write them manually instead, if you want.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 函数列表包含基类的所有虚拟函数。默认情况下，纯虚拟函数（如果你想要创建类的对象，则必须实现）是启用的。请确认一切设置如前一个截图所示，然后点击 OK。这个方便的操作会将所选虚拟函数的声明和实现添加到我们类的源文件中。如果你愿意，也可以手动编写它们。
- en: 'Let''s edit `sineitem.cpp` to implement the two pure virtual functions. First
    of all, a couple of constants at the top of the file:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编辑 `sineitem.cpp` 来实现两个纯虚拟函数。首先，在文件顶部添加一些常量：
- en: '[PRE26]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In our graph, *x* will vary from 0 to `MAX_X`, and `DX` will be the difference
    between the two consequent points of the graph. As you may know, `sin(x)` can
    have values from -1 to 1\. This information is enough to implement the `boundingRect()`
    function:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的图中，*x* 将从 0 变化到 `MAX_X`，而 `DX` 将是图中两个连续点的差值。正如你可能知道的，`sin(x)` 的值可以从 -1 到
    1。这些信息足以实现 `boundingRect()` 函数：
- en: '[PRE27]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This function simply returns the same rectangle every time. In this rectangle,
    *x* changes from 0 to `MAX_X`, and *y* changes from -1 to 1\. This returned rectangle
    is a promise to the scene that the item will only paint in this area. The scene
    relies on the correctness of that information, so you should strictly obey that
    promise. Otherwise, the scene will become cluttered up with relics of your drawing!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数简单地每次都返回相同的矩形。在这个矩形中，*x* 从 0 变化到 `MAX_X`，而 *y* 从 -1 变化到 1。这个返回的矩形是对场景的一个承诺，表示项目只会在这个区域中绘制。场景依赖于这个信息的正确性，所以你应该严格遵守这个承诺。否则，场景将充满你绘制的遗迹！
- en: 'Now, implement the `paint()` function, as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，实现`paint()`函数，如下所示：
- en: '[PRE28]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Add `#include <QtMath>` to the top section of the file to make math functions
    available.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 将`#include <QtMath>`添加到文件的顶部部分，以便使数学函数可用。
- en: What just happened?
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'When the view needs to display the scene, it calls the `paint()` function of
    each visible item and provides three arguments: a `QPainter` pointer that should
    be used for painting, a `QStyleOptionGraphicsItem` pointer that contains painting-related
    parameters for this item, and an optional `QWidget` pointer that may point to
    the currently painted widget. In the implementation of the function, we start
    with setting a cosmetic pen in the `painter` so that the line width of our graph
    is always 1\. Next, we calculate the number of points in the graph and save it
    to the `steps` variable. Then, we create a variable to store the previous point
    of the graph and initialize it with the position of the first point of the graph
    (corresponding to `x = 0`). Next, we iterate through points, calculate *x* and
    *y* for each point, and then use the `painter` object to draw a line from the
    previous point to the current point. After this, we update the value of the `previousPoint`
    variable. We use the `Q_UNUSED()` macro to suppress compiler warnings about unused
    arguments and to indicate that we, intentionally, didn''t use them.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图需要显示场景时，它会调用每个可见项目的`paint()`函数，并提供三个参数：一个用于绘制的`QPainter`指针，一个包含此项目绘制相关参数的`QStyleOptionGraphicsItem`指针，以及一个可选的`QWidget`指针，它可能指向当前绘制的窗口小部件。在函数的实现中，我们首先在`painter`中设置一个装饰性笔，以便我们的图形线条宽度始终为1。然后，我们计算图形中的点数并将其保存到`steps`变量中。接下来，我们创建一个变量来存储图形的前一个点，并将其初始化为图形的第一个点的位置（对应于`x
    = 0`）。然后，我们遍历点，为每个点计算*x*和*y*，然后使用`painter`对象从前一个点到当前点绘制一条线。之后，我们更新`previousPoint`变量的值。我们使用`Q_UNUSED()`宏来抑制编译器关于未使用参数的警告，并表明我们有意没有使用它们。
- en: 'Edit the constructor of our `View` class to create an instance of our new item:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑我们的`View`类的构造函数以创建我们新项目的实例：
- en: '[PRE29]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The application should display the sine graph now, but it is very small:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在应该显示正弦图，但它非常小：
- en: '![](img/23ef1e22-8726-480b-baaa-2cb0b21a05f3.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23ef1e22-8726-480b-baaa-2cb0b21a05f3.png)'
- en: We should add a way for users to scale our view using the mouse wheel. However,
    before we get to this, you need to learn a little more about event handling.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该添加一种方式，让用户可以通过鼠标滚轮缩放我们的视图。然而，在我们做到这一点之前，你需要学习更多关于事件处理的知识。
- en: Events
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: Any GUI application needs to react to the input events. We are already familiar
    with the signals and slots mechanism in `QObject`-based classes. However, `QObject`
    is not exactly a lightweight class. Signals and slots are powerful and convenient
    for connecting parts of the application, but invoking a signal for processing
    each keyboard press or mouse move will be too inefficient. To process such events,
    Qt has a special system that uses the `QEvent` class.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 任何GUI应用程序都需要对输入事件做出反应。我们已经熟悉了基于`QObject`类的信号和槽机制。然而，`QObject`并不是一个轻量级的类。信号和槽对于连接应用程序的各个部分来说非常强大和方便，但为每个键盘按键或鼠标移动调用信号将会非常低效。为了处理此类事件，Qt有一个特殊的系统，它使用`QEvent`类。
- en: The dispatcher of the events is the **event loop**. Almost any Qt application
    uses the main event loop that is started by calling `QCoreApplication::exec` at
    the end of the `main()` function. While the application is running, the control
    flow is either in your code (that is, in the implementation of any function in
    the project) or in the event loop. When the operating system or a component of
    the application asks the event loop to process an event, it determines the receiver
    and calls a virtual function that corresponds to the event type. A `QEvent` object
    containing information about the event is passed to that function. The virtual
    function has a choice to **accept** or **ignore** the event. If the event was
    not accepted, the event is **propagated** to the parent object in the hierarchy
    (for example, from a widget to its parent widget, and from a graphics item to
    the parent item). You can subclass a Qt class and reimplement a virtual function
    to add custom events processing.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 事件调度器是 **事件循环**。几乎任何 Qt 应用程序都使用由在 `main()` 函数末尾调用 `QCoreApplication::exec` 启动的主事件循环。当应用程序运行时，控制流程要么在您的代码中（即在项目的任何函数的实现中），要么在事件循环中。当操作系统或应用程序的组件要求事件循环处理一个事件时，它确定接收器并调用与事件类型相对应的虚函数。一个包含有关事件信息的
    `QEvent` 对象被传递到该函数。虚函数可以选择 **接受** 或 **忽略** 事件。如果事件未被接受，事件将被 **传播** 到层次结构中的父对象（例如，从一个小部件到其父小部件，从一个图形项到其父项）。您可以通过子类化
    Qt 类并重新实现虚函数来添加自定义事件处理。
- en: 'The following table shows the most useful events:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了最有用的事件：
- en: '| **Event types** | **Description** |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **事件类型** | **描述** |'
- en: '| `QEvent::KeyPress`, `QEvent::KeyRelease` | A keyboard button was pressed
    or released. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `QEvent::KeyPress`、`QEvent::KeyRelease` | 按键被按下或释放。 |'
- en: '| `QEvent::MouseButtonPress`, `QEvent::MouseButtonRelease`, `QEvent::MouseButtonDblClick`
    | The mouse buttons were pressed or released. |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `QEvent::MouseButtonPress`、`QEvent::MouseButtonRelease`、`QEvent::MouseButtonDblClick`
    | 鼠标按钮被按下或释放。 |'
- en: '| `QEvent::Wheel` | The mouse wheel was rolled. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `QEvent::Wheel` | 鼠标滚轮被滚动。 |'
- en: '| `QEvent::Enter` | The mouse cursor entered the object''s boundaries. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `QEvent::Enter` | 鼠标光标进入了对象的边界。 |'
- en: '| `QEvent::MouseMove` | The mouse cursor was moved. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `QEvent::MouseMove` | 鼠标光标被移动。 |'
- en: '| `QEvent::Leave` | The mouse cursor left the object''s boundaries. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `QEvent::Leave` | 鼠标光标离开了对象的边界。 |'
- en: '| `QEvent::Resize` | The widget was resized (for example, because the user
    resized the window or the layout changed). |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `QEvent::Resize` | 小部件的大小被调整（例如，因为用户调整了窗口大小或布局发生了变化）。 |'
- en: '| `QEvent::Close` | The user attempted to close the widget''s window. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `QEvent::Close` | 用户尝试关闭小部件的窗口。 |'
- en: '| `QEvent::ContextMenu` | The user requested a context menu (the exact action
    depends on the operating system''s way to open the context menu). |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `QEvent::ContextMenu` | 用户请求一个上下文菜单（确切的操作取决于操作系统打开上下文菜单的方式）。 |'
- en: '| `QEvent::Paint` | The widget needs to be repainted. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `QEvent::Paint` | 小部件需要重新绘制。 |'
- en: '| `QEvent::DragEnter`, `QEvent::DragLeave`, `QEvent::DragMove`, `QEvent::Drop`
    | The user performs a drag and drop action. |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `QEvent::DragEnter`、`QEvent::DragLeave`、`QEvent::DragMove`、`QEvent::Drop`
    | 用户执行了拖放操作。 |'
- en: '| `QEvent::TouchBegin`, `QEvent::TouchUpdate`, `QEvent::TouchEnd`, `QEvent::TouchCancel`
    | A touchscreen or a trackpad reported an event. |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `QEvent::TouchBegin`、`QEvent::TouchUpdate`、`QEvent::TouchEnd`、`QEvent::TouchCancel`
    | 触摸屏或触摸板报告了一个事件。 |'
- en: Each event type has a corresponding class that inherits `QEvent` (for example, `QMouseEvent`).
    Many event types have the dedicated virtual function, for example, `QWidget::mousePressEvent`
    and `QGraphicsItem::mousePressEvent`. More exotic events must be processed by
    re-implementing the `QWidget::event` (or `QGraphicsItem::sceneEvent`) function
    that receives all events, and using `event->type()` to check the event type.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 每种事件类型都有一个对应的类，该类继承自 `QEvent`（例如，`QMouseEvent`）。许多事件类型都有专门的虚函数，例如，`QWidget::mousePressEvent`
    和 `QGraphicsItem::mousePressEvent`。更特殊的事件必须通过重新实现接收所有事件的 `QWidget::event`（或 `QGraphicsItem::sceneEvent`）函数来处理，并使用
    `event->type()` 来检查事件类型。
- en: Events dispatched in the graphics scene have special types (for example, `QEvent::GraphicsSceneMousePress`)
    and special classes (for example, `QGraphicsSceneMouseEvent`) because they have
    an extended set of information about the event. In particular, mouse events contain
    information about the coordinates in the item's and the scene's coordinate systems.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图形场景中派发的事件有特殊类型（例如，`QEvent::GraphicsSceneMousePress`）和特殊类（例如，`QGraphicsSceneMouseEvent`），因为它们包含有关事件的扩展信息集。特别是鼠标事件包含有关项目及其场景坐标系统中的坐标信息。
- en: Time for action – Implementing the ability to scale the scene
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 实现缩放场景的能力
- en: 'Let''s allow the user to scale the scene using the mouse wheel on the view.
    Switch to the `view.h` file and add a declaration and an implementation of the `wheelEvent()`
    virtual function using the same method we just used in the `SineItem` class. Write
    the following code in the `view.cpp` file:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们允许用户通过在视图中使用鼠标滚轮来缩放场景。切换到`view.h`文件，并添加一个声明和一个实现`wheelEvent()`虚拟函数的声明，使用我们在`SineItem`类中刚刚使用的方法。在`view.cpp`文件中编写以下代码：
- en: '[PRE30]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you run the application now, you can scale the sine graph using the mouse
    wheel.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你可以使用鼠标滚轮来缩放正弦图。
- en: What just happened?
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: When an event occurs, Qt calls the corresponding virtual function in the widget
    in which the event occurred. In our case, whenever the user uses the mouse wheel
    on our view, the `wheelEvent()` virtual function will be called, and the `event`
    argument will hold information about the event.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件发生时，Qt会调用事件发生的小部件中的相应虚拟函数。在我们的情况下，每当用户在我们的视图中使用鼠标滚轮时，`wheelEvent()`虚拟函数将被调用，`event`参数将包含有关事件的信息。
- en: In our implementation, we start with calling the base class's implementation.
    It is very important to do this whenever you reimplement a virtual function, unless
    you want the default behavior to be completely disabled. In our case, `QGraphicsView::wheelEvent()`
    will pass the event to the scene, and if we forget to call this function, neither
    the scene nor any of its items will receive any wheel events, which can be very
    much unwanted in some cases.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，我们首先调用基类的实现。在重新实现虚拟函数时，无论何时都要这样做，除非你希望默认行为完全禁用。在我们的情况下，`QGraphicsView::wheelEvent()`会将事件传递给场景，如果我们忘记调用此函数，场景及其任何项目都不会收到任何滚轮事件，在某些情况下这可能会非常不受欢迎。
- en: After the default implementation is complete, we use the `isAccepted()` function
    to check whether an event was accepted by the scene or any items. The event will
    be rejected by default, but if we later add some item that can process wheel events
    (for example, a text document with its own scrollbar), it will receive and accept
    the event. In that case, we don't want to perform any other action based on this
    event, as it's usually desirable that any event is only processed (and accepted)
    in one location.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认实现完成后，我们使用`isAccepted()`函数来检查事件是否被场景或任何项目接受。默认情况下，事件将被拒绝，但如果我们后来添加一些可以处理滚轮事件的项目（例如，带有自己滚动条的文本文档），它将接收并接受该事件。在这种情况下，我们不想基于此事件执行任何其他操作，因为通常希望任何事件只在一个位置被处理（和接受）。
- en: In some cases, you may want your custom implementation to take priority over
    the default one. In that case, move the call to the default implementation to
    the end of the function body. When you want to prevent a particular event from
    being dispatched to the scene, use an early `return` to prevent the default implementation
    from executing.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能希望你的自定义实现比默认实现具有优先级。在这种情况下，将调用默认实现的代码移动到函数体的末尾。当你想要阻止特定事件被分派到场景时，使用早期的`return`来防止默认实现执行。
- en: The `factor` parameter for the zooming can be freely defined. You can also create
    a getter and setter method for it. For us, 1.1 will do the work. With `event->angleDelta()`,
    you get the distance of the mouse's wheel rotation as a `QPoint` pointer. Since
    we only care about vertical scrolling, just the *y* axis is relevant for us. In
    our example, we also do not care about how far the wheel was turned because, normally,
    every step is delivered separately to `wheelEvent()`. However, if you should need
    it, it's in eighths of a degree, and since most mouses work in general steps of
    15 degrees, the value should be 120 or -120, depending on whether you move the
    wheel forward or backward. On a forward wheel move, if `y()` is greater than zero,
    we zoom in using the already familiar `scale()` function. Otherwise, if the wheel
    was moved backward, we zoom out. Finally, we accept the event, indicating that
    the user's input was understood, and there is no need to propagate the event to
    parent widgets (although the view currently doesn't have a parent). That's all
    there is to it.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放的`factor`参数可以自由定义。你也可以为它创建一个getter和setter方法。对我们来说，1.1就可以完成工作。使用`event->angleDelta()`，你可以得到鼠标滚轮旋转的距离作为一个`QPoint`指针。由于我们只关心垂直滚动，所以对我们来说，只有*y*轴是相关的。在我们的例子中，我们也不关心滚轮滚动的距离有多远，因为通常，每个步骤都会单独传递给`wheelEvent()`。但是，如果你需要它，它是以八分之一度为单位，而且由于大多数鼠标以15度的通用步骤工作，所以值应该是120或-120，具体取决于你是向前还是向后滚动滚轮。在向前滚动滚轮时，如果`y()`大于零，我们使用已经熟悉的`scale()`函数进行放大。否则，如果滚轮向后移动，我们进行缩小。最后，我们接受事件，表示用户的输入已被理解，不需要将事件传播到父小部件（尽管当前视图没有父小部件）。这就是全部内容。
- en: When you try this example, you will note that, while zooming, the view zooms
    in and out on the center of the view, which is the default behavior for the view.
    You can change this behavior with `setTransformationAnchor()`. `QGraphicsView::AnchorViewCenter`
    is, as described, the default behavior. With `QGraphicsView::NoAnchor`, the zoom
    center is in the top-left corner of the view, and the value you probably want
    to use is `QGraphicsView::AnchorUnderMouse`. With that option, the point under
    the mouse builds the center of the zooming and thus stays at the same position
    inside the view.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试这个示例时，你会注意到，在缩放时，视图在视图的中心进行放大和缩小，这是视图的默认行为。你可以使用`setTransformationAnchor()`来改变这种行为。`QGraphicsView::AnchorViewCenter`，正如描述的那样，是默认行为。使用`QGraphicsView::NoAnchor`，缩放中心位于视图的左上角，你可能想要使用的值是`QGraphicsView::AnchorUnderMouse`。使用这个选项，鼠标下的点构建缩放的中心，因此保持在视图内的同一位置。
- en: Time for action – Taking the zoom level into account
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 考虑缩放级别
- en: 'Our graph currently contains points with integer *x* values because we set
    `DX = 1`. This is exactly what we want for the default level of zoom, but once
    the view is zoomed in, it becomes apparent that the graph''s line is not smooth.
    We need to change `DX` based on the current zoom level. We can do this by adding
    the following code to the beginning of the `paint()` function():'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的图表包含具有整数*x*值的点，因为我们设置了`DX = 1`。这正是我们想要的默认缩放级别，但一旦视图被放大，就会明显看出图表的线条并不平滑。我们需要根据当前的缩放级别来改变`DX`。我们可以在`paint()`函数的开始处添加以下代码来实现这一点：
- en: '[PRE31]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Delete the `DX` constant and replace `DX` with `dx` in the rest of the code.
    Now, when you scale the view, the graph's line keeps being smooth because the
    number of points increases dynamically. The `levelOfDetailFromTransform` helper
    function examines the value of the painter's transformation (which is a combination
    of all transformations applied to the item) and returns the **level of detail**.
    If the item is zoomed in 2:1, the level of detail is 2, and if the item is zoomed
    out 1:2, the level of detail is 0.5.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`DX`常量，并在代码的其余部分将`DX`替换为`dx`。现在，当你缩放视图时，图表的线条保持平滑，因为点的数量会动态增加。`levelOfDetailFromTransform`辅助函数检查画笔变换的值（这是应用于项目的所有变换的组合）并返回**细节级别**。如果项目以2:1的比例放大，细节级别为2，如果项目以1:2的比例缩小，细节级别为0.5。
- en: Time for action – Reacting to an item's selection state
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 响应项目的选择状态
- en: 'Standard items, when selected, change appearance (for example, the outline
    usually becomes dashed). When we''re creating a custom item, we need to implement
    this feature manually. Let''s make our item selectable in the `View` constructor:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 标准项目在被选中时，会改变外观（例如，轮廓通常变为虚线）。当我们创建自定义项目时，我们需要手动实现这个功能。让我们在`View`构造函数中使我们的项目可选中：
- en: '[PRE32]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s make the graph line green when the item is selected:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在项目被选中时将图表线条设置为绿色：
- en: '[PRE33]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What just happened?
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The `state` variable is a bitmask holding the possible states of the item. You
    can check its value against the values of the `QStyle::StateFlag` parameter using
    bitwise operators. In the preceding case, the `state` variable is checked against
    the `State_Selected` parameter. If this flag is set, we use green color for the
    pen.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`state` 变量是一个位掩码，包含项目的可能状态。你可以使用位运算符将其值与 `QStyle::StateFlag` 参数的值进行比较。在前面的例子中，`state`
    变量被与 `State_Selected` 参数进行比较。如果此标志被设置，我们将使用绿色笔刷。'
- en: The type of state is `QFlags<StateFlag>`. So, instead of using the bitwise operator
    to test whether a flag is set, you can use the convenient function `testFlag()`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的类型是 `QFlags<StateFlag>`。因此，你不必使用位运算符来测试标志是否设置，而是可以使用方便的函数 `testFlag()`。
- en: 'Used with the preceding example, it would be as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例一起使用时，它将是以下内容：
- en: '[PRE34]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The most important states you can use with items are described in the following
    table:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用项目描述的最重要的状态如下表所示：
- en: '| **State** | **Description** |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| **状态** | **描述** |'
- en: '| `State_Enabled` | Indicates that the item is enabled. If the item is disabled,
    you may want to draw it as grayed out. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `State_Enabled` | 表示项目处于启用状态。如果项目被禁用，你可能想将其绘制为灰色。|'
- en: '| `State_HasFocus` | Indicates that the item has the input focus. To receive
    this state, the item needs to have the `ItemIsFocusable` flag set. |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `State_HasFocus` | 表示项目具有输入焦点。要接收此状态，项目需要设置 `ItemIsFocusable` 标志。|'
- en: '| `State_MouseOver` | Indicates that the cursor is currently hovering over
    the item. To receive this state, the item needs to have the `acceptHoverEvents`
    variable set to `true`. |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `State_MouseOver` | 表示光标当前悬停在项目上。要接收此状态，项目需要将 `acceptHoverEvents` 变量设置为 `true`。|'
- en: '| `State_Selected` | Indicates that the item is selected. To receive this state,
    the item needs to have the `ItemIsSelectable` flag set. The normal behavior would
    be to draw a dashed line around the item as a selection marker. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `State_Selected` | 表示项目被选中。要接收此状态，项目需要设置 `ItemIsSelectable` 标志。正常行为将是绘制一个虚线围绕项目作为选择标记。|'
- en: Besides the state, `QStyleOptionGraphicsItem` offers much more information about
    the currently used style, such as the palette and the font used, accessible through
    the `QStyleOptionGraphicsItem::palette` and `QStyleOptionGraphicsItem::fontMetrics`
    parameters, respectively. If you aim for style-aware items, take a deeper look
    at this class in the documentation.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 除了状态之外，`QStyleOptionGraphicsItem` 还提供了关于当前使用的样式的大量信息，例如调色板和字体，分别通过 `QStyleOptionGraphicsItem::palette`
    和 `QStyleOptionGraphicsItem::fontMetrics` 参数访问。如果你旨在创建具有样式感知的项目，请在文档中更深入地了解此类。
- en: Time for action – Event handling in a custom item
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 - 在自定义项目中的事件处理
- en: Items, like widgets, can receive events in virtual functions. If you click on
    a scene (to be precise, you click on a view that propagates the event to the scene),
    the scene receives the mouse press event, and it then becomes the scene's responsibility
    to determine which item was meant by the click.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 项目，就像小部件一样，可以在虚拟函数中接收事件。如果你点击场景（更准确地说，你点击一个将事件传播到场景的视图），场景将接收鼠标按下事件，然后它就变成了场景的责任来确定点击的是哪个项目。
- en: 'Let''s override the `SineItem::mousePressEvent` function that is called when
    the user presses a mouse button inside the item:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写当用户在项目内部按下鼠标按钮时调用的 `SineItem::mousePressEvent` 函数：
- en: '[PRE35]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When a mouse press event occurs, this function is called and the passed `event`
    object contains information about the event. In our case, we check whether the
    left mouse button was pressed and use the `event->pos()` function that returns
    coordinates of the clicked point *in the item's coordinate system*. In this example,
    we ignored the *y* coordinate and used the *x* coordinate to find the corresponding
    point on our graph. Then, we simply created a child circle item that shows that
    point. We `accept` the event if we did understand the action performed and `ignore`
    it if we don't know what it means so that it can be passed to another item. You
    can run the application and click on the graph to see these circles. Note that
    when you click outside of the graph's bounding rect, the scene doesn't dispatch
    the event to our item, and its `mousePressEvent()` function is not called.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标按下事件发生时，此函数会被调用，传递的`event`对象包含有关事件的信息。在我们的例子中，我们检查是否按下了左鼠标按钮，并使用`event->pos()`函数来获取点击点的坐标，该函数返回点击点在项目坐标系统中的坐标。在这个例子中，我们忽略了*y*坐标，并使用*x*坐标来找到我们图表上的对应点。然后，我们简单地创建了一个子圆形项目来显示该点。如果我们理解了所执行的操作，我们就`接受`事件，如果我们不知道它的含义，我们就`忽略`它，以便它可以传递给另一个项目。你可以运行应用程序并点击图表来查看这些圆圈。请注意，当你点击图表外部时，场景不会将事件分发给我们的项目，其`mousePressEvent()`函数不会被调用。
- en: The `event` object also contains the `button()` function that returns the button
    that was pressed, and the `scenePos()` function that returns the clicked point
    in the scene's coordinate system. The scene's responsibility for delivering events
    does not only apply to mouse events, but also to key events and all other sorts
    of events.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`event`对象还包含`button()`函数，该函数返回被按下的按钮，以及`scenePos()`函数，该函数返回场景坐标系统中的点击点。场景负责传递事件不仅适用于鼠标事件，还适用于键盘事件和其他所有类型的事件。'
- en: Time for action – Implementing the ability to create and delete elements with
    mouse
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 实现使用鼠标创建和删除元素的能力
- en: 'Let''s allow the users to create new instances of our sine item when they click
    on the view with the left mouse button and delete the items if they use the right
    mouse button. Reimplement the `View::mousePressEvent` virtual function, as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们允许用户在点击视图时使用左鼠标按钮创建我们正弦项的新实例，如果他们使用右鼠标按钮，则删除这些项目。重新实现`View::mousePressEvent`虚函数，如下所示：
- en: '[PRE36]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we first check whether the event was accepted by the scene or any of its
    items. If not, we determine which button was pressed. For the left button, we
    create a new item and place it in the corresponding point of the scene. For the
    right button, we search for an item at that position and delete it. In both cases,
    we accept the event. When you run the application, you will note that if the user
    clicks on an existing item, a new circle will be added, and if the user clicks
    outside of any items, a new sine item will be added. That's because we properly
    set and read the `accepted` property of the event.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先检查事件是否被场景或其任何项目接受。如果没有，我们确定哪个按钮被按下。对于左按钮，我们创建一个新的项目并将其放置在场景的相应点上。对于右按钮，我们在该位置搜索项目并将其删除。在这两种情况下，我们都接受事件。当你运行应用程序时，你会注意到，如果用户点击现有项目，将添加一个新的圆圈，如果用户点击任何项目外部，将添加一个新的正弦项目。这是因为我们正确地设置了事件的`accepted`属性。
- en: You may note that the scene jumps within the view when we add a new item. This
    is caused by changes of the scene rect. To prevent this, you can set a constant
    rect using `setSceneRect()` or change the alignment using `setAlignment(Qt::AlignTop
    | Qt::AlignLeft)` in the view's constructor.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，当我们添加新项目时，场景在视图中跳跃。这是由于场景矩形的变化引起的。为了防止这种情况，你可以使用`setSceneRect()`设置一个常量矩形，或者在视图的构造函数中使用`setAlignment(Qt::AlignTop
    | Qt::AlignLeft)`来更改对齐方式。
- en: Time for action – Changing the item's size
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 更改项目的大小
- en: 'Our custom graphics item always displays the graph for *x* values between 0
    and 50\. It would be neat to make this a configurable setting. Declare a private
    `float m_maxX` field in the `SineItem` class, remove the `MAX_X` constant, and
    replace its uses with `m_maxX` in the rest of the code. As always, you must set
    the initial value of the field in the constructor, or bad things can happen. Finally,
    implement a getter and a setter for it, as shown:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制图形项目始终显示*x*值在0到50之间的图表。将此设置为可配置设置会很好。在`SineItem`类中声明一个私有的`float m_maxX`字段，删除`MAX_X`常量，并在代码的其余部分使用`m_maxX`替换其使用。始终必须在构造函数中设置字段的初始值，否则可能会发生不良情况。最后，实现它的getter和setter，如下所示：
- en: '[PRE37]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The only non-trivial part here is the `prepareGeometryChange()` call. This method
    is inherited from `QGraphicsItem` and notifies the scene that our `boundingRect()`
    function will return a different value on the next update. The scene caches bounding
    rectangles of the items, so if you don't call `prepareGeometryChange()`, the change
    of the bounding rectangle may not take effect. This action also schedules an update
    for our item.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一非平凡的部分是 `prepareGeometryChange()` 调用。这个方法是从 `QGraphicsItem` 继承的，并通知场景我们的
    `boundingRect()` 函数将在下一次更新时返回不同的值。场景缓存了项的边界矩形，所以如果你不调用 `prepareGeometryChange()`，边界矩形的更改可能不会生效。这个动作也会为我们的项安排一个更新。
- en: When the bounding rect does not change but the actual content of the item changes,
    you need to call `update()` on the item to notify the scene that it should repaint
    the item.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当边界矩形没有变化，但项的实际内容发生变化时，你需要在小部件上调用 `update()` 来通知场景它应该重新绘制该小部件。
- en: Have a go hero – Extending the item's functionality
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试扩展项的功能
- en: The abilities of `SineItem` are still pretty limited. As an exercise, you can
    try to add an option to change the minimum *x* value of the graph or set a different
    pen. You can even allow the user to specify an arbitrary function pointer to replace
    the `sin()` function. However, keep in mind that the bounding rect of the item
    depends on the value range of the function, so you need to update the item's geometry
    accurately.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`SineItem` 的功能仍然相当有限。作为一个练习，你可以尝试添加一个选项来更改图形的最小 *x* 值或设置不同的画笔。你甚至可以允许用户指定一个任意函数指针来替换
    `sin()` 函数。然而，请记住，项的边界矩形取决于函数的值域，因此你需要准确更新项的几何形状。'
- en: Widgets inside Graphics View
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Graphics View 中的小部件
- en: 'In order to show a neat feature of Graphics View, take a look at the following
    code snippet, which adds a widget to the scene:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 Graphics View 的一个整洁特性，请看以下代码片段，它向场景添加了一个小部件：
- en: '[PRE38]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'First, we create a `QSpinBox` and a `QGraphicsProxyWidget` element, which act
    as containers for widgets and indirectly inherit `QGraphicsItem.` Then, we add
    the spin box to the proxy widget by calling `addWidget()`. When `QGraphicsProxyWidget`
    gets deleted, it calls `delete` on all assigned widgets, so we do not have to
    worry about that ourselves. The widget you add should be parentless and must not
    be shown elsewhere. After setting the widget to the proxy, you can treat the proxy
    widget like any other item. Next, we add it to the scene and apply a transformation
    for demonstration. As a result, we get this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `QSpinBox` 和一个 `QGraphicsProxyWidget` 元素，它们作为小部件的容器，并间接继承 `QGraphicsItem`。然后，我们通过调用
    `addWidget()` 将旋转框添加到代理小部件中。当 `QGraphicsProxyWidget` 被删除时，它会调用所有分配的小部件的 `delete`
    方法，所以我们不必自己担心这一点。你添加的小部件应该是无父级的，并且不能在其他地方显示。在将小部件设置到代理后，你可以像对待任何其他项一样处理代理小部件。接下来，我们将它添加到场景中，并应用一个变换以进行演示。结果如下：
- en: '![](img/2f93b81a-9072-445b-af32-a9ee80065407.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f93b81a-9072-445b-af32-a9ee80065407.png)'
- en: Be aware that, originally, Graphics View wasn't designed for holding widgets.
    So when you add a lot of widgets to the scene, you will quickly notice performance
    issues, but in most situations, it should be fast enough.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最初，Graphics View 并不是为容纳小部件而设计的。所以当你向场景添加很多小部件时，你将很快注意到性能问题，但在大多数情况下，它应该足够快。
- en: 'If you want to arrange some widgets in a layout, you can use `QGraphicsAnchorLayout`,
    `QGraphicsGridLayout`, or `QGraphicsLinearLayout`. Create all widgets, create
    a layout of your choice, add the widgets to that layout, and set the layout to
    a `QGraphicsWidget` element, which is the base class for all widgets and is, easily
    spoken, the `QWidget` equivalent for Graphics View by calling `setLayout()`:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在布局中排列一些小部件，你可以使用 `QGraphicsAnchorLayout`、`QGraphicsGridLayout` 或 `QGraphicsLinearLayout`。创建所有小部件，创建一个你选择的布局，将小部件添加到该布局中，并将布局设置到
    `QGraphicsWidget` 元素上，这是所有小部件的基类，简单来说，是 Graphics View 的 `QWidget` 等价物，通过调用 `setLayout()`
    实现：
- en: '[PRE39]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The scene''s `addWidget()` function is a convenience function and behaves similar
    to `addRect`, as shown in the following code snippet:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 场景的 `addWidget()` 函数是一个便利函数，其行为类似于 `addRect`，如下面的代码片段所示：
- en: '[PRE40]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The item with the layout will look like this:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 带有布局的项将看起来像这样：
- en: '![](img/f01f4b1c-7c36-4056-82c4-79869bbcb137.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f01f4b1c-7c36-4056-82c4-79869bbcb137.png)'
- en: Optimization
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化
- en: When adding many items to a scene or using items with complex `paint()` functions,
    the performance of your application may decrease. While default optimizations
    of Graphics View are suitable for most cases, you may need to tweak them to achieve
    better performance. Let's now take a look at some of the optimizations we can
    perform to speed up the scene.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 当向场景添加许多项目或使用具有复杂`paint()`函数的项目时，您应用程序的性能可能会下降。虽然图形视图的默认优化适用于大多数情况，但您可能需要调整它们以获得更好的性能。现在让我们看看我们可以执行的一些优化，以加快场景的速度。
- en: A binary space partition tree
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉空间划分树
- en: The scene constantly keeps a record of the position of the item in its internal
    binary space partition tree. Thus, on every move of an item, the scene has to
    update the tree, an operation that can become quite time-consuming, and also memory
    consuming. This is especially true of scenes with a large number of animated items.
    On the other hand, the tree enables you to find an item (for example, with `items()`
    or `itemAt()`) incredibly quickly, even if you have thousands of items.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 场景持续记录项目在其内部二叉空间划分树中的位置。因此，每当项目移动时，场景都必须更新树，这个操作可能非常耗时，并且消耗内存。这对于包含大量动画项目的场景尤其如此。另一方面，树使您能够以极快的速度找到项目（例如，使用`items()`或`itemAt()`），即使您有成千上万的项目。
- en: So when you do not need any positional information about the items—this also
    includes collision detection—you can disable the index function by calling `setItemIndexMethod(QGraphicsScene::NoIndex)`.
    Be aware, however, that a call to `items()` or `itemAt()` results in a loop through
    all items in order to do the collision detection, which can cause performance
    problems for scenes with many items. If you cannot relinquish the tree in total,
    you can still adjust the depth of the tree with `setBspTreeDepth()`, taking the
    depth as an argument. By default, the scene will guess a reasonable value after
    it takes several parameters, such as the size and the number of items, into account.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当您不需要任何关于项目的位置信息时——这包括碰撞检测——您可以通过调用`setItemIndexMethod(QGraphicsScene::NoIndex)`来禁用索引函数。然而，请注意，调用`items()`或`itemAt()`会导致遍历所有项目以进行碰撞检测，这可能会对包含许多项目的场景造成性能问题。如果您不能完全放弃树，您仍然可以通过`setBspTreeDepth()`调整树的深度，将深度作为参数。默认情况下，场景将在考虑了几个参数（如大小和项目数量）后猜测一个合理的值。
- en: Caching the item's paint function
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存项目的绘制函数
- en: If you have items with a time-consuming paint function, you can change the item's
    cache mode. By default, no rendering is cached. With `setCacheMode()`, you can
    set the mode to either `ItemCoordinateCache` or `DeviceCoordinateCache`. The former
    renders the item in a cache of a given `QSize` element. The size of that cache
    can be controlled with the second argument of `setCacheMode()`, so the quality
    depends on how much space you assign. The cache is then used for every subsequent
    paint call. The cache is even used for applying transformations. If the quality
    deteriorates too much, just adjust the resolution by calling `setCacheMode()`
    again, but with a larger `QSize` element. `DeviceCoordinateCache`, on the other
    hand, does not cache the item on an item base but on a device level. This is,
    therefore, optimal for items that do not get transformed all the time because
    every new transformation will cause a new caching. Moving the item, however, does
    not invalidate the cache. If you use this cache mode, you do not have to define
    a resolution with the second argument. The caching is always performed at maximum
    quality.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有耗时的绘制函数的项目，您可以更改项目的缓存模式。默认情况下，没有渲染缓存。通过`setCacheMode()`，您可以设置模式为`ItemCoordinateCache`或`DeviceCoordinateCache`。前者在给定`QSize`元素的缓存中渲染项目。该缓存的大小可以通过`setCacheMode()`的第二个参数控制，因此质量取决于您分配的空间量。缓存随后用于每个后续的绘制调用。缓存甚至用于应用变换。如果质量下降太多，只需通过再次调用`setCacheMode()`并使用更大的`QSize`元素来调整分辨率。另一方面，`DeviceCoordinateCache`不在项目级别缓存项目，而是在设备级别缓存。因此，这对于不经常变换的项目是最佳的，因为每次新的变换都会导致新的缓存。但是，移动项目不会使缓存失效。如果您使用此缓存模式，您不需要使用第二个参数定义分辨率。缓存始终以最大质量执行。
- en: Optimizing the view
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化视图
- en: Since we are talking about the item's `paint()` function, let's touch on something
    related. By default, the view ensures that the painter state is saved before calling
    the item's paint function and that the state gets restored afterward. This will
    end up saving and restoring the painter state, say 50 times, if you have a scene
    with 50 items. However, you can disable this behavior by calling `setOptimizationFlag(DontSavePainterState,
    true)` on the view. If you do this, it is now your responsibility to ensure that
    any `paint()` function that changes the state of the painter (including pen, brush,
    transformation, and many other properties) must restore the previous state at
    the end. If you prevent automatic saving and restoring, keep in mind that now
    the standard items will alter the painter state. So if you use both standard and
    custom items, either stay with the default behavior or set `DontSavePainterState`,
    but then set up the pen and brush with a default value in each item's paint function.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在谈论项目的`paint()`函数，让我们谈谈相关的内容。默认情况下，视图确保在调用项目的`paint()`函数之前保存绘图状态，并在之后恢复状态。如果您有一个包含50个项目的场景，这将最终导致保存和恢复绘图状态约50次。然而，您可以通过在视图中调用`setOptimizationFlag(DontSavePainterState,
    true)`来禁用此行为。如果您这样做，现在您有责任确保任何更改绘图状态（包括笔、画刷、变换和许多其他属性）的`paint()`函数必须在结束时恢复先前的状态。如果您阻止了自动保存和恢复，请记住现在标准项目将改变绘图状态。所以如果您同时使用标准和自定义项目，要么保持默认行为，要么设置`DontSavePainterState`，然后在每个项目的`paint()`函数中使用默认值设置笔和画刷。
- en: Another flag that can be used with `setOptimizationFlag()` is `DontAdjustForAntialiasing`.
    By default, the view adjusts the painting area of each item by two pixels in all
    directions. This is useful because when one paints anti-aliased, one easily draws
    outside the bounding rectangle. Enable that optimization if you do not paint anti-aliased
    or if you are sure that your painting will stay inside the bounding rectangle.
    If you enable this flag and spot painting artifacts on the view, you haven't respected
    the item's bounding rectangle!
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 可以与`setOptimizationFlag()`一起使用的另一个标志是`DontAdjustForAntialiasing`。默认情况下，视图通过所有方向调整每个项目的绘制区域两个像素。这很有用，因为当您绘制抗锯齿时，很容易绘制到边界矩形之外。如果您不绘制抗锯齿或确信您的绘制将始终保持在边界矩形内，请启用此优化。如果您启用了此标志并在视图中发现绘制伪影，那么您没有尊重项目的边界矩形！
- en: As a further optimization, you can define how the view should update its viewport
    when the scene changes. You can set the different modes with `setViewportUpdateMode()`.
    By default (`QGraphicsView::MinimalViewportUpdate`), the view tries to determine
    only those areas that need an update and repaints only these. However, sometimes
    it is more time-consuming to find all the areas that need a redraw than to just
    paint the entire viewport. This applies if you have many small updates. Then,
    `QGraphicsView::FullViewportUpdate` is the better choice since it simply repaints
    the whole viewport. A kind of combination of the last two modes is `QGraphicsView::BoundingRectViewportUpdate`.
    In this mode, Qt detects all areas that need a redraw, and then it redraws a rectangle
    of the viewport that covers all areas affected by the change. If the optimal update
    mode changes over time, you can tell Qt to determine the best mode using `QGraphicsView::SmartViewportUpdate`.
    The view then tries to find the best update mode.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步的优化，您可以定义视图在场景变化时应该如何更新其视口。您可以使用`setViewportUpdateMode()`设置不同的模式。默认情况下（`QGraphicsView::MinimalViewportUpdate`），视图试图确定仅需要更新的那些区域，并且只重新绘制这些区域。然而，有时找到所有需要重新绘制的区域比简单地绘制整个视口更耗时。如果您有很多小的更新，那么`QGraphicsView::FullViewportUpdate`是更好的选择，因为它简单地重新绘制整个视口。最后两种模式的组合是`QGraphicsView::BoundingRectViewportUpdate`。在这种模式下，Qt检测所有需要重新绘制的区域，然后重新绘制一个覆盖所有受更改影响的区域视口矩形。如果最佳更新模式随时间变化，您可以使用`QGraphicsView::SmartViewportUpdate`告诉Qt确定最佳模式。然后视图会尝试找到最佳的更新模式。
- en: OpenGL in the Graphics View
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形视图中的OpenGL
- en: 'As a last optimization, you can take advantage of OpenGL. Instead of using
    the default viewport based on `QWidget`, advise Graphics View to use an OpenGL
    widget:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的优化，您可以利用OpenGL。而不是使用基于`QWidget`的默认视口，建议图形视图使用OpenGL小部件：
- en: '[PRE41]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This usually improves the rendering performance. However, Graphics View wasn't
    designed for GPUs and can't use them effectively. There are ways to improve the
    situation, but that goes beyond the topic and scope of this chapter. You can find
    more information about OpenGL and Graphics View in the Boxes Qt example as well
    as in Rødal's article "Accelerate your Widgets with OpenGL", which can be found
    online at [https://doc.qt.io/archives/qq/qq26-openglcanvas.html](https://doc.qt.io/archives/qq/qq26-openglcanvas.html).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常可以提高渲染性能。然而，Graphics View并不是为GPU设计的，无法有效地使用它们。有一些方法可以改善这种情况，但这超出了本章的主题和范围。你可以在Qt的示例中以及Rødal的文章“使用OpenGL加速你的小部件”中找到更多关于OpenGL和Graphics
    View的信息，该文章可在网上找到[https://doc.qt.io/archives/qq/qq26-openglcanvas.html](https://doc.qt.io/archives/qq/qq26-openglcanvas.html)。
- en: If you want to use a framework designed to be GPU accelerated, you should turn
    your attention to Qt Quick (we will start working with it in [Chapter 11](b81d9c47-58fa-49dd-931a-864c7be05840.xhtml),
    *Introduction to Qt Quick*). However, Qt Quick has its own limitations compared
    to Graphics View. This topic is elaborated in Nichols's article *Should you still
    be using QGraphicsView?*, available at [https://blog.qt.io/blog/2017/01/19/should-you-be-using-qgraphicsview/](https://blog.qt.io/blog/2017/01/19/should-you-be-using-qgraphicsview/).
    Alternatively, you can access the full power of OpenGL directly using its API
    and helpful Qt utilities. We will describe this approach in [Chapter 9](15aa8ec3-9e80-4f68-8e0e-f365e860f5c5.xhtml)*,
    OpenGL and Vulkan in Qt applications*.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用一个旨在支持GPU加速的框架，你应该关注Qt Quick（我们将在[第11章](b81d9c47-58fa-49dd-931a-864c7be05840.xhtml)，*Qt
    Quick简介*）开始使用它）。然而，与Graphics View相比，Qt Quick有其自身的局限性。这个话题在Nichols的文章*你仍然应该使用QGraphicsView吗？*中有详细阐述，该文章可在[https://blog.qt.io/blog/2017/01/19/should-you-be-using-qgraphicsview/](https://blog.qt.io/blog/2017/01/19/should-you-be-using-qgraphicsview/)找到。或者，你可以直接通过其API和有用的Qt工具访问OpenGL的全部功能。我们将在[第9章](15aa8ec3-9e80-4f68-8e0e-f365e860f5c5.xhtml)*，Qt应用程序中的OpenGL和Vulkan*中描述这种方法。
- en: Unfortunately, we can't say that you have to do this or that to optimize Graphics
    View as it highly depends on your system and view/scene. What we can tell you,
    however, is how to proceed. Once you have finished your game based on Graphics
    View, measure the performance of your game using a profiler. Make an optimization
    you think may pay or simply guess, and then profile your game again. If the results
    are better, keep the change, otherwise reject it. This sounds simple and is the
    only way optimization can be done. There are no hidden tricks or deeper knowledge.
    With time, however, your forecasting will get better.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法告诉你必须做什么或做什么来优化Graphics View，因为它高度依赖于你的系统和视图/场景。然而，我们可以告诉你如何进行。一旦你完成了基于Graphics
    View的游戏，使用分析器测量你游戏的性能。进行你认为可能带来收益的优化，或者简单地猜测，然后再次分析你的游戏。如果结果更好，保留这个变化，否则拒绝它。这听起来很简单，这是优化可以进行的唯一方法。没有隐藏的技巧或更深入的知识。然而，随着时间的推移，你的预测将变得更好。
- en: Pop quiz
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. Which of the following classes is a widget class?
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 以下哪个类是窗口小部件类？
- en: '`QGraphicsView`'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QGraphicsView`'
- en: '`QGraphicsScene`'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QGraphicsScene`'
- en: '`QGraphicsItem`'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QGraphicsItem`'
- en: Q2\. Which of the following actions does not change the graphics item's position
    on the screen?
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 以下哪个操作不会改变图形项在屏幕上的位置？
- en: Scaling the view.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩放视图。
- en: Shearing this item's parent item.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剪切此项目的父项目。
- en: Translating this item.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 翻译此项目。
- en: Rotating this item's child item.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转此项目的子项目。
- en: Q3\. Which function is not mandatory to implement in a new class derived from
    `QGraphicsItem`?
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 在从 `QGraphicsItem` 派生的新类中，哪个函数不是必须实现的？
- en: '`boundingRect()`'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`boundingRect()`'
- en: '`shape()`'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shape()`'
- en: '`paint()`'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paint()`'
- en: Q4\. Which item class should be used to display a raster image in the Graphics
    View?
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. 在Graphics View中显示位图图像应该使用哪个项目类？
- en: '`QGraphicsRectItem`'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QGraphicsRectItem`'
- en: '`QGraphicsWidget`'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QGraphicsWidget`'
- en: '`QGraphicsPixmapItem`'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QGraphicsPixmapItem`'
- en: Summary
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how the Graphics View architecture works. We went
    through the building blocks of the framework (items, scene, and view). Next, you
    learned how their coordinate systems are related and how to use them to get the
    picture you want. Later on, we described the most useful and frequently needed
    features of Graphics View. Next, we covered creating custom items and handling
    input events. In order to build a bridge to the world of widgets, you also learned
    how to incorporate items based on `QWidget` into Graphics View. Finally, we discussed
    ways to optimize the scene.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 Graphics View 架构是如何工作的。我们探讨了框架的构建块（项目、场景和视图）。接下来，你学习了它们的坐标系是如何相关的，以及如何使用它们来获取你想要的画面。随后，我们描述了
    Graphics View 最有用且最常需要的特性。然后，我们介绍了创建自定义项目和处理输入事件的方法。为了连接到 widgets 的世界，你还学习了如何将基于
    `QWidget` 的项目整合到 Graphics View 中。最后，我们讨论了优化场景的方法。
- en: Now, you really know most of the functions of the Graphics View framework. With
    this knowledge, you can already do a lot of cool stuff. However, for a game, it
    is still too static. In the next chapter, we will go through the process of creating
    a complete game and learn to use the Animation framework.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经了解了 Graphics View 框架的大部分功能。有了这些知识，你现在已经可以做一些很酷的事情了。然而，对于一个游戏来说，它仍然太静态了。在下一章中，我们将通过创建一个完整游戏的过程，并学习如何使用
    Animation 框架。
