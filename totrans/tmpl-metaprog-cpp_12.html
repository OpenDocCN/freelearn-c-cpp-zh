<html><head></head><body><div><div><h1 id="_idParaDest-140"><em class="italic"><a id="_idTextAnchor188"/>Chapter 9</em>: The Ranges Library</h1>
			<p>The previous chapter was dedicated to understanding the three main pillars of the standard library: containers, iterators, and algorithms. Throughout that chapter, we used the abstract concept of range to represent a sequence of elements delimited by two iterators. The C++20 standard makes it easier to work with ranges by providing a ranges library, consisting of two main parts: on one hand, types that define non-owning ranges and adaptations of ranges, and on the other hand, algorithms that work with these range types and do not require iterators to define a range of elements.</p>
			<p>In this final chapter, we will address the following topics:</p>
			<ul>
				<li>Moving from abstract ranges to the ranges library</li>
				<li>Understanding range concepts and views</li>
				<li>Understanding the constrained algorithms</li>
				<li>Writing your own range adaptor</li>
			</ul>
			<p>By the end of this chapter, you will have a good understanding of the content of the ranges library and you will be able to write your own range adaptor.</p>
			<p>Let’s begin the chapter with a transition from the abstract concept of a range to the C++20 ranges library.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor189"/>Advancing from abstract ranges to the ranges library</h1>
			<p>We have used the term <em class="italic">range</em> many<a id="_idIndexMarker859"/> times in the previous<a id="_idIndexMarker860"/> chapter. A <code>std::vector</code>, <code>std::list</code>, and <code>std::map</code> are concrete implementations of the range abstraction. They have ownership of the elements and they are implemented using various data structures, such as arrays, linked-lists, or trees. The standard<a id="_idIndexMarker862"/> algorithms are generic. They are<a id="_idIndexMarker863"/> container-agnostic. They know nothing about <code>std::vector</code>, <code>std::list</code>, or <code>std::map</code>. They handle range abstractions with the help of iterators. However, this has a shortcoming: we always need to retrieve a beginning and end iterator from a container. Here are some examples:</p>
			<pre class="source-code">// sorts a vector</pre>
			<pre class="source-code">std::vector&lt;int&gt; v{ 1, 5, 3, 2, 4 };</pre>
			<pre class="source-code">std::sort(v.begin(), v.end());</pre>
			<pre class="source-code">// counts even numbers in an array</pre>
			<pre class="source-code">std::array&lt;int, 5&gt; a{ 1, 5, 3, 2, 4 };</pre>
			<pre class="source-code">auto even = std::count_if(</pre>
			<pre class="source-code">   a.begin(), a.end(), </pre>
			<pre class="source-code">   [](int const n) {return n % 2 == 0; });</pre>
			<p>There are few cases when you need to process only a part of the container’s elements. In the vast majority of cases, you just have to write <code>v.begin()</code> and <code>v.end()</code> over and over again. This includes variations such as calls to <code>cbegin()</code>/<code>cend()</code>, <code>rbegin()</code>/<code>rend()</code>, or the stand-alone functions <code>std::begin()</code>/<code>std::end()</code>, and so on. Ideally, we would prefer to shorten all this and be able to write the following:</p>
			<pre class="source-code">// sorts a vector</pre>
			<pre class="source-code">std::vector&lt;int&gt; v{ 1, 5, 3, 2, 4 };</pre>
			<pre class="source-code">sort(v);</pre>
			<pre class="source-code">// counts even numbers in an array</pre>
			<pre class="source-code">std::array&lt;int, 5&gt; a{ 1, 5, 3, 2, 4 };</pre>
			<pre class="source-code">auto even = std::count_if(</pre>
			<pre class="source-code">   a, </pre>
			<pre class="source-code">   [](int const n) {return n % 2 == 0; });</pre>
			<p>On the other hand, we often need<a id="_idIndexMarker864"/> to compose operations. Most of the time<a id="_idIndexMarker865"/> that involves many operations and code that is too verbose even when using standard algorithms. Let’s consider the following example: given a sequence of integers, we want to print to the console the square of all even numbers, except the first two, in descending order of their value (not their position in the sequence). There are multiple ways to solve the problem. The following is a possible solution:</p>
			<pre class="source-code">std::vector&lt;int&gt; v{ 1, 5, 3, 2, 8, 7, 6, 4 };</pre>
			<pre class="source-code">// copy only the even elements</pre>
			<pre class="source-code">std::vector&lt;int&gt; temp;</pre>
			<pre class="source-code">std::copy_if(v.begin(), v.end(), </pre>
			<pre class="source-code">             std::back_inserter(temp), </pre>
			<pre class="source-code">             [](int const n) {return n % 2 == 0; });</pre>
			<pre class="source-code">// sort the sequence</pre>
			<pre class="source-code">std::sort(temp.begin(), temp.end(), </pre>
			<pre class="source-code">          [](int const a, int const b) {return a &gt; b; });</pre>
			<pre class="source-code">// remove the first two</pre>
			<pre class="source-code">temp.erase(temp.begin() + temp.size() - 2, temp.end());</pre>
			<pre class="source-code">// transform the elements</pre>
			<pre class="source-code">std::transform(temp.begin(), temp.end(), </pre>
			<pre class="source-code">               temp.begin(),</pre>
			<pre class="source-code">               [](int const n) {return n * n; });</pre>
			<pre class="source-code">// print each element</pre>
			<pre class="source-code">std::for_each(temp.begin(), temp.end(), </pre>
			<pre class="source-code">              [](int const n) {std::cout &lt;&lt; n &lt;&lt; '\n'; });</pre>
			<p>I believe most people would agree<a id="_idIndexMarker866"/> that, although anyone familiar<a id="_idIndexMarker867"/> with the standard algorithms can easily read this code, it’s still a lot to write. It also requires a temporary container and repetitive calls to <code>begin</code>/<code>end</code>. Therefore, I also expect most people would more easily understand the following version of the previous code, and probably prefer to write it as such:</p>
			<pre class="source-code">std::vector&lt;int&gt; v{ 1, 5, 3, 2, 8, 7, 6, 4 };</pre>
			<pre class="source-code">sort(v);</pre>
			<pre class="source-code">auto r = v</pre>
			<pre class="source-code">         | filter([](int const n) {return n % 2 == 0; })</pre>
			<pre class="source-code">         | drop(2)</pre>
			<pre class="source-code">         | reverse</pre>
			<pre class="source-code">         | transform([](int const n) {return n * n; });</pre>
			<pre class="source-code">for_each(r, [](int const n) {std::cout &lt;&lt; n &lt;&lt; '\n'; });</pre>
			<p>This is what the C++20 standard provides with the help of the ranges library. This has two main components:</p>
			<ul>
				<li><strong class="bold">Views </strong>or<strong class="bold"> range adaptors</strong>, which represent non-owning iterable sequences. They<a id="_idIndexMarker868"/> enable us to compose operations<a id="_idIndexMarker869"/> more easily such as in the last example.</li>
				<li><strong class="bold">Constrained algorithms</strong>, which enable us to <a id="_idIndexMarker870"/>operate on concrete<a id="_idIndexMarker871"/> ranges (standard containers or ranges) and not on abstract ranges delimited with a pair of iterators (although that’s possible too).</li>
			</ul>
			<p>We will explore these two offerings of the ranges library in the next sections, and we will begin with ranges.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor190"/>Understanding range concepts and views</h1>
			<p>The term <em class="italic">range</em> refers to an abstraction<a id="_idIndexMarker872"/> that defines a sequence of elements bounded by start and end iterators. A range, therefore, represents an iterable sequence of elements. However, such a sequence can be defined<a id="_idIndexMarker873"/> in several ways:</p>
			<ul>
				<li>With a begin iterator and an end sentinel. Such a sequence is iterated from the beginning to the end. A <strong class="bold">sentinel</strong> is an object that indicates the<a id="_idIndexMarker874"/> end of the sequence. It can have the same type as the iterator type or it can be of a different type.</li>
				<li>With a start object<a id="_idIndexMarker875"/> and a size (number of elements), representing a so-called counted sequence. Such a sequence is iterated <em class="italic">N</em> times (where <em class="italic">N</em> represents the size) from the start.</li>
				<li>With a start and<a id="_idIndexMarker876"/> a predicate, representing a so-called conditionally terminated sequence. Such a sequence is iterated from the start until the predicate returns false.</li>
				<li>With only a start value, representing<a id="_idIndexMarker877"/> a so-called unbounded sequence. Such a sequence can be iterated indefinitely.</li>
			</ul>
			<p>All these kinds of iterable sequences<a id="_idIndexMarker878"/> are considered ranges. Because a range is an abstraction, the C++20 library defines a series of concepts to describe requirements for range types. These are available in the <code>&lt;ranges&gt;</code> header and the <code>std::ranges</code> namespace. The following table presents the list of range concepts:</p>
			<div><div><img src="img/Table_9.01_B18367.jpg" alt="Table 9.1" width="1495" height="1649"/>
				</div>
			</div>
			<p class="figure-caption">Table 9.1</p>
			<p>The standard library defines <a id="_idIndexMarker879"/>a series of access functions for containers and arrays. These include <code>std::begin</code> and <code>std::end</code> instead of member functions <code>begin</code> and <code>end</code>, <code>std::size</code> instead of member<a id="_idIndexMarker880"/> function <code>size</code>, and so on. These are called <code>&lt;ranges&gt;</code> and <code>&lt;iterator&gt;</code> headers and the <code>std::ranges</code> namespace. They are listed in the next table:</p>
			<div><div><img src="img/Table_9.02_B18367.jpg" alt="Table 9.2" width="1499" height="914"/>
				</div>
			</div>
			<p class="figure-caption">Table 9.2</p>
			<p>The use of some of these functions is demonstrated in the following snippet:</p>
			<pre class="source-code">std::vector&lt;int&gt; v{ 8, 5, 3, 2, 4, 7, 6, 1 };</pre>
			<pre class="source-code">auto r = std::views::iota(1, 10);</pre>
			<pre class="source-code">std::cout &lt;&lt; "size(v)=" &lt;&lt; std::ranges::size(v) &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; "size(r)=" &lt;&lt; std::ranges::size(r) &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; "empty(v)=" &lt;&lt; std::ranges::empty(v) &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; "empty(r)=" &lt;&lt; std::ranges::empty(r) &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; "first(v)=" &lt;&lt; *std::ranges::begin(v) &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; "first(r)=" &lt;&lt; *std::ranges::begin(r) &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; "rbegin(v)=" &lt;&lt; *std::ranges::rbegin(v) </pre>
			<pre class="source-code">          &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; "rbegin(r)=" &lt;&lt; *std::ranges::rbegin(r) </pre>
			<pre class="source-code">          &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; "data(v)=" &lt;&lt; *std::ranges::data(v) &lt;&lt; '\n'; </pre>
			<p>In this snippet, we used a type called <code>std::views::iota</code>. As the <a id="_idIndexMarker881"/>namespace implies, this is a view. A <strong class="bold">view</strong> is a range with additional<a id="_idIndexMarker882"/> restrictions. Views are lightweight objects with non-owning semantics. They present a view of an underlying sequence of elements (a range) in a way that does not require copying or mutating the sequence. The key feature is lazy evaluation. That means that regardless of the transformation they apply, they perform it only when an element is requested (iterated) and not when the view is created.</p>
			<p>There is a series of views<a id="_idIndexMarker883"/> provided with C++20, and new views have been also included in C++23. Views are available in the <code>&lt;ranges&gt;</code> header and <code>std::ranges</code> namespace in the form, <code>std::ranges::abc_view</code>, such as <code>std::ranges::iota_view</code>. However, for convenience of use, in the <code>std::views</code> namespace, a variable template of the form, <code>std::views::abc</code>, such as <code>std::views::iota</code>, also exists. This is what we saw in the previous example. Here are two equivalent examples for using <code>iota</code>:</p>
			<pre class="source-code">// using the iota_view type</pre>
			<pre class="source-code">for (auto i : std::ranges::iota_view(1, 10))</pre>
			<pre class="source-code">   std::cout &lt;&lt; i &lt;&lt; '\n';</pre>
			<pre class="source-code">// using the iota variable template</pre>
			<pre class="source-code">for (auto i : std::views::iota(1, 10))</pre>
			<pre class="source-code">   std::cout &lt;&lt; i &lt;&lt; '\n';</pre>
			<p>The <code>iota</code> view<a id="_idIndexMarker884"/> is part of a special category<a id="_idIndexMarker885"/> of views called <strong class="bold">factories</strong>. These factories are views<a id="_idIndexMarker886"/> over newly generated ranges. The following factories<a id="_idIndexMarker887"/> are available in the ranges library:</p>
			<div><div><img src="img/Table_9.03_B18367.jpg" alt="Table 9.3" width="1499" height="871"/>
				</div>
			</div>
			<p class="figure-caption">Table 9.3</p>
			<p>If you are wondering why <code>empty_view</code> and <code>single_view</code> are useful, the answer should not be hard to find. These<a id="_idIndexMarker888"/> are useful in template code that handles ranges where empty ranges<a id="_idIndexMarker889"/> or ranges with one element are valid inputs. You don’t want multiple overloads of a function template for handling these special cases; instead, you can pass an <code>empty_view</code> or <code>single_view</code> range. The following snippets show several examples of using these factories. These snippets should be self-explanatory:</p>
			<pre class="source-code">constexpr std::ranges::empty_view&lt;int&gt; ev;</pre>
			<pre class="source-code">static_assert(std::ranges::empty(ev));</pre>
			<pre class="source-code">static_assert(std::ranges::size(ev) == 0);</pre>
			<pre class="source-code">static_assert(std::ranges::data(ev) == nullptr);</pre>
			<pre class="source-code">constexpr std::ranges::single_view&lt;int&gt; sv{42};</pre>
			<pre class="source-code">static_assert(!std::ranges::empty(sv));</pre>
			<pre class="source-code">static_assert(std::ranges::size(sv) == 1);</pre>
			<pre class="source-code">static_assert(*std::ranges::data(sv) == 42);</pre>
			<p>For <code>iota_view</code>, we have already seen a couple of examples with a bounded view. The next snippet shows again an example not only using a bounded view generated with <code>iota</code> but also an unbounded view, also generated wit<a id="_idTextAnchor191"/>h <code>iota</code>:</p>
			<pre class="source-code">auto v1 = std::ranges::views::iota(1, 10);</pre>
			<pre class="source-code">std::ranges::for_each(</pre>
			<pre class="source-code">     v1, </pre>
			<pre class="source-code">     [](int const n) {std::cout &lt;&lt; n &lt;&lt; '\n'; });</pre>
			<pre class="source-code">auto v2 = std::ranges::views::iota(1) |</pre>
			<pre class="source-code">          std::ranges::views::take(9);</pre>
			<pre class="source-code">std::ranges::for_each(</pre>
			<pre class="source-code">     v2,</pre>
			<pre class="source-code">     [](int const n) {std::cout &lt;&lt; n &lt;&lt; '\n'; });</pre>
			<p>This last<a id="_idIndexMarker890"/> example utilizes another<a id="_idIndexMarker891"/> view called <code>take_view</code>. This produces a view<a id="_idIndexMarker892"/> of the first <em class="italic">N</em> elements (in our example, <code>9</code>) of another view (in our case, the unbounded view produced with <code>iota</code>). We will discuss more about this shortly. But first, let’s take an example using the fourth view factory, <code>basic_iostream_view</code>. Let’s consider we have a list of article prices in a text, separated by a space. We need to print the total sum of these prices. There are different ways to solve it, but a possible solution is given here:</p>
			<pre class="source-code">auto text = "19.99 7.50 49.19 20 12.34";</pre>
			<pre class="source-code">auto stream = std::istringstream{ text };</pre>
			<pre class="source-code">std::vector&lt;double&gt; prices;</pre>
			<pre class="source-code"><strong class="bold">double price;</strong></pre>
			<pre class="source-code"><strong class="bold">while (stream &gt;&gt; price)</strong></pre>
			<pre class="source-code"><strong class="bold">{</strong></pre>
			<pre class="source-code"><strong class="bold">   prices.push_back(price);</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<pre class="source-code">auto total = std::accumulate(prices.begin(), prices.end(), </pre>
			<pre class="source-code">                             0.0);</pre>
			<pre class="source-code">std::cout &lt;&lt; std::format("total: {}\n", total);</pre>
			<p>The highlighted part can be replaced with the following two lines of code that use <code>basic_iostream_view</code> or, more precisely, the <code>istream_view</code> alias template:</p>
			<pre class="source-code">for (double const price : </pre>
			<pre class="source-code">        std::ranges::istream_view&lt;double&gt;(stream))</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   prices.push_back(price);</pre>
			<pre class="source-code">}</pre>
			<p>What the <code>istream_view</code> range factory is doing<a id="_idIndexMarker893"/> is applying the<a id="_idIndexMarker894"/> operator <code>&gt;&gt;</code> repeatedly on the <code>istringstream</code> object and producing a value each time it is applied. You cannot specify a delimiter; it only works with whitespaces. If you prefer to use standard algorithms rather than handcrafted loops, you can use the <code>ranges::for_each</code> constrained algorithm to produce the same result, as follows:</p>
			<pre class="source-code">std::ranges::for_each(</pre>
			<pre class="source-code">   std::ranges::istream_view&lt;double&gt;(stream),</pre>
			<pre class="source-code">   [&amp;prices](double const price) {</pre>
			<pre class="source-code">      prices.push_back(price); });</pre>
			<p>The examples given so far in this chapter included views such as <code>filter</code>, <code>take</code>, <code>drop</code>, and <code>reverse</code>. These are just a few of the standard views available in C++20. More are being added to C++23, and probably even more to future standard versions. The entire set of standard views is listed<a id="_idIndexMarker895"/> in the following table:</p>
			<div><div><img src="img/Table_9.04a_B18367.jpg" alt="Table 9.4" width="1571" height="671"/>
				</div>
			</div>
			<div><div><img src="img/Table_9.04b_B18367.jpg" alt="Table 9.4" width="1571" height="1866"/>
				</div>
			</div>
			<div><div><img src="img/Table_9.04c_B18367.jpg" alt="Table 9.4" width="1571" height="1994"/>
				</div>
			</div>
			<div><div><img src="img/Table_9.04d_B18367.jpg" alt="Table 9.4" width="1571" height="1166"/>
				</div>
			</div>
			<p class="figure-caption">Table 9.4</p>
			<p>Apart from the <a id="_idIndexMarker896"/>views (range adaptors) listed<a id="_idIndexMarker897"/> in the previous table, there are a few more that can be useful in some particular scenarios. For completeness, these are listed in the next table:</p>
			<div><div><img src="img/Table_9.05a_B18367.jpg" alt="Table 9.5&#13;&#10;" width="1571" height="564"/>
				</div>
			</div>
			<div><div><img src="img/Table_9.05b_B18367.jpg" alt="Table 9.5&#13;&#10;" width="1571" height="978"/>
				</div>
			</div>
			<p class="figure-caption">Table 9.5</p>
			<p>Now that we<a id="_idIndexMarker898"/> have enumerated all the standard range adaptors, let’s take a look at more examples using some of them.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor192"/>Exploring more examples</h2>
			<p>Previously, in this section, we saw<a id="_idIndexMarker899"/> the following example (this time with explicit namespaces):</p>
			<pre class="source-code">namespace rv = std::ranges::views;</pre>
			<pre class="source-code">std::ranges::sort(v);</pre>
			<pre class="source-code">auto r = v</pre>
			<pre class="source-code">        | rv::filter([](int const n) {return n % 2 == 0; })</pre>
			<pre class="source-code">        | rv::drop(2)</pre>
			<pre class="source-code">        | rv::reverse</pre>
			<pre class="source-code">        | rv::transform([](int const n) {return n * n; });</pre>
			<p>This is actually the shorter and more readable version of the following:</p>
			<pre class="source-code">std::ranges::sort(v);auto r =</pre>
			<pre class="source-code">  rv::transform(</pre>
			<pre class="source-code">    rv::reverse(</pre>
			<pre class="source-code">      rv::drop(</pre>
			<pre class="source-code">        rv::filter(</pre>
			<pre class="source-code">          v,</pre>
			<pre class="source-code">          [](int const n) {return n % 2 == 0; }),</pre>
			<pre class="source-code">        2)),</pre>
			<pre class="source-code">    [](int const n) {return n * n; });</pre>
			<p>The first version is possible because the pipe operator (<code>|</code>) is overloaded to simplify the composition of views in a more human-readable form. Some range adaptors take one argument, and some may take multiple arguments. The following rules apply:</p>
			<ul>
				<li>If a range adaptor <code>A</code> takes one<a id="_idIndexMarker900"/> argument, a view <code>V</code>, then <code>A(V)</code> and <code>V|A</code> are equivalent. Such a range adaptor is <code>reverse_view</code>, and an example is shown here:<pre>std::vector&lt;int&gt; v{ 1, 5, 3, 2, 8, 7, 6, 4 };
namespace rv = std::ranges::views;
auto r1 = rv::reverse(v);
auto r2 = v | rv::reverse;</pre></li>
				<li>If a range adaptor <code>A</code> takes multiple arguments, a view <code>V</code> and <code>args…</code>, then <code>A(V, args…)</code>, <code>A(args…)(V)</code>, and <code>V|A(args…)</code> are equivalent. Such a range adaptor is <code>take_view</code>, and an example is shown here:<pre>std::vector&lt;int&gt; v{ 1, 5, 3, 2, 8, 7, 6, 4 };
namespace rv = std::ranges::views;
auto r1 = rv::take(v, 2);
auto r2 = rv::take(2)(v);
auto r3 = v | rv::take(2);</pre></li>
			</ul>
			<p>So far, we have seen the likes of <code>filter</code>, <code>transform</code>, <code>reverse</code>, and <code>drop</code> put to use. To complete this part of the chapter, let’s take a series of examples to demonstrate the use of the views from <em class="italic">Table 8.7</em>. In all the following examples, we will consider <code>rv</code> as an alias for the <code>std::ranges::views</code> namespace:</p>
			<ul>
				<li>Print the last two odd numbers from a sequence, in reverse order:<pre>std::vector&lt;int&gt; v{ 1, 5, 3, 2, 4, 7, 6, 8 };
for (auto i : v |
  rv::reverse |
  rv::filter([](int const n) {return n % 2 == 1; }) |
  rv::take(2))
{
   std::cout &lt;&lt; i &lt;&lt; '\n'; // prints 7 and 3
}</pre></li>
				<li>Print the subsequence of consecutive<a id="_idIndexMarker901"/> numbers smaller than 10 from a range that does not include the first consecutive odd numbers:<pre>std::vector&lt;int&gt; v{ 1, 5, 3, 2, 4, 7, 16, 8 };
for (auto i : v |
 rv::take_while([](int const n){return n &lt; 10; }) |
 rv::drop_while([](int const n){return n % 2 == 1; })
)
{
   std::cout &lt;&lt; i &lt;&lt; '\n'; // prints 2 4 7
}</pre></li>
				<li>Print the first elements, the second elements, and, respectively, the third elements from a sequence of tuples:<pre>std::vector&lt;std::tuple&lt;int,double,std::string&gt;&gt; v = 
{ 
   {1, 1.1, "one"}, 
   {2, 2.2, "two"}, 
   {3, 3.3, "three"}
};
for (auto i : v | rv::keys)
   std::cout &lt;&lt; i &lt;&lt; '\n'; // prints 1 2 3
for (auto i : v | rv::values)
   std::cout &lt;&lt; i &lt;&lt; '\n'; // prints 1.1 2.2 3.3
for (auto i : v | rv::elements&lt;2&gt;)
   std::cout &lt;&lt; i &lt;&lt; '\n'; // prints one two three</pre></li>
				<li>Print all the elements<a id="_idIndexMarker902"/> from a vector of vectors of integers:<pre>std::vector&lt;std::vector&lt;int&gt;&gt; v { 
   {1,2,3}, {4}, {5, 6}
};
for (int const i : v | rv::join)
   std::cout &lt;&lt; i &lt;&lt; ' ';  // prints 1 2 3 4 5 6</pre></li>
				<li>Print all the elements from a vector of vectors of integers but insert a 0 between the elements of <a id="_idTextAnchor193"/>each vector. The range adaptor <code>join_with</code> is new to C++23 and may not be supported yet by compilers:<pre>std::vector&lt;std::vector&lt;int&gt;&gt; v{
   {1,2,3}, {4}, {5, 6}
};
for(int const i : v | rv::join_with(0))
   std::cout &lt;&lt; i &lt;&lt; ' ';  // print 1 2 3 0 4 0 5 6</pre></li>
				<li>Print the individual words from a sentence, where the delimited is a space:<pre>std::string text{ "this is a demo!" };
constexpr std::string_view delim{ " " };
for (auto const word : text | rv::split(delim))
{
   std::cout &lt;&lt; std::string_view(word.begin(), 
                                 word.end()) 
             &lt;&lt; '\n';
}</pre></li>
				<li>Create a view of tuples<a id="_idIndexMarker903"/> from the elements of an array of integers and a vector of doubles:<pre>std::array&lt;int, 4&gt; a {1, 2, 3, 4};
std::vector&lt;double&gt; v {10.0, 20.0, 30.0};
auto z = rv::zip(a, v)
// { {1, 10.0}, {2, 20.0}, {3, 30.0} }</pre></li>
				<li>Create a view with the multiplied elements of an array of integers and a vector of doubles:<pre>std::array&lt;int, 4&gt; a {1, 2, 3, 4};
std::vector&lt;double&gt; v {10.0, 20.0, 30.0};
auto z = rv::zip_transform(
   std::multiplies&lt;double&gt;(), a, v)
// { {1, 10.0}, {2, 20.0}, {3, 30.0} }</pre></li>
				<li>Print the pairs of adjacent elements of a sequence of integers:<pre>std::vector&lt;int&gt; v {1, 2, 3, 4};
for (auto i : v | rv::adjacent&lt;2&gt;)
{
   // prints: (1, 2) (2, 3) (3, 4)
   std::cout &lt;&lt; std::format("({},{})", 
                            i.first, i.second)";
}</pre></li>
				<li>Print the values obtained<a id="_idIndexMarker904"/> from multiplying each three consecutive values from a sequence of integers:<pre>std::vector&lt;int&gt; v {1, 2, 3, 4, 5};
for (auto i : v | rv::adjacent_transform&lt;3&gt;(
    std::multiplies()))
{
   std::cout &lt;&lt; i &lt;&lt; ' '; // prints: 3 24 60
}</pre></li>
			</ul>
			<p>These examples will hopefully help you understand the possible use cases for each of the available views. You can find more examples in the source code accompanying the book, as well as in the articles mentioned in the <em class="italic">Further reading</em> section. In the next section, we will discuss the other part of the ranges library, the constrained algorithms.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor194"/>Understanding the constrained algorithms</h1>
			<p>The standard library provides<a id="_idIndexMarker905"/> over one hundred general-purpose algorithms. As we discussed<a id="_idIndexMarker906"/> in the introductory section for the ranges library earlier, these have one thing in common: they work with abstract ranges with the help of iterators. They take iterators as arguments and they sometimes return iterators. That makes it cumbersome to repeatedly use with standard containers or arrays. Here is an example:</p>
			<pre class="source-code">auto l_odd = [](int const n) {return n % 2 == 1; };</pre>
			<pre class="source-code">std::vector&lt;int&gt; v{ 1, 1, 2, 3, 5, 8, 13 };</pre>
			<pre class="source-code">std::vector&lt;int&gt; o;</pre>
			<pre class="source-code">auto e1 = std::copy_if(v.begin(), v.end(),</pre>
			<pre class="source-code">                       std::back_inserter(o),</pre>
			<pre class="source-code">                       l_odd);</pre>
			<pre class="source-code">int arr[] = { 1, 1, 2, 3, 5, 8, 13 };</pre>
			<pre class="source-code">auto e2 = std::copy_if(std::begin(arr), std::end(arr), </pre>
			<pre class="source-code">                       std::back_inserter(o), </pre>
			<pre class="source-code">                       l_odd);</pre>
			<p>In this snippet, we have<a id="_idIndexMarker907"/> a vector <code>v</code> and an array <code>arr</code>, and we copy the odd <a id="_idIndexMarker908"/>elements from each of these two to a second vector, <code>o</code>. For this, the <code>std::copy_if</code> algorithm is used. This takes begin and end input iterators (defining the input range), an output iterator to a second range, where the copied elements will be inserted, and a unary predicate (in this example, a lambda expression). What it returns is an iterator to the destination range past the last copied element.</p>
			<p>If we look at the declaration of the <code>std::copy_if</code> algorithm, we will find the following two overloads:</p>
			<pre class="source-code">template &lt;typename InputIt, typename OutputIt,</pre>
			<pre class="source-code">          typename UnaryPredicate&gt;</pre>
			<pre class="source-code">constexpr OutputIt copy_if(InputIt first, InputIt last,</pre>
			<pre class="source-code">                           OutputIt d_first,</pre>
			<pre class="source-code">                           UnaryPredicate pred);</pre>
			<pre class="source-code">template &lt;typename ExecutionPolicy,</pre>
			<pre class="source-code">          typename ForwardIt1, typename ForwardIt2,</pre>
			<pre class="source-code">          typename UnaryPredicate&gt;</pre>
			<pre class="source-code">ForwardIt2 copy_if(ExecutionPolicy&amp;&amp; policy,</pre>
			<pre class="source-code">                   ForwardIt1 first, ForwardIt1 last,</pre>
			<pre class="source-code">                   ForwardIt2 d_first,</pre>
			<pre class="source-code">                   UnaryPredicate pred);</pre>
			<p>The first overload is the one used and described here. The second<a id="_idIndexMarker909"/> overload was introduced in C++17. This allows you to specify an execution<a id="_idIndexMarker910"/><a id="_idTextAnchor195"/> po<a id="_idTextAnchor196"/>licy such as parallel <a id="_idIndexMarker911"/>or sequential. This basically enables the parallel execution of the standard algorithms. However, this is not relevant to the topic of this chapter, and we will not explore it further.</p>
			<p>Most of the standard algorithms have a new constrained version in the <code>std::ranges</code> namespace. These algorithms are found in the <code>&lt;algorithm&gt;</code>, <code>&lt;numeric&gt;</code>, and <code>&lt;memory&gt;</code> headers and have the following traits:</p>
			<ul>
				<li>They have the same name as the existing algorithms.</li>
				<li>They have overloads that allow you to specify a range, either with a begin iterator and an end sentinel, or as a single range argument.</li>
				<li>They have modified return types that provide more information about the execution.</li>
				<li>They support projections to apply<a id="_idIndexMarker912"/> to the processed elements. A <strong class="bold">projection</strong> is an entity that can be invoked. It can be a pointer to a member, a lambda expression, or a function pointer. Such a projection is applied to the range element <em class="italic">before</em> the algorithm logic uses the element.</li>
			</ul>
			<p>Here is how the overloads of the <code>std::ranges::copy_if</code> algorithm are declared:</p>
			<pre class="source-code">template &lt;std::input_iterator I,</pre>
			<pre class="source-code">          std::sentinel_for&lt;I&gt; S,</pre>
			<pre class="source-code">          std::weakly_incrementable O,</pre>
			<pre class="source-code">          class Proj = std::identity,</pre>
			<pre class="source-code">          std::indirect_unary_predicate&lt;</pre>
			<pre class="source-code">             std::projected&lt;I, Proj&gt;&gt; Pred&gt;</pre>
			<pre class="source-code">requires std::indirectly_copyable&lt;I, O&gt;</pre>
			<pre class="source-code">constexpr copy_if_result&lt;I, O&gt; copy_if(I first, S last,</pre>
			<pre class="source-code">                                       O result,</pre>
			<pre class="source-code">                                       Pred pred,</pre>
			<pre class="source-code">                                       Proj proj = {} );</pre>
			<pre class="source-code">template &lt;ranges::input_range R,</pre>
			<pre class="source-code">      std::weakly_incrementable O,</pre>
			<pre class="source-code">      class Proj = std::identity,</pre>
			<pre class="source-code">      std::indirect_unary_predicate&lt;</pre>
			<pre class="source-code">      std::projected&lt;ranges::iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;</pre>
			<pre class="source-code">requires std::indirectly_copyable&lt;ranges::iterator_t&lt;R&gt;, O&gt;</pre>
			<pre class="source-code">constexpr copy_if_result&lt;ranges::borrowed_iterator_t&lt;R&gt;, O&gt;</pre>
			<pre class="source-code">          copy_if(R&amp;&amp; r,</pre>
			<pre class="source-code">                  O result,</pre>
			<pre class="source-code">                  Pred pred,</pre>
			<pre class="source-code">                  Proj proj = {});</pre>
			<p>If these seem more difficult <a id="_idIndexMarker913"/>to read, it is because they have more<a id="_idIndexMarker914"/> arguments, constraints, and longer type names. The good part, however, is that they make the code easier to write. Here is the previous snippet rewritten to use <code>std::ranges::copy_if</code>:</p>
			<pre class="source-code">std::vector&lt;int&gt; v{ 1, 1, 2, 3, 5, 8, 13 };</pre>
			<pre class="source-code">std::vector&lt;int&gt; o;</pre>
			<pre class="source-code">auto e1 = std::ranges::copy_if(v, std::back_inserter(o), </pre>
			<pre class="source-code">                               l_odd);</pre>
			<pre class="source-code">int arr[] = { 1, 1, 2, 3, 5, 8, 13 };</pre>
			<pre class="source-code">auto e2 = std::ranges::copy_if(arr, std::back_inserter(o), </pre>
			<pre class="source-code">                               l_odd);</pre>
			<pre class="source-code">auto r = std::ranges::views::iota(1, 10);</pre>
			<pre class="source-code">auto e3 = std::ranges::copy_if(r, std::back_inserter(o), </pre>
			<pre class="source-code">                               l_odd);</pre>
			<p>These examples show two things: how to copy elements from a<a id="_idIndexMarker915"/> <code>std::vector</code> object and an <a id="_idIndexMarker916"/>array and how to copy elements from a view (a range adaptor). What they don’t show is projections. This was briefly mentioned earlier. We’ll discuss it with more details and examples here.</p>
			<p>A projection is an invocable entity. It’s basically a function adaptor. It affects the predicate, providing a way to perform function composition. It does not provide a way to change the algorithm. For instance, let’s say we have the following type:</p>
			<pre class="source-code">struct Item</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   int         id;</pre>
			<pre class="source-code">   std::string name;</pre>
			<pre class="source-code">   double      price;</pre>
			<pre class="source-code">};</pre>
			<p>Also, for the purpose of the explanation, let’s also consider the following sequence of elements:</p>
			<pre class="source-code">std::vector&lt;Item&gt; items{</pre>
			<pre class="source-code">   {1, "pen", 5.49},</pre>
			<pre class="source-code">   {2, "ruler", 3.99},</pre>
			<pre class="source-code">   {3, "pensil case", 12.50}</pre>
			<pre class="source-code">};</pre>
			<p>Projections allow you to perform composition on the predicate. For instance, let’s say we want to copy to a second vector all the items whose names begin with the letter <em class="italic">p</em>. We can write the following:</p>
			<pre class="source-code">std::vector&lt;Item&gt; copies;</pre>
			<pre class="source-code">std::ranges::copy_if(</pre>
			<pre class="source-code">   items, </pre>
			<pre class="source-code">   std::back_inserter(copies),</pre>
			<pre class="source-code">   [](Item const&amp; i) {return i.name[0] == 'p'; });</pre>
			<p>However, we can<a id="_idIndexMarker917"/> also write the following equivalent<a id="_idIndexMarker918"/> example:</p>
			<pre class="source-code">std::vector&lt;Item&gt; copies;</pre>
			<pre class="source-code">std::ranges::copy_if(</pre>
			<pre class="source-code">   items, </pre>
			<pre class="source-code">   std::back_inserter(copies),</pre>
			<pre class="source-code">   [](std::string const&amp; name) {return name[0] == 'p'; },</pre>
			<pre class="source-code">   &amp;Item::name);</pre>
			<p>The projection, in this example, is the pointer-to-member expression <code>&amp;Item::name</code> that is applied to each <code>Item</code> element before executing the predicate (which is a lambda expression here). This can be useful when you already have reusable function objects or lambda expressions and you don’t want to write another one for passing different types of arguments.</p>
			<p>What projects cannot be used for, in this manner, is transforming a range from one type into another. For instance, you cannot just copy the names of the items from <code>std::vector&lt;Item&gt;</code> to <code>std::vector&lt;std::string&gt;</code>. This requires the use of the <code>std::ranges::transform</code> range adaptor, as shown in the following snippet:</p>
			<pre class="source-code">std::vector&lt;std::string&gt; names;</pre>
			<pre class="source-code">std::ranges::copy_if(</pre>
			<pre class="source-code">   items | rv::transform(&amp;Item::name),</pre>
			<pre class="source-code">   std::back_inserter(names),</pre>
			<pre class="source-code">   [](std::string const&amp; name) {return name[0] == 'p'; });</pre>
			<p>There are many<a id="_idIndexMarker919"/> constrained algorithms, but we will not list<a id="_idIndexMarker920"/> them here. Instead, you can check them all either<a id="_idIndexMarker921"/> directly in the standard, or on the <a href="https://en.cppreference.com/w/cpp/algorithm/ranges">https://en.cppreference.com/w/cpp/algorithm/ranges</a> page.</p>
			<p>The last topic that we’ll address in this chapter is writing <a id="_idTextAnchor197"/>a custom range adaptor.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor198"/>Writing your own range adaptor</h1>
			<p>The standard library contains<a id="_idIndexMarker922"/> a series of range adaptors that can be used for solving many different tasks. More are being added in newer versions of the standard. However, there can be situations when you’d like to create your own range adaptor to use with others from the range library. This is not actually a trivial task. For this reason, in this final section of the chapter, we will explore the steps you need to follow to write such a range adaptor.</p>
			<p>For this purpose, we will consider a range adaptor that takes every <em class="italic">Nth</em> element of a range and skips the others. We will call this adaptor <code>step_view</code>. We can use it to write code as follows:</p>
			<pre class="source-code">for (auto i : std::views::iota(1, 10) | views::step(1))</pre>
			<pre class="source-code">   std::cout &lt;&lt; i &lt;&lt; '\n';</pre>
			<pre class="source-code">for (auto i : std::views::iota(1, 10) | views::step(2))</pre>
			<pre class="source-code">   std::cout &lt;&lt; i &lt;&lt; '\n';</pre>
			<pre class="source-code">for (auto i : std::views::iota(1, 10) | views::step(3))</pre>
			<pre class="source-code">   std::cout &lt;&lt; i &lt;&lt; '\n';</pre>
			<pre class="source-code">for (auto i : std::views::iota(1, 10) | views::step(2) | </pre>
			<pre class="source-code">              std::views::take(3))</pre>
			<pre class="source-code">   std::cout &lt;&lt; i &lt;&lt; '\n';</pre>
			<p>The first loop will print all the<a id="_idIndexMarker923"/> numbers from one to nine. The second loop will print all the odd numbers, 1, 3, 5, 7, 9. The third loop will print 1, 4, 7. Lastly, the fourth loop will print 1, 3, 5.</p>
			<p>To make this possible, we need to implement the following entities:</p>
			<ul>
				<li>A class template that defines the range adaptor</li>
				<li>A deduction guide to help with class template argument deduction for the range adaptor</li>
				<li>A class template that defines the iterator type for the range adaptor</li>
				<li>A class template that defines the sentinel type for the range adaptor</li>
				<li>An overloaded pipe operator (<code>|</code>) and helper functors, required for its implementation</li>
				<li>A compile-time constant global object to simplify the use of the range adaptor</li>
			</ul>
			<p>Let’s take them one by one and learn how to define them. We’ll start with the sentinel class. A <strong class="bold">sentinel</strong> is an abstraction of a past-the-end<a id="_idIndexMarker924"/> iterator. It allows us to check whether an iteration reached the end of a range. A sentinel makes it possible for the end iterator to have a different type than the range iterators. Sentinels cannot be dereferenced or incremented. Here is how it can be defined:</p>
			<pre class="source-code">template &lt;typename R&gt;</pre>
			<pre class="source-code">struct step_iterator;</pre>
			<pre class="source-code">template &lt;typename R&gt;</pre>
			<pre class="source-code">struct step_sentinel</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using base      = std::ranges::iterator_t&lt;R&gt;;</pre>
			<pre class="source-code">   using size_type = std::ranges::range_difference_t&lt;R&gt;;</pre>
			<pre class="source-code">   step_sentinel() = default;</pre>
			<pre class="source-code">   constexpr step_sentinel(base end) : end_{ end } {}</pre>
			<pre class="source-code">   constexpr bool is_at_end(step_iterator&lt;R&gt; it) const;</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   base      end_;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">// definition of the step_iterator type</pre>
			<pre class="source-code">template &lt;typename R&gt;</pre>
			<pre class="source-code">constexpr bool step_sentinel&lt;R&gt;::is_at_end(</pre>
			<pre class="source-code">   step_iterator&lt;R&gt; it) const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return end_ == it.value();</pre>
			<pre class="source-code">}</pre>
			<p>The sentinel is constructed from an iterator<a id="_idIndexMarker925"/> and contains a member function called <code>is_at_end</code> that checks whether the stored range iterator is equal to the range iterator stored in a <code>step_iterator</code> object. This type, <code>step_iterator</code>, is a class template that defines the iterator type for our range adaptor, which we call <code>step_view</code>. Here is an implementation of this iterator type:</p>
			<pre class="source-code">template &lt;typename R&gt;</pre>
			<pre class="source-code">struct step_iterator : std::ranges::iterator_t&lt;R&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using base</pre>
			<pre class="source-code">      = std::ranges::iterator_t&lt;R&gt;;</pre>
			<pre class="source-code">   using value_type</pre>
			<pre class="source-code">      = typename std::ranges::range_value_t&lt;R&gt;;</pre>
			<pre class="source-code">   using reference_type</pre>
			<pre class="source-code">      = typename std::ranges::range_reference_t&lt;R&gt;;</pre>
			<pre class="source-code">   constexpr step_iterator(</pre>
			<pre class="source-code">      base start, base end,</pre>
			<pre class="source-code">      std::ranges::range_difference_t&lt;R&gt; step) :</pre>
			<pre class="source-code">      pos_{ start }, end_{ end }, step_{ step }</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr step_iterator operator++(int)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      auto ret = *this;</pre>
			<pre class="source-code">      pos_ = std::ranges::next(pos_, step_, end_);</pre>
			<pre class="source-code">      return ret;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr step_iterator&amp; operator++()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      pos_ = std::ranges::next(pos_, step_, end_);</pre>
			<pre class="source-code">      return *this;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr reference_type operator*() const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return *pos_;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr bool operator==(step_sentinel&lt;R&gt; s) const</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return s.is_at_end(*this);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr base const value() const { return pos_; }</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   base                                pos_;</pre>
			<pre class="source-code">   base                                end_;</pre>
			<pre class="source-code">   std::ranges::range_difference_t&lt;R&gt;  step_;</pre>
			<pre class="source-code">};</pre>
			<p>This type must have<a id="_idIndexMarker926"/> several members:</p>
			<ul>
				<li>The alias template called <code>base</code> that represents the type<a id="_idIndexMarker927"/> of the underlying range iterator.</li>
				<li>The alias template called <code>value_type</code> that represents the type<a id="_idIndexMarker928"/> of elements of an underlying range.</li>
				<li>The overloaded operators <code>++</code> and <code>*</code>.</li>
				<li>The overloaded operator <code>==</code> compares this object with a sentinel.</li>
			</ul>
			<p>The implementation <a id="_idIndexMarker929"/>of the <code>++</code> operator uses the <code>std::ranges::next</code> constrained algorithm to increment an iterator with <em class="italic">N</em> positions, but not past the end of the range.</p>
			<p>In order to use the <code>step_iterator</code> and <code>step_sentinel</code> pair for the <code>step_view</code> range adaptor, you must make sure this pair is actually well-formed. For this, we must ensure that the <code>step_iterator</code> type is an input iterator, and that the <code>step_sentinel</code> type is indeed a sentinel type for the <code>step_iterator</code> type. This can be done with the help of the following <code>static_assert</code> statements:</p>
			<pre class="source-code">namespace details</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using test_range_t = </pre>
			<pre class="source-code">      std::ranges::views::all_t&lt;std::vector&lt;int&gt;&gt;;</pre>
			<pre class="source-code">   static_assert(</pre>
			<pre class="source-code">      std::input_iterator&lt;step_iterator&lt;test_range_t&gt;&gt;);</pre>
			<pre class="source-code">   static_assert(</pre>
			<pre class="source-code">      std::sentinel_for&lt;step_sentinel&lt;test_range_t&gt;, </pre>
			<pre class="source-code">      step_iterator&lt;test_range_t&gt;&gt;);</pre>
			<pre class="source-code">}</pre>
			<p>The <code>step_iterator</code> type is used in the implementation of the <code>step_view</code> range adaptor. At a minimum, this could look as follows:</p>
			<pre class="source-code">template&lt;std::ranges::view R&gt;</pre>
			<pre class="source-code">struct step_view : </pre>
			<pre class="source-code">   public std::ranges::view_interface&lt;step_view&lt;R&gt;&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   R                                   base_;</pre>
			<pre class="source-code">   std::ranges::range_difference_t&lt;R&gt;  step_;</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">   step_view() = default;</pre>
			<pre class="source-code">   constexpr step_view(</pre>
			<pre class="source-code">      R base,</pre>
			<pre class="source-code">      std::ranges::range_difference_t&lt;R&gt; step)</pre>
			<pre class="source-code">         : base_(std::move(base))</pre>
			<pre class="source-code">         , step_(step)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr R base() const&amp;</pre>
			<pre class="source-code">      requires std::copy_constructible&lt;R&gt;</pre>
			<pre class="source-code">   { return base_; }</pre>
			<pre class="source-code">   constexpr R base()&amp;&amp; { return std::move(base_); }</pre>
			<pre class="source-code">   constexpr std::ranges::range_difference_t&lt;R&gt; const&amp; increment() const </pre>
			<pre class="source-code">   { return step_; }</pre>
			<pre class="source-code">   constexpr auto begin()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return step_iterator&lt;R const&gt;(</pre>
			<pre class="source-code">         std::ranges::begin(base_),</pre>
			<pre class="source-code">         std::ranges::end(base_), step_);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr auto begin() const </pre>
			<pre class="source-code">   requires std::ranges::range&lt;R const&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return step_iterator&lt;R const&gt;(</pre>
			<pre class="source-code">         std::ranges::begin(base_),</pre>
			<pre class="source-code">         std::ranges::end(base_), step_);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr auto end()</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return step_sentinel&lt;R const&gt;{ </pre>
			<pre class="source-code">         std::ranges::end(base_) };</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr auto end() const </pre>
			<pre class="source-code">   requires std::ranges::range&lt;R const&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return step_sentinel&lt;R const&gt;{ </pre>
			<pre class="source-code">         std::ranges::end(base_) };</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   constexpr auto size() const </pre>
			<pre class="source-code">   requires std::ranges::sized_range&lt;R const&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      auto d = std::ranges::size(base_); </pre>
			<pre class="source-code">      return step_ == 1 ? d : </pre>
			<pre class="source-code">         static_cast&lt;int&gt;((d + 1)/step_); }</pre>
			<pre class="source-code">   constexpr auto size() </pre>
			<pre class="source-code">   requires std::ranges::sized_range&lt;R&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      auto d = std::ranges::size(base_); </pre>
			<pre class="source-code">      return step_ == 1 ? d : </pre>
			<pre class="source-code">         static_cast&lt;int&gt;((d + 1)/step_);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>There is a pattern that must be followed<a id="_idIndexMarker930"/> when defining a range adaptor. This pattern<a id="_idIndexMarker931"/> is represented by the following aspects:</p>
			<ul>
				<li>The class template must have a template argument that meets the <code>std::ranges::view</code> concept.</li>
				<li>The class template should be derived from <code>std::ranges:view_interface</code>. This takes a template argument itself and that should be the range adaptor class. This is basically an implementation of the CRTP th<a id="_idTextAnchor199"/>at we learned about in <a href="B18367_07_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 7</em></a>, <em class="italic">Patterns and Idioms</em>.</li>
				<li>The class must have a default constructor.</li>
				<li>The class must have a <code>base</code> member<a id="_idIndexMarker932"/> function that returns the underlying range.</li>
				<li>The class must have a <code>begin</code> member function that returns an iterator to the first element in the range.</li>
				<li>The class must have an <code>end</code> member function that returns either an iterator to the one-past-the-last element of the range or a sentinel.</li>
				<li>For ranges that meet the requirements of the <code>std::ranges::sized_range</code> concept, this class must also contain a member function called <code>size</code> that returns the number of<a id="_idIndexMarker933"/> elements in the range.</li>
			</ul>
			<p>In order to make it possible<a id="_idIndexMarker934"/> to use class template argument deduction for the <code>step_view</code> class, a user-defined deduction guide should be defined. These were discussed in <a href="B18367_04_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Advanced Template Concepts</em>. Such a guide should look as follows:</p>
			<pre class="source-code">template&lt;class R&gt;</pre>
			<pre class="source-code">step_view(R&amp;&amp; base, </pre>
			<pre class="source-code">          std::ranges::range_difference_t&lt;R&gt; step)</pre>
			<pre class="source-code">   -&gt; step_view&lt;std::ranges::views::all_t&lt;R&gt;&gt;;</pre>
			<p>In order to make it possible to compose this range adaptor with others using the pipe iterator (<code>|</code>), this operator must be overloaded. However, we need some helper function object, which is shown in the next listing:</p>
			<pre class="source-code">namespace details</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   struct step_view_fn_closure</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      std::size_t step_;</pre>
			<pre class="source-code">      constexpr step_view_fn_closure(std::size_t step)</pre>
			<pre class="source-code">         : step_(step)</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      template &lt;std::ranges::range R&gt;</pre>
			<pre class="source-code">      constexpr auto operator()(R&amp;&amp; r) const</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         return step_view(std::forward&lt;R&gt;(r), step_);</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">   template &lt;std::ranges::range R&gt;</pre>
			<pre class="source-code">   constexpr auto operator | (R&amp;&amp; r, </pre>
			<pre class="source-code">                              step_view_fn_closure&amp;&amp; a)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return std::forward&lt;step_view_fn_closure&gt;(a)(</pre>
			<pre class="source-code">         std::forward&lt;R&gt;(r));</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>The <code>step_view_fn_closure</code> class is a function<a id="_idIndexMarker935"/> object that stores a value representing<a id="_idIndexMarker936"/> the number of elements to skip for each iterator. Its overloaded call operator takes a range as an argument and returns a <code>step_view</code> object created from the range and the value for the number of steps to jump.</p>
			<p>Finally, we want to make it possible to write code in a similar manner to what is available in the standard library, which provides a compile-time global object in the <code>std::views</code> namespace for each range adaptor that exists. For instance, instead of <code>std::ranges::transform_view</code>, you could use <code>std::views::transform</code>. Similarly, instead of <code>step_view</code> (in some namespace), we want to have an object, <code>views::step</code>. To do so, we need yet another function object, as shown next:</p>
			<pre class="source-code">namespace details</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   struct step_view_fn</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      template&lt;std::ranges::range R&gt;</pre>
			<pre class="source-code">      constexpr auto operator () (R&amp;&amp; r, </pre>
			<pre class="source-code">                                  std::size_t step) const</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         return step_view(std::forward&lt;R&gt;(r), step);</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      constexpr auto operator () (std::size_t step) const</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         return step_view_fn_closure(step);</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">namespace views</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   inline constexpr details::step_view_fn step;</pre>
			<pre class="source-code">}</pre>
			<p>The <code>step_view_fn</code> type is a function<a id="_idIndexMarker937"/> object that has two overloads<a id="_idIndexMarker938"/> for the call operator: one takes a range and an integer and returns a <code>step_view</code> object, and the other takes an integer and returns a closure for this value, or, more precisely, an instance of <code>step_view_fn_closure</code> that we saw earlier.</p>
			<p>Having all these implemented, we can successfully<a id="_idIndexMarker939"/> run the code shown at the beginning of this section. We have completed the implementation of a simple range adaptor. Hopefully, this should give you a sense of what writing range adaptors takes. The ranges library is significantly complex when you look at the details. In this chapter, you have learned some basics about the content of the library, how it can simplify your code, and how you can extend it with custom features. This knowledge should be a starting point for you should you want to learn more using other resources.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor200"/>Summary</h1>
			<p>In this final chapter of the book, we explored the C++20 ranges library. We started the discussion with a transition from the abstract concept of a range to the new ranges library. We learned about the content of this library and how it can help us write simpler code. We focused the discussion on range adapters but also looked at constrained algorithms. At the end of the chapter, we learned how to write a custom range adaptor that can be used in combination with standard adapters.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor201"/>Questions</h1>
			<ol>
				<li>What is a range?</li>
				<li>What is a view in the range library?</li>
				<li>What are constrained algorithms?</li>
				<li>What is a sentinel?</li>
				<li>How can you check that a sentinel type corresponds to an iterator type?</li>
			</ol>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor202"/>Further reading</h1>
			<ul>
				<li><em class="italic">A beginner’s guide to C++ Ranges and Views</em>, Hannes Hauswedell, <a href="https://hannes.hauswedell.net/post/2019/11/30/range_intro/">https://hannes.hauswedell.net/post/2019/11/30/range_intro/</a></li>
				<li><em class="italic">Tutorial: Writing your first view from scratch (C++20/P0789)</em>, Hannes Hauswedell, <a href="https://hannes.hauswedell.net/post/2018/04/11/view1/">https://hannes.hauswedell.net/post/2018/04/11/view1/</a></li>
				<li><em class="italic">C++20 Range Adaptors and Range Factories</em>, Barry Revzin, <a href="https://brevzin.github.io/c++/2021/02/28/ranges-reference/">https://brevzin.github.io/c++/2021/02/28/ranges-reference/</a></li>
				<li><em class="italic">Implementing a better views::split</em>, Barry Revzin, <a href="https://brevzin.github.io/c++/2020/07/06/split-view/">https://brevzin.github.io/c++/2020/07/06/split-view/</a></li>
				<li><em class="italic">Projections are Function Adaptors</em>, Barry Revzin, <a href="https://brevzin.github.io/c++/2022/02/13/projections-function-adaptors/">https://brevzin.github.io/c++/2022/02/13/projections-function-adaptors/</a></li>
				<li><em class="italic">Tutorial: C++20’s Iterator Sentinels</em>, Jonathan Müller, <a href="https://www.foonathan.net/2020/03/iterator-sentinel/">https://www.foonathan.net/2020/03/iterator-sentinel/</a></li>
				<li><em class="italic">Standard Ranges</em>, Eric Niebrel, <a href="https://ericniebler.com/2018/12/05/standard-ranges/">https://ericniebler.com/2018/12/05/standard-ranges/</a></li>
				<li><em class="italic">Zip</em>, Tim Song, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html</a></li>
				<li><em class="italic">From range projections to projected ranges</em>, Oleksandr Koval, <a href="https://oleksandrkvl.github.io/2021/10/11/projected-ranges.html">https://oleksandrkvl.github.io/2021/10/11/projected-ranges.html</a></li>
				<li><em class="italic">Item 30 - Create custom composable views</em>, Wesley Shillingford, <a href="https://cppuniverse.com/EverydayCpp20/RangesCustomViews">https://cppuniverse.com/EverydayCpp20/RangesCustomViews</a></li>
				<li><em class="italic">A custom C++20 range view</em>, Marius Bancila, <a href="https://mariusbancila.ro/blog/2020/06/06/a-custom-cpp20-range-view/">https://mariusbancila.ro/blog/2020/06/06/a-custom-cpp20-range-view/</a></li>
				<li><em class="italic">New C++23 Range Adaptors</em>, Marius Bancila, <a href="https://mariusbancila.ro/blog/2022/03/16/new-cpp23-range-adaptors/">https://mariusbancila.ro/blog/2022/03/16/new-cpp23-range-adaptors/</a></li>
				<li><em class="italic">C++ Code Samples Before and After Ranges</em>, Marius Bancila, <a href="https://mariusbancila.ro/blog/2019/01/20/cpp-code-samples-before-and-after-ranges/">https://mariusbancila.ro/blog/2019/01/20/cpp-code-samples-before-and-after-ranges/</a></li>
			</ul>
		</div>
		<div><div></div>
		</div>
	</div></body></html>