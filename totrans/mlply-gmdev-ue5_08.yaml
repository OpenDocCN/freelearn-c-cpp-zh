- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing AI into a Multiplayer Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Artificial Intelligence** (**AI**) systems offer an exciting and unique gaming
    experience for players by providing dynamic challenges that are unpredictable
    and engaging. This allows developers to create immersive worlds with realistic
    behavior from **non-player** **characters** (**NPCs**).'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will introduce you to the basics of AI in Unreal Engine but,
    as this is a book about multiplayer games, I will not go deep into the details
    of the system – instead, you will take the first steps in the creation of opponents,
    which will make your game fully playable from a networked point of view.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have created an enemy Actor that wanders
    around the level and actively pursues the player’s character once it is detected.
    This will serve as a starting point for creating more diverse and compelling enemies
    in your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, I will present you with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the AI system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an AI opponent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding opponents to the level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the `.zip` project files provided in this book’s
    accompanying project repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5)'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the files that are up to date with the end of the last chapter
    by clicking the `Unreal Shadows –` `Chapter 07``End` link.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the AI system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Crafting an AI opponent in Unreal Engine can be quite a hard task. Luckily,
    this book is focused on boosting your multiplayer prowess, rather than getting
    bogged down in all the details of AI, so I will not go deep into the Unreal Engine
    AI system. However, if you want to make your game enjoyable, it definitely helps
    to have some know-how on creating a worthy AI opponent.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make the AI character move around the level, you will need to define
    which areas are allowed and which are not (as an example, you will most definitely
    need to give the character a safe place that the opponents won’t dare to step
    into). Once we’ve done that, in the next steps, we will create these areas so
    that the AI system can manage the minions’ walking paths. Once we’ve done that,
    we’ll be well on our way to creating awesome, mindless, walking undead.
  prefs: []
  type: TYPE_NORMAL
- en: To make everything work properly, first of all, we need to give our minion opponents
    something to walk on. As you may already know, Unreal Engine uses a **Navigation
    System** to let AI Actors navigate a level using pathfinding algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The Navigation System takes the collision geometry in your level and generates
    a **Navigation Mesh**, which is then split into portions (i.e., polygon geometries)
    that are used to create a graph. This graph is what **agents** (such as AI characters)
    use to navigate to their destination. Each portion is given a cost, which agents
    then use to calculate the most efficient path (the one with the lowest overall
    cost). It’s like a smart GPS for your game characters!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want more information about the Unreal Engine Navigation System and
    its inner workings, you can visit the official Epic Games documentation at this
    link: [https://docs.unrealengine.com/5.1/en-US/navigation-system-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/navigation-system-in-unreal-engine/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a Navigation Mesh to the level, you will need to take the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the game level you’ve been working on so far and, from the **Quickly add
    to the project** button, select **NavMeshBoundsVolume**. This will add the **NavMeshBoundsVolume**
    component to the level and a **RecastNavMesh** Actor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Outliner**, select **NavMeshBoundsVolume** and, with the **Scale**
    tool enabled, resize it so that it covers your desired portion of the level –
    avoid the spawn region for your player characters, as you want to give them a
    safe place to rest or escape to if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hit the *P* key on your keyboard to show the newly created Navigation Mesh,
    which should look similar to the one depicted in *Figure 8**.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.1 – The Navigation Mesh area](img/Figure_08_01_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – The Navigation Mesh area
  prefs: []
  type: TYPE_NORMAL
- en: The green-colored area (i.e., the Navigation Mesh) represents the places where
    the AI character can walk. You will notice that walls and doors will create “holes”
    in this mesh, so the AI will be forbidden to step into it. Don’t worry about the
    portions outside of your dungeon – there are no open doors to connect them, so
    the minions won’t be able to reach them.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you were briefly introduced to the Unreal Engine Navigation
    System and you have set up a navigable area for the soon-to-be-created AI opponents.
    As I see you’re eager to start coding, let’s fire up your programming IDE and
    start writing some code together! It’s time to summon some undead minions and
    let them walk around the dungeon.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AI opponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll start by creating a class for your hero’s foes, complete
    with the basic ability to patrol and attack. Sure, they might not be the sharpest
    guys around, but hey, they’re the Lichlord’s undead minions – not exactly known
    for their intelligence, are they?
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be starting by extending the Character class, which, as you may already
    know, can be controlled by an `AIController`, allowing independent actions during
    gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we want the minion to have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: A random patrolling movement around the level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A perception system that will allow it to see and hear the player’s character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to seek out the player once it has been detected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapters, we’ll extend the Character class further by adding some
    more features such as health and spawnable goodies (when the AI has been defeated)
    but for now, we’ll just focus on the movement and perception system.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the navigation module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to do in order to have an agent that can navigate through a
    Navigation Mesh is to add the corresponding module to your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, get back to your programming IDE and open your project build file
    – the one named `UnrealShadows_LOTL.Build.cs` (or similar, if you opted for a
    different project name). Locate the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it by adding the `NavigationSystem` declaration, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With the project settings updated, we can start working on the minion AI, by
    creating a dedicated class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the minion class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s time to create the AI minion class, so create a new class derived from
    `Character` and name it `US_Minion`. Once the class has been created, open the
    `US_Minion.h` header file and, in the `private` section, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Collision` property will be used as a trigger for the AI to grab the character,
    while `PatrolLocation` will be used to tell the AI where to go if not chasing
    the character.
  prefs: []
  type: TYPE_NORMAL
- en: The `PawnSense` property is the declaration for `PawnSensingComponent`, a component
    that can be used by the AI character to see and hear pawns around the level (i.e.,
    the player characters). This component is quite straightforward to use and is
    easily configurable, letting you make the opponent more or less “dumb” during
    gameplay. You’ll get mere info on this in a minute or two when you’ll be initializing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to add some properties to the `public` section. Just add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined two movement speed properties: `PatrolSpeed` will be used when
    the minion is walking around aimlessly, while `ChaseSpeed` will be used whenever
    the minion is seeking the character, in order to make it a new pawn for the Lichlord’s
    army! The `PatrolRadius` property will be used to find a new location in the level
    for the minion to inspect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the properties, you will be declaring the public methods needed for the
    correct behavior of the AI opponent. Still in the `public` section, add this block
    of code to declare them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `SetNextPatrolLocation()` and `Chase()` methods will be used to let the
    AI character move around the scene, looking for a new spot or seeking the player
    character. The `PostInitializeComponent()` override will be used to register the
    character events. Lastly, we are declaring the usual getters for the character
    components that have been added.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step in the header declaration is to add the event handlers for this
    character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first one will manage the minion logic once it has detected a pawn with
    its senses, while the second one will be used to check whether a player character
    has been captured.
  prefs: []
  type: TYPE_NORMAL
- en: The header has finally been declared – please note that, at the moment, we are
    not taking into consideration the hearing capabilities of the minion; this is
    something we are going to implement in the next chapter when our thief hero starts
    to make some noise!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the minions’ behaviors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve declared all your functions and properties, so now it’s time to put them
    to good use by implementing some behaviors for your AI minions. Let’s make sure
    everything is running smoothly and get this project rolling!
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `US_Minion.cpp` file and add the following `include` statements at
    the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As usual, these lines of code will declare the classes we will use from now
    on. After you have done that, it’s time to implement the constructor by adding
    the needed components and initializing all the properties.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the `include` statements have been properly declared, you can start by
    locating the `AUS_Minion()` constructor and inserting the character initialization.
    Inside the brackets, just after the `PrimaryActorTick.bCanEverTick` declaration,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You’ll already be familiar with most of the code from the thief character creation,
    but you will see some noticeable additions. First of all, we are setting the `AutoPossessAI`
    property, which lets us define whether the game system will possess the AI character
    once in the level – we want it to be both in full control when it is spawned at
    runtime and when it is already in the level when the game starts, so we have opted
    for a value of `PlacedInWorldOrSpawned`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we define which controller will be used for the AI system by setting the
    `AIControllerClass` property; in this case, we are just using the base `AAIController`
    class, but you can obviously implement your own with additional features.
  prefs: []
  type: TYPE_NORMAL
- en: The last notable thing is the `PawnSense` component creation – as you can see,
    we are initializing the properties that will make the minion see and hear at a
    certain distance. You should take note of the `SensingInterval` initialization,
    which will let us tweak how much time will pass between two sense perceptions.
    This will make the difference between a very reactive character (i.e., a lower
    value) or a really dumb one (i.e., a higher one).
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the minion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s now time to initialize the character when it is added to the game. As
    you already know, this is usually done from the `BeginPlay()` method. So, just
    after the `Super::BeginPlay()` declaration, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This call will simply start the patrolling behavior. Then, add the `PostInitializeComponents()`
    implementation by adding this code to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using two delegates to react to an Actor overlap, for
    checking whether we have reached the player character, and to handle the pawn
    perception to check whether we can see the player character. Also, notice that
    they are initialized only if the role of this object is authoritative (i.e., the
    method is being executed on the server).
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to implement these two delegate functions in order to manage
    the aforementioned events.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the delegate functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever the minion detects a pawn, it will immediately check whether it is
    a character and, if the result is successful, it will start chasing it. Let’s
    add the method to handle the delegate in the source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code here is quite straightforward – we just have added a debug message
    stating that a character has been detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second delegate we need to handle is the overlap, so add the following
    method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we check again whether we have found a character, and after
    that, we simply display a debug message – it looks like our hero got a little
    too close to the minions and now they’ve roped them into joining the Lichlord’s
    undead army! Later on, you’ll implement a respawn system to let the player restart
    the game with a brand-new character.
  prefs: []
  type: TYPE_NORMAL
- en: The next step will be the actual AI’s movement through the Navigation Mesh,
    both for the patrol and chase behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the chase and patrol behaviors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s now time to start implementing the movement control for your AI character
    – specifically, you’ll be implementing the `SetNextPatrolLocation()` function,
    which will find a new reachable point for the minion, and the `Chase()` function,
    which will send the minion on a “seek and destroy” mission toward the character.
    To do so, add the following code to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first function sets the character speed to the patrolling value and uses
    the `UNavigationSystemV1::K2_GetRandomReachablePointInRadius()` method to find
    a reachable point in the Navigation Mesh. Then, the AI is simply commanded to
    reach that location.
  prefs: []
  type: TYPE_NORMAL
- en: The second function does something similar, but the target point will be the
    character – after all, it is on a mission from the Lichlord to get as many soon-to-be
    undead heroes as possible!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Tick() event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last thing you need to implement in order to make the patrolling system
    fully operational is to check whether the AI character has reached its destination;
    in this case, it will just have to find another point in the Navigation Mesh.
    As we need to continuously check the distance between the AI and the target point,
    the best place to write the code is within the `Tick()` event. Let’s find the
    method and, just after the `Super::Tick(DeltaTime)` call, add this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first line checks whether the character is patrolling (i.e.,
    the maximum speed should not equal the chase speed). Then, we are checking that
    we are near enough (about half a meter) to the patrol location in order to look
    for another reachable point.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the AI opponent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that the enemy AI has been created, you can test it out in the game level.
    To do this, open the Unreal Engine Editor and, from the Content Browser, drag
    an instance of the `US_Minion` class (located in the `C++ Classes` | `UnrealShadows_LOTL`
    folder) into the level. You should see something similar to *Figure 8**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The AI opponent in the level](img/Figure_08_02_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The AI opponent in the level
  prefs: []
  type: TYPE_NORMAL
- en: The gizmos around the character represent the `PawnSense` component – its sight
    and hearing capabilities. The sight area is represented by a green cone that shows
    how wide and far the AI can see. The hearing sense is represented by two spheres
    – a yellow one that shows how far the AI will hear a noise if it is not obstructed
    by any obstacle, and a cyan one that shows how far the AI will sense noise, even
    if generated behind an obstacle, such as a wall.
  prefs: []
  type: TYPE_NORMAL
- en: Go into play mode and the opponent should start wandering around the level and
    over the Navigation Mesh. Whenever a player character enters the minion’s line
    of sight (i.e., the green cone), the enemy will react and start chasing the player
    at a higher speed.
  prefs: []
  type: TYPE_NORMAL
- en: Once the character has been reached, you will notice that the minion will stop
    moving – its mission has been completed and it can rest!
  prefs: []
  type: TYPE_NORMAL
- en: As an extra exercise, you may want to add a timer that will check whether the
    AI is staying still for too long; in that case, it will restart its patrolling
    system by looking for a new reachable location.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this section, you have created your AI opponent, ready to roam around
    the dungeon, seeking its next victim. You have created a simple but effective
    patrolling system and added a perception sense to the AI so that it can intercept
    the player when they are not stealthy enough.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll create a spawning system in order to add minions
    as the game progresses and make things more challenging for the players.
  prefs: []
  type: TYPE_NORMAL
- en: Adding opponents to the level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have an opponent for your thief hero, it is time to let the system
    spawn a bunch of them at runtime. You’ll be doing this by implementing a spawn
    system similar to the one used in [*Chapter 3*](B18203_03.xhtml#_idTextAnchor065),
    *Testing the Multiplayer System with a Project Prototype* – this time, you’ll
    create the spawner in C++ instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want to implement here is an Actor that will have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Spawns a few minions at the start of the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawns new minions at predefined intervals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawns the minions in a selected area.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Randomly selects a minion type every time it spawns. At the moment, we have
    just one minion type, but in the following chapters, we will add more variations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a spawner class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by creating a C++ class that extends from Actor and name it `US_MinionSpawner`.
    Once created, open the `.h` file and, in the `private` section, add the following
    declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You should be already familiar with the first declaration from [*Chapter 3*](B18203_03.xhtml#_idTextAnchor065),
    *Testing the Multiplayer System with a Project Prototype* – we are declaring an
    area that will be used to randomize the spawned minion location. The second declaration
    will be used to store a reference of the timer handler used by the spawner to
    generate new minions at predefined intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to declare some properties that will make this class customizable
    in the level. In the `public` section, add the following property declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first property will expose an array that will contain all the spawnable
    minion types. As stated before, at the moment, we have just one type, but we will
    add some more later on. The other two properties are self-explanatory, letting
    us define the spawn timing and how many minions should already be in the level
    when the game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to add a `Spawn()` method in the protected section of the
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The header is now finished. Now, let’s switch to the `.cpp` and implement some
    code logic.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the spawner logic
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time to implement the spawner features. To do so, open the `.cpp` file,
    find the constructor, and add the required includes at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You are already well versed in creating components, so let’s dive right into
    the `BeginPlay()` method and add this code just after the `Super::BeginPlay()`
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we are checking that there is at least one spawnable minion type
    – if the array is empty, there is no need to go on with the code. Then, we check
    that the Actor has the authority to spawn something; as usual, we want the server
    to be in full control of what’s happening.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we call the `Spawn()` function in a loop, in order to create a starting
    pool of enemies. The last step is to create a timer, which will call the `Spawn()`
    function at an interval defined by the `SpawnDelay` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do to have the spawner fully functional is to add the `Spawn()`
    function implementation. Let’s add it at the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As long as it may seem, this code is quite straightforward, and you have already
    done something similar at the start of this book (do you remember the falling
    fruits?). We are just taking a random minion type from the array, retrieving a
    random location in the spawn area, and then we are going to spawn the minion at
    that location. The only thing worth mentioning is `SpawnCollisionHandlingOverride`,
    which is set to spawn the Actor, avoiding any collision with other objects in
    the level.
  prefs: []
  type: TYPE_NORMAL
- en: As an extra exercise, you may add a limit to the number of minions that will
    be spawned from a single spawner object. This will avoid overcrowding your level
    and making the game unplayable for your players!
  prefs: []
  type: TYPE_NORMAL
- en: The spawn Actor is ready, so it is time to compile your project and do some
    proper testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the spawner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is now time to venture into the glories of the Unreal Engine Editor and summon
    those mischievous minions to frolic throughout the level! Locate the `US_MinionSpawner`
    class (found inside the `C++ Classes` | `UnrealShadows_LOTL` folder) and drag
    it into your level to create an instance of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, position the Actor in a suitable place and resize the **Box Extent**
    parameters to set a nice size for the minions to be located within. In my case,
    I opted to place the spawner in the room labeled **SP3** with the **Box Extent**
    property set to **(900, 400, 100)**, as you can see in *Figure 8**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The spawn area](img/Figure_08_03_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – The spawn area
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, with the Actor still selected, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the **Spawn System** category in the **Details** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an element to the **Spawnable Minions** array, which will be labeled as
    **Index[0]**. From the corresponding drop-down menu, select **US_Minion**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Tweak **Spawn Delay** and **Num Minions at Start** to suit your needs; in my
    case, I have left the default values, as you can see in *Figure 8**.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The spawn settings](img/Figure_08_04_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – The spawn settings
  prefs: []
  type: TYPE_NORMAL
- en: You obviously have the freedom to add as many spawner Actors as you feel necessary
    to balance your game level.
  prefs: []
  type: TYPE_NORMAL
- en: Once you enter the realm of play mode, lo and behold, the undead minions shall
    materialize before your very eyes, their replication and synchronization across
    all clients being a testament to the mystical powers of the Lichlord! Well, actually,
    it’s a testament to the power of the Unreal Engine replication system, but you
    don’t want to let your players in on the secret. Keep them in the dark and let
    them marvel at the seamless magic of your game’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8**.5* displays how the spawner looks in action whenever you test it,
    but more simply and less poetically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The spawner in action](img/Figure_08_05_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – The spawner in action
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you created a fully customizable spawn system that can be used
    and tweaked for any level in your game. It’s time to wrap things up and move on
    to the next chapter of this adventure-packed multiplayer game.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to the basics of AI in a multiplayer game.
    First of all, you were given some information on how to create a Navigation System
    that will let your AI move independently around the level. After that, you created
    a base minion, which will patrol around seeking the player characters, changing
    its behavior to a more aggressive stance once it finds them. As a last step, you
    added spawn points around the dungeon in order to populate the area with worthy
    opponents.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing to take away from this chapter is that, with your previously
    acquired knowledge, everything is correctly synchronized over the network. I promised
    you that learning things from the start would be a huge advantage in the future!
    And trust me, putting in the effort and really grasping the basics is now paying
    off with your project!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll keep on exploring some of the possibilities of implementing
    worthy opponents for your hero – we will give it a sense of hearing and a health
    system in order to make it more engaging and, at the very least, defeatable.
  prefs: []
  type: TYPE_NORMAL
