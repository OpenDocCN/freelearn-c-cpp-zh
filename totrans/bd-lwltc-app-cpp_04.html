<html><head></head><body>
<div id="_idContainer024">
<h1 class="chapter-number" id="_idParaDest-88"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-89"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.2.1">Building the C++ Building Blocks for Low Latency Applications</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we had a detailed and highly technical discussion of how to approach developing low latency applications in C++. </span><span class="koboSpan" id="kobo.3.2">We also investigated the technical details of the C++ programming language as well as the GCC compiler. </span><span class="koboSpan" id="kobo.3.3">Now, we will move from a theoretical discussion to building some practical low latency C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">components ourselves.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We will build some relatively general components that can be used in a variety of different low latency applications, such as the ones we discussed in the previous chapters. </span><span class="koboSpan" id="kobo.5.2">As we build these basic building blocks in this chapter, we will learn about using C++ effectively to write highly performant C++ code. </span><span class="koboSpan" id="kobo.5.3">We will use these components in the rest of the book to demonstrate where these components fit into the electronic trading ecosystem that we will design </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">and build.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">C++ threading for multi-threaded low </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">latency applications</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Designing C++ memory pools to avoid dynamic </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">memory allocations</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Transferring data using </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">lock-free queues</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Building a low latency </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">logging framework</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">C++ network programming </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">using sockets</span></span></li>
</ul>
<h1 id="_idParaDest-90"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">All the code for this book can be found in the GitHub repository for this book at </span><a href="https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP"><span class="koboSpan" id="kobo.21.1">https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP</span></a><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">The source for this chapter is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.23.1">Chapter4</span></strong><span class="koboSpan" id="kobo.24.1"> directory in </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">the repository.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">We expect you to have at least intermediate C++ programming experience, since we will assume you understand the widely used C++ programming features well. </span><span class="koboSpan" id="kobo.26.2">We also assume that you have some experience with network programming in C++, since network programming is a huge topic and cannot be covered in this book. </span><span class="koboSpan" id="kobo.26.3">For this book, starting with this chapter, we will use the CMake and Ninja build systems, so we expect you to either understand CMake, g++, Ninja, Make, or some such build system to be able to build the code samples for </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">The specifications of the environment in which the source code for this book was developed are shown here. </span><span class="koboSpan" id="kobo.28.2">We present the details of this environment since all the C++ code presented in this book is not necessarily portable and might require some minor changes to work in </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">your environment:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.30.1">OS</span></strong><span class="koboSpan" id="kobo.31.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18 17:40:00 UTC 2 x86_64 x86_64 </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">x86_64 GNU/Linux</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.34.1">GCC</span></strong><span class="koboSpan" id="kobo.35.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">g++ (Ubuntu </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">11.3.0-1ubuntu1~22.04.1) 11.3.0</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.38.1">CMake</span></strong><span class="koboSpan" id="kobo.39.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">cmake </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">version 3.23.2</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.42.1">Ninja</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">1.10.2</span></strong></span></li>
</ul>
<h1 id="_idParaDest-91"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.45.1">C++ threading for multi-threaded low latency applications</span></h1>
<p><span class="koboSpan" id="kobo.46.1">The first component </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.47.1">we will build </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.48.1">is a very small one but still quite fundamental. </span><span class="koboSpan" id="kobo.48.2">This section will design and implement a method of creating and running threads of execution. </span><span class="koboSpan" id="kobo.48.3">These will be used in many different parts of a full low-latency system, depending on the design of the different sub-components in the system. </span><span class="koboSpan" id="kobo.48.4">Depending on the design of the system, different components might work together as a pipeline to facilitate parallel processing. </span><span class="koboSpan" id="kobo.48.5">We will use the multi-threading framework in exactly such a way in our electronic trading systems. </span><span class="koboSpan" id="kobo.48.6">Another use case is to pass off non-critical tasks such as logging onto disk, computing statistics, and so on to a </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">background thread.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Before we move on to the source code that creates and manipulates threads, let us first quickly </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.51.1">define a few useful macros. </span><span class="koboSpan" id="kobo.51.2">We </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.52.1">will use these functions in many places in the source code that we will be writing in this book, starting with </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">this chapter.</span></span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.54.1">Defining some useful macros and functions</span></h2>
<p><span class="koboSpan" id="kobo.55.1">Most low latency </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.56.1">applications run on modern pipelined processors that </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.57.1">pre-fetch instructions and data before they need to be executed. </span><span class="koboSpan" id="kobo.57.2">We discussed in the previous chapter that branch mispredictions are extremely expensive and stall the pipeline, introducing bubbles into it. </span><span class="koboSpan" id="kobo.57.3">Therefore, an important development practice for low latency applications is to have fewer branches. </span><span class="koboSpan" id="kobo.57.4">Since branches are unavoidable, it is also important to try and make them as predictable </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">We have two simple macros that we will use to provide branching hints to the compiler. </span><span class="koboSpan" id="kobo.59.2">These use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">__builtin_expect</span></strong><span class="koboSpan" id="kobo.61.1"> GCC built-in function that reorders the machine instructions generated by the compiler. </span><span class="koboSpan" id="kobo.61.2">Effectively, the compiler uses the branch prediction hints provided by the developer to generate machine code that is optimized under the assumption that a branch is more or less likely to </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">be taken.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">Note that instruction reordering is only part of the full picture when it comes to branch prediction, since there is a hardware branch predictor that the processor uses when running instructions. </span><span class="koboSpan" id="kobo.63.2">Note that modern hardware branch predictors are extremely good at predicting branches and jumps, especially in cases where the same branch gets taken many times and even when there are at least easily predictable </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">branching patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">The two macros are </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.67.1">
#define LIKELY(x) __builtin_expect(!!(x), 1)
#define UNLIKELY(x) __builtin_expect(!!(x), 0)</span></pre>
<p><span class="koboSpan" id="kobo.68.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">LIKELY(x)</span></strong><span class="koboSpan" id="kobo.70.1"> macro specifies that the condition specified by </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">x</span></strong><span class="koboSpan" id="kobo.72.1"> is likely to be true, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">UNLIKELY(x)</span></strong><span class="koboSpan" id="kobo.74.1"> macro does the opposite. </span><span class="koboSpan" id="kobo.74.2">As an example of the usage, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">UNLIKELY</span></strong><span class="koboSpan" id="kobo.76.1"> macro shortly in the next set of functions. </span><span class="koboSpan" id="kobo.76.2">In C++20, this is standardized like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">[[likely]]</span></strong><span class="koboSpan" id="kobo.78.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">[[unlikely]]</span></strong><span class="koboSpan" id="kobo.80.1"> attributes to perform the same function in a standard and </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">portable manner.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">We will define two additional functions next, but these are simply used for assertions in our code base. </span><span class="koboSpan" id="kobo.82.2">These should be pretty self-explanatory; </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">ASSERT</span></strong><span class="koboSpan" id="kobo.84.1"> logs a message and exits if the condition it is provided evaluates to </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">false</span></strong><span class="koboSpan" id="kobo.86.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">FATAL</span></strong><span class="koboSpan" id="kobo.88.1"> simply logs a message and exits. </span><span class="koboSpan" id="kobo.88.2">Note the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">UNLIKELY</span></strong><span class="koboSpan" id="kobo.90.1"> here to specify that we do not expect the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">!cond</span></strong><span class="koboSpan" id="kobo.92.1"> condition to evaluate to </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">true</span></strong><span class="koboSpan" id="kobo.94.1">. </span><span class="koboSpan" id="kobo.94.2">Also note that using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">ASSERT</span></strong><span class="koboSpan" id="kobo.96.1"> method on critical code paths is not free, mostly because of the if check. </span><span class="koboSpan" id="kobo.96.2">This is something that we will eventually change </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.97.1">to be optimized out of our code for release </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.98.1">builds, but for now, we will keep it, since it should be extremely cheap </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">to use:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.100.1">
inline auto ASSERT(bool cond, const std::string&amp; msg)
  noexcept {
  if(UNLIKELY(!cond)) {
    std::cerr &lt;&lt; msg &lt;&lt; std::endl;
    exit(EXIT_FAILURE);
  }
}
inline auto FATAL(const std::string&amp; msg) noexcept {
  std::cerr &lt;&lt; msg &lt;&lt; std::endl;
  exit(EXIT_FAILURE);
}</span></pre>
<p><span class="koboSpan" id="kobo.101.1">The code discussed in this section can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">Chapter4/macros.h</span></strong><span class="koboSpan" id="kobo.103.1"> source file in the GitHub repository for this book. </span><span class="koboSpan" id="kobo.103.2">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">macros.h</span></strong><span class="koboSpan" id="kobo.105.1"> header file includes the following two </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">header files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.107.1">
#include &lt;cstring&gt;
#include &lt;iostream&gt;</span></pre>
<p><span class="koboSpan" id="kobo.108.1">Now, let us jump into thread creation and manipulation functionality in the </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">next section.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.110.1">Creating and launching a new thread</span></h2>
<p><span class="koboSpan" id="kobo.111.1">The method </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.112.1">defined in the following code block creates a new thread object, sets </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.113.1">the thread affinity on the thread (more on this later), and forwards </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.114.1">the function and related arguments </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.115.1">that the thread will run during its execution. </span><span class="koboSpan" id="kobo.115.2">This is achieved in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">thread_body</span></strong><span class="koboSpan" id="kobo.117.1"> lambda, which is passed to the constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">std::thread</span></strong><span class="koboSpan" id="kobo.119.1">. </span><span class="koboSpan" id="kobo.119.2">Note the use of </span><em class="italic"><span class="koboSpan" id="kobo.120.1">variadic template arguments</span></em><span class="koboSpan" id="kobo.121.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.122.1">perfect forwarding</span></em><span class="koboSpan" id="kobo.123.1"> to allow this method to be used, running all kinds of functions, arbitrary types, and any number of arguments. </span><span class="koboSpan" id="kobo.123.2">After creating the thread, the method waits till the thread either starts running successfully or fails because it failed to set thread affinity, which is what the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">t-&gt;join()</span></strong><span class="koboSpan" id="kobo.125.1"> does. </span><span class="koboSpan" id="kobo.125.2">Ignore the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">setThreadCore(core_id)</span></strong><span class="koboSpan" id="kobo.127.1"> for now; we will discuss that in the </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">next section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.129.1">
#pragma once
#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/syscall.h&gt;
template&lt;typename T, typename... </span><span class="koboSpan" id="kobo.129.2">A&gt;
inline auto createAndStartThread(int core_id, const
  std::string &amp;name, T &amp;&amp;func, A &amp;&amp;... </span><span class="koboSpan" id="kobo.129.3">args) noexcept {
  std::atomic&lt;bool&gt; running(false), failed(false);
  auto thread_body = [&amp;] {
    if (core_id &gt;= 0 &amp;&amp; !setThreadCore(core_id)) {
      std::cerr &lt;&lt; "Failed to set core affinity for " &lt;&lt;
        name &lt;&lt; " " &lt;&lt; pthread_self() &lt;&lt; " to " &lt;&lt; core_id
          &lt;&lt; std::endl;
      failed = true;
      return;
    }
    std::cout &lt;&lt; "Set core affinity for " &lt;&lt; name &lt;&lt; " " &lt;&lt;
      pthread_self() &lt;&lt; " to " &lt;&lt; core_id &lt;&lt; std::endl;
    running = true;
    std::forward&lt;T&gt;(func)((std::forward&lt;A&gt;(args))...);
  };
  auto t = new std::thread(thread_body);
  while (!running &amp;&amp; !failed) {
    using namespace std::literals::chrono_literals;
    std::this_thread::sleep_for(1s);
  }
  if (failed) {
    t-&gt;join();
    delete t;
    t = nullptr;
  }
  return t;
}</span></pre>
<p><span class="koboSpan" id="kobo.130.1">The code discussed in </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.131.1">this section can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">Chapter4/thread_utils.h</span></strong><span class="koboSpan" id="kobo.133.1"> source </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.134.1">file in the GitHub repository for this </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.135.1">book. </span><span class="koboSpan" id="kobo.135.2">Now, let us jump into the final </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.136.1">section to set thread affinity in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">setThreadCore(core_id)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.138.1"> function.</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.139.1">Setting thread affinity</span></h2>
<p><span class="koboSpan" id="kobo.140.1">Here, we will discuss the source code to set the thread affinity for the thread creation lambda we saw in </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.141.1">the previous section. </span><span class="koboSpan" id="kobo.141.2">Before we discuss the source code, remember </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.142.1">that if there is a lot of context-switching between threads, it adds a lot of overhead to thread performance. </span><span class="koboSpan" id="kobo.142.2">Threads jumping between CPU cores also hurts performance for similar reasons. </span><span class="koboSpan" id="kobo.142.3">Setting thread affinity for performance-critical threads is very important for low latency applications to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">these issues.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">Now, let us look at how to set thread affinity in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">setThreadCore()</span></strong><span class="koboSpan" id="kobo.146.1"> method. </span><span class="koboSpan" id="kobo.146.2">First, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">CPU_ZERO()</span></strong><span class="koboSpan" id="kobo.148.1"> method to clear the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">cpu_set_t</span></strong><span class="koboSpan" id="kobo.150.1"> variable, which is just an array of flags. </span><span class="koboSpan" id="kobo.150.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">CPU_SET()</span></strong><span class="koboSpan" id="kobo.152.1"> method to enable entry for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">core_id</span></strong><span class="koboSpan" id="kobo.154.1"> we are trying to pin the core to. </span><span class="koboSpan" id="kobo.154.2">Finally, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">pthread_setaffinity_np()</span></strong><span class="koboSpan" id="kobo.156.1"> function to set the thread affinity and return </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">false</span></strong><span class="koboSpan" id="kobo.158.1"> if that fails. </span><span class="koboSpan" id="kobo.158.2">Note the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">pthread_self()</span></strong><span class="koboSpan" id="kobo.160.1"> here to get the thread ID to use, which makes sense because this is called from within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">std::thread</span></strong><span class="koboSpan" id="kobo.162.1"> instance we create </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">createAndStartThread()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.166.1">
inline auto setThreadCore(int core_id) noexcept {
  cpu_set_t cpuset;
  CPU_ZERO(&amp;cpuset);
  CPU_SET(core_id, &amp;cpuset);
  return (pthread_setaffinity_np(pthread_self(), sizeof
    (cpu_set_t), &amp;cpuset) == 0);
}</span></pre>
<p><span class="koboSpan" id="kobo.167.1">The code discussed in this section can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">Chapter4/thread_utils.h</span></strong><span class="koboSpan" id="kobo.169.1"> source file in the </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.170.1">GitHub repository for this </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.171.1">book. </span><span class="koboSpan" id="kobo.171.2">These code blocks belong in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">Common</span></strong><span class="koboSpan" id="kobo.173.1"> namespace, as you will see when you look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">thread_utils.h</span></strong><span class="koboSpan" id="kobo.175.1"> source file in the </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">GitHub repository.</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.177.1">Building an example</span></h2>
<p><span class="koboSpan" id="kobo.178.1">Before we conclude </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.179.1">this section, let us quickly look at a simple example that uses the thread utilities we just created. </span><span class="koboSpan" id="kobo.179.2">This example can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">Chapter4/thread_example.cpp</span></strong><span class="koboSpan" id="kobo.181.1"> source file in the GitHub repository for this book. </span><span class="koboSpan" id="kobo.181.2">Note that the library and all the examples for this chapter can be built using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">CMakeLists.txt</span></strong><span class="koboSpan" id="kobo.183.1"> included in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">Chapter4</span></strong><span class="koboSpan" id="kobo.185.1"> directory. </span><span class="koboSpan" id="kobo.185.2">We also provided two simple scripts, </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">build.sh</span></strong><span class="koboSpan" id="kobo.187.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">run_examples.sh</span></strong><span class="koboSpan" id="kobo.189.1">, to build and run these examples after setting the correct paths to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">cmake</span></strong><span class="koboSpan" id="kobo.191.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">ninja</span></strong><span class="koboSpan" id="kobo.193.1"> binaries. </span><span class="koboSpan" id="kobo.193.2">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">cmake</span></strong><span class="koboSpan" id="kobo.195.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">ninja</span></strong><span class="koboSpan" id="kobo.197.1"> are arbitrary build system choices here, and you can change the build system to be anything else </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">if needed.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">The example should be quite self-explanatory – we create and launch two threads with a dummy task of adding the two arguments (</span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">a</span></strong><span class="koboSpan" id="kobo.201.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">b</span></strong><span class="koboSpan" id="kobo.203.1">) passed to it. </span><span class="koboSpan" id="kobo.203.2">Then, we wait for the threads to finish execution before exiting </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">the program:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.205.1">
#include "thread_utils.h"
auto dummyFunction(int a, int b, bool sleep) {
  std::cout &lt;&lt; "dummyFunction(" &lt;&lt; a &lt;&lt; "," &lt;&lt; b &lt;&lt; ")" &lt;&lt;
    std::endl;
  std::cout &lt;&lt; "dummyFunction output=" &lt;&lt; a + b &lt;&lt;
    std::endl;
  if(sleep) {
    std::cout &lt;&lt; "dummyFunction sleeping..." </span><span class="koboSpan" id="kobo.205.2">&lt;&lt; std::endl;
    using namespace std::literals::chrono_literals;
    std::this_thread::sleep_for(5s);
  }
  std::cout &lt;&lt; "dummyFunction done." </span><span class="koboSpan" id="kobo.205.3">&lt;&lt; std::endl;
}
int main(int, char **) {
  using namespace Common;
  auto t1 = createAndStartThread(-1, "dummyFunction1",
    dummyFunction, 12, 21, false);
  auto t2 = createAndStartThread(1, "dummyFunction2",
    dummyFunction, 15, 51, true);
  std::cout &lt;&lt; "main waiting for threads to be done." </span><span class="koboSpan" id="kobo.205.4">&lt;&lt;
    std::endl;
  t1-&gt;join();
  t2-&gt;join();
  std::cout &lt;&lt; "main exiting." </span><span class="koboSpan" id="kobo.205.5">&lt;&lt; std::endl;
  return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.206.1">Running this example will output something like this as the </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">program executes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.208.1">
(base) sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter4$ ./cmake-build-release/thread_example
Set core affinity for dummyFunction1 140124979386112 to -1
dummyFunction(12,21)
dummyFunction output=33
dummyFunction done.
</span><span class="koboSpan" id="kobo.208.2">Set core affinity for dummyFunction2 140124970993408 to 1
dummyFunction(15,51)
dummyFunction output=66
dummyFunction sleeping...
</span><span class="koboSpan" id="kobo.208.3">main waiting for threads to be done.
</span><span class="koboSpan" id="kobo.208.4">dummyFunction done.
</span><span class="koboSpan" id="kobo.208.5">main exiting.</span></pre>
<p><span class="koboSpan" id="kobo.209.1">Let us move on to the </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.210.1">next section, where we will discuss how to avoid dynamic memory allocations when objects need to be created and discarded </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">during runtime.</span></span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.212.1">Designing C++ memory pools to avoid dynamic memory allocations</span></h1>
<p><span class="koboSpan" id="kobo.213.1">We have had </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.214.1">several discussions </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.215.1">on dynamic memory allocation, the steps the OS needs to perform, and why dynamic memory allocation is slow. </span><span class="koboSpan" id="kobo.215.2">Dynamic memory allocation is so slow in fact that low latency applications actively try to avoid it as much as possible on the critical path. </span><span class="koboSpan" id="kobo.215.3">We cannot build useful applications without creating and deleting many objects at runtime, and dynamic memory allocation is too slow for low </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">latency applications.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.217.1">Understanding the definition of a memory pool</span></h2>
<p><span class="koboSpan" id="kobo.218.1">First, let us formally </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.219.1">define what a memory pool is and why we need one. </span><span class="koboSpan" id="kobo.219.2">Many applications (including low latency applications) need to be able to handle many objects and an unknown number of objects. </span><span class="koboSpan" id="kobo.219.3">By an unknown number of objects, we mean that the expected count of objects cannot be determined ahead of time, and it cannot be ascertained what the maximum number of objects will be. </span><span class="koboSpan" id="kobo.219.4">Obviously, the maximum number of objects possible is what can fit inside the system’s memory. </span><span class="koboSpan" id="kobo.219.5">The traditional approach to handling these objects is to use dynamic memory allocations as needed. </span><span class="koboSpan" id="kobo.219.6">In such a case, the heap memory is considered the memory pool – that is, the pool of memory to allocate from and deallocate to. </span><span class="koboSpan" id="kobo.219.7">Unfortunately, these are slow, and we will control how the allocation and deallocation of memory happen in our system using our own custom memory pool. </span><span class="koboSpan" id="kobo.219.8">We define a memory pool as anything from which we can request additional memory or objects and return free memory or objects to. </span><span class="koboSpan" id="kobo.219.9">By building our own custom memory pool, we can leverage the usage patterns and control the allocation and deallocation mechanisms for </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">optimal performance.</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.221.1">Understanding the use cases of a memory pool</span></h2>
<p><span class="koboSpan" id="kobo.222.1">When the exact number of objects of a certain type that will be required is known ahead of time, you </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.223.1">can decide to create exactly that number when needed. </span><span class="koboSpan" id="kobo.223.2">In practice, there are many cases where the exact number of objects is not known ahead of time. </span><span class="koboSpan" id="kobo.223.3">This means we need to create objects on the fly using dynamic memory allocation. </span><span class="koboSpan" id="kobo.223.4">As mentioned previously, dynamic memory allocation is a very slow process and a problem for low latency applications. </span><span class="koboSpan" id="kobo.223.5">We use the term </span><em class="italic"><span class="koboSpan" id="kobo.224.1">memory pool</span></em><span class="koboSpan" id="kobo.225.1"> to describe a pool of objects of a certain type, and that is what we will build in this section. </span><span class="koboSpan" id="kobo.225.2">We will use the memory pool in this book to allocate and deallocate objects that we </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">cannot predict.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">The solution we will use is to pre-allocate large blocks of memory at startup and serve out required amounts at runtime – that is, do the memory allocation and deallocation steps ourselves from this storage pool. </span><span class="koboSpan" id="kobo.227.2">This ends up performing significantly better for a lot of different reasons, such as being able to limit the memory pool usage to certain components in our system instead of all processes running on the server. </span><span class="koboSpan" id="kobo.227.3">We can also control the memory storage and allocation and deallocation algorithms, tuning them to perform optimally for our </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">specific application.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">Let us start by first </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.230.1">making some design decisions for our memory pool. </span><span class="koboSpan" id="kobo.230.2">All the source code for our memory pool is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">Chapter4/mem_pool.h</span></strong><span class="koboSpan" id="kobo.232.1"> source file in the GitHub repository for </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">this book.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.234.1">Designing the memory pool storage</span></h2>
<p><span class="koboSpan" id="kobo.235.1">First, we need to decide </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.236.1">how to store the elements inside the memory pool. </span><span class="koboSpan" id="kobo.236.2">We have really two major choices here – store them on the stack using something like an old-style array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">T[N]</span></strong><span class="koboSpan" id="kobo.238.1">) or </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">std::array</span></strong><span class="koboSpan" id="kobo.240.1">, or store it on the heap using something like an old-style pointer (</span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">T*</span></strong><span class="koboSpan" id="kobo.242.1">) or something like </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">std::vector</span></strong><span class="koboSpan" id="kobo.244.1">. </span><span class="koboSpan" id="kobo.244.2">Depending on the size of the memory pool, the usage frequency, usage patterns, and the application itself, one choice might be better than the other. </span><span class="koboSpan" id="kobo.244.3">For instance, it is possible that we expect to need a huge amount of memory in the memory pool, either because the objects it stores are large or there are many of them. </span><span class="koboSpan" id="kobo.244.4">For such a case, heap allocation would be the preferred choice to accommodate the large memory requirements without impacting the stack memory. </span><span class="koboSpan" id="kobo.244.5">If we expect very few objects or small objects, we should consider using the stack implementation instead. </span><span class="koboSpan" id="kobo.244.6">If we expect to access the objects rarely, putting them on the stack might encounter better cache performance, but for frequent access, either implementation should work equally well. </span><span class="koboSpan" id="kobo.244.7">As with a lot of other choices, these decisions are always made by measuring performance in practice. </span><span class="koboSpan" id="kobo.244.8">For our memory pool, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">std::vector</span></strong><span class="koboSpan" id="kobo.246.1"> and heap allocation while noting that it is </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">not thread-safe.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">We also need a variable to track which blocks are free or in use. </span><span class="koboSpan" id="kobo.248.2">Finally, we will need one last variable to track the location of the next free block to quickly serve allocation requests. </span><span class="koboSpan" id="kobo.248.3">One important thing to note here is that we have </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">two choices:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.250.1">We use two vectors – one to track the objects and one to track the free or empty markers. </span><span class="koboSpan" id="kobo.250.2">This solution is presented in the following diagram; note that in this example, we assume that these two vectors are in very different memory locations. </span><span class="koboSpan" id="kobo.250.3">The point we are trying to make here is that accessing the free or empty marker and the object itself might cause cache misses because they are far away from </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">each other.</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.252.1"><img alt="Figure 4.1 – A memory pool implementation that uses two vectors to track objects and show which indices are free or in use" src="image/Figure_4.1_B19434.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.253.1">Figure 4.1 – A memory pool implementation that uses two vectors to track objects and show which indices are free or in use</span></p>
<ul>
<li><span class="koboSpan" id="kobo.254.1">We maintain a </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.255.1">single vector of structures (a struct, a class, or primitive objects), and each structure stores both the object and variable to represent the free or </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">empty flag.</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.257.1"><img alt="Figure 4.2 – A memory pool implementation that uses a single vector to track the object and see whether it is free or in use" src="image/Figure_4.2_B19434.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.258.1">Figure 4.2 – A memory pool implementation that uses a single vector to track the object and see whether it is free or in use</span></p>
<p><span class="koboSpan" id="kobo.259.1">The second choice is better from a cache performance perspective, because accessing the object </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.260.1">and free marker placed right after the object is better than accessing two different locations in two different vectors that might be potentially far away from each other in memory. </span><span class="koboSpan" id="kobo.260.2">This is also because, in almost all usage patterns, if we access the object, we access the free marker and </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">vice versa:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.262.1">
#pragma once
#include &lt;cstdint&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include "macros.h"
namespace Common {
  template&lt;typename T&gt;
  class MemPool final {
private:
  struct ObjectBlock {
    T object_;
    bool is_free_ = true;
  };
  std::vector&lt;ObjectBlock&gt; store_;
  size_t next_free_index_ = 0;
};</span></pre>
<p><span class="koboSpan" id="kobo.263.1">Next, we need to </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.264.1">look at how we initialize this memory pool in the constructor and some boilerplate code for the construction and </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">assignment tasks.</span></span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.266.1">Initializing the memory pool</span></h2>
<p><span class="koboSpan" id="kobo.267.1">Initializing our memory pool is quite straightforward – we simply accept a parameter that specifies </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.268.1">the initial size of our memory pool and initialize the vector to be large enough to accommodate that many concurrently allocated objects. </span><span class="koboSpan" id="kobo.268.2">In our design, we will not add functionality to resize the memory pool past its initial size, but that is a relatively straightforward extension to add if needed. </span><span class="koboSpan" id="kobo.268.3">Note that this initial vector initialization is the only time the memory pool allocates memory dynamically, so the memory pool should be created before the execution of the critical path starts. </span><span class="koboSpan" id="kobo.268.4">One thing to note here is that we add an assertion to make sure that the actual object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">T</span></strong><span class="koboSpan" id="kobo.270.1"> is the first one in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">ObjectBlock</span></strong><span class="koboSpan" id="kobo.272.1"> struct; we will see the reason for this requirement in the </span><em class="italic"><span class="koboSpan" id="kobo.273.1">Handling </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.274.1">deallocations</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.275.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.276.1">
public:
  explicit MemPool(std::size_t num_elems) :
      store_(num_elems, {T(), true}) /* pre-allocation of
        vector storage. </span><span class="koboSpan" id="kobo.276.2">*/ {
    ASSERT(reinterpret_cast&lt;const ObjectBlock *&gt;
      (&amp;(store_[0].object_)) == &amp;(store_[0]), "T object
        should be first member of ObjectBlock.");
  }</span></pre>
<p><span class="koboSpan" id="kobo.277.1">Now for some boilerplate code – we will delete the default constructor, the copy constructor, and the move constructor methods. </span><span class="koboSpan" id="kobo.277.2">We will do the same with the copy assignment operator and the move assignment operator. </span><span class="koboSpan" id="kobo.277.3">We do this so that these methods are not accidentally called without our knowledge. </span><span class="koboSpan" id="kobo.277.4">This is also the reason we made our constructor explicit – to prohibit implicit conversions where we do not </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">expect them:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.279.1">
  MemPool() = delete;
  MemPool(const MemPool&amp;) = delete;
  MemPool(const MemPool&amp;&amp;) = delete;
  MemPool&amp; operator=(const MemPool&amp;) = delete;
  MemPool&amp; operator=(const MemPool&amp;&amp;) = delete;</span></pre>
<p><span class="koboSpan" id="kobo.280.1">Now, let us move </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.281.1">on to the code to serve allocation requests by providing a free object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">T</span></strong><span class="koboSpan" id="kobo.283.1">-type </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">template parameter.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.285.1">Serving new allocation requests</span></h2>
<p><span class="koboSpan" id="kobo.286.1">Serving allocation requests is a </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.287.1">simple task of finding a block that is free in our memory pool storage, which we can do easily using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">next_free_index_</span></strong><span class="koboSpan" id="kobo.289.1"> tracker. </span><span class="koboSpan" id="kobo.289.2">Then, we update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">is_free_</span></strong><span class="koboSpan" id="kobo.291.1"> marker for that block, initialize the object block of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">T</span></strong><span class="koboSpan" id="kobo.293.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">placement new</span></strong><span class="koboSpan" id="kobo.295.1">, and then update </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">next_free_index_</span></strong><span class="koboSpan" id="kobo.297.1"> to point to the next available </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">free block.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">Note two things – the first is that we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">placement new</span></strong><span class="koboSpan" id="kobo.301.1"> to return an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">T</span></strong><span class="koboSpan" id="kobo.303.1"> instead of a memory block that is the same size as </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">T</span></strong><span class="koboSpan" id="kobo.305.1">. </span><span class="koboSpan" id="kobo.305.2">This is not strictly necessary and can be removed if the user of the memory pool wants to take responsibility for constructing the object from the memory block we return. </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">placement new</span></strong><span class="koboSpan" id="kobo.307.1"> in most compiler implementations might add an extra </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">if</span></strong><span class="koboSpan" id="kobo.309.1"> check to confirm that the memory block provided to it is </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">not null.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">The second thing, which is more of a design choice for us to make depending on the application, is that we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">updateNextFreeIndex()</span></strong><span class="koboSpan" id="kobo.313.1"> to update </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">next_free_index_</span></strong><span class="koboSpan" id="kobo.315.1"> to point to the next available free block, which can be implemented in different ways other than the provided here. </span><span class="koboSpan" id="kobo.315.2">To answer the question of which implementation is optimal is that it </span><em class="italic"><span class="koboSpan" id="kobo.316.1">depends</span></em><span class="koboSpan" id="kobo.317.1"> and needs to be measured in practice. </span><span class="koboSpan" id="kobo.317.2">Now, let us first look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">allocate()</span></strong><span class="koboSpan" id="kobo.319.1"> method where, again, we use variadic template </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.320.1">arguments to allow arbitrary arguments to be forwarded to the constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">T</span></strong><span class="koboSpan" id="kobo.322.1">. </span><span class="koboSpan" id="kobo.322.2">Note that here we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">placement new</span></strong><span class="koboSpan" id="kobo.324.1"> operator to construct an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">T</span></strong><span class="koboSpan" id="kobo.326.1"> with the given arguments from the memory block. </span><span class="koboSpan" id="kobo.326.2">Remember that </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">new</span></strong><span class="koboSpan" id="kobo.328.1"> is an operator that can also be overridden if needed, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">placement new</span></strong><span class="koboSpan" id="kobo.330.1"> operator skips the step that allocates memory and uses the provided memory </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">block instead:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
    template&lt;typename... </span><span class="koboSpan" id="kobo.332.2">Args&gt;
    T *allocate(Args... </span><span class="koboSpan" id="kobo.332.3">args) noexcept {
      auto obj_block = &amp;(store_[next_free_index_]);
      ASSERT(obj_block-&gt;is_free_, "Expected free
        ObjectBlock at index:" + std::to_string
          (next_free_index_));
      T *ret = &amp;(obj_block-&gt;object_);
      ret = new(ret) T(args...); // placement new.
</span><span class="koboSpan" id="kobo.332.4">      obj_block-&gt;is_free_ = false;
      updateNextFreeIndex();
      return ret;
    }</span></pre>
<p><span class="koboSpan" id="kobo.333.1">Let us look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">updateNextFreeIndex()</span></strong><span class="koboSpan" id="kobo.335.1"> method next. </span><span class="koboSpan" id="kobo.335.2">There are two things to note here – first, we have a branch for a case where the index wraps around the end. </span><span class="koboSpan" id="kobo.335.3">While this adds an </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">if</span></strong><span class="koboSpan" id="kobo.337.1"> condition here, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">UNLIKELY()</span></strong><span class="koboSpan" id="kobo.339.1"> specification and the expectation of our hardware branch predictor to always predict that the branch isn’t taken, this should not hurt our performance in a meaningful way. </span><span class="koboSpan" id="kobo.339.2">We can, of course, break up the loop into two loops and remove that </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">if</span></strong><span class="koboSpan" id="kobo.341.1"> condition if we really want to – that is, the first loop loops till </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">next_free_index_ == store_.size()</span></strong><span class="koboSpan" id="kobo.343.1">, and the second loop loops from </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">0 onwards.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">Secondly, we added a check to detect and fail if there is ever a case where the memory pool is completely </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.346.1">full. </span><span class="koboSpan" id="kobo.346.2">There are obviously better ways to handle this in practice that do not involve failures, but for the sake of brevity and to stay within the scope of this book, we will just fail when this happens </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">for now:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.348.1">
  private:
    auto updateNextFreeIndex() noexcept {
      const auto initial_free_index = next_free_index_;
      while (!store_[next_free_index_].is_free_) {
        ++next_free_index_;
        if (UNLIKELY(next_free_index_ == store_.size())) {
          // hardware branch predictor should almost always
              predict this to be false any ways.
</span><span class="koboSpan" id="kobo.348.2">          next_free_index_ = 0;
        }
        if (UNLIKELY(initial_free_index ==
          next_free_index_)) {
          ASSERT(initial_free_index != next_free_index_,
            "Memory Pool out of space.");
        }
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.349.1">The next section </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.350.1">deals with handling deallocations or returning objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">T</span></strong><span class="koboSpan" id="kobo.352.1"> back to the memory pool to reclaim them </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">as free.</span></span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.354.1">Handling deallocations</span></h2>
<p><span class="koboSpan" id="kobo.355.1">Deallocations are </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.356.1">a simple matter of finding the correct </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">ObjectBlock</span></strong><span class="koboSpan" id="kobo.358.1"> in our internal </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">store_</span></strong><span class="koboSpan" id="kobo.360.1"> that corresponds to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">T</span></strong><span class="koboSpan" id="kobo.362.1"> object being deallocated and marking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">is_free_</span></strong><span class="koboSpan" id="kobo.364.1"> marker for that block to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">true</span></strong><span class="koboSpan" id="kobo.366.1">. </span><span class="koboSpan" id="kobo.366.2">Here, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">reinterpret_cast</span></strong><span class="koboSpan" id="kobo.368.1"> to convert </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">T*</span></strong><span class="koboSpan" id="kobo.370.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">ObjectBlock*</span></strong><span class="koboSpan" id="kobo.372.1">, which is OK to do, since object </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">T</span></strong><span class="koboSpan" id="kobo.374.1"> is the first member in </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">ObjectBlock</span></strong><span class="koboSpan" id="kobo.376.1">. </span><span class="koboSpan" id="kobo.376.2">This should now explain the assertion we added to the constructor in the </span><em class="italic"><span class="koboSpan" id="kobo.377.1">Initializing the memory pool</span></em><span class="koboSpan" id="kobo.378.1"> section. </span><span class="koboSpan" id="kobo.378.2">We also add an assertion here to make sure that the element that the user tries to deallocate belongs to this memory pool. </span><span class="koboSpan" id="kobo.378.3">Again, there can be more graceful handling of such error cases, but we will leave that up to you for the sake of brevity and to keep the discussion within the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">this book:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.380.1">
    auto deallocate(const T *elem) noexcept {
      const auto elem_index = (reinterpret_cast&lt;const
        ObjectBlock *&gt;(elem) - &amp;store_[0]);
      ASSERT(elem_index &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;
        (elem_index) &lt; store_.size(), "Element being
          deallocated does not belong to this Memory
            pool.");
      ASSERT(!store_[elem_index].is_free_, "Expected in-use
        ObjectBlock at index:" + std::to_string
          (elem_index));
      store_[elem_index].is_free_ = true;
    }</span></pre>
<p><span class="koboSpan" id="kobo.381.1">That concludes our design and implementation of memory pools. </span><span class="koboSpan" id="kobo.381.2">Let us look at a </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">simple example.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.383.1">Using the memory pool with an example</span></h2>
<p><span class="koboSpan" id="kobo.384.1">Let us look at </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.385.1">a simple and self-explanatory example of the memory pool we just created. </span><span class="koboSpan" id="kobo.385.2">This code is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">Chapter4/mem_pool_example.cpp</span></strong><span class="koboSpan" id="kobo.387.1"> file and can be built using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">CMake</span></strong><span class="koboSpan" id="kobo.389.1"> file, as previously mentioned. </span><span class="koboSpan" id="kobo.389.2">It creates a memory pool of a primitive </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">double</span></strong><span class="koboSpan" id="kobo.391.1"> type and another of a </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.392.1">custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">MyStruct</span></strong><span class="koboSpan" id="kobo.394.1"> type. </span><span class="koboSpan" id="kobo.394.2">Then, it allocates and deallocates some elements from this memory pool and prints out the values and </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">memory locations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
#include "mem_pool.h"
struct MyStruct {
  int d_[3];
};
int main(int, char **) {
  using namespace Common;
  MemPool&lt;double&gt; prim_pool(50);
  MemPool&lt;MyStruct&gt; struct_pool(50);
  for(auto i = 0; i &lt; 50; ++i) {
    auto p_ret = prim_pool.allocate(i);
    auto s_ret = struct_pool.allocate(MyStruct{i, i+1,
      i+2});
    std::cout &lt;&lt; "prim elem:" &lt;&lt; *p_ret &lt;&lt; " allocated at:"
      &lt;&lt; p_ret &lt;&lt; std::endl;
    std::cout &lt;&lt; "struct elem:" &lt;&lt; s_ret-&gt;d_[0] &lt;&lt; "," &lt;&lt;
      s_ret-&gt;d_[1] &lt;&lt; "," &lt;&lt; s_ret-&gt;d_[2] &lt;&lt; " allocated
        at:" &lt;&lt; s_ret &lt;&lt; std::endl;
    if(i % 5 == 0) {
      std::cout &lt;&lt; "deallocating prim elem:" &lt;&lt; *p_ret &lt;&lt; "
        from:" &lt;&lt; p_ret &lt;&lt; std::endl;
      std::cout &lt;&lt; "deallocating struct elem:" &lt;&lt; s_ret
        -&gt;d_[0] &lt;&lt; "," &lt;&lt; s_ret-&gt;d_[1] &lt;&lt; "," &lt;&lt; s_ret-&gt;
           d_[2] &lt;&lt; " from:" &lt;&lt; s_ret &lt;&lt; std::endl;
      prim_pool.deallocate(p_ret);
      struct_pool.deallocate(s_ret);
    }
  }
  return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.397.1">Running this </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.398.1">example using the following command should produce output similar to what is </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.400.1">
(base) sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter4$ ./cmake-build-release/mem_pool_example
prim elem:0 allocated at:0x5641b4d1beb0
struct elem:0,1,2 allocated at:0x5641b4d1c220
deallocating prim elem:0 from:0x5641b4d1beb0
deallocating struct elem:0,1,2 from:0x5641b4d1c220
prim elem:1 allocated at:0x5641b4d1bec0
struct elem:1,2,3 allocated at:0x5641b4d1c230
prim elem:2 allocated at:0x5641b4d1bed0
...</span></pre>
<p><span class="koboSpan" id="kobo.401.1">In the next section, we </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.402.1">will build a very similar component – </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">lock-free queues.</span></span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.404.1">Transferring data using lock-free queues</span></h1>
<p><span class="koboSpan" id="kobo.405.1">In the </span><em class="italic"><span class="koboSpan" id="kobo.406.1">C++ threading for multi-threaded low latency applications</span></em><span class="koboSpan" id="kobo.407.1"> section, we hinted that one possible </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.408.1">application of having multiple threads is to set up a pipelined system. </span><span class="koboSpan" id="kobo.408.2">Here, one component thread performs part of the processing and forwards the results to the next stage of the pipeline for further processing. </span><span class="koboSpan" id="kobo.408.3">We will be using such a design in our electronic trading system, but there’ll be more on </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">that later.</span></span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.410.1">Communicating between threads and processes</span></h2>
<p><span class="koboSpan" id="kobo.411.1">There are a lot of options when it comes to transferring data between processes and/or threads. </span><strong class="bold"><span class="koboSpan" id="kobo.412.1">Inter-Process Communication</span></strong><span class="koboSpan" id="kobo.413.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.414.1">IPC</span></strong><span class="koboSpan" id="kobo.415.1">), such as mutexes, semaphores, signals, memory-mapped files, and </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.416.1">shared memory, can </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.417.1">be used for these purposes. </span><span class="koboSpan" id="kobo.417.2">It also gets </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.418.1">tricky when there is concurrent access to shared data and the important requirement is to avoid data corruption. </span><span class="koboSpan" id="kobo.418.2">Another important requirement is to make sure that the reader and writer have consistent views of the shared data. </span><span class="koboSpan" id="kobo.418.3">To transfer information from one thread to another (or from one process to another), the optimal way to do so is through a data queue that both threads have access to. </span><span class="koboSpan" id="kobo.418.4">Building a queue of data and using locks to synchronize in a concurrent access environment is an option here. </span><span class="koboSpan" id="kobo.418.5">Due to the concurrent access nature of this design, locks or mutexes or something similar has to be used to prevent errors. </span><span class="koboSpan" id="kobo.418.6">However, locks and mutexes are extremely inefficient and lead to context switches, which degrade performance tremendously for critical threads. </span><span class="koboSpan" id="kobo.418.7">So, what we need is a lock-free queue to facilitate communication </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.419.1">between threads without the overhead of locks and context switches. </span><span class="koboSpan" id="kobo.419.2">Note that the lock-free queue we will build here is only to be used for </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">Single Producer Single Consumer</span></strong><span class="koboSpan" id="kobo.421.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.422.1">SPSC</span></strong><span class="koboSpan" id="kobo.423.1">) – that is, only one thread writes to the queue and only one thread consumes from the queue. </span><span class="koboSpan" id="kobo.423.2">More complex use cases for lock-free queues will require additional complexity, which is out of the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">this book.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.425.1">Designing lock-free queue storage</span></h2>
<p><span class="koboSpan" id="kobo.426.1">For lock-free queues, we again have the option of either having the storage allocated on the stack or the </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.427.1">heap. </span><span class="koboSpan" id="kobo.427.2">Here, we will again choose </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">std::vector</span></strong><span class="koboSpan" id="kobo.429.1"> and allocate memory on the heap. </span><span class="koboSpan" id="kobo.429.2">Additionally, we create two </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">std::atomic</span></strong><span class="koboSpan" id="kobo.431.1"> variables – one called </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">next_write_index_</span></strong><span class="koboSpan" id="kobo.433.1"> – to track what index the next write to the queue will </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">go to.</span></span></p>
<p><span class="koboSpan" id="kobo.435.1">The second variable, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">next_read_index_</span></strong><span class="koboSpan" id="kobo.437.1">, is used to track what index the next unread element in the queue is located in. </span><span class="koboSpan" id="kobo.437.2">The implementation is relatively straightforward because of our assumption that a single thread writes to the queue and a single thread reads from it. </span><span class="koboSpan" id="kobo.437.3">Now, let us first design and implement the internal storage of the lock-free queue data structure. </span><span class="koboSpan" id="kobo.437.4">The source code discussed in this section can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">Chapter4/lf_queue.h</span></strong><span class="koboSpan" id="kobo.439.1"> source file in the GitHub repository for </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">A quick word on </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">std::atomic</span></strong><span class="koboSpan" id="kobo.443.1"> – it is a modern C++ construct that allows thread-safe operations. </span><span class="koboSpan" id="kobo.443.2">It lets us </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.444.1">read, update, and write variables on a shared variable without using locks or mutexes, and it does so while preserving the order of operations. </span><span class="koboSpan" id="kobo.444.2">A detailed discussion of </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">std::atomic</span></strong><span class="koboSpan" id="kobo.446.1"> and memory ordering is outside the scope of this book, but you can find a reference in our other book </span><em class="italic"><span class="koboSpan" id="kobo.447.1">Developing High-Frequency </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.448.1">Trading Systems</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">First, let us define the data members for this class in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.452.1">
#pragma once
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;atomic&gt;
namespace Common {
  template&lt;typename T&gt;
  class LFQueue final {
  private:
    std::vector&lt;T&gt; store_;
    std::atomic&lt;size_t&gt; next_write_index_ = {0};
    std::atomic&lt;size_t&gt; next_read_index_ = {0};
    std::atomic&lt;size_t&gt; num_elements_ = {0};
  };
}</span></pre>
<p><span class="koboSpan" id="kobo.453.1">This class holds a </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">std::vector</span></strong><span class="koboSpan" id="kobo.455.1"> object </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">store_</span></strong><span class="koboSpan" id="kobo.457.1"> of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">T</span></strong><span class="koboSpan" id="kobo.459.1"> template object type, which is the actual queue of data. </span><span class="koboSpan" id="kobo.459.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">std::atomic&lt;size_t&gt; next_write_index_</span></strong><span class="koboSpan" id="kobo.461.1"> variable </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.462.1">tracks the index in this vector, where the next element will be written to. </span><span class="koboSpan" id="kobo.462.2">Similarly, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">std::atomic&lt;size_t&gt; next_read_index_</span></strong><span class="koboSpan" id="kobo.464.1"> variable tracks the index in this vector, where the next element to be read or consumed is available. </span><span class="koboSpan" id="kobo.464.2">These need to be the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">std::atomic&lt;&gt;</span></strong><span class="koboSpan" id="kobo.466.1"> type, since the reading and writing operations are performed from </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">different threads.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.468.1">Initializing the lock-free queue</span></h2>
<p><span class="koboSpan" id="kobo.469.1">The constructor </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.470.1">for our lock-free queue is very similar to the constructor of the memory pool we saw earlier. </span><span class="koboSpan" id="kobo.470.2">We dynamically allocate the memory for the entire vector in the constructor. </span><span class="koboSpan" id="kobo.470.3">We can extend this design to allow the lock-free queue to be resized at runtime, but for now, we will stick to a </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">fixed-size queue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.472.1">
template&lt;typename T&gt;
class LFQueue final {
public:
  LFQueue(std::size_t num_elems) :
      store_(num_elems, T()) /* pre-allocation of vector
        storage. </span><span class="koboSpan" id="kobo.472.2">*/ {
  }</span></pre>
<p><span class="koboSpan" id="kobo.473.1">We have similar boilerplate code here with regards to the default constructor, copy and move constructors, and </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.474.1">assignment operators. </span><span class="koboSpan" id="kobo.474.2">These are deleted for the reasons we </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">discussed before:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.476.1">
  LFQueue() = delete;
  LFQueue(const LFQueue&amp;) = delete;
  LFQueue(const LFQueue&amp;&amp;) = delete;
  LFQueue&amp; operator=(const LFQueue&amp;) = delete;
  LFQueue&amp; operator=(const LFQueue&amp;&amp;) = delete;</span></pre>
<p><span class="koboSpan" id="kobo.477.1">Next, we will look at the code to add new elements to </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">the queue.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.479.1">Adding elements to the queue</span></h2>
<p><span class="koboSpan" id="kobo.480.1">The code to add </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.481.1">new elements to the queue is implemented in two parts; the first part, </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">getNextToWriteTo()</span></strong><span class="koboSpan" id="kobo.483.1">, returns a pointer to the next element to write new data to. </span><span class="koboSpan" id="kobo.483.2">The second part, </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">updateWriteIndex()</span></strong><span class="koboSpan" id="kobo.485.1">, increments the write index, </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">next_write_index_</span></strong><span class="koboSpan" id="kobo.487.1">, once the element has been written to the slot provided. </span><span class="koboSpan" id="kobo.487.2">We designed it in such a way that, instead of having a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">write()</span></strong><span class="koboSpan" id="kobo.489.1"> function, we provide the user with a pointer to the element and if the objects are quite large then not all of it needs to be updated or overwritten. </span><span class="koboSpan" id="kobo.489.2">Additionally, this design makes it much easier to deal with </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">race conditions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.491.1">
  auto getNextToWriteTo() noexcept {
    return &amp;store_[next_write_index_];
  }
  auto updateWriteIndex() noexcept {
      next_write_index_ = (next_write_index_ + 1) %
        store_.size();
      num_elements_++;
  }</span></pre>
<p><span class="koboSpan" id="kobo.492.1">In the next section, we </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.493.1">will use a very similar design to consume elements from </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">the queue.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.495.1">Consuming elements from the queue</span></h2>
<p><span class="koboSpan" id="kobo.496.1">To consume elements </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.497.1">from the queue, we do the opposite of what we did to add elements to the queue. </span><span class="koboSpan" id="kobo.497.2">Like the design we have where we split </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">write()</span></strong><span class="koboSpan" id="kobo.499.1"> into two parts, we will have two parts to consume an element from the queue. </span><span class="koboSpan" id="kobo.499.2">We have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">getNextToRead()</span></strong><span class="koboSpan" id="kobo.501.1"> method that returns a pointer to the next element to be consumed but does not update the read index. </span><span class="koboSpan" id="kobo.501.2">This method will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">nullptr</span></strong><span class="koboSpan" id="kobo.503.1"> if there is no element to be consumed. </span><span class="koboSpan" id="kobo.503.2">The second part, </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">updateReadIndex()</span></strong><span class="koboSpan" id="kobo.505.1">, just updates the read index after the element </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">is consumed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.507.1">
  auto getNextToRead() const noexcept -&gt; const T * {
    return (next_read_index_ == next_write_index_) ?
</span><span class="koboSpan" id="kobo.507.2">      nullptr : &amp;store_[next_read_index_];
  }
  auto updateReadIndex() noexcept {
      next_read_index_ = (next_read_index_ + 1) %
        store_.size();
      ASSERT(num_elements_ != 0, "Read an invalid element
        in:" + std::to_string(pthread_self()));
      num_elements_--;
  }</span></pre>
<p><span class="koboSpan" id="kobo.508.1">We also define another simple method to return the number of elements in </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">the queue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.510.1">
    auto size() const noexcept {
      return num_elements_.load();
    }</span></pre>
<p><span class="koboSpan" id="kobo.511.1">wThis finishes our </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.512.1">design and implementation of lock-free queues for the SPSC use case. </span><span class="koboSpan" id="kobo.512.2">Let us look at an example that uses this component in the </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">next sub-section.</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.514.1">Using the lock-free queue</span></h2>
<p><span class="koboSpan" id="kobo.515.1">This example of </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.516.1">how to use the lock-free data queue can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">Chapter4/lf_queue_example.cpp</span></strong><span class="koboSpan" id="kobo.518.1"> file and built as previously mentioned. </span><span class="koboSpan" id="kobo.518.2">This example creates a consumer thread and provides it with a lock-free queue instance. </span><span class="koboSpan" id="kobo.518.3">The producer then generates and adds some elements to that queue, and the consumer thread checks the queue and consumes the queue elements till the queue is empty. </span><span class="koboSpan" id="kobo.518.4">Both threads of execution – producer and consumer – wait for short periods of time between generating an element and </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">consuming it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.520.1">
#include "thread_utils.h"
#include "lf_queue.h"
struct MyStruct {
  int d_[3];
};
using namespace Common;
auto consumeFunction(LFQueue&lt;MyStruct&gt;* lfq) {
  using namespace std::literals::chrono_literals;
  std::this_thread::sleep_for(5s);
  while(lfq-&gt;size()) {
    const auto d = lfq-&gt;getNextToRead();
    lfq-&gt;updateReadIndex();
    std::cout &lt;&lt; "consumeFunction read elem:" &lt;&lt; d-&gt;d_[0]
      &lt;&lt; "," &lt;&lt; d-&gt;d_[1] &lt;&lt; "," &lt;&lt; d-&gt;d_[2] &lt;&lt; " lfq-size:"
        &lt;&lt;lfq-&gt;size() &lt;&lt; std::endl;
    std::this_thread::sleep_for(1s);
  }
  std::cout &lt;&lt; "consumeFunction exiting." </span><span class="koboSpan" id="kobo.520.2">&lt;&lt; std::endl;
}
int main(int, char **) {
  LFQueue&lt;MyStruct&gt; lfq(20);
  auto ct = createAndStartThread(-1, "", consumeFunction,
    &amp;lfq);
  for(auto i = 0; i &lt; 50; ++i) {
    const MyStruct d{i, i * 10, i * 100};
    *(lfq.getNextToWriteTo()) = d;
    lfq.updateWriteIndex();
    std::cout &lt;&lt; "main constructed elem:" &lt;&lt; d.d_[0] &lt;&lt; ","
      &lt;&lt; d.d_[1] &lt;&lt; "," &lt;&lt; d.d_[2] &lt;&lt; " lfq-size:" &lt;&lt;
        lfq.size() &lt;&lt; std::endl;
    using namespace std::literals::chrono_literals;
    std::this_thread::sleep_for(1s);
  }
  ct-&gt;join();
  std::cout &lt;&lt; "main exiting." </span><span class="koboSpan" id="kobo.520.3">&lt;&lt; std::endl;
  return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.521.1">The output of </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.522.1">running this example program is provided as follows, which is just the producer and the consumer writing to and reading from the </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">lock-free queue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.524.1">
(base) sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter4$ ./cmake-build-release/lf_queue_example
Set core affinity for  139710770276096 to -1
main constructed elem:0,0,0 lfq-size:1
main constructed elem:1,10,100 lfq-size:2
main constructed elem:2,20,200 lfq-size:3
main constructed elem:3,30,300 lfq-size:4
consumeFunction read elem:0,0,0 lfq-size:3
main constructed elem:4,40,400 lfq-size:4
consumeFunction read elem:1,10,100 lfq-size:3
main constructed elem:5,50,500 lfq-size:4
consumeFunction read elem:2,20,200 lfq-size:3
main constructed elem:6,60,600 lfq-size:4
consumeFunction read elem:3,30,300 lfq-size:3
main constructed elem:7,70,700 lfq-size:4
consumeFunction read elem:4,40,400 lfq-size:3
...</span></pre>
<p><span class="koboSpan" id="kobo.525.1">Next, we will build a </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.526.1">low latency logging framework using some of the components we just built – threads and </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">lock-free queues.</span></span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.528.1">Building a low latency logging framework</span></h1>
<p><span class="koboSpan" id="kobo.529.1">Now, we will build a low latency logging framework using some of the components we just built in the </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.530.1">previous sections. </span><span class="koboSpan" id="kobo.530.2">Logging is an important part of any application, whether it is logging general application behavior, warnings, errors, or even performance statistics. </span><span class="koboSpan" id="kobo.530.3">However, a lot of important logging output is actually from performance-critical components that are on a </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">critical path.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">A naïve logging approach would be to output to the screen, while</span><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.533.1"> a slightly better approach would be for logs to be saved to one or more log files. </span><span class="koboSpan" id="kobo.533.2">However, here we have a few problems – disk I/O is extremely slow and unpredictable, and string operations and formatting themselves are slow. </span><span class="koboSpan" id="kobo.533.3">For these reasons, performing these operations on a performance-critical thread is a terrible idea, so we will build a solution in this section to alleviate the downsides while preserving the ability to output logs </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">as needed.</span></span></p>
<p><span class="koboSpan" id="kobo.535.1">Before we jump into the logger class, we will define a few utility methods to fetch the current system time as well as convert them to strings for </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">logging purposes.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.537.1">Designing utility methods for time</span></h2>
<p><span class="koboSpan" id="kobo.538.1">We will define </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.539.1">a simple utility function to fetch the current system time and some constants to make conversions from different units easier. </span><span class="koboSpan" id="kobo.539.2">The code for the time utilities can be found in </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">Chapter4/time_utils.h</span></strong><span class="koboSpan" id="kobo.541.1"> in the GitHub repository for </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">this book:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.543.1">
#pragma once
#include &lt;chrono&gt;
#include &lt;ctime&gt;
namespace Common {
  typedef int64_t Nanos;
  constexpr Nanos NANOS_TO_MICROS = 1000;
  constexpr Nanos MICROS_TO_MILLIS = 1000;
  constexpr Nanos MILLIS_TO_SECS = 1000;
  constexpr Nanos NANOS_TO_MILLIS = NANO_TO_MICROS *
    MICROS_TO_MILLIS;
  constexpr Nanos NANOS_TO_SECS = NANOS_TO_MILLIS *
    MILLIS_TO_SECS;
  inline auto getCurrentNanos() noexcept {
    return std::chrono::duration_cast
      &lt;std::chrono::nanoseconds&gt;(std::chrono::
        system_clock::now().time_since_epoch()).count();
  }
  inline auto&amp; getCurrentTimeStr(std::string* time_str) {
    const auto time = std::chrono::system_clock::
      to_time_t(std::chrono::system_clock::now());
    time_str-&gt;assign(ctime(&amp;time));
    if(!time_str-&gt;empty())
      time_str-&gt;at(time_str-&gt;length()-1) = '\0';
    return *time_str;
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.544.1">Now, let us </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.545.1">design the logger class itself, starting with the </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">next section.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.547.1">Designing the low latency logger</span></h2>
<p><span class="koboSpan" id="kobo.548.1">To build this low latency logging framework, we will create a background logging thread whose only task is to </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.549.1">write log lines to a log file on disk. </span><span class="koboSpan" id="kobo.549.2">The idea here is to offload the slow disk I/O operations as well as the string formatting operations away from the main performance-critical thread onto this background thread. </span><span class="koboSpan" id="kobo.549.3">One thing to understand is that logging to disk does not have to be instantaneous – that is, most systems can tolerate some delay between an event happening and information pertinent to that event being logged to disk. </span><span class="koboSpan" id="kobo.549.4">We will use the multi-threading function we created in the first section of this chapter to create this logger thread and assign it the task of writing to the </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">log file.</span></span></p>
<p><span class="koboSpan" id="kobo.551.1">To publish data that needs to be logged from the main performance-critical thread to this logging thread, we will use the lock-free data queue we created in the previous section. </span><span class="koboSpan" id="kobo.551.2">The way the logger will work is that instead of writing information directly to the disk, the performance-sensitive threads will simply push the information to this lock-free queue. </span><span class="koboSpan" id="kobo.551.3">As we discussed before, a logger thread will consume from the other end of this queue and write to the disk. </span><span class="koboSpan" id="kobo.551.4">The source code for this component is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">logging.h</span></strong><span class="koboSpan" id="kobo.553.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">logging.cpp</span></strong><span class="koboSpan" id="kobo.555.1"> files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">Chapter4</span></strong><span class="koboSpan" id="kobo.557.1"> directory in the GitHub repository for </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">this book.</span></span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.559.1">Defining some logger structures</span></h2>
<p><span class="koboSpan" id="kobo.560.1">Before we start designing the logger itself, we will first define the basic block of information that </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.561.1">will be transferred across the lock-free queue from the performance-sensitive thread to the logger thread. </span><span class="koboSpan" id="kobo.561.2">In this design, we simply create a structure capable of holding the different types that we will log. </span><span class="koboSpan" id="kobo.561.3">First, let us define an enumeration that specifies the type of value the structure it is pointing to; we will call this </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">enumeration </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">LogType</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.565.1">
#pragma once
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;cstdio&gt;
#include "types.h"
#include "macros.h"
#include "lf_queue.h"
#include "thread_utils.h"
#include "time_utils.h"
namespace Common {
constexpr size_t LOG_QUEUE_SIZE = 8 * 1024 * 1024;
enum class LogType : int8_t {
  CHAR = 0,
  INTEGER = 1, LONG_INTEGER = 2, LONG_LONG_INTEGER = 3,
  UNSIGNED_INTEGER = 4, UNSIGNED_LONG_INTEGER = 5,
  UNSIGNED_LONG_LONG_INTEGER = 6,
  FLOAT = 7, DOUBLE = 8
};
}</span></pre>
<p><span class="koboSpan" id="kobo.566.1">Now, we can define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">LogElement</span></strong><span class="koboSpan" id="kobo.568.1"> structure that will hold the next value to push to the queue and, eventually, </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.569.1">write logs to the file from the logger thread. </span><span class="koboSpan" id="kobo.569.2">This structure contains a member of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">LogType</span></strong><span class="koboSpan" id="kobo.571.1"> to specify the type of value it holds. </span><span class="koboSpan" id="kobo.571.2">The other member in this structure is a union of the different possible primitive types. </span><span class="koboSpan" id="kobo.571.3">This would have been a good place to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">std::variant</span></strong><span class="koboSpan" id="kobo.573.1">, since it is a type-safe union in modern C++ with the </span><strong class="bold"><span class="koboSpan" id="kobo.574.1">discriminator</span></strong><span class="koboSpan" id="kobo.575.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">LogType type_</span></strong><span class="koboSpan" id="kobo.577.1">, which specifies what the union contains) built into it. </span><span class="koboSpan" id="kobo.577.2">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">std::variant</span></strong><span class="koboSpan" id="kobo.579.1"> has worse runtime performance; hence, we choose to move forward with the old-style </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">union here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.581.1">
struct LogElement {
  LogType type_ = LogType::CHAR;
  union {
    char c;
    int i; long l; long long ll;
    unsigned u; unsigned long ul; unsigned long long ull;
    float f; double d;
  } u_;
};</span></pre>
<p><span class="koboSpan" id="kobo.582.1">With the definition </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.583.1">of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">LogElement</span></strong><span class="koboSpan" id="kobo.585.1"> structure out of the way, let us move on to defining data in the </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">logger class.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.587.1">Initializing the logger data structures</span></h2>
<p><span class="koboSpan" id="kobo.588.1">Our logger will </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.589.1">contain a few important objects. </span><span class="koboSpan" id="kobo.589.2">Firstly, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">std::ofstream</span></strong><span class="koboSpan" id="kobo.591.1"> file object is the log file that data is written to. </span><span class="koboSpan" id="kobo.591.2">Secondly, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">LFQueue&lt;LogElement&gt;</span></strong><span class="koboSpan" id="kobo.593.1"> object is the lock-free queue to transfer data from the main thread to the logger thread. </span><span class="koboSpan" id="kobo.593.2">Next, </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">std::atomic&lt;bool&gt;</span></strong><span class="koboSpan" id="kobo.595.1"> stops the logger thread’s processing when needed, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">std::thread</span></strong><span class="koboSpan" id="kobo.597.1"> object which is the logger thread. </span><span class="koboSpan" id="kobo.597.2">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">std::string</span></strong><span class="koboSpan" id="kobo.599.1"> is the filename, which we provide purely for </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">informational purposes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.601.1">
class Logger final {
private:
  const std::string file_name_;
  std::ofstream file_;
  LFQueue&lt;LogElement&gt; queue_;
  std::atomic&lt;bool&gt; running_ = {true};
  std::thread *logger_thread_ = nullptr;
};</span></pre>
<p><span class="koboSpan" id="kobo.602.1">Now, let us move </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.603.1">on to constructing our logger, the logger queue, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">logger thread.</span></span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.605.1">Creating the logger and launching the logger thread</span></h2>
<p><span class="koboSpan" id="kobo.606.1">In the logger constructor, we will initialize the logger queue with an appropriate size, save </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">file_name_</span></strong><span class="koboSpan" id="kobo.608.1"> for </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.609.1">informational purposes, open the output log file object, and create and </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.610.1">launch the logger thread. </span><span class="koboSpan" id="kobo.610.2">Note that here </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.611.1">we will exit if we are unable to open the output log file or unable to </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.612.1">create and launch the logger thread. </span><span class="koboSpan" id="kobo.612.2">As we’ve mentioned before, there are obviously more forgiving and more graceful ways to handle these failures, but we will not explore those in this book. </span><span class="koboSpan" id="kobo.612.3">Note here that we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">core_id</span></strong><span class="koboSpan" id="kobo.614.1"> parameter in </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">createAndStartThread()</span></strong><span class="koboSpan" id="kobo.616.1"> to –1, to not set affinity on the thread right now. </span><span class="koboSpan" id="kobo.616.2">We will revisit the design of how to assign each thread to a CPU core later in the book once we understand the design of the full ecosystem, and we will tune it </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">for performance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.618.1">
  explicit Logger(const std::string &amp;file_name)
      : file_name_(file_name), queue_(LOG_QUEUE_SIZE) {
    file_.open(file_name);
    ASSERT(file_.is_open(), "Could not open log file:" +
      file_name);
    logger_thread_ = createAndStartThread(-1,
      "Common/Logger", [this]() { flushQueue(); });
    ASSERT(logger_thread_ != nullptr, "Failed to start
      Logger thread.");
  }</span></pre>
<p><span class="koboSpan" id="kobo.619.1">We pass a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">flushQueue()</span></strong><span class="koboSpan" id="kobo.621.1"> that this logger thread will run. </span><span class="koboSpan" id="kobo.621.2">As the name suggests, and in line with what we discussed, this thread will empty the queue of log data and write the data to the file; we will look at that next. </span><span class="koboSpan" id="kobo.621.3">The implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">flushQueue()</span></strong><span class="koboSpan" id="kobo.623.1"> is simple. </span><span class="koboSpan" id="kobo.623.2">If the atomic </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">running_</span></strong><span class="koboSpan" id="kobo.625.1"> Boolean is </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">true</span></strong><span class="koboSpan" id="kobo.627.1">, it runs in a loop, performing the following steps: it consumes any new elements pushed to the lock-free queue, </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">queue_</span></strong><span class="koboSpan" id="kobo.629.1">, and writes them to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">file_</span></strong><span class="koboSpan" id="kobo.631.1"> object we created. </span><span class="koboSpan" id="kobo.631.2">It unpacks the </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">LogElement</span></strong><span class="koboSpan" id="kobo.633.1"> objects in </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.634.1">the queue and writes the correct member of the union to </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.635.1">the file, depending on the type. </span><span class="koboSpan" id="kobo.635.2">The thread sleeps for </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.636.1">a millisecond when the lock-free queue is empty and then </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.637.1">checks again to see whether there are new elements to be written </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">to disk:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.639.1">
  auto flushQueue() noexcept {
    while (running_) {
      for (auto next = queue_.getNextToRead();
        queue_.size() &amp;&amp; next; next = queue_
          .getNextToRead()) {
        switch (next-&gt;type_) {
          case LogType::CHAR: file_ &lt;&lt; next-&gt;u_.c; break;
          case LogType::INTEGER: file_ &lt;&lt; next-&gt;u_.i; break;
          case LogType::LONG_INTEGER: file_ &lt;&lt; next-&gt;u_.l; break;
          case LogType::LONG_LONG_INTEGER: file_ &lt;&lt; next-&gt;
             u_.ll; break;
          case LogType::UNSIGNED_INTEGER: file_ &lt;&lt; next-&gt;
             u_.u; break;
          case LogType::UNSIGNED_LONG_INTEGER: file_ &lt;&lt;
             next-&gt;u_.ul; break;
          case LogType::UNSIGNED_LONG_LONG_INTEGER: file_
              &lt;&lt; next-&gt;u_.ull; break;
          case LogType::FLOAT: file_ &lt;&lt; next-&gt;u_.f; break;
          case LogType::DOUBLE: file_ &lt;&lt; next-&gt;u_.d; break;
        }
        queue_.updateReadIndex();
        next = queue_.getNextToRead();
      }
      using namespace std::literals::chrono_literals;
      std::this_thread::sleep_for(1ms);
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.640.1">The destructor for our logger class is important, so let us look at what cleanup tasks it needs to perform. </span><span class="koboSpan" id="kobo.640.2">First, the </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.641.1">destructor waits for the lock-free queue to be consumed by </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.642.1">the logger thread, so it waits till it is empty. </span><span class="koboSpan" id="kobo.642.2">Once it is </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.643.1">empty, it sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">running_</span></strong><span class="koboSpan" id="kobo.645.1"> flag to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">false</span></strong><span class="koboSpan" id="kobo.647.1"> so that </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.648.1">the logger thread can finish its execution. </span><span class="koboSpan" id="kobo.648.2">To wait for the logger thread to finish execution – that is, return from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">flushQueue()</span></strong><span class="koboSpan" id="kobo.650.1"> method, it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">std::thread::join()</span></strong><span class="koboSpan" id="kobo.652.1"> method on the logger thread. </span><span class="koboSpan" id="kobo.652.2">Finally, it closes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">file_</span></strong><span class="koboSpan" id="kobo.654.1"> object, which writes any buffered data onto the disk, and then we </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">are done:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.656.1">
  ~Logger() {
    std::cerr &lt;&lt; "Flushing and closing Logger for " &lt;&lt;
      file_name_ &lt;&lt; std::endl;
    while (queue_.size()) {
      using namespace std::literals::chrono_literals;
      std::this_thread::sleep_for(1s);
    }
    running_ = false;
    logger_thread_-&gt;join();
    file_.close();
  }</span></pre>
<p><span class="koboSpan" id="kobo.657.1">Finally, we will add the usual boilerplate code we discussed multiple times before regarding the constructors and </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">assignment operators:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.659.1">
  Logger() = delete;
  Logger(const Logger &amp;) = delete;
  Logger(const Logger &amp;&amp;) = delete;
  Logger &amp;operator=(const Logger &amp;) = delete;
  Logger &amp;operator=(const Logger &amp;&amp;) = delete;</span></pre>
<p><span class="koboSpan" id="kobo.660.1">In this section, we </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.661.1">saw the portion of the component that consumes from the </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.662.1">queue and writes it to disk. </span><span class="koboSpan" id="kobo.662.2">In the next section, we will see </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.663.1">how data gets added to the lock-free queue as part of the </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.664.1">logging process from the </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">performance-critical thread.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.666.1">Pushing data to the logger queue</span></h2>
<p><span class="koboSpan" id="kobo.667.1">To push data to the lo</span><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.668.1">gger queue, we will define a couple of overloaded </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">pushValue()</span></strong><span class="koboSpan" id="kobo.670.1"> methods that </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.671.1">handle different types of arguments. </span><span class="koboSpan" id="kobo.671.2">Each method does the same thing, which is to push values one by one onto the queue. </span><span class="koboSpan" id="kobo.671.3">One thing worthy of note here is that there are more efficient implementations for what we are about to discuss; however, they involve additional complexity, and we left them out for the sake of brevity and to limit the scope of what we can cover in this book. </span><span class="koboSpan" id="kobo.671.4">We will point out the areas of potential improvement when we </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">discuss them.</span></span></p>
<p><span class="koboSpan" id="kobo.673.1">First, we create a variant of </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">pushValue()</span></strong><span class="koboSpan" id="kobo.675.1"> to push objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">LogElement</span></strong><span class="koboSpan" id="kobo.677.1">, which will get called from the other </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">pushValue()</span></strong><span class="koboSpan" id="kobo.679.1"> functions we will define shortly. </span><span class="koboSpan" id="kobo.679.2">It basically writes to the next location in the lock-free queue and increments the </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">write index:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.681.1">
  auto pushValue(const LogElement &amp;log_element) noexcept {
    *(queue_.getNextToWriteTo()) = log_element;
    queue_.updateWriteIndex();
  }</span></pre>
<p><span class="koboSpan" id="kobo.682.1">The next simple variant of </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">pushValue()</span></strong><span class="koboSpan" id="kobo.684.1"> is for a single char value, which basically just creates an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">LogElement</span></strong><span class="koboSpan" id="kobo.686.1">, calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">pushValue()</span></strong><span class="koboSpan" id="kobo.688.1"> method we just discussed, and passes the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">LogElement</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.690.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.691.1">
  auto pushValue(const char value) noexcept {
    pushValue(LogElement{LogType::CHAR, {.c = value}});
  }</span></pre>
<p><span class="koboSpan" id="kobo.692.1">Now, we create a variant of </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">pushValue()</span></strong><span class="koboSpan" id="kobo.694.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">const char*</span></strong><span class="koboSpan" id="kobo.696.1"> – that is, a collection of chars. </span><span class="koboSpan" id="kobo.696.2">This implementation </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.697.1">loops through the characters one at a time and calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">pushValue()</span></strong><span class="koboSpan" id="kobo.699.1"> we implemented previously. </span><span class="koboSpan" id="kobo.699.2">This is an area of potential improvement, where we could use a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">memcpy()</span></strong><span class="koboSpan" id="kobo.701.1"> to copy over all the characters in the array instead of looping through them. </span><span class="koboSpan" id="kobo.701.2">There are some edge cases we would need to handle around the wrapping of the indices at the end of the queue, but we will leave it up to you to </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">explore further:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.703.1">
  auto pushValue(const char *value) noexcept {
    while (*value) {
      pushValue(*value);
      ++value;
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.704.1">Next, we create another variant of </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">pushValue()</span></strong><span class="koboSpan" id="kobo.706.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">const std::string&amp;</span></strong><span class="koboSpan" id="kobo.708.1">, which is quite straightforward and uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">pushValue()</span></strong><span class="koboSpan" id="kobo.710.1">, which we </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">created previously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.712.1">
  auto pushValue(const std::string &amp;value) noexcept {
    pushValue(value.c_str());
  }</span></pre>
<p><span class="koboSpan" id="kobo.713.1">Finally, we need to add variants of </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">pushValue()</span></strong><span class="koboSpan" id="kobo.715.1"> for the different primitive types. </span><span class="koboSpan" id="kobo.715.2">They are very similar to the one we built for a single char value and are </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.717.1">
  auto pushValue(const int value) noexcept {
    pushValue(LogElement{LogType::INTEGER, {.i = value}});
  }
  auto pushValue(const long value) noexcept {
    pushValue(LogElement{LogType::LONG_INTEGER, {.l =
      value}});
  }
  auto pushValue(const long long value) noexcept {
    pushValue(LogElement{LogType::LONG_LONG_INTEGER, {.ll =
      value}});
  }
  auto pushValue(const unsigned value) noexcept {
    pushValue(LogElement{LogType::UNSIGNED_INTEGER, {.u =
      value}});
  }
  auto pushValue(const unsigned long value) noexcept {
    pushValue(LogElement{LogType::UNSIGNED_LONG_INTEGER,
      {.ul = value}});
  }
  auto pushValue(const unsigned long long value) noexcept {
    pushValue(LogElement{LogType::UNSIGNED_LONG_LONG_INTEGER,
  {.ull = value}});
  }
  auto pushValue(const float value) noexcept {
    pushValue(LogElement{LogType::FLOAT, {.f = value}});
  }
  auto pushValue(const double value) noexcept {
    pushValue(LogElement{LogType::DOUBLE, {.d = value}});
  }</span></pre>
<p><span class="koboSpan" id="kobo.718.1">At this point, we have </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.719.1">achieved two goals – moved the disk output operation to the background logger thread and moved the task of formatting the primitive values into string format to the background thread. </span><span class="koboSpan" id="kobo.719.2">Next, we will add functionality for the performance-sensitive thread to use to push data to the lock-free queue, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">pushValue()</span></strong><span class="koboSpan" id="kobo.721.1"> methods we </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">just built.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.723.1">Adding a useful and generic log function</span></h2>
<p><span class="koboSpan" id="kobo.724.1">We will define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">log()</span></strong><span class="koboSpan" id="kobo.726.1"> method, which is very similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">printf()</span></strong><span class="koboSpan" id="kobo.728.1"> function but slightly simpler. </span><span class="koboSpan" id="kobo.728.2">It is simpler </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.729.1">in the sense that the format specifier is just a </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">%</span></strong><span class="koboSpan" id="kobo.731.1"> character that is used to substitute all the different primitive types. </span><span class="koboSpan" id="kobo.731.2">This method uses variadic template arguments to support an arbitrary number and types of arguments. </span><span class="koboSpan" id="kobo.731.3">It looks for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">%</span></strong><span class="koboSpan" id="kobo.733.1"> character and then substitutes the next value in its place, calling one of the overloaded </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">pushValue()</span></strong><span class="koboSpan" id="kobo.735.1"> methods we defined in the last section. </span><span class="koboSpan" id="kobo.735.2">After that, it calls itself recursively, except this time, the value points to the first argument in the template </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">parameter pack:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.737.1">
  template&lt;typename T, typename... </span><span class="koboSpan" id="kobo.737.2">A&gt;
  auto log(const char *s, const T &amp;value, A... </span><span class="koboSpan" id="kobo.737.3">args)
  noexcept {
    while (*s) {
      if (*s == '%') {
        if (UNLIKELY(*(s + 1) == '%')) {
          ++s;
        } else {
          pushValue(value);
          log(s + 1, args...);
          return;
        }
      }
      pushValue(*s++);
    }
    FATAL("extra arguments provided to log()");
  }</span></pre>
<p><span class="koboSpan" id="kobo.738.1">This method is meant to be called using something like </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">this example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.740.1">
int int_val = 10;
std::string str_val = "hello";
double dbl_val = 10.10;
log("Integer:% String:% Double:%",
  int_val, str_val, dbl_val);</span></pre>
<p><span class="koboSpan" id="kobo.741.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">log()</span></strong><span class="koboSpan" id="kobo.743.1"> method we </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.744.1">built here cannot handle a case where there are no arguments passed to it. </span><span class="koboSpan" id="kobo.744.2">Therefore, we need an extra overloaded </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">log()</span></strong><span class="koboSpan" id="kobo.746.1"> method to handle the case, where a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">const char *</span></strong><span class="koboSpan" id="kobo.748.1"> is passed to it. </span><span class="koboSpan" id="kobo.748.2">We add an extra check here to make sure that extra arguments were not passed to this method or the aforementioned </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">log()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.750.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.751.1">
  auto log(const char *s) noexcept {
    while (*s) {
      if (*s == '%') {
        if (UNLIKELY(*(s + 1) == '%')) {
          ++s;
        } else {
          FATAL("missing arguments to log()");
        }
      }
      pushValue(*s++);
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.752.1">This finishes the design and implementation of our low latency logging framework. </span><span class="koboSpan" id="kobo.752.2">Using our multi-threading </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.753.1">routine and our lock-free queue, we created a framework where the performance-critical thread offloads the string formatting and disk file write tasks to the background logger thread. </span><span class="koboSpan" id="kobo.753.2">Now, let us look at a good example of how to create, configure, and use the logger we </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">just created.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.755.1">Learning how to use the logger with an example</span></h2>
<p><span class="koboSpan" id="kobo.756.1">We will present a basic example </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.757.1">that creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">Logger</span></strong><span class="koboSpan" id="kobo.759.1"> object and configures it to write the logs to </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">logging_example.log</span></strong><span class="koboSpan" id="kobo.761.1">. </span><span class="koboSpan" id="kobo.761.2">Then, it logs a few different data types to the file through the logger. </span><span class="koboSpan" id="kobo.761.3">This source for this can be found in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">Chapter4/logging_example.cpp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.763.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.764.1">
#include "logging.h"
int main(int, char **) {
  using namespace Common;
  char c = 'd';
  int i = 3;
  unsigned long ul = 65;
  float f = 3.4;
  double d = 34.56;
  const char* s = "test C-string";
  std::string ss = "test string";
  Logger logger("logging_example.log");
  logger.log("Logging a char:% an int:% and an
    unsigned:%\n", c, i, ul);
  logger.log("Logging a float:% and a double:%\n", f, d);
  logger.log("Logging a C-string:'%'\n", s);
  logger.log("Logging a string:'%'\n", ss);
  return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.765.1">The output of running this can be viewed by outputting the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">logging_example.log</span></strong><span class="koboSpan" id="kobo.767.1"> file in the current directory, as </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.769.1">
(base) sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter4$ cat logging_example.log
Logging a char:d an int:3 and an unsigned:65
Logging a float:3.4 and a double:34.56
Logging a C-string:'test C-string'
Logging a string:'test string'</span></pre>
<p><span class="koboSpan" id="kobo.770.1">In this framework, the only overhead that a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">log()</span></strong><span class="koboSpan" id="kobo.772.1"> invokes is the overhead of iterating through the </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.773.1">characters in the string and pushing the characters and values onto the lock-free queue. </span><span class="koboSpan" id="kobo.773.2">Now, we will move our discussion to network programming and the use of sockets, which we will be using later on to facilitate communication between </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">different processes.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.775.1">C++ network programming using sockets</span></h1>
<p><span class="koboSpan" id="kobo.776.1">In this final section, we will build the last of our basic building blocks – a framework to handle network </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.777.1">programming using Unix sockets. </span><span class="koboSpan" id="kobo.777.2">We </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.778.1">will use this framework to build a server that listens for incoming TCP connections and a client that is capable of establishing a TCP connection to such a server. </span><span class="koboSpan" id="kobo.778.2">We will also use this framework to publish UDP traffic and consume from a stream of multicast traffic. </span><span class="koboSpan" id="kobo.778.3">Note that to limit the </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.779.1">scope of this discussion, we will only </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.780.1">discuss Unix sockets without any kernel bypass capabilities. </span><span class="koboSpan" id="kobo.780.2">Using kernel </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.781.1">bypass and leveraging the kernel bypass API provided by the </span><strong class="bold"><span class="koboSpan" id="kobo.782.1">Network Interface Cards</span></strong><span class="koboSpan" id="kobo.783.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.784.1">NICs</span></strong><span class="koboSpan" id="kobo.785.1">) that support it is outside the scope of this book. </span><span class="koboSpan" id="kobo.785.2">Note also that we expect you to have some basic knowledge or experience with network sockets and, ideally, programming network sockets </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">in C++.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.787.1">Building a basic socket API</span></h2>
<p><span class="koboSpan" id="kobo.788.1">Our goal here is to create a mechanism to create a network socket and initialize it with the correct </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.789.1">parameters. </span><span class="koboSpan" id="kobo.789.2">This method will be used to create listener, receiver, and sender sockets to communicate over UDP and TCP protocols. </span><span class="koboSpan" id="kobo.789.3">Before we jump into the routine that creates the socket itself, let us first define a bunch of utility methods that we will use in our final method. </span><span class="koboSpan" id="kobo.789.4">All the code for the basic socket API is in </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">Chapter4/socket_utils.cpp</span></strong><span class="koboSpan" id="kobo.791.1"> in the GitHub repository for this book. </span><span class="koboSpan" id="kobo.791.2">Note that before we investigate the implementation of the functionality, we will present the </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">Chapter4/socket_utils.h</span></strong><span class="koboSpan" id="kobo.793.1"> header file, which contains all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">include</span></strong><span class="koboSpan" id="kobo.795.1"> files and function signatures we </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">will implement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.797.1">
#pragma once
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;
#include &lt;sys/epoll.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/tcp.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;ifaddrs.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;fcntl.h&gt;
#include "macros.h"
#include "logging.h"
namespace Common {
  constexpr int MaxTCPServerBacklog = 1024;
  auto getIfaceIP(const std::string &amp;iface) -&gt; std::string;
  auto setNonBlocking(int fd) -&gt; bool;
  auto setNoDelay(int fd) -&gt; bool;
  auto setSOTimestamp(int fd) -&gt; bool;
  auto wouldBlock() -&gt; bool;
  auto setMcastTTL(int fd, int ttl) -&gt; bool;
  auto setTTL(int fd, int ttl) -&gt; bool;
  auto join(int fd, const std::string &amp;ip, const
    std::string &amp;iface, int port) -&gt; bool;
  auto createSocket(Logger &amp;logger, const std::string
    &amp;t_ip, const std::string &amp;iface, int port, bool is_udp,
       bool is_blocking, bool is_listening, int ttl, bool
         needs_so_timestamp) -&gt; int;
}</span></pre>
<p><span class="koboSpan" id="kobo.798.1">Now, let us start </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.799.1">with the implementation of these methods, starting with the </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">next section.</span></span></p>
<h3><span class="koboSpan" id="kobo.801.1">Getting interface information</span></h3>
<p><span class="koboSpan" id="kobo.802.1">The first utility </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.803.1">method we need to build is to convert network interfaces represented in string form to a form that can be used by the lower-level socket routines we will use. </span><span class="koboSpan" id="kobo.803.2">We call this </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">getIfaceIP()</span></strong><span class="koboSpan" id="kobo.805.1">, and we will need this when we specify what network interfaces to listen to, connect from, or send through. </span><span class="koboSpan" id="kobo.805.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">getifaddrs()</span></strong><span class="koboSpan" id="kobo.807.1"> method to fetch information about all the interfaces, which returns a linked list structure, </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">ifaddrs</span></strong><span class="koboSpan" id="kobo.809.1">, containing this information. </span><span class="koboSpan" id="kobo.809.2">Finally, it uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">getnameinfo()</span></strong><span class="koboSpan" id="kobo.811.1"> information to get the final name to be used with the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">the methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.813.1">
#include "socket_utils.h"
namespace Common {
  auto getIfaceIP(const std::string &amp;iface) -&gt; std::string {
    char buf[NI_MAXHOST] = {'\0'};
    ifaddrs *ifaddr = nullptr;
    if (getifaddrs(&amp;ifaddr) != -1) {
      for (ifaddrs *ifa = ifaddr; ifa; ifa = ifa-&gt;ifa_next) {
        if (ifa-&gt;ifa_addr &amp;&amp; ifa-&gt;ifa_addr-&gt;sa_family ==
          AF_INET &amp;&amp; iface == ifa-&gt;ifa_name) {
          getnameinfo(ifa-&gt;ifa_addr, sizeof(sockaddr_in),
            buf, sizeof(buf), NULL, 0, NI_NUMERICHOST);
          break;
        }
      }
      freeifaddrs(ifaddr);
    }
    return buf;
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.814.1">For instance, on my system with the following network interfaces, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.816.1">
lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
wlp4s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 192.168.10.104  netmask 255.255.255.0  broadcast 192.168.10.255</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">getIfaceIP</span></strong><span class="koboSpan" id="kobo.818.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">"lo"</span></strong><span class="koboSpan" id="kobo.820.1">) returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">127.0.0.1</span></strong><span class="koboSpan" id="kobo.822.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">getIfaceIP</span></strong><span class="koboSpan" id="kobo.824.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">"wlp4s0"</span></strong><span class="koboSpan" id="kobo.826.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">192.168.10.104</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.830.1">Next, we will move on to </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.831.1">the next important utility function we need, and this one affects the performance of applications that need </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">network sockets.</span></span></p>
<h3><span class="koboSpan" id="kobo.833.1">Setting sockets to be non-blocking</span></h3>
<p><span class="koboSpan" id="kobo.834.1">The next utility function we will build is one that sets sockets as non-blocking. </span><span class="koboSpan" id="kobo.834.2">A blocking socket is one </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.835.1">where a call that is read on it will block indefinitely till data is available. </span><span class="koboSpan" id="kobo.835.2">This is generally not a good design for extremely low latency applications for many reasons. </span><span class="koboSpan" id="kobo.835.3">One of the main reasons is that blocking sockets are implemented using switches between the user space and the kernel space, and that is highly inefficient. </span><span class="koboSpan" id="kobo.835.4">When the socket needs to be </span><em class="italic"><span class="koboSpan" id="kobo.836.1">woken up</span></em><span class="koboSpan" id="kobo.837.1"> or unblocked, there needs to be an interrupt, an interrupt handler, and so on from the kernel space to the user space to handle the event. </span><span class="koboSpan" id="kobo.837.2">Additionally, the performance-critical thread that gets blocked would incur context-switching costs, which, as already discussed, are detrimental </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">to performance.</span></span></p>
<p><span class="koboSpan" id="kobo.839.1">The following </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">setNonBlocking()</span></strong><span class="koboSpan" id="kobo.841.1"> method uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">fcntl()</span></strong><span class="koboSpan" id="kobo.843.1"> routine with </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">F_GETFL</span></strong><span class="koboSpan" id="kobo.845.1"> to first check a socket file descriptor, seeing whether it is already non-blocking. </span><span class="koboSpan" id="kobo.845.2">If it is not already non-blocking, then it uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">fcntl()</span></strong><span class="koboSpan" id="kobo.847.1"> routine again but this time with </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">F_SETFL</span></strong><span class="koboSpan" id="kobo.849.1"> to add the non-blocking bit, which is set on the file descriptor. </span><span class="koboSpan" id="kobo.849.2">It returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">true</span></strong><span class="koboSpan" id="kobo.851.1"> if the socket file descriptor was already non-blocking or the method was able to successfully make </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">it non-blocking:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.853.1">
auto setNonBlocking(int fd) -&gt; bool {
  const auto flags = fcntl(fd, F_GETFL, 0);
  if (flags == -1)
    return false;
  if (flags &amp; O_NONBLOCK)
    return true;
  return (fcntl(fd, F_SETFL, flags | O_NONBLOCK) != -1);
}</span></pre>
<p><span class="koboSpan" id="kobo.854.1">Next, we will enable another </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.855.1">important optimization for TCP sockets by disabling </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.856.1">Nagle’s algorithm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.858.1">Disabling Nagle’s algorithm</span></h3>
<p><span class="koboSpan" id="kobo.859.1">Without diving into </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.860.1">too many details, Nagle’s algorithm is used to improve </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.861.1">buffering in TCP sockets and prevent overhead associated with guaranteeing reliability on the TCP socket. </span><span class="koboSpan" id="kobo.861.2">This is achieved by delaying some packets instead of sending them out immediately. </span><span class="koboSpan" id="kobo.861.3">For many applications, it is a good feature to have, but for low latency applications, disabling the latency associated with sending packets out </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">is imperative.</span></span></p>
<p><span class="koboSpan" id="kobo.863.1">Fortunately, disabling Nagle’s algorithm is a simple matter of setting a socket option, </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">TCP_NODELAY</span></strong><span class="koboSpan" id="kobo.865.1">, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">setsockopt()</span></strong><span class="koboSpan" id="kobo.867.1"> routine, as </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.869.1">
auto setNoDelay(int fd) -&gt; bool {
  int one = 1;
  return (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,
    reinterpret_cast&lt;void *&gt;(&amp;one), sizeof(one)) != -1);
}</span></pre>
<p><span class="koboSpan" id="kobo.870.1">We will define </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.871.1">a few more routines to set optional and/or additional functionality in the next section, before we finally implement the functionality to create </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">a socket.</span></span></p>
<h3><span class="koboSpan" id="kobo.873.1">Setting up additional parameters</span></h3>
<p><span class="koboSpan" id="kobo.874.1">First, we will </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.875.1">define a simple method to check whether a socket operation would block or not. </span><span class="koboSpan" id="kobo.875.2">This is a simple check of the global </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">errno</span></strong><span class="koboSpan" id="kobo.877.1"> error variable against two possible values, </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">EWOULDBLOCK</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.879.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">EINPROGRESS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.882.1">
auto wouldBlock() -&gt; bool {
  return (errno == EWOULDBLOCK || errno == EINPROGRESS);
}</span></pre>
<p><span class="koboSpan" id="kobo.883.1">Next, we define a method </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.884.1">to set the </span><strong class="bold"><span class="koboSpan" id="kobo.885.1">Time to Live</span></strong><span class="koboSpan" id="kobo.886.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.887.1">TTL</span></strong><span class="koboSpan" id="kobo.888.1">) value on our sockets. </span><span class="koboSpan" id="kobo.888.2">TTL is a network-level setting that controls the maximum number of hops that a packet can take from sender to receiver. </span><span class="koboSpan" id="kobo.888.3">We might not really need to use this, depending on the setup of our application, but it is provided here if required. </span><span class="koboSpan" id="kobo.888.4">Fortunately, again, all we need to do is set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">IP_TTL</span></strong><span class="koboSpan" id="kobo.890.1"> socket options for non-multicast sockets and </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">IP_MULTICAST_TTL</span></strong><span class="koboSpan" id="kobo.892.1"> for multicast sockets, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">setsockopt()</span></strong><span class="koboSpan" id="kobo.894.1"> routine, as </span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.896.1">
auto setTTL(int fd, int ttl) -&gt; bool {
  return (setsockopt(fd, IPPROTO_IP, IP_TTL,
    reinterpret_cast&lt;void *&gt;(&amp;ttl), sizeof(ttl)) != -1);
}
auto setMcastTTL(int fd, int mcast_ttl) noexcept -&gt; bool {
  return (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL,
    reinterpret_cast&lt;void *&gt;(&amp;mcast_ttl), sizeof
      (mcast_ttl)) != -1);
}</span></pre>
<p><span class="koboSpan" id="kobo.897.1">Finally, we define one last method that will allow us to generate software timestamps when network packets hit the network socket. </span><span class="koboSpan" id="kobo.897.2">Note that if we had specialized hardware (NICs) that support hardware timestamping, we would enable and use those here. </span><span class="koboSpan" id="kobo.897.3">However, to limit the scope of this book, we will assume that you do not have any special hardware and can only set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">SO_TIMESTAMP</span></strong><span class="koboSpan" id="kobo.899.1"> option, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">setsockopt()</span></strong><span class="koboSpan" id="kobo.901.1"> method, to enable </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">software timestamping:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.903.1">
  auto setSOTimestamp(int fd) -&gt; bool {
    int one = 1;
    return (setsockopt(fd, SOL_SOCKET, SO_TIMESTAMP,
      reinterpret_cast&lt;void *&gt;(&amp;one), sizeof(one)) != -1);
  }</span></pre>
<p><span class="koboSpan" id="kobo.904.1">This completes our discussion of socket-related utility </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.905.1">functions, and now, we can move on to finally implementing the functionality to create generic </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">Unix sockets.</span></span></p>
<h3><span class="koboSpan" id="kobo.907.1">Creating the socket</span></h3>
<p><span class="koboSpan" id="kobo.908.1">In the first section of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">createSocket()</span></strong><span class="koboSpan" id="kobo.910.1"> method, we first check whether a non-empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">t_ip</span></strong><span class="koboSpan" id="kobo.912.1"> has been </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.913.1">provided, which represents the interface IP, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">192.168.10.104</span></strong><span class="koboSpan" id="kobo.915.1">, and if not, we fetch one from the interface name provided using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">getIfaceIP()</span></strong><span class="koboSpan" id="kobo.917.1"> method we built previously. </span><span class="koboSpan" id="kobo.917.2">We also need to populate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">addrinfo</span></strong><span class="koboSpan" id="kobo.919.1"> struct, based on the arguments passed in, because we will need to pass it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">getaddrinfo()</span></strong><span class="koboSpan" id="kobo.921.1"> routine, which will return a linked list that will finally be used to build the actual socket. </span><span class="koboSpan" id="kobo.921.2">Note that in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">createSocket()</span></strong><span class="koboSpan" id="kobo.923.1"> method, anytime we fail to create the socket or initialize it with the correct parameters, we return –1 to signify </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">the failure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.925.1">
  auto createSocket(Logger &amp;logger, const std::string
    &amp;t_ip, const std::string &amp;iface, int port,
                    bool is_udp, bool is_blocking, bool
                      is_listening, int ttl, bool
                        needs_so_timestamp) -&gt; int {
    std::string time_str;
    const auto ip = t_ip.empty() ? </span><span class="koboSpan" id="kobo.925.2">getIfaceIP(iface) :
      t_ip;
    logger.log("%:% %() % ip:% iface:% port:% is_udp:%
      is_blocking:% is_listening:% ttl:% SO_time:%\n",
        __FILE__, __LINE__, __FUNCTION__,
               Common::getCurrentTimeStr(&amp;time_str), ip,
                 iface, port, is_udp, is_blocking,
                   is_listening, ttl, needs_so_timestamp);
    addrinfo hints{};
    hints.ai_family = AF_INET;
    hints.ai_socktype = is_udp ? </span><span class="koboSpan" id="kobo.925.3">SOCK_DGRAM : SOCK_STREAM;
    hints.ai_protocol = is_udp ? </span><span class="koboSpan" id="kobo.925.4">IPPROTO_UDP : IPPROTO_TCP;
    hints.ai_flags = is_listening ? </span><span class="koboSpan" id="kobo.925.5">AI_PASSIVE : 0;
    if (std::isdigit(ip.c_str()[0]))
      hints.ai_flags |= AI_NUMERICHOST;
    hints.ai_flags |= AI_NUMERICSERV;
    addrinfo *result = nullptr;
    const auto rc = getaddrinfo(ip.c_str(), std::
      to_string(port).c_str(), &amp;hints, &amp;result);
    if (rc) {
      logger.log("getaddrinfo() failed. </span><span class="koboSpan" id="kobo.925.6">error:% errno:%\n",
        gai_strerror(rc), strerror(errno));
      return -1;
    }</span></pre>
<p><span class="koboSpan" id="kobo.926.1">The next section then checks the parameters passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">createSocket()</span></strong><span class="koboSpan" id="kobo.928.1"> method and uses </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.929.1">all the methods we built previously to set the correct socket parameters as needed. </span><span class="koboSpan" id="kobo.929.2">Note that we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">addrinfo *</span></strong><span class="koboSpan" id="kobo.931.1"> result object returned from </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">getaddrinfo()</span></strong><span class="koboSpan" id="kobo.933.1"> to create the socket through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">socket()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.935.1"> routine.</span></span></p>
<p><span class="koboSpan" id="kobo.936.1">First, we make the actual function call to create </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">the socket:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.938.1">
  int fd = -1;
  int one = 1;
  for (addrinfo *rp = result; rp; rp = rp-&gt;ai_next) {
    fd = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, rp
      -&gt;ai_protocol);
    if (fd == -1) {
      logger.log("socket() failed. </span><span class="koboSpan" id="kobo.938.2">errno:%\n",
         strerror(errno));
      return -1;
    }</span></pre>
<p><span class="koboSpan" id="kobo.939.1">Next, we set it to be non-blocking and disable Nagle’s algorithm using the methods we </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">defined previously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.941.1">
    if (!is_blocking) {
      if (!setNonBlocking(fd)) {
        logger.log("setNonBlocking() failed. </span><span class="koboSpan" id="kobo.941.2">errno:%\n",
          strerror(errno));
        return -1;
      }
      if (!is_udp &amp;&amp; !setNoDelay(fd)) {
        logger.log("setNoDelay() failed. </span><span class="koboSpan" id="kobo.941.3">errno:%\n",
          strerror(errno));
        return -1;
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.942.1">Next, we connect the socket </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.943.1">to the target address if it is not a </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">listening socket:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.945.1">
    if (!is_listening &amp;&amp; connect(fd, rp-&gt;ai_addr, rp
      -&gt;ai_addrlen) == 1 &amp;&amp; !wouldBlock()) {
      logger.log("connect() failed. </span><span class="koboSpan" id="kobo.945.2">errno:%\n",
        strerror(errno));
      return -1;
    }</span></pre>
<p><span class="koboSpan" id="kobo.946.1">Then, if we want to create a socket that listens for incoming connections, we set the correct parameters and bind the socket to a specific address that the client will try to connect to. </span><span class="koboSpan" id="kobo.946.2">We also need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">listen()</span></strong><span class="koboSpan" id="kobo.948.1"> routine for such a socket configuration. </span><span class="koboSpan" id="kobo.948.2">Note that we reference a </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">MaxTCPServerBacklog</span></strong><span class="koboSpan" id="kobo.950.1"> parameter here, which is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.952.1">
constexpr int MaxTCPServerBacklog = 1024;</span></pre>
<p><span class="koboSpan" id="kobo.953.1">Now, let us look at </span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.954.1">the code to make the socket a </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">listening socket:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.956.1">
    if (is_listening &amp;&amp; setsockopt(fd, SOL_SOCKET,
      SO_REUSEADDR, reinterpret_cast&lt;const char *&gt;(&amp;one),
        sizeof(one)) == -1) {
      logger.log("setsockopt() SO_REUSEADDR failed.
</span><span class="koboSpan" id="kobo.956.2">        errno:%\n", strerror(errno));
      return -1;
    }
    if (is_listening &amp;&amp; bind(fd, rp-&gt;ai_addr, rp-&gt;
      ai_addrlen) == -1) {
      logger.log("bind() failed. </span><span class="koboSpan" id="kobo.956.3">errno:%\n",
        strerror(errno));
      return -1;
    }
    if (!is_udp &amp;&amp; is_listening &amp;&amp; listen(fd,
      MaxTCPServerBacklog) == -1) {
      logger.log("listen() failed. </span><span class="koboSpan" id="kobo.956.4">errno:%\n",
        strerror(errno));
      return -1;
    }</span></pre>
<p><span class="koboSpan" id="kobo.957.1">Finally, we set the TTL value for the socket we just created and return the socket. </span><span class="koboSpan" id="kobo.957.2">We will also set the ability to fetch </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.958.1">the data receipt timestamps from incoming packets using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">setSOTimestamp()</span></strong><span class="koboSpan" id="kobo.960.1"> method we </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">created before:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.962.1">
    if (is_udp &amp;&amp; ttl) {
      const bool is_multicast = atoi(ip.c_str()) &amp; 0xe0;
      if (is_multicast &amp;&amp; !setMcastTTL(fd, ttl)) {
        logger.log("setMcastTTL() failed. </span><span class="koboSpan" id="kobo.962.2">errno:%\n",
          strerror(errno));
        return -1;
      }
      if (!is_multicast &amp;&amp; !setTTL(fd, ttl)) {
        logger.log("setTTL() failed. </span><span class="koboSpan" id="kobo.962.3">errno:%\n",
          strerror(errno));
        return -1;
      }
    }
      if (needs_so_timestamp &amp;&amp; !setSOTimestamp(fd)) {
        logger.log("setSOTimestamp() failed. </span><span class="koboSpan" id="kobo.962.4">errno:%\n",
          strerror(errno));
        return -1;
      }
  }
  if (result)
    freeaddrinfo(result);
  return fd;
}</span></pre>
<p><span class="koboSpan" id="kobo.963.1">Now that we have discussed and implemented the details of our lower-level socket method, we can </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.964.1">move on to the next section and build a slightly higher-level abstraction that builds on top of </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">this method.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.966.1">Implementing a sender/receiver TCP socket</span></h2>
<p><span class="koboSpan" id="kobo.967.1">Now that we </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.968.1">have finished our design and implementation of basic methods to create sockets and set different parameters on them, we can start using them. </span><span class="koboSpan" id="kobo.968.2">First, we will implement a </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.970.1"> structure that builds on top of the socket utilities we created in the previous section. </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.972.1"> can be used to both send and receive data, so it will be used both within TCP socket servers </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">and clients.</span></span></p>
<h3><span class="koboSpan" id="kobo.974.1">Defining the data members of the TCP socket</span></h3>
<p><span class="koboSpan" id="kobo.975.1">Let us jump into our implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.977.1"> structure, starting with the data members we need. </span><span class="koboSpan" id="kobo.977.2">Since </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.978.1">this socket will be used to send and receive data, we will create two buffers – one to store data to be sent out and one to store data that was just read in. </span><span class="koboSpan" id="kobo.978.2">We will also store the file descriptor corresponding to our TCP socket in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">fd_</span></strong><span class="koboSpan" id="kobo.980.1"> variable. </span><span class="koboSpan" id="kobo.980.2">We also create two flags: one to track if the send socket is connected and another to check whether the receive socket is connected. </span><span class="koboSpan" id="kobo.980.3">We will also save a reference to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">Logger</span></strong><span class="koboSpan" id="kobo.982.1"> object, purely for logging purposes. </span><span class="koboSpan" id="kobo.982.2">Finally, we will store a </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">std::function</span></strong><span class="koboSpan" id="kobo.984.1"> object, which we will use to dispatch callbacks to components that want to read data from this socket when there is new data available to be consumed. </span><span class="koboSpan" id="kobo.984.2">The code for this section is in </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">Chapter4/tcp_socket.h</span></strong><span class="koboSpan" id="kobo.986.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">Chapter4/tcp_socket.cpp</span></strong><span class="koboSpan" id="kobo.988.1"> in the GitHub repository for </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">this book:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.990.1">
#pragma once
#include &lt;functional&gt;
#include "socket_utils.h"
#include "logging.h"
namespace Common {
  constexpr size_t TCPBufferSize = 64 * 1024 * 1024;
  struct TCPSocket {
    int fd_ = -1;
    char *send_buffer_ = nullptr;
    size_t next_send_valid_index_ = 0;
    char *rcv_buffer_ = nullptr;
    size_t next_rcv_valid_index_ = 0;
    bool send_disconnected_ = false;
    bool recv_disconnected_ = false;
    struct sockaddr_in inInAddr;
    std::function&lt;void(TCPSocket *s, Nanos rx_time)&gt;
      recv_callback_;
    std::string time_str_;
    Logger &amp;logger_;
  };
}</span></pre>
<p><span class="koboSpan" id="kobo.991.1">We define a default r</span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.992.1">eceive callback we will use to initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">recv_callback_</span></strong><span class="koboSpan" id="kobo.994.1"> data member. </span><span class="koboSpan" id="kobo.994.2">This method simply logs information that confirms that the callback </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">was invoked:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.996.1">
    auto defaultRecvCallback(TCPSocket *socket, Nanos
      rx_time) noexcept {
      logger_.log("%:% %() %
        TCPSocket::defaultRecvCallback() socket:% len:%
          rx:%\n", __FILE__, __LINE__, __FUNCTION__,
                  Common::getCurrentTimeStr(&amp;time_str_),
                    socket-&gt;fd_, socket-&gt;
                      next_rcv_valid_index_, rx_time);
    }</span></pre>
<p><span class="koboSpan" id="kobo.997.1">Next, let us look at the constructor for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">TCPSocket</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.999.1"> structure.</span></span></p>
<h3><span class="koboSpan" id="kobo.1000.1">Constructing and destroying the TCP socket</span></h3>
<p><span class="koboSpan" id="kobo.1001.1">For the constructor, we </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.1002.1">will create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">send_buffer_</span></strong><span class="koboSpan" id="kobo.1004.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">rcv_buffer_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">char *</span></strong><span class="koboSpan" id="kobo.1007.1"> storage on the heap and assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">defaultRecvCallback()</span></strong><span class="koboSpan" id="kobo.1009.1"> method </span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.1010.1">to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">recv_callback_</span></strong><span class="koboSpan" id="kobo.1012.1"> member variable through a lambda method. </span><span class="koboSpan" id="kobo.1012.2">Note that we set the socket’s receive and send buffers to be of size </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">TCPBufferSize</span></strong><span class="koboSpan" id="kobo.1014.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1">defined here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1016.1">
constexpr size_t TCPBufferSize = 64 * 1024 * 1024;
    explicit TCPSocket(Logger &amp;logger)
        : logger_(logger) {
      send_buffer_ = new char[TCPBufferSize];
      rcv_buffer_ = new char[TCPBufferSize];
      recv_callback_ = [this](auto socket, auto rx_time) {
        defaultRecvCallback(socket, rx_time); };
    }</span></pre>
<p><span class="koboSpan" id="kobo.1017.1">We then create </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">destroy()</span></strong><span class="koboSpan" id="kobo.1019.1"> and a destructor to perform straightforward cleanup tasks. </span><span class="koboSpan" id="kobo.1019.2">We will </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.1020.1">close the socket file descriptor and </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.1021.1">destroy the receive and send buffers we created in </span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">the constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1023.1">
  auto TCPSocket::destroy() noexcept -&gt; void {
    close(fd_);
    fd_ = -1;
  }
  ~TCPSocket() {
    destroy();
    delete[] send_buffer_; send_buffer_ = nullptr;
    delete[] rcv_buffer_; rcv_buffer_ = nullptr;
  }</span></pre>
<p><span class="koboSpan" id="kobo.1024.1">We define the boilerplate code we saw previously to prevent accidental or unintentional constructions, copies, </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">or assignments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1026.1">
  // Deleted default, copy &amp; move constructors and
    assignment-operators.
</span><span class="koboSpan" id="kobo.1026.2">  TCPSocket() = delete;
  TCPSocket(const TCPSocket &amp;) = delete;
  TCPSocket(const TCPSocket &amp;&amp;) = delete;
  TCPSocket &amp;operator=(const TCPSocket &amp;) = delete;
  TCPSocket &amp;operator=(const TCPSocket &amp;&amp;) = delete;</span></pre>
<p><span class="koboSpan" id="kobo.1027.1">Next, let us try to </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.1028.1">perform one key operation on this </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.1029.1">socket – establishing </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">TCP connections.</span></span></p>
<h3><span class="koboSpan" id="kobo.1031.1">Establishing TCP connections</span></h3>
<p><span class="koboSpan" id="kobo.1032.1">For this structure, we </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.1033.1">will define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">connect()</span></strong><span class="koboSpan" id="kobo.1035.1"> method, which is basically what creates, initializes, and connects </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1037.1">. </span><span class="koboSpan" id="kobo.1037.2">We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">createSocket()</span></strong><span class="koboSpan" id="kobo.1039.1"> method we created in the previous section with the correct parameters to </span><span class="No-Break"><span class="koboSpan" id="kobo.1040.1">achieve this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1041.1">
  auto TCPSocket::connect(const std::string &amp;ip, const
    std::string &amp;iface, int port, bool is_listening) -&gt;
      int {
    destroy();
    fd_ = createSocket(logger_, ip, iface, port, false,
      false, is_listening, 0, true);
    inInAddr.sin_addr.s_addr = INADDR_ANY;
    inInAddr.sin_port = htons(port);
    inInAddr.sin_family = AF_INET;
    return fd_;
  }</span></pre>
<p><span class="koboSpan" id="kobo.1042.1">Next, we will move on to the next critical functionality in our socket – sending and </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">receiving data.</span></span></p>
<h3><span class="koboSpan" id="kobo.1044.1">Sending and receiving data</span></h3>
<p><span class="koboSpan" id="kobo.1045.1">We mentioned in our </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.1046.1">discussion that when new data is available, the interested listener will be notified </span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.1047.1">through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">recv_callback_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">std::function</span></strong><span class="koboSpan" id="kobo.1050.1"> mechanism. </span><span class="koboSpan" id="kobo.1050.2">Therefore, we just need to provide a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">send()</span></strong><span class="koboSpan" id="kobo.1052.1"> method for the users of this structure to send data out. </span><span class="koboSpan" id="kobo.1052.2">Note that this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">send()</span></strong><span class="koboSpan" id="kobo.1054.1"> method simply copies the provided data into the outgoing buffer, and the actual write to the wire will be done in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">sendAndRecv()</span></strong><span class="koboSpan" id="kobo.1056.1"> method we will </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">see shortly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1058.1">
  auto TCPSocket::send(const void *data, size_t len)
    noexcept -&gt; void {
    if (len &gt; 0) {
      memcpy(send_buffer_ + next_send_valid_index_, data,
        len);
      next_send_valid_index_ += len;
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.1059.1">Finally, we have the </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.1060.1">most important method for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1062.1"> structure, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">sendAndRecv()</span></strong><span class="koboSpan" id="kobo.1064.1">, which reads available data into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">rcv_buffer_</span></strong><span class="koboSpan" id="kobo.1066.1">, increments </span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.1067.1">the counters, and dispatches </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">recv_callback_</span></strong><span class="koboSpan" id="kobo.1069.1"> if there is some amount of data that was read. </span><span class="koboSpan" id="kobo.1069.2">The second half of this method does the opposite – it tries to write out data in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">send_buffer_</span></strong><span class="koboSpan" id="kobo.1071.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">send()</span></strong><span class="koboSpan" id="kobo.1073.1"> routine and updates the index </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">tracker variables:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1075.1">
  auto TCPSocket::sendAndRecv() noexcept -&gt; bool {
    char ctrl[CMSG_SPACE(sizeof(struct timeval))];
    struct cmsghdr *cmsg = (struct cmsghdr *) &amp;ctrl;
    struct iovec iov;
    iov.iov_base = rcv_buffer_ + next_rcv_valid_index_;
    iov.iov_len = TCPBufferSize - next_rcv_valid_index_;
    msghdr msg;
    msg.msg_control = ctrl;
    msg.msg_controllen = sizeof(ctrl);
    msg.msg_name = &amp;inInAddr;
    msg.msg_namelen = sizeof(inInAddr);
    msg.msg_iov = &amp;iov;
    msg.msg_iovlen = 1;
    const auto n_rcv = recvmsg(fd_, &amp;msg, MSG_DONTWAIT);
    if (n_rcv &gt; 0) {
      next_rcv_valid_index_ += n_rcv;
      Nanos kernel_time = 0;
      struct timeval time_kernel;
      if (cmsg-&gt;cmsg_level == SOL_SOCKET &amp;&amp;
          cmsg-&gt;cmsg_type == SCM_TIMESTAMP &amp;&amp;
          cmsg-&gt;cmsg_len == CMSG_LEN(sizeof(time_kernel))) {
        memcpy(&amp;time_kernel, CMSG_DATA(cmsg),
          sizeof(time_kernel));
        kernel_time = time_kernel.tv_sec * NANOS_TO_SECS +
          time_kernel.tv_usec * NANOS_TO_MICROS;
      }
      const auto user_time = getCurrentNanos();
      logger_.log("%:% %() % read socket:% len:% utime:%
        ktime:% diff:%\n", __FILE__, __LINE__,
          __FUNCTION__,
                  Common::getCurrentTimeStr(&amp;time_str_),
                    fd_, next_rcv_valid_index_, user_time,
                      kernel_time, (user_time -
                        kernel_time));
      recv_callback_(this, kernel_time);
    }
    ssize_t n_send = std::min(TCPBufferSize,
      next_send_valid_index_);
    while (n_send &gt; 0) {
      auto n_send_this_msg = std::min(static_cast&lt;ssize_t&gt;
        (next_send_valid_index_), n_send);
      const int flags = MSG_DONTWAIT | MSG_NOSIGNAL |
         (n_send_this_msg &lt; n_send ? </span><span class="koboSpan" id="kobo.1075.2">MSG_MORE : 0);
      auto n = ::send(fd_, send_buffer_, n_send_this_msg,
        flags);
      if (UNLIKELY(n &lt; 0)) {
        if (!wouldBlock())
          send_disconnected_ = true;
        break;
      }
      logger_.log("%:% %() % send socket:% len:%\n",
        __FILE__, __LINE__, __FUNCTION__,
          Common::getCurrentTimeStr(&amp;time_str_), fd_, n);
      n_send -= n;
      ASSERT(n == n_send_this_msg, "Don't support partial
        send lengths yet.");
    }
    next_send_valid_index_ = 0;
    return (n_rcv &gt; 0);
  }</span></pre>
<p><span class="koboSpan" id="kobo.1076.1">This concludes </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.1077.1">our discussion of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1079.1"> class. </span><span class="koboSpan" id="kobo.1079.2">Next, we </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.1080.1">will build a class that encapsulates and manages </span><strong class="source-inline"><span class="koboSpan" id="kobo.1081.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1082.1"> objects. </span><span class="koboSpan" id="kobo.1082.2">It will be used to implement functionality for TCP servers in components that act </span><span class="No-Break"><span class="koboSpan" id="kobo.1083.1">as servers.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.1084.1">Building a TCP server component</span></h2>
<p><span class="koboSpan" id="kobo.1085.1">We built a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1087.1"> class in the previous section that can be used by components that need to </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.1088.1">connect to TCP connections and send as well as receive data. </span><span class="koboSpan" id="kobo.1088.2">In this section, we will build a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1090.1"> component that manages several such </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1092.1"> objects internally. </span><span class="koboSpan" id="kobo.1092.2">It also manages tasks, such as listening for, accepting, and tracking new incoming connections and sending and receiving data on this collection of sockets. </span><span class="koboSpan" id="kobo.1092.3">All the source code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1094.1"> component is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">Chapter4/tcp_server.h</span></strong><span class="koboSpan" id="kobo.1096.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">Chapter4/tcp_server.cpp</span></strong><span class="koboSpan" id="kobo.1098.1"> files in the GitHub repository for </span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1">this book.</span></span></p>
<h3><span class="koboSpan" id="kobo.1100.1">Defining the data members of the TCP server</span></h3>
<p><span class="koboSpan" id="kobo.1101.1">First, we will </span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.1102.1">define and describe the data members that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1104.1"> class will contain. </span><span class="koboSpan" id="kobo.1104.2">It needs a file descriptor, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">efd_</span></strong><span class="koboSpan" id="kobo.1106.1">, and a corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">TCPSocket listener_socket_</span></strong><span class="koboSpan" id="kobo.1108.1"> to represent the socket on which it will be listening for new incoming connections from clients. </span><span class="koboSpan" id="kobo.1108.2">It maintains an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">epoll_event events_</span></strong><span class="koboSpan" id="kobo.1110.1">, which will be used to monitor the listening socket file descriptor, along with socket descriptors for connected clients. </span><span class="koboSpan" id="kobo.1110.2">It will have a few </span><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">std::vectors</span></strong><span class="koboSpan" id="kobo.1112.1"> of socket objects – sockets that we expect to receive data from, sockets we expect to send data on, and sockets that are disconnected. </span><span class="koboSpan" id="kobo.1112.2">We will see how these are </span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">used shortly.</span></span></p>
<p><span class="koboSpan" id="kobo.1114.1">This class has two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">std::function</span></strong><span class="koboSpan" id="kobo.1116.1"> objects – one used to dispatch callbacks when new data is received and another one that is dispatched after all callbacks in the current round of polling the sockets are completed. </span><span class="koboSpan" id="kobo.1116.2">To explain this better, we will first use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">epoll</span></strong><span class="koboSpan" id="kobo.1118.1"> call to find all the sockets that have data to read, dispatch </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">recv_callback_</span></strong><span class="koboSpan" id="kobo.1120.1"> for each socket that has data, and finally, when all sockets have been notified, dispatch </span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">recv_finished_callback_</span></strong><span class="koboSpan" id="kobo.1122.1">. </span><span class="koboSpan" id="kobo.1122.2">One more thing to note here is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">recv_callback_</span></strong><span class="koboSpan" id="kobo.1124.1"> provides </span><strong class="source-inline"><span class="koboSpan" id="kobo.1125.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1126.1"> on which the data was received, as well as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">Nanos rx_time</span></strong><span class="koboSpan" id="kobo.1128.1"> to specify the software receive time of the data on that socket. </span><span class="koboSpan" id="kobo.1128.2">The receive timestamps </span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.1129.1">are used to process the TCP packets in the exact order in which they were received, since the TCP server monitors and reads from many different client </span><span class="No-Break"><span class="koboSpan" id="kobo.1130.1">TCP sockets:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1131.1">
#pragma once
#include "tcp_socket.h"
namespace Common {
  struct TCPServer {
  public:
    int efd_ = -1;
    TCPSocket listener_socket_;
    epoll_event events_[1024];
    std::vector&lt;TCPSocket *&gt; sockets_, receive_sockets_,
      send_sockets_, disconnected_sockets_;
    std::function&lt;void(TCPSocket *s, Nanos rx_time)&gt;
      recv_callback_;
    std::function&lt;void()&gt; recv_finished_callback_;
    std::string time_str_;
    Logger &amp;logger_;
  };
}</span></pre>
<p><span class="koboSpan" id="kobo.1132.1">In the next section, we </span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.1133.1">will look at the code to initialize these fields and de-initialize the </span><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">TCP server.</span></span></p>
<h3><span class="koboSpan" id="kobo.1135.1">Initializing and destroying the TCP server</span></h3>
<p><span class="koboSpan" id="kobo.1136.1">The constructor </span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.1137.1">for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1139.1"> is straightforward – it initializes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">listener_socket_</span></strong><span class="koboSpan" id="kobo.1141.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">logger_</span></strong><span class="koboSpan" id="kobo.1143.1"> and sets the default callback </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.1144.1">receivers, as we did </span><span class="No-Break"><span class="koboSpan" id="kobo.1145.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">TCPSocket</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1147.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1148.1">
    explicit TCPServer(Logger &amp;logger)
        : listener_socket_(logger), logger_(logger) {
      recv_callback_ = [this](auto socket, auto rx_time) {
        defaultRecvCallback(socket, rx_time); };
      recv_finished_callback_ = [this]() {
        defaultRecvFinishedCallback(); };
    }</span></pre>
<p><span class="koboSpan" id="kobo.1149.1">We define the default receive callback methods here, which do not do anything except log that the callback was received. </span><span class="koboSpan" id="kobo.1149.2">These are placeholders anyway, since we will set different ones in </span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">real applications:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1151.1">
    auto defaultRecvCallback(TCPSocket *socket, Nanos
      rx_time) noexcept {
      logger_.log("%:% %() %
        TCPServer::defaultRecvCallback() socket:% len:%
          rx:%\n", __FILE__, __LINE__, __FUNCTION__,
            Common::getCurrentTimeStr(&amp;time_str_), socket-&gt;
              fd_, socket-&gt;next_rcv_valid_index_, rx_time);
    }
    auto defaultRecvFinishedCallback() noexcept {
      logger_.log("%:% %() % TCPServer::
       defaultRecvFinishedCallback()\n", __FILE__,
       __LINE__, __FUNCTION__,
        Common::getCurrentTimeStr(&amp;time_str_));
    }</span></pre>
<p><span class="koboSpan" id="kobo.1152.1">The code to destroy the sockets is quite simple as well – we close the file descriptor and destroy </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">TCPSocket listener_socket_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1155.1">
  auto TCPServer::destroy() {
    close(efd_);
    efd_ = -1;
    listener_socket_.destroy();
  }</span></pre>
<p><span class="koboSpan" id="kobo.1156.1">Finally, we present the boilerplate code that we saw previously for </span><span class="No-Break"><span class="koboSpan" id="kobo.1157.1">this class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1158.1">
    TCPServer() = delete;
    TCPServer(const TCPServer &amp;) = delete;
    TCPServer(const TCPServer &amp;&amp;) = delete;
    TCPServer &amp;operator=(const TCPServer &amp;) = delete;
    TCPServer &amp;operator=(const TCPServer &amp;&amp;) = delete;</span></pre>
<p><span class="koboSpan" id="kobo.1159.1">Next, let us </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.1160.1">understand the code that initializes the </span><span class="No-Break"><span class="koboSpan" id="kobo.1161.1">listener </span></span><span class="No-Break"><a id="_idIndexMarker696"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1162.1">socket.</span></span></p>
<h3><span class="koboSpan" id="kobo.1163.1">Starting up and listening for new connections</span></h3>
<p><span class="koboSpan" id="kobo.1164.1">The method </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">TCPServer::listen()</span></strong><span class="koboSpan" id="kobo.1166.1">, first creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">epoll</span></strong><span class="koboSpan" id="kobo.1168.1"> instance, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">epoll_create()</span></strong><span class="koboSpan" id="kobo.1170.1"> Linux </span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.1171.1">system call, and then </span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.1172.1">saves it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">efd_</span></strong><span class="koboSpan" id="kobo.1174.1"> variable. </span><span class="koboSpan" id="kobo.1174.2">It uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">TCPSocket::connect()</span></strong><span class="koboSpan" id="kobo.1176.1"> method we built earlier to initialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">listener_socket_</span></strong><span class="koboSpan" id="kobo.1178.1">, but here, the important part is that we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">listening</span></strong><span class="koboSpan" id="kobo.1180.1"> argument to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">true</span></strong><span class="koboSpan" id="kobo.1182.1">. </span><span class="koboSpan" id="kobo.1182.2">Finally, we add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">listener_socket_</span></strong><span class="koboSpan" id="kobo.1184.1"> to the list of sockets to be monitored using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">epoll_add()</span></strong><span class="koboSpan" id="kobo.1186.1"> method, since initially, this is the only socket to monitor. </span><span class="koboSpan" id="kobo.1186.2">We will look at this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">epoll_add()</span></strong><span class="koboSpan" id="kobo.1188.1"> method in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1189.1">next section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1190.1">
  auto TCPServer::listen(const std::string &amp;iface, int
    port) -&gt; void {
    destroy();
    efd_ = epoll_create(1);
    ASSERT(efd_ &gt;= 0, "epoll_create() failed error:" +
      std::string(std::strerror(errno)));
    ASSERT(listener_socket_.connect("", iface, port, true)
      &gt;= 0,
           "Listener socket failed to connect. </span><span class="koboSpan" id="kobo.1190.2">iface:" +
             iface + " port:" + std::to_string(port) + "
               error:" + std::string
                 (std::strerror(errno)));
    ASSERT(epoll_add(&amp;listener_socket_), "epoll_ctl()
      failed. </span><span class="koboSpan" id="kobo.1190.3">error:" + std::string(std::strerror(errno)));
  }</span></pre>
<p><span class="koboSpan" id="kobo.1191.1">Now, let us </span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.1192.1">look at how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">epoll_add()</span></strong><span class="koboSpan" id="kobo.1194.1"> and the </span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.1195.1">complementary </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">epoll_del()</span></strong><span class="koboSpan" id="kobo.1197.1"> methods are built in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1198.1">next subsection.</span></span></p>
<h3><span class="koboSpan" id="kobo.1199.1">Adding and removing monitored sockets</span></h3>
<p><span class="koboSpan" id="kobo.1200.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1201.1">epoll_add()</span></strong><span class="koboSpan" id="kobo.1202.1"> method is used to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1203.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1204.1"> to the list of sockets to be monitored. </span><span class="koboSpan" id="kobo.1204.2">It uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">epoll_ctl()</span></strong><span class="koboSpan" id="kobo.1206.1"> system call with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1207.1">EPOLL_CTL_ADD</span></strong><span class="koboSpan" id="kobo.1208.1"> parameter to add the </span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.1209.1">provided file </span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.1210.1">descriptor of the socket to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1211.1">efd_</span></strong><span class="koboSpan" id="kobo.1212.1"> epoll class member. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1213.1">EPOLLET</span></strong><span class="koboSpan" id="kobo.1214.1"> enabled the </span><em class="italic"><span class="koboSpan" id="kobo.1215.1">edge-triggered epoll</span></em><span class="koboSpan" id="kobo.1216.1"> option, which in simple terms means you are notified only once when data needs to be read instead of constant reminders. </span><span class="koboSpan" id="kobo.1216.2">In this mode, it is up to the application developer to read the data when they want. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1217.1">EPOLLIN</span></strong><span class="koboSpan" id="kobo.1218.1"> is used for notification once data is available to </span><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">be read:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1220.1">
  auto TCPServer::epoll_add(TCPSocket *socket) {
    epoll_event ev{};
    ev.events = EPOLLET | EPOLLIN;
    ev.data.ptr = reinterpret_cast&lt;void *&gt;(socket);
    return (epoll_ctl(efd_, EPOLL_CTL_ADD, socket-&gt;fd_,
      &amp;ev) != -1);
  }</span></pre>
<p><span class="koboSpan" id="kobo.1221.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">epoll_del()</span></strong><span class="koboSpan" id="kobo.1223.1"> does the opposite of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1224.1">epoll_add()</span></strong><span class="koboSpan" id="kobo.1225.1"> – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1226.1">epoll_ctl()</span></strong><span class="koboSpan" id="kobo.1227.1"> is still used, but this time, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">EPOLL_CTL_DEL</span></strong><span class="koboSpan" id="kobo.1229.1"> parameter removes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1230.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1231.1"> from the list of sockets </span><span class="No-Break"><span class="koboSpan" id="kobo.1232.1">being monitored:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1233.1">
  auto TCPServer::epoll_del(TCPSocket *socket) {
    return (epoll_ctl(efd_, EPOLL_CTL_DEL, socket-&gt;fd_,
      nullptr) != -1);
  }</span></pre>
<p><span class="koboSpan" id="kobo.1234.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1235.1">del()</span></strong><span class="koboSpan" id="kobo.1236.1"> method we will build here removes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1237.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1238.1"> from the list of sockets being monitored, as </span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.1239.1">well as the different data </span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.1240.1">member containers of </span><span class="No-Break"><span class="koboSpan" id="kobo.1241.1">the sockets:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1242.1">
  auto TCPServer::del(TCPSocket *socket) {
    epoll_del(socket);
    sockets_.erase(std::remove(sockets_.begin(),
      sockets_.end(), socket), sockets_.end());
    receive_sockets_.erase(std::remove
      (receive_sockets_.begin(), receive_sockets_.end(),
        socket), receive_sockets_.end());
    send_sockets_.erase(std::remove(send_sockets_.begin(),
      send_sockets_.end(), socket), send_sockets_.end());
  }</span></pre>
<p><span class="koboSpan" id="kobo.1243.1">Now, we can look at the most important method in this subsection – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1244.1">TCPServer::poll()</span></strong><span class="koboSpan" id="kobo.1245.1">, which will be used to perform a few tasks, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1246.1">listed here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1247.1">Call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1248.1">epoll_wait()</span></strong><span class="koboSpan" id="kobo.1249.1">, detect whether there are any new incoming connections, and if so, add them to </span><span class="No-Break"><span class="koboSpan" id="kobo.1250.1">our containers</span></span></li>
<li><span class="koboSpan" id="kobo.1251.1">From the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">epoll_wait()</span></strong><span class="koboSpan" id="kobo.1253.1">, detect sockets that have disconnected from the client’s side and remove them from </span><span class="No-Break"><span class="koboSpan" id="kobo.1254.1">our containers</span></span></li>
<li><span class="koboSpan" id="kobo.1255.1">From the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1256.1">epoll_wait()</span></strong><span class="koboSpan" id="kobo.1257.1">, check to see whether there are sockets with data ready to be read or with </span><span class="No-Break"><span class="koboSpan" id="kobo.1258.1">outgoing data</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1259.1">Let us break down the entire method into a few blocks – first, the block that calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1260.1">epoll_wait()</span></strong><span class="koboSpan" id="kobo.1261.1"> method, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">epoll</span></strong><span class="koboSpan" id="kobo.1263.1"> instance and the maximum number of events being the total number of sockets in our containers, with </span><span class="No-Break"><span class="koboSpan" id="kobo.1264.1">no timeout:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1265.1">
  auto TCPServer::poll() noexcept -&gt; void {
    const int max_events = 1 + sockets_.size();
    for (auto socket: disconnected_sockets_) {
      del(socket);
    }
    const int n = epoll_wait(efd_, events_, max_events, 0);</span></pre>
<p><span class="koboSpan" id="kobo.1266.1">Next, we iterate </span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.1267.1">through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">events_</span></strong><span class="koboSpan" id="kobo.1269.1"> array </span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.1270.1">populated by the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">epoll_wait()</span></strong><span class="koboSpan" id="kobo.1272.1"> if it returns a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">n</span></strong><span class="koboSpan" id="kobo.1274.1"> greater than 0. </span><span class="koboSpan" id="kobo.1274.2">For each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">epoll_event</span></strong><span class="koboSpan" id="kobo.1276.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">events_</span></strong><span class="koboSpan" id="kobo.1278.1"> array, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">event.data.ptr</span></strong><span class="koboSpan" id="kobo.1280.1"> object and cast it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">TCPSocket*</span></strong><span class="koboSpan" id="kobo.1282.1">, since that is how we set up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1283.1">events_</span></strong><span class="koboSpan" id="kobo.1284.1"> array in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1285.1">epoll_add()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1286.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1287.1">
    bool have_new_connection = false;
    for (int i = 0; i &lt; n; ++i) {
      epoll_event &amp;event = events_[i];
      auto socket = reinterpret_cast&lt;TCPSocket
        *&gt;(event.data.ptr);</span></pre>
<p><span class="koboSpan" id="kobo.1288.1">For each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1289.1">epoll_event</span></strong><span class="koboSpan" id="kobo.1290.1"> entry, we check whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">EPOLLIN</span></strong><span class="koboSpan" id="kobo.1292.1"> flag is set on the events flag, which would signify that there is a new socket with data to read from. </span><span class="koboSpan" id="kobo.1292.2">If this socket happens to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1293.1">listener_socket_</span></strong><span class="koboSpan" id="kobo.1294.1">, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1295.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1296.1">’s primary socket that we configured to listen for connections on, we can see that we have a new connection to add. </span><span class="koboSpan" id="kobo.1296.2">If this is a socket different from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1297.1">listener_socket_</span></strong><span class="koboSpan" id="kobo.1298.1">, then we add it to the list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1299.1">receive_sockets_</span></strong><span class="koboSpan" id="kobo.1300.1"> vectors if it does not already exist in </span><span class="No-Break"><span class="koboSpan" id="kobo.1301.1">the list:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1302.1">
      if (event.events &amp; EPOLLIN) {
        if (socket == &amp;listener_socket_) {
          logger_.log("%:% %() % EPOLLIN
            listener_socket:%\n", __FILE__, __LINE__,
              __FUNCTION__,
               Common::getCurrentTimeStr(&amp;time_str_),
                 socket-&gt;fd_);
          have_new_connection = true;
          continue;
        }
        logger_.log("%:% %() % EPOLLIN socket:%\n",
          __FILE__, __LINE__, __FUNCTION__,
            Common::getCurrentTimeStr(&amp;time_str_), socket-
              &gt;fd_);
        if(std::find(receive_sockets_.begin(),
          receive_sockets_.end(), socket) ==
            receive_sockets_.end())
          receive_sockets_.push_back(socket);
      }</span></pre>
<p><span class="koboSpan" id="kobo.1303.1">Similarly, we check </span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.1304.1">for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1305.1">EPOLLOUT</span></strong><span class="koboSpan" id="kobo.1306.1"> flag, which </span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.1307.1">signifies there is a socket that we can send data to, and add it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">send_sockets_</span></strong><span class="koboSpan" id="kobo.1309.1"> vector if it does not </span><span class="No-Break"><span class="koboSpan" id="kobo.1310.1">already exist:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1311.1">
      if (event.events &amp; EPOLLOUT) {
        logger_.log("%:% %() % EPOLLOUT socket:%\n",
          __FILE__, __LINE__, __FUNCTION__,
            Common::getCurrentTimeStr(&amp;time_str_), socket-
             &gt;fd_);
        if(std::find(send_sockets_.begin(),
          send_sockets_.end(), socket) ==
            send_sockets_.end())
          send_sockets_.push_back(socket);
      }</span></pre>
<p><span class="koboSpan" id="kobo.1312.1">Finally, we check whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1313.1">EPOLLERR</span></strong><span class="koboSpan" id="kobo.1314.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1315.1">EPOLLHUP</span></strong><span class="koboSpan" id="kobo.1316.1"> flags are set, which indicate an error or indicate that the socket was closed (signal </span><strong class="source-inline"><span class="koboSpan" id="kobo.1317.1">hang up</span></strong><span class="koboSpan" id="kobo.1318.1">) from the other end. </span><span class="koboSpan" id="kobo.1318.2">In this case, we add this socket to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1319.1">disconnected_sockets_</span></strong><span class="koboSpan" id="kobo.1320.1"> vector to </span><span class="No-Break"><span class="koboSpan" id="kobo.1321.1">be removed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1322.1">
      if (event.events &amp; (EPOLLERR | EPOLLHUP)) {
        logger_.log("%:% %() % EPOLLERR socket:%\n",
          __FILE__, __LINE__, __FUNCTION__,
            Common::getCurrentTimeStr(&amp;time_str_), socket-
              &gt;fd_);
        if(std::find(disconnected_sockets_.begin(),
          disconnected_sockets_.end(), socket) ==
            disconnected_sockets_.end())
          disconnected_sockets_.push_back(socket);
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.1323.1">Finally, in this method, we need to accept the new connection if we detected one in the previous code block. </span><span class="koboSpan" id="kobo.1323.2">We </span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.1324.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1325.1">accept()</span></strong><span class="koboSpan" id="kobo.1326.1"> system call </span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.1327.1">with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1328.1">listener_socket_</span></strong><span class="koboSpan" id="kobo.1329.1"> file descriptor to achieve this and fetch the file descriptor for this new socket. </span><span class="koboSpan" id="kobo.1329.2">We also set the socket to be non-blocking and disable Nagle’s algorithm, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1330.1">setNonBlocking()</span></strong><span class="koboSpan" id="kobo.1331.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1332.1">setNoDelay()</span></strong><span class="koboSpan" id="kobo.1333.1"> methods we </span><span class="No-Break"><span class="koboSpan" id="kobo.1334.1">built before:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1335.1">
    while (have_new_connection) {
      logger_.log("%:% %() % have_new_connection\n",
        __FILE__, __LINE__, __FUNCTION__,
         Common::getCurrentTimeStr(&amp;time_str_));
      sockaddr_storage addr;
      socklen_t addr_len = sizeof(addr);
      int fd = accept(listener_socket_.fd_,
        reinterpret_cast&lt;sockaddr *&gt;(&amp;addr), &amp;addr_len);
      if (fd == -1)
        break;
      ASSERT(setNonBlocking(fd) &amp;&amp; setNoDelay(fd), "Failed
        to set non-blocking or no-delay on socket:" + std::
          to_string(fd));
      logger_.log("%:% %() % accepted socket:%\n",
        __FILE__, __LINE__, __FUNCTION__,
          Common::getCurrentTimeStr(&amp;time_str_), fd);</span></pre>
<p><span class="koboSpan" id="kobo.1336.1">Finally, we </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.1337.1">create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1338.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1339.1"> object </span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.1340.1">using this file descriptor and add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1341.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1342.1"> object to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1343.1">sockets_</span></strong><span class="koboSpan" id="kobo.1344.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1345.1">receive_sockets_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1346.1"> containers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1347.1">
      TCPSocket *socket = new TCPSocket(logger_);
      socket-&gt;fd_ = fd;
      socket-&gt;recv_callback_ = recv_callback_;
      ASSERT(epoll_add(socket), "Unable to add socket.
</span><span class="koboSpan" id="kobo.1347.2">        error:" + std::string(std::strerror(errno)));
      if(std::find(sockets_.begin(), sockets_.end(),
        socket) == sockets_.end())
        sockets_.push_back(socket);
      if(std::find(receive_sockets_.begin(),
        receive_sockets_.end(), socket) ==
          receive_sockets_.end())
        receive_sockets_.push_back(socket);
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.1348.1">This concludes all the functionality we need to look for new connections and dead connections, as </span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.1349.1">well as monitor existing </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.1350.1">connections to see whether there is data to be read. </span><span class="koboSpan" id="kobo.1350.2">The next sub-section concludes our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1351.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1352.1"> class by demonstrating how to send and receive data from a list of sockets that have data to be read or </span><span class="No-Break"><span class="koboSpan" id="kobo.1353.1">sent out.</span></span></p>
<h3><span class="koboSpan" id="kobo.1354.1">Sending and receiving data</span></h3>
<p><span class="koboSpan" id="kobo.1355.1">The code to send </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.1356.1">and receive data on a list of sockets with incoming </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.1357.1">or outgoing data is shown here. </span><span class="koboSpan" id="kobo.1357.2">The implementation is very straightforward – it simply calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1358.1">TCPSocket::sendAndRecv()</span></strong><span class="koboSpan" id="kobo.1359.1"> method on each of the sockets in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1360.1">receive_sockets_</span></strong><span class="koboSpan" id="kobo.1361.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1362.1">send_sockets_</span></strong><span class="koboSpan" id="kobo.1363.1">. </span><span class="koboSpan" id="kobo.1363.2">For incoming data, the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">TCPSocket::sendAndRecv()</span></strong><span class="koboSpan" id="kobo.1365.1"> dispatches the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1366.1">recv_callback_</span></strong><span class="koboSpan" id="kobo.1367.1"> method. </span><span class="koboSpan" id="kobo.1367.2">One thing we need to do here is to check whether there was any data that was read this time around, and if so, we dispatch </span><strong class="source-inline"><span class="koboSpan" id="kobo.1368.1">recv_finished_callback_</span></strong><span class="koboSpan" id="kobo.1369.1"> after all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1370.1">recv_callback_</span></strong><span class="koboSpan" id="kobo.1371.1"> calls </span><span class="No-Break"><span class="koboSpan" id="kobo.1372.1">are dispatched:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1373.1">
  auto TCPServer::sendAndRecv() noexcept -&gt; void {
    auto recv = false;
    for (auto socket: receive_sockets_) {
      if(socket-&gt;sendAndRecv())
        recv = true;
    }
    if(recv)
      recv_finished_callback_();
    for (auto socket: send_sockets_) {
      socket-&gt;sendAndRecv();
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.1374.1">This concludes </span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.1375.1">our implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1376.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1377.1"> class, let </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.1378.1">us wrap up our network programming discussion with a simple example of everything we built in </span><span class="No-Break"><span class="koboSpan" id="kobo.1379.1">this section.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.1380.1">Building an example of the TCP server and clients</span></h2>
<p><span class="koboSpan" id="kobo.1381.1">In this section, we </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.1382.1">will build an example and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1383.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1384.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1385.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1386.1"> classes we implemented in this section. </span><span class="koboSpan" id="kobo.1386.2">This example can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1387.1">Chapter4/socket_example.cpp</span></strong><span class="koboSpan" id="kobo.1388.1"> source file. </span><span class="koboSpan" id="kobo.1388.2">This simple example creates </span><strong class="source-inline"><span class="koboSpan" id="kobo.1389.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1390.1">, which listens for incoming connections on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1391.1">lo</span></strong><span class="koboSpan" id="kobo.1392.1"> interface, the loopback </span><strong class="source-inline"><span class="koboSpan" id="kobo.1393.1">127.0.0.1</span></strong><span class="koboSpan" id="kobo.1394.1"> IP, and the listening port, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1395.1">12345</span></strong><span class="koboSpan" id="kobo.1396.1">. </span><span class="koboSpan" id="kobo.1396.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1397.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1398.1"> class receives data from the clients, which connect to it using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1399.1">tcpServerRecvCallback()</span></strong><span class="koboSpan" id="kobo.1400.1"> lambda method, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1401.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1402.1"> responds back to the clients with a simple response. </span><span class="koboSpan" id="kobo.1402.2">We then create five clients using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1403.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.1404.1"> class, each of which connects to this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1405.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1406.1">. </span><span class="koboSpan" id="kobo.1406.2">Finally, they each send some data to the server, which sends responses back, each of the clients repeatedly calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.1407.1">sendAndRecv()</span></strong><span class="koboSpan" id="kobo.1408.1"> to send and receive data. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1409.1">TCPServer</span></strong><span class="koboSpan" id="kobo.1410.1"> calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.1411.1">poll()</span></strong><span class="koboSpan" id="kobo.1412.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">sendAndRecv()</span></strong><span class="koboSpan" id="kobo.1414.1"> to look for connections and data and </span><span class="No-Break"><span class="koboSpan" id="kobo.1415.1">reads it.</span></span></p>
<p><span class="koboSpan" id="kobo.1416.1">First, the code that sets up the callback lambdas is </span><span class="No-Break"><span class="koboSpan" id="kobo.1417.1">presented here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1418.1">
#include "time_utils.h"
#include "logging.h"
#include "tcp_server.h"
int main(int, char **) {
  using namespace Common;
  std::string time_str_;
  Logger logger_("socket_example.log");
  auto tcpServerRecvCallback = [&amp;](TCPSocket *socket, Nanos
    rx_time)
  noexcept{
      logger_.log("TCPServer::defaultRecvCallback()
        socket:% len:% rx:%\n",
                  socket-&gt;fd_, socket-&gt;
                    next_rcv_valid_index_, rx_time);
      const std::string reply = "TCPServer received msg:" +
        std::string(socket-&gt;rcv_buffer_, socket-&gt;
          next_rcv_valid_index_);
      socket-&gt;next_rcv_valid_index_ = 0;
      socket-&gt;send(reply.data(), reply.length());
  };
  auto tcpServerRecvFinishedCallback = [&amp;]()
  noexcept{
      logger_.log("TCPServer::defaultRecvFinishedCallback()\n");
  };
  auto tcpClientRecvCallback = [&amp;](TCPSocket *socket, Nanos
    rx_time)
  noexcept{
      const std::string recv_msg = std::string(socket-&gt;
        rcv_buffer_, socket-&gt;next_rcv_valid_index_);
      socket-&gt;next_rcv_valid_index_ = 0;
      logger_.log("TCPSocket::defaultRecvCallback()
        socket:% len:% rx:% msg:%\n",
      socket-&gt;fd_, socket-&gt;next_rcv_valid_index_, rx_time,
        recv_msg);
  };</span></pre>
<p><span class="koboSpan" id="kobo.1419.1">Then, we </span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.1420.1">create, initialize, and connect the server and the clients, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1421.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1422.1">
  const std::string iface = "lo";
  const std::string ip = "127.0.0.1";
  const int port = 12345;
  logger_.log("Creating TCPServer on iface:% port:%\n",
    iface, port);
  TCPServer server(logger_);
  server.recv_callback_ = tcpServerRecvCallback;
  server.recv_finished_callback_ =
    tcpServerRecvFinishedCallback;
  server.listen(iface, port);
  std::vector &lt; TCPSocket * &gt; clients(5);
  for (size_t i = 0; i &lt; clients.size(); ++i) {
    clients[i] = new TCPSocket(logger_);
    clients[i]-&gt;recv_callback_ = tcpClientRecvCallback;
    logger_.log("Connecting TCPClient-[%] on ip:% iface:%
      port:%\n", i, ip, iface, port);
    clients[i]-&gt;connect(ip, iface, port, false);
    server.poll();
  }</span></pre>
<p><span class="koboSpan" id="kobo.1423.1">Finally, we have the </span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.1424.1">clients send data and call the appropriate polling and sending/receiving methods on the clients and the server, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1425.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1426.1">
  using namespace std::literals::chrono_literals;
  for (auto itr = 0; itr &lt; 5; ++itr) {
    for (size_t i = 0; i &lt; clients.size(); ++i) {
      const std::string client_msg = "CLIENT-[" +
        std::to_string(i) + "] : Sending " +
          std::to_string(itr * 100 + i);
      logger_.log("Sending TCPClient-[%] %\n", i,
        client_msg);
      clients[i]-&gt;send(client_msg.data(),
        client_msg.length());
      clients[i]-&gt;sendAndRecv();
      std::this_thread::sleep_for(500ms);
      server.poll();
      server.sendAndRecv();
    }
  }
  for (auto itr = 0; itr &lt; 5; ++itr) {
    for (auto &amp;client: clients)
      client-&gt;sendAndRecv();
    server.poll();
    server.sendAndRecv();
    std::this_thread::sleep_for(500ms);
  }
  return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.1427.1">Running this example, as </span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.1428.1">shown here, will output something similar to what is shown here in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1429.1">log file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1430.1">
(base) sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter4$ ./cmake-build-release/socket_example ; cat socket_example.log
Creating TCPServer on iface:lo port:12345
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter4/socket_utils.cpp:68 createSocket() Sat Mar 25 11:32:55 2023 ip:127.0.0.1 iface:lo port:12345 is_udp:0 is_blocking:0 is_listening:1 ttl:0 SO_time:1
Connecting TCPClient-[0] on ip:127.0.0.1 iface:lo port:12345
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter4/tcp_server.cpp:74 poll() Sat Mar 25 11:32:55 2023 EPOLLIN listener_socket:5
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter4/tcp_server.cpp:97 poll() Sat Mar 25 11:32:55 2023 have_new_connection
…
Sending TCPClient-[0] CLIENT-[0] : Sending 0
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter4/tcp_socket.cpp:67 sendAndRecv() Sat Mar 25 11:32:55 2023 send socket:6 len:22
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter4/tcp_server.cpp:78 poll() Sat Mar 25 11:32:55 2023 EPOLLIN socket:7
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter4/tcp_socket.cpp:51 sendAndRecv() Sat Mar 25 11:32:55 2023 read socket:7 len:22 utime:1679761975918407366 ktime:0 diff:1679761975918407366
TCPServer::defaultRecvCallback() socket:7 len:22 rx:0
…
TCPSocket::defaultRecvCallback() socket:12 len:0 rx:1679761987425505000 msg:TCPServer received msg:CLIENT-[3] : Sending 403
/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter4/tcp_socket.cpp:51 sendAndRecv() Sat Mar 25 11:33:07 2023 read socket:14 len:47 utime:1679761987925931213 ktime:1679761987925816000 diff:115213
TCPSocket::defaultRecvCallback() socket:14 len:0 rx:1679761987925816000 msg:TCPServer received msg:CLIENT-[4] : Sending 404</span></pre>
<p><span class="koboSpan" id="kobo.1431.1">This concludes our </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.1432.1">discussion of C++ network programming with sockets. </span><span class="koboSpan" id="kobo.1432.2">We covered a lot regarding the basic low-level details of socket programming. </span><span class="koboSpan" id="kobo.1432.3">We also designed and implemented slightly higher-level abstractions for TCP and UDP communication, both from a server’s and a </span><span class="No-Break"><span class="koboSpan" id="kobo.1433.1">client’s perspective.</span></span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.1434.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1435.1">In this chapter, we jumped into the world of low latency application C++ development. </span><span class="koboSpan" id="kobo.1435.2">We built some relatively fundamental but extremely useful building blocks that can be used for a variety of low latency application purposes. </span><span class="koboSpan" id="kobo.1435.3">We put into practice a lot of the theoretical discussions related to using C++ and computer architecture features effectively to build low latency and highly </span><span class="No-Break"><span class="koboSpan" id="kobo.1436.1">performant applications.</span></span></p>
<p><span class="koboSpan" id="kobo.1437.1">The first component was used to create new threads of execution and run the functions that different components might require. </span><span class="koboSpan" id="kobo.1437.2">One important functionality here is being able to control the CPU core that the newly created thread gets pinned to by setting the </span><span class="No-Break"><span class="koboSpan" id="kobo.1438.1">thread affinity.</span></span></p>
<p><span class="koboSpan" id="kobo.1439.1">The second component we built was meant to avoid dynamic memory allocation on the critical code path. </span><span class="koboSpan" id="kobo.1439.2">We reiterated the inefficiencies associated with dynamic memory allocation and designed a memory pool to be used to pre-allocate memory from the heap when constructed. </span><span class="koboSpan" id="kobo.1439.3">Then, we added utility to the component to allow the allocation and deallocation of objects at runtime without relying on dynamic </span><span class="No-Break"><span class="koboSpan" id="kobo.1440.1">memory allocation.</span></span></p>
<p><span class="koboSpan" id="kobo.1441.1">Next, we built a lock-free, </span><strong class="bold"><span class="koboSpan" id="kobo.1442.1">First In First Out</span></strong><span class="koboSpan" id="kobo.1443.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1444.1">FIFO</span></strong><span class="koboSpan" id="kobo.1445.1">)-style queue to communicate between threads in an SPSC setup. </span><span class="koboSpan" id="kobo.1445.2">The important requirement here was that a single reader and a single writer are able to access the shared data in the queue without using any locks or mutexes. </span><span class="koboSpan" id="kobo.1445.3">The absence of locks and mutexes means the absence of context switches, which, as discussed, are a major source of inefficiencies and latencies in </span><span class="No-Break"><span class="koboSpan" id="kobo.1446.1">multi-threaded applications.</span></span></p>
<p><span class="koboSpan" id="kobo.1447.1">The fourth component on our list was a framework to facilitate efficient logging for latency-sensitive applications. </span><span class="koboSpan" id="kobo.1447.2">Logging is a very important if not mandatory component of all applications, including low latency applications. </span><span class="koboSpan" id="kobo.1447.3">However, due to issues such as disk I/O, slow string formatting, and so on, traditional logging mechanisms such as writing to a log file on disk is impractical for use with low latency applications. </span><span class="koboSpan" id="kobo.1447.4">To build this component, we used the multi-threading mechanism we built, as well as the lock-free </span><span class="No-Break"><span class="koboSpan" id="kobo.1448.1">FIFO queue.</span></span></p>
<p><span class="koboSpan" id="kobo.1449.1">Finally, we had an in-depth discussion about designing our network stack – how to create network sockets, how to use them to create TCP servers and clients, and how to use them to publish and consume multicast traffic. </span><span class="koboSpan" id="kobo.1449.2">We have not used this last component yet, but we will use this component in subsequent chapters to facilitate communication between our electronic trading exchange and different </span><span class="No-Break"><span class="koboSpan" id="kobo.1450.1">market participants.</span></span></p>
<p><span class="koboSpan" id="kobo.1451.1">Now, we will move on to a case study project, which we will build in the rest of this book – our electronic trading ecosystem. </span><span class="koboSpan" id="kobo.1451.2">In the next chapter, we will first focus on designing and understanding the higher-level design of the various components in our system. </span><span class="koboSpan" id="kobo.1451.3">We will understand the purpose of these components, the motivation behind their design choices, and how the flow of information occurs in the system. </span><span class="koboSpan" id="kobo.1451.4">The next chapter will also see us designing the higher-level C++ interfaces that we will implement in the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.1452.1">this book.</span></span></p>
</div>


<div class="Content" id="_idContainer025">
<h1 id="_idParaDest-126"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.1.1">Part 2:Building a Live Trading Exchange in C++</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, we will describe and design the trading applications that make up our ecosystem, which we will be building from scratch in this book – electronic trading exchanges, exchange market data dissemination, order gateways, client market data decoders, and client trading algorithm frameworks. </span><span class="koboSpan" id="kobo.2.2">We will implement the matching engine that tracks client orders and performs matching between them. </span><span class="koboSpan" id="kobo.2.3">We will also build the components that publish market data for all participants and how it handles client connections and order requests. </span><span class="koboSpan" id="kobo.2.4">The focus will be on very low-latency reaction times and high throughput since modern electronic exchanges have thousands of participants and a huge amount of order flow flowing </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">through it.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19434_05.xhtml#_idTextAnchor134"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 5</span></em></a><em class="italic"><span class="koboSpan" id="kobo.7.1">, Designing Our Trading Ecosystem</span></em></li>
<li><a href="B19434_06.xhtml#_idTextAnchor166"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 6</span></em></a><em class="italic"><span class="koboSpan" id="kobo.9.1">, Building the C++ Matching Engine</span></em></li>
<li><a href="B19434_07.xhtml#_idTextAnchor186"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 7</span></em></a><em class="italic"><span class="koboSpan" id="kobo.11.1">, Communicating with Market Participants</span></em></li>
</ul>
</div>
<div>
<div class="IMG---Figure" id="_idContainer026">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer027">
</div>
</div>
<div>
<div id="_idContainer028">
</div>
</div>
</body></html>