- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an Online Co-Op Platformer Prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve deeper into the work of creating action multiplayer
    online games. Our goal is to turn a local multiplayer puzzle platformer game prototype
    into an online version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the final puzzle platformer prototype will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – A preview of the Puzzle Platformer prototype](img/Figure_08.01_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – A preview of the Puzzle Platformer prototype
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll know how to use the features of the `MultiplayerSpawner`
    node to create and assign playable characters to each player in the game, using
    the features offered by `MultiplayerSynchronizer` to sync relevant properties.
    With these features, we can go beyond updating the position of nodes; they will
    allow us to synchronize other properties, particularly animations. You will also
    learn how to leverage **Remote Procedure Calls** (**RPCs**) to manipulate the
    **multiplayer authority** of nodes. This will enable us to implement an exciting
    object-grabbing mechanic that will be a key element in our prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To access the resources for this chapter, you can find our repository of online
    projects by following the link provided here: [https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0).'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the repository, open the `res://08.designing-online-platformer`
    folder in the Godot Engine editor. All the necessary files for this chapter are
    located there.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s begin the onboarding process. In the upcoming section, we will familiarize
    ourselves with the project, explore its main classes, and identify where we need
    to implement networking features.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the platformer project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our project presents a captivating puzzle platformer that will test players’
    strategic thinking and collaboration skills as they overcome challenging obstacles
    together. At the heart of this game lies a core mechanic centered around the manipulation
    of objects, utilizing them to construct platforms for the other player to traverse.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s dive into the essential classes that serve as the pillars of our
    project’s foundation. Our first encounter will be with the `Player` class, which
    embodies the avatars controlled by each individual player. As the main protagonist,
    the `Player` class handles essential functionalities such as movement and interaction
    with various environmental elements. Notably, the `Player` class incorporates
    `InteractionArea2D` that detects contact with `InteractiveArea2D`, enabling players
    to perform specific actions upon them.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we encounter the `InteractiveArea2D` class. This class extends
    the functionality of the `Area2D` node and assumes the crucial role of a trigger
    area for detecting interactions. When `InteractionArea2D` overlaps with `InteractiveArea2D`,
    it becomes responsive to input events. Triggering the designated *interact* input
    action emits a signal, allowing us to create further engaging gameplay interactions.
  prefs: []
  type: TYPE_NORMAL
- en: In our game, the `Crate` class represents an interactive object that players
    can skillfully manipulate. Each `Crate` instance has an `InteractiveArea2D` node
    and a `CharacterBody2D` node, offering players the opportunity to collide with
    and leap onto them, which allows players to use them as viable platforms for navigating
    the level. These crates stand as major elements for puzzle-solving and advancing
    through the game’s levels.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we encounter the versatile `PlayerSpawner` class, responsible for the
    dynamic spawning and management of players within the game. This class adeptly
    adapts to the number of participating players, seamlessly instantiating a `Player`
    instance for each individual. Additionally, in the realm of local multiplayer,
    the `PlayerSpawner` class ensures a smooth and immersive gaming experience by
    establishing distinct controls for each player and optimizing gameplay customization.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we will dive into the `Player` object, which is composed
    of a script and a scene. We are going to understand how the script works with
    the available nodes on the scene and structures the desired behavior for our local
    `Player` node.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Player class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Player` class and scene represent the player’s avatar in the game. It is
    through this scene and script that players interact with the game world. The scene
    is a `CharacterBody2D` node with a `CollisionShape2D` Resource, a `Node2D` node
    called `Sprites`, which we use to group and pivot an `AnimatedSprite2D` node,
    and an `InteractionArea2D` node, which we are going to talk about in the *How
    the InteractiveArea2D class works* section. The `InteractionArea2D` node also
    has a `CollisionShape2D` Resource and a `RemoteTransformer2D` node, which we call
    `GrabberRemoteTransformer2D`. A `RemoteTransformer2D` node allows us to remotely
    sync the position, rotation, and scale of a node that is outside the hierarchy
    of the `RemoteTransformer2D`’s parent as if it were a sibling of the `RemoteTransformer2D`,
    which is very useful. In this case, we use the `GrabberRemoteTransformer2D` node
    to remotely transform the objects the player can grab, such as the *crate*, which
    we will talk about in the *Unveiling the Crate class* section. Finally, the `Player`
    class also has a `Label` node that we use to visually communicate the player controlling
    the avatar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The Player’s scene node hierarchy](img/Figure_8.02_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The Player’s scene node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the script itself. There are some aspects that we won’t
    delve into in this section because they are more related to the basic platformer
    game player movement, and our focus here is on the online multiplayer aspect,
    so we would go beyond our scope. But the important part for your job is to know
    that when two players are playing locally, the `Player` node can set up its controllers
    dynamically so each player controls only one avatar. And this is something you’ll
    have to make work in the online version of the prototype: how each player will
    control only their own avatar. For reference, the following code snippet does
    this locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code iterates over actions in `InputMap` singleton and creates
    new actions specific to a given controller device, using an index. It also updates
    the events and properties associated with the actions to be specific to the given
    device. The purpose of this code is to set up controller mappings for different
    players or devices in a game, allowing customization and differentiation of input
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let’s see how the *Crate* scene works, it’s a pretty simple
    scene that essentially works as a passive object that players can use as a platform
    to move around the level.
  prefs: []
  type: TYPE_NORMAL
- en: Unveiling the Crate class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Crate` scene plays a crucial role in our game prototype. It represents
    interactive objects that players can skillfully manipulate to overcome obstacles
    and progress through the levels. Each instance of the `Crate` scene is a `Node2D`
    equipped with two important components: `InteractiveArea2D` node and `CharacterBody2D`
    node.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The Crate’s scene node hierarchy](img/Figure_8.03_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – The Crate’s scene node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: The `CharacterBody2D` node represents the physical body of the *Crate* node
    within the game’s physics simulation. It ensures that the crates collide with
    the player’s avatar or other objects. The `CharacterBody2D` node handles the collision
    detection and response, allowing the player to seamlessly jump on and stand on
    the crate as if it were a solid platform.
  prefs: []
  type: TYPE_NORMAL
- en: As for `InteractiveArea2D` node, it is a special `Area2D` node that detects
    when `InteractiveArea2D` nodes overlap with it. In the context of the `Crate`
    class, the `InteractiveArea2D` node allows players to grab and lift the *Crate*
    nodes if they press the `interact` action while their `InteractionArea2D` node
    overlaps with the *Crate*’s `InteractionArea2D` node. This interaction enables
    players to use the *Crate* nodes as sturdy platforms to navigate the level since
    they will be able to move them around and jump on them even when another player
    is grabbing them. `InteractiveArea2D` node acts as a trigger, detecting when the
    player’s avatar comes into contact with the `Crate` node and assigning the `Crate`
    node to the player’s avatar `GrabbingRemoteTransform2D` node, synchronizing its
    position with the player even when they are moving.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Crate` script is fairly simple and structures how the `Crate` node responds
    and updates to interactions with the `Player` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sets up references to nodes in the `Crate`’s scene hierarchy.
    It also defines two callback functions that handle signals from the `Crate` node’s
    `InteractiveArea2D` node. When an `InteractionArea2D` node enters the `Crate`
    node’s `InteractiveArea2D` node, we presume it is the `Player` node interacting
    and we retrieve the `Player` node’s `"GrabbingRemoteTransform2D"` node, assigning
    it to the `lift_transformer` variable.
  prefs: []
  type: TYPE_NORMAL
- en: When an interaction happens, the code assigns the `lift_transformer.remote_path`
    node to the path from `lift_transformer` variable to the `Crate` node’s body.
    Remember, `lift_transformer` variable is a `RemoteTransform2D` node. This is how
    we allow the `Player` node’s `GrabbingRemoteTransform2D` node to remotely transform
    the `Crate` node’s `CharacterBody2D` Node position.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will understand how `InteractiveArea2D` node detects
    players’ interactions with the *Crate* node and its role in our game.
  prefs: []
  type: TYPE_NORMAL
- en: How the InteractiveArea2D class works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll understand the role of a major scene that lies at the
    heart of our game’s mechanics. Called `InteractiveArea2D` node, this scene plays
    a fundamental role in detecting and enabling player interactions with various
    objects in the game environment. `InteractiveArea2D` node enables us to turn any
    object into an object the player can interact with. For example, in our prototype,
    we use `InteractiveArea2D` node to allow the player to grab a `Crate` node and
    move it around.
  prefs: []
  type: TYPE_NORMAL
- en: The `InteractiveArea2D` scene, built upon the foundation of the `Area2D` node,
    serves as a fundamental component in our game. Its primary function is to detect
    and ease player interactions with objects, particularly within the player-crate
    interaction mechanic. Through the use of signals and input handling, the `InteractiveArea2D`
    scene ensures smooth gameplay interactions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The InteractiveArea2D’s scene node hierarchy](img/Figure_8.04_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – The InteractiveArea2D’s scene node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: One of the standout features of our game is the player-`Crate` node interaction
    mechanism, offering players the ability to manipulate interactive objects. The
    `InteractiveArea2D` scene serves as the catalyst for this interaction, acting
    as the gateway through which players can engage with the objects that populate
    the game world.
  prefs: []
  type: TYPE_NORMAL
- en: Using signals, the `InteractiveArea2D` scene establishes communication channels
    with other game objects and systems. Whenever a player successfully interacts
    with an object, `InteractiveArea2D` node emits the `interacted` signal. On top
    of that, the scene emits signals to indicate the availability or unavailability
    of interactions, allowing us to provide visual and auditory feedback to players.
  prefs: []
  type: TYPE_NORMAL
- en: To detect player input, the `InteractiveArea2D` scene uses an `_unhandled_input`
    callback. When players press the designated `interact` input action, it triggers
    the `interacted` signal, signaling that an interaction has occurred. This control
    scheme allows the players to interact with the game world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding the role of the `InteractiveArea2D` scene and its seamless integration
    with the player-`Crate` node interaction system is key. Now, it’s time to dive
    into the code and unleash the full potential of this vital scene in our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `InteractiveArea2D` script extends `Area2D` node and provides interaction
    functionality. It emits signals when an interaction occurs, when an interaction
    becomes available, and when an interaction becomes unavailable. It also handles
    unhandled input events to trigger interactions.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section and the final part of the onboarding, we will see how
    we create and insert `Player` instances in the game world dynamically based on
    how many players are playing.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the PlayerSpawner class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`PlayerSpawner` scene is another vital component in our game that handles the
    creation and positioning of `Player` instances. The `PlayerSpawner` class, based
    on the `Marker2D` node, follows the `Spawner` pattern, enabling us to dynamically
    generate `Player` instances in the game world.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The PlayerSpawner’s scene node hierarchy](img/Figure_8.05_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – The PlayerSpawner’s scene node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: One of the key features of the `PlayerSpawner` class is its ability to position
    the spawned `Player` instances. As a `Marker2D` node, `PlayerSpawner` node provides
    a convenient way to specify the location and orientation of the players within
    the game world. This ensures that each player starts in the appropriate position,
    ready to embark on their adventure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see its code to understand what this class does under the hood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding script showcases the implementation of a `Spawner` class, based
    on the `Marker2D` node. It checks for connected joypads and creates instances
    of the `Player` scene accordingly. If no joypads are connected, it creates a single
    instance. If there are connected joypads, it creates one `Player` instance per
    joypad and sets up their respective controls. The preceding code snippet allows
    for the dynamic creation of `Player` instances in a multiplayer game, easing our
    work developing a multiplayer experience.
  prefs: []
  type: TYPE_NORMAL
- en: We are finally done with our onboarding; in the next section, we’ll start to
    implement our online multiplayer features, turning our local prototype into something
    we can securely work with and polish knowing it’s ready to launch with remote
    multiplayer features.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning players in the match
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will understand how to improve the `PlayerSpawner` class
    to introduce online multiplayer features to our game. Leveraging the foundation
    laid by the *Understanding the PlayerSpawner class*, *Unveiling the Crate class*,
    and the *Understanding the Player class* sections, these enhancements enable multiple
    players to connect and interact seamlessly within a synchronized game environment.
  prefs: []
  type: TYPE_NORMAL
- en: '`PlayerSpawner` node plays a fundamental role in our game’s multiplayer architecture,
    acting as the core mechanism responsible for dynamically creating instances of
    the `Player` class for each connected player. These instances represent the avatars
    through which players engage with the game world.'
  prefs: []
  type: TYPE_NORMAL
- en: With the integration of multiplayer functionalities, we will add features designed
    for an online multiplayer experience. This includes mechanisms to handle multiplayer
    authority, enabling proper gameplay across all connected peers. On top of that,
    the code will establish unique player names using the peers’ IDs, allowing us
    to easily identify players on the network. To ensure synchronized actions, we
    will use RPCs, which will allow us to share events and actions among all connected
    players, especially the instantiation of other players.
  prefs: []
  type: TYPE_NORMAL
- en: One fundamental concept we are going to introduce here is the `MultiplayerSpawner`
    node. In the Godot Engine 4 High-Level Network API, the `MultiplayerSpawner` node
    is an invaluable asset for creating synced scenes in a networked multiplayer setting.
    In our context, it is a core component in synchronizing the creation of players,
    ensuring that every player can see and interact with the avatars of other players
    in real time.
  prefs: []
  type: TYPE_NORMAL
- en: With the `MultiplayerSpawner` node, we can effortlessly instantiate and position
    player avatars across all connected game instances. So to start with, let’s open
    the `PlayerSpawner` scene at `res://08.designing-online-platformer/Levels/PlayerSpawner.tscn`
    and add a `MultiplayerSpawner` node as its child.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – A MultiplayerSpawner node as a child of the PlayerSpawner node](img/Figure_8.06_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – A MultiplayerSpawner node as a child of the PlayerSpawner node
  prefs: []
  type: TYPE_NORMAL
- en: After that, we need to configure the `MultiplayerSpawner` node’s `PlayerSpawner`.
    This tells `MultiplayerSpawner` who should be the spawned scenes’ parent. Then,
    the second property should point to the same `PackedScene` Resource our `PlayerSpawner`
    node spawns. This will ensure that, when a new instance is created locally, `MultiplayerSpawner`
    node will replicate it on connected peers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – The MultiplayerSpawner’s Spawn Path and Auto Spawn List properties
    set up](img/Figure_8.07_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – The MultiplayerSpawner’s Spawn Path and Auto Spawn List properties
    set up
  prefs: []
  type: TYPE_NORMAL
- en: With that, our `MultiplayerSpawner` node is ready to sync new players on everyone’s
    game instances. But we still need to configure these new instances, otherwise,
    only the server will be able to control them. So, let’s see how we can empower
    players with the ability to control their own avatars. Open the `PlayerSpawner`
    script at `res://08.designing-online-platformer/Levels/PlayerSpawner.gd`. In the
    next section, we will make some changes to this script.
  prefs: []
  type: TYPE_NORMAL
- en: Giving players control in PlayerSpawner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new `PlayerSpawner` code introduces changes that enhance the multiplayer
    functionality of the game. Specifically, this code includes mechanisms to handle
    multiplayer synchronization and sets up `Player` instances correctly when multiple
    peers are connected. The changes involve checking for multiplayer authority, setting
    player names, and using RPCs to set up multiplayer functionality for each connected
    player. Let’s implement these features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `await(get_tree().create_timer(0.1).timeout)` at the beginning of the `_ready()`
    callback. This line introduces a delay of 0.1 seconds using a timer, allowing
    time for the multiplayer networking initialization to complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s check whether there are connected peers by checking for the size
    of the `multiplayer.get_peers()` array. With that, we can check whether there
    are any connected peers in the multiplayer session. This condition verifies whether
    this is a local game session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If this is the case, we use the original logic we saw in the *Understanding
    the Player class* section to set up the local players’ avatars’ controllers. With
    a small twist, we use the `return` keyword at the end to prevent `_ready()` from
    reaching the next steps, which are only necessary if this is an online game session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, if this is an online game session, we check whether this game instance
    is the multiplayer authority (in other words, the server), and if so, we enter
    a loop that iterates over the connected peers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similar to the local session logic, we create a `Player` instance for each
    connected player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the catch: after creating the `Player` instance, we set its name to
    the player’s peer ID. Only then do we add it as a child of the `PlayerSpawner`
    node. This ensures each `Player` instance has a unique name and will prevent the
    RPCs and `MultiplayerSpawner` node from returning errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we add another timer delay of `0.1` seconds. This delay gives time for
    peers’ game instances to synchronize their multiplayer setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we make an RPC to the `Player.setup_multiplayer()` method passing
    `player_id` as an argument. `Player.setup_multiplayer()` is responsible for configuring
    the player’s *multiplayer authority* based on the player ID, ultimately allowing
    this player, and only this player, to control this instance. We will implement
    this method in the *Setting up the Player multiplayer* *controls* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We aren’t done yet. We still need to set up the multiplayer features on other
    players’ avatar instances when `MultiplayerSpawner` node creates them. For that,
    let’s connect the `MultiplayerSpawner` node’ `spawned` signal to the `PlayerSpawner`
    node using a method called `_on_multiplayer_spawner_spawned`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – The MultiplayerSpawner spawned signal connecting to the PlayerSpawner
    _on_multiplayer_spawner_spawned callback](img/Figure_8.08_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – The MultiplayerSpawner spawned signal connecting to the PlayerSpawner
    _on_multiplayer_spawner_spawned callback
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we make an RPC on the spawned node’s `setup_multiplayer` method using
    the node’s name as an argument. Since the name is a `StringName` variable, we
    need to convert it to a string and then to an integer in order for the `Player`
    class to handle it. The complete `PlayerSpawner` script should look like this
    after these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The updated script incorporates multiplayer functionality by creating `Player`
    instances for each player in the network. It checks for the presence of connected
    joypads and multiplayer peers to determine the appropriate number of `Player`
    instances to create. The code also sets up the `Player` instances’ controls and
    synchronizes their multiplayer settings. With these changes, `PlayerSpawner` node
    now enables multiplayer gameplay, allowing multiple players to control their avatars
    and interact within the game world simultaneously with no control conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we will explore the implementation of the `Player.setup_multiplayer()`
    method, which is responsible for configuring online multiplayer settings in the
    `Player` class. Within the `setup_multiplayer()` method, we set the multiplayer
    authority, disable the physics and input processing based on the local player’s
    authority over the instance, and set a visual player index label updated with
    which player is controlling the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Player multiplayer controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, let’s see how to implement the `Player.setup_multiplayer()`
    method, which plays a core role in setting up the online multiplayer controls
    for the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `setup_multiplayer()` method, we need to take some key steps to achieve
    our online multiplayer controls. Firstly, we need to establish the new multiplayer
    authority, verifying the player’s control and decision-making capabilities within
    the multiplayer environment. Then, we will adjust the physics and input processing
    based on whether the player ID matches the player ID we designated using the node’s
    name. This ensures that each player controls the right `Player` instance.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, the method updates a visual player index label, allowing players
    to see their assigned avatar. This visual feedback enhances the multiplayer experience
    by providing a clear indication of each player’s identity and presence in the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing the `setup_multiplayer()` method, the game achieves synchronized
    multiplayer functionality, creating a cohesive and immersive multiplayer experience.
    Players can interact and collaborate with one another, encouraging a sense of
    shared adventure and enjoyment within the game world.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, let’s dive into the code and unlock the potential of our multiplayer
    gameplay on our prototype! Open the `Player` script at `res://08.designing-online-platformer/Actors/Player/Player2D.gd`
    and let’s implement the `setup_multiplayer()` method to finally allow players
    to control their avatars:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Player` script, create a new method called `setup_multiplayer()`. It
    should receive an argument to get the player’s ID; here, we’ll call it `player_id`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, decorate the method with the `@rpc` annotation, using the `"any_peer"`
    and `"call_local"` options. This specifies that the method can be called by any
    peer and executed locally. So, when players spawn their avatars, they tell the
    other peers to set up their avatars, setting up the avatar instance locally as
    well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `setup_multiplayer()` method, let’s call `set_multiplayer_authority()`
    passing `player_id` as an argument to set the new multiplayer authority of this
    `Player` instance. Remember, the multiplayer authority determines the peer’s control
    and decision-making capabilities over a given node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s create a variable to store whether `player_id` is equal to the
    `Player` instance name. With that, we check whether the current avatar is supposed
    to be controlled by the local player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we set the physics and unhandled input processes based on the value
    of the `is_player` variable. With that, we disable the physics processing and
    the input handling on the `Player` instances that don’t belong to the local player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we update the text of the `label` node to display the player index.
    Here, `%s` is a placeholder that is replaced with the value returned by `get_index()`,
    representing the player’s index in the `PlayerSpawner` children hierarchy (remember
    the first node is `MultiplayerSpawner`) so the player indexing starts at `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we have our `Player` instance ready to behave in an online multiplayer
    environment. The `setup_multiplayer()` method configures the multiplayer features
    in the `Player` instances. It sets the multiplayer authority, adjusts physics
    processing and input handling based on the local player ID, and updates a label
    with the player’s index.
  prefs: []
  type: TYPE_NORMAL
- en: But notice, since we are disabling physics and input processing, technically
    the other players’ avatars will remain static during the whole gameplay session,
    right? Each player will only control and see their own character moving around
    and we don’t want that. We want players to interact with each other and see how
    other players are behaving within this shared experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we are going to use `MultiplayerSynchronizer` node to
    keep all other players on the same page regarding each other’s avatar, including
    going beyond just the avatar’s position, but also its animation and more. We will
    also see how we handle the `Crate` node: since players can grab and carry it around,
    who should have control over it? Who should be the `Crate` node’s **Multiplayer
    Authority**?'
  prefs: []
  type: TYPE_NORMAL
- en: Syncing physical objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will understand how to use the `MultiplayerSynchronizer`
    node for more than position updates. This node plays an important role in ensuring
    that players are synchronized with the avatars of other players in the game. As
    we have seen in the *Giving players control in PlayerSpawner* section, it is essential
    to maintain consistency among players to create a seamless multiplayer experience.
  prefs: []
  type: TYPE_NORMAL
- en: The `MultiplayerSynchronizer` class serves as a bridge between players, enabling
    real-time updates and synchronization of various properties. One key aspect that
    we will explore is how the `Crate` object’s position is updated based on the player
    who is carrying it. This functionality allows for interactive and collaborative
    gameplay, where players can work together to solve puzzles or accomplish tasks.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, we will see how the `MultiplayerSynchronizer` node handles properties
    related to avatar animations. By leveraging the `MultiplayerSynchronizer` class,
    we can ensure that all players observe the same animation state of other players’
    avatars, enabling a visually consistent experience.
  prefs: []
  type: TYPE_NORMAL
- en: Through the usage of the `MultiplayerSynchronizer` node, we can establish a
    robust framework for synchronizing player actions, avatar positions, and animations.
    This synchronization ensures that all players perceive a cohesive and immersive
    multiplayer environment, fostering collaboration and enhancing the overall gameplay
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the implementation details of `MultiplayerSynchronizer`!
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing the player’s position and animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `Player` scene has some nodes responsible for playing animations based
    on the player’s actions and the current state of the avatar, namely the `Sprites`
    and `AnimatedSprite2D` nodes. It is important to synchronize the `Sprites` nodes’
    scale and the `AnimatedSprite` animation and frame since players’ avatars would
    look rather weird if they jump, run, and stay idle and there’s no visual feedback
    updating the performance of such actions in the game world other than the avatar’s
    position changing. So, in this section, let’s ensure that on top of the position,
    other relevant properties are also synced among players. For that, let’s open
    the `Player` scene at `res://08.designing-online-platformer/Actors/Player/Player2D.tscn`
    and, of course, add `MultiplayerSynchronizer` as its child. With that, we will
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to change the `MultiplayerSynchronizer`’s **Visibility
    Update Mode** to **Physics** so it syncs the physics simulations on remote peers’
    game instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.9 – The player’s MultiplayerSynchronizer properties](img/Figure_8.09_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – The player’s MultiplayerSynchronizer properties
  prefs: []
  type: TYPE_NORMAL
- en: After that, in the `PlayerCharacter2D` node’s `AnimatedSprite2D` node’s `Sprite`
    nodes’ `MultiplayerSynchronizer` node also synchronizes the animation-related
    properties, allowing the players to see what their peers’ avatars are doing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.10 – The MultiplayerSynchronizer’s Replication properties](img/Figure_8.10_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – The MultiplayerSynchronizer’s Replication properties
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! With that, our players are ready to interact within a shared
    game world. The `MultiplayerSynchronizer` node is an incredible ally to have in
    our toolbelt when developing online multiplayer games. As we can see in this section,
    those node allows for the synchronization of a range of different properties that
    can help us make our online gameplay experience enjoyable. There’s a small, though
    very important observation to make in this regard. As we’ve seen throughout this
    book, especially in *Part 1*, we can’t pass objects around, and we should avoid
    heavy data transmission through the network. So, keep that in mind when adding
    properties to the `MultiplayerSynchronizer` node’s **Replication** menu. For instance,
    if you try to sync a **Texture** property, you are likely to fail the replication.
  prefs: []
  type: TYPE_NORMAL
- en: That said, in the next section, we are going to use `MultiplayerSynchronizer`
    node to sync the `Crate` node’s position property, but there’s a twist. Since
    any player can grab a `Crate` node and move it around, who should be its **Multiplayer
    Authority**? Well, that’s what we are about to see!
  prefs: []
  type: TYPE_NORMAL
- en: Updating the crate’s position remotely
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we are fairly familiar with how `MultiplayerSynchronizer` node
    works and the overall concept of a node’s multiplayer authority, right? One of
    the core mechanics in our online multiplayer puzzle platformer game is the ability
    for players to collaborate by taking objects and using them as platforms to progress
    through the levels’ obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to see how we can dynamically change an object’s
    multiplayer authority based on which player is currently interacting with it so
    that only that player can change the object’s properties. Open the `Crate` scene
    at `res://08.designing-online-platformer/Objects/Crate/Crate.tscn`, and add a
    new `MultiplayerSynchronizer` node as its child. Then, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Just like in the `Player` scene, we need to change the `MultiplayerSynchronizer`
    node’s **Visibility Update Mode** to **Physics** to maintain the physics simulations
    consistently.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.11 – The crate’s MultiplerSynchronizer properties](img/Figure_8.11_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – The crate’s MultiplerSynchronizer properties
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the `CharacterBody2D` node’s **Position** property to the syncing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – The crate’s CharacterBody2D position property in the Replication
    menu](img/Figure_8.12_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – The crate’s CharacterBody2D position property in the Replication
    menu
  prefs: []
  type: TYPE_NORMAL
- en: With that, believe it or not, we already have what we need to sync the crate’s
    position. Currently, the crate does not have any built-in behavior to move on
    its own, as its position is expected to be altered by the players who interact
    with it. To enable this functionality, we will make some additions to the `Crate`
    script. To get started, let’s open the script file at `res://08.designing-online-platformer/Objects/Crate/Crate.gd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `_on_interactive_area_2d_area_entered()` method, we need to change the
    crate’s multiplayer authority to match the player it’s interacting with. For that,
    we can call the `set_multiplayer_authority()` method passing the area’s multiplayer
    authority. This area that just entered is the player’s `InteractionArea2D` node,
    so its multiplayer authority is the same as that of the player’s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With that, whenever the player’s avatar enters the crate’s `InteractiveArea2D`
    node, the player will become the crate’s multiplayer authority and will be able
    to grab it and change its position once they interact with it. With this addition,
    we are ready to witness the seamless synchronization of the crate’s position as
    players interact with it. You can test the prototype to explore the possibilities
    of collaborative gameplay and enjoy the immersive multiplayer experience we have
    just created!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dived into the world of online multiplayer puzzle platformers,
    which emphasized teamwork and collaboration. Players will be challenged to work
    together, leveraging their skills to overcome obstacles and progress through intricate
    levels. Throughout the chapter, we explored key concepts and techniques to enhance
    the multiplayer experience and create a seamless collaborative gameplay environment.
  prefs: []
  type: TYPE_NORMAL
- en: To enable multiplayer functionality, we introduced the `MultiplayerSpawner`
    class, which dynamically instantiates `Player` instances based on the number of
    connected players. This ensures that each player has a unique avatar in the game,
    promoting a personalized and immersive multiplayer experience. The `Player` class
    played a crucial role, and we implemented the `setup_multiplayer()` method to
    configure its multiplayer settings. This method allowed us to set each instance’s
    multiplayer authority, adjust physics and input processing, and update a visual
    player index label, providing players with a clear identification in the game.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve synchronization between players, we harnessed the power of `MultiplayerSynchronizer`
    node. This powerful tool enabled us to synchronize not only the positions of players
    but also their animations. By incorporating `MultiplayerSynchronizer` node, we
    created a visually captivating multiplayer experience where players moved and
    interacted with the game world in perfect harmony. This synchronization brought
    the multiplayer gameplay to life, enhancing immersion and ensuring a cohesive
    and enjoyable shared experience.
  prefs: []
  type: TYPE_NORMAL
- en: An exciting feature we implemented was the ability for players to grab and manipulate
    the `Crate` object. By dynamically changing the crate’s multiplayer authority,
    we ensured that only the player interacting with the crate had control over its
    movements. This added an extra layer of collaboration and puzzle-solving, as players
    can strategically use the crate as a platform to navigate the levels, fostering
    teamwork and coordination.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, this chapter provided a solid foundation for understanding and implementing
    multiplayer features using the Godot Engine High-level Network API. By combining
    the concepts and techniques explored, we created an online multiplayer puzzle
    platformer prototype, where players can seamlessly collaborate, synchronize their
    actions, and conquer challenges together. This chapter opened doors to endless
    possibilities in future multiplayer game development endeavors, empowering you
    to create engaging and interactive multiplayer experiences.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll leverage all the knowledge we’ve seen so far in *Part
    2* of this book to create a multiplayer online adventure with a persistent section
    system where players can log in and out and maintain their progress. The players
    will also synchronize the server’s world with their game instance world, which
    also means they will be able to see all the other players that are currently playing
    as well and interact with one another. It’s fundamentally a prototype that you
    can expand to a **Massive Multiplayer Online Role Playing Game** (**MMORPG**)
    if you want.
  prefs: []
  type: TYPE_NORMAL
