<html><head></head><body>
<div id="_idContainer049">
<h1 class="chapter-number" id="_idParaDest-152"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-153"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.2.1">Local Bus Interfaces</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The communication between an embedded system and other systems in its vicinity is enabled by a few protocols. </span><span class="koboSpan" id="kobo.3.2">Most microcontrollers designed for embedded systems support the most common interfaces that control and discipline the access to serial lines. </span><span class="koboSpan" id="kobo.3.3">Some of these protocols are so popular that they have become the standard for wired inter-chip communication among microcontrollers, and for controlling electronic devices, such as sensors, actuators, displays, wireless transceivers, and many other peripherals. </span><span class="koboSpan" id="kobo.3.4">This chapter describes how these protocols work, specifically focusing on the implementation of the system software, through examples running on the reference platform. </span><span class="koboSpan" id="kobo.3.5">In particular, we will cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.5.1">Introducing </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">serial communication</span></span></li>
<li><span class="koboSpan" id="kobo.7.1">A UART-based asynchronous </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">serial bus</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">An </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">SPI bus</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">An </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">I</span></span><span class="No-Break"><span class="superscript"><span class="koboSpan" id="kobo.13.1">2</span></span></span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">C bus</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.15.1">By the end of this chapter, you will learn how to integrate the common serial </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">communication protocols.</span></span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.18.1">You can find the code files for this chapter on GitHub at  </span><a href="https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter7"><span class="No-Break"><span class="koboSpan" id="kobo.19.1">https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter7</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.20.1">.</span></span></p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.21.1">Introducing serial communication</span></h1>
<p><span class="koboSpan" id="kobo.22.1">All the protocols that we will analyze in this chapter manage the access to a serial bus, which may consist of one or more wires, transporting the information in the form of electrical signals corresponding to</span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.23.1"> logic levels zeros and ones, when associated with specific time intervals. </span><span class="koboSpan" id="kobo.23.2">The protocols are different in the way they transmit and receive information on the data bus lines. </span><span class="koboSpan" id="kobo.23.3">To transmit a byte, the transceiver encodes it as a bit sequence, which is synchronized with a clock. </span><span class="koboSpan" id="kobo.23.4">The logic values of the bit are interpreted by the receiver reading its value on a specific front of the clock, depending on the </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">clock’s polarity.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">Each protocol specifies the polarity of the clock and the bit order required to transmit the data, which can start with either the most significant or the least significant bit. </span><span class="koboSpan" id="kobo.25.2">For example, a system transmitting the ASCII character </span><em class="italic"><span class="koboSpan" id="kobo.26.1">D</span></em><span class="koboSpan" id="kobo.27.1"> over a serial line regulated by raising clock fronts, with the most significant bit first, would produce a signal such as </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.29.1"><img alt="Figure 7.1 – The logic levels of the bus on clock raise fronts are interpreted MSB-first into the byte value of 0x44" src="image/B18730_07_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.30.1">Figure 7.1 – The logic levels of the bus on clock raise fronts are interpreted MSB-first into the byte value of 0x44</span></p>
<p><span class="koboSpan" id="kobo.31.1">We will now define the characteristics of serial communication interfaces following different standards. </span><span class="koboSpan" id="kobo.31.2">In particular, we will indicate the options available for clock synchronization between two endpoints exchanging data; the wiring of the signals to be used, which are specified by each protocol to access the physical media; and finally, the implementation details to program the access to the peripheral, which may differ across </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">different platforms.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.33.1">Clock and symbol synchronization</span></h2>
<p><span class="koboSpan" id="kobo.34.1">In order for the receiving side to understand the message, the clock must be synchronized between the parts. </span><span class="koboSpan" id="kobo.34.2">The clock synchronization may be implicit, as in, setting the same data rate to</span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.35.1"> read and write on the bus, or achieved by sharing the clock line from one side using an additional line to explicitly synchronize the transmit data rate. </span><span class="koboSpan" id="kobo.35.2">Serial protocols that do not foresee shared clock lines are </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">called asynchronous.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">Symbol synchronization should be explicit instead. </span><span class="koboSpan" id="kobo.37.2">As we expect to send and receive information in the form of bytes, the beginning of each 8-bit sequence should be marked either using special preamble sequences on the data line or by turning the clock on and off at the right time. </span><span class="koboSpan" id="kobo.37.3">The symbol synchronization strategy is defined differently by </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">each protocol.</span></span><a id="_idTextAnchor235"/></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.39.1">Bus wiring</span></h2>
<p><span class="koboSpan" id="kobo.40.1">The number of lines needed to establish bidirectional communication depends on the specific protocol too. </span><span class="koboSpan" id="kobo.40.2">Since one </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.41.1">wire can only transport 1 bit of information in one direction at a time, to achieve full-duplex communication, a transceiver should connect to two different wires for transmitting and receiving data. </span><span class="koboSpan" id="kobo.41.2">If the protocol supports half-duplex communication, it should provide a reliable mechanism to regulate media access instead and switch between receiving and transmitting data on the </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">same wire.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.43.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.44.1">The two endpoints must share a common reference ground voltage, which means that it might be required to add one extra wire to connect the ground lines if the devices do not already share a </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">common ground.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">Depending on the protocol, devices accessing the bus may either share a similar implementation and act as peers or have different roles assigned when participating in the communication – for example, if a master device is in charge of synchronizing the clock or regulating access to </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">the media.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">A serial protocol may foresee communication among more than two devices on the same bus. </span><span class="koboSpan" id="kobo.48.2">This may be achieved by using extra slave selection wires, one per slave device sharing the same bus, or by assigning logical addresses to each endpoint, and including the destination address for the communication in the preamble of each transmission. </span><span class="koboSpan" id="kobo.48.3">Based on these</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.49.1"> classifications, an overview of the approach taken by the most popular serial protocols implemented in embedded targets is given in the </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">following table:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.51.1"><img alt="" src="image/B18730_07.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.52.1">The protocols that</span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.53.1"> are detailed in this chapter are only the first three, as they are the most widely used in communicating with </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">embedded peripherals.</span></span><a id="_idTextAnchor237"/></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.55.1">Programming the peripherals</span></h2>
<p><span class="koboSpan" id="kobo.56.1">Multiple peripherals implementing</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.57.1"> the protocols described so far are usually integrated into microcontrollers, which means that the associated serial bus can be directly connected to specific pins of the microcontrollers. </span><span class="koboSpan" id="kobo.57.2">The peripherals can be enabled through clock gating and controlled by accessing configuration registries mapped in the peripheral region in the memory space. </span><span class="koboSpan" id="kobo.57.3">The pins connected to serial buses must also be configured to implement the corresponding alternate function, and the interrupt lines involved should be configured to be handled in the </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">vector table.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Some microcontrollers, including our reference platform, support </span><strong class="bold"><span class="koboSpan" id="kobo.60.1">Direct Memory Access</span></strong><span class="koboSpan" id="kobo.61.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.62.1">DMA</span></strong><span class="koboSpan" id="kobo.63.1">) to speed up memory</span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.64.1"> operations between the peripheral and the physical RAM. </span><span class="koboSpan" id="kobo.64.2">In many cases, this feature is useful to help process the communication data in a shorter time</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.65.1"> frame and to improve the responsiveness of the system. </span><span class="koboSpan" id="kobo.65.2">The DMA controller can be programmed to initiate a transfer operation and trigger an interrupt when </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">it completes.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">The interface to control the features relative to each protocol is specific to the functionalities exposed by the peripheral. </span><span class="koboSpan" id="kobo.67.2">In the next sections, the interfaces exposed by UART, SPI, and I</span><span class="superscript"><span class="koboSpan" id="kobo.68.1">2</span></span><span class="koboSpan" id="kobo.69.1">C peripherals are analyzed, and code samples tailored to the reference platform are provided as examples of one of the possible implementations for similar </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">device drive</span><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.71.1">rs.</span></span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.72.1">UART-based asynchronous serial bus</span></h1>
<p><span class="koboSpan" id="kobo.73.1">Historically used for many </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.74.1">different purposes, thanks to the simplicity of its asynchronous nature, UART dates back to the origins of computing, and it is still a very popular circuit used in many contexts. </span><span class="koboSpan" id="kobo.74.2">Personal computers up to the early 2000s included at least one RS-232 serial port, realized with a UART controller and the transceivers allowing to operate at higher voltages. </span><span class="koboSpan" id="kobo.74.3">Nowadays, the USB has replaced serial communication on personal computers, but host computers can still access TTL serial buses using USB-UART peripherals. </span><span class="koboSpan" id="kobo.74.4">Microcontrollers have one or more pairs of pins that can be associated with an internal UART controller and connected to a serial bus to configure a bidirectional, asynchronous, full-duplex communication channel toward a device connected to the </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">same </span><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.76.1">bus.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.77.1">Protocol description</span></h2>
<p><span class="koboSpan" id="kobo.78.1">As previously mentioned, asynchronous </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.79.1">serial communications rely on implicit synchronization of the bit rate between the transmitter and the receiver in order to guarantee that the data is correctly processed on the receiving end of the communication. </span><span class="koboSpan" id="kobo.79.2">If the peripheral clock is fast enough to keep the device running at a high frequency, asynchronous serial communication may be pushed up to several megabits </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">per second.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">The symbol synchronization strategy is based on the identification of the beginning of the transmission of every single byte on the wire. </span><span class="koboSpan" id="kobo.81.2">When no device is transmitting, the bus is in an </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">idle state.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">To initiate the</span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.84.1"> transmission, the transceiver pulls the TX line down to the low logic level, for a period of time that is at least half of the bit sampling period depending on the bit rate. </span><span class="koboSpan" id="kobo.84.2">The bits composing the byte being transferred are then translated into logical </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">0</span></strong><span class="koboSpan" id="kobo.86.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">1</span></strong><span class="koboSpan" id="kobo.88.1"> values, which are held on the TX line for the time corresponding to each bit, according to the bit rate. </span><span class="koboSpan" id="kobo.88.2">After this start condition is easily recognized by the receiver, the bits composing the symbol follow in a specific order, from the least significant bit up to the most </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">significant one.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">The number of data bits composing the symbol is also configurable. </span><span class="koboSpan" id="kobo.90.2">The default data length of 8 bits allows each symbol to be converted into a byte. </span><span class="koboSpan" id="kobo.90.3">At the end of the data, an optional parity bit can be configured to count the number of active bits, as a very simplistic form of a redundant check. </span><span class="koboSpan" id="kobo.90.4">The parity bit, if present, can be configured to indicate whether the number of </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">1</span></strong><span class="koboSpan" id="kobo.92.1"> values in the symbol is odd or even. </span><span class="koboSpan" id="kobo.92.2">While returning to the idle state, 1 or 2 stop bits must be used to indicate the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">the symbol.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">A stop bit is transmitted by pulling the signal high for the entire duration of a bit transmission, marking the end of the current symbol, and forcing the receiver to initiate receiving the next one. </span><span class="koboSpan" id="kobo.94.2">A 1-stop bit is the most used default; the 1.5- and 2-stop bit settings provide a longer inter-symbol idling interval, which was useful in the past to communicate with slower, less responsive hardware but is rarely </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">used today.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">The two endpoints must be aware of these settings before initiating the communication. </span><span class="koboSpan" id="kobo.96.2">Serial controllers do not normally support the dynamic detection of the symbol rate or of any of the settings from the device connected to the other end, and, for this reason, the only way to successfully attempt any serial communication is to program both devices on the bus using the same well-known settings. </span><span class="koboSpan" id="kobo.96.3">As a recap, these settings are </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.98.1">The bit rate, expressed in bits </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">per second</span></span></li>
<li><span class="koboSpan" id="kobo.100.1">The number of data bits in each symbol (</span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">typically 8)</span></span></li>
<li><span class="koboSpan" id="kobo.102.1">The meaning of parity bit, if present (</span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">O</span></strong><span class="koboSpan" id="kobo.104.1"> is odd, </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">E</span></strong><span class="koboSpan" id="kobo.106.1"> is even, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">N</span></strong><span class="koboSpan" id="kobo.108.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">not present)</span></span></li>
<li><span class="koboSpan" id="kobo.110.1">The number of </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">stop bits</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.112.1">Additionally, the sender must be configured to send 1, 1.5, or 2 stop bits at the end of each transmission. </span><span class="koboSpan" id="kobo.112.2">1.5 and 2 stop bits were more widely used in the past to synchronize communication with ancient electromechanical devices. </span><span class="koboSpan" id="kobo.112.3">Nowadays, parity checks and stop bits greater</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.113.1"> than 1 are not needed for communications using modern transceivers and are </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">rarely used.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">This group of settings is often abbreviated into something such as 115200-8-N-1 or 38400-8-O-2 to indicate, respectively, a 115.2 Kbps serial line with 8 data bits per symbol, no parity and 1 stop bit, and a 38400 line with the same data bits, odd parity, and 2 </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">sto</span><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.117.1">p bits.</span></span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.118.1">Programming the controller</span></h2>
<p><span class="koboSpan" id="kobo.119.1">Development boards </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.120.1">usually provide multiple UARTs, and our reference, the STM32F407, is not an exception. </span><span class="koboSpan" id="kobo.120.2">According to the manual, </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">UART3</span></strong><span class="koboSpan" id="kobo.122.1"> can be associated with the PD8 (TX) and PD9 (RX) pins, which we will use in this example. </span><span class="koboSpan" id="kobo.122.2">The code needed to turn on the clock for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">D</span></strong><span class="koboSpan" id="kobo.124.1"> GPIO group and set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">8</span></strong><span class="koboSpan" id="kobo.126.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">9</span></strong><span class="koboSpan" id="kobo.128.1"> pins in alternate mode, with an alternate function of </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">7</span></strong><span class="koboSpan" id="kobo.130.1">, is </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.132.1">
#define AHB1_CLOCK_ER (*(volatile uint32_t *)(0x40023830))
#define GPIOD_AHB1_CLOCK_ER (1 &lt;&lt; 3)
#define GPIOD_BASE 0x40020c00
#define GPIOD_MODE (*(volatile uint32_t *)(GPIOD_BASE + 0x00))
#define GPIOD_AFL (*(volatile uint32_t *)(GPIOD_BASE + 0x20))
#define GPIOD_AFH (*(volatile uint32_t *)(GPIOD_BASE + 0x24))
#define GPIO_MODE_AF (2)
#define UART3_PIN_AF (7)
#define UART3_RX_PIN (9)
#define UART3_TX_PIN (8)
static void uart3_pins_setup(void)
{
  uint32_t reg;
  AHB1_CLOCK_ER |= GPIOD_AHB1_CLOCK_ER;
  reg = GPIOD_MODE &amp; ~ (0x03 &lt;&lt; (UART3_RX_PIN * 2));
  GPIOD_MODE = reg | (2 &lt;&lt; (UART3_RX_PIN * 2));
  reg = GPIOD_MODE &amp; ~ (0x03 &lt;&lt; (UART3_TX_PIN * 2));
  GPIOD_MODE = reg | (2 &lt;&lt; (UART3_TX_PIN * 2));
  reg = GPIOD_AFH &amp; ~(0xf &lt;&lt; ((UART3_TX_PIN - 8) * 4));
  GPIOD_AFH = reg | (UART3_PIN_AF &lt;&lt; ((UART3_TX_PIN - 8) *
     4));
  reg = GPIOD_AFH &amp; ~(0xf &lt;&lt; ((UART3_RX_PIN - 8) * 4));
  GPIOD_AFH = reg | (UART3_PIN_AF &lt;&lt; ((UART3_RX_PIN - 8) *
     4));
}</span></pre>
<p><span class="koboSpan" id="kobo.133.1">The device has its own </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.134.1">clock-gating configuration bit in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">APB1_CLOCK_ER</span></strong><span class="koboSpan" id="kobo.136.1"> register, at </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">position </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">18</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.140.1">
#define APB1_CLOCK_ER (*(volatile uint32_t *)(0x40023840))
#define UART3_APB1_CLOCK_ER_VAL (1 &lt;&lt; 18)</span></pre>
<p><span class="koboSpan" id="kobo.141.1">Each UART controller can be accessed using registers mapped in the peripheral region, with fixed offsets from the UART controller </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">base address:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.143.1">UART Status Register (SR)</span></strong><span class="koboSpan" id="kobo.144.1">: A read-only</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.145.1"> register containing status flags, with an offset equal </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">0</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.148.1">UART_Data Register (DR)</span></strong><span class="koboSpan" id="kobo.149.1">: A read/write </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.150.1">data register, with an offset equal </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">4</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.153.1">UART Bit Rate Register (BRR)</span></strong><span class="koboSpan" id="kobo.154.1">: This sets</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.155.1"> the clock divisor to obtain the desired bit rate, offset equal </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">8</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.158.1">UART Configuration Registers (CRxs)</span></strong><span class="koboSpan" id="kobo.159.1">: One or more </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">UART_CRx</span></strong><span class="koboSpan" id="kobo.161.1"> registers at offset </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">12</span></strong><span class="koboSpan" id="kobo.163.1">, to set the serial port</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.164.1"> parameters, enable interrupts and DMA, and enable and disable </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">the transceiver</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.166.1">In this example, we </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.167.1">define shortcut macros to access the following registers </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">UART3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.171.1">
#define UART3 (0x40004800)
#define UART3_SR (*(volatile uint32_t *)(UART3))
#define UART3_DR (*(volatile uint32_t *)(UART3 + 0x04))
#define UART3_BRR (*(volatile uint32_t *)(UART3 + 0x08))
#define UART3_CR1 (*(volatile uint32_t *)(UART3 + 0x0c))
#define UART3_CR2 (*(volatile uint32_t *)(UART3 + 0x10))</span></pre>
<p><span class="koboSpan" id="kobo.172.1">We define the positions in the corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">bit fields:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
#define UART_CR1_UART_ENABLE (1 &lt;&lt; 13)
#define UART_CR1_SYMBOL_LEN (1 &lt;&lt; 12)
#define UART_CR1_PARITY_ENABLED (1 &lt;&lt; 10)
#define UART_CR1_PARITY_ODD (1 &lt;&lt; 9)
#define UART_CR1_TX_ENABLE (1 &lt;&lt; 3)
#define UART_CR1_RX_ENABLE (1 &lt;&lt; 2)
#define UART_CR2_STOPBITS (3 &lt;&lt; 12)
#define UART_SR_TX_EMPTY (1 &lt;&lt; 7)</span></pre>
<p><span class="koboSpan" id="kobo.175.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">uart3_pins_setup</span></strong><span class="koboSpan" id="kobo.177.1"> helper function can be called at the beginning of the initialization function to set up the pin. </span><span class="koboSpan" id="kobo.177.2">The function accepts arguments to set the bit rate, parity bit, and stop</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.178.1"> bits on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">UART3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.180.1"> port:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.181.1">
int uart3_setup(uint32_t bitrate, uint8_t data,
char parity, uint8_t stop)
{
  uart3_pins_setup();</span></pre>
<p><span class="koboSpan" id="kobo.182.1">The device is </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">turned on:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.184.1">
  APB1_CLOCK_ER |= UART3_APB1_CLOCK_ER_VAL;</span></pre>
<p><span class="koboSpan" id="kobo.185.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">CR1</span></strong><span class="koboSpan" id="kobo.187.1"> configuration register, the bit to enable the transmitter </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">is set:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.189.1">
  UART3_CR1 |= UART_CR1_TX_ENABLE;</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">UART_BRR</span></strong><span class="koboSpan" id="kobo.191.1"> is set to contain the divisor between the clock speed and the desired </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">bit rate:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.193.1">
  UART3_BRR = CLOCK_SPEED / bitrate;</span></pre>
<p><span class="koboSpan" id="kobo.194.1">Our function also accepts a character to indicate the desired parity. </span><span class="koboSpan" id="kobo.194.2">The options are </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">O</span></strong><span class="koboSpan" id="kobo.196.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">E</span></strong><span class="koboSpan" id="kobo.198.1"> for odd or even. </span><span class="koboSpan" id="kobo.198.2">Any other character will keep the </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">parity disabled:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.200.1">
  /* Default: No parity */
  UART3_CR1 &amp;= ~(UART_CR1_PARITY_ENABLED | 
      UART_CR1_PARITY_ODD);
   switch (parity) {
       case 'O':
           UART3_CR1 |= UART_CR1_PARITY_ODD;
           /* fall through to enable parity */
       case 'E':
           UART3_CR1 |= UART_CR1_PARITY_ENABLED;
           break;
}</span></pre>
<p><span class="koboSpan" id="kobo.201.1">The number of stop bits is</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.202.1"> set according to the parameter. </span><span class="koboSpan" id="kobo.202.2">The configuration is stored using 2 bits of the register, with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">0</span></strong><span class="koboSpan" id="kobo.204.1"> meaning 1 stop bit, and a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">2</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.206.1">meaning 2:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
  reg = UART3_CR2 &amp; ~UART_CR2_STOPBITS;
  if (stop &gt; 1)
    UART3_CR2 = reg | (2 &lt;&lt; 12);</span></pre>
<p><span class="koboSpan" id="kobo.208.1">The configuration is now complete. </span><span class="koboSpan" id="kobo.208.2">The UART can be turned on to </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">initiate transmissions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.210.1">
  UART3_CR1 |= UART_CR1_UART_ENABLE;
  return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.211.1">Serial data can now be transmitted on PD8 simply by copying one byte at a time on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">U</span><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.213.1">ART_DR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.214.1"> register.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.215.1">Hello world!</span></h2>
<p><span class="koboSpan" id="kobo.216.1">One of the most useful functions </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.217.1">when developing an embedded system is to convert one of the available UARTs into a logging port, where debug messages and other information produced during the execution can be read on the host computer using a </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">serial-to-USB converter:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.219.1"><img alt="Figure 7.2 – The host is connected to the serial port of the target platform using a converter" src="image/B18730_07_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.220.1">Figure 7.2 – The host is connected to the serial port of the target platform using a converter</span></p>
<p><span class="koboSpan" id="kobo.221.1">The UART logic includes FIFO buffers in both directions. </span><span class="koboSpan" id="kobo.221.2">The transmit FIFO is fed by writing on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">UART_DR</span></strong><span class="koboSpan" id="kobo.223.1"> register. </span><span class="koboSpan" id="kobo.223.2">To actually output data on the UART TX line in polling mode, we choose to check</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.224.1"> that the FIFO is empty before writing each character, to ensure that no more than one character is put in the FIFO at a time. </span><span class="koboSpan" id="kobo.224.2">When the FIFO is empty, the bit associated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">TX_FIFO_EMPTY</span></strong><span class="koboSpan" id="kobo.226.1"> flag in </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">UART3_SR</span></strong><span class="koboSpan" id="kobo.228.1"> is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">1</span></strong><span class="koboSpan" id="kobo.230.1"> by the device. </span><span class="koboSpan" id="kobo.230.2">The following function shows how to transmit an entire string of characters passed as an argument, waiting for the FIFO to empty after </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">every byte:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.232.1">
void uart3_write(const char *text)
{
  const char *p = text;
  int i;
  volatile uint32_t reg;
  while(*p) {
    do {
      reg = UART3_SR;
    } while ((reg &amp; UART_SR_TX_EMPTY) == 0);
    UART3_DR = *p;
    p++;
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.233.1">In the main program, it is possible to call this function with a pre-formatted, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">NULL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">-terminated string:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.236.1">
#include "system.h"
#include "uart.h"
void main(void) {
  flash_set_waitstates();
  clock_config();
  uart3_setup(115200, 8, 'N', 1);
  uart3_write("Hello World!\r\n");
  while(1)
    WFI();
}</span></pre>
<p><span class="koboSpan" id="kobo.237.1">If the host is connected to the other </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.238.1">endpoint of the serial bus, as a result, we can visualize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">Hello World!</span></strong><span class="koboSpan" id="kobo.240.1"> message using a serial terminal program, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">minicom</span></strong><span class="koboSpan" id="kobo.242.1">, on </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">the host.</span></span></p>
<p><span class="koboSpan" id="kobo.244.1">By capturing the output of the PD8 pin, used as </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">UART_TX</span></strong><span class="koboSpan" id="kobo.246.1"> on the target, and setting the right option for the serial decoding, we have a better idea of how the serial flow is parsed on the receiving side. </span><span class="koboSpan" id="kobo.246.2">The logic analyzer can show how the data bits are sampled after every start condition, and reveal the ASCII character associated with the byte on the wire. </span><span class="koboSpan" id="kobo.246.3">Logic analyzer tools are usually capable of decoding the bits captured on the wire, and showing each byte transmitted back into its ASCII format. </span><span class="koboSpan" id="kobo.246.4">This feature offers a quick and accurate way to verify that our serial communication is compliant, the time in between the consecutive bits respects the selected baud rate, and the content on the wire matches the data sent to the UART transceiver, as in the following figure, which shows our embedded target sending “</span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">Hello</span></strong><span class="koboSpan" id="kobo.248.1">” from the string and passing it to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">uart3_write</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.250.1"> function.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.251.1"><img alt="Figure 7.3 – Screenshot of the logic analyzer tool showing the first 5 bytes sent by the example to the﻿ host using UART3" src="image/B18730_07_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.252.1">Figure 7.3 – Screenshot of the logic analyzer tool showing the first 5 bytes sent by the example to the</span><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.253.1"> host using UART3</span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.254.1">newlib printf</span></h2>
<p><span class="koboSpan" id="kobo.255.1">Writing pre-formatted strings is not the most ideal API for accessing a serial port to provide debugging messages. </span><span class="koboSpan" id="kobo.255.2">Application</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.256.1"> developers would most certainly prefer if the system exposed a standard C </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">printf</span></strong><span class="koboSpan" id="kobo.258.1"> function. </span><span class="koboSpan" id="kobo.258.2">When the toolchain includes an implementation of a standard C library, it usually gives you the possibility to connect the standard output of the main program to a serial interface. </span><span class="koboSpan" id="kobo.258.3">Luckily enough, the toolchain in use for the reference platform allows us to link to </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">newlib</span></strong><span class="koboSpan" id="kobo.260.1"> functions. </span><span class="koboSpan" id="kobo.260.2">Similar to what we did in </span><a href="B18730_05.xhtml#_idTextAnchor149"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.261.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.262.1">, </span><em class="italic"><span class="koboSpan" id="kobo.263.1">Memory Management</span></em><span class="koboSpan" id="kobo.264.1">, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">malloc</span></strong><span class="koboSpan" id="kobo.266.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">free</span></strong><span class="koboSpan" id="kobo.268.1"> functions from </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">newlib</span></strong><span class="koboSpan" id="kobo.270.1">, we provide a backend function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">_write()</span></strong><span class="koboSpan" id="kobo.272.1">, which gets the output redirected from the string formatted by all the calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">printf()</span></strong><span class="koboSpan" id="kobo.274.1">. </span><span class="koboSpan" id="kobo.274.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">_write</span></strong><span class="koboSpan" id="kobo.276.1"> function implemented here will receive all the strings pre-formatted </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">printf()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.280.1">
int _write(void *r, uint8_t *text, int len)
{
  char *p = (char *)text;
  int i;
  volatile uint32_t reg;
  text[len - 1] = 0;
  while(*p) {
    do {
       reg = UART3_SR;
    } while ((reg &amp; UART_SR_TX_EMPTY) == 0);
    UART3_DR = *p;
    p++;
  }
  return len;
}</span></pre>
<p><span class="koboSpan" id="kobo.281.1">So, in this case, linking with </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">newlib</span></strong><span class="koboSpan" id="kobo.283.1"> allows us to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">printf</span></strong><span class="koboSpan" id="kobo.285.1"> to produce messages, including its variance-argument </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.286.1">parsing, as in this example </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">main()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.288.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.289.1">
#include &lt;stdio.h&gt;
#include "system.h"
#include "uart.h"
void main(void) {
  char name[] = "World";
  flash_set_waitstates();
  clock_config();
  uart3_setup(115200, 8, 'N', 1);
  printf("Hello %s!\r\n", name);
  while(1)
    WFI();</span></pre>
<p><span class="koboSpan" id="kobo.290.1">This second example will produce the same output as the first one, but this time, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">printf</span></strong><span class="koboSpan" id="kobo.292.1"> fu</span><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.293.1">nction </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">newlib</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">.</span></span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.297.1">Receiving data</span></h2>
<p><span class="koboSpan" id="kobo.298.1">To enable the receiver on the same UART, the initialization function should also turn on the receiver using the corresponding switch in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">UART_CR1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.300.1"> register:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
UART3_CR1 |= UART_CR1_TX_ENABLE | UART_CR1_RX_ENABLE;</span></pre>
<p><span class="koboSpan" id="kobo.302.1">This ensures that the</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.303.1"> receiving side of the transceiver is enabled too. </span><span class="koboSpan" id="kobo.303.2">To read data in polling mode, blocking until a character is received, we can use the following function, which will return the value of the </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">byte read:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.305.1">
char uart3_read(void)
{
  char c;
  volatile uint32_t reg;
  do {
    reg = UART3_SR;
  } while ((reg &amp; UART_SR_RX_NOTEMPTY) == 0);
  c = (char)(UART3_DR &amp; 0xff);
  return c;
}</span></pre>
<p><span class="koboSpan" id="kobo.306.1">This way, we can, for example, echo back to the console each character received from </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">the host:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.308.1">
void main(void) {
  char c[2];
  flash_set_waitstates();
  clock_config();
  uart3_setup(115200, 8, 'N', 1);
  uart3_write("Hello World!\r\n");
  while(1) {
    c[0] = uart3_read();
    c[1] = 0;
    uart3_write(c);
    uart3_write("\r\n");
  }
}</span></pre>
<h2 id="_idParaDest-165"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.309.1">Interrupt-based input/output</span></h2>
<p><span class="koboSpan" id="kobo.310.1">The examples in this section are based on polling the status of the UART by continuously checking the flags of </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">UART_SR</span></strong><span class="koboSpan" id="kobo.312.1">. </span><span class="koboSpan" id="kobo.312.2">The write operation contains a busy loop that can spin for several milliseconds, depending on the length of the string. </span><span class="koboSpan" id="kobo.312.3">Even worse, the read function presented earlier spins within </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.313.1">a busy loop until there is data to read from the peripheral, which means that the whole system is hanging until new data is received. </span><span class="koboSpan" id="kobo.313.2">In a single-thread embedded system, returning to the main loop with the shortest latency possible is important to keep the </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">system responsive.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">The correct way to perform UART communication without blocking is by using the interrupt line associated with the UART to trigger actions based on the event received. </span><span class="koboSpan" id="kobo.315.2">UART can be configured to raise the interrupt signal upon multiple types of events. </span><span class="koboSpan" id="kobo.315.3">As we have seen in the previous examples, to regulate input and output operations, we are interested in particular in two </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">specific events:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.317.1">A TX FIFO empty event, allowing more data to </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">be transmitted</span></span></li>
<li><span class="koboSpan" id="kobo.319.1">A RX FIFO not-empty event, signaling the presence of newly </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">received data</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.321.1">The interrupt for these two events can be enabled by setting the corresponding bits in </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">UART_CR1</span></strong><span class="koboSpan" id="kobo.323.1">. </span><span class="koboSpan" id="kobo.323.2">We define two helper functions with the purpose of turning interrupts on and </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">off, independently:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.325.1">
#define UART_CR1_TXEIE (1 &lt;&lt; 7)
#define UART_CR1_RXNEIE (1 &lt;&lt; 5)
static void uart3_tx_interrupt_onoff(int enable)
{
  if (enable)
    UART3_CR1 |= UART_CR1_TXEIE;
  else
    UART3_CR1 &amp;= ~UART_CR1_TXEIE;
}
static void uart3_rx_interrupt_onoff(int enable)
{
  if (enable)
    UART3_CR1 |= UART_CR1_RXNEIE;
  else
    UART3_CR1 &amp;= ~UART_CR1_RXNEIE;
}</span></pre>
<p><span class="koboSpan" id="kobo.326.1">A service routine can be </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.327.1">associated with the interrupt events, and then check the flags in </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">UART_SR</span></strong><span class="koboSpan" id="kobo.329.1"> to identify the cause of </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">the interrupt:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">
void isr_uart3(void)
{
  volatile uint32_t reg;
  reg = UART3_SR;
  if (reg &amp; UART_SR_RX_NOTEMPTY) {
     /* Receive a new byte */
  }
  if ((reg &amp; UART_SR_TX_EMPTY)
  {
     /* resume pending transmission */
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.332.1">The implementation of the interrupt routine depends on the specific system design. </span><span class="koboSpan" id="kobo.332.2">An RTOS may decide to multiplex access to the serial port to multiple threads and wake up threads waiting to access the resource. </span><span class="koboSpan" id="kobo.332.3">In a single-thread application, it is possible to add intermediate system buffers to provide non-blocking calls, which return immediately after</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.333.1"> copying the data from the receiving buffer, or to the transmitting one. </span><span class="koboSpan" id="kobo.333.2">The interrupt service routine fills the receiving buffer with new data from the bus and transmits the data from the pending buffer. </span><span class="koboSpan" id="kobo.333.3">Using appropriate structures, such as circular buffers to implement system input and output queues, ensures that the use of the memory</span><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.334.1"> assigned </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">is optimized.</span></span></p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.336.1">SPI bus</span></h1>
<p><span class="koboSpan" id="kobo.337.1">The SPI bus provides a different approach, based on master-slave communication. </span><span class="koboSpan" id="kobo.337.2">As the name suggests, the interface was initially designed to control peripherals. </span><span class="koboSpan" id="kobo.337.3">This is reflected in the design, as all the communication is always initiated by the master on the bus. </span><span class="koboSpan" id="kobo.337.4">Thanks to the full-duplex pin configuration and the synchronized clock, it may be much faster than asynchronous communication, due to the better robustness to clock skews between the systems</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.338.1"> sharing the bus. </span><span class="koboSpan" id="kobo.338.2">An SPI is widely used as a communication protocol for several different devices, due to its simple logic and the flexibility given by the fact that the slave does not have to be preconfigured to communicate at a predefined speed that matches the one on the master. </span><span class="koboSpan" id="kobo.338.3">Multiple peripherals can share the same bus, as long as media access strategies are defined. </span><span class="koboSpan" id="kobo.338.4">A common way for a master to control one peripheral at a time is by using separate GPIO lines to control the slave selection, although this does require an additio</span><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.339.1">nal wire for </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">each slave.</span></span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.341.1">Protocol description</span></h2>
<p><span class="koboSpan" id="kobo.342.1">The configuration of the SPI transceiver</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.343.1"> is very flexible. </span><span class="koboSpan" id="kobo.343.2">Usually, a transceiver on a microcontroller is able to act as a master as well as a slave. </span><span class="koboSpan" id="kobo.343.3">A few predefined settings must be known in advance and shared between the master and all the slaves on the </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">same bus:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.345.1">The clock polarity, indicating whether the clock tick corresponds to a raising or a falling edge of </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">the clock</span></span></li>
<li><span class="koboSpan" id="kobo.347.1">The clock phase, indicating whether the clock idle position is high </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">or low</span></span></li>
<li><span class="koboSpan" id="kobo.349.1">The length of the data packet, any value between 4 and </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">16 bits</span></span></li>
<li><span class="koboSpan" id="kobo.351.1">The bit order, indicating whether the data is transmitted starting from the most significant bit or the least </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">significant bit</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.353.1">Since the clock is </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.354.1">synchronous and imposed by the master at all times, the SPI does not have a predefined frequency of operation, although using too high a speed might not work with all peripherals </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">and microcontrollers.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">SPI communication toward a slave is disabled until the master initiates a transaction. </span><span class="koboSpan" id="kobo.356.2">At the beginning of each transaction, the master selects the slave by activating its </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">slave-select line:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.358.1"><img alt="Figure 7.4 – An additional signal may be used to select a specific slave on the bus" src="image/B18730_07_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.359.1">Figure 7.4 – An additional signal may be used to select a specific slave on the bus</span></p>
<p><span class="koboSpan" id="kobo.360.1">To initiate the communication, the master must activate the clock, and may send a command sequence to the slave on the MOSI line. </span><span class="koboSpan" id="kobo.360.2">When the clock is detected, the slave can immediately start transferring bytes in the opposite direction using the </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">MISO line.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">Even if the master has finished transmitting, it must comply with the protocol implemented by the slave and permit it to reply by keeping the clock alive for the duration of the transaction. </span><span class="koboSpan" id="kobo.362.2">The slave is given a predefined number of byte slots to communicate with </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">the master.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">In order to keep the clock alive even when there is no data to transfer to the slave, the master can keep sending </span><em class="italic"><span class="koboSpan" id="kobo.365.1">dummy</span></em><span class="koboSpan" id="kobo.366.1"> bytes through the MOSI line, which are ignored by the slave. </span><span class="koboSpan" id="kobo.366.2">In the meantime, the slave is allowed to send data through the MISO line, as long as the master ensures that the clock keeps running. </span><span class="koboSpan" id="kobo.366.3">Unlike UART, in the master-slave communication </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.367.1">model implemented in the SPI, the slaves can never spontaneously initiate SPI communication, as the master is the only device on the bus allowed to transmit a clock. </span><span class="koboSpan" id="kobo.367.2">Each SPI transaction is self-contained, and at the end, the slave is deselected by turning off the correspo</span><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.368.1">nding </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">slave-select signal.</span></span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.370.1">Programming the transceiver</span></h2>
<p><span class="koboSpan" id="kobo.371.1">On the reference board, an </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.372.1">accelerometer is connected as a slave to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">SPI1</span></strong><span class="koboSpan" id="kobo.374.1"> bus, so we can examine how to implement the master side of the communication on the microcontroller by configuring the transceiver and executing a bidirectional transaction toward </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">the peripheral.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">SPI1</span></strong><span class="koboSpan" id="kobo.378.1"> bus has its configuration registers mapped in the </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">peripherals region:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.380.1">
#define SPI1 (0x40013000)
#define SPI1_CR1 (*(volatile uint32_t *)(SPI1))
#define SPI1_CR2 (*(volatile uint32_t *)(SPI1 + 0x04))
#define SPI1_SR (*(volatile uint32_t *)(SPI1 + 0x08))
#define SPI1_DR (*(volatile uint32_t *)(SPI1 + 0x0c))</span></pre>
<p><span class="koboSpan" id="kobo.381.1">The peripheral exposes a total of </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">four registers:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.383.1">Two bit-field </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">configuration registers</span></span></li>
<li><span class="koboSpan" id="kobo.385.1">One </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">status register</span></span></li>
<li><span class="koboSpan" id="kobo.387.1">One bidirectional </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">data register</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.389.1">It is clear that the interface is similar to that of the UART transceiver, as the configuration of the communication parameters goes through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">SPI_CRx</span></strong><span class="koboSpan" id="kobo.391.1"> registers, the status of the FIFO can be monitored by looking at </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">SPI_SR</span></strong><span class="koboSpan" id="kobo.393.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">SPI_DR</span></strong><span class="koboSpan" id="kobo.395.1"> can be used to read and write data to the </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">serial bus.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">The value for the configuration register CR1 contains </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.399.1">The clock phase, 0 or 1, in </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">bit 0</span></span></li>
<li><span class="koboSpan" id="kobo.401.1">The clock polarity in </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">bit 1</span></span></li>
<li><span class="koboSpan" id="kobo.403.1">The SPI master mode flag in </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">bit 2</span></span></li>
<li><span class="koboSpan" id="kobo.405.1">The bit rate scaling factor in </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">bits 3-5</span></span></li>
<li><span class="koboSpan" id="kobo.407.1">The SPI enable flag in </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">bit 6</span></span></li>
<li><span class="koboSpan" id="kobo.409.1">Other configuration </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.410.1">parameters, such as the word length, LSB-first, and other flags, which will not be used in this example, as the default will be kept for </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">these parameters</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.412.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">CR2</span></strong><span class="koboSpan" id="kobo.414.1"> configuration register contains the flags to enable the interrupt events and the DMA transfers, as</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.415.1"> well as the </span><strong class="bold"><span class="koboSpan" id="kobo.416.1">Slave Select Output Enable</span></strong><span class="koboSpan" id="kobo.417.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.418.1">SSOE</span></strong><span class="koboSpan" id="kobo.419.1">) flag, which is relevant in </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">this example.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">SPI1_SR</span></strong><span class="koboSpan" id="kobo.423.1"> status register is similar to the UART status register in the previous section, as it contains flags to determine whether the transmit FIFO is empty, and when the FIFO on the receiving side is not empty, to regulate the phases of </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">the transfer.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">The bits corresponding to the flags that are used in this example are defined </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.427.1">
#define SPI_CR1_MASTER (1 &lt;&lt; 2)
#define SPI_CR1_SPI_EN (1 &lt;&lt; 6)
#define SPI_CR2_SSOE (1 &lt;&lt; 2)
#define SPI_SR_RX_NOTEMPTY (1 &lt;&lt; 0)
#define SPI_SR_TX_EMPTY (1 &lt;&lt; 1)</span></pre>
<p><span class="koboSpan" id="kobo.428.1">The RCC controls the clock and the reset lines toward the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">SPI1</span></strong><span class="koboSpan" id="kobo.430.1"> transceiver connected to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">APB2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.432.1"> bus:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.433.1">
#define APB2_CLOCK_ER (*(volatile uint32_t *)(0x40023844))
#define APB2_CLOCK_RST (*(volatile uint32_t
      *)(0x40023824))
#define SPI1_APB2_CLOCK_ER_VAL (1 &lt;&lt; 12)</span></pre>
<p><span class="koboSpan" id="kobo.434.1">The transceiver can be reset by sending a reset pulse from </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">the RCC:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.436.1">
static void spi1_reset(void)
{
   APB2_CLOCK_RST |= SPI1_APB2_CLOCK_ER_VAL;
   APB2_CLOCK_RST &amp;= ~SPI1_APB2_CLOCK_ER_VAL;
}</span></pre>
<p><span class="koboSpan" id="kobo.437.1">The PA5, PA6, and PA7 pins can</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.438.1"> be associated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">SPI1</span></strong><span class="koboSpan" id="kobo.440.1"> transceiver by setting the appropriate </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">alternate function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.442.1">
#define SPI1_PIN_AF 5
#define SPI1_CLOCK_PIN 5
#define SPI1_MOSI_PIN 6
#define SPI1_MISO_PIN 7
static void spi1_pins_setup(void)
{
  uint32_t reg;
  AHB1_CLOCK_ER |= GPIOA_AHB1_CLOCK_ER;
  reg = GPIOA_MODE &amp; ~(0x03 &lt;&lt; (SPI1_CLOCK_PIN * 2));
  reg &amp;= ~(0x03 &lt;&lt; (SPI1_MOSI_PIN));
  reg &amp;= ~(0x03 &lt;&lt; (SPI1_MISO_PIN));
  reg |= (2 &lt;&lt; (SPI1_CLOCK_PIN * 2));
  reg |= (2 &lt;&lt; (SPI1_MOSI_PIN * 2)) | (2 &lt;&lt; (SPI1_MISO_PIN
      *2))
  GPIOA_MODE = reg;
  reg = GPIOA_AFL &amp; ~(0xf &lt;&lt; ((SPI1_CLOCK_PIN) * 4));
  reg &amp;= ~(0xf &lt;&lt; ((SPI1_MOSI_PIN) * 4));
  reg &amp;= ~(0xf &lt;&lt; ((SPI1_MISO_PIN) * 4));
  reg |= SPI1_PIN_AF &lt;&lt; ((SPI1_CLOCK_PIN) * 4);
  reg |= SPI1_PIN_AF &lt;&lt; ((SPI1_MOSI_PIN) * 4);
  reg |= SPI1_PIN_AF &lt;&lt; ((SPI1_MISO_PIN) * 4);
  GPIOA_AFL = reg;
}</span></pre>
<p><span class="koboSpan" id="kobo.443.1">The additional pin connected to the “chip select” line of the accelerometer is PE3, which is configured as output, with </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.444.1">a pull-up internal resistor. </span><span class="koboSpan" id="kobo.444.2">The logic</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.445.1"> of this pin is active low so that a logical zero will turn the </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">chip on:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.447.1">
#define SLAVE_PIN 3
static void slave_pin_setup(void)
{
  uint32_t reg;
  AHB1_CLOCK_ER |= GPIOE_AHB1_CLOCK_ER;
  reg = GPIOE_MODE &amp; ~(0x03 &lt;&lt; (SLAVE_PIN * 2));
  GPIOE_MODE = reg | (1 &lt;&lt; (SLAVE_PIN * 2));
  reg = GPIOE_PUPD &amp; ~(0x03 &lt;&lt; (SLAVE_PIN * 2));
  GPIOE_PUPD = reg | (0x01 &lt;&lt; (SLAVE_PIN * 2));
  reg = GPIOE_OSPD &amp; ~(0x03 &lt;&lt; (SLAVE_PIN * 2));
  GPIOE_OSPD = reg | (0x03 &lt;&lt; (SLAVE_PIN * 2));
}</span></pre>
<p><span class="koboSpan" id="kobo.448.1">The initialization of the transceiver begins with the configuration of the four pins involved. </span><span class="koboSpan" id="kobo.448.2">The clock gate</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.449.1"> is then activated, and the transceiver receives a reset via a pulse through </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">the RCC:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.451.1">
void spi1_setup(int polarity, int phase)
{
  spi1_pins_setup();
  slave_pin_setup();
  APB2_CLOCK_ER |= SPI1_APB2_CLOCK_ER_VAL;
  spi1_reset();</span></pre>
<p><span class="koboSpan" id="kobo.452.1">The default parameters (MSB-first, 8-bit word length) are left untouched. </span><span class="koboSpan" id="kobo.452.2">The bit rate scaling factor of this controller is expressed in powers of 2, starting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">2</span></strong><span class="koboSpan" id="kobo.454.1"> corresponding to a bit</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.455.1"> field value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">0</span></strong><span class="koboSpan" id="kobo.457.1">, and doubling at each increment. </span><span class="koboSpan" id="kobo.457.2">A generic driver should calculate the correct scaling factor, according to the desired clock rate and the peripheral clock frequency. </span><span class="koboSpan" id="kobo.457.3">In this simple case, we enforce a hardcoded scaling factor of 64, corresponding to the </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">value </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">SPI1_CR1</span></strong><span class="koboSpan" id="kobo.462.1"> is then set </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.464.1">
  SPI1_CR1 = SPI_CR1_MASTER | (5 &lt;&lt; 3) | (polarity &lt;&lt; 1) | 
      (phase &lt;&lt; 0);</span></pre>
<p><span class="koboSpan" id="kobo.465.1">Finally, we set the bit corresponding to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">SSOE</span></strong><span class="koboSpan" id="kobo.467.1"> flag in </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">SPI1_CR2</span></strong><span class="koboSpan" id="kobo.469.1">, and the transceiver </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">is enabled:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.471.1">
  SPI1_CR2 |= SPI_CR2_SSOE;
  SPI1_CR1 |= SPI_CR1_SPI_EN;
}</span></pre>
<p><span class="koboSpan" id="kobo.472.1">Read and write operations can now begin, as both the master and slave SPI controllers are </span><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.473.1">ready to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">the transactions.</span></span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.475.1">SPI transactions</span></h2>
<p><span class="koboSpan" id="kobo.476.1">The read and write functions</span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.477.1"> represent the two different phases of the SPI transaction. </span><span class="koboSpan" id="kobo.477.2">Most SPI slave devices are capable of communicating using a full-duplex mechanism so that bytes are exchanged in both directions while the clock is active. </span><span class="koboSpan" id="kobo.477.3">During each interval, a byte is transmitted in both directions, using the MISO and MOSI </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">lines independently.</span></span></p>
<p><span class="koboSpan" id="kobo.479.1">A common strategy, implemented by many slaves, consists of accessing registers for read and write operations in the slave devices, by using well-known command handles that are documented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">device’s datasheet.</span></span></p>
<p><span class="koboSpan" id="kobo.481.1">The STM32F407DISCOVERY board has an accelerometer connected to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">SPI1</span></strong><span class="koboSpan" id="kobo.483.1"> bus, which responds to predefined commands accessing specific registers in the device memory for reading or writing. </span><span class="koboSpan" id="kobo.483.2">In these cases, the read and write operations are performed sequentially: during the first interval, the master transmits the command handle, while the device has nothing to transmit, then the actual bytes are transmitted in either direction at </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">subsequent intervals.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">The example operation described here consists of reading the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">WHOAMI</span></strong><span class="koboSpan" id="kobo.487.1"> register in the accelerometer, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">0x8F</span></strong><span class="koboSpan" id="kobo.489.1"> command handle. </span><span class="koboSpan" id="kobo.489.2">The peripheral should respond with 1 byte containing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">0x3B</span></strong><span class="koboSpan" id="kobo.491.1"> value, which correctly identifies the device and proves that the SPI communication is working correctly. </span><span class="koboSpan" id="kobo.491.2">However, during the transmission of the command byte, the device has nothing to transmit yet, so the result of the first read operation can be discarded. </span><span class="koboSpan" id="kobo.491.3">Similarly, after sending the command, the master has nothing else to</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.492.1"> communicate to the slave, so it outputs a </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">0xFF</span></strong><span class="koboSpan" id="kobo.494.1"> value on the MOSI line while reading the byte transmitted by the slave through the MISO line at the </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">same time.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">The steps to perform to successfully perform a 1-byte read on this specific device are </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">as follows:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.498.1">Turn on the slave by pulling down the </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">slave-select signal.</span></span></li>
<li><span class="koboSpan" id="kobo.500.1">Send a byte containing the code for the 1-byte </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">read operation.</span></span></li>
<li><span class="koboSpan" id="kobo.502.1">Send 1 dummy byte while the slave transfers the reply using </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">the clock.</span></span></li>
<li><span class="koboSpan" id="kobo.504.1">Read back the value transferred from the slave during the </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">second interval.</span></span></li>
<li><span class="koboSpan" id="kobo.506.1">Turn off the slave by pulling the slave-select signal </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">back up.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.508.1">To do so, we define blocking read and write functions </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.510.1">
uint8_t spi1_read(void)
{
  volatile uint32_t reg;
  do {
    reg = SPI1_SR;
  } while ((reg &amp; SPI_SR_RX_NOTEMPTY) == 0);
  return (uint8_t)SPI1_DR;
}
void spi1_write(const char byte)
{
  int i;
  volatile uint32_t reg;
  SPI1_DR = byte;
  do {
    reg = SPI1_SR;
  } while ((reg &amp; SPI_SR_TX_EMPTY) == 0);
}</span></pre>
<p><span class="koboSpan" id="kobo.511.1">The read operation waits until the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">RX_NOTEMPTY</span></strong><span class="koboSpan" id="kobo.513.1"> flag is enabled on </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">SPI1_SR</span></strong><span class="koboSpan" id="kobo.515.1"> before transferring the </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.516.1">contents of the data register. </span><span class="koboSpan" id="kobo.516.2">The transmit function instead transfers the value of the byte to transmit onto the data register, and then polls for the end of the operation by waiting for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">TX_EMPTY</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.518.1"> flag.</span></span></p>
<p><span class="koboSpan" id="kobo.519.1">The two operations can now be concatenated. </span><span class="koboSpan" id="kobo.519.2">The master has to explicitly send 2 data bytes in total, so our main application can query the accelerometer identification register by doing </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.521.1">
 slave_on();
 spi1_write(0x8F);
 b = spi1_read();
 spi1_write(0xFF);
 b = spi1_read();
 slave_off();</span></pre>
<p><span class="koboSpan" id="kobo.522.1">This is what happens on </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">the bus:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.524.1">During the first write, the command </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">0x8F</span></strong><span class="koboSpan" id="kobo.526.1"> is sent </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">to MOSI.</span></span></li>
<li><span class="koboSpan" id="kobo.528.1">The value read using the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">spi1_read</span></strong><span class="koboSpan" id="kobo.530.1"> function is the dummy bit that the slave has put into MISO while listening for the incoming command. </span><span class="koboSpan" id="kobo.530.2">The value obtained has no meaning in this particular case – therefore, it </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">is discarded.</span></span></li>
<li><span class="koboSpan" id="kobo.532.1">The second </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.533.1">write puts the dummy bit on the MOSI line, as the master does not have anything else to transmit. </span><span class="koboSpan" id="kobo.533.2">This forces the clock generation for the second byte, which is needed by the slave to reply to </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">the command.</span></span></li>
<li><span class="koboSpan" id="kobo.535.1">The second read processes the reply transferred using the MISO line during the write of the dummy byte from the master. </span><span class="koboSpan" id="kobo.535.2">The value obtained in this second transaction is a valid reply from the slave, according to the description of the command in </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">the documentation.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.537.1">Looking at the serial transaction with the logic analyzer, we can clearly distinguish the two phases, and the alternate relevant content – first, on MOSI to transmit the command, and then on MISO to receive </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">the reply:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.539.1"><img alt="Figure 7.5 – A bidirectional SPI transaction, containing a request from the master and a reply from the slave (from top to bottom: SPI1_MISO, SPI1_MOSI, SLAVE_SELECT, and SPI1_CLOCK)" src="image/B18730_07_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.540.1">Figure 7.5 – A bidirectional SPI transaction, containing a request from the master and a reply from the slave (from top to bottom: SPI1_MISO, SPI1_MOSI, SLAVE_SELECT, and SPI1_CLOCK)</span></p>
<p><span class="koboSpan" id="kobo.541.1">Once again, using blocking operations with a busy loop is a very bad practice. </span><span class="koboSpan" id="kobo.541.2">The reason why it is shown here is to explain the primitive operations needed to successfully complete bidirectional SPI transactions. </span><span class="koboSpan" id="kobo.541.3">In a real embedded system, it is always recommended to use</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.542.1"> interrupt-based transfers to ensure that the CPU is not busy looping while waiting for the transfer to complete. </span><span class="koboSpan" id="kobo.542.2">SPI controllers provide interrupt signals to indicate the state of the FIFO buffers of the controller, in order to synchronize the SPI transaction with the actions required up</span><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.543.1">on data transfers in </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">either direction.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.545.1">Interrupt-based SPI transfers</span></h2>
<p><span class="koboSpan" id="kobo.546.1">The interface to enable the interrupt for the SPI transceiver is in fact very similar to that of UART as seen in the previous</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.547.1"> section. </span><span class="koboSpan" id="kobo.547.2">In order for non-blocking transactions to be correctly implemented, they have to be split between their read and write phases to allow events to trigger the </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">associated actions.</span></span></p>
<p><span class="koboSpan" id="kobo.549.1">Setting these two bits in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">SPI1_CR2</span></strong><span class="koboSpan" id="kobo.551.1"> register will enable the interrupt trigger upon an empty transmit FIFO and a non-empty receive </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">FIFO, respectively:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.553.1">
#define SPI_CR2_TXEIE (1 &lt;&lt; 7)
#define SPI_CR2_RXNEIE (1 &lt;&lt; 6)</span></pre>
<p><span class="koboSpan" id="kobo.554.1">The associated service routine, included in the interrupt vector, can still peek at the values in </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">SPI1_SR</span></strong><span class="koboSpan" id="kobo.556.1"> to advance the transaction to the </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">next phase:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.558.1">
void isr_spi1(void)
{
  volatile uint32_t reg;
  reg = SPI1_SR;
  if (reg &amp; SPI_SR_RX_NOTEMPTY) {
    /* End of transmission: new data available on MISO*/
  }
  if ((reg &amp; SPI_SR_TX_EMPTY)
  {
    /* End of transmission: the TX FIFO is empty*/
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.559.1">Once again, the implementation of the top half of the interrupt is left to the reader, as it depends on the API that the system is required to implement, the nature of the transactions, and </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.560.1">their impact on the responsiveness of the system. </span><span class="koboSpan" id="kobo.560.2">Short, high-speed SPI transactions, however, may be short and scattered in time so that even implementing blocking operations has a </span><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.561.1">smaller influence on the </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">system latency.</span></span></p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.563.1">I</span><span class="superscript"><span class="koboSpan" id="kobo.564.1">2</span></span><span class="koboSpan" id="kobo.565.1">C bus</span></h1>
<p><span class="koboSpan" id="kobo.566.1">The third serial communication </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.567.1">protocol analyzed in this chapter is I</span><span class="superscript"><span class="koboSpan" id="kobo.568.1">2</span></span><span class="koboSpan" id="kobo.569.1">C. </span><span class="koboSpan" id="kobo.569.2">From the communication strategy point of view, this protocol shares some similarities with SPI. </span><span class="koboSpan" id="kobo.569.3">However, the default bit rate for I</span><span class="superscript"><span class="koboSpan" id="kobo.570.1">2</span></span><span class="koboSpan" id="kobo.571.1">C communication is much lower, as the protocol privileges lower-power consumption </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">over throughput.</span></span></p>
<p><span class="koboSpan" id="kobo.573.1">The same two-wire bus can accommodate multiple participants, both masters and slaves, and there is no need for extra signals to physically select the slave of the transaction, as slaves have fixed logic </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">addresses assigned:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.575.1"><img alt="Figure 7.6 – I2C bus with three slaves and external pull-up resistors" src="image/B18730_07_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.576.1">Figure 7.6 – I</span><span class="superscript"><span class="koboSpan" id="kobo.577.1">2</span></span><span class="koboSpan" id="kobo.578.1">C bus with three slaves and external pull-up resistors</span></p>
<p><span class="koboSpan" id="kobo.579.1">One wire transports the clock generated by the master, and the other is used as a bidirectional synchronous data path. </span><span class="koboSpan" id="kobo.579.2">This is possible thanks to the unique mechanism of arbitration of the </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.580.1">channel, which relies on the electronic design of the transceivers and may deal with the presence of multiple masters on the same bus in a very </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">clean way.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">The two signals must be connected to the high-level voltage of the bus (typically 3.3 V) using pull-up resistors. </span><span class="koboSpan" id="kobo.582.2">The controllers never drive the signal high and instead, they let it float to its default value imposed by the pull-ups while transmitting ones. </span><span class="koboSpan" id="kobo.582.3">As a consequence, logic level zero is always dominant; if any of the devices connected to the bus enforce a zero by pulling the line down, all the devices will read the line as low, no matter how many other senders are keeping the logic level 1 on the bus. </span><span class="koboSpan" id="kobo.582.4">This allows the bus to be controlled by multiple transceivers at the same time, and transmit operations can be coordinated by initiating new transactions only when the bus becomes available. </span><span class="koboSpan" id="kobo.582.5">In this section, we will see an introduction to the protocol, in order to introduce the software tools used to </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.583.1">manage the I</span><span class="superscript"><span class="koboSpan" id="kobo.584.1">2</span></span><span class="koboSpan" id="kobo.585.1">C controller peripherals. </span><span class="koboSpan" id="kobo.585.2">More information on the I</span><span class="superscript"><span class="koboSpan" id="kobo.586.1">2</span></span><span class="koboSpan" id="kobo.587.1">C bus communication and</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.588.1"> the related documentation can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">at </span></span><a href="https://www.i2c-bus.org/"><span class="No-Break"><span class="koboSpan" id="kobo.590.1">https://www.i2c-bus.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.591.1">.</span></span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.592.1">Protocol description</span></h2>
<p><span class="koboSpan" id="kobo.593.1">The synchronization between the</span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.594.1"> master and slave is achieved by a recognizable </span><strong class="bold"><span class="koboSpan" id="kobo.595.1">START condition</span></strong><span class="koboSpan" id="kobo.596.1"> and a </span><strong class="bold"><span class="koboSpan" id="kobo.597.1">STOP condition</span></strong><span class="koboSpan" id="kobo.598.1">, which determine the </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.599.1">beginning and </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.600.1">the end of a transaction, respectively. </span><span class="koboSpan" id="kobo.600.2">The bus is initially idle, with both signals at the high logic state when all the participants </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">are idling.</span></span></p>
<p><span class="koboSpan" id="kobo.602.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">START</span></strong><span class="koboSpan" id="kobo.604.1"> condition is the only case when </span><strong class="bold"><span class="koboSpan" id="kobo.605.1">SDA</span></strong><span class="koboSpan" id="kobo.606.1"> is pulled low before </span><strong class="bold"><span class="koboSpan" id="kobo.607.1">SCL</span></strong><span class="koboSpan" id="kobo.608.1"> by the master. </span><span class="koboSpan" id="kobo.608.2">The special condition communicates to slaves and other masters on the bus that a transaction is initiated. </span><span class="koboSpan" id="kobo.608.3">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">STOP</span></strong><span class="koboSpan" id="kobo.610.1"> condition can be identified by the SDA transaction from a low to a high level, while the SCL remains high. </span><span class="koboSpan" id="kobo.610.2">After a </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">STOP</span></strong><span class="koboSpan" id="kobo.612.1"> condition, the bus is idle again, and initiating communication is only possible if a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">START</span></strong><span class="koboSpan" id="kobo.614.1"> condition </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">is transmitted.</span></span></p>
<p><span class="koboSpan" id="kobo.616.1">A master sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">START</span></strong><span class="koboSpan" id="kobo.618.1"> condition by pulling SDA and SCL low in this order. </span><span class="koboSpan" id="kobo.618.2">A frame is composed of nine clock periods. </span><span class="koboSpan" id="kobo.618.3">After the edge of each clock pulse is raised, the level of SDA does not change until the clock is low again. </span><span class="koboSpan" id="kobo.618.4">This allows us to transmit 1 frame of 8 bytes in the first 8 clock raise fronts. </span><span class="koboSpan" id="kobo.618.5">During the last clock pulse, the master does not drive the SDA line, which is then held high by the pull-up resistor. </span><span class="koboSpan" id="kobo.618.6">Any receiver that wants to acknowledge the reception of the frame can drive the signal low. </span><span class="koboSpan" id="kobo.618.7">This condition on the ninth clock </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.619.1">pulse is known as </span><strong class="bold"><span class="koboSpan" id="kobo.620.1">ACK</span></strong><span class="koboSpan" id="kobo.621.1">. </span><span class="koboSpan" id="kobo.621.2">If no receiving device acknowledges the frame, SDA remains high, and the sender understands that the frame did not reach the </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">intended destination:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.623.1"><img alt="Figure 7.7 – A single-byte I2C transaction on the bus, with the correct START and STOP conditions and the ACK flag set by the receiver" src="image/B18730_07_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.624.1">Figure 7.7 – A single-byte I</span><span class="superscript"><span class="koboSpan" id="kobo.625.1">2</span></span><span class="koboSpan" id="kobo.626.1">C transaction on the bus, with the correct START and STOP conditions and the ACK flag set by the receiver</span></p>
<p><span class="koboSpan" id="kobo.627.1">A transaction consists of two or more frames and is always initiated by a device operating in master mode. </span><span class="koboSpan" id="kobo.627.2">The</span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.628.1"> first frame of each transaction is called the </span><strong class="bold"><span class="koboSpan" id="kobo.629.1">address frame</span></strong><span class="koboSpan" id="kobo.630.1"> and contains the </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.631.1">address and the mode for the next operation. </span><span class="koboSpan" id="kobo.631.2">All the subsequent frames in the transaction are data frames, containing 1 byte each. </span><span class="koboSpan" id="kobo.631.3">The master decides how many frames compose the transaction and the direction of the data transfer by keeping the transaction active for the desired amount of frames</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.632.1"> before enforcing a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.633.1">STOP condition</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.635.1">Slave devices have fixed 7-bit addresses where they can be contacted using the bus. </span><span class="koboSpan" id="kobo.635.2">A slave that notices a </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">START</span></strong><span class="koboSpan" id="kobo.637.1"> condition on the bus must listen for the address frame and compare it with its address. </span><span class="koboSpan" id="kobo.637.2">If the address matches, the address frame must be acknowledged by pulling the SDA line low during the ninth clock pulse within the transmission of </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">the frame.</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">Data is always</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.640.1"> transferred with the leading </span><strong class="bold"><span class="koboSpan" id="kobo.641.1">Most Significant Bit</span></strong><span class="koboSpan" id="kobo.642.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.643.1">MSB</span></strong><span class="koboSpan" id="kobo.644.1">), and the format for the address frame is </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.646.1"><img alt="Figure 7.8 – Format of the address frame containing a destination 7-bit address and the R/W̅ flag" src="image/B18730_07_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.647.1">Figure 7.8 – Format of the address frame containing a destination 7-bit address and the R/</span><em class="italic" xml:lang="en-GB"><span class="koboSpan" id="kobo.648.1">W̅</span></em><span class="koboSpan" id="kobo.649.1"> flag</span></p>
<p><span class="koboSpan" id="kobo.650.1">The preceding diagram shows the format used by the address frame. </span><span class="koboSpan" id="kobo.650.2">The </span><em class="italic"><span class="koboSpan" id="kobo.651.1">R/W̅</span></em><span class="koboSpan" id="kobo.652.1"> bit is set by the master to indicate the direction of the transaction. </span><em class="italic"><span class="koboSpan" id="kobo.653.1">R/W̅</span></em><span class="koboSpan" id="kobo.654.1"> reads as read, not write, meaning that a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">0</span></strong><span class="koboSpan" id="kobo.656.1"> indicates a write operation, and a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">1</span></strong><span class="koboSpan" id="kobo.658.1"> indicates a read operation. </span><span class="koboSpan" id="kobo.658.2">Depending on the value of this bit, the data bytes following the transactions are either flowing toward the slave (a write operation) or from the selected slave to the master (a read operation). </span><span class="koboSpan" id="kobo.658.3">In a read operation, the direction of the ACK bit is also inverted for the data frames following the selection of the slave, and the master is supposed to acknowledge</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.659.1"> each frame received within the transaction. </span><span class="koboSpan" id="kobo.659.2">The master can decide to abort the transmission at any time by not pulling down the ACK bit on the last frame, and enforcing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">STOP</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.661.1">condition afterward.</span></span></p>
<p><span class="koboSpan" id="kobo.662.1">The transaction continues after the transfer of the address frame, and the data can be transferred using subsequent data frames, each containing 1 byte, that can be acknowledged by the receiver. </span><span class="koboSpan" id="kobo.662.2">If the value of the </span><em class="italic"><span class="koboSpan" id="kobo.663.1">R/W̅</span></em><span class="koboSpan" id="kobo.664.1"> bit in the address frame is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">0</span></strong><span class="koboSpan" id="kobo.666.1">, the master intends to initiate a write operation. </span><span class="koboSpan" id="kobo.666.2">Once the slave has acknowledged the address frame by recognizing itself as the destination, it is ready to receive data, and acknowledges data frames, until the master sends the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">STOP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.668.1"> condition.</span></span></p>
<p><span class="koboSpan" id="kobo.669.1">The I</span><span class="superscript"><span class="koboSpan" id="kobo.670.1">2</span></span><span class="koboSpan" id="kobo.671.1">C protocol specifies that if a </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">START</span></strong><span class="koboSpan" id="kobo.673.1"> condition is repeated at the end of a transaction, instead of sending the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">STOP </span></strong><span class="koboSpan" id="kobo.675.1">condition, a new transaction can be started right away without setting the bus to its idling state. </span><span class="koboSpan" id="kobo.675.2">A repeated </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">START</span></strong><span class="koboSpan" id="kobo.677.1"> condition ensures that two or more transactions can be performed on the same bus without interruptions, for example, preventing another master from starting a communication </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">between them.</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">A less popular format foresees 10-bit addresses for the slaves. </span><span class="koboSpan" id="kobo.679.2">10-bit addresses are an extension of the standard, introduced at a later time, that provide compatibility with 7-bit addressable devices on the same bus. </span><span class="koboSpan" id="kobo.679.3">The address is selected using 2 consecutive frames, and the first 5 bits, </span><strong class="bold"><span class="koboSpan" id="kobo.680.1">A6</span></strong><span class="koboSpan" id="kobo.681.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.682.1">A2</span></strong><span class="koboSpan" id="kobo.683.1">, in the first frame are set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">11110</span></strong><span class="koboSpan" id="kobo.685.1"> to indicate the selection of a 10-bit address. </span><span class="koboSpan" id="kobo.685.2">As per the protocol specification, addresses starting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">0000</span></strong><span class="koboSpan" id="kobo.687.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">1111</span></strong><span class="koboSpan" id="kobo.689.1"> are reserved </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.690.1">and must not be used by slaves. </span><span class="koboSpan" id="kobo.690.2">In the 10-bit format, the most significant 2 bits are contained in </span><strong class="bold"><span class="koboSpan" id="kobo.691.1">A1</span></strong><span class="koboSpan" id="kobo.692.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.693.1">A0</span></strong><span class="koboSpan" id="kobo.694.1"> of the first frame, while the second frame contains the remaining 8 bits. </span><span class="koboSpan" id="kobo.694.2">The </span><em class="italic"><span class="koboSpan" id="kobo.695.1">R/W̅</span></em><span class="koboSpan" id="kobo.696.1"> bit keeps its position in the first frame. </span><span class="koboSpan" id="kobo.696.2">This addressing mechanism is not v</span><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.697.1">ery common, as only a few slave devices </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">support it.</span></span></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.699.1">Clock stretching</span></h2>
<p><span class="koboSpan" id="kobo.700.1">We have observed that the master is the only one driving the SCL signal during I</span><span class="superscript"><span class="koboSpan" id="kobo.701.1">2</span></span><span class="koboSpan" id="kobo.702.1">C transactions. </span><span class="koboSpan" id="kobo.702.2">This is always true, except when the slave is not yet ready to transmit the requested data from the </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.703.1">master. </span><span class="koboSpan" id="kobo.703.2">In this particular case, the slave may decide to delay the transaction by keeping the clock line pulled low, which results in the transaction being put on hold. </span><span class="koboSpan" id="kobo.703.3">The master recognizes its inability to oscillate the clock, as releasing the SCL signal to a floating state does not result in a change to a high logic level on the bus. </span><span class="koboSpan" id="kobo.703.4">The master will keep trying to release the SCL signal to its natural high position until the requested data is finally available on the slave, which eventually releases the hold on </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">the line.</span></span></p>
<p><span class="koboSpan" id="kobo.705.1">The transmission can now resume after being kept on hold for an indefinite amount of time, and the master is still expected to produce the nine clock pulses to conclude the transmission. </span><span class="koboSpan" id="kobo.705.2">Because no more frames are expected within this transaction, the master does not pull the ACK bit low in the end, and sends the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">STOP</span></strong><span class="koboSpan" id="kobo.707.1"> condition instead to correctly complete </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">the transaction:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.709.1"><img alt="Figure 7.9 – I2C read transaction with the reply frame delayed by the slave using the clock-stretching technique" src="image/B18730_07_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.710.1">Figure 7.9 – I</span><span class="superscript"><span class="koboSpan" id="kobo.711.1">2</span></span><span class="koboSpan" id="kobo.712.1">C read transaction with the reply frame delayed by the slave using the clock-stretching technique</span></p>
<p><span class="koboSpan" id="kobo.713.1">Even though not all devices support clock stretching, this mechanism is useful to complete transactions when the requested data is slightly late. </span><span class="koboSpan" id="kobo.713.2">Clock stretching is a very unique feature of I</span><span class="superscript"><span class="koboSpan" id="kobo.714.1">2</span></span><span class="koboSpan" id="kobo.715.1">C, making it a very versatile protocol to communicate with sensors and other input </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.716.1">peripherals. </span><span class="koboSpan" id="kobo.716.2">Clock stretching is very important to communicate with slower devices that cannot provide the values to complete the transaction in time. </span><span class="koboSpan" id="kobo.716.3">It is advisable that this feature is correctly supported by a master device that is designed to communicate with generic I2C slaves. </span><span class="koboSpan" id="kobo.716.4">On the slave side, to enforce clock stretching, the device must provide a hardware configuration that allows us to keep the SCL line at a logical low value until it is ready again. </span><span class="koboSpan" id="kobo.716.5">This means that the SCL line must be bidirectional in this particular case, and the slave should be designed to access it to enforce a pull-down to keep the transaction a</span><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.717.1">live while preparing the transfer of the </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">next frame.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.719.1">Multiple masters</span></h2>
<p><span class="koboSpan" id="kobo.720.1">I</span><span class="superscript"><span class="koboSpan" id="kobo.721.1">2</span></span><span class="koboSpan" id="kobo.722.1">C offers a deterministic </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.723.1">mechanism to detect and react to the presence of multiple masters on the bus, which is, again, based on the electrical property of the </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">SDA line.</span></span></p>
<p><span class="koboSpan" id="kobo.725.1">Before initiating any communication, the master ensures that the bus is available by sensing the SDA and SCL lines. </span><span class="koboSpan" id="kobo.725.2">The way the </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">START</span></strong><span class="koboSpan" id="kobo.727.1"> condition is designed can already rule out most of the conflicts. </span><span class="koboSpan" id="kobo.727.2">Concurrent start conditions can be interrupted whenever the SDA line is sensed</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.728.1"> low in the initial grace time between the two edges. </span><span class="koboSpan" id="kobo.728.2">This mechanism alone does not prevent two I</span><span class="superscript"><span class="koboSpan" id="kobo.729.1">2</span></span><span class="koboSpan" id="kobo.730.1">C masters from accessing the channel at the same time, because conflicts are still possible due to the propagation time of the signal across </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">the wire.</span></span></p>
<p><span class="koboSpan" id="kobo.732.1">Two master devices that initiate a transaction at the same time continuously compare the status of the line, after each bit has been transmitted. </span><span class="koboSpan" id="kobo.732.2">In the case of two masters perfectly synchronized for two different transmissions, the first bit with a different value on the two sources will only be noticed by the master transmitting a </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">1</span></strong><span class="koboSpan" id="kobo.734.1"> value, because the expected value is not reflected by the actual line status. </span><span class="koboSpan" id="kobo.734.2">That master aborts the transaction immediately, and the transmitter can detect the error as a conflict on the network, which, in this context, means that the arbitration was lost in favor of another master. </span><span class="koboSpan" id="kobo.734.3">Meanwhile, the other master will not notice anything, and neither will the slaves, because the transaction </span><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.735.1">will continue despite the silently contended </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">bus line.</span></span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.737.1">Programming the controller</span></h2>
<p><span class="koboSpan" id="kobo.738.1">Microcontrollers may provide one </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.739.1">or more I</span><span class="superscript"><span class="koboSpan" id="kobo.740.1">2</span></span><span class="koboSpan" id="kobo.741.1">C controllers on board that can be bound to specific pins using alternate functions. </span><span class="koboSpan" id="kobo.741.2">On our reference board, to enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">I2C1</span></strong><span class="koboSpan" id="kobo.743.1"> bus, we activate the clock gating and start the initialization procedure by accessing the control, data, and status register mapped in the peripheral </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">memory region:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.745.1">
#define APB1_CLOCK_ER (*(volatile uint32_t *)(0x40023840))
#define APB1_CLOCK_RST (*(volatile uint32_t *)(0x40023820))
#define I2C1_APB1_CLOCK_ER_VAL (1 &lt;&lt; 21)</span></pre>
<p><span class="koboSpan" id="kobo.746.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">I2C1</span></strong><span class="koboSpan" id="kobo.748.1"> controller on the STM32F407 is associated with pins PB6 and PB9 when they are configured with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">AF 4</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.750.1">alternate function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.751.1">
#define I2C1_PIN_AF 4
#define I2C1_SCL 6
#define I2C1_SDA 9
#define GPIO_MODE_AF (2)
static void i2c1_pins_setup(void)
{
  uint32_t reg;
  AHB1_CLOCK_ER |= GPIOB_AHB1_CLOCK_ER;
  /* Set mode = AF */
  reg = GPIOB_MODE &amp; ~(0x03 &lt;&lt; (I2C1_SCL * 2));
  reg &amp;= ~(0x03 &lt;&lt; (I2C1_SDA * 2));
  GPIOB_MODE = reg | (2 &lt;&lt; (I2C1_SCL * 2)) | 
      (2 &lt;&lt; (I2C_SDA * 2));
  /* Alternate function: */
  reg = GPIOB_AFL &amp; ~(0xf &lt;&lt; ((I2C1_SCL) * 4));
  GPIOB_AFL = reg | (I2C1_PIN_AF &lt;&lt; ((I2C1_SCL - 8) * 4));
  reg = GPIOB_AFH &amp; ~(0xf &lt;&lt; ((I2C1_SDA - 8) * 4));
  GPIOB_AFH = reg | (I2C1_PIN_AF &lt;&lt; ((I2C1_SDA - 8) * 4));
}</span></pre>
<p><span class="koboSpan" id="kobo.752.1">The initialization </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.753.1">function accesses the configuration registers of the I</span><span class="superscript"><span class="koboSpan" id="kobo.754.1">2</span></span><span class="koboSpan" id="kobo.755.1">C controller, mapped in the peripheral region. </span><span class="koboSpan" id="kobo.755.2">After the pin configuration and the RCC startup sequence, the transceiver speed is calibrated by using the frequency of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">APB1</span></strong><span class="koboSpan" id="kobo.757.1"> bus clock, in MHz. </span><span class="koboSpan" id="kobo.757.2">When the clocks are calibrated, the transceiver is enabled by setting a bit in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">CR1</span></strong><span class="koboSpan" id="kobo.759.1"> register. </span><span class="koboSpan" id="kobo.759.2">The parameters used here configure the master bus clock to run at 400 kHz. </span><span class="koboSpan" id="kobo.759.3">While the default setting for the protocol foresees a</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.760.1"> clock of 100 kHz, the 400 kHz option was added later on, and is now supported by </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">many devices:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.762.1">
#define I2C1 (0x40005400)
#define APB1_SPEED_IN_MHZ (42)
#define I2C1_CR1 (*(volatile uint32_t *)(I2C1))
#define I2C1_CR2 (*(volatile uint32_t *)(I2C1 + 0x04))
#define I2C1_OAR1 (*(volatile uint32_t *)(I2C1 + 0x08))
#define I2C1_OAR2 (*(volatile uint32_t *)(I2C1 + 0x0c))
#define I2C1_DR (*(volatile uint32_t *)(I2C1 + 0x10))
#define I2C1_SR1 (*(volatile uint32_t *)(I2C1 + 0x14))
#define I2C1_SR2 (*(volatile uint32_t *)(I2C1 + 0x18))
#define I2C1_CCR (*(volatile uint32_t *)(I2C1 + 0x1c))
#define I2C1_TRISE (*(volatile uint32_t *)(I2C1 + 0x20))
#define I2C_CR2_FREQ_MASK (0x3ff)
#define I2C_CCR_MASK (0xfff)
#define I2C_TRISE_MASK (0x3f)
#define I2C_CR1_ENABLE (1 &lt;&lt; 0)
void i2c1_setup(void)
{
  uint32_t reg;
  i2c1_pins_setup();
  APB1_CLOCK_ER |= I2C1_APB1_CLOCK_ER_VAL;
  I2C1_CR1 &amp;= ~I2C_CR1_ENABLE;
  i2c1_reset();
  reg = I2C1_CR2 &amp; ~(I2C_CR2_FREQ_MASK);
  I2C1_CR2 = reg | APB1_SPEED_IN_MHZ;
  reg = I2C1_CCR &amp; ~(I2C_CCR_MASK);
  I2C1_CCR = reg | (APB1_SPEED_IN_MHZ * 5);
  reg = I2C1_TRISE &amp; ~(I2C_TRISE_MASK);
  I2C1_TRISE = reg | APB1_SPEED_IN_MHZ + 1;
  I2C1_CR1 |= I2C_CR1_ENABLE;
}</span></pre>
<p><span class="koboSpan" id="kobo.763.1">From this moment on, the controller is ready to be configured and used, either in master or slave mode. </span><span class="koboSpan" id="kobo.763.2">Data can be read and written using </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">I2C1_DR</span></strong><span class="koboSpan" id="kobo.765.1">, in the same way as SPI and UART. </span><span class="koboSpan" id="kobo.765.2">The main</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.766.1"> difference here is that, for a master I</span><span class="superscript"><span class="koboSpan" id="kobo.767.1">2</span></span><span class="koboSpan" id="kobo.768.1">C device, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">START</span></strong><span class="koboSpan" id="kobo.770.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">STOP</span></strong><span class="koboSpan" id="kobo.772.1"> conditions must be manually triggered by setting the corresponding values in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">I2C1_CR1</span></strong><span class="koboSpan" id="kobo.774.1"> register. </span><span class="koboSpan" id="kobo.774.2">Functions such as the following are intended for </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">this purpose:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.776.1">
static void i2c1_send_start(void)
{
  volatile uint32_t sr1;
  I2C1_CR1 |= I2C_CR1_START;
  do {
    sr1 = I2C1_SR1;
  } while ((sr1 &amp; I2C_SR1_START) == 0);
}
static void i2c1_send_stop(void)
{
  I2C1_CR1 |= I2C_CR1_STOP;
}</span></pre>
<p><span class="koboSpan" id="kobo.777.1">At the end of each condition, the bus must be tested for possible errors or abnormal events. </span><span class="koboSpan" id="kobo.777.2">The combination of the flags in </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">I2C1_CR1</span></strong><span class="koboSpan" id="kobo.779.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">I2C1_CR2</span></strong><span class="koboSpan" id="kobo.781.1"> must reflect the expected status for the transaction to continue, or it must be gracefully aborted in the case of timeouts or </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">unrecoverable errors.</span></span></p>
<p><span class="koboSpan" id="kobo.783.1">Due to the complexity </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.784.1">caused by the high number of events possible during the setup of the transaction, it is necessary to implement a complete state machine that keeps track of the phases of the transmission to use the transceiver in </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">master mode.</span></span></p>
<p><span class="koboSpan" id="kobo.786.1">As a demonstration of basic interactions with the transceiver, we can write a sequential interaction with the bus, but a real-life scenario would require us to keep track of the state of each transaction and react to the many scenarios possible within the combination of the flags contained in </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">I2C1_SR1</span></strong><span class="koboSpan" id="kobo.788.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">I2C1_SR2</span></strong><span class="koboSpan" id="kobo.790.1">. </span><span class="koboSpan" id="kobo.790.2">This sequence initiates a transaction toward an I</span><span class="superscript"><span class="koboSpan" id="kobo.791.1">2</span></span><span class="koboSpan" id="kobo.792.1">C slave with an address of </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">0x42</span></strong><span class="koboSpan" id="kobo.794.1">, and if the slave responds, it sends 2 bytes with values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">0x00</span></strong><span class="koboSpan" id="kobo.796.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">0x01</span></strong><span class="koboSpan" id="kobo.798.1">, respectively. </span><span class="koboSpan" id="kobo.798.2">The only purpose of this sequence is to show the interaction with the transceiver, and it does not recover from any of the possible errors. </span><span class="koboSpan" id="kobo.798.3">At the beginning of the transaction, we zero the flags related to the ACK or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">STOP</span></strong><span class="koboSpan" id="kobo.800.1"> condition, and we enable the transceiver using the lowest bit </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">CR1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.804.1">
void i2c1_test_sequence(void)
{
  volatile uint32_t sr1, sr2;
  const uint8_t address = 0x42;
  I2C1_CR1 &amp;= ~(I2C_CR1_ENABLE | I2C_CR1_STOP |
      I2C_CR1_ACK);
  I2C1_CR1 |= I2C_CR1_ENABLE;</span></pre>
<p><span class="koboSpan" id="kobo.805.1">To ensure that no other master is occupying the bus, the procedure hangs until the busy flag is cleared in </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">the</span></span><span class="No-Break"><a id="_idIndexMarker534"/></span><span class="No-Break"><span class="koboSpan" id="kobo.807.1"> transceiver:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.808.1">
  do {
    sr2 = I2C1_SR2;
  } while ((sr2 &amp; I2C_SR2_BUSY) != 0);</span></pre>
<p><span class="koboSpan" id="kobo.809.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">START</span></strong><span class="koboSpan" id="kobo.811.1"> condition is sent, using the function defined earlier, which will also wait until the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">START</span></strong><span class="koboSpan" id="kobo.813.1"> condition appears on </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">the bus:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.815.1">
  i2c1_send_start();</span></pre>
<p><span class="koboSpan" id="kobo.816.1">The destination address is set to the highest 7 bits of the byte we are about to transmit. </span><span class="koboSpan" id="kobo.816.2">The lowest bit is off as well, indicating a write operation. </span><span class="koboSpan" id="kobo.816.3">To proceed after a correct address selection that has been acknowledged by the receiving slave, two flags must be set in </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">I2C1_SR2</span></strong><span class="koboSpan" id="kobo.818.1">, indicating that the master mode has been selected and the bus is </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">still taken:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.820.1">
  I2C1_DR = (address &lt;&lt; 1);
  do {
    sr2 = I2C1_SR2;
  } while ((sr2 &amp; (I2C_SR2_BUSY | I2C_SR2_MASTER)) !=
          (I2C_SR2_BUSY | I2C_SR2_MASTER));</span></pre>
<p><span class="koboSpan" id="kobo.821.1">The data communication with the slave has now been initiated, and the 2 data bytes can be transmitted. </span><span class="koboSpan" id="kobo.821.2">The TX FIFO </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">EMPTY</span></strong><span class="koboSpan" id="kobo.823.1"> event indicates when each byte has been transferred within a frame in </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">the transaction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.825.1">
  I2C1_DR = (0x00);
  do {
    sr1 = I2C1_SR1;
  } while ((sr1 &amp; I2C_SR1_TX_EMPTY) != 0);
  I2C1_DR = (0x01);
  do {
    sr1 = I2C1_SR1;
  } while ((sr1 &amp; I2C_SR1_TX_EMPTY) != 0);</span></pre>
<p><span class="koboSpan" id="kobo.826.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">STOP</span></strong><span class="koboSpan" id="kobo.828.1"> conditi</span><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.829.1">on is set, and the transaction </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">is over:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.831.1">
  i2c1_send_stop();
}</span></pre>
<h2 id="_idParaDest-176"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.832.1">Interrupt handling</span></h2>
<p><span class="koboSpan" id="kobo.833.1">The event interface of the I</span><span class="superscript"><span class="koboSpan" id="kobo.834.1">2</span></span><span class="koboSpan" id="kobo.835.1">C controller on the reference target is complex enough to provide two separate</span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.836.1"> interrupt handlers for each transceiver. </span><span class="koboSpan" id="kobo.836.2">The suggested implementation for a generic I</span><span class="superscript"><span class="koboSpan" id="kobo.837.1">2</span></span><span class="koboSpan" id="kobo.838.1">C master includes a proper interrupt setup and the definition of all the combinations between states and events. </span><span class="koboSpan" id="kobo.838.2">The I</span><span class="superscript"><span class="koboSpan" id="kobo.839.1">2</span></span><span class="koboSpan" id="kobo.840.1">C controller can be configured to associate interrupts with all the relevant events happening on the bus, allowing for the fine-tuning of specific corner cases, an</span><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.841.1">d a more-or-less complete implementation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">I</span></span><span class="No-Break"><span class="superscript"><span class="koboSpan" id="kobo.843.1">2</span></span></span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">C protocol.</span></span></p>
<p><span class="koboSpan" id="kobo.845.1">That brings us to the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">this chapter.</span></span></p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.847.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.848.1">This chapter has given us the necessary information to start programming system support for the most popular local bus communication interfaces available on embedded targets. </span><span class="koboSpan" id="kobo.848.2">Accessing peripherals and other microcontrollers in the same geographical location is one of the typical requirements of embedded systems interacting with sensors, actuators, and other devices in proximity of the </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">embedded system.</span></span></p>
<p><span class="koboSpan" id="kobo.850.1">Several implementations providing a higher level of abstraction to the transceivers analyzed here already exist. </span><span class="koboSpan" id="kobo.850.2">The serial communication protocols covered in this chapter, namely UART, SPI, and I</span><span class="superscript"><span class="koboSpan" id="kobo.851.1">2</span></span><span class="koboSpan" id="kobo.852.1">C, are usually accessible through drivers that are part of the board support kit and do not need to be reimplemented from scratch. </span><span class="koboSpan" id="kobo.852.2">This chapter, however, purposely focused on studying the behavior of the components from the closest possible point of view, to better understand the interface provided by the hardware manufacturer, and possibly provide the tools to design new ways of accessing the interfaces, tailored or optimized, for a specific platform or scenario, while also understanding the choices behind some of the protocol </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">design characteristics.</span></span></p>
<p><span class="koboSpan" id="kobo.854.1">In the next chapter, we will describe the mechanisms used to reduce the power consumption of embedded systems by studying the low-power and ultra-low-power features present in modern </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">embedded devices.</span></span></p>
</div>
</body></html>