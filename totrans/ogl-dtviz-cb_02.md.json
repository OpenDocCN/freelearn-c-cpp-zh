["```cpp\ntypedef struct\n{\n  GLfloat x, y, z; //position\n  GLfloat r, g, b, a; //color and alpha channels\n} Vertex;\n```", "```cpp\nVertex v = {0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};\n```", "```cpp\n    void drawPoint(Vertex v1, GLfloat size){\n    ```", "```cpp\n      glPointSize(size);\n    ```", "```cpp\n      glBegin(GL_POINTS);\n    ```", "```cpp\n      glColor4f(v1.r, v1.g, v1.b, v1.a);\n      glVertex3f(v1.x, v1.y, v1.z);\n    ```", "```cpp\n      glEnd();\n    }\n    ```", "```cpp\n    void drawPointsDemo(int width, int height){\n      GLfloat size=5.0f;\n      for(GLfloat x = 0.0f; x<=1.0f; x+=0.2f, size+=5)\n      {\n        Vertex v1 = {x, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};\n        drawPoint(v1, size);\n      }\n    }\n    ```", "```cpp\n    #include <GLFW/glfw3.h>\n    #include <stdlib.h>\n    #include <stdio.h>\n    ```", "```cpp\n    const int WINDOWS_WIDTH = 640*2;\n    const int WINDOWS_HEIGHT = 480;\n    ```", "```cpp\n    typedef struct\n    {\n      GLfloat x, y, z;\n      GLfloat r, g, b, a;\n    } Vertex;\n    void drawPoint(Vertex v1, GLfloat size);\n    void drawPointsDemo(int width, int height);\n    ```", "```cpp\n    int main(void)\n    {\n      GLFWwindow* window;\n      if (!glfwInit())\n        exit(EXIT_FAILURE);\n      window = glfwCreateWindow(WINDOWS_WIDTH, WINDOWS_HEIGHT, \"Chapter 2: Primitive drawings\", NULL, NULL);\n      if (!window){\n        glfwTerminate();\n        exit(EXIT_FAILURE);\n      }\n      glfwMakeContextCurrent(window);\n    ```", "```cpp\n      glEnable(GL_POINT_SMOOTH);\n      glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);\n      glEnable(GL_BLEND);\n      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    ```", "```cpp\n      while (!glfwWindowShouldClose(window))\n      {\n        float ratio;\n        int width, height;\n        glfwGetFramebufferSize(window, &width, &height);\n        ratio = (float) width / (float)height;\n        glViewport(0, 0, width, height);\n        glClear(GL_COLOR_BUFFER_BIT);\n    ```", "```cpp\n        glMatrixMode(GL_PROJECTION);\n        glLoadIdentity();\n        //Orthographic Projection\n        glOrtho(-ratio, ratio, -1.f, 1.f, 1.f, -1.f);\n        glMatrixMode(GL_MODELVIEW);\n        glLoadIdentity();\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    ```", "```cpp\n        drawPointsDemo(width, height);\n    ```", "```cpp\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n      }\n    ```", "```cpp\n      glfwDestroyWindow(window);\n      glfwTerminate();\n      exit(EXIT_SUCCESS);\n    }\n    ```", "```cpp\nglEnable(GL_POINT_SMOOTH);\nglEnable(GL_BLEND);\nglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n```", "```cpp\nGL_POINTS, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUADS, GL_QUAD_STRIP, and GL_POLYGON\n```", "```cpp\n    void drawLineSegment(Vertex v1, Vertex v2, GLfloat width) {\n    ```", "```cpp\n      glLineWidth(width);\n    ```", "```cpp\n      glBegin(GL_LINES);\n    ```", "```cpp\n      glColor4f(v1.r, v1.g, v1.b, v1.a);\n      glVertex3f(v1.x, v1.y, v1.z);\n      glColor4f(v2.r, v2.g, v2.b, v2.a);\n      glVertex3f(v2.x, v2.y, v2.z);\n      glEnd();\n    }\n    ```", "```cpp\nvoid drawGrid(GLfloat width, GLfloat height, GLfloat grid_width){\n  //horizontal lines\n  for(float i=-height; i<height; i+=grid_width){\n    Vertex v1 = {-width, i, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};\n    Vertex v2 = {width, i, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};\n    drawLineSegment(v1, v2);\n  }\n  //vertical lines\n  for(float i=-width; i<width; i+=grid_width){\n    Vertex v1 = {i, -height, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};\n    Vertex v2 = {i, height, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};\n    drawLineSegment(v1, v2);\n  }\n}\n```", "```cpp\nvoid drawLineDemo(){\n  //draw a simple grid\n  drawGrid(5.0f, 1.0f, 0.1f);\n  //define the vertices and colors of the line segments\n  Vertex v1 = {-5.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.7f};\n  Vertex v2 = {5.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.7f};\n  Vertex v3 = {0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.7f};\n  Vertex v4 = {0.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.7f};\n  //draw the line segments\n  drawLineSegment(v1, v2, 10.0f);\n  drawLineSegment(v3, v4, 10.0f);\n}\n```", "```cpp\n    void drawTriangle(Vertex v1, Vertex v2, Vertex v3){\n    ```", "```cpp\n      glBegin(GL_TRIANGLES);\n    ```", "```cpp\n      glColor4f(v1.r, v1.g, v1.b, v1.a);\n      glVertex3f(v1.x, v1.y, v1.z);\n      glColor4f(v2.r, v2.g, v2.b, v2.a);\n      glVertex3f(v2.x, v2.y, v2.z);\n      glColor4f(v3.r, v3.g, v3.b, v3.a);\n      glVertex3f(v3.x, v3.y, v3.z);\n      glEnd(),\n    }\n    ```", "```cpp\n    void drawTriangleDemo(){\n      //Triangle Demo\n      Vertex v1 = {0.0f, 0.8f, 0.0f, 1.0f, 0.0f, 0.0f, 0.6f};\n      Vertex v2 = {-1.0f, -0.8f, 0.0f, 0.0f, 1.0f, 0.0f, 0.6f};\n      Vertex v3 = {1.0f, -0.8f, 0.0f, 0.0f, 0.0f, 1.0f, 0.6f};\n      drawTriangle(v1, v2, v3);\n    }\n    ```", "```cpp\n(v1, v2, v3), (v1, v3, v4),...,(v1, vn-1, vn)\nfor n vertices\n```", "```cpp\n    typedef struct\n    {\n      GLfloat x, y, z;\n    } Data;\n    ```", "```cpp\n    void draw2DscatterPlot (const Data *data, int num_points){\n    ```", "```cpp\n      Vertex v1 = {-10.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};\n      Vertex v2 = {10.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f};\n      drawLineSegment(v1, v2, 2.0f);\n      v1.x = 0.0f;\n      v2.x = 0.0f;\n      v1.y = -1.0f;\n      v2.y = 1.0f;\n      drawLineSegment(v1, v2, 2.0f);\n    ```", "```cpp\n      for(int i=0; i<num_points; i++){\n        GLfloat x=data[i].x;\n        GLfloat y=data[i].y;\n        Vertex v={x, y, 0.0f, 1.0f, 1.0f, 1.0f, 0.5f};\n        drawPoint(v, 8.0f);\n      }\n    }\n    ```", "```cpp\n    void draw2DlineSegments(const Data *data, int num_points){\n      for(int i=0; i<num_points-1; i++){\n        GLfloat x1=data[i].x;\n        GLfloat y1=data[i].y;\n        GLfloat x2=data[i+1].x;\n        GLfloat y2=data[i+1].y;\n        Vertex v1={x1, y1, 0.0f, 0.0f, 1.0f, 1.0f, 0.5f};\n        Vertex v2={x2, y2, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f};\n        drawLineSegment(v1, v2, 4.0f);\n      }\n    }\n    ```", "```cpp\n    void linePlotDemo(float phase_shift){\n      drawGrid(5.0f, 1.0f, 0.1f);\n      GLfloat range = 10.0f;\n      const int num_points = 200;\n      Data *data=(Data*)malloc(sizeof(Data)*num_points);\n      for(int i=0; i<num_points; i++){\n        data[i].x=((GLfloat)i/num_points)*range-range/2.0f;\n        data[i].y= 0.8f*cosf(data[i].x*3.14f+phase_shift);\n      }\n      draw2DScatterPlot(data, num_points);\n      draw2DLineSegments(data, num_points);\n      free(data);\n    }\n    ```", "```cpp\n    #include <math.h>\n    ...\n    int main(void){\n      ...\n      float phase_shift=0.0f;\n      while (!glfwWindowShouldClose(window)){\n        ...\n        phase_shift+=0.02f;\n        linePlotDemo(phase_shift);\n        ...\n\n        //finished all demo calls\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n      }\n      ...\n    }\n    ```", "```cpp\nfloat data_ecg[]={0.396568808f, 0.372911844f, 0.311059085f, 0.220346775f, 0.113525529f, 0.002200333f, -0.103284775f, -0.194218528f, -0.266285973f, -0.318075979f, -0.349670132f, -0.362640042f, -0.360047348f, -0.346207663f, -0.325440887f, -0.302062532f, -0.279400804f, -0.259695686f â€¦ };\n\n```", "```cpp\n    void plotECGData(int offset, int size, float offset_y, float scale){\n      //space between samples\n      const float space = 2.0f/size*ratio;\n      //initial position of the first vertex to render\n      float pos = -size*space/2.0f;\n      //set the width of the line\n      glLineWidth(5.0f);\n      glBegin(GL_LINE_STRIP);\n      //set the color of the line to green\n      glColor4f(0.1f, 1.0f, 0.1f, 0.8f);\n      for (int i=offset; i<size+offset; i++){\n        const float data = scale*data_ecg[i]+offset_y;\n        glVertex3f(pos, data, 0.0f);\n        pos += space;\n      }\n      glEnd();\n    }\n    ```", "```cpp\n    void ecg_demo(int counter){\n      const int data_size=ECG_DATA_BUFFER_SIZE;\n      //Emulate the presence of multiple ECG leads (just for demo/ display purposes)\n      plotECGData(counter, data_size*0.5, -0.5f, 0.1f);\n      plotECGData(counter+data_size, data_size*0.5, 0.0f, 0.5f);\n      plotECGData(counter+data_size*2, data_size*0.5, 0.5f, -0.25f);\n    }\n    ```", "```cpp\n    #include \"data_ecg.h\"\n    ...\n    int main(void){\n      ...\n      while (!glfwWindowShouldClose(window)){\n        ...\n        drawGrid(5.0f, 1.0f, 0.1f);\n        //reset counter to 0 after reaching the end of the sample data\n        if(counter>5000){\n          counter=0;\n        }\n        counter+=5;\n        //run the demo visualizer\n        ecg_demo(counter);\n        ...\n      }\n    }\n    ```", "```cpp\n    void gaussianDemo(float sigma){\n      //construct a 1000x1000 grid\n      const int grid_x = 1000;\n      const int grid_y = 1000;\n      const int num_points = grid_x*grid_y;\n      Data *data=(Data*)malloc(sizeof(Data)*num_points);\n      int data_counter=0;\n      for(int x = -grid_x/2; x<grid_x/2; x+=1){\n        for(int y = -grid_y/2; y<grid_y/2; y+=1){\n          float x_data = 2.0f*x/grid_x;\n          float y_data = 2.0f*y/grid_y;\n          //compute the height z based on a\n          //2D Gaussian function.\n          float z_data = exp(-0.5f*(x_data*x_data)/(sigma*sigma) -0.5f*(y_data*y_data)/(sigma*sigma))/(sigma*sigma*2.0f*M_PI);\n          data[data_counter].x = x_data;\n          data[data_counter].y = y_data;\n          data[data_counter].z = z_data;\n          data_counter++;\n        }\n      }\n      //visualize the result using a 2D heat map\n      draw2DHeatMap(data, num_points);\n      free(data);\n    }\n    ```", "```cpp\n    void draw2DHeatMap(const Data *data, int num_points){\n      //locate the maximum and minimum values in the dataset\n      float max_value=-999.9f;\n      float min_value=999.9f;\n      for(int i=0; i<num_points; i++){\n        const Data d = data[i];\n        if(d.z > max_value){\n          max_value = d.z;\n        }\n        if(d.z < min_value){\n          min_value = d.z;\n        }\n      }\n      const float halfmax = (max_value + min_value) / 2;\n\n      //display the result\n      glPointSize(2.0f);\n      glBegin(GL_POINTS);\n      for(int i = 0; i<num_points; i++){\n        const Data d = data[i];\n        float value = d.z;\n        float b = 1.0f - value/halfmax;\n        float r = value/halfmax - 1.0f;\n        if(b < 0){\n          b=0;\n        }\n        if(r < 0){\n          r=0;\n        }\n        float g = 1.0f - b - r;\n        glColor4f(r, g, b, 0.5f);\n        glVertex3f(d.x, d.y, 0.0f);\n      }\n      glEnd();\n    }\n    ```", "```cpp\n    #define _USE_MATH_DEFINES // M_PI constant\n    #include <math.h>\n    ...\n    int main(void){\n      ...\n      float sigma = 0.01f;\n      while (!glfwWindowShouldClose(window)){\n        ...\n        drawGrid(5.0f, 1.0f, 0.1f);\n        sigma+=0.01f;\n        if(sigma>1.0f)\n          sigma=0.01;\n        gaussianDemo(sigma);\n        ...\n      }\n    }\n    ```"]