<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-243"><a id="_idTextAnchor243"/>12</h1>
<h1 id="_idParaDest-244"><a id="_idTextAnchor244"/>Accessing Databases with SQL Driver and Qt</h1>
<p><strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) is a special programming language used to manage data held in a relational database management system. A SQL server is a database system designed to use one of the many types of SQL programming languages to manage its data.</p>
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Setting up a database</li>
<li>Connecting to a database</li>
<li>Writing basic SQL queries</li>
<li>Creating a login screen with Qt</li>
<li>Displaying information from a database in model view</li>
<li>Advanced SQL queries</li>
</ul>
<h1 id="_idParaDest-245"><a id="_idTextAnchor245"/>Technical requirements</h1>
<p>The technical requirements for this chapter include Qt 6.6.1 MinGW 64-bit and Qt Creator 12.0.2. All the code used in this chapter can be downloaded from the following GitHub repository: <a href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter12">https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter12</a>.</p>
<h1 id="_idParaDest-246"><a id="_idTextAnchor246"/>Setting up a database</h1>
<p>Qt supports several different types of SQL drivers <a id="_idIndexMarker763"/>in the form of plugins/add-ons, such as <strong class="bold">SQLite</strong>, <strong class="bold">ODBC</strong>, <strong class="bold">PostgreSQL</strong>, <strong class="bold">MySQL</strong>, and so on. However, it’s very easy to integrate these drivers into your Qt project. We will learn how to do this in the following example.</p>
<h2 id="_idParaDest-247"><a id="_idTextAnchor247"/>How to do it…</h2>
<p>In this example, we will learn<a id="_idIndexMarker764"/> how to use Qt with <strong class="bold">SQLite</strong>. Let’s set up our SQLite editor before we dive into Qt:</p>
<ol>
<li>Download <strong class="bold">SQLiteStudio</strong> from <a href="https://sqlitestudio.pl">https://sqlitestudio.pl</a> and install it to administrate your SQLite databases:</li>
</ol>
<div><div><img alt="Figure 12.1 – Install SQLiteStudio onto your computer" src="img/B20976_12_001.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Install SQLiteStudio onto your computer</p>
<ol>
<li value="2">Open <strong class="bold">SQLiteStudio</strong> and you should see something like this:</li>
</ol>
<div><div><img alt="Figure 12.2 – SQLiteStudio is a handy program for managing SQLite databases" src="img/B20976_12_002.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – SQLiteStudio is a handy program for managing SQLite databases</p>
<ol>
<li value="3">We need to create a new<a id="_idIndexMarker765"/> database before we start; go to <strong class="bold">Database</strong> | <strong class="bold">Add a database</strong>. Select the <strong class="bold">SQLite 3</strong> option for your database type, followed by selecting your file name and <a id="_idIndexMarker766"/>setting your database name. Then, click the <strong class="bold">Test connection</strong> button. You should see a green tick appearing beside the button. After that, click on the <strong class="bold">OK</strong> button:</li>
</ol>
<div><div><img alt="Figure 12.3 – Creating a new SQLite 3 database" src="img/B20976_12_003.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Creating a new SQLite 3 database</p>
<ol>
<li value="4">Once the database has<a id="_idIndexMarker767"/> been created, you should see the database appear in the <strong class="bold">Databases</strong> window. Then, right-click on <strong class="bold">Tables</strong> and select <strong class="bold">Create a table</strong> option from the menu that pops up:</li>
</ol>
<div><div><img alt="Figure 12.4 – Select the Create a table option from the menu" src="img/B20976_12_004.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Select the Create a table option from the menu</p>
<ol>
<li value="5">Set the table name as <code>employee</code>. Then, click on the <strong class="bold">Add column (lns)</strong> button located above the <a id="_idIndexMarker768"/>table name input field. The <strong class="bold">Column</strong> window will now pop up:</li>
</ol>
<div><div><img alt="Figure 12.5 – Create a new column called emp_id" src="img/B20976_12_005.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Create a new column called emp_id</p>
<ol>
<li value="6">Set the column name as <code>emp_id</code>, set the data type as <strong class="bold">INTEGER</strong>, and check the <strong class="bold">Primary key</strong> checkbox. Then, click <a id="_idIndexMarker769"/>on the <strong class="bold">Configure</strong> button<a id="_idIndexMarker770"/> at the right of the <strong class="bold">Primary key</strong> checkbox. The <strong class="bold">Edit constraint</strong> window will now pop up. Check on the <strong class="bold">Autoincrement</strong> checkbox and click <strong class="bold">Apply</strong>:</li>
</ol>
<div><div><img alt="Figure 12.6 – Enable the Autoincrement checkbox" src="img/B20976_12_006.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Enable the Autoincrement checkbox</p>
<ol>
<li value="7">After that, press the <code>emp_id</code>. Let’s repeat the steps above (without enabling the<a id="_idIndexMarker771"/> primary key) to create other columns. You may follow the same settings as seen here:</li>
</ol>
<div><div><img alt="Figure 12.7 – Create all five columns" src="img/B20976_12_007.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Create all five columns</p>
<ol>
<li value="8">The columns are not actually created at this point. Click on the button with a green tick icon located<a id="_idIndexMarker772"/> above the table name. A window will pop up to confirm the creation of the columns. Press <strong class="bold">OK</strong> to proceed:</li>
</ol>
<div><div><img alt="Figure 12.8 – Click the OK button to confirm" src="img/B20976_12_008.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Click the OK button to confirm</p>
<ol>
<li value="9">Now, we have created the <code>employee</code> table. Let’s move on from the <code>employee</code> table, which is currently empty. Let’s insert dummy data into the <code>employee</code> table by<a id="_idIndexMarker773"/> clicking on the <strong class="bold">Insert row (Ins)</strong> button, which is the one with a green plus icon. Then, simply insert some dummy data like so:</li>
</ol>
<div><div><img alt="Figure 12.9 – Insert dummy data into the employee table" src="img/B20976_12_009.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Insert dummy data into the employee table</p>
<ol>
<li value="10">Let’s set up the SQL driver for our Qt project. Just go to your Qt installation folder and look for the <code>sqldrivers</code> folder. For example, mine is located at <code>C:\Qt\6.4.2\mingw_64\plugins\sqldrivers</code>.</li>
<li>Copy the entire <code>sqldrivers</code> folder to your project’s build directory. You can remove the DLL files that are not relevant to the SQL server you’re running. In our case, since we’re using <code>qsqlite.dll</code>.</li>
<li>The DLL files mentioned in the previous step are the drivers that enable Qt to communicate with different<a id="_idIndexMarker774"/> types of SQL architecture. You may also need the DLL file of the SQL client library in order for the driver to work. In our case, we need <code>sqlite3.dll</code> to be located in the same directory as our program’s executable. You can either get it from the installation directory of <strong class="bold">SQLiteStudio</strong> or from the official website of <strong class="bold">SQLite</strong>: <a href="https://www.sqlite.org/download.html">https://www.sqlite.org/download.html</a>.</li>
</ol>
<h2 id="_idParaDest-248"><a id="_idTextAnchor248"/>How it works…</h2>
<p>Qt provides us with SQL <a id="_idIndexMarker775"/>drivers so that we can easily connect to different types of SQL servers without implementing them ourselves.</p>
<p>Currently, Qt officially supports SQLite, ODBC, and PostgreSQL. If you need to connect directly to MySQL, you need to recompile Qt drivers by yourself, which is out of the scope of this book. For security reasons, it’s not recommended that you connect to MySQL directly from your application. Instead, your application should interact with your MySQL database (or any other SQL servers that are not officially supported by Qt) indirectly by sending an HTTP request using <code>QNetworkAccessManager</code> to your backend script (such as PHP, ASP, and JSP), which can then communicate with the database.</p>
<p>If you only need a simple file-based database and don’t plan to use a server-based database, <strong class="bold">SQLite</strong> is a good choice for you, which is what we have chosen for this chapter.</p>
<p>In the <em class="italic">Connecting to a database</em> recipe, we will learn how to connect to our SQL database using Qt’s SQL module.</p>
<h1 id="_idParaDest-249"><a id="_idTextAnchor249"/>Connecting to a database</h1>
<p>In this recipe, we will learn how to <a id="_idIndexMarker776"/>connect our Qt 6 application to the SQL server.</p>
<h2 id="_idParaDest-250"><a id="_idTextAnchor250"/>How to do it…</h2>
<p>Connecting to SQL Server in Qt is really simple:</p>
<ol>
<li>Open Qt Creator and create a new <strong class="bold">Qt Widgets </strong><strong class="bold">Application</strong> project.</li>
<li>Open your project file (<code>.pro</code>), add the <code>sql</code> module to your project, and run <code>qmake</code> like this:<pre class="source-code">
QT += core gui <code>mainwindow.ui</code> and drag seven label widgets, a combo box, and a checkbox to the canvas. Set the <code>text</code> properties of four of the labels to <code>Name:</code>, <code>Age:</code>, <code>Gender:</code>, and <code>Married:</code>. Then, set the <code>objectName</code> properties of the rest to name, age, gender, and married. There is no need to set the object name for the previous four labels because they’re for display purposes only:</li>
</ol>
<div><div><img alt="Figure 12.10 –  Setting the text properties" src="img/B20976_12_010.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10 –  Setting the text properties</p>
<ol>
<li value="4">Open <code>mainwindow.h</code> and add <a id="_idIndexMarker777"/>the following headers below the <code>QMainWindow</code> header:<pre class="source-code">
#include &lt;QMainWindow&gt;
<strong class="bold">#include &lt;QtSql&gt;</strong>
<strong class="bold">#include &lt;QSqlDatabase&gt;</strong>
<strong class="bold">#include &lt;QSqlQuery&gt;</strong>
<code>mainwindow.cpp</code> and insert the following code into the class constructor:<pre class="source-code">
MainWindow::MainWindow(QWidget *parent) :
     QMainWindow(parent), ui(new Ui::MainWindow) {
     ui-&gt;setupUi(this);
     <strong class="bold">QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE");</strong>
     <strong class="bold">db.setDatabaseName("database.db3");</strong></pre></li> <li>Start the SQL query once the database connection has been opened:<pre class="source-code">
     if (db.open()) {
           QSqlQuery query;
           if (query.exec("SELECT emp_name, emp_age, emp_gender, emp_married FROM employee")) {
                 while (query.next()) {
                       qDebug() &lt;&lt; query.value(0) &lt;&lt; query.value(1) &lt;&lt;
query.value(2) &lt;&lt; query.value(3);
                       ui-&gt;name-&gt;setText(query.value(0).toString());
                       ui-&gt;age-&gt;setText(query.value(1).toString());
                       ui-&gt;gender-&gt;setCurrentIndex(query.value(2).toInt());
                       ui-&gt;married-&gt;setChecked(query.value(3).toBool());
                 }
           }</pre></li> <li>Print out any error <a id="_idIndexMarker778"/>texts:<pre class="source-code">
           else {
                 qDebug() &lt;&lt; query.lastError().text();
           }
           db.close();
     }
     else {
           qDebug() &lt;&lt; "Failed to connect to database.";
     }
}</pre></li> <li>If you compile and run your<a id="_idIndexMarker779"/> project now, you should get something like this:</li>
</ol>
<div><div><img alt="Figure 12.11 – The data from our database is now showing on the Qt program" src="img/B20976_12_011.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11 – The data from our database is now showing on the Qt program</p>
<h2 id="_idParaDest-251"><a id="_idTextAnchor251"/>How it works…</h2>
<p>The previous example shows you how to connect to your SQL database using the <code>QSqlDatabase</code> class derived from the SQL module. You won’t be able to access any of the classes related to SQL without adding the module to your Qt project.</p>
<p>We must tell Qt which SQL architecture we are running by mentioning it when calling the <code>addDatabase()</code> function. The options supported by Qt are <code>QSqlDatabase: QMYSQL driver not loaded</code>, you should check whether the DLL files are placed in the correct directory.</p>
<p>We can send our SQL statements to the database through the <code>QSqlQuery</code> class and wait for it to return the results, which are usually either the data you requested or error messages due to invalid statements. If there are any data coming from the database server, they will all be stored in the <code>QSqlQuery</code> class. All you need to retrieve these data is to perform a “while” loop on the <code>QSqlQuery</code> class to check for all existing records and retrieve them by calling the <code>value()</code> function.</p>
<p>Since we used SQLite in the preceding example, we don’t need to set the server host, username, and password when connecting to the database. SQLite is a file-based SQL database; therefore, we only need to set the file name when calling <code>QSqlDatabase::setDatabaseName()</code>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Qt 6 no longer officially <a id="_idIndexMarker780"/>supports QMYSQL or QMYSQL3. You can add MySQL support by re-compiling Qt from the source yourself. However, this method is not recommended for beginners. For more information, check out <a href="https://doc.qt.io/qt-6/sql-driver.html#compile-qt-with-a-specific-driver">https://doc.qt.io/qt-6/sql-driver.html#compile-qt-with-a-specific-driver</a>.</p>
<h1 id="_idParaDest-252"><a id="_idTextAnchor252"/>Writing basic SQL queries</h1>
<p>In the previous example, we <a id="_idIndexMarker781"/>wrote our very first SQL query, which involves the <code>SELECT</code> statement. This time, we will learn how to use some other SQL statements, such as <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>.</p>
<h2 id="_idParaDest-253"><a id="_idTextAnchor253"/>How to do it…</h2>
<p>Let’s create a simple program that demonstrates basic SQL query commands by following these steps:</p>
<ol>
<li>We can use our previous project files, but there are a couple of things we need to change. Open <code>mainwindow.ui</code> and replace the labels for <code>UPDATE</code>, <code>INSERT</code>, and <code>DELETE</code>:</li>
</ol>
<div><div><img alt="Figure 12.12 – Modify the UI to this" src="img/B20976_12_012.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12 – Modify the UI to this</p>
<ol>
<li value="2">Open <code>mainwindow.h</code> and add the following variables under the private inheritance:<pre class="source-code">
private:
     Ui::MainWindow *ui;
     <strong class="bold">QSqlDatabase db;</strong>
     <strong class="bold">bool connected;</strong>
     <code>mainwindow.cpp</code> and go to the class constructor. It is still pretty much the same as the previous example, except we store the database connection status in a Boolean <a id="_idIndexMarker782"/>variable called <code>connected</code>, and we also obtain the ID of the data from the database and store it in an integer variable called <code>currentID</code>:<pre class="source-code">
MainWindow::MainWindow(QWidget *parent) :
     QMainWindow(parent), ui(new Ui::MainWindow) {
     ui-&gt;setupUi(this);
     <strong class="bold">db = QSqlDatabase::addDatabase("QSQLITE");</strong>
     <strong class="bold">db.setDatabaseName("database.db3");</strong>
     <strong class="bold">connected = db.open();</strong></pre></li> <li>Let’s make a query after we have connected to the database:<pre class="source-code">
     if (connected) {
           QSqlQuery query;
           if (query.exec("SELECT emp_id, emp_name, emp_age, emp_gender, emp_married FROM employee")) {
                 while (query.next()) {
                       currentID = query.value(0).toInt();
                       ui-&gt;name-&gt;setText(query.value(1).toString());
                       ui-&gt;age-&gt;setText(query.value(2).toString());
                       ui-&gt;gender-&gt;setCurrentIndex(query.value(3).toInt());
                       ui-&gt;married-&gt;setChecked(query.value(4).toBool());
                 }
           }</pre></li> <li>Print out any error <a id="_idIndexMarker783"/>messages:<pre class="source-code">
           else {
                 qDebug() &lt;&lt; query.lastError().text();
           }
     }
     else {
           qDebug() &lt;&lt; "Failed to connect to database.";
     }
}</pre></li> <li>Go to <code>mainwindow.ui</code> and right-click on one of the buttons we added to the canvas in step 1. Select <code>mainwindow.h</code> and <code>mainwindow.cpp</code>:<pre class="source-code">
private slots:
     void on_updateButton_clicked();
     void on_insertButton_clicked();
     void on_deleteButton_clicked();</pre></li> <li>Open <code>mainwindow.cpp</code> and we will declare what the program will do when we click on the <strong class="bold">Update</strong> button:<pre class="source-code">
void MainWindow::on_updateButton_clicked() {
     if (connected) {
           if (currentID == 0) {
                 qDebug() &lt;&lt; "Nothing to update.";
           }
           else {
                 QString id = QString::number(currentID);
                 QString name = ui-&gt;name-&gt;text();
                 QString age = ui-&gt;age-&gt;text();
                 QString gender =
QString::number(ui-&gt;gender-&gt;currentIndex());
                 QString married =
QString::number(ui-&gt;married-&gt;isChecked());</pre></li> <li>Make an <code>UPDATE</code> query<a id="_idIndexMarker784"/> like so:<pre class="source-code">
                 qDebug() &lt;&lt; "UPDATE employee SET emp_name = '" + name + "', emp_age = '" + age + "', emp_gender = " + gender + ", emp_married = " + married + " WHERE emp_id = " + id;
                 QSqlQuery query;
                 if (query.exec("UPDATE employee SET emp_name = '" + name + "', emp_age = '" + age + "', emp_gender = " + gender + ", emp_married = " + married + " WHERE emp_id = " + id)) {
                       qDebug() &lt;&lt; "Update success.";
                 }</pre></li> <li>Print out the last error message, if any:<pre class="source-code">
                 else {
                       qDebug() &lt;&lt; query.lastError().text();
                 }
           }
     }
     else {
           qDebug() &lt;&lt; "Failed to connect to database.";
     }
}</pre></li> <li>Declare what will <a id="_idIndexMarker785"/>happen when the <strong class="bold">INSERT</strong> button is clicked:<pre class="source-code">
void MainWindow::on_insertButton_clicked() {
     if (connected) {
           QString name = ui-&gt;name-&gt;text();
           QString age = ui-&gt;age-&gt;text();
           QString gender =
QString::number(ui-&gt;gender-&gt;currentIndex());
           QString married =
QString::number(ui-&gt;married-&gt;isChecked());
           qDebug() &lt;&lt; "INSERT INTO employee (emp_name, emp_age, emp_gender, emp_married) VALUES ('" + name + "','" + age + "', " + gender + "," + married + ")";</pre></li> <li>Make an <code>INSERT</code> query like so:<pre class="source-code">
           QSqlQuery query;
           if (query.exec("INSERT INTO employee (emp_name, emp_age, emp_gender, emp_married) VALUES ('" + name + "','" + age + "', " + gender + "," + married + ")")) {
                 currentID = query.lastInsertId().toInt();
                 qDebug() &lt;&lt; "Insert success.";
           } else {
                 qDebug() &lt;&lt; query.lastError().text();
           }
     }
     else {
           qDebug() &lt;&lt; "Failed to connect to database.";
     }
}</pre></li> <li>Declare what will<a id="_idIndexMarker786"/> happen when the <strong class="bold">Delete</strong> button is clicked:<pre class="source-code">
void MainWindow::on_deleteButton_clicked() {
     if (connected) {
           if (currentID == 0) {
                 qDebug() &lt;&lt; "Nothing to delete.";
           } else {
                 QString id = QString::number(currentID);
                 qDebug() &lt;&lt; "DELETE FROM employee WHERE emp_id = " + id;
                 QSqlQuery query;
                 if (query.exec("DELETE FROM employee WHERE emp_id = " + id)) {
                       currentID = 0;
                       qDebug() &lt;&lt; "Delete success.";
                 } else {
                       qDebug() &lt;&lt; query.lastError().text();
                 }
           }
     }
     else {
           qDebug() &lt;&lt; "Failed to connect to database.";
     }
}</pre></li> <li>Call <code>QSqlDatabase::close()</code> at the class destructor to properly terminate the SQL connection <a id="_idIndexMarker787"/>before exiting the program:<pre class="source-code">
MainWindow::~MainWindow() {
     db.close();
     delete ui;
}</pre></li> <li>If you compile and run the program now, you should be able to select the default data from the database. Then, you can choose to update it or delete it from the database. You can also insert new data into the database by clicking the Insert button. You can use <strong class="bold">SQLiteStudio</strong> to check whether the data are being altered correctly:</li>
</ol>
<div><div><img alt="Figure 12.13 – Data successfully modified in SQLite" src="img/B20976_12_013.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13 – Data successfully modified in SQLite</p>
<h2 id="_idParaDest-254"><a id="_idTextAnchor254"/>How it works…</h2>
<p>It’s very important to check whether the database is connected before we proceed to send an SQL query to the database. Therefore, we keep that status in a variable and use it to check before sending out any queries. This, however, is not recommended for complex programs that are kept <a id="_idIndexMarker788"/>open for long periods of time, as the database might get disconnected during those periods, and a fixed variable may not be accurate. In that case, it’s better to check the actual status by calling <code>QSqlDatabase::isOpen()</code>.</p>
<p>The <code>currentID</code> variable is used to save the ID of the current data you obtained from the database. When you want to update the data or delete them from the database, this variable is crucial for letting the database know what data you’re trying to update or delete. If you set your database table correctly, SQLite will treat each item of data as a unique entry, so you can be sure that no repeated ID will be produced in the database when new data are being saved.</p>
<p>After inserting new data into the database, we call <code>QSqlQuery::lastInsertId()</code> to obtain the ID of the new data and save it as a <code>currentID</code> variable so that it becomes the current data that we can update or delete from the database. It is a good habit to test your SQL queries on <code>SQLiteStudio</code> before using them in Qt. You can instantly find out whether your SQL statements are correct or incorrect instead of waiting for your project to be built, trying it out, and then rebuilding it. As programmers, we must work in the most efficient way.</p>
<p>Work hard and work smart.</p>
<h1 id="_idParaDest-255"><a id="_idTextAnchor255"/>Creating a login screen with Qt</h1>
<p>In this recipe, we will learn <a id="_idIndexMarker789"/>how put our knowledge to use and create a<a id="_idIndexMarker790"/> functional login screen using Qt and SQLite.</p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor256"/>How to do it…</h2>
<p>Create your first functional login screen by following these steps:</p>
<ol>
<li>Open a web browser and go to <code>user</code>, which looks like this:</li>
</ol>
<div><div><img alt="Figure 12.14 – Create a new user table" src="img/B20976_12_014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14 – Create a new user table</p>
<ol>
<li value="2">Let’s insert our first item of data into the newly created table and set <code>user_employeeID</code> to the ID of an existing employee. In this way, the user account we create will be linked to the data of one of the employees:</li>
</ol>
<div><div><img alt="Figure 12.15 – The user_employeeID column is linked to the employee’s emp_id column" src="img/B20976_12_015.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.15 – The user_employeeID column is linked to the employee’s emp_id column</p>
<ol>
<li value="3">Open <code>mainwindow.ui</code>. Place a<a id="_idIndexMarker791"/> stacked widget on the canvas and make sure it contains <a id="_idIndexMarker792"/>two pages. Then, set up the two pages in the stacked widget as follows:</li>
</ol>
<div><div><img alt="Figure 12.16 – Create a two-page UI inside a stacked widget" src="img/B20976_12_016.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.16 – Create a two-page UI inside a stacked widget</p>
<ol>
<li value="4">On the first page of the stacked widget, click the <strong class="bold">Edit Tab Order</strong> icon on top of the widget so that you can adjust the order of the widgets in your program:</li>
</ol>
<div><div><img alt="Figure 12.17 – Change the order of the widgets by pressing this button" src="img/B20976_12_017.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.17 – Change the order of the widgets by pressing this button</p>
<ol>
<li value="5">Once you click the <strong class="bold">Edit Tab Order</strong> icon, you will see some numbers appear on top of each widget in the canvas. Make sure the numbers look the same as they do in the screenshot that follows. Otherwise, click <a id="_idIndexMarker793"/>on the numbers to change their order. We only do this for <a id="_idIndexMarker794"/>the first page of the stacked widget; it’s okay to keep the second page as it is:</li>
</ol>
<div><div><img alt="Figure 12.18 – The order of each widget is shown" src="img/B20976_12_018.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.18 – The order of each widget is shown</p>
<ol>
<li value="6">Right-click on the <code>clicked()</code> option is selected and press <strong class="bold">OK</strong>. Qt will then create a slot function for you in your project source files. Repeat this step for the <strong class="bold">Log Out</strong> button as well.</li>
<li>Open <code>mainwindow.h</code> and add the following headers after the <code>#include &lt;</code><code>QMainWindow&gt;</code> line:<pre class="source-code">
#include &lt;QMainWindow&gt;
<strong class="bold">#include &lt;QtSql&gt;</strong>
<strong class="bold">#include &lt;QSqlDatabase&gt;</strong>
<strong class="bold">#include &lt;QSqlQuery&gt;</strong>
<strong class="bold">#include &lt;QMessageBox&gt;</strong>
<code>mainwindow.h</code>:<pre class="source-code">
private:
     Ui::MainWindow *ui;
     QSqlDatabase db;</pre></li> <li>Open <code>mainwindow.cpp</code> and <a id="_idIndexMarker795"/>put this code in the class constructor:<pre class="source-code">
MainWindow::MainWindow(QWidget *parent) :
     QMainWindow(parent),
     ui(new Ui::MainWindow) {
     ui-&gt;setupUi(this);
     <strong class="bold">ui-&gt;stackedWidget-&gt;setCurrentIndex(0);</strong>
     <strong class="bold">db = QSqlDatabase::addDatabase("QSQLITE");</strong>
     <strong class="bold">db.setDatabaseName("database.db3");</strong>
     <strong class="bold">if (!db.open()) {</strong>
           <strong class="bold">qDebug() &lt;&lt; "Failed to connect to database.";</strong>
     <strong class="bold">}</strong>
}</pre></li> <li>Define what will<a id="_idIndexMarker796"/> happen if the <code>Login</code> button is clicked:<pre class="source-code">
void MainWindow::on_loginButton_clicked() {
     QString username = ui-&gt;username-&gt;text();
     QString password = ui-&gt;password-&gt;text();
     QSqlQuery query;
     if (query.exec("SELECT user_employeeID from user WHERE user_username = '" + username + "' AND user_password = '" + password + "'")) {
           int resultSize = 0;
           while (query.next()) {
                 QString employeeID = query.value(0).toString();
                 QSqlQuery query2;</pre></li> <li>Make a SQL <a id="_idIndexMarker797"/>query:<pre class="source-code">
                 if (query2.exec("SELECT emp_name, emp_age, emp_gender, emp_married FROM employee WHERE emp_id = " + employeeID)) {
                       while (query2.next()) {
                             QString name = query2.value(0).toString();
                             QString age = query2.value(1).toString();
                             int gender = query2.value(2).toInt();
                             bool married = query2.value(3).toBool();
                             ui-&gt;name-&gt;setText(name);
                             ui-&gt;age-&gt;setText(age);</pre></li> <li>We continue with<a id="_idIndexMarker798"/> the preceding code, and we set the gender and married texts before switching the stacked widget to its second page:<pre class="source-code">
                             if (gender == 0)
                                   ui-&gt;gender-&gt;setText("Male");
                             else
                                   ui-&gt;gender-&gt;setText("Female");
                             if (married)
                                   ui-&gt;married-&gt;setText("Yes");
                             else
                                   ui-&gt;married-&gt;setText("No");
                             ui-&gt;stackedWidget-&gt;setCurrentIndex(1);
                       }
                 }
                 resultSize++;
           }</pre></li> <li>Print an error <a id="_idIndexMarker799"/>message if the<a id="_idIndexMarker800"/> login fails:<pre class="source-code">
           if (resultSize == 0)
           {
                 QMessageBox::warning(this, "Login failed", "Invalid username or password.");
           }
     }
     else
     {
           qDebug() &lt;&lt; query.lastError().text();
     }
}</pre></li> <li>Define what will happen<a id="_idIndexMarker801"/> if the <strong class="bold">Log Out</strong> button is clicked:<pre class="source-code">
void MainWindow::on_logoutButton_clicked() {
     ui-&gt;stackedWidget-&gt;setCurrentIndex(0);
}</pre></li> <li>Close the database<a id="_idIndexMarker802"/> when the main window is closed:<pre class="source-code">
MainWindow::~MainWindow() {
     db.close();
     delete ui;
}</pre></li> <li>Compile and run the program, and you should be able to log in with the dummy account. After you have logged in, you should be able to see the dummy employee information linked to the user account. You can also log out by clicking on the <strong class="bold">Log </strong><strong class="bold">Out</strong> button:</li>
</ol>
<div><div><img alt="Figure 12.19 – A simple, working login screen" src="img/B20976_12_019.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.19 – A simple, working login screen</p>
<h2 id="_idParaDest-257"><a id="_idTextAnchor257"/>How it works…</h2>
<p>In this example, we select data from the user table that matches the username and password that we inserted into the text fields. If nothing is found, it means we have provided an invalid username <a id="_idIndexMarker803"/>or password. Otherwise, obtain the <code>user_employeeID</code> data from the user account <a id="_idIndexMarker804"/>and do another SQL query to look for information from the <code>employee</code> table that matches the <code>user_employeeID</code> variable. Then, display the data according to the UI of your program.</p>
<p>We must set the widget order in the <strong class="bold">Edit Tab Order</strong> mode so that when the program has started, the first widget that gets focused on is the username line-edit widget. If the user presses the <em class="italic">Tab</em> key on the keyboard, the focus should switch to the second widget, which is the password line edit. An incorrect widget order will ruin the user experience and drive away any potential users. Make sure that the <strong class="bold">echoMode</strong> option of the password line edit is set to <strong class="bold">Password</strong>. That setting will hide the actual password inserted into the line edit and replace it with dot symbols for security purposes.</p>
<p>Since SQLite does not support returning the query size, we cannot use the <code>QSqlQuery::size()</code> function to determine how many results are being returned; the result will always be -<code>1</code>. Therefore, we declared a <code>resultSize</code> variable to count the result within the while loop operation.</p>
<h1 id="_idParaDest-258"><a id="_idTextAnchor258"/>Displaying information from a database in model view</h1>
<p>Follow these steps to display <a id="_idIndexMarker805"/>information from a database on a model view widget:</p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor259"/>How to do it…</h2>
<p>In this recipe, we will learn how to display multiple sets of data obtained from our SQL database in a model view in our program:</p>
<ol>
<li>We will be using the database table called <code>employee</code>, which we used in the previous example in <em class="italic">Creating a login screen with Qt</em>. This time, we need a lot more data in the employee table. Open up your <strong class="bold">SQLiteStudio</strong> control panel. Add data for a few more employees so that we can display it later in our program:</li>
</ol>
<div><div><img alt="Figure 12.20 – Add more dummy data to the employee table" src="img/B20976_12_020.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.20 – Add more dummy data to the employee table</p>
<ol>
<li value="2">Open Qt Creator, create a new <strong class="bold">Qt Widgets Application</strong> project, and then add the <strong class="bold">SQL</strong> module to your project.</li>
<li>Open <code>mainwindow.ui</code> and add a table widget (not a table view) from <strong class="bold">Item Widget</strong> (item-based) under the <strong class="bold">Widget</strong> box pane. Select the main window on the canvas and click on <a id="_idIndexMarker806"/>either the <strong class="bold">Lay Out Vertically</strong> or <strong class="bold">Lay Out Horizontally</strong> button to make the table widget stick to the size of the main window even when it’s resized:</li>
</ol>
<div><div><img alt="Figure 12.21 – Click on the Lay Out Vertically button" src="img/B20976_12_021.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.21 – Click on the Lay Out Vertically button</p>
<ol>
<li value="4">Double-click on the table widget and a window will appear. Under the <strong class="bold">Columns</strong> tab, add five items by clicking on the <strong class="bold">+</strong> button in the top-left corner. Name the items <strong class="bold">ID</strong>, <strong class="bold">Name</strong>, <strong class="bold">Age</strong>, <strong class="bold">Gender</strong>, and <strong class="bold">Married</strong>. Click <strong class="bold">OK</strong> when you’re done:</li>
</ol>
<div><div><img alt="Figure 12.22 – We also set the text alignment to center" src="img/B20976_12_022.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.22 – We also set the text alignment to center</p>
<ol>
<li value="5">Right-click on the table widget and select <code>itemChanged(QTableWidgetItem*)</code> option in the pop-up <a id="_idIndexMarker807"/>window, and press <strong class="bold">OK</strong>. A slot function will be created in both of your source files.</li>
<li>Open <code>mainwindow.h</code> and add these private variables to the <code>MainWindow</code> class:<pre class="source-code">
private:
     Ui::MainWindow *ui;
     <strong class="bold">bool hasInit;</strong>
     <code>mainwindow.h</code>:<pre class="source-code">
#include &lt;QtSql&gt;
#include &lt;QSqlDatabase&gt;
#include &lt;QSqlQuery&gt;
#include &lt;QMessageBox&gt;
#include &lt;QDebug&gt;
#include &lt;QTableWidgetItem&gt;</pre></li> <li>Open <code>mainwindow.cpp</code>; we’re going to write tons of code there. We need to declare what will happen when the program is started. Add the following code to the constructor <a id="_idIndexMarker808"/>of the <code>MainWindow</code> class:<pre class="source-code">
MainWindow::MainWindow(QWidget *parent) :
     QMainWindow(parent),
     ui(new Ui::MainWindow)
{
     <strong class="bold">hasInit = false;</strong>
     ui-&gt;setupUi(this);
     <strong class="bold">db = QSqlDatabase::addDatabase("QSQLITE");</strong>
     <strong class="bold">db.setDatabaseName("database.db3");</strong>
     <strong class="bold">ui-&gt;tableWidget-&gt;setColumnHidden(0, true);</strong></pre></li> <li>The SQL query code looks like this:<pre class="source-code">
     if (db.open()) {
           QSqlQuery query;
           if (query.exec("SELECT emp_id, emp_name, emp_age, emp_gender, emp_married FROM employee")) {
                 while (query.next()) {
                       qDebug() &lt;&lt; query.value(0) &lt;&lt; query.value(1) &lt;&lt; query.value(2) &lt;&lt; query.value(3) &lt;&lt; query.value(4);
                       QString id = query.value(0).toString();
                       QString name = query.value(1).toString();
                       QString age = query.value(2).toString();
                       int gender = query.value(3).toInt();
                       bool married = query.value(4).toBool();</pre></li> <li>Create <a id="_idIndexMarker809"/>several <code>QTableWidgetItem</code> objects:<pre class="source-code">
                       ui-&gt;tableWidget-&gt;setRowCount(ui-&gt;tableWidget-&gt;rowCount() + 1);
                       QTableWidgetItem* idItem = new QTableWidgetItem(id);
                       QTableWidgetItem* nameItem = new QTableWidgetItem(name);
                       QTableWidgetItem* ageItem = new QTableWidgetItem(age);
                       QTableWidgetItem* genderItem = new QTableWidgetItem();
                       if (gender == 0)
                             genderItem-&gt;setData(0, "Male");
                       else
                             genderItem-&gt;setData(0, "Female");
                       QTableWidgetItem* marriedItem = new QTableWidgetItem();
                       if (married)
                             marriedItem-&gt;setData(0, "Yes");
                       else
                             marriedItem-&gt;setData(0, "No");</pre></li> <li>Move those <a id="_idIndexMarker810"/>objects to the table widget:<pre class="source-code">
                       ui-&gt;tableWidget-&gt;setItem(ui-&gt;tableWidget-&gt;rowCount() - 1, 0, idItem);
                       ui-&gt;tableWidget-&gt;setItem(ui-&gt;tableWidget-&gt;rowCount() - 1, 1, nameItem);
                       ui-&gt;tableWidget-&gt;setItem(ui-&gt;tableWidget-&gt;rowCount() - 1, 2, ageItem);
                       ui-&gt;tableWidget-&gt;setItem(ui-&gt;tableWidget-&gt;rowCount() - 1, 3, genderItem);
                       ui-&gt;tableWidget-&gt;setItem(ui-&gt;tableWidget-&gt;rowCount() - 1, 4, marriedItem);
                 }
                 hasInit = true;
           }
           else {
                 qDebug() &lt;&lt; query.lastError().text();
           }
     }
     else {
           qDebug() &lt;&lt; "Failed to connect to database.";
     }
}</pre></li> <li>Declare what will happen when an item of the table widget has been edited. Add the<a id="_idIndexMarker811"/> following code to the <code>on_tableWidget_itemChanged()</code> slot function:<pre class="source-code">
void MainWindow::on_tableWidget_itemChanged(QTableWidgetItem *item) {
     if (hasInit) {
           QString id = ui-&gt;tableWidget-&gt;item(item-&gt;row(), 0)-&gt;data(0).toString();
           QString name = ui-&gt;tableWidget-&gt;item(item-&gt;row(), 1)-&gt;data(0).toString();
           QString age = QString::number(ui-&gt;tableWidget-&gt;item(item-&gt;row(), 2)-&gt;data(0).toInt());
           ui-&gt;tableWidget-&gt;item(item-&gt;row(), 2)-&gt;setData(0, age);
           QString gender;
           if (ui-&gt;tableWidget-&gt;item(item-&gt;row(), 3)-&gt;data(0).toString() == "Male") {
                 gender = "0";
           } else {
                 ui-&gt;tableWidget-&gt;item(item-&gt;row(), 3)-&gt;setData(0,"Female");
                 gender = "1";
           }
           QString married;
           if (ui-&gt;tableWidget-&gt;item(item-&gt;row(), 4)-&gt;data(0).toString() == "No") {
                 married = "0";
           } else {
                 ui-&gt;tableWidget-&gt;item(item-&gt;row(), 4)-&gt;setData(0, "Yes");
                 married = "1";
           }
           qDebug() &lt;&lt; id &lt;&lt; name &lt;&lt; age &lt;&lt; gender &lt;&lt; married;
           QSqlQuery query;
           if (query.exec("UPDATE employee SET emp_name = '" + name + "', emp_age = '" + age + "', emp_gender = '" + gender + "', emp_married = '" + married + "' WHERE emp_id = " + id)) {
                 QMessageBox::information(this, "Update Success", "Data updated to database.");
           } else {
                 qDebug() &lt;&lt; query.lastError().text();
           }
     }
}</pre></li> <li>Close the <a id="_idIndexMarker812"/>database at the class destructor:<pre class="source-code">
MainWindow::~MainWindow() {
     db.close();
     delete ui;
}</pre></li> <li>If you compile and run the example now, you should get something like this:</li>
</ol>
<div><div><img alt="Figure 12.23 – We have created our own SQL editor" src="img/B20976_12_023.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.23 – We have created our own SQL editor</p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor260"/>How it works…</h2>
<p>The table widget is similar to <a id="_idIndexMarker813"/>the one you see in spreadsheet <a id="_idIndexMarker814"/>applications such as <strong class="bold">Microsoft Excel</strong> and <strong class="bold">OpenOffice Calc</strong>. In contrast to other types of<a id="_idIndexMarker815"/> model viewers, such as list view or tree view, table view (or table widget) is a two-dimensional model viewer, which displays data in the form of rows and columns.</p>
<p>The main difference between a table view and a table widget in Qt is that a table widget is built on top of a table view class, which means a table widget is easier to use and more suitable for beginners. However, a table widget is less flexible and tends to be less scalable than a table view, which is not the best choice if you want to customize your table. After retrieving data from SQLite, we created a <code>QTableWidgetItem</code> item for each of the data items and set which column and row should be added to the table widget. Before adding an item to the table widget, we must increase the row count of the table by calling <code>QTableWidget::setRowCount()</code>. We can also get the current row count of the table widget by simply calling <code>QTableWidget::rowCount()</code>.</p>
<p>The first column from the left is hidden from view because we only use it to save the ID of the data so that we can use it to update the database when one of the data items in its row has changed. The <code>on_tableWidget_itemChanged()</code> slot function will be called when the data in one of the cells has changed. It will not only get called when you edit the data in the cell but also when the data are first added to the table after being retrieved from the database. To ensure that this function is only triggered when we edit the data, we use a Boolean <a id="_idIndexMarker816"/>variable called <code>hasInit</code> to check whether we have done the initialization process (adding the first batch of data to the table). If <code>hasInit</code> is false, ignore the function call.</p>
<p>To prevent users from entering a totally irrelevant type of data, such as inserting letters into a numerical-only data cell, we manually check whether the data are anything close to what we’d expected when they were being edited. Revert it to a default value if it doesn’t come close to anything considered valid. This is, of course, a simple hack, which does the job but is not the most professional method. Alternatively, you can try to create a new class that inherits the <code>QItemDelegate</code> class and defines how your model view should behave. Then, call <code>QTableWidget::setItemDelegate()</code> to apply the class to your table widget.</p>
<h1 id="_idParaDest-261"><a id="_idTextAnchor261"/>Advanced SQL queries</h1>
<p>By following this<a id="_idIndexMarker817"/> recipe, you will learn how to use advanced SQL statements such as <code>INNER</code> <code>JOIN</code>, <code>COUNT</code>, <code>LIKE</code>, and <code>DISTINCT</code>.</p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor262"/>How to do it…</h2>
<p>You can do a lot more than just perform simple queries on the SQL database. Let’s follow these steps to learn how:</p>
<ol>
<li>We need to add a few tables to our database before we can dive into the programming part. Open your <strong class="bold">SQLiteStudio</strong>. We need several tables for this example to work:</li>
</ol>
<div><div><img alt="Figure 12.24 – Additional tables that we need to create for this example" src="img/B20976_12_024.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.24 – Additional tables that we need to create for this example</p>
<ol>
<li value="2">I will show you the structure of each of the tables required for this project and the dummy data<a id="_idIndexMarker818"/> inserted into the tables for testing. The first table is called <code>branch</code>, which is used to store the IDs and names of different branches of the dummy company:</li>
</ol>
<div><div><img alt="Figure 12.25 – The branch table" src="img/B20976_12_025.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.25 – The branch table</p>
<ol>
<li value="3">Secondly, we have the <code>department</code> table, which stores the IDs and names of different departments of the dummy company, which is also linked to the <code>branch</code> data by the branch IDs:</li>
</ol>
<div><div><img alt="Figure 12.26 – The department table, which links to the branch table" src="img/B20976_12_026.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.26 – The department table, which links to the branch table</p>
<ol>
<li value="4">We also have an <code>employee</code> table, which stores information on all the employees in the dummy <a id="_idIndexMarker819"/>company. This table is similar to the one we used in the previous examples, except it has two extra columns, <code>emp_birthday</code> and <code>emp_departmentID</code>:</li>
</ol>
<div><div><img alt="Figure 12.27 – The employee table, which links to the department table" src="img/B20976_12_027.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.27 – The employee table, which links to the department table</p>
<ol>
<li value="5">We also have a table called <code>log</code>, which contains dummy records of the login time for each employee. <code>log_loginTime</code> will be set as a date-time variable type:</li>
</ol>
<div><div><img alt="Figure 12.28 – The log table, which links to the user table" src="img/B20976_12_028.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.28 – The log table, which links to the user table</p>
<ol>
<li value="6">We have the <code>user</code> table that<a id="_idIndexMarker820"/> we also used in the previous examples:</li>
</ol>
<div><div><img alt="Figure 12.29 – The user table" src="img/B20976_12_029.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.29 – The user table</p>
<ol>
<li value="7">Open Qt Creator. This time, instead of choosing <strong class="bold">Qt Widgets Application</strong>, we select <strong class="bold">Qt </strong><strong class="bold">Console Application</strong>:</li>
</ol>
<div><div><img alt="Figure 12.30 – Create a Qt Console Application project" src="img/B20976_12_030.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.30 – Create a Qt Console Application project</p>
<ol>
<li value="8">Open your project file (.pro) and add the <code>sql</code> module to your project:<pre class="source-code">
QT += core <strong class="bold">sql</strong>
<code>main.cpp</code> and add<a id="_idIndexMarker821"/> the following header files to the top of the source file:<pre class="source-code">
#include &lt;QSqlDatabase&gt;
#include &lt;QSqlQuery&gt;
#include &lt;QSqlError&gt;
#include &lt;QDate&gt;
#include &lt;QDebug&gt;</pre></li> <li>Add the following function to display employees who are more than 30 years old:<pre class="source-code">
void filterAge() {
     qDebug() &lt;&lt; "== Employees above 40 year old =============";
     QSqlQuery query;
     if (query.exec("SELECT emp_name, emp_age FROM employee WHERE emp_age &gt; 40")) {
           while (query.next()) {
                 qDebug() &lt;&lt; query.value(0).toString() &lt;&lt; query.value(1).toString();
           }
     }
     else {
     qDebug() &lt;&lt; query.lastError().text();
     }
}</pre></li> <li>Add the following<a id="_idIndexMarker822"/> function to display the <code>department</code> and <code>branch</code> information of each employee:<pre class="source-code">
void getDepartmentAndBranch() {
     qDebug() &lt;&lt; "== Get employees' department and branch =============";
     QSqlQuery query;
     if (query.exec("SELECT emp_name, dep_name, brh_name FROM (SELECT emp_name, emp_departmentID FROM employee) AS myEmployee INNER JOIN department ON department.dep_id = myEmployee.emp_departmentID INNER JOIN branch ON branch.brh_id = department.dep_branchID")) {
           while (query.next()) {
                 qDebug() &lt;&lt; query.value(0).toString() &lt;&lt; query.value(1).toString() &lt;&lt; query.value(2).toString();
           }
     }
     else {
           qDebug() &lt;&lt; query.lastError().text();
     }
}</pre></li> <li>Add the following function, which displays employees who are working in the New York branch and are <a id="_idIndexMarker823"/>under 40 years old:<pre class="source-code">
void filterBranchAndAge() {
     qDebug() &lt;&lt; "== Employees from New York and age below 40 =============";
     QSqlQuery query;
     if (query.exec("SELECT emp_name, emp_age, dep_name, brh_name FROM (SELECT emp_name, emp_age, emp_departmentID FROM employee) AS myEmployee INNER JOIN department ON department.dep_id = myEmployee.emp_departmentID INNER JOIN branch ON branch.brh_id = department.dep_branchID WHERE branch.brh_name = 'New York' AND myEmployee.emp_age &lt; 40")) {
           while (query.next()) {
                 qDebug() &lt;&lt; query.value(0).toString() &lt;&lt; query.value(1).toString() &lt;&lt; query.value(2).toString() &lt;&lt; query.value(3).toString();
           }
     }
     else {
     qDebug() &lt;&lt; query.lastError().text();
     }
}</pre></li> <li>Add the following function, which <a id="_idIndexMarker824"/>counts the total number of female employees in the dummy company:<pre class="source-code">
void countFemale() {
     qDebug() &lt;&lt; "== Count female employees =============";
     QSqlQuery query;
     if (query.exec("SELECT COUNT(emp_gender) FROM employee WHERE emp_gender = 1")) {
           while (query.next()) {
                 qDebug() &lt;&lt; query.value(0).toString();
           }
     }
     else {
           qDebug() &lt;&lt; query.lastError().text();
     }
}</pre></li> <li>Add the following <a id="_idIndexMarker825"/>function, which filters the employee list and only displays those names that start with <code>Ja</code>:<pre class="source-code">
void filterName() {
     qDebug() &lt;&lt; "== Employees name start with 'Ja' =============";
     QSqlQuery query;
     if (query.exec("SELECT emp_name FROM employee WHERE emp_name LIKE '%Ja%'")) {
           while (query.next()) {
                 qDebug() &lt;&lt; query.value(0).toString();
           }
     }
     else {
           qDebug() &lt;&lt; query.lastError().text();
     }
}</pre></li> <li>Add the following function, which<a id="_idIndexMarker826"/> displays employees who have birthdays in August:<pre class="source-code">
void filterBirthday() {
     qDebug() &lt;&lt; "== Employees birthday in August =============";
     QSqlQuery query;
     if (query.exec("SELECT emp_name, emp_birthday FROM employee WHERE strftime('%m', emp_birthday) = '08'")) {
           while (query.next()) {
                 qDebug() &lt;&lt; query.value(0).toString() &lt;&lt; query.value(1).toDate().toString("d-MMMM-yyyy");
           }
     }
     else {
           qDebug() &lt;&lt; query.lastError().text();
     }
}</pre></li> <li>Add the following function, which checks who logged into the dummy system on 27 April 2024 and displays<a id="_idIndexMarker827"/> their names on the terminal:<pre class="source-code">
void checkLog() {
     qDebug() &lt;&lt; "== Employees who logged in on 27 April 2024 =============";
     QSqlQuery query;
     if (query.exec("SELECT DISTINCT emp_name FROM (SELECT emp_id, emp_name FROM employee) AS myEmployee INNER JOIN user ON user.user_employeeID = myEmployee.emp_id INNER JOIN log ON log.log_userID = user.user_id WHERE DATE(log.log_loginTime) = '2024-04-27'")) {
           while (query.next()) {
                 qDebug() &lt;&lt; query.value(0).toString();
           }
     }
     else {
           qDebug() &lt;&lt; query.lastError().text();
     }
}</pre></li> <li>In the <code>main()</code> function, connect the program to the SQLite database and call all the functions that we defined in the previous steps. Close the database connection, and we’re done:<pre class="source-code">
int main(int argc, char *argv[]) {
     QCoreApplication a(argc, argv);
     QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE");
     db.setDatabaseName("database.db3");
     if (db.open()) {
           filterAge();
           getDepartmentAndBranch();
           filterBranchAndAge();
           countFemale();
           filterName();
           filterBirthday();
           checkLog();
           db.close();
     }
     else {
           qDebug() &lt;&lt; "Failed to connect to database.";
     }
     return a.exec();
}</pre></li> <li>If you compile and run the project now, you <a id="_idIndexMarker828"/>should see a terminal window that displays the filtered results:</li>
</ol>
<div><div><img alt="Figure 12.31 – Printing the results on the Application Output window" src="img/B20976_12_031.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.31 – Printing the results on the Application Output window</p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor263"/>How it works…</h2>
<p>A console application does <a id="_idIndexMarker829"/>not have a GUI and only shows you a text display in a terminal window. This is usually used in a backend system, as it uses fewer resources compared to a widget application. We used it in this example because it’s faster to display the result without the need to place any widgets in the program, which we don’t need in this case.</p>
<p>We separated the SQL queries into different functions so that it’s easier to maintain the code and it doesn’t become too messy. Do note that in C++, the functions have to be located before the <code>main()</code> function; otherwise, they will not be able to be called by <code>main()</code>.</p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor264"/>There’s more…</h2>
<p>The <code>INNER JOIN</code> statement used in the preceding example joins two tables together and selects all rows from both tables, as long as there is a match between the columns in both tables. There are many other types of <code>JOIN</code> statements that you can use in SQLite (and some other types of SQL architecture), such as <code>LEFT JOIN</code>, <code>RIGHT JOIN</code>, and <code>FULL </code><code>OUTER JOIN</code>.</p>
<p>The following diagram shows the different types of <code>JOIN</code> statements and their effects:</p>
<div><div><img alt="Figure 12.32 – Different types of JOIN statements" src="img/B20976_12_032.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.32 – Different types of JOIN statements</p>
<p>The following bullet points explain the <code>LIKE</code> and <code>DISTINCT</code> statements, which we used in our example code in<a id="_idIndexMarker830"/> this recipe:</p>
<ul>
<li>The <code>LIKE</code> statement is normally used to search for a string variable in the database without the full word. Notice that there are two % symbols located before and after the search keyword.</li>
<li>The <code>DISTINCT</code> statement used in the previous example filters out results that have the exact same variable. For example, without the <code>DISTINCT</code> statement, you will see two versions of Larry King appear in the terminal because there are two records of him logging into the system on the same day. By adding the <code>DISTINCT</code> statement, SQLite will eliminate one of the results and ensure every result is unique.</li>
<li>You may be wondering what <code>d-MMMM-yyyy</code> stands for and why we used it in the preceding example. That is actually an expression supplied to the <code>QDateTime</code> class in Qt to display the date-time result using a given format. In this case, it will change the date-time data that we get from SQLite, 2024-08-06, to the format that we specified, resulting in 6-August-2024.</li>
</ul>
<p>For more information, check out Qt’s documentation at <a href="http://doc.qt.io/qt-6/qdatetime.html#toString">http://doc.qt.io/qt-6/qdatetime.html#toString</a>, which has the full list of expressions that can be used to determine the format of the date and time string.</p>
<p>SQL provides an easy and efficient way to save <a id="_idIndexMarker831"/>and load user data without reinventing the wheel. Qt provides you with an out-of-the-box solution for connecting your application with a SQL database; in this chapter, we have learned how to do this by using a step-by-step approach, and we were able to load and save our user’s data into the SQL database.</p>
</div>
</body></html>