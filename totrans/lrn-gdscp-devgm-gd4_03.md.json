["```cpp\nvar inventory = [\"Key\", \"Potion\", \"Red Flower\", \"Boots\"]\n```", "```cpp\nvar inventory = [\n   \"Key\",\n   \"Potion\",\n   \"Red Flower\",\n   \"Boots\"\n]\n```", "```cpp\nprint( inventory[0] )\n# Prints out: Key\n```", "```cpp\nvar index = 3\nprint(inventory[index])\n```", "```cpp\nvar inventory = [\"Key\", \"Potion\"]\nprints(\"The last item in your inventory is a: \", inventory[-1])\n# Prints out: Potion\n```", "```cpp\ninventory[3] = \"Helmet\"\n```", "```cpp\nvar array_of_numbers = [1, 4, -74, 0]\narray_of_numbers[3] 4 to the third element in our array_of_numbers, 0, so that the value is now 4.\n\t\t\tUsing the assignment operator (`=`) makes it easy to change the elements in an array.\n\t\t\tData types in arrays\n\t\t\tArrays can hold any data type. You can even put multiple different data types in the same array, like so:\n\n```", "```cpp\n\n\t\t\tThis is bad practice because when you want to access one of the elements, you don’t know what you are dealing with. That is why I advise you to always use one data type for all the elements in an array.\n\t\t\tStrings are secretly arrays\n\t\t\tIf you think back to [*Chapter 2*](B19358_02.xhtml#_idTextAnchor044), when I said that strings are called that way because they are *strings of characters*, then this might not seem like a big surprise. But a string can be thought of as an array of characters. So, we can get one specific character, just like we would get one particular element in an array:\n\n```", "```cpp\n\n\t\t\tIn practice, we use this less often, but it is good to know how strings work under the hood.\n\t\t\tManipulating arrays\n\t\t\tSo far, we have created arrays, accessed their elements, and even changed those elements. But there are so many more things that arrays can do. Unlike the standard data types we’ve already encountered, arrays provide functions to us that we could use. Functions are little pieces of code, just like the `_ready()` function we have been writing for each scene, that provides functionality and can do things for us.\n\t\t\tFor example, one of these functions can append an extra element at the end of an array:\n\n```", "```cpp\n\n\t\t\tTry printing out this variable; it will show `[Key, Potion, Sword]`. Cool, right?\n\t\t\tAs you can see, to call a function of an array, add a point (`.`), followed by the name of that function, to the name of that array. This also applies to other data types.\n\t\t\tBut what if we want to append one array to another one? Well, there is a function for that too:\n\n```", "```cpp\n\n\t\t\tNow, the whole `loot` array will be appended at the end of the inventory.\n\t\t\tBut wait, there’s more! What if you need to remove an element? You use the `remove_at()` function. This function removes an element of the array at a certain index:\n\n```", "```cpp\n\n\t\t\tThis will remove the element at index 1\\. But what if you don’t know the position the element is at? You can always find it!\n\n```", "```cpp\n\n\t\t\tThe `find()` function will return the index of the element we were looking for. If it finds nothing, it will return the number `-1`. So, it’s best to check if the number it returns is equal to or larger than 0; otherwise, you might remove the wrong element.\n\t\t\tThe `remove_at()` and `find()` functions are very useful in their own right, but there is also a function that combines the two into one! This is the `erase()` function, and it can be used like this:\n\n```", "```cpp\n\n\t\t\tThis last line of code will give the same result as the snippet of the two lines before because it removes the first instance of `\"Sword\"` it finds within the array.\n\t\t\tArrays are an important concept in programming. They dynamically hold an arbitrary number of elements.\n\t\t\tAfter a small detour into debugging in the next section, we’ll learn how we can loop over these elements and run code for each of them separately using the `for` and `while` keywords.\n\t\t\tDon’t be scared of errors or warnings\n\t\t\tWe’ve encountered errors here and there while writing code, especially during some of the experiments. These errors often contain valuable information about the problem and how to solve it. Let’s examine the following piece of code:\n\t\t\t![Figure 3.1 – An error tells us that the var keyword should be followed by the new variable’s name](img/B19358_03_01.jpg)\n\n\t\t\tFigure 3.1 – An error tells us that the var keyword should be followed by the new variable’s name\n\t\t\tHere, I stopped typing halfway while defining a variable. The code editor immediately gave me an error. As shown at the bottom, it is telling me it expected a variable’s name. Thanks for the hint, engine!\n\t\t\tLet’s look at an error that the engine can’t predict before running the code:\n\n```", "```cpp\n\n\t\t\tAt first glance, this code might look okay, but if you put it in a script and run it, you’ll see the following error pop up:\n\t\t\t![Figure 3.2 – After running this code, the interpreter warns us that the inventory array does not have a 101st element](img/B19358_03_02.jpg)\n\n\t\t\tFigure 3.2 – After running this code, the interpreter warns us that the inventory array does not have a 101st element\n\t\t\tThe **Debugger** panel opened up, clearly stating that there was an *Invalid get index ‘100’ (on base: ‘Array’)* error. This means we used an invalid index to retrieve an element from an array. We can also see a yellow arrow showing the exact line where the error occurred. From this, we can conclude that the inventory array does not have a 101st element and thus, we should not try to print it out.\n\t\t\tSome errors and warnings already pop up while writing the code, such as the first one we saw in this section. This makes it easy to ensure what we write will run. Unfortunately, writing code that does not contain errors or warnings at this stage does not guarantee that executing this code will be error and warning-free. This is because, from the moment we run a piece of code, it can encounter scenarios the code parser could never have considered.\n\t\t\tThese runtime errors and warnings occur because GDScript is a weakly typed language, meaning that any variable can have any type and could even switch types mid-execution. Here’s a simple example:\n\n```", "```cpp\n\n\t\t\tBut this means that during execution, a piece of code could crash. In [*Chapter 4*](B19358_04.xhtml#_idTextAnchor164), you’ll learn how to deal with this uncertainty in an elegant way that keeps the flexibility of loosely typed variables.\n\t\t\tIt is good to appreciate warnings and errors. The engine does not show these to bully us but to nudge us in the right direction to create a better, more solid piece of software. If the engine didn’t care and didn’t crash the game when an error occurred, for example, then we might ship a half-broken game. This is not what we want! We want the best experience for our players with the lowest number of bugs!\n\t\t\tBugs\n\t\t\tWhen a game is broken in some way, be it a crash or a logical error, we say it has **bugs**. This terminology comes from one of the first times a computer malfunctioned and the culprit turned out to be a literal bug that crawled into the machinery. But the term was even used before that by the likes of Thomas Edison to describe “little faults and difficulties” in a piece of hardware.\n\t\t\tIn the next section, we’ll learn about loops.\n\t\t\tLoops\n\t\t\tWe’ve been putting lines of code one after the other and Godot Engine executed them nicely from top to bottom. But there comes a time when we want to repeat one or multiple lines of code. For example, what if we want to print out every item in the player’s inventory in a nice way?\n\t\t\tWe could do something like that with the following code:\n\n```", "```cpp\n\n\t\t\tThis is called a **loop**; this specific one is a **for loop**. We’ll have a look at the two kinds of loops that are present in GDScript in the next few sections.\n\t\t\tFor loops\n\t\t\t A `for` loop called **item**. Of course, we can use the same structure for other arrays and call the temporary variable differently. I chose the name *items* because that is what an inventory contains. Another suitable name could be *item_name*.\n\t\t\tWe can visualize the `for` loop with the following flow chart:\n\t\t\t![Figure 3.3 – The flow of a for loop during the execution of the code](img/B19358_03_03.jpg)\n\n\t\t\tFigure 3.3 – The flow of a for loop during the execution of the code\n\t\t\tAs shown in *Figure 3**.3*, we start the loop from the top. If there is a first element, we follow the *Yes* and execute the code block within the loop for that element. Then, we check if there is a next element. If so, we execute the code block again, now for that element, and so on until there are no more elements left.\n\t\t\tThe `for` loop looks like this:\n\n```", "```cpp\n\n\t\t\tSyntax\n\t\t\tThe preceding structure is also called the syntax of the language. It captures the rules of what is possible and how things should be specified in the language.\n\t\t\tA `for` loop is a very powerful control flow structure. Let’s have a look at some other use cases in which we can use it.\n\t\t\tRange function\n\t\t\tSometimes, you will want to iterate over all indexes within an array. To do so, you can use the `range()` function, which is built into the engine. This function returns an array from `0` to a specified number. Here’s an example:\n\n```", "```cpp\n\n\t\t\tThis code will print out `[0, 1, 2, 3,` `4, 5]`.\n\t\t\tNotice that we gave the number `6` to the function but that the array stops at the number 5.\n\t\t\tWe can use the `range()` function like so:\n\n```", "```cpp\n\n\t\t\tHere, I called the `size()` function on the `inventory` array; this returns the size of the array, which we then can plug right into the `range()` function.\n\t\t\tThe `range()` function can even do more than this. If you provide it with two numbers, it will create an array that starts from the first number and goes up to the second one, excluding it again. Try this:\n\n```", "```cpp\n\n\t\t\tAs an experiment, try constructing a `for` loop with the preceding `range()` function and print the result – that is, `range(16,` `26, 2)`.\n\t\t\tYou’ll see that we go from `16` to `26` as expected. But this time, the interval between each number is `2`. So, we should get the numbers `16`, `18`, `20`, `22` and `24`.\n\t\t\tThe third argument that’s given to a range command defines the size of the step we take between numbers.\n\t\t\tNow that we have the `for` loop and `range()` function under our belt, let’s take a look at the while loop.\n\t\t\tWhile loops\n\t\t\tThe second kind of loop in GDScript is the `if` statement – we give it a condition and repeat its code block, so long as the condition evaluates to `true`. Here’s an example:\n\n```", "```cpp\n\n\t\t\tHere, we remove the first element of the inventory array as long, so the array has a length of more than three elements.\n\t\t\tThe syntax of a `while` loop looks as follows:\n\n```", "```cpp\n\n\t\t\tWhen Godot encounters a `while` statement, it follows these steps:\n\n\t\t\t\t1.  First, it evaluates the condition statement. If it is true, it will go to *step 2*; otherwise. it will skip the code block completely and go to *step 4*.\n\t\t\t\t2.  Second, the code block will be executed.\n\t\t\t\t3.  Third, it will go back to *step 1* to evaluate the condition again and see if it has changed.\n\t\t\t\t4.  Finally, it will execute the rest of the code.\n\n\t\t\tSo `while` loops will loop so long as the condition we defined returns a `true` value.\n\t\t\tWe can visualize a `while` loop with the following flow chart:\n\t\t\t![Figure 3.4 – The flow of a while loop during the execution of the code](img/B19358_03_04.jpg)\n\n\t\t\tFigure 3.4 – The flow of a while loop during the execution of the code\n\t\t\t In *Figure 3**.4*, we start the loop by evaluating the condition we specified. If it results in a `true` value, we execute the code block of the loop. If this value is not evaluated to be `true`, we exit the loop.\n\t\t\tInfinite loops\n\t\t\tThe code block within a `while` statement must work toward getting the condition to evaluate false. Otherwise, this will result in an **infinite loop**. Luckily, Godot ensures this does not crash our computer, but it could freeze up your game and make that crash instead!\n\t\t\tSo far, we have learned about the two basic loops within GDScript. Now, let’s have a look at how we can have more control over these loops with some special keywords that we can only use within these loops.\n\t\t\tContinuing or breaking a loop\n\t\t\tTwo keywords can only be used within a loop: **continue** and **break**. Using them excessively or abusing them is not a best practice; you can avoid both if you construct your loop correctly. But they are still essential to know.\n\t\t\tThe continue keyword\n\t\t\tThe `for` loop, this means we go to the next element in the array. In a `while` loop, this means we go back to evaluating the condition:\n\t\t\t![Figure 3.5 – The continue keyword will skip all subsequent code and go back to the start of the loop for the next element in the array](img/B19358_03_05.jpg)\n\n\t\t\tFigure 3.5 – The continue keyword will skip all subsequent code and go back to the start of the loop for the next element in the array\n\t\t\tFor example, the following code will print out all items in the inventory but skip `Banana`:\n\n```", "```cpp\n\n\t\t\tThe result of this loop will be as follows:\n\n```", "```cpp\n\n\t\t\tThe `continue` keyword is quite useful when you want to skip elements, but what if you want to halt the execution of the loop altogether? That is where the `break` keyword comes in. Let’s look at that now.\n\t\t\tThe break keyword\n\t\t\tSometimes, you’ll want to stop the execution of a loop prematurely. In such a case, we can use the **break** keyword:\n\t\t\t![Figure 3.6 – The break keyword will skip all subsequent code and stop executing the loop](img/B19358_03_06.jpg)\n\n\t\t\tFigure 3.6 – The break keyword will skip all subsequent code and stop executing the loop\n\t\t\tThe interpreter will drop everything it was doing within the loop and go to the code after it. Here’s an example:\n\n```", "```cpp\n\n\t\t\tThis snippet will print out the following:\n\n```", "```cpp\n\n\t\t\tThen, it will see that the first item in the inventory is `Bananas`, so the `if` statement evaluates to `true` and we break the loop, stopping it completely.\n\t\t\tWith that, we’ve seen how to use `continue` and `break`, but as I said earlier, it is possible to write the same loop without these keywords. As an experiment, try rewriting both examples using the **continue** and **break** keywords so that they have the same behavior, but don’t use the **continue** or **break** keywords.\n\t\t\tLoops allow us to run code for an undefined number of elements, making our code more flexible and dynamic. We will use them throughout this book. Now, let’s take a look at another container data type: dictionaries.\n\t\t\tDictionaries\n\t\t\tA **dictionary** is another data container, just like an array. But unlike arrays, which store data in a certain order, dictionaries store data using a **key-value pair**. Instead of associating each element with a predetermined number, like in an array, we associate them with a key that we define ourselves. Because we must define our own keys, there is a more rigid structure in a dictionary than in an array.\n\t\t\tCreating a dictionary\n\t\t\tLet’s say that we want to store the name, price, and weight of an item in our game. We can do this using a dictionary:\n\n```", "```cpp\n\n\t\t\tHere, we use curly brackets, `{}`, to define a dictionary. Then, we define a key and its associated value within the curly brackets. For example, the `\"name\"` key is associated with the `\"Boots\"` value. Each key-value pair must be separated by a comma:\n\t\t\t![Figure 3.7 – Dictionaries consist of one or more key-value pairs](img/B19358_03_07.jpg)\n\n\t\t\tFigure 3.7 – Dictionaries consist of one or more key-value pairs\n\t\t\tAs an experiment, try printing the preceding dictionary like so:\n\n```", "```cpp\n\n\t\t\tDictionaries help us in organizing the data together in a more structured form. Now, let’s have a look at what data we can put in a dictionary.\n\t\t\tData types in dictionaries\n\t\t\tWhat data types can we use for keys and values?\n\t\t\tThe values within a dictionary can be any data type we like, even arrays or other dictionaries!\n\t\t\tThe keys, on the other hand, cannot. We can only use simple data types as keys in a dictionary. Strings, floats and integers are valid. More complex data types, such as arrays or dictionaries, are not allowed.\n\t\t\tIt’s good to note that the type of the keys and values don’t need to be the same over the whole dictionary. You can use different data types throughout:\n\n```", "```cpp\n\n\t\t\tAs you can see, dictionaries are very powerful structures for organizing data.\n\t\t\tAccessing and changing values\n\t\t\tAccessing and changing a dictionary’s values is very similar to how we access the values of an array. Instead of specifying the index of the element within the square brackets, we specify the key of the value we want:\n\n```", "```cpp\n\n\t\t\tWe can even use a stored key from within a variable:\n\n```", "```cpp\n\n\t\t\tLastly, if the key you are trying to access is a string, you can also get to its value using the following syntax:\n\n```", "```cpp\n\n\t\t\tJust use a dot behind the dictionary’s name and then the key. This will not work if the key is anything other than a string, like a number.\n\t\t\tCreating a new key-value pair\n\t\t\tA remarkable feature of dictionaries is that we can easily add new key-value pairs after the dictionary is created. We can simply do this by assigning a value to a non-existing key:\n\n```", "```cpp\n\n\t\t\tHere, we added a new key-value pair to the item dictionary with `\"color\"` as the key and `\"blue\"` as the value.\n\t\t\tUseful functions\n\t\t\tJust like arrays, dictionaries have some useful functions that come in handy occasionally.\n\t\t\thas\n\t\t\tSometimes, we need to know if a dictionary contains a certain key. In such a case, we can count on the `has()` function:\n\n```", "```cpp\n\n\t\t\tBecause the `item` dictionary has a key called *name*, this code will print that name.\n\t\t\terase\n\t\t\tWe only saw how to add key-value pairs to a dictionary. But with `erase()`, we can also remove a pair:\n\n```", "```cpp\n\n\t\t\tThe item dictionary will be empty at the end of this snippet.\n\t\t\tAs an experiment, try printing out the item dictionary after you erase all keys.\n\t\t\tLooping through dictionaries\n\t\t\tIt might be surprising, but you can loop through dictionaries, just like arrays. For example, if we want to print out all the information in an item dictionary, we could do something like this:\n\n```", "```cpp\n\n\t\t\tAs you can see, the temporary variable, `key`, carries the keys of the dictionary one for one.\n\t\t\tWe can also directly iterate over all the values of a dictionary instead of first having to get the keys:\n\n```", "```cpp\n\n\t\t\tThis loop will print out all the values within the dictionary.\n\t\t\tImportant note\n\t\t\tLooping over an array or other data structure can also be called *iterating* over it.\n\t\t\tAs an experiment, try printing out the values of a dictionary with `item.values()`:  `print(item.values())`\n\t\t\tNested loops\n\t\t\tIf you want to have more fun with loops, you can also nest them. By this, we mean you can use a loop within another loop. For example, let’s say we have an inventory that is an array of item dictionaries and we want to print out the information of each item in a nice way. We could do something like this:\n\n```", "```cpp\n\n\t\t\tFirst, we iterate over all the elements of the array, which gives us each item dictionary. Then, we iterate on all the keys of that item and print the key and its value.\n\t\t\tOf course, you can also combine `while` and `for` loops freely. There are no limits!\n\t\t\tWith that, we’ve learned all about the two main looping control flows and the two main container data types in GDScript. In the next section, we’ll learn about a new data type: `null`.\n\t\t\tNull\n\t\t\tLastly, let me introduce you to a new data type: `null`. It carries no information, cannot be changed, and has no functions you can call. So, what is it good for? It is a variable’s value when we don’t give it one from the start. Try out the following snippet of code:\n\n```", "```cpp\n\n\t\t\tYou’ll see that it will print out `null`. Sometimes, you’ll want to do this to ensure a variable exists but don’t want to initiate it with a value yet. In the filing cabinet metaphor from [*Chapter 2*](B19358_02.xhtml#_idTextAnchor044), this would mean that we reserved a drawer and a name for the variable but haven’t filled it with data yet.\n\t\t\tUsing a variable in any way while it is null will result in an error. For example, the next two operations will result in an error while running the code:\n\n```", "```cpp\n\n\t\t\tSo, it is best to check whether a variable is `null` if you are not sure that the variable is initialized:\n\n```", "```cpp\n\n\t\t\tSome operators or functions return `null` when they cannot complete their task as expected. For example, if you access a key in a dictionary that doesn’t exist, it will return the `null` value:\n\n```", "```cpp\n\n\t\t\tThe preceding example will print out `null`.\n\t\t\tAdditional exercises – Sharpening the axe\n\n\t\t\t\t1.  Write a script that finds and prints out the name of the most expensive item in the following array using a `for` loop. You will need to keep two variables `most_expensive_item` and `max_price`. The `max_price` variable starts out at 0\\. Now, every time you come across a more expensive item you save that item in the `most_expensive_item` variable and update the new `max_price`. The most expensive item in the following array should be the *Ring* *of Might*:\n\n    ```", "```cpp\n\n    \t\t\t\t2.  Write a script that checks whether a specific string is a palindrome; this means that the string should look the same whether you’re reading it forward or backward. For example, *rotator* is a palindrome, while *bee* is not. To do this, you’ll have to iterate over the string in two directions simultaneously.\n\n\t\t\tSummary\n\t\t\tIn this chapter, we looked at two new container types, arrays and dictionaries, and two types of loops, `for` and `while` loops. We also learned about useful functions in the string data type and got acquainted with the `null` value.\n\t\t\tIn the next chapter, we’ll learn all about classes, which are custom data types that we can define ourselves.\n\t\t\tQuiz time\n\n\t\t\t\t*   What are two container types we learned about in this chapter?\n\t\t\t\t*   What is the difference between arrays and dictionaries?\n\t\t\t\t*   How do you access the 4th value in the following array?\n\n    ```", "```cpp\n\n    \t\t\t\t*   How do you access the value of the height in the following dictionary?\n\n    ```", "```cpp\n\n    \t\t\t\t*   What does `range(2,` `9)` return?\n\t\t\t\t*   What is the difference between a `for` and a `while` loop?\n\t\t\t\t*   When we use one loop inside of another loop, do we call this a nested loop?\n\t\t\t\t*   What value does the following variable have?\n\n    ```", "```cpp\n\n```"]