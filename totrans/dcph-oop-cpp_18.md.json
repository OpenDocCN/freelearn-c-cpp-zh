["```cpp\n// Person is the Adaptee class (class requiring adaptation)\nclass Person\n{\nprivate:\n    string firstName, lastName, title, greeting;\n    char middleInitial  = '\\0';  // in-class initialization\nprotected:\n    void ModifyTitle(const string &);  \npublic:\n    Person() = default;   // default constructor\n    Person(const string &, const string &, char, \n           const string &);\n    // default copy constructor prototype is not necessary\n    // Person(const Person &) = default;  // copy ctor\n    // Default op= suffices, so we'll comment out proto.\n    // (see online code for review of implementation)\n    // Person &operator=(const Person &); // assignment op.\n    virtual ~Person()= default;  // virtual destructor\n    const string &GetFirstName() const \n        { return firstName; }  \n    const string &GetLastName() const \n        { return lastName; }    \n    const string &GetTitle() const { return title; }\n    char GetMiddleInitial() const { return middleInitial; }\n    void SetGreeting(const string &);\n    virtual const string &Speak() { return greeting; }\n    virtual void Print() const;\n};\n// Assume constructors, destructor, and non-inline methods\n// are implemented as expected (see online code)\n```", "```cpp\nclass Humanoid: private Person   // Humanoid is abstract\n{                           \nprotected:\n    void SetTitle(const string &t) { ModifyTitle(t); }\npublic:\n    Humanoid() = default;   \n    Humanoid(const string &, const string &, \n             const string &, const string &);\n    // default copy constructor prototype not required\n    // Humanoid(const Humanoid &h) = default; \n    // default op= suffices, so commented out below, but\n    // let's review how we'd write op= if needed\n    // note explicit Humanoid downcast after calling base  \n    // class Person::op= to match return type needed here\n    // Humanoid &operator=(const Humanoid &h) \n    //     { return dynamic_cast<Humanoid &> \n    //              (Person::operator=(h)); }\n    // dtor proto. not required since base dtor is virt.\n    // ~Humanoid() override = default; // virt destructor\n    // Added interfaces for the Adapter class \n    const string &GetSecondaryName() const \n        { return GetFirstName(); }  \n    const string &GetPrimaryName() const \n        { return GetLastName(); } \n    // scope resolution needed in method to avoid recursion \n    const string &GetTitle() const \n        { return Person::GetTitle();}\n    void SetSalutation(const string &m) { SetGreeting(m); }\n    virtual void GetInfo() const { Print(); }\n    virtual const string &Converse() = 0; // abstract class\n};\nHumanoid::Humanoid(const string &n2, const string &n1, \n    const string &planetNation, const string &greeting):\n    Person(n2, n1, ' ', planetNation)\n{\n    SetGreeting(greeting);\n}\nconst string &Humanoid::Converse()  // default definition \n{                    // for pure virtual function - unusual\n    return Speak();\n}\n```", "```cpp\nclass Orkan: public Humanoid\n{\npublic:\n    Orkan() = default;   // default constructor\n    Orkan(const string &n2, const string &n1, \n        const string &t): Humanoid(n2, n1, t, \"Nanu nanu\")\n        { }\n    // default copy constructor prototype not required\n    // Orkan(const Orkan &h) = default;  \n    // default op= suffices, so commented out below, but\n    // let's review how we'd write it if needed\n    // note explicit Orkan downcast after calling base  \n    // class Humanoid::op= to match return type needed here\n    // Orkan &operator=(const Orkan &h) \n    //    { return dynamic_cast<Orkan &>\n    //             (Humanoid::operator=(h)); }\n    // dtor proto. not required since base dtor is virt.\n    // ~Orkan() override = default; // virtual destructor\n    const string &Converse() override;  \n};\n// Must override Converse to make Orkan a concrete class\nconst string &Orkan::Converse()  \n{                                \n    return Humanoid::Converse(); // use scope resolution to\n}                                // avoid recursion\n```", "```cpp\nclass Romulan: public Humanoid\n{\npublic:\n    Romulan() = default;   // default constructor\n    Romulan(const string &n2, const string &n1, \n        const string &t): Humanoid(n2, n1, t, \"jolan'tru\")\n        { }\n    // default copy constructor prototype not required\n    // Romulan(const Romulan &h) = default;\n    // default op= suffices, so commented out below, but\n    // let's review how we'd write it if so needed\n    // note explicit Romulan downcast after calling base  \n    // class Humanoid::op= to match return type needed here\n    // Romulan &operator=(const Romulan &h) \n    //    { return dynamic_cast<Romulan &>\n    //             (Humanoid::operator=(h)); }\n    // dtor proto. not required since base dtor is virt.\n    // ~Romulan() override = default;  // virt destructor\n    const string &Converse() override;  \n};\n// Must override Converse to make Romulan a concrete class\nconst string &Romulan::Converse()  \n{                               \n    return Humanoid::Converse(); // use scope resolution to\n}                                // avoid recursion        \n```", "```cpp\nclass Earthling: public Humanoid\n{\npublic:\n    Earthling() = default;   // default constructor\n    Earthling(const string &n2, const string &n1, \n        const string &t): Humanoid(n2, n1, t, \"Hello\") { }\n    // default copy constructor prototype not required\n    // Earthling(const Romulan &h) = default;  \n    // default op= suffices, so commented out below, but\n    // let's review how we'd write it if so needed\n    // note explicit Earthling downcast after calling base\n    // class Humanoid::op= to match return type needed here\n    // Earthling &operator=(const Earthling &h) \n    //    { return dynamic_cast<Earthling &>\n    //             (Humanoid::operator=(h)); }\n    // dtor proto. not required since base dtor is virt.\n    // ~Earthling() override = default; // virt destructor\n    const string &Converse() override;  \n};\n// Must override to make Earthling a concrete class\nconst string &Earthling::Converse() \n{                                                          \n    return Humanoid::Converse(); // use scope resolution to\n}                                // avoid recursion\n```", "```cpp\nint main()\n{\n    list<Humanoid *> allies;\n    Orkan *o1 = new Orkan(\"Mork\", \"McConnell\", \"Orkan\");\n    Romulan *r1 = new Romulan(\"Donatra\", \"Jarok\", \n                              \"Romulan\");\n    Earthling *e1 = new Earthling(\"Eve\", \"Xu\",\n                                  \"Earthling\");\n    // Add each specific type of Humanoid to generic list\n    allies.push_back(o1);\n    allies.push_back(r1);\n    allies.push_back(e1);\n\n    // Process the list of allies (which are Humanoid *'s \n    // Actually, each is a specialization of Humanoid!)\n    for (auto *entity : allies)\n    {\n        entity->GetInfo();\n        cout << entity->Converse() << endl;\n    }\n    // Though each type of Humanoid has a default\n    // Salutation, each may expand their skills with \n    // an alternate language\n    e1->SetSalutation(\"Bonjour\");\n    e1->GetInfo();\n    cout << e1->Converse() << endl; // Show the Earthling's \n                           // revised language capabilities\n    delete o1;   // delete the heap instances\n    delete r1;\n    delete e1;\n    return 0;\n}\n```", "```cpp\nOrkan Mork McConnell\nNanu nanu\nRomulan Donatra Jarok\njolan'tru\nEarthling Eve Xu\nHello\nEarthling Eve Xu\nBonjour\n```", "```cpp\n// Assume that Person exists mostly as before – however,\n// Person::ModifyTitle() must be moved from protected to\n// public or be unused if modifying Person is not possible.\n// Let's assume we moved Person::ModifyTitle() to public.\nclass Humanoid    // Humanoid is abstract\n{\nprivate:\n    Person *life = nullptr;  // delegate all requests to\n                             // the associated object\nprotected:\n    void SetTitle(const string &t) \n        { life->ModifyTitle(t); }\npublic:\n    Humanoid() = default;\n    Humanoid(const string &, const string &, \n             const string &, const string &);\n    Humanoid(const Humanoid &h);// we have work for copies!\n    Humanoid &operator=(const Humanoid &); // and for op=\n    virtual ~Humanoid()  // virtual destructor\n        { delete life; life = nullptr; }  \n    // Added interfaces for the Adapter class\n    const string &GetSecondaryName() const \n        { return life->GetFirstName(); }\n    const string &GetPrimaryName() const \n        { return life->GetLastName(); }    \n    const string &GetTitle() const \n        { return life->GetTitle();}\n    void SetSalutation(const string &m) \n        { life->SetGreeting(m); }\n    virtual void GetInfo() const { life->Print(); }\n    virtual const string &Converse() = 0; // abstract class\n};\nHumanoid::Humanoid(const string &n2, const string &n1, \n          const string &planetNation, const string &greeting)\n{\n    life = new Person(n2, n1, ' ', planetNation);\n    life->SetGreeting(greeting);\n}\n// copy constructor (we need to write it ourselves)\nHumanoid::Humanoid(const Humanoid &h)  \n{  // Remember life data member is of type Person\n    delete life;  // delete former associated object\n    life = new Person(h.GetSecondaryName(),\n                     h.GetPrimaryName(),' ', h.GetTitle());\n    life->SetGreeting(h.life->Speak());  \n}\n// overloaded operator= (we need to write it ourselves)\nHumanoid &Humanoid::operator=(const Humanoid &h)\n{\n    if (this != &h)\n        life->Person::operator=(dynamic_cast\n                                <const Person &>(h));\n    return *this;\n}\nconst string &Humanoid::Converse() //default definition for\n{                              // pure virtual fn - unusual\n    return life->Speak();\n}\n```", "```cpp\n// Assume Person class exists with its usual implementation\nPerson objectRead; // holds the object from current read\n                   // to support a simulation of a DB read\nvoid db_open(const string &dbName)\n{   // Assume implementation exists\n    cout << \"Opening database: \" << dbName << endl;\n}\nvoid db_close(const string &dbName)\n{   // Assume implementation exists\n    cout << \"Closing database: \" << dbName << endl;\n}\nPerson &db_read(const string &dbName, const string &key)\n{   // Assume implementation exists\n    cout << \"Reading from: \" << dbName << \" using key: \";\n    cout << key << endl;\n    // In a true implementation, we would read the data\n    // using the key and return the object we read in\n    return objectRead; // non-stack instance for simulation\n}\nconst string &db_write(const string &dbName, Person &data)\n{   // Assume implementation exists\n    const string &key = data.GetLastName();\n    cout << \"Writing: \" << key << \" to: \" << \n             dbName << endl;\n    return key;\n}\n```", "```cpp\n// CitizenDataBase is the Adapter class \nclass CitizenDataBase  // Adapter wraps undesired interface\n{\nprivate:\n    string name;\npublic:\n    // No default constructor (unusual)\n    CitizenDataBase(const string &);\n    CitizenDataBase(const CitizenDataBase &) = delete;\n    CitizenDataBase &operator=(const CitizenDataBase &) \n                               = delete;  // disallow =\n    virtual ~CitizenDataBase();  // virtual destructor\n    inline Person &Read(const string &);\n    inline const string &Write(Person &);\n};\nCitizenDataBase::CitizenDataBase(const string &n): name(n)\n{\n    db_open(name);   // call existing external function\n}\nCitizenDataBase::~CitizenDataBase()\n{\n    db_close(name);  // close database with external\n}                    // function\nPerson &CitizenDataBase::Read(const string &key)\n{\n    return db_read(name, key);   // call external function\n}\nconst string &CitizenDataBase::Write(Person &data)\n{\n    return db_write(name, data);  // call external function\n}\n```", "```cpp\nint main()\n{\n    string key;\n    string name(\"PersonData\"); // name of database\n    Person p1(\"Curt\", \"Jeffreys\", 'M', \"Mr.\");\n    Person p2(\"Frank\", \"Burns\", 'W', \"Mr.\");\n    Person p3;\n    CitizenDataBase People(name);   // open Database\n    key = People.Write(p1); // write a Person object\n    p3 = People.Read(key);  // using a key, retrieve Person\n    return 0;\n}                        // destruction will close database\n```", "```cpp\nOpening database: PersonData\nWriting: Jeffreys to: PersonData\nReading from: PersonData using key: Jeffreys\nClosing database: PersonData\n```"]