<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer031">&#13;
			<h1 id="_idParaDest-155" class="chapter-number"><a id="_idTextAnchor159"/>10</h1>&#13;
			<h1 id="_idParaDest-156"><a id="_idTextAnchor160"/>Debugging Using LLVM Tools</h1>&#13;
			<p>LLVM comes with a set of tools that helps you identify certain errors in your application. All these tools make use of the LLVM<a id="_idIndexMarker584"/> and <span class="No-Break"><strong class="bold">clang</strong></span><span class="No-Break"> libraries.</span></p>&#13;
			<p>In this chapter, you will learn how to instrument an application <a id="_idIndexMarker585"/>with <strong class="bold">sanitizers</strong>, as well as how to use the most common sanitizer to identify a wide range of bugs, after which you’ll implement fuzz testing for your application. This will help you identify bugs that are usually not found with unit testing. You will also learn how to identify performance bottlenecks in your application, run <a id="_idIndexMarker586"/>the <strong class="bold">static analyzer</strong> to identify problems normally not found by the compiler, and create your own clang-based tool, in which you can extend clang with <span class="No-Break">new functionality.</span></p>&#13;
			<p>This chapter will cover the <span class="No-Break">following topics:</span></p>&#13;
			<ul>&#13;
				<li>Instrumenting an application <span class="No-Break">with sanitizers</span></li>&#13;
				<li>Finding bugs <span class="No-Break">with </span><span class="No-Break"><strong class="bold">libFuzzer</strong></span></li>&#13;
				<li>Performance profiling <span class="No-Break">with </span><span class="No-Break"><strong class="bold">XRay</strong></span></li>&#13;
				<li>Checking the source with the <strong class="bold">Clang </strong><span class="No-Break"><strong class="bold">Static Analyzer</strong></span></li>&#13;
				<li>Creating your own <span class="No-Break">clang-based tool</span></li>&#13;
			</ul>&#13;
			<p>By the end of this chapter, you will know how to use the various LLVM and clang tools to identify a large category of errors in an application. You will also acquire the knowledge to extend clang with new functionality, for example, to enforce naming conventions or to add new <span class="No-Break">source analysis.</span></p>&#13;
			<h1 id="_idParaDest-157"><a id="_idTextAnchor161"/>Technical requirements</h1>&#13;
			<p>To create the <strong class="bold">flame graph</strong> in the <em class="italic">Performance profiling with XRay</em> section, you need to install the scripts from <a href="https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a>. Some systems, such as <strong class="bold">Fedora</strong> and <strong class="bold">FreeBSD</strong>, provide a package for these scripts, which you can <span class="No-Break">also use.</span></p>&#13;
			<p>To view the <strong class="bold">Chrome visualization</strong> in the same section, you need to have the <strong class="bold">Chrome</strong> browser installed. You can download the browser from <a href="https://www.google.com/chrome/">https://www.google.com/chrome/</a> or use the package manager of your system to install <span class="No-Break"><strong class="bold">Chrome</strong></span><span class="No-Break"> browser.</span></p>&#13;
			<p>Additionally, to run the static analyzer via the <strong class="source-inline">scan-build</strong> script, you need to have the <strong class="source-inline">perl-core</strong> package installed on <strong class="bold">Fedora</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">Ubuntu</strong></span><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-158"><a id="_idTextAnchor162"/>Instrumenting an application with sanitizers</h1>&#13;
			<p>LLVM comes with a<a id="_idIndexMarker587"/> couple of <strong class="bold">sanitizers</strong>. These <a id="_idIndexMarker588"/>are passes that instrument the <strong class="bold">intermediate representation</strong> (<strong class="bold">IR</strong>) to <a id="_idIndexMarker589"/>check for certain misbehavior of an application. Usually, they require library support, which is part of the <strong class="source-inline">compiler-rt</strong> project. The sanitizers can be enabled in clang, which makes them very comfortable to use. To build the <strong class="source-inline">compiler-rt</strong> project, we can simply add the <strong class="source-inline">-DLLVM_ENABLE_RUNTIMES=compiler-rt</strong> CMake variable to the initial CMake configuration step when <span class="No-Break">building LLVM.</span></p>&#13;
			<p>In the following sections, we will look at the <strong class="source-inline">address</strong>, <strong class="source-inline">memory</strong>, and <strong class="source-inline">thread</strong> sanitizers. First, we’ll look at the <span class="No-Break"><strong class="source-inline">address</strong></span><span class="No-Break"> sanitizer.</span></p>&#13;
			<h2 id="_idParaDest-159"><a id="_idTextAnchor163"/>Detecting memory access problems with the address sanitizer</h2>&#13;
			<p>You can use<a id="_idIndexMarker590"/> the <strong class="source-inline">address</strong> sanitizer <a id="_idIndexMarker591"/>to detect different types of memory access bugs within an application. This includes common errors such as using dynamically allocated memory after freeing it or writing to dynamically allocated memory outside the boundaries of the <span class="No-Break">allocated memory.</span></p>&#13;
			<p>When enabled, the <strong class="source-inline">address</strong> sanitizer replaces calls to the <strong class="source-inline">malloc()</strong> and <strong class="source-inline">free()</strong> functions with its own version and instruments all memory accesses with a checking guard. Of course, this adds a lot of overhead to the application, and you will only use the <strong class="source-inline">address</strong> sanitizer during the testing phase of the application. If you are interested in the implementation details, then you can find the source of the pass in the <strong class="source-inline">llvm/lib/Transforms/Instrumentation/AddressSanitzer.cpp</strong> file and a description of the implemented algorithm <span class="No-Break">at </span><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm"><span class="No-Break">https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm</span></a><span class="No-Break">.</span></p>&#13;
			<p>Let’s run a short example to show the capabilities of the <span class="No-Break"><strong class="source-inline">address</strong></span><span class="No-Break"> sanitizer!</span></p>&#13;
			<p>The following example application, <strong class="source-inline">outofbounds.c</strong>, allocates <strong class="source-inline">12</strong> bytes of memory, but initializes <span class="No-Break"><strong class="source-inline">14</strong></span><span class="No-Break"> bytes:</span></p>&#13;
			<pre class="source-code">&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;string.h&gt;&#13;
int main(int argc, char *argv[]) {&#13;
  char *p = malloc(12);&#13;
  memset(p, 0, 14);&#13;
  return (int)*p;&#13;
}</pre>			<p>You can compile and run<a id="_idIndexMarker592"/> this <a id="_idIndexMarker593"/>application without noticing a problem as this behavior is typical for this kind of error. Even in larger applications, such kinds of bugs can go unnoticed for a long time. However, if you enable the <strong class="source-inline">address</strong> sanitizer with the <strong class="source-inline">-fsanitize=address</strong> option, then the application stops after detecting <span class="No-Break">the error.</span></p>&#13;
			<p>It is also useful to enable debug symbols with the <strong class="source-inline">–g</strong> options because it helps identify the location of the error in the source. The following code is an example of how to compile the source file with the <strong class="source-inline">address</strong> sanitizer and debug <span class="No-Break">symbols enabled:</span></p>&#13;
			<pre class="console">&#13;
$ clang -fsanitize=address -g outofbounds.c -o outofbounds</pre>			<p>Now, you get a lengthy error report when running <span class="No-Break">the application:</span></p>&#13;
			<pre class="console">&#13;
$ ./outofbounds&#13;
==============================================================&#13;
==1067==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000001c at pc 0x00000023a6ef bp 0x7fffffffeb10 sp 0x7fffffffe2d8&#13;
WRITE of size 14 at 0x60200000001c thread T0&#13;
    #0 0x23a6ee in __asan_memset /usr/src/contrib/llvm-project/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:26:3&#13;
    #1 0x2b2a03 in main /home/kai/sanitizers/outofbounds.c:6:3&#13;
    #2 0x23331f in _start /usr/src/lib/csu/amd64/crt1.c:76:7</pre>			<p>The report also contains detailed information about the memory content. The important information is the type of the error – <strong class="bold">heap buffer overflow</strong>, in<a id="_idIndexMarker594"/> this case – and the offending source line. To find the source line, you must look at the stack trace at location #1, which is the last location before the address sanitizer intercepts the execution of the application. It shows <em class="italic">line 6</em> in the <strong class="source-inline">outofbounds.c</strong> file, which is the line containing the call to <strong class="source-inline">memset()</strong>. This is the exact place where the buffer <span class="No-Break">overflow happens.</span></p>&#13;
			<p>If you replace the line containing <strong class="source-inline">memset(p, 0, 14);</strong> in the <strong class="source-inline">outofbounds.c</strong> file with the following<a id="_idIndexMarker595"/> code, then <a id="_idIndexMarker596"/>you can introduce access to memory once you’ve freed the memory. You’ll need to store the source in the <span class="No-Break"><strong class="source-inline">useafterfree.c</strong></span><span class="No-Break"> file:</span></p>&#13;
			<pre class="source-code">&#13;
  memset(p, 0, 12);&#13;
  free(p);</pre>			<p>Again, if you compile and run it, the sanitizer detects the use of the pointer after the memory <span class="No-Break">is freed:</span></p>&#13;
			<pre class="console">&#13;
$ clang -fsanitize=address -g useafterfree.c -o useafterfree&#13;
$ ./useafterfree&#13;
==============================================================&#13;
==1118==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000010 at pc 0x0000002b2a5c bp 0x7fffffffeb00 sp 0x7fffffffeaf8&#13;
READ of size 1 at 0x602000000010 thread T0&#13;
    #0 0x2b2a5b in main /home/kai/sanitizers/useafterfree.c:8:15&#13;
    #1 0x23331f in _start /usr/src/lib/csu/amd64/crt1.c:76:7</pre>			<p>This time, the report points to <em class="italic">line 8</em>, which contains dereferencing of the <span class="No-Break"><strong class="source-inline">p</strong></span><span class="No-Break"> pointer.</span></p>&#13;
			<p>On <strong class="bold">x86_64 Linux</strong> and <strong class="bold">macOS</strong>, you<a id="_idIndexMarker597"/> can also <a id="_idIndexMarker598"/>enable a leak detector. If you set the <strong class="source-inline">ASAN_OPTIONS</strong> environment variable to <strong class="source-inline">detect_leaks=1</strong> before running the application, then you also get a report about <span class="No-Break">memory leaks.</span></p>&#13;
			<p>On the command line, you can do this <span class="No-Break">as follows:</span></p>&#13;
			<pre class="console">&#13;
$ ASAN_OPTIONS=detect_leaks=1 ./useafterfree</pre>			<p>The <strong class="source-inline">address</strong> sanitizer is very useful because it catches a category of bugs that are otherwise difficult<a id="_idIndexMarker599"/> to <a id="_idIndexMarker600"/>detect. The <strong class="source-inline">memory</strong> sanitizer does a similar task. We’ll examine its use cases in the <span class="No-Break">next section.</span></p>&#13;
			<h2 id="_idParaDest-160"><a id="_idTextAnchor164"/>Finding uninitialized memory accesses with the memory sanitizer</h2>&#13;
			<p>Using uninitialized memory is<a id="_idIndexMarker601"/> another <a id="_idIndexMarker602"/>category of bugs that are hard to find. In <strong class="bold">C</strong> and <strong class="bold">C++</strong>, the general<a id="_idIndexMarker603"/> memory <a id="_idIndexMarker604"/>allocation routines do not initialize the memory buffer with a default value. The same is true for automatic variables on <span class="No-Break">the stack.</span></p>&#13;
			<p>There are lots of opportunities for errors, and the memory sanitizer helps find these bugs. If you are interested in the implementation details, you can find the source for the memory sanitizer pass in the <strong class="source-inline">llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp</strong> file. The comment at the top of the file explains the ideas behind <span class="No-Break">the implementation.</span></p>&#13;
			<p>Let’s run a small example and save the following source as the <strong class="source-inline">memory.c</strong> file. Note that the <strong class="source-inline">x</strong> variable is not initialized and is used as a <span class="No-Break"><strong class="source-inline">return</strong></span><span class="No-Break"> value:</span></p>&#13;
			<pre class="source-code">&#13;
int main(int argc, char *argv[]) {&#13;
  int x;&#13;
  return x;&#13;
}</pre>			<p>Without the sanitizer, the application will run just fine. However, you will get an error report if you use the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">fsanitize=memory</strong></span><span class="No-Break"> option:</span></p>&#13;
			<pre class="console">&#13;
$ clang -fsanitize=memory -g memory.c -o memory&#13;
$ ./memory&#13;
==1206==WARNING: MemorySanitizer: use-of-uninitialized-value&#13;
    #0 0x10a8f49 in main /home/kai/sanitizers/memory.c:3:3&#13;
    #1 0x1053481 in _start /usr/src/lib/csu/amd64/crt1.c:76:7&#13;
SUMMARY: MemorySanitizer: use-of-uninitialized-value /home/kai/sanitizers/memory.c:3:3 in main&#13;
Exiting</pre>			<p>Like the <strong class="source-inline">address</strong> sanitizer, the memory sanitizer stops the application at the first error that’s found. As<a id="_idIndexMarker605"/> shown <a id="_idIndexMarker606"/>here the memory sanitizer provides a <strong class="bold">use of initialized </strong><span class="No-Break"><strong class="bold">value</strong></span><span class="No-Break"> warning.</span></p>&#13;
			<p>Finally, in the next section, we’ll look at how we can use the <strong class="source-inline">thread</strong> sanitizer to detect data races in <span class="No-Break">multi-threaded applications.</span></p>&#13;
			<h2 id="_idParaDest-161"><a id="_idTextAnchor165"/>Pointing out data races with the thread sanitizer</h2>&#13;
			<p>To leverage the<a id="_idIndexMarker607"/> power of modern CPUs, applications<a id="_idIndexMarker608"/> now use multiple threads. This is a powerful technique, but it also introduces new sources of errors. A very common problem in multi-threaded applications is that the access to global data is not protected, for <a id="_idIndexMarker609"/>example, with<a id="_idIndexMarker610"/> a <strong class="bold">mutex</strong> or <strong class="bold">semaphore</strong>. This is called a <strong class="bold">data race</strong>. The <strong class="source-inline">thread</strong> sanitizer can detect data races in <strong class="bold">Pthreads</strong>-based <a id="_idIndexMarker611"/>applications and in applications using the LLVM <strong class="bold">libc++</strong> implementation. You can find the implementation in the <span class="No-Break"><strong class="source-inline">llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp</strong></span><span class="No-Break"> file.</span></p>&#13;
			<p>To demonstrate the functionality of the <strong class="source-inline">thread</strong> sanitizer, we will create a very simple producer-consumer-style application. The producer thread increments a global variable, while the consumer thread decrements the same variable. Access to the global variable is not protected, so this is a <span class="No-Break">data race.</span></p>&#13;
			<p>You’ll need to save<a id="_idIndexMarker612"/> the<a id="_idIndexMarker613"/> following source in the <span class="No-Break"><strong class="source-inline">thread.c</strong></span><span class="No-Break"> file:</span></p>&#13;
			<pre class="source-code">&#13;
#include &lt;pthread.h&gt;&#13;
int data = 0;&#13;
void *producer(void *x) {&#13;
  for (int i = 0; i &lt; 10000; ++i) ++data;&#13;
  return x;&#13;
}&#13;
void *consumer(void *x) {&#13;
  for (int i = 0; i &lt; 10000; ++i) --data;&#13;
  return x;&#13;
}&#13;
int main() {&#13;
  pthread_t t1, t2;&#13;
  pthread_create(&amp;t1, NULL, producer, NULL);&#13;
  pthread_create(&amp;t2, NULL, consumer, NULL);&#13;
  pthread_join(t1, NULL);&#13;
  pthread_join(t2, NULL);&#13;
  return data;&#13;
}</pre>			<p>In the preceding code, the <strong class="source-inline">data</strong> variable is shared between two threads. Here, it is of the <strong class="source-inline">int</strong> type to make the example simple since often, a data structure such as the <strong class="source-inline">std::vector</strong> class or similar would be used. Furthermore, these two threads run the <strong class="source-inline">producer()</strong> and <span class="No-Break"><strong class="source-inline">consumer()</strong></span><span class="No-Break"> functions.</span></p>&#13;
			<p>The <strong class="source-inline">producer()</strong> function only increments the <strong class="source-inline">data</strong> variable, while the <strong class="source-inline">consumer()</strong> function decrements it. No access protection is implemented, so this constitutes a data race. The <strong class="source-inline">main()</strong> function starts both threads with the <strong class="source-inline">pthread_create()</strong> function, waits for the end of the threads with the <strong class="source-inline">pthread_join()</strong> function, and returns the current value of the <span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break"> variable.</span></p>&#13;
			<p>If you compile and run this application, then you will note no error – that is, the return value is always zero. An error – in this case, a return value not equal to zero – will appear if the number of loops that are performed is increased by a factor of 100. At this point, you will begin to notice other <span class="No-Break">values appear.</span></p>&#13;
			<p>We can use the <strong class="source-inline">thread</strong> sanitizer to identify the data race within our program. To compile with the <strong class="source-inline">thread</strong> sanitizer enabled, you’ll need to pass the <strong class="source-inline">-fsanitize=thread</strong> option to clang. Adding debug symbols with the <strong class="source-inline">–g</strong> options gives you line numbers in the <a id="_idIndexMarker614"/>report, which <a id="_idIndexMarker615"/>is also helpful. Note that you also need to link the <span class="No-Break"><strong class="source-inline">pthread</strong></span><span class="No-Break"> library:</span></p>&#13;
			<pre class="console">&#13;
$ clang -fsanitize=thread -g thread.c -o thread -lpthread&#13;
$ ./thread&#13;
==================&#13;
WARNING: ThreadSanitizer: data race (pid=1474)&#13;
  Write of size 4 at 0x000000cdf8f8 by thread T2:&#13;
    #0 consumer /home/kai/sanitizers/thread.c:11:35 (thread+0x2b0fb2)&#13;
  Previous write of size 4 at 0x000000cdf8f8 by thread T1:&#13;
    #0 producer /home/kai/sanitizers/thread.c:6:35 (thread+0x2b0f22)&#13;
  Location is global 'data' of size 4 at 0x000000cdf8f8 (thread+0x000000cdf8f8)&#13;
  Thread T2 (tid=100437, running) created by main thread at:&#13;
    #0 pthread_create /usr/src/contrib/llvm-project/compiler-rt/lib/tsan/rtl/tsan_interceptors_posix.cpp:962:3 (thread+0x271703)&#13;
    #1 main /home/kai/sanitizers/thread.c:18:3 (thread+0x2b1040)&#13;
  Thread T1 (tid=100436, finished) created by main thread at:&#13;
    #0 pthread_create /usr/src/contrib/llvm-project/compiler-rt/lib/tsan/rtl/tsan_interceptors_posix.cpp:962:3 (thread+0x271703)&#13;
    #1 main /home/kai/sanitizers/thread.c:17:3 (thread+0x2b1021)&#13;
SUMMARY: ThreadSanitizer: data race /home/kai/sanitizers/thread.c:11:35 in consumer&#13;
==================&#13;
ThreadSanitizer: reported 1 warnings</pre>			<p>The report points us to <em class="italic">lines 6</em> and <em class="italic">11</em> of the source file, where the global variable is accessed. It also <a id="_idIndexMarker616"/>shows <a id="_idIndexMarker617"/>that two threads named <em class="italic">T1</em> and <em class="italic">T2</em> accessed the variable and the file and line number of the respective calls to the <span class="No-Break"><strong class="source-inline">pthread_create()</strong></span><span class="No-Break"> function.</span></p>&#13;
			<p>With that, we’ve learned how to use three different types of sanitizers to identify common problems in applications. The <strong class="source-inline">address</strong> sanitizer helps us identify common memory access errors, such as out-of-bounds accesses or using memory after it’s been freed. Using the <strong class="source-inline">memory</strong> sanitizer, we can find access to uninitialized memory, and the <strong class="source-inline">thread</strong> sanitizer helps <a id="_idIndexMarker618"/>us <a id="_idIndexMarker619"/>identify <span class="No-Break">data races.</span></p>&#13;
			<p>In the next section, we’ll try to trigger the sanitizers by running our application on random data. This process is known as <span class="No-Break"><strong class="bold">fuzz testing</strong></span><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-162"><a id="_idTextAnchor166"/>Finding bugs with libFuzzer</h1>&#13;
			<p>To test your application, you’ll need to <a id="_idIndexMarker620"/>write <strong class="bold">unit tests</strong>. This is a great way to make sure <a id="_idIndexMarker621"/>your software behaves correctly and as you might expect. However, because of the exponential number of possible inputs, you’ll probably miss certain weird inputs, and a few bugs <span class="No-Break">as well.</span></p>&#13;
			<p><strong class="bold">Fuzz testing</strong> can help<a id="_idIndexMarker622"/> here. The idea is to present your application with randomly generated data, or data based on valid input but with random changes. This is done repeatedly, so your application is tested with a large number of inputs, which is why fuzz testing can be a powerful testing approach. It has been noted that fuzz testing has assisted in finding hundreds of bugs within web browsers and <span class="No-Break">other software.</span></p>&#13;
			<p>Interestingly, LLVM comes with its own fuzz testing library. Originally part of the LLVM core libraries, the <strong class="bold">libFuzzer</strong> implementation was finally moved to <strong class="source-inline">compiler-rt</strong>. The library is designed to test small and <span class="No-Break">fast functions.</span></p>&#13;
			<p>Let’s run a small example to see how libFuzzer works. First, you will need to provide the <strong class="source-inline">LLVMFuzzerTestOneInput()</strong> function. This function is called by the <strong class="bold">fuzzer driver</strong> and provides <a id="_idIndexMarker623"/>you with some input. The following function counts consecutive ASCII digits in the input. Once it’s done that, we’ll feed random input <span class="No-Break">to it.</span></p>&#13;
			<p>You’ll need to save the example in the <span class="No-Break"><strong class="source-inline">fuzzer.c</strong></span><span class="No-Break"> file:</span></p>&#13;
			<pre class="source-code">&#13;
#include &lt;stdint.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
int count(const uint8_t *Data, size_t Size) {&#13;
  int cnt = 0;&#13;
  if (Size)&#13;
    while (Data[cnt] &gt;= '0' &amp;&amp; Data[cnt] &lt;= '9') ++cnt;&#13;
  return cnt;&#13;
}&#13;
int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {&#13;
  count(Data, Size);&#13;
  return 0;&#13;
}</pre>			<p>In the preceding code, the <strong class="source-inline">count()</strong> function counts the number of digits in the memory pointed to by the <strong class="source-inline">Data</strong> variable. The size of the data is only checked to determine if there are any bytes available. Inside the <strong class="source-inline">while</strong> loop, the size is <span class="No-Break">not checked.</span></p>&#13;
			<p>Used with <a id="_idIndexMarker624"/>normal <strong class="bold">C strings</strong>, there will be no error because C strings are always terminated by a <strong class="source-inline">0</strong> byte. The <strong class="source-inline">LLVMFuzzerTestOneInput()</strong> function is the so-called <strong class="bold">fuzz target</strong>, and it is <a id="_idIndexMarker625"/>the function called by<a id="_idIndexMarker626"/> libFuzzer. It calls the function we want to test and returns <strong class="source-inline">0</strong>, which is currently the only <span class="No-Break">allowed value.</span></p>&#13;
			<p>To compile the file with libFuzzer, you must add the <strong class="source-inline">-fsanitize=fuzzer</strong> option. The recommendation is to also enable the <strong class="source-inline">address</strong> sanitizer and the generation of debug symbols. We can use the following command to compile the <span class="No-Break"><strong class="source-inline">fuzzer.c</strong></span><span class="No-Break"> file:</span></p>&#13;
			<pre class="console">&#13;
$ clang -fsanitize=fuzzer,address -g fuzzer.c -o fuzzer</pre>			<p>When you run the test, it emits a lengthy report. The report contains more information than a stack trace, so let’s have a closer look <span class="No-Break">at it:</span></p>&#13;
			<ol>&#13;
				<li>The first line tells you the seed that was used to initialize the random number generator. You can use the <strong class="source-inline">–seed=</strong> option to repeat <span class="No-Break">this execution:</span><pre class="source-code">&#13;
INFO: Seed: 1297394926</pre></li>				<li>By default, libFuzzer limits inputs to, at most, <strong class="source-inline">4096</strong> bytes. You can change the default by using the <strong class="source-inline">–</strong><span class="No-Break"><strong class="source-inline">max_len=</strong></span><span class="No-Break"> option:</span><pre class="source-code">&#13;
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes</pre></li>				<li>Now, we can run the test without providing sample input. The set of all sample inputs is called <strong class="source-inline">corpus</strong>, and it is empty for <span class="No-Break">this run:</span><pre class="source-code">&#13;
INFO: A corpus is not provided, starting from an empty corpus</pre></li>				<li>Some information about the generated test data will follow. It shows you that <strong class="source-inline">28</strong> inputs were tried and <strong class="source-inline">6</strong> inputs, which together have a length of <strong class="source-inline">19</strong> bytes, were found, which together cover <strong class="source-inline">6</strong> coverage points or <span class="No-Break">basic blocks:</span><pre class="source-code">&#13;
#28     NEW    cov: 6 ft: 9 corp: 6/19b lim: 4 exec/s: 0 rss: 29Mb L: 4/4 MS: 4 CopyPart-PersAutoDict-CopyPart-ChangeByte- DE: "1\x00"-</pre></li>				<li>After this, a buffer overflow was detected, and it followed the information from the <strong class="source-inline">address</strong> sanitizer. Lastly, the report tells you where the input causing the buffer overflow <span class="No-Break">is saved:</span><pre class="source-code">&#13;
artifact_prefix='./'; Test unit written to ./crash-17ba0791499db908433b80f37c5fbc89b870084b</pre></li>			</ol>&#13;
			<p>With the saved <a id="_idIndexMarker627"/>input, the test case can be executed with the same crashing <span class="No-Break">input again:</span></p>&#13;
			<pre class="console">&#13;
$ ./fuzzer crash-17ba0791499db908433b80f37c5fbc89b870084b</pre>			<p>This helps identify the problem as we can use the saved input as a direct reproducer to fix whatever problems that may arise. However, only using random data is often not very helpful in every situation. If you try to fuzz test the <strong class="source-inline">tinylang</strong> lexer or parser, then pure random data leads to immediate rejection of the input because no valid token can <span class="No-Break">be found.</span></p>&#13;
			<p>In such cases, it is more useful to provide a small set of valid input, called the corpus. In this situation, the files of the corpus are randomly mutated and used as input. You can think of the input as mostly valid, with just a few bits flipped. This also works great with other input, which must have a certain format. For example, for a library that processes <strong class="bold">JPEG</strong> and <strong class="bold">PNG</strong> files, you will provide some small <strong class="bold">JPEG</strong> and <strong class="bold">PNG</strong> files <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">corpus</strong></span><span class="No-Break">.</span></p>&#13;
			<p>An example of providing the corpus looks like this. You can save the corpus files in one or more directories and you can create a simple corpus for our fuzz test with the help of the <span class="No-Break"><strong class="source-inline">printf</strong></span><span class="No-Break"> command:</span></p>&#13;
			<pre class="console">&#13;
$ mkdir corpus&#13;
$ printf "012345\0" &gt;corpus/12345.txt&#13;
$ printf "987\0" &gt;corpus/987.txt</pre>			<p>When running the test, you must provide the directory on the <span class="No-Break">command line:</span></p>&#13;
			<pre class="console">&#13;
$ ./fuzzer corpus/</pre>			<p>The corpus is then used as the base for generating random input, as the report <span class="No-Break">tells you:</span></p>&#13;
			<pre class="console">&#13;
INFO: seed corpus: files: 2 min: 4b max: 7b total: 11b rss: 29Mb</pre>			<p>Furthermore, if you are testing a function that works on tokens or other magic values, such as a programming language, then you can speed up the process by providing a dictionary with the tokens. For a programming language, the dictionary would contain all the keywords and special symbols used in the language. Moreover, the dictionary definitions follow a simple key-value style. For example, to define the <strong class="source-inline">if</strong> keyword in the dictionary, you can add <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code">&#13;
kw1="if"</pre>			<p>However, the key is optional, and you can leave it out. Now, you can specify the dictionary file on the<a id="_idIndexMarker628"/> command line with the <strong class="source-inline">–</strong><span class="No-Break"><strong class="source-inline">dict=</strong></span><span class="No-Break"> option.</span></p>&#13;
			<p>Now that we’ve covered using libFuzzer to find bugs, let’s look at the limitations and alternatives for the <span class="No-Break">libFuzzer implementation.</span></p>&#13;
			<h2 id="_idParaDest-163"><a id="_idTextAnchor167"/>Limitations and alternatives</h2>&#13;
			<p>The libFuzzer implementation<a id="_idIndexMarker629"/> is fast but poses several restrictions on the test target. They are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li>The function under <strong class="source-inline">test</strong> must accept the input as an array in memory. Some library functions require a file path to the data instead, and they cannot be tested <span class="No-Break">with libFuzzer.</span></li>&#13;
				<li>The <strong class="source-inline">exit()</strong> function should not <span class="No-Break">be called.</span></li>&#13;
				<li>The global state should not <span class="No-Break">be altered.</span></li>&#13;
				<li>Hardware random number generators should not <span class="No-Break">be used.</span></li>&#13;
			</ul>&#13;
			<p>The first two restrictions are an implication of the implementation of libFuzzer as a library. The latter two restrictions are needed to avoid confusion in the evaluation algorithm. If one of these restrictions is not met, then two identical calls to the fuzz target can yield <span class="No-Break">different results.</span></p>&#13;
			<p>The best-known alternative tool for fuzz testing is <strong class="bold">AFL</strong>, which can be found at <a href="https://github.com/google/AFL">https://github.com/google/AFL</a>. AFL requires an instrumented binary (an LLVM plugin for instrumentation is provided) and requires the application to take the input as a file path on the command line. AFL and libFuzzer can share the same corpus and the same dictionary files. Thus, it is possible to test an application with both tools. Furthermore, where libFuzzer is not applicable, AFL may be a <span class="No-Break">good alternative.</span></p>&#13;
			<p>There are many more ways of influencing the way libFuzzer works. You can read the reference <a id="_idIndexMarker630"/>page at <a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a> for <span class="No-Break">more details.</span></p>&#13;
			<p>In the next section, we look at a different problem an application can have – we’ll try to identify performance bottlenecks while using the <span class="No-Break">XRay tool.</span></p>&#13;
			<h1 id="_idParaDest-164"><a id="_idTextAnchor168"/>Performance profiling with XRay</h1>&#13;
			<p>If your application <a id="_idIndexMarker631"/>seems to run slow, then you might want to know where the time is spent in the code. Here, instrumenting the code with <strong class="bold">XRay</strong> can assist with this task. Basically, at each function entry and exit, a special call is inserted into the runtime library. This allows you to count how often a function is called, and also how much time is spent in the function. You can find the implementation for the instrumentation pass in the <strong class="source-inline">llvm/lib/XRay/</strong> directory. The runtime portion is part <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">compiler-rt</strong></span><span class="No-Break">.</span></p>&#13;
			<p>In the following example source, real work is simulated by calling the <strong class="source-inline">usleep()</strong> function. The <strong class="source-inline">func1()</strong> function sleeps for 10 µs. The <strong class="source-inline">func2()</strong> function calls <strong class="source-inline">func1()</strong> or sleeps for 100 µs, depending on if the <strong class="source-inline">n</strong> parameter is odd or even. Inside the <strong class="source-inline">main()</strong> function, both functions are called inside a loop. This is already enough to get interesting information. You’ll need to save the following source code in the <span class="No-Break"><strong class="source-inline">xraydemo.c</strong></span><span class="No-Break"> file:</span></p>&#13;
			<pre class="source-code">&#13;
#include &lt;unistd.h&gt;&#13;
void func1() { usleep(10); }&#13;
void func2(int n) {&#13;
  if (n % 2) func1();&#13;
  else usleep(100);&#13;
}&#13;
int main(int argc, char *argv[]) {&#13;
  for (int i = 0; i &lt; 100; i++) { func1(); func2(i); }&#13;
  return 0;&#13;
}</pre>			<p>To enable the XRay instrumentation during compilation, you will need to specify the <strong class="source-inline">-fxray-instrument</strong> option. It is worth noting that functions with less than 200 instructions are not instrumented. This is because this is an arbitrary threshold defined by the developers, and<a id="_idIndexMarker632"/> in our case, the functions would not be instrumented. The threshold can be specified with the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">fxray-instruction-threshold=</strong></span><span class="No-Break"> option.</span></p>&#13;
			<p>Alternatively, we can add a function attribute to control if a function should be instrumented. For example, adding the following prototype would result in us always instrumenting <span class="No-Break">the function:</span></p>&#13;
			<pre class="source-code">&#13;
void func1() __attribute__((xray_always_instrument));</pre>			<p>Likewise, by using the <strong class="source-inline">xray_never_instrument</strong> attribute, you can turn off instrumentation for <span class="No-Break">a function.</span></p>&#13;
			<p>We will now use the command-line option and compile the <strong class="source-inline">xraydemo.c</strong> file, <span class="No-Break">as follows:</span></p>&#13;
			<pre class="console">&#13;
$ clang -fxray-instrument -fxray-instruction-threshold=1 -g\&#13;
  xraydemo.c -o xraydemo</pre>			<p>In the resulting binary, instrumentation is turned off by default. If you run the binary, you will note no difference compared to a non-instrumented binary. The <strong class="source-inline">XRAY_OPTIONS</strong> environment variable is used to control the recording of runtime data. To enable data collection, you can run the application <span class="No-Break">as follows:</span></p>&#13;
			<pre class="console">&#13;
$ XRAY_OPTIONS="patch_premain=true xray_mode=xray-basic"\&#13;
  ./xraydemo</pre>			<p>The <strong class="source-inline">xray_mode=xray-basic</strong> option tells the runtime that we want to use basic mode. In this mode, all runtime data is collected, which can result in large log files. When the <strong class="source-inline">patch_premain=true</strong> option is given, functions that are run before the <strong class="source-inline">main()</strong> function are <span class="No-Break">also instrumented.</span></p>&#13;
			<p>After running this command, a new file will be created in the directory, in which the collected data is stored. You will need to<a id="_idIndexMarker633"/> use the <strong class="bold">llvm-xray</strong> tool to extract any readable information from <span class="No-Break">this file.</span></p>&#13;
			<p>The llvm-xray tool supports<a id="_idIndexMarker634"/> various sub-commands. First of all, you can use the <strong class="source-inline">account</strong> sub-command to extract some basic statistics. For example, to get the top 10 most called functions, you can add the <strong class="source-inline">-top=10</strong> option to limit the output, and the <strong class="source-inline">-sort=count</strong> option to specify the function call count as the sort criteria. You can also influence the sort order with the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">sortorder=</strong></span><span class="No-Break"> option.</span></p>&#13;
			<p>The following commands can be run to get the statistics from <span class="No-Break">our program:</span></p>&#13;
			<pre class="console">&#13;
$ llvm-xray account xray-log.xraydemo.xVsWiE --sort=count\&#13;
  --sortorder=dsc --instr_map ./xraydemo&#13;
Functions with latencies: 3&#13;
   funcid      count        sum  function&#13;
        1        150   0.166002  demo.c:4:0: func1&#13;
        2        100   0.543103  demo.c:9:0: func2&#13;
        3          1   0.655643  demo.c:17:0: main</pre>			<p>As you can see, the <strong class="source-inline">func1()</strong> function is called most often; you can also see the accumulated time spent in this function. This example only has three functions, so the <strong class="source-inline">–top=</strong> option has no visible effect here, but for real applications, it is <span class="No-Break">very useful.</span></p>&#13;
			<p>From the collected data, it is possible to reconstruct all the stack frames that occurred during runtime. You use the <strong class="source-inline">stack</strong> sub-command to view the top 10 stacks. The output shown here has been <a id="_idIndexMarker635"/>reduced <span class="No-Break">for brevity:</span></p>&#13;
			<pre class="console">&#13;
$ llvm-xray stack xray-log.xraydemo.xVsWiE –instr_map\&#13;
  ./xraydemo&#13;
Unique Stacks: 3&#13;
Top 10 Stacks by leaf sum:&#13;
Sum: 1325516912&#13;
lvl   function              count              sum&#13;
#0    main                      1       1777862705&#13;
#1    func2                    50       1325516912&#13;
Top 10 Stacks by leaf count:&#13;
Count: 100&#13;
lvl   function              count              sum&#13;
#0    main                      1       1777862705&#13;
#1    func1                   100        303596276</pre>			<p>A <strong class="bold">stack frame</strong> is the<a id="_idIndexMarker636"/> sequence of how a function is called. The <strong class="source-inline">func2()</strong> function is called by the <strong class="source-inline">main()</strong> function, and this is the stack frame with the largest accumulated time. The depth depends on how many functions are called, and the stack frames are <span class="No-Break">usually large.</span></p>&#13;
			<p>This sub-command can also be used to <a id="_idIndexMarker637"/>create a <strong class="bold">flame graph</strong> from the stack frames. With a flame graph, you can easily identify which functions have a large, accumulated runtime. The output is the stack frames with count and runtime information. Using the <strong class="source-inline">flamegraph.pl</strong> script, you can convert the data into a <strong class="bold">scalable vector graphics</strong> (<strong class="bold">SVG</strong>) file that <a id="_idIndexMarker638"/>you can view in <span class="No-Break">your browser.</span></p>&#13;
			<p>With the following command, you instruct <strong class="source-inline">llvm-xray</strong> to output all stack frames with the <strong class="source-inline">–all-stacks</strong> option. Using the <strong class="source-inline">–stack-format=flame</strong> option, the output is in the format expected by the <strong class="source-inline">flamegraph.pl</strong> script. Moreover, with the <strong class="source-inline">–aggregation-type</strong> option, you can choose if stack frames are aggregated by total time or by the number of invocations. The output of <strong class="source-inline">llvm-xray</strong> is piped into the <strong class="source-inline">flamegraph.pl</strong> script, and the resulting output is saved in the <span class="No-Break"><strong class="source-inline">flame.svg</strong></span><span class="No-Break"> file:</span></p>&#13;
			<pre class="console">&#13;
$ llvm-xray stack xray-log.xraydemo.xVsWiE --all-stacks\&#13;
  --stack-format=flame --aggregation-type=time\&#13;
  --instr_map ./xraydemo | flamegraph.pl &gt;flame.svg</pre>			<p>After running the command and generating the new flame graph, you can open the generated <strong class="source-inline">flame.svg</strong> file in your browser. The graphic looks <span class="No-Break">as follows:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer027" class="IMG---Figure">&#13;
					<img src="Images/B19561_10_1.jpg" alt="Figure 10.1 – Flame graph produced by llvm-xray" width="1001" height="216"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Flame graph produced by llvm-xray</p>&#13;
			<p>Flame graphs can be <a id="_idIndexMarker639"/>confusing at first glance because the <em class="italic">X</em>-axis does not have the usual meaning of elapsed time. Instead, the functions are simply sorted alphabetically by name. Furthermore, the <em class="italic">Y</em>-axis of the flame graph shows the stack depth, where the bottom begins counting from zero. The colors are chosen to have a good contrast and have no other meaning. From the preceding graph, you can easily determine the call hierarchy and the time spent in <span class="No-Break">a function.</span></p>&#13;
			<p>Information about a stack frame is displayed only after you move the mouse cursor over the rectangle representing the frame. By clicking on the frame, you can zoom into this stack frame. Flame graphs are of great help if you want to identify functions worth optimizing. To find out more about flame graphs, please visit the website of Brendan Gregg, the inventor of flame <span class="No-Break">graphs: </span><a href="http://www.brendangregg.com/flamegraphs.html"><span class="No-Break">http://www.brendangregg.com/flamegraphs.html</span></a><span class="No-Break">.</span></p>&#13;
			<p>Additionally, you can use the <strong class="source-inline">convert</strong> subcommand to convert the data into <strong class="source-inline">.yaml</strong> format or the format used<a id="_idIndexMarker640"/> by the <strong class="bold">Chrome Trace Viewer Visualization</strong>. The latter is another nice way to create a graphic from the data. To save the data in the <strong class="source-inline">xray.evt</strong> file, you can run the <span class="No-Break">following command:</span></p>&#13;
			<pre class="console">&#13;
$ llvm-xray convert --output-format=trace_event\&#13;
  --output=xray.evt --symbolize --sort\&#13;
  --instr_map=./xraydemo xray-log.xraydemo.xVsWiE</pre>			<p>If you do not specify the <strong class="source-inline">–symbolize</strong> option, then no function names are shown in the <span class="No-Break">resulting graph.</span></p>&#13;
			<p>Once you’ve done<a id="_idIndexMarker641"/> that, open Chrome and type <strong class="source-inline">chrome:///tracing</strong>. Next, click on the <strong class="bold">Load</strong> button to load the <strong class="source-inline">xray.evt</strong> file. You will see the following visualization of <span class="No-Break">the data:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer028" class="IMG---Figure">&#13;
					<img src="Images/B19561_10_2.jpg" alt="Figure 10.2 – Chrome Trace Viewer Visualization generated by llvm-xray" width="1042" height="467"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Chrome Trace Viewer Visualization generated by llvm-xray</p>&#13;
			<p>In this view, the stack frames are sorted by the time the function call occurs. For further interpretation of the visualization, please read the tutorial <span class="No-Break">at </span><a href="https://www.chromium.org/developers/how-tos/trace-event-profiling-tool"><span class="No-Break">https://www.chromium.org/developers/how-tos/trace-event-profiling-tool</span></a><span class="No-Break">.</span></p>&#13;
			<p class="callout-heading">Tip</p>&#13;
			<p class="callout">The llvm-xray tool has more functionality that is applicable for performance profiling. You can read about it on the LLVM website at <a href="https://llvm.org/docs/XRay.html">https://llvm.org/docs/XRay.html</a> <span class="No-Break">and </span><a href="https://llvm.org/docs/XRayExample.html"><span class="No-Break">https://llvm.org/docs/XRayExample.html</span></a><span class="No-Break">.</span></p>&#13;
			<p>In this section, we learned how to instrument an application with XRay, how to collect runtime information, and how to visualize that data. We can use this knowledge to find performance<a id="_idIndexMarker642"/> bottlenecks <span class="No-Break">in applications.</span></p>&#13;
			<p>Another approach to identifying errors in an application is to analyze the so<a id="_idTextAnchor169"/>urce code, which is done with the clang <span class="No-Break">static analyzer.</span></p>&#13;
			<h1 id="_idParaDest-165"><a id="_idTextAnchor170"/>Checking the source with the clang static analyzer</h1>&#13;
			<p>The <strong class="bold">clang static analyzer</strong> is a tool <a id="_idIndexMarker643"/>that performs additional <a id="_idIndexMarker644"/>checks <a id="_idIndexMarker645"/>on C, C++, and <strong class="bold">Objective C</strong> source<a id="_idIndexMarker646"/> code. The checks that are performed by the static analyzer are more thorough than the checks the compiler performs. They are also more costly in terms of time and required resources. The static analyzer has a set of checkers, which check for <span class="No-Break">certain bugs.</span></p>&#13;
			<p>The tool performs a symbolic interpretation of the source code, which looks at all code paths through an application and derives constraints on the values used in the application from it. <strong class="bold">Symbolic interpretation</strong> is a <a id="_idIndexMarker647"/>common technique that’s used in compilers, for example, to identify constant values. In the context of the static analyzer, the checkers are applied to the <span class="No-Break">derived values.</span></p>&#13;
			<p>For example, if the divisor of a division is zero, then the static analyzer warns us about it. We can check this with the following example stored in the <span class="No-Break"><strong class="source-inline">div.c</strong></span><span class="No-Break"> file:</span></p>&#13;
			<pre class="source-code">&#13;
int divbyzero(int a, int b) { return a / b; }&#13;
int bug() { return divbyzero(5, 0); }</pre>			<p>The static analyzer will warn about a division by <strong class="source-inline">0</strong> in this example. However, when compiling, the file, when compiled with the <strong class="source-inline">clang -Wall -c div.c</strong> command, will show <span class="No-Break">no warning.</span></p>&#13;
			<p>There are two ways to invoke the static analyzer from the command line. The older tool is <strong class="bold">scan-build</strong>, which <a id="_idIndexMarker648"/>is included in LLVM and can be used for simple scenarios. The newer<a id="_idIndexMarker649"/> tool is <strong class="bold">CodeChecker</strong>, available at <a href="https://github.com/Ericsson/codechecker/">https://github.com/Ericsson/codechecker/</a>. To check a single file, the <strong class="source-inline">scan-build</strong> tool is the easiest solution. You simply pass the <strong class="source-inline">compile</strong> command to the tool; everything else is <span class="No-Break">done automatically:</span></p>&#13;
			<pre class="console">&#13;
$ scan-build clang -c div.c&#13;
scan-build: Using '/usr/home/kai/LLVM/llvm-17/bin/clang-17' for static analysis&#13;
div.c:2:12: warning: Division by zero [core.DivideZero]&#13;
  return a / b;&#13;
         ~~^~~&#13;
1 warning generated.&#13;
scan-build: Analysis run complete.&#13;
scan-build: 1 bug found.&#13;
scan-build: Run 'scan-view /tmp/scan-build-2021-03-01-023401-8721-1' to examine bug reports.</pre>			<p>The output on the <a id="_idIndexMarker650"/>screen<a id="_idIndexMarker651"/> already tells you that a problem was found – that is, the <strong class="source-inline">core.DivideZero</strong> checker was triggered. However, that is not all. You will find a complete report in HTML in the mentioned subdirectory of the <strong class="source-inline">/tmp</strong> directory. You can then use the <strong class="source-inline">scan-view</strong> command to view the report or open the <strong class="source-inline">index.html</strong> file found in the subdirectory in <span class="No-Break">your browser.</span></p>&#13;
			<p>The first page of the report shows you a summary of the bugs that <span class="No-Break">were found:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer029" class="IMG---Figure">&#13;
					<img src="Images/B19561_10_3.jpg" alt="Figure 10.3 – Summary page" width="737" height="522"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Summary page</p>&#13;
			<p>For each error that <a id="_idIndexMarker652"/>was <a id="_idIndexMarker653"/>found, the summary page shows the type of the error, the location in the source, and the path length after which the analyzer found the error. A link to a detailed report for the error is <span class="No-Break">also provided.</span></p>&#13;
			<p>The following screenshot shows the detailed report for <span class="No-Break">the error:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer030" class="IMG---Figure">&#13;
					<img src="Images/B19561_10_4.jpg" alt="Figure 10.4 – Detailed report" width="577" height="640"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Detailed report</p>&#13;
			<p>With this detailed report, you can verify the error by following the numbered bubbles. Our simple example shows how passing <strong class="source-inline">0</strong> as a parameter value leads to a division by <span class="No-Break">zero error.</span></p>&#13;
			<p>Thus, human verification is required. If the derived constraints are not precise enough for a certain checker, then false positives are possible – that is, an error is reported for perfectly fine code. Based<a id="_idIndexMarker654"/> on the report, you can use <a id="_idIndexMarker655"/>them to identify <span class="No-Break">false positives.</span></p>&#13;
			<p>You are not limited to checkers that are provided with the tool – you can a<a id="_idTextAnchor171"/>lso add new checkers. The next section demonstrates how to <span class="No-Break">do this.</span></p>&#13;
			<h2 id="_idParaDest-166"><a id="_idTextAnchor172"/>Adding a new checker to the clang static analyzer</h2>&#13;
			<p>Many C libraries provide<a id="_idIndexMarker656"/> functions that must be used in pairs. For example, the C standard library provides the <strong class="source-inline">malloc()</strong> and <strong class="source-inline">free()</strong> functions. The memory that’s allocated by <strong class="source-inline">malloc()</strong> function must be freed exactly one time by the <strong class="source-inline">free()</strong> function. Not calling the <strong class="source-inline">free()</strong> function, or calling it several times, is a programming error. There are many more instances of this coding pattern, and the static analyzer provides checkers for some <span class="No-Break">of them.</span></p>&#13;
			<p>The <strong class="bold">iconv</strong> library provides <a id="_idIndexMarker657"/>functions for converting text from one encoding into another – for example, from Latin-1 encoding into UTF-16 encoding. To perform the conversion, the implementation needs to allocate memory. To transparently manage the internal resources, the iconv library provides the <strong class="source-inline">iconv_open()</strong> and <strong class="source-inline">iconv_close()</strong> functions, which must be used in pairs, similar to the memory management functions. No checker is implemented for those functions, so let’s <span class="No-Break">implement one.</span></p>&#13;
			<p>To add a new checker to the clang static analyzer, you must create a new subclass of the <strong class="source-inline">Checker</strong> class. The static analyzer tries all possible paths through the code. The analyzer engine generates events at certain points – for example, before or after a function call. Moreover, your class must provide callbacks for these events if you need to handle them. The <strong class="source-inline">Checker</strong> class and the registrations for the events are provided in the <strong class="source-inline">clang/include/clang/StaticAnalyzer/Core/Checker.h</strong> <span class="No-Break">header file.</span></p>&#13;
			<p>Usually, a checker needs to track some symbols. However, the checker cannot manage the state because it does not know which code path the analyzer engine currently tries. Therefore, the tracked state must be registered with the engine, and can only be changed using a <span class="No-Break"><strong class="source-inline">ProgramStateRef</strong></span><span class="No-Break"> instance.</span></p>&#13;
			<p>To detect the errors, the checker needs to track the descriptor that’s returned from the <strong class="source-inline">iconv_open()</strong> function. The analyzer engine returns a <strong class="source-inline">SymbolRef</strong> instance for the return value of the <strong class="source-inline">iconv_open()</strong> function. We associate this symbol with a state to reflect if <strong class="source-inline">iconv_close()</strong> was called or not. For the state, we create the <strong class="source-inline">IconvState</strong> class, which encapsulates a <span class="No-Break"><strong class="source-inline">bool</strong></span><span class="No-Break"> value.</span></p>&#13;
			<p>The new <strong class="source-inline">IconvChecker</strong> class needs to handle four types <span class="No-Break">of events:</span></p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">PostCall</strong>, which occurs after a function call. After the <strong class="source-inline">iconv_open()</strong> function was called, we retrieved the symbol for the return value and remembered it as being in an “<span class="No-Break">opened” state.</span></li>&#13;
				<li><strong class="source-inline">PreCall</strong>, which occurs before a function call. Before the <strong class="source-inline">iconv_close()</strong> function is called, we check if the symbol for the descriptor is in an “opened” state. If not, then the <strong class="source-inline">iconv_close()</strong> function was already called for the descriptor, and we have detected a double call to <span class="No-Break">the function.</span></li>&#13;
				<li><strong class="source-inline">DeadSymbols</strong>, which occurs when unused symbols are cleaned up. We check if an unused symbol for a descriptor is still in an “opened” state. If it is, then we have detected a missing call to <strong class="source-inline">iconv_close()</strong>, which is a <span class="No-Break">resource leak.</span></li>&#13;
				<li><strong class="source-inline">PointerEscape</strong>, which is called when the symbols can no longer be tracked by the analyzer. In this case, we remove the symbol from the state because we can no longer reason about whether the descriptor was closed <span class="No-Break">or not.</span></li>&#13;
			</ul>&#13;
			<p>We can create a new <a id="_idIndexMarker658"/>directory to implement the<a id="_idTextAnchor173"/> new checker as a clang plugin, and add the implementations within the <span class="No-Break"><strong class="source-inline">IconvChecker.cpp</strong></span><span class="No-Break"> file:</span></p>&#13;
			<ol>&#13;
				<li>For the implementation, we need to include several header files. The <strong class="source-inline">include</strong> file, <strong class="source-inline">BugType.h</strong> is required for emitting reports. The header file, <strong class="source-inline">Checker.h</strong>, provides the declaration of the <strong class="source-inline">Checker</strong> class and the callbacks for the events, which are declared in the <strong class="source-inline">CallEvent</strong> file Moreover, the <strong class="source-inline">CallDescription.h</strong> file helps with matching functions and methods. Finally, the <strong class="source-inline">CheckerContext.h</strong> file is required for declaring the <strong class="source-inline">CheckerContext</strong> class, which is the central class that provides access to the state of <span class="No-Break">the analyzer:</span><pre class="source-code">&#13;
#include "clang/StaticAnalyzer/Core/BugReporter/BugType.h"&#13;
#include "clang/StaticAnalyzer/Core/Checker.h"&#13;
#include "clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h"&#13;
#include "clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h"&#13;
#include "clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h"&#13;
#include "clang/StaticAnalyzer/Frontend/CheckerRegistry.h"&#13;
#include &lt;optional&gt;</pre></li>				<li>To avoid typing<a id="_idIndexMarker659"/> the namespace names, we can use the <strong class="source-inline">clang</strong> and <span class="No-Break"><strong class="source-inline">ento</strong></span><span class="No-Break"> namespaces:</span><pre class="source-code">&#13;
using namespace clang;&#13;
using namespace ento;</pre></li>				<li>We associate a state with each symbol representing an iconv descriptor. The state can be open or closed, and we use a <strong class="source-inline">bool</strong> typed variable, with <strong class="source-inline">true</strong> value for the open state. The state value is encapsulated in the <strong class="source-inline">IconvState</strong> struct. This struct is used with a <strong class="source-inline">FoldingSet</strong> data structure, which is a hash set that filters duplicate entries. To be usable with this data structure implementation, the <strong class="source-inline">Profile()</strong> method is added here, which sets the unique bits of this struct. We put the struct into an anonymous namespace to avoid polluting the global namespace. Instead of exposing the <strong class="source-inline">bool</strong> value, the class provides the <strong class="source-inline">getOpened()</strong> and <strong class="source-inline">getClosed()</strong> factory methods and the <strong class="source-inline">isOpen()</strong> <span class="No-Break">query method:</span><pre class="source-code">&#13;
namespace {&#13;
class IconvState {&#13;
  const bool IsOpen;&#13;
  IconvState(bool IsOpen) : IsOpen(IsOpen) {}&#13;
public:&#13;
  bool isOpen() const { return IsOpen; }&#13;
  static IconvState getOpened() {&#13;
    return IconvState(true);&#13;
  }&#13;
  static IconvState getClosed() {&#13;
    return IconvState(false);&#13;
  }&#13;
  bool operator==(const IconvState &amp;O) const {&#13;
    return IsOpen == O.IsOpen;&#13;
  }&#13;
  void Profile(llvm::FoldingSetNodeID &amp;ID) const {&#13;
    ID.AddInteger(IsOpen);&#13;
  }&#13;
};&#13;
} // namespace</pre></li>				<li>The <strong class="source-inline">IconvState</strong> struct <a id="_idIndexMarker660"/>represents the state of an iconv descriptor, which is represented by a symbol of the <strong class="source-inline">SymbolRef</strong> class. This is best done with a map, which has the symbol as the key and the state as the value. As explained earlier, the checker cannot hold the state. Instead, the state must be registered with the global program state, which is done with the <strong class="source-inline">REGISTER_MAP_WITH_PROGRAMSTATE</strong> macro. This macro introduces the <strong class="source-inline">IconvStateMap</strong> name, which we will use later to access <span class="No-Break">the map:</span><pre class="source-code">&#13;
REGISTER_MAP_WITH_PROGRAMSTATE(IconvStateMap, SymbolRef,&#13;
                               IconvState)</pre></li>				<li>We also implement the <strong class="source-inline">IconvChecker</strong> class in an anonymous namespace. The requested <strong class="source-inline">PostCall</strong>, <strong class="source-inline">PreCall</strong>, <strong class="source-inline">DeadSymbols</strong>, and <strong class="source-inline">PointerEscape</strong> events are template parameters to the <strong class="source-inline">Checker</strong> <span class="No-Break">base class:</span><pre class="source-code">&#13;
namespace {&#13;
class IconvChecker&#13;
    : public Checker&lt;check::PostCall, check::PreCall,&#13;
                     check::DeadSymbols,&#13;
                     check::PointerEscape&gt; {</pre></li>				<li>The <strong class="source-inline">IconvChecker</strong> class<a id="_idIndexMarker661"/> has fields of the <strong class="source-inline">CallDescription</strong> type, which are used to identify function calls to <strong class="source-inline">iconv_open()</strong>, <strong class="source-inline">iconv()</strong>, and <strong class="source-inline">iconv_close()</strong>in <span class="No-Break">the program:</span><pre class="source-code">&#13;
  CallDescription IconvOpenFn, IconvFn, IconvCloseFn;</pre></li>				<li>The class also holds references to the detected <span class="No-Break">bug types:</span><pre class="source-code">&#13;
  std::unique_ptr&lt;BugType&gt; DoubleCloseBugType;&#13;
  std::unique_ptr&lt;BugType&gt; LeakBugType;</pre></li>				<li>Finally, the class has a couple of methods. Besides the constructor and the methods for the call events, we also need a method to emit a <span class="No-Break">bug report:</span><pre class="source-code">&#13;
  void report(ArrayRef&lt;SymbolRef&gt; Syms,&#13;
              const BugType &amp;Bug, StringRef Desc,&#13;
              CheckerContext &amp;C, ExplodedNode *ErrNode,&#13;
              std::optional&lt;SourceRange&gt; Range =&#13;
                  std::nullopt) const;&#13;
public:&#13;
  IconvChecker();&#13;
  void checkPostCall(const CallEvent &amp;Call,&#13;
                     CheckerContext &amp;C) const;&#13;
  void checkPreCall(const CallEvent &amp;Call,&#13;
                    CheckerContext &amp;C) const;&#13;
  void checkDeadSymbols(SymbolReaper &amp;SymReaper,&#13;
                        CheckerContext &amp;C) const;&#13;
  ProgramStateRef&#13;
  checkPointerEscape(ProgramStateRef State,&#13;
                     const InvalidatedSymbols &amp;Escaped,&#13;
                     const CallEvent *Call,&#13;
                     PointerEscapeKind Kind) const;&#13;
};&#13;
} // namespace</pre></li>				<li>The implementation of the <a id="_idIndexMarker662"/>constructor of the <strong class="source-inline">IconvChecker</strong> class initializes the <strong class="source-inline">CallDescription</strong> fields using the name of the functions, and creates the objects representing the <span class="No-Break">bug types:</span><pre class="source-code">&#13;
IconvChecker::IconvChecker()&#13;
    : IconvOpenFn({"iconv_open"}), IconvFn({"iconv"}),&#13;
      IconvCloseFn({"iconv_close"}, 1) {&#13;
  DoubleCloseBugType.reset(new BugType(&#13;
      this, "Double iconv_close", "Iconv API Error"));&#13;
  LeakBugType.reset(new BugType(&#13;
      this, "Resource Leak", "Iconv API Error",&#13;
      /*SuppressOnSink=*/true));&#13;
}</pre></li>				<li>Now, we can implement the first call event method, <strong class="source-inline">checkPostCall()</strong>. This method is called after the analyzer has executed a function call. If the executed function is not a global C function and not named <strong class="source-inline">iconv_open</strong>, then there is nothing <span class="No-Break">to do:</span><pre class="source-code">&#13;
void IconvChecker::checkPostCall(&#13;
    const CallEvent &amp;Call, CheckerContext &amp;C) const {&#13;
  if (!Call.isGlobalCFunction())&#13;
    return;&#13;
  if (!IconvOpenFn.matches(Call))&#13;
    return;</pre></li>				<li>Otherwise, we can<a id="_idIndexMarker663"/> try to get the return value of the function as a symbol. To store the symbol with the open state in the global program state, we need to get a <strong class="source-inline">ProgramStateRef</strong> instance from the <strong class="source-inline">CheckerContext</strong> instance. The state is immutable, so adding the symbol to the state results in a new state. Finally, the analyzer engine is informed about the new state with a call to the <span class="No-Break"><strong class="source-inline">addTransition()</strong></span><span class="No-Break"> method:</span><pre class="source-code">&#13;
  if (SymbolRef Handle =&#13;
          Call.getReturnValue().getAsSymbol()) {&#13;
    ProgramStateRef State = C.getState();&#13;
    State = State-&gt;set&lt;IconvStateMap&gt;(&#13;
        Handle, IconvState::getOpened());&#13;
    C.addTransition(State);&#13;
  }&#13;
}</pre></li>				<li>Likewise, the <strong class="source-inline">checkPreCall()</strong> method is called before the analyzer executes a function. Only a global C function called <strong class="source-inline">iconv_close</strong> is of interest <span class="No-Break">to us:</span><pre class="source-code">&#13;
void IconvChecker::checkPreCall(&#13;
    const CallEvent &amp;Call, CheckerContext &amp;C) const {&#13;
  if (!Call.isGlobalCFunction()) {&#13;
    return;&#13;
  }&#13;
  if (!IconvCloseFn.matches(Call)) {&#13;
    return;&#13;
  }</pre></li>				<li>If the symbol for <a id="_idIndexMarker664"/>the first argument of the function, which is the iconv descriptor, is known, then we can retrieve the state of the symbol from the <span class="No-Break">program state:</span><pre class="source-code">&#13;
  if (SymbolRef Handle =&#13;
          Call.getArgSVal(0).getAsSymbol()) {&#13;
    ProgramStateRef State = C.getState();&#13;
    if (const IconvState *St =&#13;
            State-&gt;get&lt;IconvStateMap&gt;(Handle)) {</pre></li>				<li>If the state represents the closed state, then we have detected a double close error, and we can generate a bug report for it. The call to <strong class="source-inline">generateErrorNode()</strong> can return a <strong class="source-inline">nullptr</strong> value if an error report was already generated for this path, so we have to check for <span class="No-Break">this situation:</span><pre class="source-code">&#13;
      if (!St-&gt;isOpen()) {&#13;
        if (ExplodedNode *N = C.generateErrorNode()) {&#13;
          report(Handle, *DoubleCloseBugType,&#13;
                 "Closing a previous closed iconv "&#13;
                 "descriptor",&#13;
                 C, N, Call.getSourceRange());&#13;
        }&#13;
        return;&#13;
      }&#13;
    }</pre></li>				<li>Otherwise, we must set the state for the symbol to the “<span class="No-Break">closed” state:</span><pre class="source-code">&#13;
    State = State-&gt;set&lt;IconvStateMap&gt;(&#13;
        Handle, IconvState::getClosed());&#13;
    C.addTransition(State);&#13;
  }&#13;
}</pre></li>				<li>The <strong class="source-inline">checkDeadSymbols()</strong> method is <a id="_idIndexMarker665"/>called to clean up unused symbols. We loop over all symbols we track and ask the <strong class="source-inline">SymbolReaper</strong> instance if the current symbol <span class="No-Break">is dead:</span><pre class="source-code">&#13;
void IconvChecker::checkDeadSymbols(&#13;
    SymbolReaper &amp;SymReaper, CheckerContext &amp;C) const {&#13;
  ProgramStateRef State = C.getState();&#13;
  SmallVector&lt;SymbolRef, 8&gt; LeakedSyms;&#13;
  for (auto [Sym, St] : State-&gt;get&lt;IconvStateMap&gt;()) {&#13;
    if (SymReaper.isDead(Sym)) {</pre></li>				<li>If the symbol is dead, then we need to check the state. If the state is still open, then this is a potential resource leak. There is one exception: <strong class="source-inline">iconv_open()</strong> returns <strong class="source-inline">-1</strong> in case of an error. If the analyzer is in a code path that handles this error, then it is wrong to assume a resource leak because the function call failed. We try to get the value of the symbol from the <strong class="source-inline">ConstraintManager</strong> instance, and we do not consider the symbol as a resource leak if this value is <strong class="source-inline">-1</strong>. We add a leaked symbol to a <strong class="source-inline">SmallVector</strong> instance to generate the error report later. Finally, we <a id="_idIndexMarker666"/>remove the dead symbol from the <span class="No-Break">program state:</span><pre class="source-code">&#13;
      if (St.isOpen()) {&#13;
        bool IsLeaked = true;&#13;
        if (const llvm::APSInt *Val =&#13;
                State-&gt;getConstraintManager().getSymVal(&#13;
                    State, Sym))&#13;
          IsLeaked = Val-&gt;getExtValue() != -1;&#13;
        if (IsLeaked)&#13;
          LeakedSyms.push_back(Sym);&#13;
      }&#13;
      State = State-&gt;remove&lt;IconvStateMap&gt;(Sym);&#13;
    }&#13;
  }</pre></li>				<li>After the loop, we call the <strong class="source-inline">generateNonFatalErrorNode()</strong> method. This method transitions to the new program state and returns an error node if there is not already an error node for this path. The <strong class="source-inline">LeakedSyms</strong> container holds the (possibly empty) list of leaked symbols, and we call the <strong class="source-inline">report()</strong> method to generate an <span class="No-Break">error report:</span><pre class="source-code">&#13;
  if (ExplodedNode *N =&#13;
          C.generateNonFatalErrorNode(State)) {&#13;
    report(LeakedSyms, *LeakBugType,&#13;
           "Opened iconv descriptor not closed", C, N);&#13;
  }&#13;
}</pre></li>				<li>The <strong class="source-inline">checkPointerEscape()</strong> function is called when the analyzer detects a function call for which the parameters cannot be tracked. In such a case, we must assume that we do not know if the iconv descriptor will be closed inside the function or not. The exceptions are a call to <strong class="source-inline">iconv()</strong>, which does the conversion and is known to not call the <strong class="source-inline">iconv_close()</strong> function, and the <strong class="source-inline">iconv_close()</strong> function itself, which we handle in the <strong class="source-inline">checkPreCall()</strong> method. We also do not change the state if the call is inside a system header file, and if we know that the arguments do not escape in the called function. In all other cases, we<a id="_idIndexMarker667"/> remove the symbol from <span class="No-Break">the state:</span><pre class="source-code">&#13;
ProgramStateRef IconvChecker::checkPointerEscape(&#13;
    ProgramStateRef State,&#13;
    const InvalidatedSymbols &amp;Escaped,&#13;
    const CallEvent *Call,&#13;
    PointerEscapeKind Kind) const {&#13;
  if (Kind == PSK_DirectEscapeOnCall) {&#13;
    if (IconvFn.matches(*Call) ||&#13;
        IconvCloseFn.matches(*Call))&#13;
      return State;&#13;
    if (Call-&gt;isInSystemHeader() ||&#13;
        !Call-&gt;argumentsMayEscape())&#13;
      return State;&#13;
  }&#13;
  for (SymbolRef Sym : Escaped)&#13;
    State = State-&gt;remove&lt;IconvStateMap&gt;(Sym);&#13;
  return State;&#13;
}</pre></li>				<li>The <strong class="source-inline">report()</strong> method generates an error report. The important parameters of the method are an array of symbols, the type of the bug, and a bug description. Inside the method, a bug report is created for each symbol, and the symbol is marked as the interesting one for the bug. If a source range is provided as a parameter, then<a id="_idIndexMarker668"/> this is also added to the report. Finally, the report <span class="No-Break">is emitted:</span><pre class="source-code">&#13;
void IconvChecker::report(&#13;
    ArrayRef&lt;SymbolRef&gt; Syms, const BugType &amp;Bug,&#13;
    StringRef Desc, CheckerContext &amp;C,&#13;
    ExplodedNode *ErrNode,&#13;
    std::optional&lt;SourceRange&gt; Range) const {&#13;
  for (SymbolRef Sym : Syms) {&#13;
    auto R = std::make_unique&lt;PathSensitiveBugReport&gt;(&#13;
        Bug, Desc, ErrNode);&#13;
    R-&gt;markInteresting(Sym);&#13;
    if (Range)&#13;
      R-&gt;addRange(*Range);&#13;
    C.emitReport(std::move(R));&#13;
  }&#13;
}</pre></li>				<li>Now, the new checker needs to be registered at a <strong class="source-inline">CheckerRegistry</strong> instance. When our plugin is loaded, the <strong class="source-inline">clang_registerCheckers()</strong> function is used, in which we perform the registration. Each checker has a name and belongs to a package. We call the <strong class="source-inline">IconvChecker</strong> checker and put it into the <strong class="source-inline">unix</strong> packager because the iconv library is a standard POSIX interface. This is the first parameter of the <strong class="source-inline">addChecker()</strong> method. The second parameter is a brief documentation of the functionality, and the third parameter can be a URI to a document that provides more information about <span class="No-Break">the checker:</span><pre class="source-code">&#13;
extern "C" void&#13;
clang_registerCheckers(CheckerRegistry &amp;registry) {&#13;
  registry.addChecker&lt;IconvChecker&gt;(&#13;
      "unix.IconvChecker",&#13;
      "Check handling of iconv functions", "");&#13;
}</pre></li>				<li>Finally, we need to declare the version of the static analyzer API we are using, which enables the<a id="_idIndexMarker669"/> system to determine if the plugin <span class="No-Break">is compatible:</span><pre class="source-code">&#13;
extern "C" const char clang_analyzerAPIVersionString[] =&#13;
    CLANG_ANALYZER_API_VERSION_STRING;</pre><p class="list-inset">This finishes the implementation of the new checker. To build the plugin, we also need to create a build description in the <strong class="source-inline">CMakeLists.txt</strong> file which lives in the same directory <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">IconvChecker.cpp</strong></span><span class="No-Break">:</span></p></li>				<li>Begin by defining the<a id="_idIndexMarker670"/> required <strong class="bold">CMake</strong> version and the name of <span class="No-Break">the project:</span><pre class="source-code">&#13;
cmake_minimum_required(VERSION 3.20.0)&#13;
project(iconvchecker)</pre></li>				<li>Next, include the LLVM files. If CMake can’t find the files automatically, then you have to set the <strong class="source-inline">LLVM_DIR</strong> variable so that it points to the LLVM directory containing the <span class="No-Break">CMake files:</span><pre class="source-code">&#13;
find_package(LLVM REQUIRED CONFIG)</pre></li>				<li>Append the LLVM directory with the CMake files to the search path, and include the required modules <span class="No-Break">from LLVM:</span><pre class="source-code">&#13;
list(APPEND CMAKE_MODULE_PATH ${LLVM_DIR})&#13;
include(AddLLVM)&#13;
include(HandleLLVMOptions)</pre></li>				<li>Then, load the CMake definitions for clang. If CMake can’t find the files automatically, then you have to set the <strong class="source-inline">Clang_DIR</strong> variable so that it points to the clang directory containing the <span class="No-Break">CMake files:</span><pre class="source-code">&#13;
find_package(Clang REQUIRED)</pre></li>				<li>Next, append the Clang directory with the CMake files to the search path, and include the required modules <span class="No-Break">from Clang:</span><pre class="source-code">&#13;
list(APPEND CMAKE_MODULE_PATH ${Clang_DIR})&#13;
include(AddClang)</pre></li>				<li>Then, define where the <a id="_idIndexMarker671"/>header files and the library files are located, and which definitions <span class="No-Break">to use:</span><pre class="source-code">&#13;
include_directories("${LLVM_INCLUDE_DIR}"&#13;
                    "${CLANG_INCLUDE_DIRS}")&#13;
add_definitions("${LLVM_DEFINITIONS}")&#13;
link_directories("${LLVM_LIBRARY_DIR}")</pre></li>				<li>The previous definitions set up the build environment. Insert the following command, which defines the name of your plugin, the source file(s) of the plugin, and that it is a <span class="No-Break">clang plugin:</span><pre class="source-code">&#13;
add_llvm_library(IconvChecker MODULE IconvChecker.cpp&#13;
                 PLUGIN_TOOL clang)</pre></li>				<li>On <strong class="bold">Windows</strong>, the plugin support is different from <strong class="bold">Unix</strong>, and the required LLVM and clang libraries must be linked in. The following code <span class="No-Break">ensures this:</span><pre class="source-code">&#13;
if(WIN32 OR CYGWIN)&#13;
  set(LLVM_LINK_COMPONENTS Support)&#13;
  clang_target_link_libraries(IconvChecker PRIVATE&#13;
    clangAnalysis&#13;
    clangAST&#13;
    clangStaticAnalyzerCore&#13;
    clangStaticAnalyzerFrontend)&#13;
endif()</pre></li>			</ol>&#13;
			<p>Now, we can configure and build the plugin, assuming that the <strong class="source-inline">CMAKE_GENERATOR</strong> and <strong class="source-inline">CMAKE_BUILD_TYPE</strong> environment variables <span class="No-Break">are set:</span></p>&#13;
			<pre class="console">&#13;
$ cmake -DLLVM_DIR=~/LLVM/llvm-17/lib/cmake/llvm \&#13;
        -DClang_DIR=~/LLVM/llvm-17/lib/cmake/clang \&#13;
        -B build&#13;
$ cmake --build build</pre>			<p>You can test the new checker with the following source saved in the <strong class="source-inline">conv.c</strong> file, which has two calls to <a id="_idIndexMarker672"/>the <span class="No-Break"><strong class="source-inline">iconv_close()</strong></span><span class="No-Break"> function:</span></p>&#13;
			<pre class="source-code">&#13;
#include &lt;iconv.h&gt;&#13;
void doconv() {&#13;
  iconv_t id = iconv_open("Latin1", "UTF-16");&#13;
  iconv_close(id);&#13;
  iconv_close(id);&#13;
}</pre>			<p>To use the plugin with the <strong class="source-inline">scan-build</strong> script, you need to specify the path to the plugin via the <strong class="source-inline">-load-plugin</strong> option. A run with the <strong class="source-inline">conv.c</strong> file <span class="No-Break">looks like:</span></p>&#13;
			<pre class="console">&#13;
$ scan-build -load-plugin build/IconvChecker.so clang-17 \&#13;
             -c conv.c&#13;
scan-build: Using '/home/kai/LLVM/llvm-17/bin/clang-17' for static analysis&#13;
conv.c:6:3: warning: Closing a previous closed iconv descriptor [unix.IconvChecker]&#13;
    6 |   iconv_close(id);&#13;
      |   ^~~~~~~~~~~~~~~&#13;
1 warning generated.&#13;
scan-build: Analysis run complete.&#13;
scan-build: 1 bug found.&#13;
scan-build: Run 'scan-view /tmp/scan-build-2023-08-08-114154-12451-1' to examine bug reports.</pre>			<p>With that, you’ve learned how to extend the clang static analyzer with your own checker. You can use this knowledge to either create new general checkers and contribute them to the community or create checkers specifically built for your needs, to raise the quality of <span class="No-Break">your product.</span></p>&#13;
			<p>The static analyzer is<a id="_idIndexMarker673"/> built by leveraging the clang infrastructure. The next section introduces you to how can build your own plugin <span class="No-Break">extending clang.</span></p>&#13;
			<h1 id="_idParaDest-167"><a id="_idTextAnchor174"/>Creating your own clang-based tool</h1>&#13;
			<p>The static analyzer is an<a id="_idIndexMarker674"/> impressive example of what you can do with the clang infrastructure. It is also possible to extend clang with plugins so that you can add your own functionality to clang. The technique is very similar to adding a pass plugin <span class="No-Break">to LLVM.</span></p>&#13;
			<p>Let’s explore the functionality with a simple plugin. The LLVM coding standard requires function names to begin with a lowercase letter. However, the coding standard has evolved, and there are many instances in which a function begins with an uppercase letter. A plugin that warns about a violation of the naming rule can help fix this issue, so let’s give it <span class="No-Break">a try.</span></p>&#13;
			<p>Because you want to run a user-defined action over the AST, you need to define a subclass of the <strong class="source-inline">PluginASTAction</strong> class. If you write your own tool using the clang libraries, then you can define subclasses of the <strong class="source-inline">ASTFrontendAction</strong> class for your actions. The <strong class="source-inline">PluginASTAction</strong> class is a subclass of the <strong class="source-inline">ASTFrontendAction</strong> class, with the additional ability to parse <span class="No-Break">command-line options.</span></p>&#13;
			<p>The other class you need is a subclass of the <strong class="source-inline">ASTConsumer</strong> class. An AST consumer is a class using which you can run an action over an AST, regardless of the origin of the AST. Nothing more is needed for our first plugin. You can create the implementation in the <strong class="source-inline">NamingPlugin.cpp</strong> file <span class="No-Break">as follows:</span></p>&#13;
			<ol>&#13;
				<li>Begin by including the required header files. Besides the mentioned <strong class="source-inline">ASTConsumer</strong> class, you also need an instance of the compiler and the <span class="No-Break">plugin registry:</span><pre class="source-code">&#13;
#include "clang/AST/ASTConsumer.h"&#13;
#include "clang/Frontend/CompilerInstance.h"&#13;
#include "clang/Frontend/FrontendPluginRegistry.h"</pre></li>				<li>Use the <strong class="source-inline">clang</strong> namespace and put your implementation into an anonymous <strong class="source-inline">namespace</strong> to <a id="_idIndexMarker675"/>avoid <span class="No-Break">name clashes:</span><pre class="source-code">&#13;
using namespace clang;&#13;
namespace {</pre></li>				<li>Next, define your subclass of the <strong class="source-inline">ASTConsumer</strong> class. Later, you will want to emit warnings in case you detect a violation of the naming rule. To do so, you need a reference to a <span class="No-Break"><strong class="source-inline">DiagnosticsEngine</strong></span><span class="No-Break"> instance.</span></li>&#13;
				<li>You’ll need to store a <strong class="source-inline">CompilerInstance</strong> instance in the class, after which you can ask for a <span class="No-Break"><strong class="source-inline">DiagnosticsEngine</strong></span><span class="No-Break"> instance:</span><pre class="source-code">&#13;
class NamingASTConsumer : public ASTConsumer {&#13;
  CompilerInstance &amp;CI;&#13;
public:&#13;
  NamingASTConsumer(CompilerInstance &amp;CI) : CI(CI) {}</pre></li>				<li>An <strong class="source-inline">ASTConsumer</strong> instance has several entry methods. The <strong class="source-inline">HandleTopLevelDecl()</strong> method fits our purpose. The method is called for each declaration at the top level. This includes more than functions – for example, variables. So, you must use the LLVM RTTI <strong class="source-inline">dyn_cast&lt;&gt;()</strong> function to determine if the declaration is a function declaration. The <strong class="source-inline">HandleTopLevelDecl()</strong> method has a declaration group as a parameter, which can contain more than a single declaration. This requires a loop over the declarations. The<a id="_idIndexMarker676"/> following code shows the <span class="No-Break"><strong class="source-inline">HandleTopLevelDecl()</strong></span><span class="No-Break"> method:</span><pre class="source-code">&#13;
  bool HandleTopLevelDecl(DeclGroupRef DG) override {&#13;
    for (DeclGroupRef::iterator I = DG.begin(),&#13;
                                E = DG.end();&#13;
         I != E; ++I) {&#13;
      const Decl *D = *I;&#13;
      if (const FunctionDecl *FD =&#13;
              dyn_cast&lt;FunctionDecl&gt;(D)) {</pre></li>				<li>After finding a function declaration, you’ll need to retrieve the name of the function. You’ll also need to make sure that the name is <span class="No-Break">not empty:</span><pre class="source-code">&#13;
        std::string Name =&#13;
            FD-&gt;getNameInfo().getName().getAsString();&#13;
        assert(Name.length() &gt; 0 &amp;&amp;&#13;
               "Unexpected empty identifier");</pre><p class="list-inset">If the function name does not start with a lowercase letter, then you’ll have a violation of the naming rule that <span class="No-Break">was found:</span></p><pre class="source-code">        char &amp;First = Name.at(0);&#13;
        if (!(First &gt;= 'a' &amp;&amp; First &lt;= 'z')) {</pre></li>				<li>To emit a warning, you need a <strong class="source-inline">DiagnosticsEngine</strong> instance. Additionally, you need a message ID. Inside clang, the message ID is defined as an enumeration. Because your plugin is not part of clang, you need to create a custom ID, which you can then use to emit <span class="No-Break">the warning:</span><pre class="source-code">&#13;
          DiagnosticsEngine &amp;Diag = CI.getDiagnostics();&#13;
          unsigned ID = Diag.getCustomDiagID(&#13;
              DiagnosticsEngine::Warning,&#13;
              "Function name should start with "&#13;
              "lowercase letter");&#13;
          Diag.Report(FD-&gt;getLocation(), ID);</pre></li>				<li>Except for closing all open braces, you need to return <strong class="source-inline">true</strong> from this function to indicate that<a id="_idIndexMarker677"/> processing <span class="No-Break">can continue:</span><pre class="source-code">&#13;
        }&#13;
      }&#13;
    }&#13;
    return true;&#13;
  }&#13;
};</pre></li>				<li>Next, you need to create the <strong class="source-inline">PluginASTAction</strong> subclass, which implements the interface called <span class="No-Break">by clang:</span><pre class="source-code">&#13;
class PluginNamingAction : public PluginASTAction {&#13;
public:</pre><p class="list-inset">The first method you must implement is the <strong class="source-inline">CreateASTConsumer()</strong> method, which returns an instance of your <strong class="source-inline">NamingASTConsumer</strong> class. This method is called by clang, and the passed <strong class="source-inline">CompilerInstance</strong> instance gives you access to all the important classes of the compiler. The following code <span class="No-Break">demonstrates this:</span></p><pre class="source-code">  std::unique_ptr&lt;ASTConsumer&gt;&#13;
  CreateASTConsumer(CompilerInstance &amp;CI,&#13;
                    StringRef file) override {&#13;
    return std::make_unique&lt;NamingASTConsumer&gt;(CI);&#13;
  }</pre></li>				<li>A plugin also has access to command-line options. Your plugin has no command-line parameters, and you will only return <strong class="source-inline">true</strong> to <span class="No-Break">indicate success:</span><pre class="source-code">&#13;
  bool ParseArgs(const CompilerInstance &amp;CI,&#13;
                 const std::vector&lt;std::string&gt; &amp;args)&#13;
                                               override {&#13;
    return true;&#13;
  }</pre></li>				<li>The action type of a plugin describes when the action is invoked. The default value is <strong class="source-inline">Cmdline</strong>, which<a id="_idIndexMarker678"/> means that the plugin must be named on the command line to be invoked. You’ll need to override the method and change the value to <strong class="source-inline">AddAfterMainAction</strong>, which automatically runs <span class="No-Break">the action:</span><pre class="source-code">&#13;
  PluginASTAction::ActionType getActionType() override {&#13;
    return AddAfterMainAction;&#13;
  }</pre></li>				<li>The implementation of your <strong class="source-inline">PluginNamingAction</strong> class is finished; only the closing braces for the class and the anonymous namespace are missing. Add them to the code, <span class="No-Break">as follows:</span><pre class="source-code">&#13;
};&#13;
}</pre></li>				<li>Lastly, you need to register the plugin. The first parameter is the name of the plugin, while the second parameter is <span class="No-Break">help text:</span><pre class="source-code">&#13;
static FrontendPluginRegistry::Add&lt;PluginNamingAction&gt;&#13;
    X("naming-plugin", "naming plugin");</pre></li>			</ol>&#13;
			<p>This finishes the implementation of the plugin. To compile the plugin, create a build description in the <strong class="source-inline">CMakeLists.txt</strong> file. The plugin lives outside the clang source tree, so you need to set up a complete project. You can do so by following <span class="No-Break">these steps:</span></p>&#13;
			<ol>&#13;
				<li>Begin by defining the required <strong class="bold">CMake</strong> version and the name of <span class="No-Break">the project:</span><pre class="source-code">&#13;
cmake_minimum_required(VERSION 3.20.0)&#13;
project(naminglugin)</pre></li>				<li>Next, include the LLVM files. If CMake can’t find the files automatically, then you have to set the <strong class="source-inline">LLVM_DIR</strong> variable so that it points to the LLVM directory containing the <span class="No-Break">CMake files:</span><pre class="source-code">&#13;
find_package(LLVM REQUIRED CONFIG)</pre></li>				<li>Append the LLVM directory <a id="_idIndexMarker679"/>with the CMake files to the search path, and include some <span class="No-Break">required modules:</span><pre class="source-code">&#13;
list(APPEND CMAKE_MODULE_PATH ${LLVM_DIR})&#13;
include(AddLLVM)&#13;
include(HandleLLVMOptions)</pre></li>				<li>Then, load the CMake definitions for clang. If CMake can’t find the files automatically, then you have to set the <strong class="source-inline">Clang_DIR</strong> variable so that it points to the clang directory containing the <span class="No-Break">CMake files:</span><pre class="source-code">&#13;
find_package(Clang REQUIRED)</pre></li>				<li>Next, define where the headers files and the library files are located, and which definitions <span class="No-Break">to use:</span><pre class="source-code">&#13;
include_directories("${LLVM_INCLUDE_DIR}"&#13;
                    "${CLANG_INCLUDE_DIRS}")&#13;
add_definitions("${LLVM_DEFINITIONS}")&#13;
link_directories("${LLVM_LIBRARY_DIR}")</pre></li>				<li>The previous definitions set up the build environment. Insert the following command, which defines the name of your plugin, the source file(s) of the plugin, and that it is a <span class="No-Break">clang plugin:</span><pre class="source-code">&#13;
add_llvm_library(NamingPlugin MODULE NamingPlugin.cpp&#13;
                 PLUGIN_TOOL clang)</pre><p class="list-inset">On <strong class="bold">Windows</strong>, the plugin support is different from <strong class="bold">Unix</strong>, and the required LLVM and clang libraries must be linked in. The following code <span class="No-Break">ensures this:</span></p><pre class="source-code">if(WIN32 OR CYGWIN)&#13;
  set(LLVM_LINK_COMPONENTS Support)&#13;
  clang_target_link_libraries(NamingPlugin PRIVATE&#13;
    clangAST clangBasic clangFrontend clangLex)&#13;
endif()</pre></li>			</ol>&#13;
			<p>Now, we can configure and<a id="_idIndexMarker680"/> build the plugin, assuming that the <strong class="source-inline">CMAKE_GENERATOR</strong> and <strong class="source-inline">CMAKE_BUILD_TYPE</strong> environment variables <span class="No-Break">are set:</span></p>&#13;
			<pre class="console">&#13;
$ cmake -DLLVM_DIR=~/LLVM/llvm-17/lib/cmake/llvm \&#13;
        -DClang_DIR=~/LLVM/llvm-17/lib/cmake/clang \&#13;
        -B build&#13;
$ cmake --build build</pre>			<p>These steps create the <strong class="source-inline">NamingPlugin.so</strong> shared library in the <span class="No-Break"><strong class="source-inline">build</strong></span><span class="No-Break"> directory.</span></p>&#13;
			<p>To test the plugin, save the following source as the <strong class="source-inline">naming.c</strong> file. The function name, <strong class="source-inline">Func1</strong>, violates the naming rule, but not the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> name:</span></p>&#13;
			<pre class="source-code">&#13;
int Func1() { return 0; }&#13;
int main() { return Func1(); }</pre>			<p>To invoke the plugin, you need to specify the <strong class="source-inline">–</strong><span class="No-Break"><strong class="source-inline">fplugin=</strong></span><span class="No-Break"> option:</span></p>&#13;
			<pre class="console">&#13;
$ clang -fplugin=build/NamingPlugin.so naming.c&#13;
naming.c:1:5: warning: Function name should start with lowercase letter&#13;
int Func1() { return 0; }&#13;
    ^&#13;
1 warning generated.</pre>			<p>This kind of invocation requires that you override the <strong class="source-inline">getActionType()</strong> method of the <strong class="source-inline">PluginASTAction</strong> class and that you return a value different from the <strong class="source-inline">Cmdline</strong> <span class="No-Break">default value.</span></p>&#13;
			<p>If you did not do this – for example, because you want to have more control over the invocation of the plugin action – then you can run the plugin from the compiler <span class="No-Break">command line:</span></p>&#13;
			<pre class="console">&#13;
$ clang -cc1 -load ./NamingPlugin.so -plugin naming-plugin\&#13;
  naming.c</pre>			<p>Congratulations – you have built your first <span class="No-Break">clang plugin!</span></p>&#13;
			<p>The disadvantage of this approach is that it has certain limitations. The <strong class="source-inline">ASTConsumer</strong> class has different entry methods, but they are all coarse-grained. This can be solved by using the <strong class="source-inline">RecursiveASTVisitor</strong> class. This class traverses all AST nodes, and you can override the <strong class="source-inline">VisitXXX()</strong> methods<a id="_idIndexMarker681"/> you are interested in. You can rewrite the plugin so that it uses the visitor by following <span class="No-Break">these steps:</span></p>&#13;
			<ol>&#13;
				<li>You need an additional <strong class="source-inline">include</strong> for the definition of the <strong class="source-inline">RecursiveASTVisitor</strong> class. Insert it <span class="No-Break">as follows:</span><pre class="source-code">&#13;
#include "clang/AST/RecursiveASTVisitor.h"</pre></li>				<li>Then, define the visitor as the first class in the anonymous namespace. You will only store a reference to the AST context, which will give you access to all the important methods for AST manipulation, including the <strong class="source-inline">DiagnosticsEngine</strong> instance, which is required for emitting <span class="No-Break">the warning:</span><pre class="source-code">&#13;
class NamingVisitor&#13;
    : public RecursiveASTVisitor&lt;NamingVisitor&gt; {&#13;
private:&#13;
  ASTContext &amp;ASTCtx;&#13;
public:&#13;
  explicit NamingVisitor(CompilerInstance &amp;CI)&#13;
      : ASTCtx(CI.getASTContext()) {}</pre></li>				<li>During traversal, the <strong class="source-inline">VisitFunctionDecl()</strong> method is called whenever a function declaration is<a id="_idIndexMarker682"/> discovered. Copy the body of the inner loop inside the <strong class="source-inline">HandleTopLevelDecl()</strong> <span class="No-Break">function here:</span><pre class="source-code">&#13;
  virtual bool VisitFunctionDecl(FunctionDecl *FD) {&#13;
    std::string Name =&#13;
        FD-&gt;getNameInfo().getName().getAsString();&#13;
    assert(Name.length() &gt; 0 &amp;&amp;&#13;
           "Unexpected empty identifier");&#13;
    char &amp;First = Name.at(0);&#13;
    if (!(First &gt;= 'a' &amp;&amp; First &lt;= 'z')) {&#13;
      DiagnosticsEngine &amp;Diag = ASTCtx.getDiagnostics();&#13;
      unsigned ID = Diag.getCustomDiagID(&#13;
          DiagnosticsEngine::Warning,&#13;
          "Function name should start with "&#13;
          "lowercase letter");&#13;
      Diag.Report(FD-&gt;getLocation(), ID);&#13;
    }&#13;
    return true;&#13;
  }&#13;
};</pre></li>				<li>This finishes the visitor’s implementation. In your <strong class="source-inline">NamingASTConsumer</strong> class, you will now only store a <span class="No-Break">visitor instance:</span><pre class="source-code">&#13;
  std::unique_ptr&lt;NamingVisitor&gt; Visitor;&#13;
public:&#13;
  NamingASTConsumer(CompilerInstance &amp;CI)&#13;
      : Visitor(std::make_unique&lt;NamingVisitor&gt;(CI)) {}</pre></li>				<li>Remove the <strong class="source-inline">HandleTopLevelDecl()</strong> method – the functionality is now in the visitor class, so you’ll need to override the <strong class="source-inline">HandleTranslationUnit()</strong> method instead. This class is called once for each translation unit. You will start the AST <span class="No-Break">traversal here:</span><pre class="source-code">&#13;
  void&#13;
  HandleTranslationUnit(ASTContext &amp;ASTCtx) override {&#13;
    Visitor-&gt;TraverseDecl(&#13;
        ASTCtx.getTranslationUnitDecl());&#13;
  }</pre></li>			</ol>&#13;
			<p>This new implementation has the same functionality. The advantage is that it is easier to extend. For example, if you want to examine variable declarations, then you must implement the <strong class="source-inline">VisitVarDecl()</strong> method. Alternatively, if you want to work with a statement, then you must implement the <strong class="source-inline">VisitStmt()</strong> method. With this approach, you have a visitor method for each entity of the C, C++, and Objective <span class="No-Break">C languages.</span></p>&#13;
			<p>Having access to the AST allows you to build plugins that perform complex tasks. Enforcing naming conventions, as described in this section, is a useful addition to clang. Another useful addition you <a id="_idIndexMarker683"/>could implement as a plugin is the calculation of a software metric <a id="_idIndexMarker684"/>such as <strong class="bold">cyclomatic complexity</strong>. You can also add or replace AST nodes, allowing you, for example, to add runtime instrumentation. Adding plugins allows you to extend clang in the way you <span class="No-Break">need it.</span></p>&#13;
			<h1 id="_idParaDest-168"><a id="_idTextAnchor175"/>Summary</h1>&#13;
			<p>In this chapter, you learned how to apply various sanitizers. You detected pointer errors with the <strong class="source-inline">address</strong> sanitizer, uninitialized memory access with the <strong class="source-inline">memory</strong> sanitizer, and performed data races with the <strong class="source-inline">thread</strong> sanitizer. Application errors are often triggered by malformed input, and you implemented fuzz testing to test your application with <span class="No-Break">random data.</span></p>&#13;
			<p>You also instrumented your application with XRay to identify the performance bottlenecks, and you also learned about the various ways you can visualize the data. This chapter also taught you how to utilize the clang static analyzer for identifying potential errors by interpreting the source code, and how to create your own <span class="No-Break">clang plugin.</span></p>&#13;
			<p>These skills will help you raise the quality of the applications you build as it is certainly good to find runtime errors before your application users complain about them. Applying the knowledge you’ve gained in this chapter, you can not only find a wide range of common errors, but you can also extend clang with <span class="No-Break">new functionality.</span></p>&#13;
			<p>In the next chapter, you will learn how to add a new backend <span class="No-Break">to LLVM.</span></p>&#13;
		</div>&#13;
	</div></body></html>