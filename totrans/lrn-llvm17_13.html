<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-155" class="chapter-number"><a id="_idTextAnchor159"/>10</h1>&#13;
			<h1 id="_idParaDest-156"><a id="_idTextAnchor160"/>Debugging Using LLVM Tools</h1>&#13;
			<p>LLVM comes with a set of tools that helps you identify certain errors in your application. All these tools make use of the LLVM<a id="_idIndexMarker584"/> and <strong class="bold">clang</strong> libraries.</p>&#13;
			<p>In this chapter, you will learn how to instrument an application <a id="_idIndexMarker585"/>with <strong class="bold">sanitizers</strong>, as well as how to use the most common sanitizer to identify a wide range of bugs, after which you’ll implement fuzz testing for your application. This will help you identify bugs that are usually not found with unit testing. You will also learn how to identify performance bottlenecks in your application, run <a id="_idIndexMarker586"/>the <strong class="bold">static analyzer</strong> to identify problems normally not found by the compiler, and create your own clang-based tool, in which you can extend clang with new functionality.</p>&#13;
			<p>This chapter will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Instrumenting an application with sanitizers</li>&#13;
				<li>Finding bugs with <strong class="bold">libFuzzer</strong></li>&#13;
				<li>Performance profiling with <strong class="bold">XRay</strong></li>&#13;
				<li>Checking the source with the <strong class="bold">Clang </strong><strong class="bold">Static Analyzer</strong></li>&#13;
				<li>Creating your own clang-based tool</li>&#13;
			</ul>&#13;
			<p>By the end of this chapter, you will know how to use the various LLVM and clang tools to identify a large category of errors in an application. You will also acquire the knowledge to extend clang with new functionality, for example, to enforce naming conventions or to add new source analysis.</p>&#13;
			<h1 id="_idParaDest-157"><a id="_idTextAnchor161"/>Technical requirements</h1>&#13;
			<p>To create the <strong class="bold">flame graph</strong> in the <em class="italic">Performance profiling with XRay</em> section, you need to install the scripts from <a href="https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a>. Some systems, such as <strong class="bold">Fedora</strong> and <strong class="bold">FreeBSD</strong>, provide a package for these scripts, which you can also use.</p>&#13;
			<p>To view the <strong class="bold">Chrome visualization</strong> in the same section, you need to have the <strong class="bold">Chrome</strong> browser installed. You can download the browser from <a href="https://www.google.com/chrome/">https://www.google.com/chrome/</a> or use the package manager of your system to install <strong class="bold">Chrome</strong> browser.</p>&#13;
			<p>Additionally, to run the static analyzer via the <code>scan-build</code> script, you need to have the <code>perl-core</code> package installed on <strong class="bold">Fedora</strong> and <strong class="bold">Ubuntu</strong>.</p>&#13;
			<h1 id="_idParaDest-158"><a id="_idTextAnchor162"/>Instrumenting an application with sanitizers</h1>&#13;
			<p>LLVM comes with a<a id="_idIndexMarker587"/> couple of <code>compiler-rt</code> project. The sanitizers can be enabled in clang, which makes them very comfortable to use. To build the <code>compiler-rt</code> project, we can simply add the <code>-DLLVM_ENABLE_RUNTIMES=compiler-rt</code> CMake variable to the initial CMake configuration step when building LLVM.</p>&#13;
			<p>In the following sections, we will look at the <code>address</code>, <code>memory</code>, and <code>thread</code> sanitizers. First, we’ll look at the <code>address</code> sanitizer.</p>&#13;
			<h2 id="_idParaDest-159"><a id="_idTextAnchor163"/>Detecting memory access problems with the address sanitizer</h2>&#13;
			<p>You can use<a id="_idIndexMarker590"/> the <code>address</code> sanitizer <a id="_idIndexMarker591"/>to detect different types of memory access bugs within an application. This includes common errors such as using dynamically allocated memory after freeing it or writing to dynamically allocated memory outside the boundaries of the allocated memory.</p>&#13;
			<p>When enabled, the <code>address</code> sanitizer replaces calls to the <code>malloc()</code> and <code>free()</code> functions with its own version and instruments all memory accesses with a checking guard. Of course, this adds a lot of overhead to the application, and you will only use the <code>address</code> sanitizer during the testing phase of the application. If you are interested in the implementation details, then you can find the source of the pass in the <code>llvm/lib/Transforms/Instrumentation/AddressSanitzer.cpp</code> file and a description of the implemented algorithm at <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm">https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm</a>.</p>&#13;
			<p>Let’s run a short example to show the capabilities of the <code>address</code> sanitizer!</p>&#13;
			<p>The following example application, <code>outofbounds.c</code>, allocates <code>12</code> bytes of memory, but initializes <code>14</code> bytes:</p>&#13;
			<pre class="source-code">&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;string.h&gt;&#13;
int main(int argc, char *argv[]) {&#13;
  char *p = malloc(12);&#13;
  memset(p, 0, 14);&#13;
  return (int)*p;&#13;
}</pre>			<p>You can compile and run<a id="_idIndexMarker592"/> this <a id="_idIndexMarker593"/>application without noticing a problem as this behavior is typical for this kind of error. Even in larger applications, such kinds of bugs can go unnoticed for a long time. However, if you enable the <code>address</code> sanitizer with the <code>-fsanitize=address</code> option, then the application stops after detecting the error.</p>&#13;
			<p>It is also useful to enable debug symbols with the <code>–g</code> options because it helps identify the location of the error in the source. The following code is an example of how to compile the source file with the <code>address</code> sanitizer and debug symbols enabled:</p>&#13;
			<pre class="console">&#13;
$ clang -fsanitize=address -g outofbounds.c -o outofbounds</pre>			<p>Now, you get a lengthy error report when running the application:</p>&#13;
			<pre class="console">&#13;
$ ./outofbounds&#13;
==============================================================&#13;
==1067==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000001c at pc 0x00000023a6ef bp 0x7fffffffeb10 sp 0x7fffffffe2d8&#13;
WRITE of size 14 at 0x60200000001c thread T0&#13;
    #0 0x23a6ee in __asan_memset /usr/src/contrib/llvm-project/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:26:3&#13;
    #1 0x2b2a03 in main /home/kai/sanitizers/outofbounds.c:6:3&#13;
    #2 0x23331f in _start /usr/src/lib/csu/amd64/crt1.c:76:7</pre>			<p>The report also contains detailed information about the memory content. The important information is the type of the error – <code>outofbounds.c</code> file, which is the line containing the call to <code>memset()</code>. This is the exact place where the buffer overflow happens.</p>&#13;
			<p>If you replace the line containing <code>memset(p, 0, 14);</code> in the <code>outofbounds.c</code> file with the following<a id="_idIndexMarker595"/> code, then <a id="_idIndexMarker596"/>you can introduce access to memory once you’ve freed the memory. You’ll need to store the source in the <code>useafterfree.c</code> file:</p>&#13;
			<pre class="source-code">&#13;
  memset(p, 0, 12);&#13;
  free(p);</pre>			<p>Again, if you compile and run it, the sanitizer detects the use of the pointer after the memory is freed:</p>&#13;
			<pre class="console">&#13;
$ clang -fsanitize=address -g useafterfree.c -o useafterfree&#13;
$ ./useafterfree&#13;
==============================================================&#13;
==1118==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000010 at pc 0x0000002b2a5c bp 0x7fffffffeb00 sp 0x7fffffffeaf8&#13;
READ of size 1 at 0x602000000010 thread T0&#13;
    #0 0x2b2a5b in main /home/kai/sanitizers/useafterfree.c:8:15&#13;
    #1 0x23331f in _start /usr/src/lib/csu/amd64/crt1.c:76:7</pre>			<p>This time, the report points to <em class="italic">line 8</em>, which contains dereferencing of the <code>p</code> pointer.</p>&#13;
			<p>On <code>ASAN_OPTIONS</code> environment variable to <code>detect_leaks=1</code> before running the application, then you also get a report about memory leaks.</p>&#13;
			<p>On the command line, you can do this as follows:</p>&#13;
			<pre class="console">&#13;
$ ASAN_OPTIONS=detect_leaks=1 ./useafterfree</pre>			<p>The <code>address</code> sanitizer is very useful because it catches a category of bugs that are otherwise difficult<a id="_idIndexMarker599"/> to <a id="_idIndexMarker600"/>detect. The <code>memory</code> sanitizer does a similar task. We’ll examine its use cases in the next section.</p>&#13;
			<h2 id="_idParaDest-160"><a id="_idTextAnchor164"/>Finding uninitialized memory accesses with the memory sanitizer</h2>&#13;
			<p>Using uninitialized memory is<a id="_idIndexMarker601"/> another <a id="_idIndexMarker602"/>category of bugs that are hard to find. In <strong class="bold">C</strong> and <strong class="bold">C++</strong>, the general<a id="_idIndexMarker603"/> memory <a id="_idIndexMarker604"/>allocation routines do not initialize the memory buffer with a default value. The same is true for automatic variables on the stack.</p>&#13;
			<p>There are lots of opportunities for errors, and the memory sanitizer helps find these bugs. If you are interested in the implementation details, you can find the source for the memory sanitizer pass in the <code>llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp</code> file. The comment at the top of the file explains the ideas behind the implementation.</p>&#13;
			<p>Let’s run a small example and save the following source as the <code>memory.c</code> file. Note that the <code>x</code> variable is not initialized and is used as a <code>return</code> value:</p>&#13;
			<pre class="source-code">&#13;
int main(int argc, char *argv[]) {&#13;
  int x;&#13;
  return x;&#13;
}</pre>			<p>Without the sanitizer, the application will run just fine. However, you will get an error report if you use the <code>-</code><code>fsanitize=memory</code> option:</p>&#13;
			<pre class="console">&#13;
$ clang -fsanitize=memory -g memory.c -o memory&#13;
$ ./memory&#13;
==1206==WARNING: MemorySanitizer: use-of-uninitialized-value&#13;
    #0 0x10a8f49 in main /home/kai/sanitizers/memory.c:3:3&#13;
    #1 0x1053481 in _start /usr/src/lib/csu/amd64/crt1.c:76:7&#13;
SUMMARY: MemorySanitizer: use-of-uninitialized-value /home/kai/sanitizers/memory.c:3:3 in main&#13;
Exiting</pre>			<p>Like the <code>address</code> sanitizer, the memory sanitizer stops the application at the first error that’s found. As<a id="_idIndexMarker605"/> shown <a id="_idIndexMarker606"/>here the memory sanitizer provides a <strong class="bold">use of initialized </strong><strong class="bold">value</strong> warning.</p>&#13;
			<p>Finally, in the next section, we’ll look at how we can use the <code>thread</code> sanitizer to detect data races in multi-threaded applications.</p>&#13;
			<h2 id="_idParaDest-161"><a id="_idTextAnchor165"/>Pointing out data races with the thread sanitizer</h2>&#13;
			<p>To leverage the<a id="_idIndexMarker607"/> power of modern CPUs, applications<a id="_idIndexMarker608"/> now use multiple threads. This is a powerful technique, but it also introduces new sources of errors. A very common problem in multi-threaded applications is that the access to global data is not protected, for <a id="_idIndexMarker609"/>example, with<a id="_idIndexMarker610"/> a <code>thread</code> sanitizer can detect data races in <code>llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp</code> file.</p>&#13;
			<p>To demonstrate the functionality of the <code>thread</code> sanitizer, we will create a very simple producer-consumer-style application. The producer thread increments a global variable, while the consumer thread decrements the same variable. Access to the global variable is not protected, so this is a data race.</p>&#13;
			<p>You’ll need to save<a id="_idIndexMarker612"/> the<a id="_idIndexMarker613"/> following source in the <code>thread.c</code> file:</p>&#13;
			<pre class="source-code">&#13;
#include &lt;pthread.h&gt;&#13;
int data = 0;&#13;
void *producer(void *x) {&#13;
  for (int i = 0; i &lt; 10000; ++i) ++data;&#13;
  return x;&#13;
}&#13;
void *consumer(void *x) {&#13;
  for (int i = 0; i &lt; 10000; ++i) --data;&#13;
  return x;&#13;
}&#13;
int main() {&#13;
  pthread_t t1, t2;&#13;
  pthread_create(&amp;t1, NULL, producer, NULL);&#13;
  pthread_create(&amp;t2, NULL, consumer, NULL);&#13;
  pthread_join(t1, NULL);&#13;
  pthread_join(t2, NULL);&#13;
  return data;&#13;
}</pre>			<p>In the preceding code, the <code>data</code> variable is shared between two threads. Here, it is of the <code>int</code> type to make the example simple since often, a data structure such as the <code>std::vector</code> class or similar would be used. Furthermore, these two threads run the <code>producer()</code> and <code>consumer()</code> functions.</p>&#13;
			<p>The <code>producer()</code> function only increments the <code>data</code> variable, while the <code>consumer()</code> function decrements it. No access protection is implemented, so this constitutes a data race. The <code>main()</code> function starts both threads with the <code>pthread_create()</code> function, waits for the end of the threads with the <code>pthread_join()</code> function, and returns the current value of the <code>data</code> variable.</p>&#13;
			<p>If you compile and run this application, then you will note no error – that is, the return value is always zero. An error – in this case, a return value not equal to zero – will appear if the number of loops that are performed is increased by a factor of 100. At this point, you will begin to notice other values appear.</p>&#13;
			<p>We can use the <code>thread</code> sanitizer to identify the data race within our program. To compile with the <code>thread</code> sanitizer enabled, you’ll need to pass the <code>-fsanitize=thread</code> option to clang. Adding debug symbols with the <code>–g</code> options gives you line numbers in the <a id="_idIndexMarker614"/>report, which <a id="_idIndexMarker615"/>is also helpful. Note that you also need to link the <code>pthread</code> library:</p>&#13;
			<pre class="console">&#13;
$ clang -fsanitize=thread -g thread.c -o thread -lpthread&#13;
$ ./thread&#13;
==================&#13;
WARNING: ThreadSanitizer: data race (pid=1474)&#13;
  Write of size 4 at 0x000000cdf8f8 by thread T2:&#13;
    #0 consumer /home/kai/sanitizers/thread.c:11:35 (thread+0x2b0fb2)&#13;
  Previous write of size 4 at 0x000000cdf8f8 by thread T1:&#13;
    #0 producer /home/kai/sanitizers/thread.c:6:35 (thread+0x2b0f22)&#13;
  Location is global 'data' of size 4 at 0x000000cdf8f8 (thread+0x000000cdf8f8)&#13;
  Thread T2 (tid=100437, running) created by main thread at:&#13;
    #0 pthread_create /usr/src/contrib/llvm-project/compiler-rt/lib/tsan/rtl/tsan_interceptors_posix.cpp:962:3 (thread+0x271703)&#13;
    #1 main /home/kai/sanitizers/thread.c:18:3 (thread+0x2b1040)&#13;
  Thread T1 (tid=100436, finished) created by main thread at:&#13;
    #0 pthread_create /usr/src/contrib/llvm-project/compiler-rt/lib/tsan/rtl/tsan_interceptors_posix.cpp:962:3 (thread+0x271703)&#13;
    #1 main /home/kai/sanitizers/thread.c:17:3 (thread+0x2b1021)&#13;
SUMMARY: ThreadSanitizer: data race /home/kai/sanitizers/thread.c:11:35 in consumer&#13;
==================&#13;
ThreadSanitizer: reported 1 warnings</pre>			<p>The report points us to <em class="italic">lines 6</em> and <em class="italic">11</em> of the source file, where the global variable is accessed. It also <a id="_idIndexMarker616"/>shows <a id="_idIndexMarker617"/>that two threads named <em class="italic">T1</em> and <em class="italic">T2</em> accessed the variable and the file and line number of the respective calls to the <code>pthread_create()</code> function.</p>&#13;
			<p>With that, we’ve learned how to use three different types of sanitizers to identify common problems in applications. The <code>address</code> sanitizer helps us identify common memory access errors, such as out-of-bounds accesses or using memory after it’s been freed. Using the <code>memory</code> sanitizer, we can find access to uninitialized memory, and the <code>thread</code> sanitizer helps <a id="_idIndexMarker618"/>us <a id="_idIndexMarker619"/>identify data races.</p>&#13;
			<p>In the next section, we’ll try to trigger the sanitizers by running our application on random data. This process is known as <strong class="bold">fuzz testing</strong>.</p>&#13;
			<h1 id="_idParaDest-162"><a id="_idTextAnchor166"/>Finding bugs with libFuzzer</h1>&#13;
			<p>To test your application, you’ll need to <a id="_idIndexMarker620"/>write <strong class="bold">unit tests</strong>. This is a great way to make sure <a id="_idIndexMarker621"/>your software behaves correctly and as you might expect. However, because of the exponential number of possible inputs, you’ll probably miss certain weird inputs, and a few bugs as well.</p>&#13;
			<p><strong class="bold">Fuzz testing</strong> can help<a id="_idIndexMarker622"/> here. The idea is to present your application with randomly generated data, or data based on valid input but with random changes. This is done repeatedly, so your application is tested with a large number of inputs, which is why fuzz testing can be a powerful testing approach. It has been noted that fuzz testing has assisted in finding hundreds of bugs within web browsers and other software.</p>&#13;
			<p>Interestingly, LLVM comes with its own fuzz testing library. Originally part of the LLVM core libraries, the <code>compiler-rt</code>. The library is designed to test small and fast functions.</p>&#13;
			<p>Let’s run a small example to see how libFuzzer works. First, you will need to provide the <code>LLVMFuzzerTestOneInput()</code> function. This function is called by the <strong class="bold">fuzzer driver</strong> and provides <a id="_idIndexMarker623"/>you with some input. The following function counts consecutive ASCII digits in the input. Once it’s done that, we’ll feed random input to it.</p>&#13;
			<p>You’ll need to save the example in the <code>fuzzer.c</code> file:</p>&#13;
			<pre class="source-code">&#13;
#include &lt;stdint.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
int count(const uint8_t *Data, size_t Size) {&#13;
  int cnt = 0;&#13;
  if (Size)&#13;
    while (Data[cnt] &gt;= '0' &amp;&amp; Data[cnt] &lt;= '9') ++cnt;&#13;
  return cnt;&#13;
}&#13;
int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {&#13;
  count(Data, Size);&#13;
  return 0;&#13;
}</pre>			<p>In the preceding code, the <code>count()</code> function counts the number of digits in the memory pointed to by the <code>Data</code> variable. The size of the data is only checked to determine if there are any bytes available. Inside the <code>while</code> loop, the size is not checked.</p>&#13;
			<p>Used with <a id="_idIndexMarker624"/>normal <code>0</code> byte. The <code>LLVMFuzzerTestOneInput()</code> function is the so-called <code>0</code>, which is currently the only allowed value.</p>&#13;
			<p>To compile the file with libFuzzer, you must add the <code>-fsanitize=fuzzer</code> option. The recommendation is to also enable the <code>address</code> sanitizer and the generation of debug symbols. We can use the following command to compile the <code>fuzzer.c</code> file:</p>&#13;
			<pre class="console">&#13;
$ clang -fsanitize=fuzzer,address -g fuzzer.c -o fuzzer</pre>			<p>When you run the test, it emits a lengthy report. The report contains more information than a stack trace, so let’s have a closer look at it:</p>&#13;
			<ol>&#13;
				<li>The first line tells you the seed that was used to initialize the random number generator. You can use the <code>–seed=</code> option to repeat this execution:<pre class="source-code">&#13;
INFO: Seed: 1297394926</pre></li>				<li>By default, libFuzzer limits inputs to, at most, <code>4096</code> bytes. You can change the default by using the <code>–</code><code>max_len=</code> option:<pre class="source-code">&#13;
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes</pre></li>				<li>Now, we can run the test without providing sample input. The set of all sample inputs is called <code>corpus</code>, and it is empty for this run:<pre class="source-code">&#13;
INFO: A corpus is not provided, starting from an empty corpus</pre></li>				<li>Some information about the generated test data will follow. It shows you that <code>28</code> inputs were tried and <code>6</code> inputs, which together have a length of <code>19</code> bytes, were found, which together cover <code>6</code> coverage points or basic blocks:<pre class="source-code">&#13;
#28     NEW    cov: 6 ft: 9 corp: 6/19b lim: 4 exec/s: 0 rss: 29Mb L: 4/4 MS: 4 CopyPart-PersAutoDict-CopyPart-ChangeByte- DE: "1\x00"-</pre></li>				<li>After this, a buffer overflow was detected, and it followed the information from the <code>address</code> sanitizer. Lastly, the report tells you where the input causing the buffer overflow is saved:<pre class="source-code">&#13;
artifact_prefix='./'; Test unit written to ./crash-17ba0791499db908433b80f37c5fbc89b870084b</pre></li>			</ol>&#13;
			<p>With the saved <a id="_idIndexMarker627"/>input, the test case can be executed with the same crashing input again:</p>&#13;
			<pre class="console">&#13;
$ ./fuzzer crash-17ba0791499db908433b80f37c5fbc89b870084b</pre>			<p>This helps identify the problem as we can use the saved input as a direct reproducer to fix whatever problems that may arise. However, only using random data is often not very helpful in every situation. If you try to fuzz test the <code>tinylang</code> lexer or parser, then pure random data leads to immediate rejection of the input because no valid token can be found.</p>&#13;
			<p>In such cases, it is more useful to provide a small set of valid input, called the corpus. In this situation, the files of the corpus are randomly mutated and used as input. You can think of the input as mostly valid, with just a few bits flipped. This also works great with other input, which must have a certain format. For example, for a library that processes <code>corpus</code>.</p>&#13;
			<p>An example of providing the corpus looks like this. You can save the corpus files in one or more directories and you can create a simple corpus for our fuzz test with the help of the <code>printf</code> command:</p>&#13;
			<pre class="console">&#13;
$ mkdir corpus&#13;
$ printf "012345\0" &gt;corpus/12345.txt&#13;
$ printf "987\0" &gt;corpus/987.txt</pre>			<p>When running the test, you must provide the directory on the command line:</p>&#13;
			<pre class="console">&#13;
$ ./fuzzer corpus/</pre>			<p>The corpus is then used as the base for generating random input, as the report tells you:</p>&#13;
			<pre class="console">&#13;
INFO: seed corpus: files: 2 min: 4b max: 7b total: 11b rss: 29Mb</pre>			<p>Furthermore, if you are testing a function that works on tokens or other magic values, such as a programming language, then you can speed up the process by providing a dictionary with the tokens. For a programming language, the dictionary would contain all the keywords and special symbols used in the language. Moreover, the dictionary definitions follow a simple key-value style. For example, to define the <code>if</code> keyword in the dictionary, you can add the following:</p>&#13;
			<pre class="source-code">&#13;
kw1="if"</pre>			<p>However, the key is optional, and you can leave it out. Now, you can specify the dictionary file on the<a id="_idIndexMarker628"/> command line with the <code>–</code><code>dict=</code> option.</p>&#13;
			<p>Now that we’ve covered using libFuzzer to find bugs, let’s look at the limitations and alternatives for the libFuzzer implementation.</p>&#13;
			<h2 id="_idParaDest-163"><a id="_idTextAnchor167"/>Limitations and alternatives</h2>&#13;
			<p>The libFuzzer implementation<a id="_idIndexMarker629"/> is fast but poses several restrictions on the test target. They are as follows:</p>&#13;
			<ul>&#13;
				<li>The function under <code>test</code> must accept the input as an array in memory. Some library functions require a file path to the data instead, and they cannot be tested with libFuzzer.</li>&#13;
				<li>The <code>exit()</code> function should not be called.</li>&#13;
				<li>The global state should not be altered.</li>&#13;
				<li>Hardware random number generators should not be used.</li>&#13;
			</ul>&#13;
			<p>The first two restrictions are an implication of the implementation of libFuzzer as a library. The latter two restrictions are needed to avoid confusion in the evaluation algorithm. If one of these restrictions is not met, then two identical calls to the fuzz target can yield different results.</p>&#13;
			<p>The best-known alternative tool for fuzz testing is <strong class="bold">AFL</strong>, which can be found at <a href="https://github.com/google/AFL">https://github.com/google/AFL</a>. AFL requires an instrumented binary (an LLVM plugin for instrumentation is provided) and requires the application to take the input as a file path on the command line. AFL and libFuzzer can share the same corpus and the same dictionary files. Thus, it is possible to test an application with both tools. Furthermore, where libFuzzer is not applicable, AFL may be a good alternative.</p>&#13;
			<p>There are many more ways of influencing the way libFuzzer works. You can read the reference <a id="_idIndexMarker630"/>page at <a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a> for more details.</p>&#13;
			<p>In the next section, we look at a different problem an application can have – we’ll try to identify performance bottlenecks while using the XRay tool.</p>&#13;
			<h1 id="_idParaDest-164"><a id="_idTextAnchor168"/>Performance profiling with XRay</h1>&#13;
			<p>If your application <a id="_idIndexMarker631"/>seems to run slow, then you might want to know where the time is spent in the code. Here, instrumenting the code with <code>llvm/lib/XRay/</code> directory. The runtime portion is part of <code>compiler-rt</code>.</p>&#13;
			<p>In the following example source, real work is simulated by calling the <code>usleep()</code> function. The <code>func1()</code> function sleeps for 10 µs. The <code>func2()</code> function calls <code>func1()</code> or sleeps for 100 µs, depending on if the <code>n</code> parameter is odd or even. Inside the <code>main()</code> function, both functions are called inside a loop. This is already enough to get interesting information. You’ll need to save the following source code in the <code>xraydemo.c</code> file:</p>&#13;
			<pre class="source-code">&#13;
#include &lt;unistd.h&gt;&#13;
void func1() { usleep(10); }&#13;
void func2(int n) {&#13;
  if (n % 2) func1();&#13;
  else usleep(100);&#13;
}&#13;
int main(int argc, char *argv[]) {&#13;
  for (int i = 0; i &lt; 100; i++) { func1(); func2(i); }&#13;
  return 0;&#13;
}</pre>			<p>To enable the XRay instrumentation during compilation, you will need to specify the <code>-fxray-instrument</code> option. It is worth noting that functions with less than 200 instructions are not instrumented. This is because this is an arbitrary threshold defined by the developers, and<a id="_idIndexMarker632"/> in our case, the functions would not be instrumented. The threshold can be specified with the <code>-</code><code>fxray-instruction-threshold=</code> option.</p>&#13;
			<p>Alternatively, we can add a function attribute to control if a function should be instrumented. For example, adding the following prototype would result in us always instrumenting the function:</p>&#13;
			<pre class="source-code">&#13;
void func1() __attribute__((xray_always_instrument));</pre>			<p>Likewise, by using the <code>xray_never_instrument</code> attribute, you can turn off instrumentation for a function.</p>&#13;
			<p>We will now use the command-line option and compile the <code>xraydemo.c</code> file, as follows:</p>&#13;
			<pre class="console">&#13;
$ clang -fxray-instrument -fxray-instruction-threshold=1 -g\&#13;
  xraydemo.c -o xraydemo</pre>			<p>In the resulting binary, instrumentation is turned off by default. If you run the binary, you will note no difference compared to a non-instrumented binary. The <code>XRAY_OPTIONS</code> environment variable is used to control the recording of runtime data. To enable data collection, you can run the application as follows:</p>&#13;
			<pre class="console">&#13;
$ XRAY_OPTIONS="patch_premain=true xray_mode=xray-basic"\&#13;
  ./xraydemo</pre>			<p>The <code>xray_mode=xray-basic</code> option tells the runtime that we want to use basic mode. In this mode, all runtime data is collected, which can result in large log files. When the <code>patch_premain=true</code> option is given, functions that are run before the <code>main()</code> function are also instrumented.</p>&#13;
			<p>After running this command, a new file will be created in the directory, in which the collected data is stored. You will need to<a id="_idIndexMarker633"/> use the <strong class="bold">llvm-xray</strong> tool to extract any readable information from this file.</p>&#13;
			<p>The llvm-xray tool supports<a id="_idIndexMarker634"/> various sub-commands. First of all, you can use the <code>account</code> sub-command to extract some basic statistics. For example, to get the top 10 most called functions, you can add the <code>-top=10</code> option to limit the output, and the <code>-sort=count</code> option to specify the function call count as the sort criteria. You can also influence the sort order with the <code>-</code><code>sortorder=</code> option.</p>&#13;
			<p>The following commands can be run to get the statistics from our program:</p>&#13;
			<pre class="console">&#13;
$ llvm-xray account xray-log.xraydemo.xVsWiE --sort=count\&#13;
  --sortorder=dsc --instr_map ./xraydemo&#13;
Functions with latencies: 3&#13;
   funcid      count        sum  function&#13;
        1        150   0.166002  demo.c:4:0: func1&#13;
        2        100   0.543103  demo.c:9:0: func2&#13;
        3          1   0.655643  demo.c:17:0: main</pre>			<p>As you can see, the <code>func1()</code> function is called most often; you can also see the accumulated time spent in this function. This example only has three functions, so the <code>–top=</code> option has no visible effect here, but for real applications, it is very useful.</p>&#13;
			<p>From the collected data, it is possible to reconstruct all the stack frames that occurred during runtime. You use the <code>stack</code> sub-command to view the top 10 stacks. The output shown here has been <a id="_idIndexMarker635"/>reduced for brevity:</p>&#13;
			<pre class="console">&#13;
$ llvm-xray stack xray-log.xraydemo.xVsWiE –instr_map\&#13;
  ./xraydemo&#13;
Unique Stacks: 3&#13;
Top 10 Stacks by leaf sum:&#13;
Sum: 1325516912&#13;
lvl   function              count              sum&#13;
#0    main                      1       1777862705&#13;
#1    func2                    50       1325516912&#13;
Top 10 Stacks by leaf count:&#13;
Count: 100&#13;
lvl   function              count              sum&#13;
#0    main                      1       1777862705&#13;
#1    func1                   100        303596276</pre>			<p>A <code>func2()</code> function is called by the <code>main()</code> function, and this is the stack frame with the largest accumulated time. The depth depends on how many functions are called, and the stack frames are usually large.</p>&#13;
			<p>This sub-command can also be used to <a id="_idIndexMarker637"/>create a <code>flamegraph.pl</code> script, you can convert the data into a <strong class="bold">scalable vector graphics</strong> (<strong class="bold">SVG</strong>) file that <a id="_idIndexMarker638"/>you can view in your browser.</p>&#13;
			<p>With the following command, you instruct <code>llvm-xray</code> to output all stack frames with the <code>–all-stacks</code> option. Using the <code>–stack-format=flame</code> option, the output is in the format expected by the <code>flamegraph.pl</code> script. Moreover, with the <code>–aggregation-type</code> option, you can choose if stack frames are aggregated by total time or by the number of invocations. The output of <code>llvm-xray</code> is piped into the <code>flamegraph.pl</code> script, and the resulting output is saved in the <code>flame.svg</code> file:</p>&#13;
			<pre class="console">&#13;
$ llvm-xray stack xray-log.xraydemo.xVsWiE --all-stacks\&#13;
  --stack-format=flame --aggregation-type=time\&#13;
  --instr_map ./xraydemo | flamegraph.pl &gt;flame.svg</pre>			<p>After running the command and generating the new flame graph, you can open the generated <code>flame.svg</code> file in your browser. The graphic looks as follows:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B19561_10_1.jpg" alt="Figure 10.1 – Flame graph produced by llvm-xray" width="1001" height="216"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Flame graph produced by llvm-xray</p>&#13;
			<p>Flame graphs can be <a id="_idIndexMarker639"/>confusing at first glance because the <em class="italic">X</em>-axis does not have the usual meaning of elapsed time. Instead, the functions are simply sorted alphabetically by name. Furthermore, the <em class="italic">Y</em>-axis of the flame graph shows the stack depth, where the bottom begins counting from zero. The colors are chosen to have a good contrast and have no other meaning. From the preceding graph, you can easily determine the call hierarchy and the time spent in a function.</p>&#13;
			<p>Information about a stack frame is displayed only after you move the mouse cursor over the rectangle representing the frame. By clicking on the frame, you can zoom into this stack frame. Flame graphs are of great help if you want to identify functions worth optimizing. To find out more about flame graphs, please visit the website of Brendan Gregg, the inventor of flame graphs: <a href="http://www.brendangregg.com/flamegraphs.html">http://www.brendangregg.com/flamegraphs.html</a>.</p>&#13;
			<p>Additionally, you can use the <code>convert</code> subcommand to convert the data into <code>.yaml</code> format or the format used<a id="_idIndexMarker640"/> by the <code>xray.evt</code> file, you can run the following command:</p>&#13;
			<pre class="console">&#13;
$ llvm-xray convert --output-format=trace_event\&#13;
  --output=xray.evt --symbolize --sort\&#13;
  --instr_map=./xraydemo xray-log.xraydemo.xVsWiE</pre>			<p>If you do not specify the <code>–symbolize</code> option, then no function names are shown in the resulting graph.</p>&#13;
			<p>Once you’ve done<a id="_idIndexMarker641"/> that, open Chrome and type <code>chrome:///tracing</code>. Next, click on the <code>xray.evt</code> file. You will see the following visualization of the data:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B19561_10_2.jpg" alt="Figure 10.2 – Chrome Trace Viewer Visualization generated by llvm-xray" width="1042" height="467"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Chrome Trace Viewer Visualization generated by llvm-xray</p>&#13;
			<p>In this view, the stack frames are sorted by the time the function call occurs. For further interpretation of the visualization, please read the tutorial at <a href="https://www.chromium.org/developers/how-tos/trace-event-profiling-tool">https://www.chromium.org/developers/how-tos/trace-event-profiling-tool</a>.</p>&#13;
			<p class="callout-heading">Tip</p>&#13;
			<p class="callout">The llvm-xray tool has more functionality that is applicable for performance profiling. You can read about it on the LLVM website at <a href="https://llvm.org/docs/XRay.html">https://llvm.org/docs/XRay.html</a> and <a href="https://llvm.org/docs/XRayExample.html">https://llvm.org/docs/XRayExample.html</a>.</p>&#13;
			<p>In this section, we learned how to instrument an application with XRay, how to collect runtime information, and how to visualize that data. We can use this knowledge to find performance<a id="_idIndexMarker642"/> bottlenecks in applications.</p>&#13;
			<p>Another approach to identifying errors in an application is to analyze the so<a id="_idTextAnchor169"/>urce code, which is done with the clang static analyzer.</p>&#13;
			<h1 id="_idParaDest-165"><a id="_idTextAnchor170"/>Checking the source with the clang static analyzer</h1>&#13;
			<p>The <strong class="bold">clang static analyzer</strong> is a tool <a id="_idIndexMarker643"/>that performs additional <a id="_idIndexMarker644"/>checks <a id="_idIndexMarker645"/>on C, C++, and <strong class="bold">Objective C</strong> source<a id="_idIndexMarker646"/> code. The checks that are performed by the static analyzer are more thorough than the checks the compiler performs. They are also more costly in terms of time and required resources. The static analyzer has a set of checkers, which check for certain bugs.</p>&#13;
			<p>The tool performs a symbolic interpretation of the source code, which looks at all code paths through an application and derives constraints on the values used in the application from it. <strong class="bold">Symbolic interpretation</strong> is a <a id="_idIndexMarker647"/>common technique that’s used in compilers, for example, to identify constant values. In the context of the static analyzer, the checkers are applied to the derived values.</p>&#13;
			<p>For example, if the divisor of a division is zero, then the static analyzer warns us about it. We can check this with the following example stored in the <code>div.c</code> file:</p>&#13;
			<pre class="source-code">&#13;
int divbyzero(int a, int b) { return a / b; }&#13;
int bug() { return divbyzero(5, 0); }</pre>			<p>The static analyzer will warn about a division by <code>0</code> in this example. However, when compiling, the file, when compiled with the <code>clang -Wall -c div.c</code> command, will show no warning.</p>&#13;
			<p>There are two ways to invoke the static analyzer from the command line. The older tool is <code>scan-build</code> tool is the easiest solution. You simply pass the <code>compile</code> command to the tool; everything else is done automatically:</p>&#13;
			<pre class="console">&#13;
$ scan-build clang -c div.c&#13;
scan-build: Using '/usr/home/kai/LLVM/llvm-17/bin/clang-17' for static analysis&#13;
div.c:2:12: warning: Division by zero [core.DivideZero]&#13;
  return a / b;&#13;
         ~~^~~&#13;
1 warning generated.&#13;
scan-build: Analysis run complete.&#13;
scan-build: 1 bug found.&#13;
scan-build: Run 'scan-view /tmp/scan-build-2021-03-01-023401-8721-1' to examine bug reports.</pre>			<p>The output on the <a id="_idIndexMarker650"/>screen<a id="_idIndexMarker651"/> already tells you that a problem was found – that is, the <code>core.DivideZero</code> checker was triggered. However, that is not all. You will find a complete report in HTML in the mentioned subdirectory of the <code>/tmp</code> directory. You can then use the <code>scan-view</code> command to view the report or open the <code>index.html</code> file found in the subdirectory in your browser.</p>&#13;
			<p>The first page of the report shows you a summary of the bugs that were found:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B19561_10_3.jpg" alt="Figure 10.3 – Summary page" width="737" height="522"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Summary page</p>&#13;
			<p>For each error that <a id="_idIndexMarker652"/>was <a id="_idIndexMarker653"/>found, the summary page shows the type of the error, the location in the source, and the path length after which the analyzer found the error. A link to a detailed report for the error is also provided.</p>&#13;
			<p>The following screenshot shows the detailed report for the error:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B19561_10_4.jpg" alt="Figure 10.4 – Detailed report" width="577" height="640"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Detailed report</p>&#13;
			<p>With this detailed report, you can verify the error by following the numbered bubbles. Our simple example shows how passing <code>0</code> as a parameter value leads to a division by zero error.</p>&#13;
			<p>Thus, human verification is required. If the derived constraints are not precise enough for a certain checker, then false positives are possible – that is, an error is reported for perfectly fine code. Based<a id="_idIndexMarker654"/> on the report, you can use <a id="_idIndexMarker655"/>them to identify false positives.</p>&#13;
			<p>You are not limited to checkers that are provided with the tool – you can a<a id="_idTextAnchor171"/>lso add new checkers. The next section demonstrates how to do this.</p>&#13;
			<h2 id="_idParaDest-166"><a id="_idTextAnchor172"/>Adding a new checker to the clang static analyzer</h2>&#13;
			<p>Many C libraries provide<a id="_idIndexMarker656"/> functions that must be used in pairs. For example, the C standard library provides the <code>malloc()</code> and <code>free()</code> functions. The memory that’s allocated by <code>malloc()</code> function must be freed exactly one time by the <code>free()</code> function. Not calling the <code>free()</code> function, or calling it several times, is a programming error. There are many more instances of this coding pattern, and the static analyzer provides checkers for some of them.</p>&#13;
			<p>The <code>iconv_open()</code> and <code>iconv_close()</code> functions, which must be used in pairs, similar to the memory management functions. No checker is implemented for those functions, so let’s implement one.</p>&#13;
			<p>To add a new checker to the clang static analyzer, you must create a new subclass of the <code>Checker</code> class. The static analyzer tries all possible paths through the code. The analyzer engine generates events at certain points – for example, before or after a function call. Moreover, your class must provide callbacks for these events if you need to handle them. The <code>Checker</code> class and the registrations for the events are provided in the <code>clang/include/clang/StaticAnalyzer/Core/Checker.h</code> header file.</p>&#13;
			<p>Usually, a checker needs to track some symbols. However, the checker cannot manage the state because it does not know which code path the analyzer engine currently tries. Therefore, the tracked state must be registered with the engine, and can only be changed using a <code>ProgramStateRef</code> instance.</p>&#13;
			<p>To detect the errors, the checker needs to track the descriptor that’s returned from the <code>iconv_open()</code> function. The analyzer engine returns a <code>SymbolRef</code> instance for the return value of the <code>iconv_open()</code> function. We associate this symbol with a state to reflect if <code>iconv_close()</code> was called or not. For the state, we create the <code>IconvState</code> class, which encapsulates a <code>bool</code> value.</p>&#13;
			<p>The new <code>IconvChecker</code> class needs to handle four types of events:</p>&#13;
			<ul>&#13;
				<li><code>PostCall</code>, which occurs after a function call. After the <code>iconv_open()</code> function was called, we retrieved the symbol for the return value and remembered it as being in an “opened” state.</li>&#13;
				<li><code>PreCall</code>, which occurs before a function call. Before the <code>iconv_close()</code> function is called, we check if the symbol for the descriptor is in an “opened” state. If not, then the <code>iconv_close()</code> function was already called for the descriptor, and we have detected a double call to the function.</li>&#13;
				<li><code>DeadSymbols</code>, which occurs when unused symbols are cleaned up. We check if an unused symbol for a descriptor is still in an “opened” state. If it is, then we have detected a missing call to <code>iconv_close()</code>, which is a resource leak.</li>&#13;
				<li><code>PointerEscape</code>, which is called when the symbols can no longer be tracked by the analyzer. In this case, we remove the symbol from the state because we can no longer reason about whether the descriptor was closed or not.</li>&#13;
			</ul>&#13;
			<p>We can create a new <a id="_idIndexMarker658"/>directory to implement the<a id="_idTextAnchor173"/> new checker as a clang plugin, and add the implementations within the <code>IconvChecker.cpp</code> file:</p>&#13;
			<ol>&#13;
				<li>For the implementation, we need to include several header files. The <code>include</code> file, <code>BugType.h</code> is required for emitting reports. The header file, <code>Checker.h</code>, provides the declaration of the <code>Checker</code> class and the callbacks for the events, which are declared in the <code>CallEvent</code> file Moreover, the <code>CallDescription.h</code> file helps with matching functions and methods. Finally, the <code>CheckerContext.h</code> file is required for declaring the <code>CheckerContext</code> class, which is the central class that provides access to the state of the analyzer:<pre class="source-code">&#13;
#include "clang/StaticAnalyzer/Core/BugReporter/BugType.h"&#13;
#include "clang/StaticAnalyzer/Core/Checker.h"&#13;
#include "clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h"&#13;
#include "clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h"&#13;
#include "clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h"&#13;
#include "clang/StaticAnalyzer/Frontend/CheckerRegistry.h"&#13;
#include &lt;optional&gt;</pre></li>				<li>To avoid typing<a id="_idIndexMarker659"/> the namespace names, we can use the <code>clang</code> and <code>ento</code> namespaces:<pre class="source-code">&#13;
using namespace clang;&#13;
using namespace ento;</pre></li>				<li>We associate a state with each symbol representing an iconv descriptor. The state can be open or closed, and we use a <code>bool</code> typed variable, with <code>true</code> value for the open state. The state value is encapsulated in the <code>IconvState</code> struct. This struct is used with a <code>FoldingSet</code> data structure, which is a hash set that filters duplicate entries. To be usable with this data structure implementation, the <code>Profile()</code> method is added here, which sets the unique bits of this struct. We put the struct into an anonymous namespace to avoid polluting the global namespace. Instead of exposing the <code>bool</code> value, the class provides the <code>getOpened()</code> and <code>getClosed()</code> factory methods and the <code>isOpen()</code> query method:<pre class="source-code">&#13;
namespace {&#13;
class IconvState {&#13;
  const bool IsOpen;&#13;
  IconvState(bool IsOpen) : IsOpen(IsOpen) {}&#13;
public:&#13;
  bool isOpen() const { return IsOpen; }&#13;
  static IconvState getOpened() {&#13;
    return IconvState(true);&#13;
  }&#13;
  static IconvState getClosed() {&#13;
    return IconvState(false);&#13;
  }&#13;
  bool operator==(const IconvState &amp;O) const {&#13;
    return IsOpen == O.IsOpen;&#13;
  }&#13;
  void Profile(llvm::FoldingSetNodeID &amp;ID) const {&#13;
    ID.AddInteger(IsOpen);&#13;
  }&#13;
};&#13;
} // namespace</pre></li>				<li>The <code>IconvState</code> struct <a id="_idIndexMarker660"/>represents the state of an iconv descriptor, which is represented by a symbol of the <code>SymbolRef</code> class. This is best done with a map, which has the symbol as the key and the state as the value. As explained earlier, the checker cannot hold the state. Instead, the state must be registered with the global program state, which is done with the <code>REGISTER_MAP_WITH_PROGRAMSTATE</code> macro. This macro introduces the <code>IconvStateMap</code> name, which we will use later to access the map:<pre class="source-code">&#13;
REGISTER_MAP_WITH_PROGRAMSTATE(IconvStateMap, SymbolRef,&#13;
                               IconvState)</pre></li>				<li>We also implement the <code>IconvChecker</code> class in an anonymous namespace. The requested <code>PostCall</code>, <code>PreCall</code>, <code>DeadSymbols</code>, and <code>PointerEscape</code> events are template parameters to the <code>Checker</code> base class:<pre class="source-code">&#13;
namespace {&#13;
class IconvChecker&#13;
    : public Checker&lt;check::PostCall, check::PreCall,&#13;
                     check::DeadSymbols,&#13;
                     check::PointerEscape&gt; {</pre></li>				<li>The <code>IconvChecker</code> class<a id="_idIndexMarker661"/> has fields of the <code>CallDescription</code> type, which are used to identify function calls to <code>iconv_open()</code>, <code>iconv()</code>, and <code>iconv_close()</code>in the program:<pre class="source-code">&#13;
  CallDescription IconvOpenFn, IconvFn, IconvCloseFn;</pre></li>				<li>The class also holds references to the detected bug types:<pre class="source-code">&#13;
  std::unique_ptr&lt;BugType&gt; DoubleCloseBugType;&#13;
  std::unique_ptr&lt;BugType&gt; LeakBugType;</pre></li>				<li>Finally, the class has a couple of methods. Besides the constructor and the methods for the call events, we also need a method to emit a bug report:<pre class="source-code">&#13;
  void report(ArrayRef&lt;SymbolRef&gt; Syms,&#13;
              const BugType &amp;Bug, StringRef Desc,&#13;
              CheckerContext &amp;C, ExplodedNode *ErrNode,&#13;
              std::optional&lt;SourceRange&gt; Range =&#13;
                  std::nullopt) const;&#13;
public:&#13;
  IconvChecker();&#13;
  void checkPostCall(const CallEvent &amp;Call,&#13;
                     CheckerContext &amp;C) const;&#13;
  void checkPreCall(const CallEvent &amp;Call,&#13;
                    CheckerContext &amp;C) const;&#13;
  void checkDeadSymbols(SymbolReaper &amp;SymReaper,&#13;
                        CheckerContext &amp;C) const;&#13;
  ProgramStateRef&#13;
  checkPointerEscape(ProgramStateRef State,&#13;
                     const InvalidatedSymbols &amp;Escaped,&#13;
                     const CallEvent *Call,&#13;
                     PointerEscapeKind Kind) const;&#13;
};&#13;
} // namespace</pre></li>				<li>The implementation of the <a id="_idIndexMarker662"/>constructor of the <code>IconvChecker</code> class initializes the <code>CallDescription</code> fields using the name of the functions, and creates the objects representing the bug types:<pre class="source-code">&#13;
IconvChecker::IconvChecker()&#13;
    : IconvOpenFn({"iconv_open"}), IconvFn({"iconv"}),&#13;
      IconvCloseFn({"iconv_close"}, 1) {&#13;
  DoubleCloseBugType.reset(new BugType(&#13;
      this, "Double iconv_close", "Iconv API Error"));&#13;
  LeakBugType.reset(new BugType(&#13;
      this, "Resource Leak", "Iconv API Error",&#13;
      /*SuppressOnSink=*/true));&#13;
}</pre></li>				<li>Now, we can implement the first call event method, <code>checkPostCall()</code>. This method is called after the analyzer has executed a function call. If the executed function is not a global C function and not named <code>iconv_open</code>, then there is nothing to do:<pre class="source-code">&#13;
void IconvChecker::checkPostCall(&#13;
    const CallEvent &amp;Call, CheckerContext &amp;C) const {&#13;
  if (!Call.isGlobalCFunction())&#13;
    return;&#13;
  if (!IconvOpenFn.matches(Call))&#13;
    return;</pre></li>				<li>Otherwise, we can<a id="_idIndexMarker663"/> try to get the return value of the function as a symbol. To store the symbol with the open state in the global program state, we need to get a <code>ProgramStateRef</code> instance from the <code>CheckerContext</code> instance. The state is immutable, so adding the symbol to the state results in a new state. Finally, the analyzer engine is informed about the new state with a call to the <code>addTransition()</code> method:<pre class="source-code">&#13;
  if (SymbolRef Handle =&#13;
          Call.getReturnValue().getAsSymbol()) {&#13;
    ProgramStateRef State = C.getState();&#13;
    State = State-&gt;set&lt;IconvStateMap&gt;(&#13;
        Handle, IconvState::getOpened());&#13;
    C.addTransition(State);&#13;
  }&#13;
}</pre></li>				<li>Likewise, the <code>checkPreCall()</code> method is called before the analyzer executes a function. Only a global C function called <code>iconv_close</code> is of interest to us:<pre class="source-code">&#13;
void IconvChecker::checkPreCall(&#13;
    const CallEvent &amp;Call, CheckerContext &amp;C) const {&#13;
  if (!Call.isGlobalCFunction()) {&#13;
    return;&#13;
  }&#13;
  if (!IconvCloseFn.matches(Call)) {&#13;
    return;&#13;
  }</pre></li>				<li>If the symbol for <a id="_idIndexMarker664"/>the first argument of the function, which is the iconv descriptor, is known, then we can retrieve the state of the symbol from the program state:<pre class="source-code">&#13;
  if (SymbolRef Handle =&#13;
          Call.getArgSVal(0).getAsSymbol()) {&#13;
    ProgramStateRef State = C.getState();&#13;
    if (const IconvState *St =&#13;
            State-&gt;get&lt;IconvStateMap&gt;(Handle)) {</pre></li>				<li>If the state represents the closed state, then we have detected a double close error, and we can generate a bug report for it. The call to <code>generateErrorNode()</code> can return a <code>nullptr</code> value if an error report was already generated for this path, so we have to check for this situation:<pre class="source-code">&#13;
      if (!St-&gt;isOpen()) {&#13;
        if (ExplodedNode *N = C.generateErrorNode()) {&#13;
          report(Handle, *DoubleCloseBugType,&#13;
                 "Closing a previous closed iconv "&#13;
                 "descriptor",&#13;
                 C, N, Call.getSourceRange());&#13;
        }&#13;
        return;&#13;
      }&#13;
    }</pre></li>				<li>Otherwise, we must set the state for the symbol to the “closed” state:<pre class="source-code">&#13;
    State = State-&gt;set&lt;IconvStateMap&gt;(&#13;
        Handle, IconvState::getClosed());&#13;
    C.addTransition(State);&#13;
  }&#13;
}</pre></li>				<li>The <code>checkDeadSymbols()</code> method is <a id="_idIndexMarker665"/>called to clean up unused symbols. We loop over all symbols we track and ask the <code>SymbolReaper</code> instance if the current symbol is dead:<pre class="source-code">&#13;
void IconvChecker::checkDeadSymbols(&#13;
    SymbolReaper &amp;SymReaper, CheckerContext &amp;C) const {&#13;
  ProgramStateRef State = C.getState();&#13;
  SmallVector&lt;SymbolRef, 8&gt; LeakedSyms;&#13;
  for (auto [Sym, St] : State-&gt;get&lt;IconvStateMap&gt;()) {&#13;
    if (SymReaper.isDead(Sym)) {</pre></li>				<li>If the symbol is dead, then we need to check the state. If the state is still open, then this is a potential resource leak. There is one exception: <code>iconv_open()</code> returns <code>-1</code> in case of an error. If the analyzer is in a code path that handles this error, then it is wrong to assume a resource leak because the function call failed. We try to get the value of the symbol from the <code>ConstraintManager</code> instance, and we do not consider the symbol as a resource leak if this value is <code>-1</code>. We add a leaked symbol to a <code>SmallVector</code> instance to generate the error report later. Finally, we <a id="_idIndexMarker666"/>remove the dead symbol from the program state:<pre class="source-code">&#13;
      if (St.isOpen()) {&#13;
        bool IsLeaked = true;&#13;
        if (const llvm::APSInt *Val =&#13;
                State-&gt;getConstraintManager().getSymVal(&#13;
                    State, Sym))&#13;
          IsLeaked = Val-&gt;getExtValue() != -1;&#13;
        if (IsLeaked)&#13;
          LeakedSyms.push_back(Sym);&#13;
      }&#13;
      State = State-&gt;remove&lt;IconvStateMap&gt;(Sym);&#13;
    }&#13;
  }</pre></li>				<li>After the loop, we call the <code>generateNonFatalErrorNode()</code> method. This method transitions to the new program state and returns an error node if there is not already an error node for this path. The <code>LeakedSyms</code> container holds the (possibly empty) list of leaked symbols, and we call the <code>report()</code> method to generate an error report:<pre class="source-code">&#13;
  if (ExplodedNode *N =&#13;
          C.generateNonFatalErrorNode(State)) {&#13;
    report(LeakedSyms, *LeakBugType,&#13;
           "Opened iconv descriptor not closed", C, N);&#13;
  }&#13;
}</pre></li>				<li>The <code>checkPointerEscape()</code> function is called when the analyzer detects a function call for which the parameters cannot be tracked. In such a case, we must assume that we do not know if the iconv descriptor will be closed inside the function or not. The exceptions are a call to <code>iconv()</code>, which does the conversion and is known to not call the <code>iconv_close()</code> function, and the <code>iconv_close()</code> function itself, which we handle in the <code>checkPreCall()</code> method. We also do not change the state if the call is inside a system header file, and if we know that the arguments do not escape in the called function. In all other cases, we<a id="_idIndexMarker667"/> remove the symbol from the state:<pre class="source-code">&#13;
ProgramStateRef IconvChecker::checkPointerEscape(&#13;
    ProgramStateRef State,&#13;
    const InvalidatedSymbols &amp;Escaped,&#13;
    const CallEvent *Call,&#13;
    PointerEscapeKind Kind) const {&#13;
  if (Kind == PSK_DirectEscapeOnCall) {&#13;
    if (IconvFn.matches(*Call) ||&#13;
        IconvCloseFn.matches(*Call))&#13;
      return State;&#13;
    if (Call-&gt;isInSystemHeader() ||&#13;
        !Call-&gt;argumentsMayEscape())&#13;
      return State;&#13;
  }&#13;
  for (SymbolRef Sym : Escaped)&#13;
    State = State-&gt;remove&lt;IconvStateMap&gt;(Sym);&#13;
  return State;&#13;
}</pre></li>				<li>The <code>report()</code> method generates an error report. The important parameters of the method are an array of symbols, the type of the bug, and a bug description. Inside the method, a bug report is created for each symbol, and the symbol is marked as the interesting one for the bug. If a source range is provided as a parameter, then<a id="_idIndexMarker668"/> this is also added to the report. Finally, the report is emitted:<pre class="source-code">&#13;
void IconvChecker::report(&#13;
    ArrayRef&lt;SymbolRef&gt; Syms, const BugType &amp;Bug,&#13;
    StringRef Desc, CheckerContext &amp;C,&#13;
    ExplodedNode *ErrNode,&#13;
    std::optional&lt;SourceRange&gt; Range) const {&#13;
  for (SymbolRef Sym : Syms) {&#13;
    auto R = std::make_unique&lt;PathSensitiveBugReport&gt;(&#13;
        Bug, Desc, ErrNode);&#13;
    R-&gt;markInteresting(Sym);&#13;
    if (Range)&#13;
      R-&gt;addRange(*Range);&#13;
    C.emitReport(std::move(R));&#13;
  }&#13;
}</pre></li>				<li>Now, the new checker needs to be registered at a <code>CheckerRegistry</code> instance. When our plugin is loaded, the <code>clang_registerCheckers()</code> function is used, in which we perform the registration. Each checker has a name and belongs to a package. We call the <code>IconvChecker</code> checker and put it into the <code>unix</code> packager because the iconv library is a standard POSIX interface. This is the first parameter of the <code>addChecker()</code> method. The second parameter is a brief documentation of the functionality, and the third parameter can be a URI to a document that provides more information about the checker:<pre class="source-code">&#13;
extern "C" void&#13;
clang_registerCheckers(CheckerRegistry &amp;registry) {&#13;
  registry.addChecker&lt;IconvChecker&gt;(&#13;
      "unix.IconvChecker",&#13;
      "Check handling of iconv functions", "");&#13;
}</pre></li>				<li>Finally, we need to declare the version of the static analyzer API we are using, which enables the<a id="_idIndexMarker669"/> system to determine if the plugin is compatible:<pre class="source-code">&#13;
extern "C" const char clang_analyzerAPIVersionString[] =&#13;
    CLANG_ANALYZER_API_VERSION_STRING;</pre><p class="list-inset">This finishes the implementation of the new checker. To build the plugin, we also need to create a build description in the <code>CMakeLists.txt</code> file which lives in the same directory as <code>IconvChecker.cpp</code>:</p></li>				<li>Begin by defining the<a id="_idIndexMarker670"/> required <strong class="bold">CMake</strong> version and the name of the project:<pre class="source-code">&#13;
cmake_minimum_required(VERSION 3.20.0)&#13;
project(iconvchecker)</pre></li>				<li>Next, include the LLVM files. If CMake can’t find the files automatically, then you have to set the <code>LLVM_DIR</code> variable so that it points to the LLVM directory containing the CMake files:<pre class="source-code">&#13;
find_package(LLVM REQUIRED CONFIG)</pre></li>				<li>Append the LLVM directory with the CMake files to the search path, and include the required modules from LLVM:<pre class="source-code">&#13;
list(APPEND CMAKE_MODULE_PATH ${LLVM_DIR})&#13;
include(AddLLVM)&#13;
include(HandleLLVMOptions)</pre></li>				<li>Then, load the CMake definitions for clang. If CMake can’t find the files automatically, then you have to set the <code>Clang_DIR</code> variable so that it points to the clang directory containing the CMake files:<pre class="source-code">&#13;
find_package(Clang REQUIRED)</pre></li>				<li>Next, append the Clang directory with the CMake files to the search path, and include the required modules from Clang:<pre class="source-code">&#13;
list(APPEND CMAKE_MODULE_PATH ${Clang_DIR})&#13;
include(AddClang)</pre></li>				<li>Then, define where the <a id="_idIndexMarker671"/>header files and the library files are located, and which definitions to use:<pre class="source-code">&#13;
include_directories("${LLVM_INCLUDE_DIR}"&#13;
                    "${CLANG_INCLUDE_DIRS}")&#13;
add_definitions("${LLVM_DEFINITIONS}")&#13;
link_directories("${LLVM_LIBRARY_DIR}")</pre></li>				<li>The previous definitions set up the build environment. Insert the following command, which defines the name of your plugin, the source file(s) of the plugin, and that it is a clang plugin:<pre class="source-code">&#13;
add_llvm_library(IconvChecker MODULE IconvChecker.cpp&#13;
                 PLUGIN_TOOL clang)</pre></li>				<li>On <strong class="bold">Windows</strong>, the plugin support is different from <strong class="bold">Unix</strong>, and the required LLVM and clang libraries must be linked in. The following code ensures this:<pre class="source-code">&#13;
if(WIN32 OR CYGWIN)&#13;
  set(LLVM_LINK_COMPONENTS Support)&#13;
  clang_target_link_libraries(IconvChecker PRIVATE&#13;
    clangAnalysis&#13;
    clangAST&#13;
    clangStaticAnalyzerCore&#13;
    clangStaticAnalyzerFrontend)&#13;
endif()</pre></li>			</ol>&#13;
			<p>Now, we can configure and build the plugin, assuming that the <code>CMAKE_GENERATOR</code> and <code>CMAKE_BUILD_TYPE</code> environment variables are set:</p>&#13;
			<pre class="console">&#13;
$ cmake -DLLVM_DIR=~/LLVM/llvm-17/lib/cmake/llvm \&#13;
        -DClang_DIR=~/LLVM/llvm-17/lib/cmake/clang \&#13;
        -B build&#13;
$ cmake --build build</pre>			<p>You can test the new checker with the following source saved in the <code>conv.c</code> file, which has two calls to <a id="_idIndexMarker672"/>the <code>iconv_close()</code> function:</p>&#13;
			<pre class="source-code">&#13;
#include &lt;iconv.h&gt;&#13;
void doconv() {&#13;
  iconv_t id = iconv_open("Latin1", "UTF-16");&#13;
  iconv_close(id);&#13;
  iconv_close(id);&#13;
}</pre>			<p>To use the plugin with the <code>scan-build</code> script, you need to specify the path to the plugin via the <code>-load-plugin</code> option. A run with the <code>conv.c</code> file looks like:</p>&#13;
			<pre class="console">&#13;
$ scan-build -load-plugin build/IconvChecker.so clang-17 \&#13;
             -c conv.c&#13;
scan-build: Using '/home/kai/LLVM/llvm-17/bin/clang-17' for static analysis&#13;
conv.c:6:3: warning: Closing a previous closed iconv descriptor [unix.IconvChecker]&#13;
    6 |   iconv_close(id);&#13;
      |   ^~~~~~~~~~~~~~~&#13;
1 warning generated.&#13;
scan-build: Analysis run complete.&#13;
scan-build: 1 bug found.&#13;
scan-build: Run 'scan-view /tmp/scan-build-2023-08-08-114154-12451-1' to examine bug reports.</pre>			<p>With that, you’ve learned how to extend the clang static analyzer with your own checker. You can use this knowledge to either create new general checkers and contribute them to the community or create checkers specifically built for your needs, to raise the quality of your product.</p>&#13;
			<p>The static analyzer is<a id="_idIndexMarker673"/> built by leveraging the clang infrastructure. The next section introduces you to how can build your own plugin extending clang.</p>&#13;
			<h1 id="_idParaDest-167"><a id="_idTextAnchor174"/>Creating your own clang-based tool</h1>&#13;
			<p>The static analyzer is an<a id="_idIndexMarker674"/> impressive example of what you can do with the clang infrastructure. It is also possible to extend clang with plugins so that you can add your own functionality to clang. The technique is very similar to adding a pass plugin to LLVM.</p>&#13;
			<p>Let’s explore the functionality with a simple plugin. The LLVM coding standard requires function names to begin with a lowercase letter. However, the coding standard has evolved, and there are many instances in which a function begins with an uppercase letter. A plugin that warns about a violation of the naming rule can help fix this issue, so let’s give it a try.</p>&#13;
			<p>Because you want to run a user-defined action over the AST, you need to define a subclass of the <code>PluginASTAction</code> class. If you write your own tool using the clang libraries, then you can define subclasses of the <code>ASTFrontendAction</code> class for your actions. The <code>PluginASTAction</code> class is a subclass of the <code>ASTFrontendAction</code> class, with the additional ability to parse command-line options.</p>&#13;
			<p>The other class you need is a subclass of the <code>ASTConsumer</code> class. An AST consumer is a class using which you can run an action over an AST, regardless of the origin of the AST. Nothing more is needed for our first plugin. You can create the implementation in the <code>NamingPlugin.cpp</code> file as follows:</p>&#13;
			<ol>&#13;
				<li>Begin by including the required header files. Besides the mentioned <code>ASTConsumer</code> class, you also need an instance of the compiler and the plugin registry:<pre class="source-code">&#13;
#include "clang/AST/ASTConsumer.h"&#13;
#include "clang/Frontend/CompilerInstance.h"&#13;
#include "clang/Frontend/FrontendPluginRegistry.h"</pre></li>				<li>Use the <code>clang</code> namespace and put your implementation into an anonymous <code>namespace</code> to <a id="_idIndexMarker675"/>avoid name clashes:<pre class="source-code">&#13;
using namespace clang;&#13;
namespace {</pre></li>				<li>Next, define your subclass of the <code>ASTConsumer</code> class. Later, you will want to emit warnings in case you detect a violation of the naming rule. To do so, you need a reference to a <code>DiagnosticsEngine</code> instance.</li>&#13;
				<li>You’ll need to store a <code>CompilerInstance</code> instance in the class, after which you can ask for a <code>DiagnosticsEngine</code> instance:<pre class="source-code">&#13;
class NamingASTConsumer : public ASTConsumer {&#13;
  CompilerInstance &amp;CI;&#13;
public:&#13;
  NamingASTConsumer(CompilerInstance &amp;CI) : CI(CI) {}</pre></li>				<li>An <code>ASTConsumer</code> instance has several entry methods. The <code>HandleTopLevelDecl()</code> method fits our purpose. The method is called for each declaration at the top level. This includes more than functions – for example, variables. So, you must use the LLVM RTTI <code>dyn_cast&lt;&gt;()</code> function to determine if the declaration is a function declaration. The <code>HandleTopLevelDecl()</code> method has a declaration group as a parameter, which can contain more than a single declaration. This requires a loop over the declarations. The<a id="_idIndexMarker676"/> following code shows the <code>HandleTopLevelDecl()</code> method:<pre class="source-code">&#13;
  bool HandleTopLevelDecl(DeclGroupRef DG) override {&#13;
    for (DeclGroupRef::iterator I = DG.begin(),&#13;
                                E = DG.end();&#13;
         I != E; ++I) {&#13;
      const Decl *D = *I;&#13;
      if (const FunctionDecl *FD =&#13;
              dyn_cast&lt;FunctionDecl&gt;(D)) {</pre></li>				<li>After finding a function declaration, you’ll need to retrieve the name of the function. You’ll also need to make sure that the name is not empty:<pre class="source-code">&#13;
        std::string Name =&#13;
            FD-&gt;getNameInfo().getName().getAsString();&#13;
        assert(Name.length() &gt; 0 &amp;&amp;&#13;
               "Unexpected empty identifier");</pre><p class="list-inset">If the function name does not start with a lowercase letter, then you’ll have a violation of the naming rule that was found:</p><pre class="source-code">        char &amp;First = Name.at(0);&#13;
        if (!(First &gt;= 'a' &amp;&amp; First &lt;= 'z')) {</pre></li>				<li>To emit a warning, you need a <code>DiagnosticsEngine</code> instance. Additionally, you need a message ID. Inside clang, the message ID is defined as an enumeration. Because your plugin is not part of clang, you need to create a custom ID, which you can then use to emit the warning:<pre class="source-code">&#13;
          DiagnosticsEngine &amp;Diag = CI.getDiagnostics();&#13;
          unsigned ID = Diag.getCustomDiagID(&#13;
              DiagnosticsEngine::Warning,&#13;
              "Function name should start with "&#13;
              "lowercase letter");&#13;
          Diag.Report(FD-&gt;getLocation(), ID);</pre></li>				<li>Except for closing all open braces, you need to return <code>true</code> from this function to indicate that<a id="_idIndexMarker677"/> processing can continue:<pre class="source-code">&#13;
        }&#13;
      }&#13;
    }&#13;
    return true;&#13;
  }&#13;
};</pre></li>				<li>Next, you need to create the <code>PluginASTAction</code> subclass, which implements the interface called by clang:<pre class="source-code">&#13;
class PluginNamingAction : public PluginASTAction {&#13;
public:</pre><p class="list-inset">The first method you must implement is the <code>CreateASTConsumer()</code> method, which returns an instance of your <code>NamingASTConsumer</code> class. This method is called by clang, and the passed <code>CompilerInstance</code> instance gives you access to all the important classes of the compiler. The following code demonstrates this:</p><pre class="source-code">  std::unique_ptr&lt;ASTConsumer&gt;&#13;
  CreateASTConsumer(CompilerInstance &amp;CI,&#13;
                    StringRef file) override {&#13;
    return std::make_unique&lt;NamingASTConsumer&gt;(CI);&#13;
  }</pre></li>				<li>A plugin also has access to command-line options. Your plugin has no command-line parameters, and you will only return <code>true</code> to indicate success:<pre class="source-code">&#13;
  bool ParseArgs(const CompilerInstance &amp;CI,&#13;
                 const std::vector&lt;std::string&gt; &amp;args)&#13;
                                               override {&#13;
    return true;&#13;
  }</pre></li>				<li>The action type of a plugin describes when the action is invoked. The default value is <code>Cmdline</code>, which<a id="_idIndexMarker678"/> means that the plugin must be named on the command line to be invoked. You’ll need to override the method and change the value to <code>AddAfterMainAction</code>, which automatically runs the action:<pre class="source-code">&#13;
  PluginASTAction::ActionType getActionType() override {&#13;
    return AddAfterMainAction;&#13;
  }</pre></li>				<li>The implementation of your <code>PluginNamingAction</code> class is finished; only the closing braces for the class and the anonymous namespace are missing. Add them to the code, as follows:<pre class="source-code">&#13;
};&#13;
}</pre></li>				<li>Lastly, you need to register the plugin. The first parameter is the name of the plugin, while the second parameter is help text:<pre class="source-code">&#13;
static FrontendPluginRegistry::Add&lt;PluginNamingAction&gt;&#13;
    X("naming-plugin", "naming plugin");</pre></li>			</ol>&#13;
			<p>This finishes the implementation of the plugin. To compile the plugin, create a build description in the <code>CMakeLists.txt</code> file. The plugin lives outside the clang source tree, so you need to set up a complete project. You can do so by following these steps:</p>&#13;
			<ol>&#13;
				<li>Begin by defining the required <strong class="bold">CMake</strong> version and the name of the project:<pre class="source-code">&#13;
cmake_minimum_required(VERSION 3.20.0)&#13;
project(naminglugin)</pre></li>				<li>Next, include the LLVM files. If CMake can’t find the files automatically, then you have to set the <code>LLVM_DIR</code> variable so that it points to the LLVM directory containing the CMake files:<pre class="source-code">&#13;
find_package(LLVM REQUIRED CONFIG)</pre></li>				<li>Append the LLVM directory <a id="_idIndexMarker679"/>with the CMake files to the search path, and include some required modules:<pre class="source-code">&#13;
list(APPEND CMAKE_MODULE_PATH ${LLVM_DIR})&#13;
include(AddLLVM)&#13;
include(HandleLLVMOptions)</pre></li>				<li>Then, load the CMake definitions for clang. If CMake can’t find the files automatically, then you have to set the <code>Clang_DIR</code> variable so that it points to the clang directory containing the CMake files:<pre class="source-code">&#13;
find_package(Clang REQUIRED)</pre></li>				<li>Next, define where the headers files and the library files are located, and which definitions to use:<pre class="source-code">&#13;
include_directories("${LLVM_INCLUDE_DIR}"&#13;
                    "${CLANG_INCLUDE_DIRS}")&#13;
add_definitions("${LLVM_DEFINITIONS}")&#13;
link_directories("${LLVM_LIBRARY_DIR}")</pre></li>				<li>The previous definitions set up the build environment. Insert the following command, which defines the name of your plugin, the source file(s) of the plugin, and that it is a clang plugin:<pre class="source-code">&#13;
add_llvm_library(NamingPlugin MODULE NamingPlugin.cpp&#13;
                 PLUGIN_TOOL clang)</pre><p class="list-inset">On <strong class="bold">Windows</strong>, the plugin support is different from <strong class="bold">Unix</strong>, and the required LLVM and clang libraries must be linked in. The following code ensures this:</p><pre class="source-code">if(WIN32 OR CYGWIN)&#13;
  set(LLVM_LINK_COMPONENTS Support)&#13;
  clang_target_link_libraries(NamingPlugin PRIVATE&#13;
    clangAST clangBasic clangFrontend clangLex)&#13;
endif()</pre></li>			</ol>&#13;
			<p>Now, we can configure and<a id="_idIndexMarker680"/> build the plugin, assuming that the <code>CMAKE_GENERATOR</code> and <code>CMAKE_BUILD_TYPE</code> environment variables are set:</p>&#13;
			<pre class="console">&#13;
$ cmake -DLLVM_DIR=~/LLVM/llvm-17/lib/cmake/llvm \&#13;
        -DClang_DIR=~/LLVM/llvm-17/lib/cmake/clang \&#13;
        -B build&#13;
$ cmake --build build</pre>			<p>These steps create the <code>NamingPlugin.so</code> shared library in the <code>build</code> directory.</p>&#13;
			<p>To test the plugin, save the following source as the <code>naming.c</code> file. The function name, <code>Func1</code>, violates the naming rule, but not the <code>main</code> name:</p>&#13;
			<pre class="source-code">&#13;
int Func1() { return 0; }&#13;
int main() { return Func1(); }</pre>			<p>To invoke the plugin, you need to specify the <code>–</code><code>fplugin=</code> option:</p>&#13;
			<pre class="console">&#13;
$ clang -fplugin=build/NamingPlugin.so naming.c&#13;
naming.c:1:5: warning: Function name should start with lowercase letter&#13;
int Func1() { return 0; }&#13;
    ^&#13;
1 warning generated.</pre>			<p>This kind of invocation requires that you override the <code>getActionType()</code> method of the <code>PluginASTAction</code> class and that you return a value different from the <code>Cmdline</code> default value.</p>&#13;
			<p>If you did not do this – for example, because you want to have more control over the invocation of the plugin action – then you can run the plugin from the compiler command line:</p>&#13;
			<pre class="console">&#13;
$ clang -cc1 -load ./NamingPlugin.so -plugin naming-plugin\&#13;
  naming.c</pre>			<p>Congratulations – you have built your first clang plugin!</p>&#13;
			<p>The disadvantage of this approach is that it has certain limitations. The <code>ASTConsumer</code> class has different entry methods, but they are all coarse-grained. This can be solved by using the <code>RecursiveASTVisitor</code> class. This class traverses all AST nodes, and you can override the <code>VisitXXX()</code> methods<a id="_idIndexMarker681"/> you are interested in. You can rewrite the plugin so that it uses the visitor by following these steps:</p>&#13;
			<ol>&#13;
				<li>You need an additional <code>include</code> for the definition of the <code>RecursiveASTVisitor</code> class. Insert it as follows:<pre class="source-code">&#13;
#include "clang/AST/RecursiveASTVisitor.h"</pre></li>				<li>Then, define the visitor as the first class in the anonymous namespace. You will only store a reference to the AST context, which will give you access to all the important methods for AST manipulation, including the <code>DiagnosticsEngine</code> instance, which is required for emitting the warning:<pre class="source-code">&#13;
class NamingVisitor&#13;
    : public RecursiveASTVisitor&lt;NamingVisitor&gt; {&#13;
private:&#13;
  ASTContext &amp;ASTCtx;&#13;
public:&#13;
  explicit NamingVisitor(CompilerInstance &amp;CI)&#13;
      : ASTCtx(CI.getASTContext()) {}</pre></li>				<li>During traversal, the <code>VisitFunctionDecl()</code> method is called whenever a function declaration is<a id="_idIndexMarker682"/> discovered. Copy the body of the inner loop inside the <code>HandleTopLevelDecl()</code> function here:<pre class="source-code">&#13;
  virtual bool VisitFunctionDecl(FunctionDecl *FD) {&#13;
    std::string Name =&#13;
        FD-&gt;getNameInfo().getName().getAsString();&#13;
    assert(Name.length() &gt; 0 &amp;&amp;&#13;
           "Unexpected empty identifier");&#13;
    char &amp;First = Name.at(0);&#13;
    if (!(First &gt;= 'a' &amp;&amp; First &lt;= 'z')) {&#13;
      DiagnosticsEngine &amp;Diag = ASTCtx.getDiagnostics();&#13;
      unsigned ID = Diag.getCustomDiagID(&#13;
          DiagnosticsEngine::Warning,&#13;
          "Function name should start with "&#13;
          "lowercase letter");&#13;
      Diag.Report(FD-&gt;getLocation(), ID);&#13;
    }&#13;
    return true;&#13;
  }&#13;
};</pre></li>				<li>This finishes the visitor’s implementation. In your <code>NamingASTConsumer</code> class, you will now only store a visitor instance:<pre class="source-code">&#13;
  std::unique_ptr&lt;NamingVisitor&gt; Visitor;&#13;
public:&#13;
  NamingASTConsumer(CompilerInstance &amp;CI)&#13;
      : Visitor(std::make_unique&lt;NamingVisitor&gt;(CI)) {}</pre></li>				<li>Remove the <code>HandleTopLevelDecl()</code> method – the functionality is now in the visitor class, so you’ll need to override the <code>HandleTranslationUnit()</code> method instead. This class is called once for each translation unit. You will start the AST traversal here:<pre class="source-code">&#13;
  void&#13;
  HandleTranslationUnit(ASTContext &amp;ASTCtx) override {&#13;
    Visitor-&gt;TraverseDecl(&#13;
        ASTCtx.getTranslationUnitDecl());&#13;
  }</pre></li>			</ol>&#13;
			<p>This new implementation has the same functionality. The advantage is that it is easier to extend. For example, if you want to examine variable declarations, then you must implement the <code>VisitVarDecl()</code> method. Alternatively, if you want to work with a statement, then you must implement the <code>VisitStmt()</code> method. With this approach, you have a visitor method for each entity of the C, C++, and Objective C languages.</p>&#13;
			<p>Having access to the AST allows you to build plugins that perform complex tasks. Enforcing naming conventions, as described in this section, is a useful addition to clang. Another useful addition you <a id="_idIndexMarker683"/>could implement as a plugin is the calculation of a software metric <a id="_idIndexMarker684"/>such as <strong class="bold">cyclomatic complexity</strong>. You can also add or replace AST nodes, allowing you, for example, to add runtime instrumentation. Adding plugins allows you to extend clang in the way you need it.</p>&#13;
			<h1 id="_idParaDest-168"><a id="_idTextAnchor175"/>Summary</h1>&#13;
			<p>In this chapter, you learned how to apply various sanitizers. You detected pointer errors with the <code>address</code> sanitizer, uninitialized memory access with the <code>memory</code> sanitizer, and performed data races with the <code>thread</code> sanitizer. Application errors are often triggered by malformed input, and you implemented fuzz testing to test your application with random data.</p>&#13;
			<p>You also instrumented your application with XRay to identify the performance bottlenecks, and you also learned about the various ways you can visualize the data. This chapter also taught you how to utilize the clang static analyzer for identifying potential errors by interpreting the source code, and how to create your own clang plugin.</p>&#13;
			<p>These skills will help you raise the quality of the applications you build as it is certainly good to find runtime errors before your application users complain about them. Applying the knowledge you’ve gained in this chapter, you can not only find a wide range of common errors, but you can also extend clang with new functionality.</p>&#13;
			<p>In the next chapter, you will learn how to add a new backend to LLVM.</p>&#13;
		</div>&#13;
	</div></body></html>