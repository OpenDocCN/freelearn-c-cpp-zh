<html><head></head><body>
<div id="_idContainer008">
<h1 class="chapter-number" id="_idParaDest-69"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.2.1">Identifying Ideal Candidates for Rewriting – Patterns and Anti-Patterns</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Refactoring is</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.4.1"> a crucial technique in software development that involves making changes to existing code to improve its structure, readability, and maintainability without altering its behavior. </span><span class="koboSpan" id="kobo.4.2">It is vital for </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">several reasons.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">It helps to eliminate technical debt and enhance the overall quality of the code base. </span><span class="koboSpan" id="kobo.6.2">Developers can achieve this by removing redundant or duplicate code, simplifying complex code, and improving code readability, resulting in more maintainable and </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">robust software.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">Refactoring facilitates future development. </span><span class="koboSpan" id="kobo.8.2">By restructuring code to be more modular, developers can reuse existing code more effectively, saving time and effort in future development. </span><span class="koboSpan" id="kobo.8.3">This makes code more flexible and adaptable to change, making it easier to add new features, fix bugs, and </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">optimize performance.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">Well-structured and maintainable code makes it easier for multiple developers to collaborate effectively on a project. </span><span class="koboSpan" id="kobo.10.2">Refactoring helps to standardize code practices, reduce complexity, and improve documentation, making it easier for developers to understand and contribute to a </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">Eventually, refactoring reduces costs associated with software development in the long term. </span><span class="koboSpan" id="kobo.12.2">By improving code quality and maintainability, refactoring can help to reduce the time and effort required for bug fixes, updates, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">maintenance tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">In this chapter, we will focus on identifying good candidates for refactoring in C++ projects. </span><span class="koboSpan" id="kobo.14.2">However, identifying the right code segments for refactoring can be challenging, especially in large and complex systems. </span><span class="koboSpan" id="kobo.14.3">Therefore, it is essential to understand the factors that make code segments ideal candidates for refactoring. </span><span class="koboSpan" id="kobo.14.4">In this chapter, we will explore these factors and provide guidelines for identifying good candidates for refactoring in C++. </span><span class="koboSpan" id="kobo.14.5">We will also discuss common refactoring techniques and tools that can be used to improve the quality of </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">C++ code.</span></span></p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.16.1">What kind of code is worth rewriting?</span></h1>
<p><span class="koboSpan" id="kobo.17.1">Determining whether a piece of code is worth rewriting depends on several factors, including the code’s maintainability, readability, performance, scalability, and adherence to best practices. </span><span class="koboSpan" id="kobo.17.2">Let’s look at some situations where code may be </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">worth rewriting.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.19.1">Smelly code</span></strong><span class="koboSpan" id="kobo.20.1"> is </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.21.1">often an indication that code needs to be rewritten. </span><span class="koboSpan" id="kobo.21.2">These are signs of poor design or implementation, such as long methods, large classes, duplicated code, or poor naming conventions. </span><span class="koboSpan" id="kobo.21.3">Addressing these code smells can improve the overall quality of the code base and make it easier to maintain in the </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">long run.</span></span></p>
<p><span class="koboSpan" id="kobo.23.1">Code that exhibits low cohesion or high coupling might be worth rewriting. </span><span class="koboSpan" id="kobo.23.2">Low cohesion means that the elements within a module or class are not closely related, and the module or class has too many responsibilities. </span><span class="koboSpan" id="kobo.23.3">High coupling refers to a high degree of dependency between modules or classes, making the code harder to maintain and modify. </span><span class="koboSpan" id="kobo.23.4">Refactoring such code can lead to a more modular and </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">easier-to-understand architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">In the previous chapters, we discussed the importance of SOLID principles; code that violates them can also be </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">worth rewriting.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">Another reason to rewrite code is if it relies on outdated technologies, libraries, or programming practices. </span><span class="koboSpan" id="kobo.27.2">Such code can become increasingly difficult to maintain over time and may not take advantage of newer, more efficient methods or tools. </span><span class="koboSpan" id="kobo.27.3">Updating the code to use current technologies and practices can improve its performance, security, </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">and maintainability.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">Lastly, if the code has performance or scalability issues, it may be worth rewriting. </span><span class="koboSpan" id="kobo.29.2">This can involve optimizing algorithms, data structures, or resource management to ensure that the code runs more efficiently and can handle </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">larger workloads.</span></span></p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.31.1">Smelly code and its basic characteristics</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.32.1">Smelly code</span></strong><span class="koboSpan" id="kobo.33.1">, also </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.34.1">known as </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">code smells</span></strong><span class="koboSpan" id="kobo.36.1">, refers to the symptoms in a code base that suggest underlying design or implementation issues. </span><span class="koboSpan" id="kobo.36.2">These symptoms are not necessarily bugs but are indicators of potential problems that can make the code harder to understand, maintain, and modify. </span><span class="koboSpan" id="kobo.36.3">Code smells are often the result of </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.37.1">poor coding practices or the accumulation of technical debt over time. </span><span class="koboSpan" id="kobo.37.2">Although code smells might not directly affect the functionality of a program, they can significantly impact the overall code quality, leading to an increased risk of bugs and a decrease in </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">developer productivity.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">One aspect of addressing smelly code involves identifying and applying appropriate design patterns. </span><span class="koboSpan" id="kobo.39.2">Design patterns are reusable solutions to common problems that arise in software design. </span><span class="koboSpan" id="kobo.39.3">They provide a proven framework for solving specific problems, allowing developers to build on the collective wisdom and experience of other developers. </span><span class="koboSpan" id="kobo.39.4">By applying these patterns, it is possible to refactor smelly code into a more structured, modular, and maintainable form. </span><span class="koboSpan" id="kobo.39.5">Let’s take a look at a </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">few examples.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">The </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.42.1">strategy pattern allows us to define a family of algorithms, encapsulate each one in a separate class, and make them interchangeable at runtime. </span><span class="koboSpan" id="kobo.42.2">The strategy pattern is useful for refactoring code that has multiple branches or conditions performing similar tasks with slightly </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">different implementations.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Let’s consider an example of an application that saves data using different storage strategies, such as saving to disk or a remote </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">storage service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.46.1">
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;assert&gt;
enum class StorageType {
    Disk,
    Remote
};
class DataSaver {
public:
    DataSaver(StorageType storage_type) : storage_type_(storage_type) {}
    void save_data(const std::string&amp; data) const {
        switch (storage_type_) {
            case StorageType::Disk:
                save_to_disk(data);
                break;
            case StorageType::Remote:
                save_to_remote(data);
                break;
            default:
                assert(false &amp;&amp; “Unknown storage type.”);
        }
    }
    void set_storage_type(StorageType storage_type) {
        storage_type_ = storage_type;
    }
private:
    void save_to_disk(const std::string&amp; data) const {
        // saving to disk
    }
    void save_to_remote(const std::string&amp; data) const {
        // saving data to a remote storage service.
    </span><span class="koboSpan" id="kobo.46.2">}
    StorageType storage_type_;
};
int main() {
    DataSaver disk_data_saver(StorageType::Disk);
    disk_data_saver.save_data(“Save this data to disk.”);
    DataSaver remote_data_saver(StorageType::Remote);
    remote_data_saver.save_data(“Save this data to remote storage.”);
    // Switch the storage type at runtime.
    </span><span class="koboSpan" id="kobo.46.3">disk_data_saver.set_storage_type(StorageType::Remote);
    disk_data_saver.save_data(“Save this data to remote storage after switching storage type.”);
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.47.1">In this class, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">save_data</span></strong><span class="koboSpan" id="kobo.49.1"> method checks the storage type on each call and uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">switch</span></strong><span class="koboSpan" id="kobo.51.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">case</span></strong><span class="koboSpan" id="kobo.53.1"> block to decide which saving method to use. </span><span class="koboSpan" id="kobo.53.2">This approach works, but it has </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">some drawbacks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.55.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">DataSaver</span></strong><span class="koboSpan" id="kobo.57.1"> class is responsible for handling all the different storage types, making it harder to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">and extend.</span></span></li>
<li><span class="koboSpan" id="kobo.59.1">Adding new storage types requires modifying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">DataSaver</span></strong><span class="koboSpan" id="kobo.61.1"> class and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">StorageType</span></strong><span class="koboSpan" id="kobo.63.1"> enumeration, increasing the risk of introducing bugs or breaking existing functionality. </span><span class="koboSpan" id="kobo.63.2">For example, if for some reason the wrong enum type is provided, the </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">code aborts.</span></span></li>
<li><span class="koboSpan" id="kobo.65.1">The code is less modular and flexible compared to the strategy pattern, where behaviors are encapsulated in </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">separate classes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.67.1">By</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.68.1"> implementing the strategy pattern, we can address these drawbacks and create a more maintainable, flexible, and extensible design for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">DataSaver</span></strong><span class="koboSpan" id="kobo.70.1"> class. </span><span class="koboSpan" id="kobo.70.2">First, define an interface called </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">SaveStrategy</span></strong><span class="koboSpan" id="kobo.72.1"> that represents the </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">saving behavior:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.74.1">
class SaveStrategy {
public:
    virtual ~SaveStrategy() {}
    virtual void save_data(const std::string&amp; data) const = 0;
};</span></pre>
<p><span class="koboSpan" id="kobo.75.1">Next, implement concrete </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">SaveStrategy</span></strong><span class="koboSpan" id="kobo.77.1"> classes for each </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">storage type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.79.1">
class DiskSaveStrategy : public SaveStrategy {
public:
    void save_data(const std::string&amp; data) const override {
        // ...
    </span><span class="koboSpan" id="kobo.79.2">}
};
class RemoteSaveStrategy : public SaveStrategy {
public:
    void save_data(const std::string&amp; data) const override {
        // ...
    </span><span class="koboSpan" id="kobo.79.3">}
};</span></pre>
<p><span class="koboSpan" id="kobo.80.1">Now, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">DataSaver</span></strong><span class="koboSpan" id="kobo.82.1"> class that uses the strategy pattern to delegate its saving behavior to </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.83.1">the appropriate </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">SaveStrategy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.85.1"> implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.86.1">
class DataSaver {
public:
    DataSaver(std::unique_ptr&lt;SaveStrategy&gt; save_strategy)
        : save_strategy_(std::move(save_strategy)) {}
    void save_data(const std::string&amp; data) const {
        save_strategy_-&gt;save_data(data);
    }
    void set_save_strategy(std::unique_ptr&lt;SaveStrategy&gt; save_strategy) {
        save_strategy_ = std::move(save_strategy);
    }
private:
    std::unique_ptr&lt;SaveStrategy&gt; save_strategy_;
};</span></pre>
<p><span class="koboSpan" id="kobo.87.1">Finally, here’s an</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.88.1"> example of how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">DataSaver</span></strong><span class="koboSpan" id="kobo.90.1"> class with different </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">saving strategies:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.92.1">
int main() {
    DataSaver disk_data_saver(std::make_unique&lt;DiskSaveStrategy&gt;());
    disk_data_saver.save_data(“Save this data to disk.”);
    DataSaver remote_data_saver(std::make_unique&lt;RemoteSaveStrategy&gt;());
    remote_data_saver.save_data(“Save this data to remote storage.”);
    // Switch the saving strategy at runtime.
    </span><span class="koboSpan" id="kobo.92.2">disk_data_saver.set_save_strategy(std::make_unique&lt;RemoteSaveStrategy&gt;());
    disk_data_saver.save_data(“Save this data to remote storage after switching strategy.”);
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.93.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">DataSaver</span></strong><span class="koboSpan" id="kobo.95.1"> class uses the strategy pattern to delegate its saving behavior to different </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">SaveStrategy</span></strong><span class="koboSpan" id="kobo.97.1"> implementations, allowing it to easily switch between saving to disk and saving to remote storage. </span><span class="koboSpan" id="kobo.97.2">This design makes the code more modular, maintainable, and flexible, allowing new storage strategies to be added with minimal changes to the existing code. </span><span class="koboSpan" id="kobo.97.3">Additionally, the new version of the code does not need to terminate or throw an exception on the wrong save </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">strategy type.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Let’s assume</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.100.1"> we have file parser implementations for two formats, CSV </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">and JSON:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.102.1">
class CsvParser {
public:
    void parse_file(const std::string&amp; file_path) {
        std::ifstream file(file_path);
        if (!file) {
            std::cerr &lt;&lt; “Error opening file: “ &lt;&lt; file_path &lt;&lt; std::endl;
            return;
        }
        std::string line;
        while (std::getline(file, line)) {
            process_line(line);
        }
        file.close();
        post_process();
    }
private:
    void process_line(const std::string&amp; line) {
        // Implement the CSV-specific parsing logic.
        </span><span class="koboSpan" id="kobo.102.2">std::cout &lt;&lt; “Processing CSV line: “ &lt;&lt; line &lt;&lt; std::endl;
    }
    void post_process() {
        std::cout &lt;&lt; “CSV parsing completed.” </span><span class="koboSpan" id="kobo.102.3">&lt;&lt; std::endl;
    }
};
class JsonParser {
public:
    void parse_file(const std::string&amp; file_path) {
        std::ifstream file(file_path);
        if (!file) {
            std::cerr &lt;&lt; “Error opening file: “ &lt;&lt; file_path &lt;&lt; std::endl;
            return;
        }
        std::string line;
        while (std::getline(file, line)) {
            process_line(line);
        }
        file.close();
        post_process();
    }
private:
    void process_line(const std::string&amp; line) {
        // Implement the JSON-specific parsing logic.
        </span><span class="koboSpan" id="kobo.102.4">std::cout &lt;&lt; “Processing JSON line: “ &lt;&lt; line &lt;&lt; std::endl;
    }
    void post_process() {
        std::cout &lt;&lt; “JSON parsing completed.” </span><span class="koboSpan" id="kobo.102.5">&lt;&lt; std::endl;
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.103.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">CsvParser</span></strong><span class="koboSpan" id="kobo.105.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">JsonParser</span></strong><span class="koboSpan" id="kobo.107.1"> classes have separate implementations</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.108.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">parse_file</span></strong><span class="koboSpan" id="kobo.110.1"> method that contain duplicate code for opening, reading, and closing the file. </span><span class="koboSpan" id="kobo.110.2">The format-specific parsing logic is implemented in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">process_line</span></strong><span class="koboSpan" id="kobo.112.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">post_process</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.114.1"> methods.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">While this design works, it has some drawbacks: the shared parsing steps are duplicated in both classes, making it harder to maintain and update the code, and adding support for new file formats requires creating new classes with similar code structures, which can lead to even more </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">code duplication.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">By implementing the</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.118.1"> template method pattern, you can address these drawbacks and create a more maintainable, extensible, and reusable design for the file parsers. </span><span class="koboSpan" id="kobo.118.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">FileParser</span></strong><span class="koboSpan" id="kobo.120.1"> base class handles the common parsing steps, while the derived classes implement the format-specific </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">parsing logic.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">As in the previous example, let’s start with creating an abstract base class. </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">FileParser</span></strong><span class="koboSpan" id="kobo.124.1"> represents the general file </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">parsing process:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.126.1">
class FileParser {
public:
    void parse_file(const std::string&amp; file_path) {
        std::ifstream file(file_path);
        if (!file) {
            std::cerr &lt;&lt; “Error opening file: “ &lt;&lt; file_path &lt;&lt; std::endl;
            return;
        }
        std::string line;
        while (std::getline(file, line)) {
            process_line(line);
        }
        file.close();
        post_process();
    }
protected:
    virtual void process_line(const std::string&amp; line) = 0;
    virtual void post_process() = 0;
};</span></pre>
<p><span class="koboSpan" id="kobo.127.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">FileParser</span></strong><span class="koboSpan" id="kobo.129.1"> class </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.130.1">has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">parse_file</span></strong><span class="koboSpan" id="kobo.132.1"> method that handles the common steps of opening a file, reading its content line by line, and closing the file. </span><span class="koboSpan" id="kobo.132.2">The format-specific parsing logic is implemented by the pure virtual </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">process_line</span></strong><span class="koboSpan" id="kobo.134.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">post_process</span></strong><span class="koboSpan" id="kobo.136.1"> methods, which will be overridden by the </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">derived classes.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">Now, create </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.139.1">derived classes for different </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">file formats:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.141.1">
class CsvParser : public FileParser {
protected:
    void process_line(const std::string&amp; line) override {
        // Implement the CSV-specific parsing logic.
        </span><span class="koboSpan" id="kobo.141.2">std::cout &lt;&lt; “Processing CSV line: “ &lt;&lt; line &lt;&lt; std::endl;
    }
    void post_process() override {
        std::cout &lt;&lt; “CSV parsing completed.” </span><span class="koboSpan" id="kobo.141.3">&lt;&lt; std::endl;
    }
};
class JsonParser : public FileParser {
protected:
    void process_line(const std::string&amp; line) override {
        // Implement the JSON-specific parsing logic.
        </span><span class="koboSpan" id="kobo.141.4">std::cout &lt;&lt; “Processing JSON line: “ &lt;&lt; line &lt;&lt; std::endl;
    }
    void post_process() override {
        std::cout &lt;&lt; “JSON parsing completed.” </span><span class="koboSpan" id="kobo.141.5">&lt;&lt; std::endl;
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.142.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">CsvParser</span></strong><span class="koboSpan" id="kobo.144.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">JsonParser</span></strong><span class="koboSpan" id="kobo.146.1"> classes inherit from </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">FileParser</span></strong><span class="koboSpan" id="kobo.148.1"> and implement the format-specific parsing logic in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">process_line</span></strong><span class="koboSpan" id="kobo.150.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">post_process</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.152.1"> methods.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">Here’s an example </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.154.1">of how to use the </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">file parsers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
int main() {
    CsvParser csv_parser;
    csv_parser.parse_file(“data.csv”);
    JsonParser json_parser;
    json_parser.parse_file(“data.json”);
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.157.1">By implementing the template method pattern, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">FileParser</span></strong><span class="koboSpan" id="kobo.159.1"> class provides a reusable template for handling the common steps of file parsing while allowing derived classes to implement format-specific parsing logic. </span><span class="koboSpan" id="kobo.159.2">This design makes it easy to add support for new file formats without modifying the base </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">FileParser</span></strong><span class="koboSpan" id="kobo.161.1"> class, leading to a more maintainable and extensible code base. </span><span class="koboSpan" id="kobo.161.2">It is important to note that usually, the complicated part of implementing this design pattern is to recognize the common logic between the classes. </span><span class="koboSpan" id="kobo.161.3">Often the implementation requires some sort of unification of the </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">common logic.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">Another helpful pattern to look at is the observer pattern. </span><span class="koboSpan" id="kobo.163.2">The previous chapter mentions its technical implementation details (raw, shared, or weak pointer implementation). </span><span class="koboSpan" id="kobo.163.3">However, in this chapter, I would like to cover its usage from a </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">design perspective.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">The observer pattern</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.166.1"> defines a one-to-many dependency between objects, allowing multiple observers to be notified when the state of the subject changes. </span><span class="koboSpan" id="kobo.166.2">This pattern can be beneficial when refactoring code that involves event handling or updates to multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">dependent components.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">Consider a car system where an </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">Engine</span></strong><span class="koboSpan" id="kobo.170.1"> class holds the car’s current speed and RPM (revolutions per minute). </span><span class="koboSpan" id="kobo.170.2">There are several elements that need to know about these values, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">Dashboard</span></strong><span class="koboSpan" id="kobo.172.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">Controller</span></strong><span class="koboSpan" id="kobo.174.1">. </span><span class="koboSpan" id="kobo.174.2">The dashboard displays the latest update from the engine and </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">Controller</span></strong><span class="koboSpan" id="kobo.176.1"> adjusts the car’s behavior based on the speed and RPM. </span><span class="koboSpan" id="kobo.176.2">The straightforward way to implement this is to have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">Engine</span></strong><span class="koboSpan" id="kobo.178.1"> class directly call </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">update</span></strong><span class="koboSpan" id="kobo.180.1"> methods on each </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">display element:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.182.1">
class Dashboard {
public:
    void update(int speed, int rpm) {
        // display the current speed
    }
};
class Controller {
public:
    void update(int speed, int rpm) {
        // Adjust car’s behavior based on the speed and RPM.
    </span><span class="koboSpan" id="kobo.182.2">}
};
class Engine {
public:
    void set_dashboard(Dashboard* dashboard) {
        dashboard_ = dashboard;
    }
    void set_controller(Controller* controller) {
        controller_ = controller;
    }
    void set_measurements(int speed, int rpm) {
        speed_ = speed;
        rpm_ = rpm;
        measurements_changed();
    }
private:
    void measurements_changed() {
        dashboard_-&gt;update(_speed, rpm_);
        controller_-&gt;update(_speed, rpm_);
    }
    int speed_;
    int rpm_;
    Dashboard* dashboard_;
    Controller* controller_;
};
int main() {
    Engine engine;
    engine.set_measurements(80, 3000);
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.183.1">This code has a couple </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">of issues:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.185.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">Engine</span></strong><span class="koboSpan" id="kobo.187.1"> class is tightly coupled with </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">Dashboard</span></strong><span class="koboSpan" id="kobo.189.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">Controller</span></strong><span class="koboSpan" id="kobo.191.1">, making it difficult to add or remove other components that might be interested in the car’s speed </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">and RPM.</span></span></li>
<li><span class="koboSpan" id="kobo.193.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">Engine</span></strong><span class="koboSpan" id="kobo.195.1"> class is responsible for updating the display elements directly, which complicates the code and makes it </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">less flexible.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.197.1">We can refactor the </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.198.1">code using the observer pattern to decouple the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">Engine</span></strong><span class="koboSpan" id="kobo.200.1"> from the display elements. </span><span class="koboSpan" id="kobo.200.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">Engine</span></strong><span class="koboSpan" id="kobo.202.1"> class will become a subject, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">Dashboard</span></strong><span class="koboSpan" id="kobo.204.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">Controller</span></strong><span class="koboSpan" id="kobo.206.1"> will </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">become observers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.208.1">
class Observer {
public:
    virtual ~Observer() {}
    virtual void update(int speed, int rpm) = 0;
};
class Dashboard : public Observer {
public:
    void update(int speed, int rpm) override {
        // display the current speed
    }
};
class Controller : public Observer {
public:
    void update(int speed, int rpm) override {
        // Adjust car’s behavior based on the speed and RPM.
    </span><span class="koboSpan" id="kobo.208.2">}
};
class Engine {
public:
    void register_observer(Observer* observer) {
        observers_.push_back(observer);
    }
    void remove_observer(Observer* observer) {
        observers_.erase(std::remove(_observers.begin(), observers_.end(), observer), observers_.end());
    }
    void set_measurements(int speed, int rpm) {
        speed_ = speed;
        rpm_ = rpm;
        notify_observers();
    }
private:
    void notify_observers() {
        for (auto observer : observers_) {
            observer-&gt;update(_speed, _rpm);
        }
    }
    std::vector&lt;Observer*&gt; observers_;
    int speed_;
    int rpm_;
};</span></pre>
<p><span class="koboSpan" id="kobo.209.1">The following</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.210.1"> snippet demonstrates the usage of the new </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">class hierarchy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.212.1">
int main() {
    Engine engine;
    Dashboard dashboard;
    Controller controller;
    // Register observers
    engine.register_observer(&amp;dashboard);
    engine.register_observer(&amp;controller);
    // Update measurements
    engine.set_measurements(80, 3000);
    // Remove an observer
    engine.remove_observer(&amp;dashboard);
    // Update measurements again
    engine.set_measurements(100, 3500);
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.213.1">In this</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.214.1"> example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">Dashboard</span></strong><span class="koboSpan" id="kobo.216.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">Controller</span></strong><span class="koboSpan" id="kobo.218.1"> are registered as observers to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">Engine</span></strong><span class="koboSpan" id="kobo.220.1"> subject. </span><span class="koboSpan" id="kobo.220.2">When the engine’s speed and RPM change, </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">set_measurements</span></strong><span class="koboSpan" id="kobo.222.1"> is called, triggering </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">notify_observers</span></strong><span class="koboSpan" id="kobo.224.1">, which in turn calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">update</span></strong><span class="koboSpan" id="kobo.226.1"> method on each registered observer. </span><span class="koboSpan" id="kobo.226.2">This allows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">Dashboard</span></strong><span class="koboSpan" id="kobo.228.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">Controller</span></strong><span class="koboSpan" id="kobo.230.1"> to receive the updated speed and </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">RPM values.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">Then, </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">Dashboard</span></strong><span class="koboSpan" id="kobo.234.1"> is unregistered as an observer. </span><span class="koboSpan" id="kobo.234.2">When the engine’s speed and RPM are updated again, only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">Controller</span></strong><span class="koboSpan" id="kobo.236.1"> receives the </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">updated values.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">With this setup, adding or removing observers is as simple as calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">register_observer</span></strong><span class="koboSpan" id="kobo.240.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">remove_observer</span></strong><span class="koboSpan" id="kobo.242.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">Engine</span></strong><span class="koboSpan" id="kobo.244.1">, and there is no need to modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">Engine</span></strong><span class="koboSpan" id="kobo.246.1"> class when adding new types of observers. </span><span class="koboSpan" id="kobo.246.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">Engine</span></strong><span class="koboSpan" id="kobo.248.1"> class is now decoupled from the specific observer classes, making the system more flexible and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">to maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">Another great pattern </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.251.1">is the state machine. </span><span class="koboSpan" id="kobo.251.2">It is not a classic pattern but probably the most powerful one. </span><span class="koboSpan" id="kobo.251.3">State machines, also known as </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">Finite State Machines</span></strong><span class="koboSpan" id="kobo.253.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.254.1">FSMs</span></strong><span class="koboSpan" id="kobo.255.1">), are</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.256.1"> mathematical models of computation. </span><span class="koboSpan" id="kobo.256.2">They’re used to represent and control execution flow in both hardware and software designs. </span><span class="koboSpan" id="kobo.256.3">A state machine has a finite number of states, and at any given time, it’s in one of these states. </span><span class="koboSpan" id="kobo.256.4">It transitions from one state to another in response to external inputs or </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">predefined conditions.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">In the realm of hardware, state machines are frequently used in the design of digital systems, serving as the control logic for everything from </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.259.1">tiny microcontrollers to massive </span><strong class="bold"><span class="koboSpan" id="kobo.260.1">central processing units</span></strong><span class="koboSpan" id="kobo.261.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.262.1">CPUs</span></strong><span class="koboSpan" id="kobo.263.1">). </span><span class="koboSpan" id="kobo.263.2">They govern the sequence of operations, ensuring that actions happen in the correct order and that the system responds appropriately to different inputs </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">or conditions.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">In software, state machines </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.266.1">are equally useful, particularly in systems where the program flow is influenced by a series of states and transitions between those states. </span><span class="koboSpan" id="kobo.266.2">Applications range from simple button debouncing in embedded systems to complex game character behavior or communication </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">protocol management.</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">State machines are ideal for situations where a system has a well-defined set of states that it cycles through, and where the transitions between states are triggered by specific events or conditions. </span><span class="koboSpan" id="kobo.268.2">They’re particularly useful in situations where the system’s behavior is not just a function of the current inputs, but also of the system’s history. </span><span class="koboSpan" id="kobo.268.3">State machines encapsulate this history in the form of the current state, making it explicit </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">and manageable.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">Using a state machine </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.271.1">can have numerous benefits. </span><span class="koboSpan" id="kobo.271.2">They can simplify complex conditional logic, making it easier to understand, debug, and maintain. </span><span class="koboSpan" id="kobo.271.3">They also make it easy to add new states or transitions without disturbing existing code, enhancing modularity and flexibility. </span><span class="koboSpan" id="kobo.271.4">Furthermore, they make the system’s behavior explicit and predictable, reducing the risk of </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">unexpected behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">Let’s consider a real-world scenario of a distributed computing system where a job is submitted to be processed. </span><span class="koboSpan" id="kobo.273.2">This job goes through various states, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">Submitted</span></strong><span class="koboSpan" id="kobo.275.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">Queued</span></strong><span class="koboSpan" id="kobo.277.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">Running</span></strong><span class="koboSpan" id="kobo.279.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">Completed</span></strong><span class="koboSpan" id="kobo.281.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">Failed</span></strong><span class="koboSpan" id="kobo.283.1">. </span><span class="koboSpan" id="kobo.283.2">We will model this using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">Boost.Statechart</span></strong><span class="koboSpan" id="kobo.285.1"> library. </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">Boost.Statechart</span></strong><span class="koboSpan" id="kobo.287.1"> is a C++ library that provides a framework for building state machines. </span><span class="koboSpan" id="kobo.287.2">It is part of the Boost libraries collection. </span><span class="koboSpan" id="kobo.287.3">This library facilitates the development of hierarchical state machines, allowing you to model complex systems with intricate states and transitions. </span><span class="koboSpan" id="kobo.287.4">It aims to make it easier to write well-structured, modular, and maintainable code when dealing with complex state logic. </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">Boost.Statechart</span></strong><span class="koboSpan" id="kobo.289.1"> provides both compile-time and runtime checks to help ensure the correctness of the state </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">machine’s behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">First, we include the necessary header files and set up </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">some namespaces:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.293.1">
#include &lt;boost/statechart/state_machine.hpp&gt;
#include &lt;boost/statechart/simple_state.hpp&gt;
#include &lt;boost/statechart/transition.hpp&gt;
#include &lt;iostream&gt;
namespace sc = boost::statechart;</span></pre>
<p><span class="koboSpan" id="kobo.294.1">Next, we define our events: </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">JobSubmitted</span></strong><span class="koboSpan" id="kobo.296.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">JobQueued</span></strong><span class="koboSpan" id="kobo.298.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">JobRunning</span></strong><span class="koboSpan" id="kobo.300.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">JobCompleted</span></strong><span class="koboSpan" id="kobo.302.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">JobFailed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.306.1">
struct EventJobSubmitted : sc::event&lt; EventJobSubmitted &gt; {};
struct EventJobQueued : sc::event&lt; EventJobQueued &gt; {};
struct EventJobRunning : sc::event&lt; EventJobRunning &gt; {};
struct EventJobCompleted : sc::event&lt; EventJobCompleted &gt; {};
struct EventJobFailed : sc::event&lt; EventJobFailed &gt; {};</span></pre>
<p><span class="koboSpan" id="kobo.307.1">Then, we define</span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.308.1"> our states, each state is a class that inherits from </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">sc::simple_state</span></strong><span class="koboSpan" id="kobo.310.1">. </span><span class="koboSpan" id="kobo.310.2">We will have five states: </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">Submitted</span></strong><span class="koboSpan" id="kobo.312.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">Queued</span></strong><span class="koboSpan" id="kobo.314.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">Running</span></strong><span class="koboSpan" id="kobo.316.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">Completed</span></strong><span class="koboSpan" id="kobo.318.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">Failed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.322.1">
struct Submitted;
struct Queued;
struct Running;
struct Completed;
struct Failed;
struct Submitted : sc::simple_state&lt; Submitted, Job &gt; {
    typedef sc::transition&lt; EventJobQueued, Queued &gt; reactions;
    Submitted() { std::cout &lt;&lt; “Job Submitted\n”; }
};
struct Queued : sc::simple_state&lt; Queued, Job &gt; {
    typedef sc::transition&lt; EventJobRunning, Running &gt; reactions;
    Queued() { std::cout &lt;&lt; “Job Queued\n”; }
};
struct Running : sc::simple_state&lt; Running, Job &gt; {
    typedef boost::mpl::list&lt;
        sc::transition&lt; EventJobCompleted, Completed &gt;,
        sc::transition&lt; EventJobFailed, Failed &gt;
    &gt; reactions;
    Running() { std::cout &lt;&lt; “Job Running\n”; }
};
struct Completed : sc::simple_state&lt; Completed, Job &gt; {
    Completed() { std::cout &lt;&lt; “Job Completed\n”; }
};
struct Failed : sc::simple_state&lt; Failed, Job &gt; {
    Failed() { std::cout &lt;&lt; “Job Failed\n”; }
};</span></pre>
<p><span class="koboSpan" id="kobo.323.1">Finally, we define</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.324.1"> our state machine, </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">Job</span></strong><span class="koboSpan" id="kobo.326.1">, which starts in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">Submitted</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.328.1"> state.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.329.1">
struct Job : sc::state_machine&lt; Job, Submitted &gt; {};</span></pre>
<p><span class="koboSpan" id="kobo.330.1">In a </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">main</span></strong><span class="koboSpan" id="kobo.332.1"> function, we can create an instance of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">Job</span></strong><span class="koboSpan" id="kobo.334.1"> state machine and process </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">some events:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.336.1">
int main() {
    Job my_job;
    my_job.initiate();
    my_job.process_event(EventJobQueued());
    my_job.process_event(EventJobRunning());
    my_job.process_event(EventJobCompleted());
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.337.1">This will </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.338.1">output </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.340.1">
Job Submitted
Job Queued
Job Running
Job Completed</span></pre>
<p><span class="koboSpan" id="kobo.341.1">This simple example shows how state machines can be used to model a process with multiple states and transitions. </span><span class="koboSpan" id="kobo.341.2">We used events to trigger transitions between states. </span><span class="koboSpan" id="kobo.341.3">Another approach is to use state reactions, where a state can decide when to transition based on the conditions or the data </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">it has.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">This can be achieved using custom reactions in </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">Boost.Statechart</span></strong><span class="koboSpan" id="kobo.345.1">. </span><span class="koboSpan" id="kobo.345.2">A custom reaction is a member function that’s called when an event is processed. </span><span class="koboSpan" id="kobo.345.3">It can decide what to do: ignore the event, consume the event without transitioning, or transition to a </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">new state.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">Let’s modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">Job</span></strong><span class="koboSpan" id="kobo.349.1"> state machine to make it decide when to transition from </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">Running</span></strong><span class="koboSpan" id="kobo.351.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">Completed</span></strong><span class="koboSpan" id="kobo.353.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">Failed</span></strong><span class="koboSpan" id="kobo.355.1"> based on the completion status of </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">the job.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">First, we will define a new event, </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">EventJobUpdate</span></strong><span class="koboSpan" id="kobo.359.1">, which will carry the completion status of </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">the job:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.361.1">
struct EventJobUpdate : sc::event&lt; EventJobUpdate &gt; {
    EventJobUpdate(bool is_complete) : is_complete(is_complete) {}
    bool is_complete;
};</span></pre>
<p><span class="koboSpan" id="kobo.362.1">Then, in</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.363.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">Running</span></strong><span class="koboSpan" id="kobo.365.1"> state, we will define a custom reaction for </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">this event:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.367.1">
struct Running : sc::simple_state&lt; Running, Job &gt; {
    typedef sc::custom_reaction&lt; EventJobUpdate &gt; reactions;
    sc::result react(const EventJobUpdate&amp; event) {
        if (event.is_complete) {
            return transit&lt;Completed&gt;();
        } else {
            return transit&lt;Failed&gt;();
        }
    }
    Running() { std::cout &lt;&lt; “Job Running\n”; }
};</span></pre>
<p><span class="koboSpan" id="kobo.368.1">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">Running</span></strong><span class="koboSpan" id="kobo.370.1"> state will decide when to transition to </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">Completed</span></strong><span class="koboSpan" id="kobo.372.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">Failed</span></strong><span class="koboSpan" id="kobo.374.1"> based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">is_complete</span></strong><span class="koboSpan" id="kobo.376.1"> field of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">EventJobUpdate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.378.1"> event.</span></span></p>
<p><span class="koboSpan" id="kobo.379.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">main</span></strong><span class="koboSpan" id="kobo.381.1"> function, we can now process the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">EventJobUpdate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.383.1"> event:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.384.1">
int main() {
    Job my_job;
    my_job.initiate();
    my_job.process_event(EventJobQueued());
    my_job.process_event(EventJobRunning());
    my_job.process_event(EventJobUpdate(true)); // The job is complete.
    </span><span class="koboSpan" id="kobo.384.2">return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.385.1">This will </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.386.1">output </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.388.1">
Job Submitted
Job Queued
Job Running
Job Completed</span></pre>
<p><span class="koboSpan" id="kobo.389.1">If we process </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">EventJobUpdate</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.391.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.394.1">
my_job.process_event(EventJobUpdate(false)); // The job is not complete.</span></pre>
<p><span class="koboSpan" id="kobo.395.1">It will output </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.397.1">
Job Submitted
Job Queued
Job Running
Job Failed</span></pre>
<p><span class="koboSpan" id="kobo.398.1">This shows how a state can decide when to transition based on the conditions or the data </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">it has.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">Logic implemented as a state machine can be easily extended by adding new states and transition rules between them. </span><span class="koboSpan" id="kobo.400.2">However, at some point state machines may include too many states (let’s say, more than seven). </span><span class="koboSpan" id="kobo.400.3">Often it is a symptom of smelly code. </span><span class="koboSpan" id="kobo.400.4">It means that the state machine is overloaded with too many states implementing several state machines. </span><span class="koboSpan" id="kobo.400.5">For example, our distributed system can be implemented as a state machine itself. </span><span class="koboSpan" id="kobo.400.6">The system could have its own states, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">Idle</span></strong><span class="koboSpan" id="kobo.402.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">ProcessingJobs</span></strong><span class="koboSpan" id="kobo.404.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">SystemFailure</span></strong><span class="koboSpan" id="kobo.406.1">. </span><span class="koboSpan" id="kobo.406.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">ProcessingJobs</span></strong><span class="koboSpan" id="kobo.408.1"> state will further contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">Job</span></strong><span class="koboSpan" id="kobo.410.1"> state machine as a sub-state machine. </span><span class="koboSpan" id="kobo.410.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">System</span></strong><span class="koboSpan" id="kobo.412.1"> state machine can communicate with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Job</span></strong><span class="koboSpan" id="kobo.414.1"> sub-state machine by processing events. </span><span class="koboSpan" id="kobo.414.2">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">System</span></strong><span class="koboSpan" id="kobo.416.1"> transitions to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">ProcessingJobs</span></strong><span class="koboSpan" id="kobo.418.1"> state, it can process an </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">EventJobSubmitted</span></strong><span class="koboSpan" id="kobo.420.1"> event to start the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">Job</span></strong><span class="koboSpan" id="kobo.422.1"> sub-state machine. </span><span class="koboSpan" id="kobo.422.2">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">Job</span></strong><span class="koboSpan" id="kobo.424.1"> transitions to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">Completed</span></strong><span class="koboSpan" id="kobo.426.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">Failed</span></strong><span class="koboSpan" id="kobo.428.1"> state, it can process an </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">EventJobFinished</span></strong><span class="koboSpan" id="kobo.430.1"> event to notify </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">System</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">First, we</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.435.1"> define the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">EventJobFinished</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1"> event:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.438.1">
struct EventJobFinished : sc::event&lt; EventJobFinished &gt; {};</span></pre>
<p><span class="koboSpan" id="kobo.439.1">Then, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">Completed</span></strong><span class="koboSpan" id="kobo.441.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">Failed</span></strong><span class="koboSpan" id="kobo.443.1"> states of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">Job</span></strong><span class="koboSpan" id="kobo.445.1"> state machine, we process the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">EventJobFinished</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.447.1"> event:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.448.1">
struct Completed : sc::simple_state&lt; Completed, Job &gt; {
    Completed() {
        std::cout &lt;&lt; “Job Completed\n”;
        context&lt; Job &gt;().outermost_context().process_event(EventJobFinished());
    }
};
struct Failed : sc::simple_state&lt; Failed, Job &gt; {
    Failed() {
        std::cout &lt;&lt; “Job Failed\n”;
        context&lt; Job &gt;().outermost_context().process_event(EventJobFinished());
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.449.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">ProcessingJobs</span></strong><span class="koboSpan" id="kobo.451.1"> state of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">System</span></strong><span class="koboSpan" id="kobo.453.1"> state machine, we define a custom reaction for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">EventJobFinished</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.455.1"> event:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.456.1">
struct ProcessingJobs : sc::state&lt; ProcessingJobs, System, Job &gt; {
    typedef sc::custom_reaction&lt; EventJobFinished &gt; reactions;
    sc::result react(const EventJobFinished&amp;) {
        std::cout &lt;&lt; “Job Finished\n”;
        return transit&lt;Idle&gt;();
    }
    ProcessingJobs(my_context ctx) : my_base(ctx) {
        std::cout &lt;&lt; “System Processing Jobs\n”;
        context&lt; System &gt;().process_event(EventJobSubmitted());
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.457.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">main</span></strong><span class="koboSpan" id="kobo.459.1"> function, we </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.460.1">can create an instance of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">System</span></strong><span class="koboSpan" id="kobo.462.1"> state machine and </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">start it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.464.1">
int main() {
    System my_system;
    my_system.initiate();
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.465.1">This will output </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.467.1">
System Idle
System Processing Jobs
Job Submitted
Job Queued
Job Running
Job Completed
Job Finished
System Idle</span></pre>
<p><span class="koboSpan" id="kobo.468.1">This shows how </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.469.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">System</span></strong><span class="koboSpan" id="kobo.471.1"> state machine interacts with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">Job</span></strong><span class="koboSpan" id="kobo.473.1"> sub-state machine. </span><span class="koboSpan" id="kobo.473.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">System</span></strong><span class="koboSpan" id="kobo.475.1"> starts the </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">Job</span></strong><span class="koboSpan" id="kobo.477.1"> when it transitions to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">ProcessingJobs</span></strong><span class="koboSpan" id="kobo.479.1"> state, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">Job</span></strong><span class="koboSpan" id="kobo.481.1"> notifies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">System</span></strong><span class="koboSpan" id="kobo.483.1"> when it’s finished. </span><span class="koboSpan" id="kobo.483.2">This allows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">System</span></strong><span class="koboSpan" id="kobo.485.1"> to manage the life cycle of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">Job</span></strong><span class="koboSpan" id="kobo.487.1"> and react to its </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">state changes.</span></span></p>
<p><span class="koboSpan" id="kobo.489.1">This can make your state machines more flexible </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">and dynamic.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">In general, state machines are a powerful tool for managing complex behavior robustly and understandably. </span><span class="koboSpan" id="kobo.491.2">Despite their utility, state machines are not always the first choice for structuring code, perhaps due to the perceived complexity or lack of familiarity. </span><span class="koboSpan" id="kobo.491.3">However, when dealing with a system characterized by a complex web of conditional logic, considering a state machine can be a wise move. </span><span class="koboSpan" id="kobo.491.4">It’s a powerful tool that can bring clarity and robustness to your software design, making it an essential part of the refactoring toolkit in C++ or any </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">other language.</span></span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.493.1">Anti-patterns</span></h1>
<p><span class="koboSpan" id="kobo.494.1">In contrast to </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.495.1">design patterns, anti-patterns are common solutions to problems that turn out to be counterproductive or harmful in the long run. </span><span class="koboSpan" id="kobo.495.2">Recognizing and avoiding anti-patterns is crucial in addressing smelly code, as applying them can exacerbate existing issues and introduce new ones. </span><span class="koboSpan" id="kobo.495.3">Some examples of anti-patterns include Singleton, God Object, Copy-Paste Programming, Premature Optimization, and </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">Spaghetti Code.</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">Singleton is </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.498.1">known to violate dependency inversion and open/closed principles. </span><span class="koboSpan" id="kobo.498.2">It creates a global instance, which can lead to hidden dependencies between classes and make the code hard to understand and maintain. </span><span class="koboSpan" id="kobo.498.3">It violates the dependency inversion principle, as it encourages high-level modules to depend on low-level modules instead of depending on abstractions. </span><span class="koboSpan" id="kobo.498.4">Additionally, the singleton pattern often makes it difficult to replace the singleton instance with a different implementation, for example, when extending the class or during testing. </span><span class="koboSpan" id="kobo.498.5">This violates the open/closed principle, as it requires modifying the code to change or extend the behavior. </span><span class="koboSpan" id="kobo.498.6">In the following code sample, we have a singleton class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">Database</span></strong><span class="koboSpan" id="kobo.500.1">, used by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">OrderManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.502.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.503.1">
class Database {
public:
    static Database&amp; get_instance() {
        static Database instance;
        return instance;
    }
    template&lt;typename T&gt;
    std::optional&lt;T&gt; get(const Id&amp; id) const;
    template&lt;typename T&gt;
    void save(const T&amp; data);
private:
    Database() {} // Private constructor
    Database(const Database&amp;) = delete; // Delete copy constructor
    Database&amp; operator=(const Database&amp;) = delete; // Delete copy assignment operator
};
class OrderManager {
public:
  void addOrder(const Order&amp; order) {
    auto db = Database::get_instance();
    // check order validity
    // notify other components about the new order, etc
    db.save(order);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.504.1">The idea of </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.505.1">having the database connection represented as a singleton is quite logical: the application allows having a single database connection per application instance, and the database is used everywhere in the code. </span><span class="koboSpan" id="kobo.505.2">The usage of singleton hides the fact that </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">OrderManager</span></strong><span class="koboSpan" id="kobo.507.1"> depends on </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">Database</span></strong><span class="koboSpan" id="kobo.509.1">, which makes the code less obvious and predictable. </span><span class="koboSpan" id="kobo.509.2">The usage of singleton makes it almost impossible to test the business logic of </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">OrderManager</span></strong><span class="koboSpan" id="kobo.511.1"> via unit tests without running a real instance of the </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">database aside.</span></span></p>
<p><span class="koboSpan" id="kobo.513.1">The problem can be solved by creating an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">Database</span></strong><span class="koboSpan" id="kobo.515.1"> somewhere at the beginning of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">main</span></strong><span class="koboSpan" id="kobo.517.1"> function and passing it to all the classes that need a </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">database connection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.519.1">
class OrderManager {
  public:
  OrderManager(Database&amp; db);
  // the rest of the code is the same
};
int main() {
  auto db = Database{};
  auto order_manager = OrderManager{db};
}</span></pre>
<p><span class="koboSpan" id="kobo.520.1">Note that despite the fact that </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">Database</span></strong><span class="koboSpan" id="kobo.522.1"> is not a singleton anymore (that is, its constructor is public), it still cannot be copied. </span><span class="koboSpan" id="kobo.522.2">Technically, this allows developers to create new instances ad hoc, which is not a desired behavior. </span><span class="koboSpan" id="kobo.522.3">In my experience, it can be easily avoided by knowledge sharing within the team and enforced by code review. </span><span class="koboSpan" id="kobo.522.4">Those developers who think it is not enough can keep </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">Database</span></strong><span class="koboSpan" id="kobo.524.1"> unchanged but make sure that </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">get_instance</span></strong><span class="koboSpan" id="kobo.526.1"> is called only once and passed by reference </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">since then:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.528.1">
int main() {
  auto db = Database::get_instance();
  auto order_manager = OrderManager{db};
}</span></pre>
<p><span class="koboSpan" id="kobo.529.1">If a code smell</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.530.1"> involves a class with too many responsibilities, applying the god object anti-pattern would be inappropriate, as it would only make the class more convoluted and difficult to maintain. </span><span class="koboSpan" id="kobo.530.2">In general, god class is a violation of the single responsibility principle on steroids. </span><span class="koboSpan" id="kobo.530.3">For example, let’s take a look at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">class, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">EcommerceSystem</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
class ECommerceSystem {
public:
    // Product management
    void add_product(int id, const std::string&amp; name, uint64_t price) {
        products_[id] = {name, price};
    }
    void remove_product(int id) {
        products_.erase(id);
    }
    void update_product(int id, const std::string&amp; name, uint64_t price) {
        products_[id] = {name, price};
    }
    void list_products() {
        // print the list of products
    }
    // Cart management
    void add_to_cart(int product_id, int quantity) {
        cart_[product_id] += quantity;
    }
    void remove_from_cart(int product_id) {
        cart_.erase(product_id);
    }
    void update_cart(int product_id, int quantity) {
        cart_[product_id] = quantity;
    }
    uint64_t calculate_cart_total() {
        uint64_t total = 0;
        for (const auto&amp; item : cart_) {
            total += products_[item.first].second * item.second;
        }
        return total;
    }
    // Order management
    void place_order() {
        // Process payment, update inventory, send confirmation email, etc.
        </span><span class="koboSpan" id="kobo.534.2">// ...
        </span><span class="koboSpan" id="kobo.534.3">cart_.clear();
    }
    // Persistence
    void save_to_file(const std::string&amp; file_name) {
        // serializing the state to a file
    }
    void load_from_file(const std::string&amp; file_name) {
        // loading a file and parsing it
    }
private:
    std::map&lt;int, std::pair&lt;std::string, uint64_t&gt;&gt; products_;
    std::map&lt;int, int&gt; cart_;
};</span></pre>
<p><span class="koboSpan" id="kobo.535.1">In this </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.536.1">example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">ECommerceSystem</span></strong><span class="koboSpan" id="kobo.538.1"> class takes on multiple responsibilities such as product management, cart management, order management, and persistence (saving and loading data from a file). </span><span class="koboSpan" id="kobo.538.2">This class is difficult to maintain, understand, </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">and modify.</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">A better approach would be to break down the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">ECommerceSystem</span></strong><span class="koboSpan" id="kobo.542.1"> into smaller, more focused classes, each handling a </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">specific responsibility:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.544.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">ProductManager</span></strong><span class="koboSpan" id="kobo.546.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">manages products</span></span></li>
<li><span class="koboSpan" id="kobo.548.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">CartManager</span></strong><span class="koboSpan" id="kobo.550.1"> class manages </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">the cart</span></span></li>
<li><span class="koboSpan" id="kobo.552.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">OrderManager</span></strong><span class="koboSpan" id="kobo.554.1"> class manages orders and related tasks (e.g., processing payments and sending </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">confirmation emails)</span></span></li>
<li><span class="koboSpan" id="kobo.556.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">PersistenceManager</span></strong><span class="koboSpan" id="kobo.558.1"> class handles saving and loading data </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">from files</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.560.1">These classes </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.561.1">can be implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.563.1">
class ProductManager {
public:
    void add_product(int id, const std::string&amp; name, uint64_t price) {
        products_[id] = {name, price};
    }
    void remove_product(int id) {
        products_.erase(id);
    }
    void update_product(int id, const std::string&amp; name, uint64_t price) {
        products_[id] = {name, price};
    }
    std::pair&lt;std::string, uint64_t&gt; get_product(int id) {
        return products_[id];
    }
    void list_products() {
        // print the list of products
    }
private:
    std::map&lt;int, std::pair&lt;std::string, uint64_t&gt;&gt; products_;
};
class CartManager {
public:
    void add_to_cart(int product_id, int quantity) {
        cart_[product_id] += quantity;
    }
    void remove_from_cart(int product_id) {
        cart_.erase(product_id);
    }
    void update_cart(int product_id, int quantity) {
        cart_[product_id] = quantity;
    }
    std::map&lt;int, int&gt; get_cart_contents() {
        return cart_;
    }
    void clear_cart() {
        cart_.clear();
    }
private:
    std::map&lt;int, int&gt; cart_;
};
class OrderManager {
public:
    OrderManager(ProductManager&amp; product_manager, CartManager&amp; cart_manager)
        : product_manager_(product_manager), cart_manager_(cart_manager) {}
    uint64_t calculate_cart_total() {
        // calculate cart’s total the same as before
    }
    void place_order() {
        // Process payment, update inventory, send confirmation email, etc.
        </span><span class="koboSpan" id="kobo.563.2">// ...
        </span><span class="koboSpan" id="kobo.563.3">cart_manager_.clear_cart();
    }
private:
    ProductManager&amp; product_manager_;
    CartManager&amp; cart_manager_;
};
class PersistenceManager {
public:
    PersistenceManager(ProductManager&amp; product_manager)
        : product_manager_(product_manager) {}
    void save_to_file(const std::string&amp; file_name) {
      // saving
    }
    void load_from_file(const std::string&amp; file_name) {
      // loading
    }
private:
    ProductManager&amp; product_manager_;
};</span></pre>
<p><span class="koboSpan" id="kobo.564.1">Eventually, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">ECommerce</span></strong><span class="koboSpan" id="kobo.566.1"> class that owns the new classes and provides proxy methods to</span><a id="_idIndexMarker158"/> <span class="No-Break"><span class="koboSpan" id="kobo.567.1">their functionality:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.568.1">
// include the new classes
class ECommerce {
public:
    void add_product(int id, const std::string&amp; name, uint64_t price) {
        product_manager_.add_product(id, name, price);
    }
    void remove_product(int id) {
        product_manager_.remove_product(id);
    }
    void update_product(int id, const std::string&amp; name, uint64_t price) {
        product_manager_.update_product(id, name, price);
    }
    void list_products() {
        product_manager_.list_products();
    }
    void add_to_cart(int product_id, int quantity) {
        cart_manager_.add_to_cart(product_id, quantity);
    }
    void remove_from_cart(int product_id) {
        cart_manager_.remove_from_cart(product_id);
    }
    void update_cart(int product_id, int quantity) {
        cart_manager_.update_cart(product_id, quantity);
    }
    uint64_t calculate_cart_total() {
        return order_manager_.calculate_cart_total();
    }
    void place_order() {
        order_manager_.place_order();
    }
    void save_to_file(const std::string&amp; filename) {
        persistence_manager_.save_to_file(filename);
    }
    void load_from_file(const std::string&amp; filename) {
        persistence_manager_.load_from_file(filename);
    }
private:
    ProductManager product_manager_;
    CartManager cart_manager_;
    OrderManager order_manager_{product_manager_, cart_manager_};
    PersistenceManager persistence_manager_{product_manager_};
};
int main() {
    ECommerce e_commerce;
    e_commerce.add_product(1, “Laptop”, 999.99);
    e_commerce.add_product(2, “Smartphone”, 699.99);
    e_commerce.add_product(3, “Headphones”, 99.99);
    e_commerce.list_products();
    e_commerce.add_to_cart(1, 1); // Add 1 Laptop to the cart
    e_commerce.add_to_cart(3, 2); // Add 2 Headphones to the cart
    uint64_t cart_total = e_commerce.calculate_cart_total();
    std::cout &lt;&lt; “Cart Total: $” &lt;&lt; cart_total &lt;&lt; std::endl;
    e_commerce.place_order();
    std::cout &lt;&lt; “Order placed successfully!” </span><span class="koboSpan" id="kobo.568.2">&lt;&lt; std::endl;
    e_commerce.save_to_file(“products.txt”);
    e_commerce.remove_product(1);
    e_commerce.remove_product(2);
    e_commerce.remove_product(3);
    std::cout &lt;&lt; “Loading products from file...” </span><span class="koboSpan" id="kobo.568.3">&lt;&lt; std::endl;
    e_commerce.load_from_file(“products.txt”);
    e_commerce.list_products();
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.569.1">By dividing</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.570.1"> the responsibilities among multiple smaller classes, the code becomes more modular, easier to maintain, and better suited to real-life applications. </span><span class="koboSpan" id="kobo.570.2">Small changes in the internal business logic of one of the subclasses will not necessitate updates to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">ECommerce</span></strong><span class="koboSpan" id="kobo.572.1"> class. </span><span class="koboSpan" id="kobo.572.2">In C++ it might be even more important due to the notorious compilation time issues. </span><span class="koboSpan" id="kobo.572.3">It is easier to test these classes separately, or completely replace the implementation of one of them, for example, to save the data not to the disk but to </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">remote storage.</span></span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.574.1">The pitfalls of magic numbers – a case study on data chunking</span></h2>
<p><span class="koboSpan" id="kobo.575.1">Let’s </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.576.1">consider the following C++ function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">send</span></strong><span class="koboSpan" id="kobo.578.1">, which aims</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.579.1"> to send a block of data in chunks to some destination. </span><span class="koboSpan" id="kobo.579.2">Here’s how the </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">function looks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.581.1">
#include &lt;cstddef&gt;
#include &lt;algorithm&gt;
// Actually sending the data
void do_send(const std::uint8_t* data, size_t size);
void send(const std::uint8_t* data, size_t size) {
    for (std::size_t position = 0; position &lt; size;) {
        std::size_t length = std::min(size_t{256}, size - position);  // 256 is a magic number
        do_send(data + position, position + length);
        position += length;
    }
}</span></pre>
<h3><span class="koboSpan" id="kobo.582.1">What does the code do?</span></h3>
<p><span class="koboSpan" id="kobo.583.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">send</span></strong><span class="koboSpan" id="kobo.585.1"> function takes a pointer to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">std::uint8_t</span></strong><span class="koboSpan" id="kobo.587.1"> array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">data</span></strong><span class="koboSpan" id="kobo.589.1">) and its size (</span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">size</span></strong><span class="koboSpan" id="kobo.591.1">). </span><span class="koboSpan" id="kobo.591.2">It then proceeds to send this data in chunks to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">do_send</span></strong><span class="koboSpan" id="kobo.593.1"> function, which is responsible for the actual sending process. </span><span class="koboSpan" id="kobo.593.2">The chunks have a maximum size of 256 bytes each, as defined within the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">send</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.595.1"> function.</span></span></p>
<h3><span class="koboSpan" id="kobo.596.1">Why is the magic number problematic?</span></h3>
<p><span class="koboSpan" id="kobo.597.1">The number 256 is directly embedded into the code, and there’s no explanation for what it represents. </span><span class="koboSpan" id="kobo.597.2">This is a classic example of a </span><strong class="bold"><span class="koboSpan" id="kobo.598.1">magic number</span></strong><span class="koboSpan" id="kobo.599.1">. </span><span class="koboSpan" id="kobo.599.2">Anyone reading this code would have to guess why 256 was chosen. </span><span class="koboSpan" id="kobo.599.3">Is it a hardware limit? </span><span class="koboSpan" id="kobo.599.4">A protocol constraint? </span><span class="koboSpan" id="kobo.599.5">A performance </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">tuning parameter?</span></span></p>
<h3><span class="koboSpan" id="kobo.601.1">The constexpr solution</span></h3>
<p><span class="koboSpan" id="kobo.602.1">One way to</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.603.1"> improve the clarity of this code is to replace the magic number with a named </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">constexpr</span></strong><span class="koboSpan" id="kobo.605.1"> variable. </span><span class="koboSpan" id="kobo.605.2">For instance, the code could be rewritten </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.607.1">
#include &lt;cstddef&gt;
#include &lt;algorithm&gt;
constexpr std::size_t MAX_DATA_TO_SEND = 256;  // Named constant replaces magic number
// Actually sending the data
void do_send(const std::uint8_t* data, size_t size);
void send(const std::uint8_t* data, size_t size) {
    for (std::size_t position = 0; position &lt; size;) {
        std::size_t length = std::min(MAX_DATA_TO_SEND, size - position);  // Use the named constant
        do_send(data + position, position + length);
        position += length;
    }
}</span></pre>
<h3><span class="koboSpan" id="kobo.608.1">Advantages of using constexpr</span></h3>
<p><span class="koboSpan" id="kobo.609.1">Replacing </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.610.1">the magic number with </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">MAX_DATA_TO_SEND</span></strong><span class="koboSpan" id="kobo.612.1"> makes it easier to understand why this limit exists. </span><span class="koboSpan" id="kobo.612.2">Furthermore, if you have another function, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">read</span></strong><span class="koboSpan" id="kobo.614.1">, which also needs to read data in chunks of 256 bytes, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">constexpr</span></strong><span class="koboSpan" id="kobo.616.1"> variable ensures consistency. </span><span class="koboSpan" id="kobo.616.2">If ever the chunk size needs to be changed, you only have to update it in one place, thereby reducing the risk of bugs </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">and inconsistencies.</span></span></p>
<p><span class="koboSpan" id="kobo.618.1">When dealing </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.619.1">with smelly code, it is essential to understand the underlying causes of the smells and to apply the correct patterns or avoid anti-patterns to refactor the code effectively. </span><span class="koboSpan" id="kobo.619.2">For instance, if a code smell involves duplicated code, one should avoid Copy-Paste Programming and instead apply patterns like the Template Method or Strategy pattern to promote code reuse and reduce duplication. </span><span class="koboSpan" id="kobo.619.3">Similarly, if a code smell involves tightly coupled modules or classes, you should apply patterns such as Adapter or the Dependency Inversion Principle to reduce coupling and </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">improve modularity.</span></span></p>
<p><span class="koboSpan" id="kobo.621.1">It is important to remember that refactoring smelly code should be an iterative and incremental process. </span><span class="koboSpan" id="kobo.621.2">Developers should continuously review and evaluate their code base for smells, making small, focused changes that gradually improve the code’s quality and maintainability. </span><span class="koboSpan" id="kobo.621.3">This approach allows better risk management, as it minimizes the chances of introducing new bugs or issues during the refactoring process. </span><span class="koboSpan" id="kobo.621.4">The best way to achieve that is unit tests. </span><span class="koboSpan" id="kobo.621.5">They help verify that the refactored code still meets its original requirements and behaves as expected, even after modifications to its internal structure or organization. </span><span class="koboSpan" id="kobo.621.6">By having a strong set of tests in place before starting the refactoring process, developers can have confidence that their changes will not negatively impact the application’s behavior. </span><span class="koboSpan" id="kobo.621.7">This allows them to focus on improving the code’s design, readability, and maintainability without worrying about unintentionally breaking the functionality. </span><span class="koboSpan" id="kobo.621.8">We will explore unit tests in </span><a href="B19606_13.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.622.1">Chapter 13</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.623.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.624.1">In conclusion, smelly code is a term that describes symptoms in a codebase that indicate potential design or implementation issues. </span><span class="koboSpan" id="kobo.624.2">Addressing smelly code involves recognizing and applying appropriate design patterns, as well as avoiding anti-patterns that can be detrimental to code quality. </span><span class="koboSpan" id="kobo.624.3">By understanding the underlying causes of code smells and using patterns and anti-patterns effectively, developers can refactor their code base to be more maintainable, readable, and resilient to future changes. </span><span class="koboSpan" id="kobo.624.4">Continuous evaluation and incremental refactoring are key to keeping code smells at bay and ensuring a high-quality, efficient codebase that can adapt to evolving requirements </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">and demands.</span></span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.626.1">Legacy code</span></h1>
<p><span class="koboSpan" id="kobo.627.1">Refactoring</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.628.1"> legacy C++ code is a significant undertaking that has the potential </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.629.1">to breathe new life into an aging code base. </span><span class="koboSpan" id="kobo.629.2">Often, legacy code is written in old dialects of C++, such as C++98 or C++03, which do not take advantage of the new language features and standard library improvements introduced in C++11, C++14, C++17, </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">and C++20.</span></span></p>
<p><span class="koboSpan" id="kobo.631.1">One common area for modernization is memory management. </span><span class="koboSpan" id="kobo.631.2">Legacy C++ code often uses raw pointers for managing dynamic memory, leading to potential issues with memory leaks and null pointer dereferencing. </span><span class="koboSpan" id="kobo.631.3">Such code can be refactored to use smart pointers, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.633.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.635.1">, which automatically manage the lifetime of the objects they point to, reducing the risk of </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">memory leaks.</span></span></p>
<p><span class="koboSpan" id="kobo.637.1">Another modernization opportunity lies in adopting the range-based </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">for</span></strong><span class="koboSpan" id="kobo.639.1"> loops introduced in C++11. </span><span class="koboSpan" id="kobo.639.2">Older loops with explicit iterators or index variables can be replaced with cleaner and more intuitive range-based loops. </span><span class="koboSpan" id="kobo.639.3">This not only makes the code easier to read but also reduces the potential for off-by-one and iterator </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">invalidation errors.</span></span></p>
<p><span class="koboSpan" id="kobo.641.1">As mentioned in previous chapters, legacy C++ code bases often make heavy use of raw arrays and C-style strings. </span><span class="koboSpan" id="kobo.641.2">Such code can be refactored to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">std::array</span></strong><span class="koboSpan" id="kobo.643.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">std::vector</span></strong><span class="koboSpan" id="kobo.645.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">std::string</span></strong><span class="koboSpan" id="kobo.647.1">, which are safer, more flexible, and provide useful </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">member functions.</span></span></p>
<p><span class="koboSpan" id="kobo.649.1">Lastly, modern C++ has made significant strides in improving concurrency support with the introduction of </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">std::thread</span></strong><span class="koboSpan" id="kobo.651.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">std::async</span></strong><span class="koboSpan" id="kobo.653.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">std::future</span></strong><span class="koboSpan" id="kobo.655.1"> in C++11, followed by further enhancements in subsequent standards. </span><span class="koboSpan" id="kobo.655.2">Legacy code that uses platform-specific threading or older concurrency libraries could benefit from refactoring to use these modern, portable </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">concurrency tools.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">Let’s start with an example of legacy code that uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">pthread</span></strong><span class="koboSpan" id="kobo.659.1"> to create a new thread. </span><span class="koboSpan" id="kobo.659.2">This thread will perform a </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">simple calculation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.661.1">
#include &lt;pthread.h&gt;
#include &lt;iostream&gt;
void* calculate(void* arg) {
    int* result = new int(0);
    for (int i = 0; i &lt; 10000; ++i)
        *result += i;
    pthread_exit(result);
}
int main() {
    pthread_t thread;
    if (pthread_create(&amp;thread, nullptr, calculate, nullptr)) {
        std::cerr &lt;&lt; “Error creating thread\n”;
        return 1;
    }
    int* result = nullptr;
    if (pthread_join(thread, (void**)&amp;result)) {
        std::cerr &lt;&lt; “Error joining thread\n”;
        return 2;
    }
    std::cout &lt;&lt; “Result: “ &lt;&lt; *result &lt;&lt; ‘\n’;
    delete result;
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.662.1">Now, we can </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.663.1">refactor this code using </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">std::async</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.665.1">from C++11:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.666.1">
#include &lt;future&gt;
#include &lt;iostream&gt;
int calculate() {
    int result = 0;
    for (int i = 0; i &lt; 10000; ++i)
        result += i;
    return result;
}
int main() {
    std::future&lt;int&gt; future = std::async(std::launch::async, calculate);
    try {
        int result = future.get();
        std::cout &lt;&lt; “Result: “ &lt;&lt; result &lt;&lt; ‘\n’;
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; “Error: “ &lt;&lt; e.what() &lt;&lt; ‘\n’;
        return 1;
    }
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.667.1">In the refactored version, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">std::async</span></strong><span class="koboSpan" id="kobo.669.1"> to start a new task and </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">std::future::get</span></strong><span class="koboSpan" id="kobo.671.1"> to obtain the result. </span><span class="koboSpan" id="kobo.671.2">The calculate function directly returns the result as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">int</span></strong><span class="koboSpan" id="kobo.673.1">, which is much simpler and safer than allocating memory in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">pthread</span></strong><span class="koboSpan" id="kobo.675.1"> version. </span><span class="koboSpan" id="kobo.675.2">There are a few things to note. </span><span class="koboSpan" id="kobo.675.3">The call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">std::future::get</span></strong><span class="koboSpan" id="kobo.677.1"> blocks the execution until the async is done. </span><span class="koboSpan" id="kobo.677.2">Additionally, the example uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">std::launch::async</span></strong><span class="koboSpan" id="kobo.679.1">, which ensures that the task is launched in a separate thread. </span><span class="koboSpan" id="kobo.679.2">The C++ 11 standard allows the implementations to decide what is the default policy: a separate thread or </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.680.1">a deferred execution. </span><span class="koboSpan" id="kobo.680.2">At the time of writing, Microsoft Visual C++, GCC, and Clang run the task in a separate thread by default. </span><span class="koboSpan" id="kobo.680.3">The only difference is that while GCC and Clang create a new thread per task, Microsoft Visual C++ reuses threads from an internal thread pool. </span><span class="koboSpan" id="kobo.680.4">The error handling is also simpler, as any exception thrown by the calculate function will be caught </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">std::future::get</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">Often legacy code uses object-oriented wrappers around </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">pthread</span></strong><span class="koboSpan" id="kobo.686.1"> and other platform-specific APIs. </span><span class="koboSpan" id="kobo.686.2">Replacing them with the standard C++ implementation can decrease the amount of code that the developers have to support and make code more portable. </span><span class="koboSpan" id="kobo.686.3">However, multi-threading is a complex topic, so if the existing code has some rich thread-related logic, it is important to make sure that it </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">stays intact.</span></span></p>
<p><span class="koboSpan" id="kobo.688.1">The built-in algorithms provided with modern C++ can improve legacy code readability and maintenance. </span><span class="koboSpan" id="kobo.688.2">Often, developers need to check whether an array contains a certain value. </span><span class="koboSpan" id="kobo.688.3">Pre-C++11 language allowed doing something </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.690.1">
#include &lt;vector&gt;
#include &lt;iostream&gt;
int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6};
    bool has_even = false;
    for (size_t i = 0; i &lt; numbers.size(); ++i) {
        if (numbers[i] % 2 == 0) {
            has_even = true;
            break;
        }
    }
    if (has_even)
        std::cout &lt;&lt; “The vector contains an even number.\n”;
    else
        std::cout &lt;&lt; “The vector does not contain any even numbers.\n”;
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.691.1">With C++11, we </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.692.1">can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">std::any_of</span></strong><span class="koboSpan" id="kobo.694.1">, a new algorithm that checks if any element in a range satisfies a predicate. </span><span class="koboSpan" id="kobo.694.2">This allows us to write the code more concisely </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">and expressively:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.696.1">
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6};
    bool has_even = std::any_of(numbers.begin(), numbers.end(),
                                [](int n) { return n % 2 == 0; });
    if (has_even)
        std::cout &lt;&lt; “The vector contains an even number.\n”;
    else
        std::cout &lt;&lt; “The vector does not contain any even numbers.\n”;
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.697.1">In this refactored </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.698.1">version, we use a lambda function as the predicate for </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">std::any_of</span></strong><span class="koboSpan" id="kobo.700.1">. </span><span class="koboSpan" id="kobo.700.2">This makes the code more concise and the intention clearer. </span><span class="koboSpan" id="kobo.700.3">Algorithms such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">std::all_of`` </span></strong><span class="koboSpan" id="kobo.702.1">and </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">std::none_of`</span></strong><span class="koboSpan" id="kobo.704.1"> allows to clearly express </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">similar checks</span></span></p>
<p><span class="koboSpan" id="kobo.706.1">Remember, refactoring should be done incrementally, with each change tested thoroughly to ensure it doesn’t introduce new bugs or regressions. </span><span class="koboSpan" id="kobo.706.2">It can be a time-consuming process, but the benefits in terms of improved code quality, maintainability, and performance can </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">be substantial.</span></span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.708.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.709.1">In this chapter, we’ve explored some of the key design patterns that can be instrumental in refactoring legacy C++ code, including the strategy pattern, template method pattern, and observer pattern. </span><span class="koboSpan" id="kobo.709.2">These patterns, when applied judiciously, can significantly improve the structure of your code, making it more flexible, maintainable, and resilient </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">to change.</span></span></p>
<p><span class="koboSpan" id="kobo.711.1">While we’ve provided practical, real-world examples to illustrate the use of these patterns, this is by no means an exhaustive treatment. </span><span class="koboSpan" id="kobo.711.2">Design patterns are a vast and deep subject, with many more patterns and variations to explore. </span><span class="koboSpan" id="kobo.711.3">For a more comprehensive understanding of design patterns, I strongly recommend you delve into the seminal work </span><em class="italic"><span class="koboSpan" id="kobo.712.1">Design Patterns: Elements of Reusable Object-Oriented Software</span></em><span class="koboSpan" id="kobo.713.1"> by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, often referred to as the </span><em class="italic"><span class="koboSpan" id="kobo.714.1">Gang of </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.715.1">Four</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.716.1"> book.</span></span></p>
<p><span class="koboSpan" id="kobo.717.1">In addition, to keep abreast of the most recent developments and emerging best practices, consider resources such as </span><em class="italic"><span class="koboSpan" id="kobo.718.1">Hands-On Design Patterns with C++: Solve common C++ problems with modern design patterns and build robust applications</span></em><span class="koboSpan" id="kobo.719.1"> by Fedor G. </span><span class="koboSpan" id="kobo.719.2">Pikus, and </span><em class="italic"><span class="koboSpan" id="kobo.720.1">C++ Concurrency in Action</span></em><span class="koboSpan" id="kobo.721.1"> by Anthony Williams. </span><span class="koboSpan" id="kobo.721.2">These works will provide you with a broader perspective and deeper understanding of the powerful role design patterns play in crafting high-quality </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">C++ software.</span></span></p>
<p><span class="koboSpan" id="kobo.723.1">Remember, the goal of refactoring and applying design patterns is not just to write code that works, but to write code that is clean, easy to understand, easy to modify, and easy to maintain in the </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">long run.</span></span></p>
<p><span class="koboSpan" id="kobo.725.1">In the upcoming chapter, we’ll be delving deeper into the world of C++, focusing specifically on naming conventions, their importance in writing clean and maintainable code, and best practices established by </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">the community.</span></span></p>
</div>
</body></html>