<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-69"><a id="_idTextAnchor068"/>4</h1>
<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Identifying Ideal Candidates for Rewriting – Patterns and Anti-Patterns</h1>
<p>Refactoring is<a id="_idIndexMarker121"/> a crucial technique in software development that involves making changes to existing code to improve its structure, readability, and maintainability without altering its behavior. It is vital for several reasons.</p>
<p>It helps to eliminate technical debt and enhance the overall quality of the code base. Developers can achieve this by removing redundant or duplicate code, simplifying complex code, and improving code readability, resulting in more maintainable and robust software.</p>
<p>Refactoring facilitates future development. By restructuring code to be more modular, developers can reuse existing code more effectively, saving time and effort in future development. This makes code more flexible and adaptable to change, making it easier to add new features, fix bugs, and optimize performance.</p>
<p>Well-structured and maintainable code makes it easier for multiple developers to collaborate effectively on a project. Refactoring helps to standardize code practices, reduce complexity, and improve documentation, making it easier for developers to understand and contribute to a code base.</p>
<p>Eventually, refactoring reduces costs associated with software development in the long term. By improving code quality and maintainability, refactoring can help to reduce the time and effort required for bug fixes, updates, and other maintenance tasks.</p>
<p>In this chapter, we will focus on identifying good candidates for refactoring in C++ projects. However, identifying the right code segments for refactoring can be challenging, especially in large and complex systems. Therefore, it is essential to understand the factors that make code segments ideal candidates for refactoring. In this chapter, we will explore these factors and provide guidelines for identifying good candidates for refactoring in C++. We will also discuss common refactoring techniques and tools that can be used to improve the quality of C++ code.</p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>What kind of code is worth rewriting?</h1>
<p>Determining whether a piece of code is worth rewriting depends on several factors, including the code’s maintainability, readability, performance, scalability, and adherence to best practices. Let’s look at some situations where code may be worth rewriting.</p>
<p><strong class="bold">Smelly code</strong> is <a id="_idIndexMarker122"/>often an indication that code needs to be rewritten. These are signs of poor design or implementation, such as long methods, large classes, duplicated code, or poor naming conventions. Addressing these code smells can improve the overall quality of the code base and make it easier to maintain in the long run.</p>
<p>Code that exhibits low cohesion or high coupling might be worth rewriting. Low cohesion means that the elements within a module or class are not closely related, and the module or class has too many responsibilities. High coupling refers to a high degree of dependency between modules or classes, making the code harder to maintain and modify. Refactoring such code can lead to a more modular and easier-to-understand architecture.</p>
<p>In the previous chapters, we discussed the importance of SOLID principles; code that violates them can also be worth rewriting.</p>
<p>Another reason to rewrite code is if it relies on outdated technologies, libraries, or programming practices. Such code can become increasingly difficult to maintain over time and may not take advantage of newer, more efficient methods or tools. Updating the code to use current technologies and practices can improve its performance, security, and maintainability.</p>
<p>Lastly, if the code has performance or scalability issues, it may be worth rewriting. This can involve optimizing algorithms, data structures, or resource management to ensure that the code runs more efficiently and can handle larger workloads.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>Smelly code and its basic characteristics</h1>
<p><strong class="bold">Smelly code</strong>, also <a id="_idIndexMarker123"/>known as <strong class="bold">code smells</strong>, refers to the symptoms in a code base that suggest underlying design or implementation issues. These symptoms are not necessarily bugs but are indicators of potential problems that can make the code harder to understand, maintain, and modify. Code smells are often the result of <a id="_idIndexMarker124"/>poor coding practices or the accumulation of technical debt over time. Although code smells might not directly affect the functionality of a program, they can significantly impact the overall code quality, leading to an increased risk of bugs and a decrease in developer productivity.</p>
<p>One aspect of addressing smelly code involves identifying and applying appropriate design patterns. Design patterns are reusable solutions to common problems that arise in software design. They provide a proven framework for solving specific problems, allowing developers to build on the collective wisdom and experience of other developers. By applying these patterns, it is possible to refactor smelly code into a more structured, modular, and maintainable form. Let’s take a look at a few examples.</p>
<p>The <a id="_idIndexMarker125"/>strategy pattern allows us to define a family of algorithms, encapsulate each one in a separate class, and make them interchangeable at runtime. The strategy pattern is useful for refactoring code that has multiple branches or conditions performing similar tasks with slightly different implementations.</p>
<p>Let’s consider an example of an application that saves data using different storage strategies, such as saving to disk or a remote storage service:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;assert&gt;
enum class StorageType {
    Disk,
    Remote
};
class DataSaver {
public:
    DataSaver(StorageType storage_type) : storage_type_(storage_type) {}
    void save_data(const std::string&amp; data) const {
        switch (storage_type_) {
            case StorageType::Disk:
                save_to_disk(data);
                break;
            case StorageType::Remote:
                save_to_remote(data);
                break;
            default:
                assert(false &amp;&amp; “Unknown storage type.”);
        }
    }
    void set_storage_type(StorageType storage_type) {
        storage_type_ = storage_type;
    }
private:
    void save_to_disk(const std::string&amp; data) const {
        // saving to disk
    }
    void save_to_remote(const std::string&amp; data) const {
        // saving data to a remote storage service.
    }
    StorageType storage_type_;
};
int main() {
    DataSaver disk_data_saver(StorageType::Disk);
    disk_data_saver.save_data(“Save this data to disk.”);
    DataSaver remote_data_saver(StorageType::Remote);
    remote_data_saver.save_data(“Save this data to remote storage.”);
    // Switch the storage type at runtime.
    disk_data_saver.set_storage_type(StorageType::Remote);
    disk_data_saver.save_data(“Save this data to remote storage after switching storage type.”);
    return 0;
}</pre>
<p>In this class, the <code>save_data</code> method checks the storage type on each call and uses a <code>switch</code>-<code>case</code> block to decide which saving method to use. This approach works, but it has some drawbacks:</p>
<ul>
<li>The <code>DataSaver</code> class is responsible for handling all the different storage types, making it harder to maintain and extend.</li>
<li>Adding new storage types requires modifying the <code>DataSaver</code> class and the <code>StorageType</code> enumeration, increasing the risk of introducing bugs or breaking existing functionality. For example, if for some reason the wrong enum type is provided, the code aborts.</li>
<li>The code is less modular and flexible compared to the strategy pattern, where behaviors are encapsulated in separate classes.</li>
</ul>
<p>By<a id="_idIndexMarker126"/> implementing the strategy pattern, we can address these drawbacks and create a more maintainable, flexible, and extensible design for the <code>DataSaver</code> class. First, define an interface called <code>SaveStrategy</code> that represents the saving behavior:</p>
<pre class="source-code">
class SaveStrategy {
public:
    virtual ~SaveStrategy() {}
    virtual void save_data(const std::string&amp; data) const = 0;
};</pre>
<p>Next, implement concrete <code>SaveStrategy</code> classes for each storage type:</p>
<pre class="source-code">
class DiskSaveStrategy : public SaveStrategy {
public:
    void save_data(const std::string&amp; data) const override {
        // ...
    }
};
class RemoteSaveStrategy : public SaveStrategy {
public:
    void save_data(const std::string&amp; data) const override {
        // ...
    }
};</pre>
<p>Now, create a <code>DataSaver</code> class that uses the strategy pattern to delegate its saving behavior to <a id="_idIndexMarker127"/>the appropriate <code>SaveStrategy</code> implementation:</p>
<pre class="source-code">
class DataSaver {
public:
    DataSaver(std::unique_ptr&lt;SaveStrategy&gt; save_strategy)
        : save_strategy_(std::move(save_strategy)) {}
    void save_data(const std::string&amp; data) const {
        save_strategy_-&gt;save_data(data);
    }
    void set_save_strategy(std::unique_ptr&lt;SaveStrategy&gt; save_strategy) {
        save_strategy_ = std::move(save_strategy);
    }
private:
    std::unique_ptr&lt;SaveStrategy&gt; save_strategy_;
};</pre>
<p>Finally, here’s an<a id="_idIndexMarker128"/> example of how to use the <code>DataSaver</code> class with different saving strategies:</p>
<pre class="source-code">
int main() {
    DataSaver disk_data_saver(std::make_unique&lt;DiskSaveStrategy&gt;());
    disk_data_saver.save_data(“Save this data to disk.”);
    DataSaver remote_data_saver(std::make_unique&lt;RemoteSaveStrategy&gt;());
    remote_data_saver.save_data(“Save this data to remote storage.”);
    // Switch the saving strategy at runtime.
    disk_data_saver.set_save_strategy(std::make_unique&lt;RemoteSaveStrategy&gt;());
    disk_data_saver.save_data(“Save this data to remote storage after switching strategy.”);
    return 0;
}</pre>
<p>In this example, the <code>DataSaver</code> class uses the strategy pattern to delegate its saving behavior to different <code>SaveStrategy</code> implementations, allowing it to easily switch between saving to disk and saving to remote storage. This design makes the code more modular, maintainable, and flexible, allowing new storage strategies to be added with minimal changes to the existing code. Additionally, the new version of the code does not need to terminate or throw an exception on the wrong save strategy type.</p>
<p>Let’s assume<a id="_idIndexMarker129"/> we have file parser implementations for two formats, CSV and JSON:</p>
<pre class="source-code">
class CsvParser {
public:
    void parse_file(const std::string&amp; file_path) {
        std::ifstream file(file_path);
        if (!file) {
            std::cerr &lt;&lt; “Error opening file: “ &lt;&lt; file_path &lt;&lt; std::endl;
            return;
        }
        std::string line;
        while (std::getline(file, line)) {
            process_line(line);
        }
        file.close();
        post_process();
    }
private:
    void process_line(const std::string&amp; line) {
        // Implement the CSV-specific parsing logic.
        std::cout &lt;&lt; “Processing CSV line: “ &lt;&lt; line &lt;&lt; std::endl;
    }
    void post_process() {
        std::cout &lt;&lt; “CSV parsing completed.” &lt;&lt; std::endl;
    }
};
class JsonParser {
public:
    void parse_file(const std::string&amp; file_path) {
        std::ifstream file(file_path);
        if (!file) {
            std::cerr &lt;&lt; “Error opening file: “ &lt;&lt; file_path &lt;&lt; std::endl;
            return;
        }
        std::string line;
        while (std::getline(file, line)) {
            process_line(line);
        }
        file.close();
        post_process();
    }
private:
    void process_line(const std::string&amp; line) {
        // Implement the JSON-specific parsing logic.
        std::cout &lt;&lt; “Processing JSON line: “ &lt;&lt; line &lt;&lt; std::endl;
    }
    void post_process() {
        std::cout &lt;&lt; “JSON parsing completed.” &lt;&lt; std::endl;
    }
};</pre>
<p>In this example, the <code>CsvParser</code> and <code>JsonParser</code> classes have separate implementations<a id="_idIndexMarker130"/> of the <code>parse_file</code> method that contain duplicate code for opening, reading, and closing the file. The format-specific parsing logic is implemented in the <code>process_line</code> and <code>post_process</code> methods.</p>
<p>While this design works, it has some drawbacks: the shared parsing steps are duplicated in both classes, making it harder to maintain and update the code, and adding support for new file formats requires creating new classes with similar code structures, which can lead to even more code duplication.</p>
<p>By implementing the<a id="_idIndexMarker131"/> template method pattern, you can address these drawbacks and create a more maintainable, extensible, and reusable design for the file parsers. The <code>FileParser</code> base class handles the common parsing steps, while the derived classes implement the format-specific parsing logic.</p>
<p>As in the previous example, let’s start with creating an abstract base class. <code>FileParser</code> represents the general file parsing process:</p>
<pre class="source-code">
class FileParser {
public:
    void parse_file(const std::string&amp; file_path) {
        std::ifstream file(file_path);
        if (!file) {
            std::cerr &lt;&lt; “Error opening file: “ &lt;&lt; file_path &lt;&lt; std::endl;
            return;
        }
        std::string line;
        while (std::getline(file, line)) {
            process_line(line);
        }
        file.close();
        post_process();
    }
protected:
    virtual void process_line(const std::string&amp; line) = 0;
    virtual void post_process() = 0;
};</pre>
<p>The <code>FileParser</code> class <a id="_idIndexMarker132"/>has a <code>parse_file</code> method that handles the common steps of opening a file, reading its content line by line, and closing the file. The format-specific parsing logic is implemented by the pure virtual <code>process_line</code> and <code>post_process</code> methods, which will be overridden by the derived classes.</p>
<p>Now, create <a id="_idIndexMarker133"/>derived classes for different file formats:</p>
<pre class="source-code">
class CsvParser : public FileParser {
protected:
    void process_line(const std::string&amp; line) override {
        // Implement the CSV-specific parsing logic.
        std::cout &lt;&lt; “Processing CSV line: “ &lt;&lt; line &lt;&lt; std::endl;
    }
    void post_process() override {
        std::cout &lt;&lt; “CSV parsing completed.” &lt;&lt; std::endl;
    }
};
class JsonParser : public FileParser {
protected:
    void process_line(const std::string&amp; line) override {
        // Implement the JSON-specific parsing logic.
        std::cout &lt;&lt; “Processing JSON line: “ &lt;&lt; line &lt;&lt; std::endl;
    }
    void post_process() override {
        std::cout &lt;&lt; “JSON parsing completed.” &lt;&lt; std::endl;
    }
};</pre>
<p>In this example, the <code>CsvParser</code> and <code>JsonParser</code> classes inherit from <code>FileParser</code> and implement the format-specific parsing logic in the <code>process_line</code> and <code>post_process</code> methods.</p>
<p>Here’s an example <a id="_idIndexMarker134"/>of how to use the file parsers:</p>
<pre class="source-code">
int main() {
    CsvParser csv_parser;
    csv_parser.parse_file(“data.csv”);
    JsonParser json_parser;
    json_parser.parse_file(“data.json”);
    return 0;
}</pre>
<p>By implementing the template method pattern, the <code>FileParser</code> class provides a reusable template for handling the common steps of file parsing while allowing derived classes to implement format-specific parsing logic. This design makes it easy to add support for new file formats without modifying the base <code>FileParser</code> class, leading to a more maintainable and extensible code base. It is important to note that usually, the complicated part of implementing this design pattern is to recognize the common logic between the classes. Often the implementation requires some sort of unification of the common logic.</p>
<p>Another helpful pattern to look at is the observer pattern. The previous chapter mentions its technical implementation details (raw, shared, or weak pointer implementation). However, in this chapter, I would like to cover its usage from a design perspective.</p>
<p>The observer pattern<a id="_idIndexMarker135"/> defines a one-to-many dependency between objects, allowing multiple observers to be notified when the state of the subject changes. This pattern can be beneficial when refactoring code that involves event handling or updates to multiple dependent components.</p>
<p>Consider a car system where an <code>Engine</code> class holds the car’s current speed and RPM (revolutions per minute). There are several elements that need to know about these values, such as <code>Dashboard</code> and <code>Controller</code>. The dashboard displays the latest update from the engine and <code>Controller</code> adjusts the car’s behavior based on the speed and RPM. The straightforward way to implement this is to have the <code>Engine</code> class directly call <code>update</code> methods on each display element:</p>
<pre class="source-code">
class Dashboard {
public:
    void update(int speed, int rpm) {
        // display the current speed
    }
};
class Controller {
public:
    void update(int speed, int rpm) {
        // Adjust car’s behavior based on the speed and RPM.
    }
};
class Engine {
public:
    void set_dashboard(Dashboard* dashboard) {
        dashboard_ = dashboard;
    }
    void set_controller(Controller* controller) {
        controller_ = controller;
    }
    void set_measurements(int speed, int rpm) {
        speed_ = speed;
        rpm_ = rpm;
        measurements_changed();
    }
private:
    void measurements_changed() {
        dashboard_-&gt;update(_speed, rpm_);
        controller_-&gt;update(_speed, rpm_);
    }
    int speed_;
    int rpm_;
    Dashboard* dashboard_;
    Controller* controller_;
};
int main() {
    Engine engine;
    engine.set_measurements(80, 3000);
    return 0;
}</pre>
<p>This code has a couple of issues:</p>
<ul>
<li>The <code>Engine</code> class is tightly coupled with <code>Dashboard</code> and <code>Controller</code>, making it difficult to add or remove other components that might be interested in the car’s speed and RPM.</li>
<li>The <code>Engine</code> class is responsible for updating the display elements directly, which complicates the code and makes it less flexible.</li>
</ul>
<p>We can refactor the <a id="_idIndexMarker136"/>code using the observer pattern to decouple the <code>Engine</code> from the display elements. The <code>Engine</code> class will become a subject, and <code>Dashboard</code> and <code>Controller</code> will become observers:</p>
<pre class="source-code">
class Observer {
public:
    virtual ~Observer() {}
    virtual void update(int speed, int rpm) = 0;
};
class Dashboard : public Observer {
public:
    void update(int speed, int rpm) override {
        // display the current speed
    }
};
class Controller : public Observer {
public:
    void update(int speed, int rpm) override {
        // Adjust car’s behavior based on the speed and RPM.
    }
};
class Engine {
public:
    void register_observer(Observer* observer) {
        observers_.push_back(observer);
    }
    void remove_observer(Observer* observer) {
        observers_.erase(std::remove(_observers.begin(), observers_.end(), observer), observers_.end());
    }
    void set_measurements(int speed, int rpm) {
        speed_ = speed;
        rpm_ = rpm;
        notify_observers();
    }
private:
    void notify_observers() {
        for (auto observer : observers_) {
            observer-&gt;update(_speed, _rpm);
        }
    }
    std::vector&lt;Observer*&gt; observers_;
    int speed_;
    int rpm_;
};</pre>
<p>The following<a id="_idIndexMarker137"/> snippet demonstrates the usage of the new class hierarchy:</p>
<pre class="source-code">
int main() {
    Engine engine;
    Dashboard dashboard;
    Controller controller;
    // Register observers
    engine.register_observer(&amp;dashboard);
    engine.register_observer(&amp;controller);
    // Update measurements
    engine.set_measurements(80, 3000);
    // Remove an observer
    engine.remove_observer(&amp;dashboard);
    // Update measurements again
    engine.set_measurements(100, 3500);
    return 0;
}</pre>
<p>In this<a id="_idIndexMarker138"/> example, <code>Dashboard</code> and <code>Controller</code> are registered as observers to the <code>Engine</code> subject. When the engine’s speed and RPM change, <code>set_measurements</code> is called, triggering <code>notify_observers</code>, which in turn calls the <code>update</code> method on each registered observer. This allows the <code>Dashboard</code> and <code>Controller</code> to receive the updated speed and RPM values.</p>
<p>Then, <code>Dashboard</code> is unregistered as an observer. When the engine’s speed and RPM are updated again, only the <code>Controller</code> receives the updated values.</p>
<p>With this setup, adding or removing observers is as simple as calling <code>register_observer</code> or <code>remove_observer</code> on the <code>Engine</code>, and there is no need to modify the <code>Engine</code> class when adding new types of observers. The <code>Engine</code> class is now decoupled from the specific observer classes, making the system more flexible and easier to maintain.</p>
<p>Another great pattern <a id="_idIndexMarker139"/>is the state machine. It is not a classic pattern but probably the most powerful one. State machines, also known as <strong class="bold">Finite State Machines</strong> (<strong class="bold">FSMs</strong>), are<a id="_idIndexMarker140"/> mathematical models of computation. They’re used to represent and control execution flow in both hardware and software designs. A state machine has a finite number of states, and at any given time, it’s in one of these states. It transitions from one state to another in response to external inputs or predefined conditions.</p>
<p>In the realm of hardware, state machines are frequently used in the design of digital systems, serving as the control logic for everything from <a id="_idIndexMarker141"/>tiny microcontrollers to massive <strong class="bold">central processing units</strong> (<strong class="bold">CPUs</strong>). They govern the sequence of operations, ensuring that actions happen in the correct order and that the system responds appropriately to different inputs or conditions.</p>
<p>In software, state machines <a id="_idIndexMarker142"/>are equally useful, particularly in systems where the program flow is influenced by a series of states and transitions between those states. Applications range from simple button debouncing in embedded systems to complex game character behavior or communication protocol management.</p>
<p>State machines are ideal for situations where a system has a well-defined set of states that it cycles through, and where the transitions between states are triggered by specific events or conditions. They’re particularly useful in situations where the system’s behavior is not just a function of the current inputs, but also of the system’s history. State machines encapsulate this history in the form of the current state, making it explicit and manageable.</p>
<p>Using a state machine <a id="_idIndexMarker143"/>can have numerous benefits. They can simplify complex conditional logic, making it easier to understand, debug, and maintain. They also make it easy to add new states or transitions without disturbing existing code, enhancing modularity and flexibility. Furthermore, they make the system’s behavior explicit and predictable, reducing the risk of unexpected behavior.</p>
<p>Let’s consider a real-world scenario of a distributed computing system where a job is submitted to be processed. This job goes through various states, such as <code>Submitted</code>, <code>Queued</code>, <code>Running</code>, <code>Completed</code>, and <code>Failed</code>. We will model this using the <code>Boost.Statechart</code> library. <code>Boost.Statechart</code> is a C++ library that provides a framework for building state machines. It is part of the Boost libraries collection. This library facilitates the development of hierarchical state machines, allowing you to model complex systems with intricate states and transitions. It aims to make it easier to write well-structured, modular, and maintainable code when dealing with complex state logic. <code>Boost.Statechart</code> provides both compile-time and runtime checks to help ensure the correctness of the state machine’s behavior.</p>
<p>First, we include the necessary header files and set up some namespaces:</p>
<pre class="source-code">
#include &lt;boost/statechart/state_machine.hpp&gt;
#include &lt;boost/statechart/simple_state.hpp&gt;
#include &lt;boost/statechart/transition.hpp&gt;
#include &lt;iostream&gt;
namespace sc = boost::statechart;</pre>
<p>Next, we define our events: <code>JobSubmitted</code>, <code>JobQueued</code>, <code>JobRunning</code>, <code>JobCompleted</code>, and <code>JobFailed</code>:</p>
<pre class="source-code">
struct EventJobSubmitted : sc::event&lt; EventJobSubmitted &gt; {};
struct EventJobQueued : sc::event&lt; EventJobQueued &gt; {};
struct EventJobRunning : sc::event&lt; EventJobRunning &gt; {};
struct EventJobCompleted : sc::event&lt; EventJobCompleted &gt; {};
struct EventJobFailed : sc::event&lt; EventJobFailed &gt; {};</pre>
<p>Then, we define<a id="_idIndexMarker144"/> our states, each state is a class that inherits from <code>sc::simple_state</code>. We will have five states: <code>Submitted</code>, <code>Queued</code>, <code>Running</code>, <code>Completed</code>, and <code>Failed</code>:</p>
<pre class="source-code">
struct Submitted;
struct Queued;
struct Running;
struct Completed;
struct Failed;
struct Submitted : sc::simple_state&lt; Submitted, Job &gt; {
    typedef sc::transition&lt; EventJobQueued, Queued &gt; reactions;
    Submitted() { std::cout &lt;&lt; “Job Submitted\n”; }
};
struct Queued : sc::simple_state&lt; Queued, Job &gt; {
    typedef sc::transition&lt; EventJobRunning, Running &gt; reactions;
    Queued() { std::cout &lt;&lt; “Job Queued\n”; }
};
struct Running : sc::simple_state&lt; Running, Job &gt; {
    typedef boost::mpl::list&lt;
        sc::transition&lt; EventJobCompleted, Completed &gt;,
        sc::transition&lt; EventJobFailed, Failed &gt;
    &gt; reactions;
    Running() { std::cout &lt;&lt; “Job Running\n”; }
};
struct Completed : sc::simple_state&lt; Completed, Job &gt; {
    Completed() { std::cout &lt;&lt; “Job Completed\n”; }
};
struct Failed : sc::simple_state&lt; Failed, Job &gt; {
    Failed() { std::cout &lt;&lt; “Job Failed\n”; }
};</pre>
<p>Finally, we define<a id="_idIndexMarker145"/> our state machine, <code>Job</code>, which starts in the <code>Submitted</code> state.</p>
<pre class="source-code">
struct Job : sc::state_machine&lt; Job, Submitted &gt; {};</pre>
<p>In a <code>main</code> function, we can create an instance of our <code>Job</code> state machine and process some events:</p>
<pre class="source-code">
int main() {
    Job my_job;
    my_job.initiate();
    my_job.process_event(EventJobQueued());
    my_job.process_event(EventJobRunning());
    my_job.process_event(EventJobCompleted());
    return 0;
}</pre>
<p>This will <a id="_idIndexMarker146"/>output the following:</p>
<pre class="source-code">
Job Submitted
Job Queued
Job Running
Job Completed</pre>
<p>This simple example shows how state machines can be used to model a process with multiple states and transitions. We used events to trigger transitions between states. Another approach is to use state reactions, where a state can decide when to transition based on the conditions or the data it has.</p>
<p>This can be achieved using custom reactions in <code>Boost.Statechart</code>. A custom reaction is a member function that’s called when an event is processed. It can decide what to do: ignore the event, consume the event without transitioning, or transition to a new state.</p>
<p>Let’s modify the <code>Job</code> state machine to make it decide when to transition from <code>Running</code> to <code>Completed</code> or <code>Failed</code> based on the completion status of the job.</p>
<p>First, we will define a new event, <code>EventJobUpdate</code>, which will carry the completion status of the job:</p>
<pre class="source-code">
struct EventJobUpdate : sc::event&lt; EventJobUpdate &gt; {
    EventJobUpdate(bool is_complete) : is_complete(is_complete) {}
    bool is_complete;
};</pre>
<p>Then, in<a id="_idIndexMarker147"/> the <code>Running</code> state, we will define a custom reaction for this event:</p>
<pre class="source-code">
struct Running : sc::simple_state&lt; Running, Job &gt; {
    typedef sc::custom_reaction&lt; EventJobUpdate &gt; reactions;
    sc::result react(const EventJobUpdate&amp; event) {
        if (event.is_complete) {
            return transit&lt;Completed&gt;();
        } else {
            return transit&lt;Failed&gt;();
        }
    }
    Running() { std::cout &lt;&lt; “Job Running\n”; }
};</pre>
<p>Now, the <code>Running</code> state will decide when to transition to <code>Completed</code> or <code>Failed</code> based on the <code>is_complete</code> field of the <code>EventJobUpdate</code> event.</p>
<p>In the <code>main</code> function, we can now process the <code>EventJobUpdate</code> event:</p>
<pre class="source-code">
int main() {
    Job my_job;
    my_job.initiate();
    my_job.process_event(EventJobQueued());
    my_job.process_event(EventJobRunning());
    my_job.process_event(EventJobUpdate(true)); // The job is complete.
    return 0;
}</pre>
<p>This will <a id="_idIndexMarker148"/>output the following:</p>
<pre class="source-code">
Job Submitted
Job Queued
Job Running
Job Completed</pre>
<p>If we process <code>EventJobUpdate</code> with <code>false</code>:</p>
<pre class="source-code">
my_job.process_event(EventJobUpdate(false)); // The job is not complete.</pre>
<p>It will output the following:</p>
<pre class="source-code">
Job Submitted
Job Queued
Job Running
Job Failed</pre>
<p>This shows how a state can decide when to transition based on the conditions or the data it has.</p>
<p>Logic implemented as a state machine can be easily extended by adding new states and transition rules between them. However, at some point state machines may include too many states (let’s say, more than seven). Often it is a symptom of smelly code. It means that the state machine is overloaded with too many states implementing several state machines. For example, our distributed system can be implemented as a state machine itself. The system could have its own states, such as <code>Idle</code>, <code>ProcessingJobs</code>, and <code>SystemFailure</code>. The <code>ProcessingJobs</code> state will further contain the <code>Job</code> state machine as a sub-state machine. The <code>System</code> state machine can communicate with the <code>Job</code> sub-state machine by processing events. When the <code>System</code> transitions to the <code>ProcessingJobs</code> state, it can process an <code>EventJobSubmitted</code> event to start the <code>Job</code> sub-state machine. When the <code>Job</code> transitions to the <code>Completed</code> or <code>Failed</code> state, it can process an <code>EventJobFinished</code> event to notify the <code>System</code>.</p>
<p>First, we<a id="_idIndexMarker149"/> define the <code>EventJobFinished</code> event:</p>
<pre class="source-code">
struct EventJobFinished : sc::event&lt; EventJobFinished &gt; {};</pre>
<p>Then, in the <code>Completed</code> and <code>Failed</code> states of the <code>Job</code> state machine, we process the <code>EventJobFinished</code> event:</p>
<pre class="source-code">
struct Completed : sc::simple_state&lt; Completed, Job &gt; {
    Completed() {
        std::cout &lt;&lt; “Job Completed\n”;
        context&lt; Job &gt;().outermost_context().process_event(EventJobFinished());
    }
};
struct Failed : sc::simple_state&lt; Failed, Job &gt; {
    Failed() {
        std::cout &lt;&lt; “Job Failed\n”;
        context&lt; Job &gt;().outermost_context().process_event(EventJobFinished());
    }
};</pre>
<p>In the <code>ProcessingJobs</code> state of the <code>System</code> state machine, we define a custom reaction for the <code>EventJobFinished</code> event:</p>
<pre class="source-code">
struct ProcessingJobs : sc::state&lt; ProcessingJobs, System, Job &gt; {
    typedef sc::custom_reaction&lt; EventJobFinished &gt; reactions;
    sc::result react(const EventJobFinished&amp;) {
        std::cout &lt;&lt; “Job Finished\n”;
        return transit&lt;Idle&gt;();
    }
    ProcessingJobs(my_context ctx) : my_base(ctx) {
        std::cout &lt;&lt; “System Processing Jobs\n”;
        context&lt; System &gt;().process_event(EventJobSubmitted());
    }
};</pre>
<p>In the <code>main</code> function, we <a id="_idIndexMarker150"/>can create an instance of our <code>System</code> state machine and start it:</p>
<pre class="source-code">
int main() {
    System my_system;
    my_system.initiate();
    return 0;
}</pre>
<p>This will output the following:</p>
<pre class="source-code">
System Idle
System Processing Jobs
Job Submitted
Job Queued
Job Running
Job Completed
Job Finished
System Idle</pre>
<p>This shows how <a id="_idIndexMarker151"/>the <code>System</code> state machine interacts with the <code>Job</code> sub-state machine. The <code>System</code> starts the <code>Job</code> when it transitions to the <code>ProcessingJobs</code> state, and the <code>Job</code> notifies the <code>System</code> when it’s finished. This allows the <code>System</code> to manage the life cycle of the <code>Job</code> and react to its state changes.</p>
<p>This can make your state machines more flexible and dynamic.</p>
<p>In general, state machines are a powerful tool for managing complex behavior robustly and understandably. Despite their utility, state machines are not always the first choice for structuring code, perhaps due to the perceived complexity or lack of familiarity. However, when dealing with a system characterized by a complex web of conditional logic, considering a state machine can be a wise move. It’s a powerful tool that can bring clarity and robustness to your software design, making it an essential part of the refactoring toolkit in C++ or any other language.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Anti-patterns</h1>
<p>In contrast to <a id="_idIndexMarker152"/>design patterns, anti-patterns are common solutions to problems that turn out to be counterproductive or harmful in the long run. Recognizing and avoiding anti-patterns is crucial in addressing smelly code, as applying them can exacerbate existing issues and introduce new ones. Some examples of anti-patterns include Singleton, God Object, Copy-Paste Programming, Premature Optimization, and Spaghetti Code.</p>
<p>Singleton is <a id="_idIndexMarker153"/>known to violate dependency inversion and open/closed principles. It creates a global instance, which can lead to hidden dependencies between classes and make the code hard to understand and maintain. It violates the dependency inversion principle, as it encourages high-level modules to depend on low-level modules instead of depending on abstractions. Additionally, the singleton pattern often makes it difficult to replace the singleton instance with a different implementation, for example, when extending the class or during testing. This violates the open/closed principle, as it requires modifying the code to change or extend the behavior. In the following code sample, we have a singleton class, <code>Database</code>, used by the <code>OrderManager</code> class:</p>
<pre class="source-code">
class Database {
public:
    static Database&amp; get_instance() {
        static Database instance;
        return instance;
    }
    template&lt;typename T&gt;
    std::optional&lt;T&gt; get(const Id&amp; id) const;
    template&lt;typename T&gt;
    void save(const T&amp; data);
private:
    Database() {} // Private constructor
    Database(const Database&amp;) = delete; // Delete copy constructor
    Database&amp; operator=(const Database&amp;) = delete; // Delete copy assignment operator
};
class OrderManager {
public:
  void addOrder(const Order&amp; order) {
    auto db = Database::get_instance();
    // check order validity
    // notify other components about the new order, etc
    db.save(order);
  }
};</pre>
<p>The idea of <a id="_idIndexMarker154"/>having the database connection represented as a singleton is quite logical: the application allows having a single database connection per application instance, and the database is used everywhere in the code. The usage of singleton hides the fact that <code>OrderManager</code> depends on <code>Database</code>, which makes the code less obvious and predictable. The usage of singleton makes it almost impossible to test the business logic of <code>OrderManager</code> via unit tests without running a real instance of the database aside.</p>
<p>The problem can be solved by creating an instance of <code>Database</code> somewhere at the beginning of the <code>main</code> function and passing it to all the classes that need a database connection:</p>
<pre class="source-code">
class OrderManager {
  public:
  OrderManager(Database&amp; db);
  // the rest of the code is the same
};
int main() {
  auto db = Database{};
  auto order_manager = OrderManager{db};
}</pre>
<p>Note that despite the fact that <code>Database</code> is not a singleton anymore (that is, its constructor is public), it still cannot be copied. Technically, this allows developers to create new instances ad hoc, which is not a desired behavior. In my experience, it can be easily avoided by knowledge sharing within the team and enforced by code review. Those developers who think it is not enough can keep <code>Database</code> unchanged but make sure that <code>get_instance</code> is called only once and passed by reference since then:</p>
<pre class="source-code">
int main() {
  auto db = Database::get_instance();
  auto order_manager = OrderManager{db};
}</pre>
<p>If a code smell<a id="_idIndexMarker155"/> involves a class with too many responsibilities, applying the god object anti-pattern would be inappropriate, as it would only make the class more convoluted and difficult to maintain. In general, god class is a violation of the single responsibility principle on steroids. For example, let’s take a look at the following class, <code>EcommerceSystem</code>:</p>
<pre class="source-code">
class ECommerceSystem {
public:
    // Product management
    void add_product(int id, const std::string&amp; name, uint64_t price) {
        products_[id] = {name, price};
    }
    void remove_product(int id) {
        products_.erase(id);
    }
    void update_product(int id, const std::string&amp; name, uint64_t price) {
        products_[id] = {name, price};
    }
    void list_products() {
        // print the list of products
    }
    // Cart management
    void add_to_cart(int product_id, int quantity) {
        cart_[product_id] += quantity;
    }
    void remove_from_cart(int product_id) {
        cart_.erase(product_id);
    }
    void update_cart(int product_id, int quantity) {
        cart_[product_id] = quantity;
    }
    uint64_t calculate_cart_total() {
        uint64_t total = 0;
        for (const auto&amp; item : cart_) {
            total += products_[item.first].second * item.second;
        }
        return total;
    }
    // Order management
    void place_order() {
        // Process payment, update inventory, send confirmation email, etc.
        // ...
        cart_.clear();
    }
    // Persistence
    void save_to_file(const std::string&amp; file_name) {
        // serializing the state to a file
    }
    void load_from_file(const std::string&amp; file_name) {
        // loading a file and parsing it
    }
private:
    std::map&lt;int, std::pair&lt;std::string, uint64_t&gt;&gt; products_;
    std::map&lt;int, int&gt; cart_;
};</pre>
<p>In this <a id="_idIndexMarker156"/>example, the <code>ECommerceSystem</code> class takes on multiple responsibilities such as product management, cart management, order management, and persistence (saving and loading data from a file). This class is difficult to maintain, understand, and modify.</p>
<p>A better approach would be to break down the <code>ECommerceSystem</code> into smaller, more focused classes, each handling a specific responsibility:</p>
<ul>
<li>The <code>ProductManager</code> class manages products</li>
<li>The <code>CartManager</code> class manages the cart</li>
<li>The <code>OrderManager</code> class manages orders and related tasks (e.g., processing payments and sending confirmation emails)</li>
<li>The <code>PersistenceManager</code> class handles saving and loading data from files</li>
</ul>
<p>These classes <a id="_idIndexMarker157"/>can be implemented as follows:</p>
<pre class="source-code">
class ProductManager {
public:
    void add_product(int id, const std::string&amp; name, uint64_t price) {
        products_[id] = {name, price};
    }
    void remove_product(int id) {
        products_.erase(id);
    }
    void update_product(int id, const std::string&amp; name, uint64_t price) {
        products_[id] = {name, price};
    }
    std::pair&lt;std::string, uint64_t&gt; get_product(int id) {
        return products_[id];
    }
    void list_products() {
        // print the list of products
    }
private:
    std::map&lt;int, std::pair&lt;std::string, uint64_t&gt;&gt; products_;
};
class CartManager {
public:
    void add_to_cart(int product_id, int quantity) {
        cart_[product_id] += quantity;
    }
    void remove_from_cart(int product_id) {
        cart_.erase(product_id);
    }
    void update_cart(int product_id, int quantity) {
        cart_[product_id] = quantity;
    }
    std::map&lt;int, int&gt; get_cart_contents() {
        return cart_;
    }
    void clear_cart() {
        cart_.clear();
    }
private:
    std::map&lt;int, int&gt; cart_;
};
class OrderManager {
public:
    OrderManager(ProductManager&amp; product_manager, CartManager&amp; cart_manager)
        : product_manager_(product_manager), cart_manager_(cart_manager) {}
    uint64_t calculate_cart_total() {
        // calculate cart’s total the same as before
    }
    void place_order() {
        // Process payment, update inventory, send confirmation email, etc.
        // ...
        cart_manager_.clear_cart();
    }
private:
    ProductManager&amp; product_manager_;
    CartManager&amp; cart_manager_;
};
class PersistenceManager {
public:
    PersistenceManager(ProductManager&amp; product_manager)
        : product_manager_(product_manager) {}
    void save_to_file(const std::string&amp; file_name) {
      // saving
    }
    void load_from_file(const std::string&amp; file_name) {
      // loading
    }
private:
    ProductManager&amp; product_manager_;
};</pre>
<p>Eventually, the <code>ECommerce</code> class that owns the new classes and provides proxy methods to<a id="_idIndexMarker158"/> their functionality:</p>
<pre class="source-code">
// include the new classes
class ECommerce {
public:
    void add_product(int id, const std::string&amp; name, uint64_t price) {
        product_manager_.add_product(id, name, price);
    }
    void remove_product(int id) {
        product_manager_.remove_product(id);
    }
    void update_product(int id, const std::string&amp; name, uint64_t price) {
        product_manager_.update_product(id, name, price);
    }
    void list_products() {
        product_manager_.list_products();
    }
    void add_to_cart(int product_id, int quantity) {
        cart_manager_.add_to_cart(product_id, quantity);
    }
    void remove_from_cart(int product_id) {
        cart_manager_.remove_from_cart(product_id);
    }
    void update_cart(int product_id, int quantity) {
        cart_manager_.update_cart(product_id, quantity);
    }
    uint64_t calculate_cart_total() {
        return order_manager_.calculate_cart_total();
    }
    void place_order() {
        order_manager_.place_order();
    }
    void save_to_file(const std::string&amp; filename) {
        persistence_manager_.save_to_file(filename);
    }
    void load_from_file(const std::string&amp; filename) {
        persistence_manager_.load_from_file(filename);
    }
private:
    ProductManager product_manager_;
    CartManager cart_manager_;
    OrderManager order_manager_{product_manager_, cart_manager_};
    PersistenceManager persistence_manager_{product_manager_};
};
int main() {
    ECommerce e_commerce;
    e_commerce.add_product(1, “Laptop”, 999.99);
    e_commerce.add_product(2, “Smartphone”, 699.99);
    e_commerce.add_product(3, “Headphones”, 99.99);
    e_commerce.list_products();
    e_commerce.add_to_cart(1, 1); // Add 1 Laptop to the cart
    e_commerce.add_to_cart(3, 2); // Add 2 Headphones to the cart
    uint64_t cart_total = e_commerce.calculate_cart_total();
    std::cout &lt;&lt; “Cart Total: $” &lt;&lt; cart_total &lt;&lt; std::endl;
    e_commerce.place_order();
    std::cout &lt;&lt; “Order placed successfully!” &lt;&lt; std::endl;
    e_commerce.save_to_file(“products.txt”);
    e_commerce.remove_product(1);
    e_commerce.remove_product(2);
    e_commerce.remove_product(3);
    std::cout &lt;&lt; “Loading products from file...” &lt;&lt; std::endl;
    e_commerce.load_from_file(“products.txt”);
    e_commerce.list_products();
    return 0;
}</pre>
<p>By dividing<a id="_idIndexMarker159"/> the responsibilities among multiple smaller classes, the code becomes more modular, easier to maintain, and better suited to real-life applications. Small changes in the internal business logic of one of the subclasses will not necessitate updates to the <code>ECommerce</code> class. In C++ it might be even more important due to the notorious compilation time issues. It is easier to test these classes separately, or completely replace the implementation of one of them, for example, to save the data not to the disk but to remote storage.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>The pitfalls of magic numbers – a case study on data chunking</h2>
<p>Let’s <a id="_idIndexMarker160"/>consider the following C++ function, <code>send</code>, which aims<a id="_idIndexMarker161"/> to send a block of data in chunks to some destination. Here’s how the function looks:</p>
<pre class="source-code">
#include &lt;cstddef&gt;
#include &lt;algorithm&gt;
// Actually sending the data
void do_send(const std::uint8_t* data, size_t size);
void send(const std::uint8_t* data, size_t size) {
    for (std::size_t position = 0; position &lt; size;) {
        std::size_t length = std::min(size_t{256}, size - position);  // 256 is a magic number
        do_send(data + position, position + length);
        position += length;
    }
}</pre>
<h3>What does the code do?</h3>
<p>The <code>send</code> function takes a pointer to a <code>std::uint8_t</code> array (<code>data</code>) and its size (<code>size</code>). It then proceeds to send this data in chunks to the <code>do_send</code> function, which is responsible for the actual sending process. The chunks have a maximum size of 256 bytes each, as defined within the <code>send</code> function.</p>
<h3>Why is the magic number problematic?</h3>
<p>The number 256 is directly embedded into the code, and there’s no explanation for what it represents. This is a classic example of a <strong class="bold">magic number</strong>. Anyone reading this code would have to guess why 256 was chosen. Is it a hardware limit? A protocol constraint? A performance tuning parameter?</p>
<h3>The constexpr solution</h3>
<p>One way to<a id="_idIndexMarker162"/> improve the clarity of this code is to replace the magic number with a named <code>constexpr</code> variable. For instance, the code could be rewritten like this:</p>
<pre class="source-code">
#include &lt;cstddef&gt;
#include &lt;algorithm&gt;
constexpr std::size_t MAX_DATA_TO_SEND = 256;  // Named constant replaces magic number
// Actually sending the data
void do_send(const std::uint8_t* data, size_t size);
void send(const std::uint8_t* data, size_t size) {
    for (std::size_t position = 0; position &lt; size;) {
        std::size_t length = std::min(MAX_DATA_TO_SEND, size - position);  // Use the named constant
        do_send(data + position, position + length);
        position += length;
    }
}</pre>
<h3>Advantages of using constexpr</h3>
<p>Replacing <a id="_idIndexMarker163"/>the magic number with <code>MAX_DATA_TO_SEND</code> makes it easier to understand why this limit exists. Furthermore, if you have another function, such as <code>read</code>, which also needs to read data in chunks of 256 bytes, using the <code>constexpr</code> variable ensures consistency. If ever the chunk size needs to be changed, you only have to update it in one place, thereby reducing the risk of bugs and inconsistencies.</p>
<p>When dealing <a id="_idIndexMarker164"/>with smelly code, it is essential to understand the underlying causes of the smells and to apply the correct patterns or avoid anti-patterns to refactor the code effectively. For instance, if a code smell involves duplicated code, one should avoid Copy-Paste Programming and instead apply patterns like the Template Method or Strategy pattern to promote code reuse and reduce duplication. Similarly, if a code smell involves tightly coupled modules or classes, you should apply patterns such as Adapter or the Dependency Inversion Principle to reduce coupling and improve modularity.</p>
<p>It is important to remember that refactoring smelly code should be an iterative and incremental process. Developers should continuously review and evaluate their code base for smells, making small, focused changes that gradually improve the code’s quality and maintainability. This approach allows better risk management, as it minimizes the chances of introducing new bugs or issues during the refactoring process. The best way to achieve that is unit tests. They help verify that the refactored code still meets its original requirements and behaves as expected, even after modifications to its internal structure or organization. By having a strong set of tests in place before starting the refactoring process, developers can have confidence that their changes will not negatively impact the application’s behavior. This allows them to focus on improving the code’s design, readability, and maintainability without worrying about unintentionally breaking the functionality. We will explore unit tests in <a href="B19606_13.xhtml#_idTextAnchor260"><em class="italic">Chapter 13</em></a>.</p>
<p>In conclusion, smelly code is a term that describes symptoms in a codebase that indicate potential design or implementation issues. Addressing smelly code involves recognizing and applying appropriate design patterns, as well as avoiding anti-patterns that can be detrimental to code quality. By understanding the underlying causes of code smells and using patterns and anti-patterns effectively, developers can refactor their code base to be more maintainable, readable, and resilient to future changes. Continuous evaluation and incremental refactoring are key to keeping code smells at bay and ensuring a high-quality, efficient codebase that can adapt to evolving requirements and demands.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Legacy code</h1>
<p>Refactoring<a id="_idIndexMarker165"/> legacy C++ code is a significant undertaking that has the potential <a id="_idIndexMarker166"/>to breathe new life into an aging code base. Often, legacy code is written in old dialects of C++, such as C++98 or C++03, which do not take advantage of the new language features and standard library improvements introduced in C++11, C++14, C++17, and C++20.</p>
<p>One common area for modernization is memory management. Legacy C++ code often uses raw pointers for managing dynamic memory, leading to potential issues with memory leaks and null pointer dereferencing. Such code can be refactored to use smart pointers, such as <code>std::unique_ptr</code> and <code>std::shared_ptr</code>, which automatically manage the lifetime of the objects they point to, reducing the risk of memory leaks.</p>
<p>Another modernization opportunity lies in adopting the range-based <code>for</code> loops introduced in C++11. Older loops with explicit iterators or index variables can be replaced with cleaner and more intuitive range-based loops. This not only makes the code easier to read but also reduces the potential for off-by-one and iterator invalidation errors.</p>
<p>As mentioned in previous chapters, legacy C++ code bases often make heavy use of raw arrays and C-style strings. Such code can be refactored to use <code>std::array</code>, <code>std::vector</code>, and <code>std::string</code>, which are safer, more flexible, and provide useful member functions.</p>
<p>Lastly, modern C++ has made significant strides in improving concurrency support with the introduction of <code>std::thread</code>, <code>std::async</code>, and <code>std::future</code> in C++11, followed by further enhancements in subsequent standards. Legacy code that uses platform-specific threading or older concurrency libraries could benefit from refactoring to use these modern, portable concurrency tools.</p>
<p>Let’s start with an example of legacy code that uses <code>pthread</code> to create a new thread. This thread will perform a simple calculation:</p>
<pre class="source-code">
#include &lt;pthread.h&gt;
#include &lt;iostream&gt;
void* calculate(void* arg) {
    int* result = new int(0);
    for (int i = 0; i &lt; 10000; ++i)
        *result += i;
    pthread_exit(result);
}
int main() {
    pthread_t thread;
    if (pthread_create(&amp;thread, nullptr, calculate, nullptr)) {
        std::cerr &lt;&lt; “Error creating thread\n”;
        return 1;
    }
    int* result = nullptr;
    if (pthread_join(thread, (void**)&amp;result)) {
        std::cerr &lt;&lt; “Error joining thread\n”;
        return 2;
    }
    std::cout &lt;&lt; “Result: “ &lt;&lt; *result &lt;&lt; ‘\n’;
    delete result;
    return 0;
}</pre>
<p>Now, we can <a id="_idIndexMarker167"/>refactor this code using <code>std::async</code> from C++11:</p>
<pre class="source-code">
#include &lt;future&gt;
#include &lt;iostream&gt;
int calculate() {
    int result = 0;
    for (int i = 0; i &lt; 10000; ++i)
        result += i;
    return result;
}
int main() {
    std::future&lt;int&gt; future = std::async(std::launch::async, calculate);
    try {
        int result = future.get();
        std::cout &lt;&lt; “Result: “ &lt;&lt; result &lt;&lt; ‘\n’;
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; “Error: “ &lt;&lt; e.what() &lt;&lt; ‘\n’;
        return 1;
    }
    return 0;
}</pre>
<p>In the refactored version, we use <code>std::async</code> to start a new task and <code>std::future::get</code> to obtain the result. The calculate function directly returns the result as an <code>int</code>, which is much simpler and safer than allocating memory in the <code>pthread</code> version. There are a few things to note. The call to <code>std::future::get</code> blocks the execution until the async is done. Additionally, the example uses <code>std::launch::async</code>, which ensures that the task is launched in a separate thread. The C++ 11 standard allows the implementations to decide what is the default policy: a separate thread or <a id="_idIndexMarker168"/>a deferred execution. At the time of writing, Microsoft Visual C++, GCC, and Clang run the task in a separate thread by default. The only difference is that while GCC and Clang create a new thread per task, Microsoft Visual C++ reuses threads from an internal thread pool. The error handling is also simpler, as any exception thrown by the calculate function will be caught by <code>std::future::get</code>.</p>
<p>Often legacy code uses object-oriented wrappers around <code>pthread</code> and other platform-specific APIs. Replacing them with the standard C++ implementation can decrease the amount of code that the developers have to support and make code more portable. However, multi-threading is a complex topic, so if the existing code has some rich thread-related logic, it is important to make sure that it stays intact.</p>
<p>The built-in algorithms provided with modern C++ can improve legacy code readability and maintenance. Often, developers need to check whether an array contains a certain value. Pre-C++11 language allowed doing something like this:</p>
<pre class="source-code">
#include &lt;vector&gt;
#include &lt;iostream&gt;
int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6};
    bool has_even = false;
    for (size_t i = 0; i &lt; numbers.size(); ++i) {
        if (numbers[i] % 2 == 0) {
            has_even = true;
            break;
        }
    }
    if (has_even)
        std::cout &lt;&lt; “The vector contains an even number.\n”;
    else
        std::cout &lt;&lt; “The vector does not contain any even numbers.\n”;
    return 0;
}</pre>
<p>With C++11, we <a id="_idIndexMarker169"/>can use <code>std::any_of</code>, a new algorithm that checks if any element in a range satisfies a predicate. This allows us to write the code more concisely and expressively:</p>
<pre class="source-code">
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6};
    bool has_even = std::any_of(numbers.begin(), numbers.end(),
                                [](int n) { return n % 2 == 0; });
    if (has_even)
        std::cout &lt;&lt; “The vector contains an even number.\n”;
    else
        std::cout &lt;&lt; “The vector does not contain any even numbers.\n”;
    return 0;
}</pre>
<p>In this refactored <a id="_idIndexMarker170"/>version, we use a lambda function as the predicate for <code>std::any_of</code>. This makes the code more concise and the intention clearer. Algorithms such as <code>std::all_of`` </code>and <code>std::none_of`</code> allows to clearly express similar checks</p>
<p>Remember, refactoring should be done incrementally, with each change tested thoroughly to ensure it doesn’t introduce new bugs or regressions. It can be a time-consuming process, but the benefits in terms of improved code quality, maintainability, and performance can be substantial.</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Summary</h1>
<p>In this chapter, we’ve explored some of the key design patterns that can be instrumental in refactoring legacy C++ code, including the strategy pattern, template method pattern, and observer pattern. These patterns, when applied judiciously, can significantly improve the structure of your code, making it more flexible, maintainable, and resilient to change.</p>
<p>While we’ve provided practical, real-world examples to illustrate the use of these patterns, this is by no means an exhaustive treatment. Design patterns are a vast and deep subject, with many more patterns and variations to explore. For a more comprehensive understanding of design patterns, I strongly recommend you delve into the seminal work <em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em> by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, often referred to as the <em class="italic">Gang of </em><em class="italic">Four</em> book.</p>
<p>In addition, to keep abreast of the most recent developments and emerging best practices, consider resources such as <em class="italic">Hands-On Design Patterns with C++: Solve common C++ problems with modern design patterns and build robust applications</em> by Fedor G. Pikus, and <em class="italic">C++ Concurrency in Action</em> by Anthony Williams. These works will provide you with a broader perspective and deeper understanding of the powerful role design patterns play in crafting high-quality C++ software.</p>
<p>Remember, the goal of refactoring and applying design patterns is not just to write code that works, but to write code that is clean, easy to understand, easy to modify, and easy to maintain in the long run.</p>
<p>In the upcoming chapter, we’ll be delving deeper into the world of C++, focusing specifically on naming conventions, their importance in writing clean and maintainable code, and best practices established by the community.</p>
</div>
</body></html>