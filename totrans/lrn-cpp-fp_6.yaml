- en: Optimizing Code with Metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed the optimizing techniques using lazy evaluation in the previous
    chapter, and used the delaying process, caching technique, and memoization to
    make our code run fast. In this chapter, we will optimize the code using **metaprogramming**,
    where we will create a code that will create more code. The topics we will discuss
    in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The part that builds the template metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring flow control into template metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the code in the compile-time execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages and disadvantages of template metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to say this is that metaprogramming is a technique that creates
    a code by using a code. Implementing metaprogramming, we write a computer program
    that manipulates the other programs and treats them as its data. In addition,
    templates are a compile-time mechanism in C++ that is **Turing-complete**, which
    means any computation expressible by a computer program can be computed, in some
    form, by a template metaprogram before runtime. It also uses recursion a lot and
    has immutable variables. So, in metaprogramming, we create code that will run
    when the code is compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessing the code using a macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start our discussion on metaprogramming, let''s go back to the era when
    the ANSI C programming language was a popular language. For simplicity, we used
    the C preprocessor by creating a macro. The C parameterized macro is also known
    as **metafunctions**, and is one of the examples of metaprogramming. Consider
    the following parameterized macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the C++ programming language has a drawback compatibility to the C language,
    we can compile the preceding macro using our C++ compiler. Let''s create the code
    to consume the preceding macro, which will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding `macro.cpp` code, we pass two arguments to the
    `MAX` macro since it is a parameterized macro, which means the parameter can be
    obtained from the users. If we run the preceding code, we should see the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3415c09-ba2c-4b3c-9377-afd18f2d9d30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we discussed at the beginning of this chapter, metaprogramming is a code
    that will run in compile time. By using a macro in the preceding code, we can
    demonstrate there''s a new code generated from the `MAX` macro. The preprocessor
    will parse the macro in compile time and bring the new code. In compile time,
    the compiler modifies the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides a one line macro preprocessor, we can also generate a multiline macro
    metafunction. To achieve this, we can use the backslash character at the end of
    the line. Let''s suppose we need to swap the two values. We can create a parameterized
    macro named `SWAP` and consume it like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we will create a multiline preprocessor
    macro and use backslash characters at the end of each line. Each time we invoke
    the `SWAP` parameterized macro, it will then be replaced with the implementation
    of the macro. We will see the following output on the console if we run the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/502d5c3f-23b1-4998-b4c8-04ea9ef089bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we have a basic understanding of the metaprogramming, especially in metafunction,
    we can move further in the next topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use parenthesis for each variable in every implementation of the macro preprocessor
    because the preprocessor is simply replacing our code with the implementation
    of the macro. Let''s suppose we have the following macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MULTIPLY(a,b) (a * b)` It won''t be a problem if we pass the number as the
    parameters. However, if we pass an operation as the argument, a problem will occur.
    For instance, if we use the `MULTIPLY` macro as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MULTIPLY(x+2,y+5);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the compiler will replace it as `(x+2*y+5)`. This happens because the
    macro just replaces the `a` variable with the `x + 2` expression and the `b` variable
    with the `y + 5` expression, with any additional parentheses. And because the
    order of multiplication is higher than addition, we will have got the result as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(x+2y+5)`'
  prefs: []
  type: TYPE_NORMAL
- en: And that is not what we expect. As a result, the best approach is to use parenthesis
    in each variable of the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting template metaprogramming in the Standard Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed the Standard Library in [Chapter 1](58c8c3cc-432a-4664-be4d-a78917b16f15.xhtml),
    *Diving into Modern C++*, and dealt with it in the previous chapter too. The Standard
    Library provided in the C++ language is mostly a template that contains an incomplete
    function. However, it will be used to generate complete functions. The template
    metaprogramming is the C++ template to generate C++ types and code in compile
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s pick up one of the classes in the Standard Library--the `Array` class.
    In the `Array` class, we can define a data type for it. When we instance the array,
    the compiler actually generates the code for an array of the data type we define.
    Now, let''s try to build a simple `Array` template implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we instance the `char` and `int` arrays as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'What the compiler does is it creates these two implementations of the template
    based on the data type we define. Although we won''t see this in the code, the
    compiler actually creates the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code snippet, the template metaprogramming is
    a code that creates another code in compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Building the template metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we go further in the template metaprogramming discussion, it's better
    if we discuss the skeleton that builds the template metaprogramming. There are
    four factors that form the template metaprogramming--**type**, **value**, **branch**,
    and **recursion**. In this topic, we will dig into the factors that form the template.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a value to the variable in the template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we discussed the concept of metafunction
    when we talked about the macro preprocessor. In the macro preprocessor, we explicitly
    manipulate the source code; in this case, the macro (metafunction) manipulates
    the source code. In contrast, we work with types in C++ template metaprogramming.
    This means the metafunction is a function that works with types. So, the better
    approach to use template metaprogramming is working with type parameters only
    when possible. When we are talking about the variables in template metaprogramming,
    it''s actually not a variable since the value on it cannot be modified. What we
    need from the variable is its name so we can access it. Because we will code with
    types, the named values are `typedef`, as we can see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the preceding code, we store the `int` type to the `valueDataType`
    alias name so we can access the data type using the `valueDataType` variable.
    If we need to store a value instead of the data type to the variable, we can use
    `enum` so it will be the data member of the `enum` itself. Let''s take a look
    at the following code snippet if we want to store the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Based on the preceding code snippet, we can now access the `value` variable
    to fetch its value.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping a function to the input parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add the variable to the template metaprogramming. Now, what we have
    to do next is retrieve the user parameters and map them to a function. Let''s
    suppose we want to develop a `Multiplexer` function that will multiply two values
    and we have to use the template metaprogramming. The following code snippet can
    be used to solve this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code snippet, the template requires two arguments,
    `A` and `B`, from the user, and it will use them to get the value of `result`
    variable by multiplying these two parameters. We can access the result variable
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If we run the preceding code snippet, the `i` variable will store `6` since
    it will calculate `2` times `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the correct process based on the condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we have more than one function, we have to choose one over the others
    based on certain conditions. We can construct the conditional branch by providing
    two alternative specializations of the `template` class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding `template` code, we have two templates that
    have `X` and `A`/`B` as their type. When the template has only a single type,
    that is, `typename X`, it means that the two types (`CheckingType <X, X>`) we
    compare are exactly the same. Otherwise, these two data types are different. The
    following code snippet can be used to consume the two preceding templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code snippet, we try to compare the `UnknownType`
    data type with the `int` type. The `UnknownType` data type might be coming from
    the other process. Then, we can decide the next process we want to run by comparing
    these two types using templates.
  prefs: []
  type: TYPE_NORMAL
- en: Up to here, you might wonder how template multiprogramming will help us make
    code optimization. Soon we will use the template metaprogramming to optimize code.
    However, we need to discuss other things that will solidify our knowledge in template
    multiprogramming. For now, please be patient and keep reading.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating the process recursively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have successfully added value and data type to the template, then created
    a branch to decide the next process based on the current condition. Another thing
    we have to consider in the basic template is repeating the process. However, since
    the variable in the template is immutable, we cannot iterate the sequence. Instead,
    we have to recur the process as we discussed in [Chapter 4](7c3fb034-5951-4003-905f-48dd745a1c6f.xhtml),
    *Repeating Method Invocation Using Recursive Algorithm*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we are developing a template to calculate the factorial value.
    The first thing we have to do is develop a general template that passes the `I`
    value to the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we can obtain the value of the factorial
    by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `I` is an integer number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to develop a template to ensure that it doesn''t end up with
    an infinite loop. We can create the following template that passes zero (`0`)
    as a parameter to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a pair of templates that will generate the value of the factorial
    in compile time. The following is a sample code to get the value of `Factorial(10)`
    in compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we run the preceding code, we will get `3628800` as a result of the factorial
    of `10`.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a type in compile-time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in the preceding topic, `type` is a basic part of a template.
    However, we can select a certain type based on the input from the user. Let''s
    create a template that can decide what type should be used in the variable. The
    following `types.cpp` code will show the implementation of the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, we have a template named `datatype`. This
    template can be used to select the `type` we pass to it. We can use the `using`
    keyword to assign a variable to a `type`. From the preceding `types.cpp` code,
    we will assign a `t` variable to `type` from the `datatype` template. The `t`
    variable now will be `int` since we passed the `int` data type to the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a code to select the correct data type based on the current
    condition. We will have an `IfElseDataType` template that takes three arguments
    which are `predicate`, the data type when the `predicate` parameter is true, and
    the data type when the `predicate` parameter is false. The code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, by having the `IfElseDataType` template, we can select the correct type
    to the variable based on the condition we have. Let''s suppose we want to assign
    `2147483647` to a variable so we can check if it''s a short number. If so, `myVar`
    will be of type `short`, otherwise, it will be `int`. Moreover, since the maximum
    value of `short` type is `32767`, by giving the predicate as `SHRT_MAX == 2147483647`
    will be resulting `FALSE`. Therefore, the type of `myVar` will be an `int` type,
    as we can see in the following output that will appear on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9f65a57-9612-429f-82b7-55741f74cc50.png)'
  prefs: []
  type: TYPE_IMG
- en: Flow control with template metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code flow is an important aspect in coding a program. In many programming languages,
    they have an `if-else`, `switch`, and `do-while` statement to arrange the flow
    of the code. Now, let's refactor the usual flow of code to become a template-based
    flow. We will start by using the `if-else` statement, followed by the `switch`
    statement, and finally ending with the `do-while` statement, all in templates.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding the next process by the current condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it''s time to use the template as we discussed previously. Let''s suppose
    we have two functions that we have to choose by a certain condition. What we usually
    do is use the `if-else` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we have two functions--`TrueStatement()`
    and `FalseStatement()`. We also have a condition in the code--`2 + 3 == 5`. And
    since the condition is `TRUE`, then the `TrueStatement()` function will be run
    as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e5c6760-bbad-42e6-9208-48d2213aca67.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s refactor the preceding `condition.cpp` code. We will create three
    templates here. First, the template initialization that inputs the condition as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create two templates for each condition--`TRUE` or `FALSE`. The name
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Each template in the preceding code snippet will run the functions we have
    created before--the `TrueStatement()` and `FalseStatement()` functions. And we
    will get the complete code as the following `conditionmeta.cpp` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we put the condition on the bracket of the `IfElse` template,
    then call the `func()` method inside the template. If we run the `conditionmeta.cpp`
    code, we will get the exact same output such as the `condition.cpp` code, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52dfab6d-8e80-4036-9e19-95f40d013725.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have the `if-else` statement to flow our code in the template metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the correct statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++ programming, and other programming languages as well, we use the `switch`
    statement to select a certain process based on the value we give to the `switch`
    statement. If the value matches with the one of the switch case, it will run the
    process under that case. Let''s take a look at the following `switch.cpp` code
    that implements the `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we have a function named `Square()` that
    takes an argument. The argument we pass to it is based on the value that we give
    to the switch statement. Since the value we pass to switch is `2`, the `Square(2)`
    method will be run. The following screenshot is what we will see on the console
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb934a6e-293e-47b9-b771-cb7d9da4832f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To refactor the `switch.cpp` code to template metaprogramming, we have to create
    three templates that consist of the function we plan to run. First, we will create
    the initialization template to retrieve the value from the user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding initialization template will also be used for the default value.
    Next, we will add two templates for each possible value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Each preceding template will run the `Square()` function and pass the argument
    based on the value of the template. The complete code is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we do the same as `conditionmeta.cpp`--we call the `func()`
    method inside the template to run the selected function. The value for this `switch-case`
    condition is the template we put in the angle bracket. If we run the preceding
    `switchmeta.cpp` code, we will see the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eeb896aa-2598-4995-b3b0-bbb61386f762.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, we've got the exact same output for
    `switchmeta.cpp` code as compared to the `switch.cpp` code. Thus, we have successfully
    refactored the `switch.cpp` code into the template metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Looping the process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We usually use the `do-while` loop when we iterate something. Let''s suppose
    we need to print certain numbers until it reaches zero (`0`). The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we will print the number `100`, decrease
    its value, and print again. It will always run until the number reaches zero (`0`).
    The output on the console should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a84c23b-dd08-4dfc-99a6-273c36918e06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s refactor it to the template metaprogramming. Here, we need only
    two templates to achieve the `do-while` loop in template metaprogramming. First,
    we will create the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The limit in the preceding code is the value that is passed to the `do-while`
    loop. And, to not make the loop become an infinite loop, we have to design the
    `DoWhile` template when it has reached zero (`0`), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding template will do nothing since it''s used only to break the loop.
    The complete refactoring of the `do-while` loop is like the following `loopmeta.cpp`
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We then call the `func()` method inside the template to run our desired function.
    And, if we run the code, we will see the following output on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5fd496c-ddac-483e-b0db-523307b3c91e.png)'
  prefs: []
  type: TYPE_IMG
- en: Again, we have successfully refactored the `loop.cpp` code into `loopmeta.cpp`
    code since both have the exact same output.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the code in compile-time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier, template metaprogramming will run the code in compile-time
    by creating a new code. Now, let's see how we can get the compile-time constant
    and generate a compile-time class in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a compile-time constant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To retrieve a compile-time constant, let''s create a code that has the template
    for a Fibonacci algorithm in it. We will consume the template so the compiler
    will provide the value in compile time. The code should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, the value variable in the Fibonacci template
    will provide a compile-time constant. And if we run the preceding code, we will
    see the following output on the console screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/015e83df-4905-4a3c-aa49-c8f233a2282c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have `75025` that is generated by the compiler as a compile-time constant.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the class using a compile-time class generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides the generation of a compile-time constant, we will also generate the
    class in compile time. Let''s suppose we have a template to find out the prime
    number in the range `0` to `X`. The following `isprimemeta.cpp` code will explain
    the implementation of the template metaprogramming to find the prime number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two kinds of templates with different roles--the **prime checker**,
    that ensures the number that is passed is a prime number, and the **printer**,
    that displays the prime number to the console. The compiler then generates the
    class in compile-time when the code accesses `PrimeNumberPrinter<500> printer`
    and `printer.func()`. And when we run the preceding `isprimemeta.cpp` code, we
    will see the following output on the console screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1377d14f-9287-4e54-93b8-39bf5906fe43.png)'
  prefs: []
  type: TYPE_IMG
- en: Since we pass `500` to the template, we will get the prime number from `0` to
    `500`. The preceding output has proven that the compiler has successfully generated
    a compile-time class so we can get the correct value.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks of metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After our discussion about template metaprogramming, the following are the
    advantages we derive:'
  prefs: []
  type: TYPE_NORMAL
- en: Template metaprogramming has no side effect since it is immutable, so we cannot
    modify an existing type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is better code readability compared to code that does not implement metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It reduces repetition of the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although we can gain benefits from template metaprogramming, there are several
    disadvantages, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is quite complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compilation time takes longer since we now execute code during compile-time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler can optimize the generated code much better and perform inlining,
    for instance, the C `qsort()` function and the C++ `sort` template. In C, the
    `qsort()` function takes a pointer to a comparison function, so there will be
    one copy of the `qsort` code that is not inlined. It will make a call through
    the pointer to the comparison routine. In C++, `std::sort` is a template, and
    it can take a `functor` object as a comparator. There is a different copy of `std::sort`
    for each different type used as a comparator. If we use a `functor` class with
    an overloaded `operator()` function, the call to the comparator can easily be
    inlined into this copy of `std::sort`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metaprogramming, especially template metaprogramming, creates new code for us
    automatically so we don't need to write a lot of code in our source. By using
    template metaprogramming, we can refactor the flow control of our code as well
    as run the code in compile-time execution.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about concurrency techniques that will bring
    a responsive enhancement to the application that we build. We can run the processes
    in our code simultaneously using the parallelism technique.
  prefs: []
  type: TYPE_NORMAL
