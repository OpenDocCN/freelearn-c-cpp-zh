["```cpp\n    void framebuffer_size_callback(GLFWwindow* window, int width, int height)\n    {\n    ```", "```cpp\n      const float fovY = 45.0f;\n      const float front = 0.1f;\n      const float back = 128.0f;\n      float ratio = 1.0f;\n      if (height > 0)\n        ratio = (float) width / (float) height;\n    ```", "```cpp\n      glViewport(0, 0, width, height);\n    ```", "```cpp\n      glMatrixMode(GL_PROJECTION);\n    ```", "```cpp\n      glLoadIdentity();\n    ```", "```cpp\n      gluPerspective(fovY, ratio, front, back);\n    }\n    ```", "```cpp\n  const double DEG2RAD = 3.14159265 / 180;\n  // tangent of half fovY\n  double tangent = tan(fovY/2 * DEG2RAD);  \n  // half height of near plane\n  double height_f = front * tangent;     \n  // half width of near plane\n  double width_f = height_f * ratio;   \n\n  //Create the projection matrix based on the near clipping \n  //plane and the location of the corners\n  glFrustum(-width_f, width_f, -height_f, height_f, front, back);\n}\n```", "```cpp\n#include <GLFW/glfw3.h>\n...\n\n// Window size\nconst int WINDOWS_WIDTH = 1280;\nconst int WINDOWS_HEIGHT = 720;\n\n// NEW: Callback functions and helper functions for 3D plot\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height);\nvoid draw2DHeatMap(const Data *data, int num_points);\nvoid gaussianDemo(float sigma);\n...\n\nint main(void)\n{\n  GLFWwindow* window;\n  int width, height;\n  if (!glfwInit()){\n    exit(EXIT_FAILURE);\n  }\n  window = glfwCreateWindow(WINDOWS_WIDTH, WINDOWS_HEIGHT, \"Chapter 3: 3D Data Plotting\", NULL, NULL);\n  if (!window){\n    glfwTerminate();\n    exit(EXIT_FAILURE);\n  }\n  glfwMakeContextCurrent(window);\n  glfwSwapInterval(1);\n  // NEW: Callback functions\n  ...\n\n  //enable anti-aliasing\n  glEnable(GL_BLEND);\n  //smooth the points\n  glEnable(GL_LINE_SMOOTH);\n  //smooth the lines\n  glEnable(GL_POINT_SMOOTH);\n  glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);\n  glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);\n  //needed for alpha blending\n  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n  glEnable(GL_ALPHA_TEST) ;\n  // NEW: Initialize parameters for perspective rendering\n  ...\n  while (!glfwWindowShouldClose(window))\n  {\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);\n    // NEW: Perspective rendering\n    ...\n  }\n  glfwDestroyWindow(window);\n  glfwTerminate();\n  exit(EXIT_SUCCESS);\n}\n```", "```cpp\nglfwGetFramebufferSize(window, &width, &height);\nframebuffer_size_callback(window, width, height);\n```", "```cpp\nGLfloat alpha=210.0f, beta=-70.0f, zoom=2.0f;\n```", "```cpp\nfloat sigma = 0.1f;\nfloat sign = 1.0f;\nfloat step_size = 0.01f;\n```", "```cpp\n    glMatrixMode(GL_MODELVIEW);\n    ```", "```cpp\n    glLoadIdentity();\n    glTranslatef(0.0, 0.0, -2.0);\n    // rotate by beta degrees around the x-axis\n    glRotatef(beta, 1.0, 0.0, 0.0);\n    // rotate by alpha degrees around the z-axis\n    glRotatef(alpha, 0.0, 0.0, 1.0);\n    ```", "```cpp\n    drawOrigin();\n    sigma=sigma+sign*step_size;\n    if(sigma>1.0f){\n      sign = -1.0f;\n    }\n    if(sigma<0.1){\n      sign = 1.0f;\n    }\n    gaussianDemo(sigma);\n    ```", "```cpp\n    void drawOrigin(){\n    ```", "```cpp\n      glLineWidth(4.0f);\n      glBegin(GL_LINES);\n      float transparency = 0.5f;\n\n      //draw a red line for the x-axis\n      glColor4f(1.0f, 0.0f, 0.0f, transparency);\n      glVertex3f(0.0f, 0.0f, 0.0f);\n      glColor4f(1.0f, 0.0f, 0.0f, transparency);\n      glVertex3f(0.3f, 0.0f, 0.0f);\n\n      //draw a green line for the y-axis\n      glColor4f(0.0f, 1.0f, 0.0f, transparency);\n      glVertex3f(0.0f, 0.0f, 0.0f);\n      glColor4f(0.0f, 1.0f, 0.0f, transparency);\n      glVertex3f(0.0f, 0.0f, 0.3f);\n\n      //draw a blue line for the z-axis\n      glColor4f(0.0f, 0.0f, 1.0f, transparency);\n      glVertex3f(0.0f, 0.0f, 0.0f);\n      glColor4f(0.0f, 0.0f, 1.0f, transparency);\n      glVertex3f(0.0f, 0.3f, 0.0f);\n      glEnd();\n    }\n    ```", "```cpp\n    void gaussianDemo(float sigma){\n      const int grid_x = 400;\n      const int grid_y = 400;\n      const int num_points = grid_x*grid_y;\n      Data *data=(Data*)malloc(sizeof(Data)*num_points);\n      int data_counter=0;\n\n      //standard deviation\n      const float sigma2=sigma*sigma;\n      //amplitude\n      const float sigma_const = 10.0f*(sigma2*2.0f*(float)M_PI);\n\n      for(float x = -grid_x/2.0f; x<grid_x/2.0f; x+=1.0f){\n       for(float y = -grid_y/2.0f; y<grid_y/2.0f; y+=1.0f){\n          float x_data = 2.0f*x/grid_x;\n          float y_data = 2.0f*y/grid_y;\n          //Set the mean to 0\n          float z_data = exp(-0.5f*(x_data*x_data)/(sigma2) -0.5f*(y_data*y_data)/(sigma2)) /sigma_const;\n          data[data_counter].x = x_data;\n          data[data_counter].y = y_data;\n          data[data_counter].z = z_data;\n          data_counter++;\n        }\n      }\n      draw2DHeatMap(data, num_points);\n      free(data);\n    }\n    ```", "```cpp\n    void draw2DHeatMap(const Data *data, int num_points){\n      glPointSize(3.0f);\n      glBegin(GL_POINTS);\n      float transparency = 0.25f;\n      //locate the maximum and minimum values in the dataset\n      float max_value=-999.9f;\n      float min_value=999.9f;\n      for(int i=0; i<num_points; i++){\n        Data d = data[i];\n        if(d.z > max_value)\n          max_value = d.z;\n        if(d.z < min_value)\n          min_value = d.z;\n      }\n      float halfmax = (max_value + min_value) / 2;\n      //display the result\n      for(int i = 0; i<num_points; i++){\n        Data d = data[i];\n        float value = d.z;\n        float b = 1.0f - value/halfmax;\n        float r = value/halfmax - 1.0f;\n        if(b < 0)\n          b=0;\n        if(r < 0)\n          r=0;\n        float g = 1.0f - b - r;\n        glColor4f(r, g, b, transparency);\n        glVertex3f(d.x, d.y, d.z);\n      }\n      glEnd();\n    }\n    ```", "```cpp\n    GLboolean locked = GL_FALSE;\n    GLfloat alpha=210.0f, beta=-70.0f, zoom=2.0f;\n    ```", "```cpp\n    void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)\n    {\n    ```", "```cpp\n      if (action != GLFW_PRESS)\n        return;\n    ```", "```cpp\n      switch (key)\n      {\n    ```", "```cpp\n        case GLFW_KEY_ESCAPE:\n          glfwSetWindowShouldClose(window, GL_TRUE);\n          break;\n    ```", "```cpp\n        case GLFW_KEY_SPACE:\n          freeze=!freeze;\n          break;\n    ```", "```cpp\n        case GLFW_KEY_LEFT:\n          alpha += 5.0f;\n          break;\n        case GLFW_KEY_RIGHT:\n          alpha -= 5.0f;\n          break;\n        case GLFW_KEY_UP:\n          beta -= 5.0f;\n          break;\n        case GLFW_KEY_DOWN:\n          beta += 5.0f;\n          break;\n    ```", "```cpp\n        case GLFW_KEY_PAGE_UP:\n          zoom -= 0.25f;\n          if (zoom < 0.0f)\n            zoom = 0.0f;\n            break;\n        case GLFW_KEY_PAGE_DOWN:\n          zoom += 0.25f;\n          break;\n          default:\n          break;\n      }\n    }\n    ```", "```cpp\n    void mouse_button_callback(GLFWwindow* window, int button, int action, int mods)\n    {\n    ```", "```cpp\n      if (button != GLFW_MOUSE_BUTTON_LEFT)\n        return;\n    ```", "```cpp\n      if (action == GLFW_PRESS)\n      {\n        glfwSetInputMode(window, GLFW_CURSOR,   GLFW_CURSOR_DISABLED);\n        locked = GL_TRUE;\n      }\n      else\n      {\n        locked = GL_FALSE;\n        glfwSetInputMode(window, GLFW_CURSOR,GLFW_CURSOR_NORMAL);\n      }\n    }\n    ```", "```cpp\n    void cursor_position_callback(GLFWwindow* window, double x, double y)\n    {\n    ```", "```cpp\n      //if the mouse button is pressed\n      if (locked)\n      {\n        alpha += (GLfloat) (x - cursorX) / 10.0f;\n        beta += (GLfloat) (y - cursorY) / 10.0f;\n      }\n      //update the cursor position\n      cursorX = (int) x;\n      cursorY = (int) y;\n    }\n    ```", "```cpp\n    void scroll_callback(GLFWwindow* window, double x, double y)\n    {\n    ```", "```cpp\n      zoom += (float) y / 4.0f;\n      if (zoom < 0.0f)\n        zoom = 0.0f;\n    }\n    ```", "```cpp\n//keyboard input callback\nglfwSetKeyCallback(window, key_callback);\n\n//framebuffer size callback  \nglfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n\n//mouse button callback\nglfwSetMouseButtonCallback(window, mouse_button_callback);\n\n//mouse movement callback\nglfwSetCursorPosCallback(window, cursor_position_callback);\n\n//mouse scroll callback\nglfwSetScrollCallback(window, scroll_callback);\n```", "```cpp\n    #define MCML_SIZE_X 50\n    #define MCML_SIZE_Y 50\n    #define MCML_SIZE_Z 200\n    float mcml_data[MCML_SIZE_X][MCML_SIZE_Y][MCML_SIZE_Z];\n    Vertex mcml_vertices[MCML_SIZE_X][MCML_SIZE_Y][MCML_SIZE_Z];\n    float max_data, min_data;\n    int slice_x = 0, slice_z = 0, slice_y = 0;\n    float point_size=5.0f;\n\n    //load the data from a text file\n    void loadMCML(){\n      FILE *ifp;\n      //open the file for reading\n      ifp = fopen(\"MCML_output.txt\", \"r\");\n      if (ifp == NULL) {\n        fprintf(stderr, \"ERROR: Can't open MCML Data file!\\n\");\n        exit(1);\n      }\n      float data;\n      float max=0, min=9999999;\n      for(int x=0; x<MCML_SIZE_X; x++){\n        for(int z=0; z<MCML_SIZE_Z; z++){\n          for(int y=0; y<MCML_SIZE_Y; y++){\n            if (fscanf(ifp, \"%f\\n\", &data) == EOF){\n              fprintf(stderr, \"ERROR: Missing MCML Data file!\\n\");\n              exit(1);\n            }\n            //store the log compressed data point\n            data = log(data+1);\n            mcml_data[x][y][z]=data;\n            //find the max and min from the data set for heatmap\n            if(data>max){\n              max=data;\n            }\n            if(data<min){\n              min=data;\n            }\n            //normalize the coordinates\n            mcml_vertices[x][y][z].x=(float)(x-MCML_SIZE_X/2.0f)/MCML_SIZE_X;\n            mcml_vertices[x][y][z].y=(float)(y-MCML_SIZE_Y/2.0f)/MCML_SIZE_Y;\n            mcml_vertices[x][y][z].z=(float)(z-MCML_SIZE_Z/2.0f)/MCML_SIZE_Z*2.0f;\n          }\n        }\n      }\n      fclose(ifp);\n      max_data = max;\n      min_data = min;\n      halfmax= (max+min)/2.0f;\n    ```", "```cpp\n      //store the heat map representation of the data\n      for(int z=0; z<MCML_SIZE_Z; z++){\n        for(int x=0; x<MCML_SIZE_X; x++){\n          for(int y=0; y<MCML_SIZE_Y; y++){\n            float value = mcml_data[x][y][z];\n            COLOUR c = GetColour(value, min_data,max_data);\n            mcml_vertices[x][y][z].r=c.r;\n            mcml_vertices[x][y][z].g=c.g;\n            mcml_vertices[x][y][z].b=c.b;\n          }\n        }\n      }\n    }\n    ```", "```cpp\n    Color getHeatMapColor(float value, float min, float max)\n    {\n      //remapping the value to the JET color scheme\n      Color c = {1.0f, 1.0f, 1.0f}; // default value\n      float dv;\n      //clamp the data \n      if (value < min)\n        value = min;\n      if (value > max)\n        value = max;\n      range = max - min;\n      //the first region (0%-25%)\n      if (value < (min + 0.25f * range)) {\n        c.r = 0.0f;\n        c.g = 4.0f * (value - min) / range;\n      }\n      //the second region of value (25%-50%)\n      else if (value < (min + 0.5f * range)) {\n        c.r = 0.0f;\n        c.b = 1.0f + 4.0f * (min + 0.25f * range - value) / range;\n      }\n      //the third region of value (50%-75%)\n      else if (value < (min + 0.75f * range)) {\n        c.r = 4.0f * (value - min - 0.5f * range) / range;\n        c.b = 0.0f;\n      }\n      //the fourth region (75%-100%)\n      else {\n        c.g = 1.0f + 4.0f * (min + 0.75f * range - value) / range;\n        c.b = 0.0f;\n      }\n      return(c);\n    }\n    ```", "```cpp\n    void drawMCMLPoints(){\n      glPointSize(point_size);\n      glBegin(GL_POINTS);\n      for(int z=0; z<MCML_SIZE_Z; z++){\n        for(int x=0; x<MCML_SIZE_X; x++){\n          for(int y=0; y<MCML_SIZE_Y; y++){\n            glColor4f(mcml_vertices[x][y][z].r,mcml_vertices[x][y][z].g,mcml_vertices[x][y][z].b, 0.15f);\n            glVertex3f(mcml_vertices[x][y][z].x,mcml_vertices[x][y][z].y,mcml_vertices[x][y][z].z);\n          }\n        }\n      }\n      glEnd();\n    }\n    ```", "```cpp\n    void drawMCMLSlices(){\n      glPointSize(10.0f);\n      glBegin(GL_POINTS);\n\n      //display data on xy plane\n      for(int x=0; x<MCML_SIZE_X; x++){\n        for(int y=0; y<MCML_SIZE_Y; y++){\n          int z = slice_z;\n          glColor4f(mcml_vertices[x][y][z].r,mcml_vertices[x][y][z].g,mcml_vertices[x][y][z].b, 0.9f);\n          glVertex3f(mcml_vertices[x][y][z].x,mcml_vertices[x][y][z].y,mcml_vertices[x][y][z].z);\n        }\n      }\n\n      //display data on yz plane\n      for(int z=0; z<MCML_SIZE_Z; z++){\n        for(int y=0; y<MCML_SIZE_Y; y++){\n          int x = slice_x;\n          glColor4f(mcml_vertices[x][y][z].r,mcml_vertices[x][y][z].g,mcml_vertices[x][y][z].b, 0.9f);\n          glVertex3f(mcml_vertices[x][y][z].x,mcml_vertices[x][y][z].y,mcml_vertices[x][y][z].z);\n        }\n      }\n\n      //display data on xz plane\n      for(int z=0; z<MCML_SIZE_Z; z++){\n        for(int x=0; x<MCML_SIZE_X; x++){\n          int y = slice_y;\n          glColor4f(mcml_vertices[x][y][z].r,mcml_vertices[x][y][z].g,mcml_vertices[x][y][z].b, 0.9f);\n          glVertex3f(mcml_vertices[x][y][z].x,mcml_vertices[x][y][z].y,mcml_vertices[x][y][z].z);\n        }\n      }\n      glEnd();\n    }\n    ```", "```cpp\n    void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)\n    {\n      if (action != GLFW_PRESS)\n        return;\n      switch (key)\n      {\n        case GLFW_KEY_ESCAPE:\n          glfwSetWindowShouldClose(window, GL_TRUE);\n          break;\n        case GLFW_KEY_P:\n          point_size+=0.5;\n          break;\n        case GLFW_KEY_O:\n          point_size-=0.5;\n          break;\n        case GLFW_KEY_A:\n          slice_y -=1;\n          if(slice_y < 0)\n            slice_y = 0;\n          break;\n        case GLFW_KEY_D:\n          slice_y +=1;\n          if(slice_y >= MCML_SIZE_Y-1)\n            slice_y = MCML_SIZE_Y-1;\n          break;\n        case GLFW_KEY_W:\n          slice_z +=1;\n          if(slice_z >= MCML_SIZE_Z-1)\n            slice_z = MCML_SIZE_Z-1;\n          break;\n        case GLFW_KEY_S:\n          slice_z -= 1;\n          if (slice_z < 0)\n            slice_z = 0;\n          break;\n        case GLFW_KEY_E:\n          slice_x -=1;\n          if(slice_x < 0)\n            slice_x = 0;\n          break;\n        case GLFW_KEY_Q:\n          slice_x +=1;\n          if(slice_x >= MCML_SIZE_X-1)\n            slice_x = MCML_SIZE_X-1;\n          break;\n        case GLFW_KEY_PAGE_UP:\n          zoom -= 0.25f;\n          if (zoom < 0.f)\n            zoom = 0.f;\n          break;\n        case GLFW_KEY_PAGE_DOWN:\n          zoom += 0.25f;\n          break;\n        default:\n          break;\n      }\n    }\n    ```", "```cpp\n    while (!glfwWindowShouldClose(window))\n    {\n      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n      glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n\n      glMatrixMode(GL_MODELVIEW);\n      glLoadIdentity();\n      glTranslatef(0.0, 0.0, -zoom);\n      glRotatef(beta, 1.0, 0.0, 0.0);\n      glRotatef(alpha, 0.0, 0.0, 1.0);\n      //disable depth test so we can render the points with blending\n      glDisable(GL_DEPTH_TEST);\n      drawMCMLPoints();\n      //must enable this to ensure the slides are rendered in the right order \n      glEnable(GL_DEPTH_TEST);\n      drawMCMLSlices();\n\n      //draw the origin with the x,y,z axes for visualization\n      drawOrigin();\n      glfwSwapBuffers(window);\n      glfwPollEvents();\n    }\n    ```"]