- en: Chapter 01
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第01章
- en: Essential Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Essential Features
- en: '*Extreme C* is a book that will provide you with both the fundamental and the
    advanced knowledge you need in order to develop and maintain real C applications.
    Generally, only knowing the syntax of a programming language is not enough to
    write successful programs with it – and this is of greater importance in C compared
    to most other languages. So, we''re going to cover all of the concepts you need
    to write great software in C, from simple single process programs to more complex
    multiple process systems.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 《*极致C*》是一本将为你提供开发和维护真实C应用程序所需的基本和高级知识的书籍。通常，仅了解一种编程语言的语法是不够的，用它来编写成功的程序——在C语言中，这一点比大多数其他语言更为重要。因此，我们将涵盖你编写C语言优秀软件所需的所有概念，从简单的单进程程序到更复杂的多进程系统。
- en: This first chapter is primarily concerned with particular features of C that
    you'll find extremely useful while you're writing C programs. These features are
    involved in situations you will encounter regularly while writing in C. Although
    there are a number of great books and tutorials on C programming that explain
    everything in detail and cover almost all aspects of C syntax, it would be useful
    to consider some key features here before we go deeper with C.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一章主要关注你在编写C程序时会发现极其有用的C语言特定特性。这些特性涉及你在C语言编程中会经常遇到的情况。尽管有许多关于C编程的优秀书籍和教程，它们详细解释了所有内容，并涵盖了C语法的几乎所有方面，但在我们深入C语言之前，考虑一些关键特性将是有用的。
- en: These features include preprocessor directives, variable pointers, function
    pointers, and structures. They are common, of course, in today's more modern programming
    languages, and it's easy to find their counterparts in Java, C#, Python, and so
    on. For example, *references* in Java can be considered as similar elements to
    variable pointers in C. These features and their related concepts are so fundamental,
    that without them, no piece of software could continue to work, even if it could
    get executed! Even a simple "hello world" program cannot work without loading
    a number of shared libraries that require the usage of *function pointers*!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性包括预处理指令、变量指针、函数指针和结构体。当然，在今天的更现代的编程语言中，这些特性很常见，也很容易在Java、C#、Python等语言中找到它们的对应物。例如，Java中的*引用*可以被认为是与C语言中的变量指针相似元素。这些特性和它们相关的概念是如此基础，以至于没有它们，任何软件都无法继续工作，即使它能够被执行！甚至一个简单的“hello
    world”程序也无法在没有加载需要使用*函数指针*的多个共享库的情况下运行！
- en: So, whenever you see something like traffic lights, your car's central computer,
    the microwave oven in your kitchen, the operating system of your smartphone, or
    probably any other device that you generally don't think about, they all have
    pieces of software written in C.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，无论何时你看到像交通信号灯、你汽车的中央电脑、厨房里的微波炉、你智能手机的操作系统，或者可能任何其他你通常不会去想的其他设备，它们都有用C语言编写的软件组件。
- en: Our lives today have been greatly impacted by the invention of the C programming
    language, and our world would be very different without C.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的生活今天受到了C编程语言的发明巨大影响，没有C语言，我们的世界将会非常不同。
- en: 'This chapter focuses on the essential features and machinery required to write
    expert C code and contains a handpicked collection of features for us to study
    in depth. We''ll explore the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注编写专家级C代码所需的必要特性和机制，并包含了一组精选的特性，供我们深入研究。我们将探讨以下主题：
- en: '**Preprocessor directives, macros, and conditional compilation**: Preprocessing
    is one of those C features that you can''t easily find in other programming languages.
    Preprocessing brings a lot of advantages, and we''ll dive into some of its interesting
    applications, including *macros* and *conditional directives*.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预处理指令、宏和条件编译**：预处理是C语言中那些你在其他编程语言中难以找到的特性之一。预处理带来了许多优势，我们将深入探讨其中一些有趣的应用，包括*宏*和*条件指令*。'
- en: '**Variable pointers**: This section deep-dives into *variable pointers* and
    their uses. We''ll also find some helpful insights by looking at some of the flaws
    that could be introduced by misusing variable pointers.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量指针**：本节将深入探讨*变量指针*及其用途。我们还将通过观察一些可能因滥用变量指针而引入的缺陷来获得一些有价值的见解。'
- en: '**Functions**: This section of the chapter is a deep dive into everything we
    know about functions, beyond just their syntax. In fact, the syntax is the easy
    part! In this section, we will look at functions as the building blocks for writing
    *procedural* code. This section also talks about the *function call mechanism*
    and how a function receives its arguments from the caller function.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**：本章的这一部分深入探讨了关于函数的各个方面，而不仅仅是它们的语法。实际上，语法是最容易的部分！在本节中，我们将探讨函数作为编写*过程式*代码的构建块。本节还讨论了*函数调用机制*以及函数如何从调用函数接收其参数。'
- en: '**Function pointers**: Undoubtedly, *function pointers* are one of the most
    important features of C. A function pointer is a pointer that points to an existing
    function instead of a variable. The ability to store a pointer to an existing
    logic is profoundly important in algorithm design, and that''s why we have a dedicated
    section on this topic. Function pointers appear in a vast range of applications
    ranging from loading dynamic libraries to *polymorphism*, and we''ll be seeing
    plenty more of function pointers across the next couple of chapters.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数指针**：毫无疑问，*函数指针*是C语言最重要的特性之一。函数指针是指向现有函数的指针，而不是指向变量。在算法设计中，能够存储指向现有逻辑的指针至关重要，这就是为什么我们专门有一个章节来介绍这个话题。函数指针在从加载动态库到*多态性*的广泛应用中都有出现，在接下来的几章中，我们还将看到更多关于函数指针的内容。'
- en: '**Structures**: C structures might have a simple syntax and convey a simple
    idea, but they are the main building blocks for writing *well-organized* and more
    *object-oriented* code. Their importance, together with function pointers, simply
    cannot be overstated! In the last section of this chapter, we''ll revisit all
    the things that you need to know about structures in C and the tricks around them.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构体**：C语言的结构体可能有简单的语法和传达简单的概念，但它们是编写*组织良好*和更*面向对象*的代码的主要构建块。它们的重要性，连同函数指针一起，绝对不能被高估！在本章的最后部分，我们将回顾关于C语言中结构体及其技巧的所有需要了解的内容。'
- en: The essential features of C, and their surrounding concepts, play a key role
    in the Unix ecosystem, and they have led to C being an important and influential
    technology despite its old age and harsh syntax. We will talk more about the mutual
    influence of C and Unix upon one another in the upcoming chapters. For now, let's
    begin this first chapter by talking about preprocessor directives.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的基本特性和它们周围的概念在Unix生态系统中扮演着关键角色，它们使得尽管C语言历史悠久且语法严格，C语言仍然成为一个重要且具有影响力的技术。在接下来的章节中，我们将更多地讨论C语言和Unix之间的相互影响。现在，让我们从讨论预处理指令开始，开始这一章的学习。
- en: 'Before reading this chapter, bear in mind that you should be already familiar
    with C. Most of the examples are trivial in this chapter, but it is highly recommended
    that you know C syntax before moving on to other chapters. For your convenience,
    below is a list of topics that you should be familiar with before moving on with
    this book:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之前，请记住你应该已经熟悉C语言。本章中的大多数例子都很简单，但强烈建议你在继续阅读其他章节之前了解C语言的语法。为了方便起见，以下是在继续阅读本书之前你应该熟悉的主题列表：
- en: General knowledge of computer architecture — you should know about memory, CPU,
    peripheral devices and their characteristics, and how a program interacts with
    these elements in a computer system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机体系结构的一般知识——你应该了解内存、CPU、外围设备及其特性，以及程序如何在计算机系统中与这些元素交互。
- en: General knowledge of programming — you should know what an algorithm is, how
    its execution can be traced, what a source code is, what binary numbers are, and
    how their related arithmetic work.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的一般知识——你应该了解算法是什么，其执行如何追踪，源代码是什么，二进制数是什么，以及它们相关的算术如何工作。
- en: Familiarity with using the Terminal and the basic shell commands in a Unix-like
    operating system such as Linux or macOS.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉在类似Linux或macOS的Unix操作系统中使用终端和基本shell命令。
- en: Intermediate knowledge about programming topics such as conditional statements,
    different kinds of loops, structures or classes in at least one programming language,
    pointers in C or C++, functions, and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 至少一种编程语言中关于编程主题的中级知识，如条件语句、不同类型的循环、结构或类，C语言或C++中的指针、函数等。
- en: Basic knowledge about object-oriented programming — this is not mandatory because
    we will explain object-oriented programming in detail, but such knowledge will
    help you to have a better understanding while reading the chapters in the third
    part of the book; *Object Orientation*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关于面向对象编程的基本知识——这不是强制性的，因为我们将在书中详细解释面向对象编程，但这样的知识将有助于你在阅读书的第三部分“面向对象”章节时更好地理解；*面向对象*。
- en: Preprocessor directives
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理器指令
- en: '*Preprocessing* is a powerful feature in C. We''ll cover it fully in *Chapter
    2*, *Compilation and Linking*, but right now let''s define preprocessing as something
    that allows you to engineer and modify your source code before submitting it to
    the compiler. This means that the C compilation pipeline has at least one step
    more in comparison to other languages. In other programming languages, the source
    code is directly sent to the compiler, but in C and C++, it should be preprocessed
    first.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*预处理*是 C 中的一个强大特性。我们将在 *第二章*，*编译和链接* 中全面介绍它，但现在是时候定义预处理为一种允许你在提交给编译器之前对源代码进行工程化和修改的东西。这意味着与其他语言相比，C
    的编译管道至少多了一步。在其他编程语言中，源代码会直接发送到编译器，但在 C 和 C++ 中，它应该先进行预处理。'
- en: This extra step has made C (and C++) a unique programming language in the sense
    that a C programmer can effectively change their source code before submitting
    it to the compiler. This feature is not present in most higher-level programming
    languages.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步额外的操作使得 C（以及 C++）成为一门独特的编程语言，因为 C 程序员可以在提交给编译器之前有效地更改他们的源代码。这种特性在大多数高级编程语言中并不存在。
- en: The purpose of preprocessing is to remove the preprocessing directives and substitute
    them with equivalent generated C code and prepare a final source that is ready
    to be submitted to the compiler.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理的目的在于移除预处理指令，并用等效生成的 C 代码替换它们，准备一个最终可以提交给编译器的源代码。
- en: The behavior of the C preprocessor can be controlled and influenced using a set of
    *directives*. C directives are lines of code starting with a `#` character in
    both header and source files. These lines are only meaningful to the C preprocessor
    and never to the C compiler. There are various directives in C, but some of them
    are very important especially the directives used for macro definition and the
    directives used for conditional compilation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一组 *指令* 来控制并影响 C 预处理器的行为。C 指令是以 `#` 字符开头的代码行，在头文件和源文件中都是如此。这些行只对 C 预处理器有意义，而对
    C 编译器没有意义。C 中有各种指令，但其中一些非常重要，特别是用于宏定义的指令和用于条件编译的指令。
- en: In the following section, we'll explain macros and give various examples demonstrating
    their various uses. We also analyze them further to find their advantages and
    disadvantages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释宏并给出各种示例，以展示它们的多种用途。我们还将进一步分析它们，以找到它们的优缺点。
- en: Macros
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏
- en: There are many rumors regarding C macros. One says that they make your source
    code too complicated and less readable. Another says that you face issues while
    debugging applications if you have used macros in your code. You might have heard
    some of these statements yourself. But to what extent are they valid? Are macros
    evils that should be avoided? Or do they have some benefits that can be brought
    to your project?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 C 宏有很多传言。一种说法是它们会使你的源代码变得过于复杂且难以阅读。另一种说法是，如果你在代码中使用了宏，在调试应用程序时可能会遇到问题。你可能自己听到过一些这样的说法。但它们在多大程度上是有效的？宏是应该避免的邪恶吗？还是它们对你的项目有一些可以带来的好处？
- en: The reality is that you'll find macros in any well-known C project. As proof,
    download a well-known C project such as Apache HTTP Server and do a grep for `#define`.
    You will see a list of files where macros are defined. For you as a C developer,
    there is no way to escape macros. Even if you don't use them yourself, you will
    likely see them in other people's code. Therefore, you need to learn what they
    are and how to deal with them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你会在任何知名的 C 项目中找到宏。作为证明，下载一个知名的 C 项目，例如 Apache HTTP 服务器，并使用 `grep` 命令搜索 `#define`。你将看到一系列定义宏的文件。对于你作为一个
    C 开发者来说，你无法避免宏。即使你自己不使用它们，你也可能会在其他人的代码中看到它们。因此，你需要了解它们是什么以及如何处理它们。
- en: The `grep` command refers to a standard shell utility program in Unix-like operating
    systems that searches for a pattern in a stream of characters. It can be used
    to search for a text or a pattern in the content of all files found in a given
    path.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep` 命令指的是 Unix 类操作系统中的一个标准壳工具程序，它会在字符流中搜索一个模式。它可以用来在给定路径下找到的所有文件的 内容中搜索文本或模式。'
- en: 'Macros have a number of applications and you can see some of them as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 宏有多个应用，以下是一些示例：
- en: Defining a constant
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个常量
- en: Using as a function instead of writing a C function
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数而不是编写 C 函数
- en: Loop unrolling
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环展开
- en: Header guards
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头文件保护
- en: Code generation
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码生成
- en: Conditional compilation
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件编译
- en: While there are many more possible applications of macros, we'll focus on the
    above in the following sections.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管宏有更多可能的用途，我们将在接下来的几节中关注上述内容。
- en: Defining a macro
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一个宏
- en: 'Macros are defined using the `#define` directive. Each macro has a name and
    a possible list of parameters. It also has a *value* that gets substituted by
    its *name* in the preprocessing phase through a step called *macro expansion*.
    A macro can also be *undefined* with the `#undef` directive. Let''s start with
    a simple example, *example 1.1*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 宏使用 `#define` 指令定义。每个宏都有一个名称和一个可能的参数列表。它还有一个 *值*，在预处理阶段通过称为 *宏展开* 的步骤用其 *名称*
    替换。也可以使用 `#undef` 指令 *取消定义* 宏。让我们从一个简单的例子开始，*示例 1.1*：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 1-1 [ExtremeC_examples_chapter1_1.c]: Defining a macro'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-1 [ExtremeC_examples_chapter1_1.c]：定义一个宏
- en: 'In the preceding code box, `ABC` is not a variable that holds an integer value
    nor an integer constant. In fact, it''s a macro called `ABC` and its corresponding
    value is `5`. After the macro expansion phase, the resulting code that can be
    submitted to the C compiler looks similar to the one we see as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码框中，`ABC` 不是一个持有整数值的变量，也不是一个整型常量。实际上，它是一个名为 `ABC` 的宏，其对应的值是 `5`。在宏展开阶段之后，可以提交给
    C 编译器的结果代码看起来如下：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Code Box 1-2: The generated code for the example 1.1 after macro expansion
    phase'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-2：示例 1.1 在宏展开阶段生成的代码
- en: The code in *Code Box 1-2* has a valid C syntax, and now the compiler can proceed
    and compile it. In the preceding example, the preprocessor did the macro expansion,
    and as a part of it, the preprocessor simply replaced the macro's name with its
    value. The preprocessor has also removed the comments on the beginning lines.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码框 1-2* 中的代码具有有效的 C 语法，现在编译器可以继续并编译它。在先前的例子中，预处理器执行了宏展开，作为其中的一部分，预处理器简单地用宏的值替换了宏的名称。预处理器还删除了开头几行的注释。'
- en: 'Let''s now have a look at another example, *example 1.2*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看另一个示例，*示例 1.2*：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Code Box 1-3 [ExtremeC_examples_chapter1_2.c]: Defining a function-like macro'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-3 [ExtremeC_examples_chapter1_2.c]：定义一个函数式宏
- en: 'In the preceding code box, similar to *example 1.1*, `ADD` is not a function.
    It is just a *function-like macro* that accepts arguments. After preprocessing,
    the resulting code will be like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码框中，类似于 *示例 1.1*，`ADD` 不是一个函数。它只是一个接受参数的 *函数式宏*。预处理之后，生成的代码将如下所示：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Code Box 1-4: Example 1.2 after preprocessing and macro expansion'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-4：预处理和宏展开后的示例 1.2
- en: As you can see in the preceding code box, the expansion that has taken place
    is as follows. The argument `x` used as parameter `a` is replaced with all instances
    of `a` in the macro's value. This is the same for the parameter `b`, and its corresponding
    argument `y`. Then, the final substitution occurs, and we get `x + y` instead
    of `ADD(a, b)` in the preprocessed code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在先前的代码框中看到的，所发生的展开如下。用作参数 `a` 的参数 `x` 被替换为宏值中所有 `a` 的实例。对于参数 `b` 和其对应的参数 `y`
    也是如此。然后，进行最终替换，我们在预处理的代码中得到 `x + y` 而不是 `ADD(a, b)`。
- en: Since function-like macros can accept input arguments, they can mimic C functions.
    In other words, instead of putting a frequently used logic into a C function,
    you can name that logic as a function-like macro and use that macro instead.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数式宏可以接受输入参数，它们可以模仿 C 函数。换句话说，您可以将频繁使用的逻辑命名为函数式宏，并使用该宏代替 C 函数。
- en: This way, the macro occurrences will be replaced by the frequently used logic,
    as part of the preprocessing phase, and there is no need to introduce a new C function.
    We will discuss this more and compare the two approaches.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，宏的出现将被频繁使用的逻辑替换，作为预处理阶段的一部分，无需引入新的 C 函数。我们将在后面进一步讨论这一点，并比较两种方法。
- en: Macros only exist before the compilation phase. This means that the compiler,
    theoretically, doesn't know anything about the macros. This is a very important
    point to remember if you are going to use macros instead of functions. The compiler
    knows everything about a function because it is part of the C grammar and it is
    parsed and being kept in the *parse tree*. But a macro is just a C preprocessor
    directive only known to the preprocessor itself.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 宏只存在于编译阶段之前。这意味着理论上，编译器对宏一无所知。如果你打算使用宏而不是函数，这是一个非常重要的要点。编译器对函数了如指掌，因为它是C语法的一部分，并且被解析并保存在
    *解析树* 中。但宏只是C预处理器指令，只有预处理器本身知道。
- en: Macros allow you to *generate* code before the compilation. In other programming
    languages such as Java, you need to use a *code generator* to fulfill this purpose.
    We will give examples regarding this application of macros.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 宏允许你在编译之前 *生成* 代码。在其他编程语言，如Java中，你需要使用 *代码生成器* 来完成这个目的。我们将给出关于宏这一应用的例子。
- en: 'Modern C compilers are aware of C preprocessor directives. Despite the common belief
    that they don''t know anything about the preprocessing phase, they actually do.
    The modern C compilers know about the source before entering the preprocessing
    phase. Look at the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C编译器了解C预处理器指令。尽管普遍认为它们对预处理阶段一无所知，但实际上并非如此。现代C编译器在进入预处理阶段之前就了解源代码。看看以下代码：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Code Box 1-5 [example.c]: Macro definition which yields an undeclared identifier
    error'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-5 [example.c]：导致未声明的标识符错误的宏定义
- en: 'If you compile the above code using `clang` in macOS, the following would be
    the output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用macOS中的`clang`编译上述代码，输出将会是：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Shell Box 1-1: The output of the compilation refers to the macro definition'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行框 1-1：编译输出的结果引用了宏定义
- en: As you see, the compiler has generated an error message that points exactly
    to the line in which the macro is defined.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，编译器生成了一条错误信息，它精确地指向了宏定义所在的行。
- en: 'As a side note, in most modern compilers, you can view the preprocessing result
    just before the compilation. For example, when using `gcc` or `clang`, you can
    use the `-E` option to dump the code after preprocessing. The following shell
    box demonstrates how to use the `-E` option. Note that the output is not fully
    shown:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，在大多数现代编译器中，你可以在编译前查看预处理结果。例如，当使用`gcc`或`clang`时，你可以使用`-E`选项来输出预处理后的代码。以下命令行框演示了如何使用`-E`选项。请注意，输出并未完全显示：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Shell Box 1-2: The code of example.c after preprocessing phase'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行框 1-2：预处理阶段后的example.c代码
- en: Now we come to an important definition. A *translation unit* (or a *compilation
    unit*) is the preprocessed C code that is ready to be passed to the compiler.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来定义一个重要的概念。一个 *翻译单元*（或一个 *编译单元*）是经过预处理的C代码，它已经准备好传递给编译器。
- en: In a translation unit, all directives are substituted with inclusions or macro
    expansions and a flat long piece of C code has been produced.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在翻译单元中，所有指令都被替换为包含或宏展开，生成了一段平坦的长C代码。
- en: Now that you know more about macros, let's work on some more difficult examples.
    They will show you the power and danger of macros. In my opinion, extreme development
    deals with dangerous and delicate stuff in a skilled way, and this is exactly
    what C is about.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你对宏有了更多的了解，让我们来处理一些更复杂的例子。它们将展示宏的强大和危险之处。在我看来，极端的开发方式以熟练的方式处理危险和微妙的事物，这正是C语言的核心所在。
- en: 'The next example is an interesting one. Just pay attention to how the macros
    are used in sequence to generate a loop:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子很有趣。请注意宏是如何按顺序使用来生成循环的：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Code Box 1-6 [ExtremeC_examples_chapter1_3.c]: Using macros to generate a loop'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-6 [ExtremeC_examples_chapter1_3.c]：使用宏生成循环
- en: 'As you see in the preceding code box, the code inside the `main` function is
    not a valid C code in any way! But after preprocessing, we get a correct C source
    code that compiles without any problem. Following is the preprocessed result:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的代码框中看到的，`main`函数内部的代码在任何方面都不是有效的C代码！但在预处理之后，我们得到了一个正确的C源代码，它可以无问题地编译。以下是预处理的结果：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Code Box 1-7: Example 1.3 after preprocessing phase'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-7：预处理阶段后的示例 1.3
- en: In *Code Box 1-6*, in the `main` function, we just used a different and not
    C-looking set of instructions to write our algorithm. Then after preprocessing,
    in *Code Box 1-7*, we got a fully functional and correct C program. This is an
    important application of macros; to define a new **domain specific language**
    (**DSL**) and write code using it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *代码框 1-6* 的 `main` 函数中，我们只是使用了一组不同且看起来不像 C 的指令来编写我们的算法。然后预处理后，在 *代码框 1-7*
    中，我们得到了一个完全功能且正确的 C 程序。这是宏的一个重要应用；定义一个新的 **领域特定语言** (**DSL**) 并使用它来编写代码。
- en: DSLs are very useful in different parts of a project; for example, they are
    used heavily in testing frameworks such as Google Test framework (gtest) where
    a DSL is used to write assertions, expectations, and test scenarios.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: DSLs 在项目的不同部分非常有用；例如，它们在测试框架（如 Google Test 框架（gtest））中被大量使用，其中 DSL 用于编写断言、期望和测试场景。
- en: We should note that we don't have any C directives in the final preprocessed
    code. This means that the `#include` directive in *Code Box 1-6* has been replaced
    by the contents of the file it was referring to. That is why you see the content
    of the `stdio.h` header file (which we replaced with ellipses) in *Code Box 1-7*
    before the `main` function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，在最终的预处理器代码中我们没有任何 C 指令。这意味着 *代码框 1-6* 中的 `#include` 指令已被它所引用的文件的内容所替换。这就是为什么你在
    *代码框 1-7* 中的 `main` 函数之前看到了 `stdio.h` 头文件的内容（我们用省略号替换了它）。
- en: 'Let''s now look at the next example, *example 1.4*, which introduces two new
    operators regarding macro parameters; the `#` and `##` operators:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看下一个示例，*示例 1.4*，它介绍了关于宏参数的两个新运算符；`#` 和 `##` 运算符：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Code Box 1-8 [ExtremeC_examples_chapter1_4.c]: Using # and ## operators in
    a macro'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 1-8 [ExtremeC_examples_chapter1_4.c]：在宏中使用 # 和 ## 运算符'
- en: While expanding the macro, the `#` operator turns the parameter into its string
    form surrounded by a pair of quotation marks. For example, in the preceding code,
    the `#` operator used before the `NAME` parameter turns it into `"copy"` in the
    preprocessed code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展宏时，`#` 运算符将参数转换为带有引号的字符串形式。例如，在上面的代码中，`#` 运算符在 `NAME` 参数之前使用，将其转换为预处理器代码中的
    `"copy"`。
- en: 'The `##` operator has a different meaning. It just concatenates the parameters
    to other elements in the macro definition and usually forms variable names. Following
    is the final preprocessed source for *example 1.4*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`##` 运算符有不同的含义。它只是将参数连接到宏定义中的其他元素，并通常形成变量名。以下是 *示例 1.4* 的最终预处理器源代码：'
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Code Box 1-9: Example 1.4 after preprocessing phase'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-9：预处理阶段后的示例 1.4
- en: Comparing the source before and after preprocessing helps you to realize how
    `#` and `##` operators are applied to the macro arguments. Note that, in the final
    preprocessed code, all lines expanded from the same macro definition are on the
    same line.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 比较预处理前后的源代码有助于你理解 `#` 和 `##` 运算符是如何应用于宏参数的。请注意，在最终的预处理器代码中，从同一宏定义扩展的所有行都在同一行上。
- en: It is a good practice to break long macros into multiple lines but do not forget
    to use \ (one backslash) to let the preprocessor know that the rest of the definition
    comes on the next line. Note that \ doesn't get substituted with a *newline* character.
    Instead, it is an indicator that the following line is the continuation of the
    same macro definition.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将长宏拆分成多行是一个好的实践，但不要忘记使用 \ (一个反斜杠) 来让预处理器知道定义的其余部分将在下一行。请注意，\ 不会替换为 *换行符*。相反，它是一个指示符，表示下一行是同一宏定义的延续。
- en: Now let's talk about a different type of macros. The next section is going to
    talk about *variadic macros* which can accept a variable number of arguments.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论不同类型的宏。下一节将讨论可以接受可变数量参数的 *可变参数宏*。
- en: Variadic macros
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变参数宏
- en: 'The next example, *example 1.5*, is dedicated to variadic macros, which can
    accept a variable number of input arguments. Sometimes the same variadic macro
    accepts 2 arguments, sometimes 4 arguments, and sometimes 7\. Variadic macros
    are very handy when you are not sure about the number of arguments in different
    usages of the same macro. A simple example is given as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例，*示例 1.5*，是关于可变参数宏的，它可以接受可变数量的输入参数。有时同一个可变参数宏接受 2 个参数，有时接受 4 个参数，有时接受 7
    个。当不确定同一个宏的不同用法中参数的数量时，可变参数宏非常方便。以下是一个简单的示例：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Code Box 1-10 [ExtremeC_examples_chapter1_5.c]: Definition and usage of a variadic
    macro'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-10 [ExtremeC_examples_chapter1_5.c]：可变宏的定义和用法
- en: 'In the preceding code box, you see a new identifier: `__VA_ARGS__`. It is an
    indicator that tells the preprocessor to replace it with all the remaining input
    arguments that are not assigned to any parameter yet.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码框中，你看到了一个新的标识符：`__VA_ARGS__`。这是一个指示符，告诉预处理器用所有尚未分配给任何参数的剩余输入参数来替换它。
- en: In the preceding example, in the second usage of `LOG_ERROR`, according to the
    macro definition, the arguments `argv[1]`, `1`, and `VERSION` are those input
    arguments that are *not* assigned to any parameter. So, they are going to be used
    in place of `__VA_ARGS__` while expanding the macro.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，在第二次使用 `LOG_ERROR` 时，根据宏定义，参数 `argv[1]`、`1` 和 `VERSION` 是那些尚未分配给任何参数的输入参数。因此，它们将在宏展开时用来代替
    `__VA_ARGS__`。
- en: As a side note, the function `fprintf` writes to a *file descriptor*. In *example
    1.5*, the file descriptor is `stderr`, which is the *error stream* of the process.
    Also, note the ending semicolon after each `LOG_ERROR` usage. It is mandatory
    because the macro doesn't supply them as part of its definition and the programmer
    *must* add that semicolon to make the final preprocessed code syntactically correct.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，函数 `fprintf` 将内容写入 *文件描述符*。在 *示例 1.5* 中，文件描述符是 `stderr`，它是进程的 *错误流*。注意每个
    `LOG_ERROR` 使用后的分号结束。这是强制性的，因为宏在其定义中不提供这些分号，程序员 *必须* 添加这个分号以使最终预处理的代码在语法上正确。
- en: 'The following code is the final output after passing through the C preprocessor:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是通过 C 预处理器处理后的最终输出：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Code Box 1-11: Example 1.5 after preprocessing phase'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-11：预处理阶段后的示例 1.5
- en: The next example, *example 1.6*, is a progressive usage of variadic macros that
    tries to mimic a loop. There is a well-known example about this. Before having
    `foreach` in C++, the *boost* framework was (and still is) offering the `foreach`
    behavior using a number of macros.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例，*示例 1.6*，是变长宏的渐进式使用，试图模拟循环。关于这一点有一个著名的例子。在 C++ 有 `foreach` 之前，*boost*
    框架（现在仍然如此）通过一系列宏提供 `foreach` 行为。
- en: 'In the following link, you can see how the `BOOST_FOREACH` macro is defined
    as the last thing in the header file: [https://www.boost.org/doc/libs/1_35_0/boost/foreach.hpp](https://www.boost.org/doc/libs/1_35_0/boost/foreach.hpp).
    It is used to iterate over a boost collection, and it is actually a function-like
    macro.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中，你可以看到 `BOOST_FOREACH` 宏是如何在头文件中定义的：[https://www.boost.org/doc/libs/1_35_0/boost/foreach.hpp](https://www.boost.org/doc/libs/1_35_0/boost/foreach.hpp)。它用于遍历
    boost 集合，实际上是一个函数式宏。
- en: 'Our following example, *example 1.6*, is about a simple loop which is not comparable
    to boost''s `foreach` at all, but yet, it is giving you an idea on how to use
    variadic macros for repeating a number of instructions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的示例，*示例 1.6*，是关于一个简单的循环，它与 boost 的 `foreach` 完全不可比，但仍然，它给你提供了一个如何使用变长宏重复一系列指令的思路：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code Box 1-12 [ExtremeC_examples_chapter1_6.c]: Using variadic macros to mimic
    a loop'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-12 [ExtremeC_examples_chapter1_6.c]：使用变长宏模拟循环
- en: 'Before starting to explain the example, let''s look at the final code after
    preprocessing. Then, the explanation of what happened will be easier:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始解释示例之前，让我们看看预处理后的最终代码。然后，对发生了什么进行解释将会更容易：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Code Box 1-13: Example 1.6 after preprocessing phase'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-13：预处理阶段后的示例 1.6
- en: If you look at the preprocessed code carefully, you will see that the `LOOP`
    macro has been expanded to multiple `printf` instructions instead of looping instructions
    such as `for` or `while`. It is obvious why this is the case, and it's because
    of the fact that the preprocessor doesn't write smart C code for us. It is there
    to replace macros with the instructions given by us.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看预处理后的代码，你会看到 `LOOP` 宏已经被展开为多个 `printf` 指令，而不是 `for` 或 `while` 这样的循环指令。很明显为什么是这样，这是因为预处理器不会为我们编写智能的
    C 代码。它的作用是将宏替换为我们提供的指令。
- en: The only way to create a loop with a macro is just to put the iteration instructions
    one after another, and as some separate instructions. This means that a simple
    macro loop with 1000 iterations will be substituted with 1000 instructions in
    C and we won't have any actual C loop in the final code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用宏创建循环的唯一方法是将迭代指令一个接一个地放置，作为一些独立的指令。这意味着一个简单的宏循环，有 1000 次迭代，将在 C 中被替换为 1000
    条指令，我们最终代码中不会有任何实际的 C 循环。
- en: The preceding technique will lead to a large binary size which can be thought
    of as a disadvantage. But putting instructions one after another instead of putting
    them into a loop, which is known as *loop unrolling*, has its own applications,
    which require an acceptable level of performance in constrained and high-performance
    environments. According to what we explained so far, it seems that loop unrolling
    using macros is a trade-off between binary size and performance. We talk more
    about this in the upcoming section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的技术会导致二进制文件大小增大，这可以被视为一个缺点。但将指令一个接一个地放置，而不是将它们放入循环中，这被称为*循环展开*，有其自身的应用，这些应用需要在受限和性能要求高的环境中达到可接受的性能水平。根据我们到目前为止所解释的，似乎使用宏进行循环展开是在二进制大小和性能之间的一种权衡。我们将在下一节中更多地讨论这个问题。
- en: There is one more note about the preceding example. As you see, different usages
    of the `LOOP` macro in the `main` function have produced different results. In
    the first usage, we pass `copy paste cut` without any commas between the words.
    The preprocessor accepts it as a single input, so the simulated loop has only
    one iteration.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面示例的另一个注意事项。正如你所见，`main`函数中`LOOP`宏的不同用法产生了不同的结果。在第一次使用中，我们传递了`copy paste
    cut`，单词之间没有逗号。预处理程序将其接受为单个输入，因此模拟循环只有一个迭代。
- en: In the second usage, the input `copy, paste, cut` is passed with words separated
    by commas. Now, the preprocessor treats them as three different arguments; hence,
    the simulated loop has three iterations. This is clear from the following *Shell Box
    1-3*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次使用中，输入`copy, paste, cut`通过逗号分隔单词传递。现在，预处理程序将它们视为三个不同的参数；因此，模拟循环有三个迭代。这可以从下面的*Shell
    Box 1-3*中清楚地看出。
- en: In the third usage, we pass four values, `copy, paste, cut, select,` but only
    three of them are processed. As you see, the preprocessed code is exactly the
    same as the second usage. That's because of the fact that our looping macros are
    only capable of handling lists of up to three elements. Extra elements after the
    third are ignored.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三次使用中，我们传递了四个值，`copy, paste, cut, select,`但只有三个被处理。正如你所见，预处理代码与第二次使用完全相同。这是因为我们的循环宏只能处理最多三个元素的列表。超过第三个的额外元素将被忽略。
- en: 'Note that this doesn''t produce compilation errors because nothing wrong has
    been generated as the final C code, but our macros are limited in the number of
    elements they can process:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这不会产生编译错误，因为没有生成任何错误的最终C代码，但我们的宏在处理元素的数量上有限制：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Shell Box 1-3: Compilation and output of example 1.6'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 1-3：示例1.6的编译和输出
- en: Advantages and disadvantages of macros
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宏的优缺点
- en: Let's start the discussion by talking a bit about software design. Defining
    macros and putting them together is an art, and at times an addictive one! You
    start building the expected preprocessed code in your mind even before having
    any macros defined and based on that you define your macros. Since it is an easy
    way to replicate the code and play with it, it can be overused. Overusing the
    macros may not be a big issue for you, but it might be for your teammates. But
    why is that?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论软件设计开始，稍微谈谈宏的定义和组合。这既是一门艺术，有时也是一种上瘾的行为！你甚至在没有定义任何宏之前，就在脑海中开始构建预期的预处理代码，并基于此来定义你的宏。由于这是一种复制代码并与之玩耍的简单方法，因此可能会过度使用。过度使用宏可能对你来说不是大问题，但可能对你的队友来说却是。但为什么是这样呢？
- en: Macros have an important characteristic. If you write something in macros, they
    will be replaced by other lines of code before the compilation phase, and finally,
    you'll have a flat long piece of code without any modularity at compile time.
    Of course, you have the modularity in your mind and probably in your macros, but
    it is not present in your final binaries. This is exactly where using macros can
    start to cause design issues.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 宏有一个重要的特性。如果你在宏中编写某些内容，它们将在编译阶段之前被其他代码行替换，最终你将得到一段没有模块性的平坦长代码。当然，你在心中和可能在你的宏中拥有模块性，但在你的最终二进制文件中并不存在。这正是使用宏可能开始引起设计问题的原因。
- en: 'Software design tries to package similar algorithms and concepts in several
    manageable and reusable *modules*, but macros try to make everything linear and
    flat. So, when you are using macros as some logical building blocks within your
    software design, the information regarding them can be lost after the preprocessing
    phase, as part of the final translation units. That''s why the architects and
    designers use a rule of thumb about macros:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计试图将类似的算法和概念打包成几个可管理的和可重用的*模块*，但宏试图使一切线性化和扁平化。因此，当你将宏作为软件设计中的某些逻辑构建块使用时，它们的信息可能会在预处理阶段丢失，成为最终翻译单元的一部分。这就是为什么架构师和设计师会使用关于宏的经验法则：
- en: If a macro can be written as a C function, then you should write a C function instead!
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果可以将宏写成C函数，那么你应该写一个C函数而不是宏！
- en: From the debugging perspective, again, it is said that macros are evil. A developer
    uses compilation errors to find the places where there exist *syntax errors* as
    part of their daily development tasks. They also use *logs* and possibly *compilation
    warnings* to detect a bug and fix it. The compilation errors and warnings both
    are beneficial to the bug analysis routine, and both of them are generated by
    the compilers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从调试的角度来看，再次强调，宏被认为是有害的。开发者使用编译错误来查找日常开发任务中存在的*语法错误*的位置。他们还使用*日志*和可能*编译警告*来检测错误并修复它。编译错误和警告都对错误分析流程有益，并且都是由编译器生成的。
- en: Regarding the macros, and especially with old C compilers, the compiler didn't
    know anything about the macros and it was treating the compiling source (the translation
    unit) as a long, linear, flat piece of code. So, for a developer looking at the
    actual C code with macros and for the C compiler looking at the preprocessed code
    without macros, there were two different worlds. So, the developer could not understand
    easily what the compiler reported.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 关于宏，尤其是对于旧的C编译器，编译器对宏一无所知，它将编译源代码（翻译单元）视为一段长、线性、扁平的代码。因此，对于查看带有宏的实际C代码的开发者和查看没有宏的预处理代码的C编译器来说，存在两个不同的世界。所以，开发者很难理解编译器报告的内容。
- en: Hopefully, with the help of our modern C compilers, this issue is not that severe
    anymore. Nowadays, the famous C compilers such as `gcc` and `clang` know more
    about the preprocessing phase, and they try to keep, use, and report according
    to the source code that the developer sees. Otherwise, the problem with macros
    could be repeated with `#include` directives, simply because the main content
    of a translation unit is only known when all inclusions have happened. As a conclusion,
    we can say that the problem with debugging is less severe than the problem we
    explained in the previous paragraph about the software design.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 希望借助我们现代的C编译器，这个问题已经不再那么严重了。如今，著名的C编译器如`gcc`和`clang`对预处理阶段有了更深入的了解，并且它们会尽量保持、使用并报告开发者所看到的源代码。否则，宏的问题可能会通过`#include`指令重复出现，简单来说，因为翻译单元的主要内容只有在所有包含发生之后才会被知晓。因此，我们可以得出结论，调试问题没有我们之前段落中提到的软件设计问题那么严重。
- en: If you remember, we brought up a discussion during the explanation of *example
    1.6*. It was about a trade-off between the binary size and the performance of
    a program. A more general form of this trade-off is between having a single big
    binary and having multiple small binaries. Both of them are providing the same
    functionality, but the former can have a better performance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们在解释*示例1.6*时提出过一次讨论。这是关于程序的二进制大小和性能之间的权衡。这种权衡的更一般形式是在单个大二进制和多个小二进制之间。它们都提供相同的功能，但前者可能会有更好的性能。
- en: The number of binaries used in a project, especially when the project is big,
    is more or less proportional to the degree of *modularization* and the design
    effort spent on it. As an example, a project having 60 libraries (shared or static)
    and one executable seems to be developed according to a software plan which is
    splitting dependencies into multiple libraries and using them in a single main
    executable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个项目中使用的二进制文件数量，尤其是在项目很大时，或多或少与*模块化*的程度和投入的设计努力成正比。例如，一个拥有60个库（共享或静态）和一个可执行文件的项目似乎是根据一个软件计划开发的，该计划将依赖关系拆分成多个库，并在单个主可执行文件中使用它们。
- en: In other words, when a project is being developed according to the software
    design principals and best practices, the number of binaries and their sizes are
    engineered in a careful way and usually will be comprised of multiple lightweight
    binaries with applicable minimum sizes, instead of having a single huge binary.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当一个项目根据软件设计原则和最佳实践进行开发时，二进制文件的数量和大小会经过精心设计，通常将由多个轻量级二进制文件组成，这些二进制文件具有适用的最小大小，而不是只有一个庞大的二进制文件。
- en: Software design tries to have each software component in a suitable position
    in a giant hierarchy instead of putting them in a linear order. And this is intrinsically
    against the performance even though its effect on the performance is tiny in most
    cases.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计试图将每个软件组件放置在一个巨大的层次结构中的合适位置，而不是将它们按线性顺序排列。尽管在大多数情况下其对性能的影响很小，但这种做法本质上与性能相悖。
- en: So, we can conclude that the discussion regarding *example 1.6* was about the
    trade-off between design and performance. When you need performance, sometimes
    you need to sacrifice the design and put things in a linear construction. For
    example, you could avoid loops and use *loop unrolling* instead.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以得出结论，关于*示例1.6*的讨论是关于设计和性能之间的权衡。当你需要性能时，有时你需要牺牲设计，将事物置于线性构造中。例如，你可以避免循环，并使用*循环展开*。
- en: From a different perspective, performance starts with choosing proper algorithms
    for the problems defined in the design phase. The next step is usually called
    *optimization* or *performance tuning*. In this phase, gaining performance is
    equivalent to letting the CPU just compute in a linear and sequential manner and
    not to force it to jump between different parts of the code. This can be done
    either by modifying the already used algorithms or by replacing them with some
    performant and usually more complex algorithms. This stage can come into conflict
    with the design philosophy. As we said before, design tries to put things in a
    hierarchy and make them non-linear, but the CPU expects things to be linear, already
    fetched and ready to be processed. So, this trade-off should be taken care of
    and balanced for each problem separately.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个角度来看，性能始于在设计阶段定义的问题中选择合适的算法。接下来的步骤通常被称为*优化*或*性能调整*。在这个阶段，获得性能等同于让CPU以线性且顺序的方式计算，而不是强迫它在不同部分的代码之间跳跃。这可以通过修改已经使用的算法或用一些性能更好且通常更复杂的算法来替换它们来实现。这个阶段可能会与设计哲学发生冲突。正如我们之前所说的，设计试图将事物置于层次结构中并使其非线性，但CPU期望事物是线性的，已经取出的并且准备好被处理。因此，这种权衡应该针对每个问题单独处理和平衡。
- en: Let's explain the loop unrolling a bit more. This technique is mostly used in
    embedded development and especially in environments that suffer from limited processing
    power. The technique is to remove loops and make them linear to increase the performance
    and avoid the looping overhead while running iterations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释一下循环展开。这项技术主要在嵌入式开发中使用，尤其是在处理能力有限的环境中。其技术是通过移除循环，使它们线性化，以提高性能并避免在迭代过程中产生循环开销。
- en: This is exactly what we did in *example 1.6*; we mimicked a loop with macros,
    which led to a linear set of instructions. In this sense, we can say that the
    macros can be used for performance tuning in embedded development and the environments
    in which a slight change in the way that the instructions are executed will cause
    a significant performance boost. More than that, macros can bring readability
    to the code and we can factor out repeated instructions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在*示例1.6*中所做的；我们使用宏模拟了一个循环，这导致了一系列线性指令。从这个意义上说，我们可以说宏可以用于嵌入式开发中的性能调整，以及在指令执行方式的一点点改变就能带来显著性能提升的环境中。更重要的是，宏可以使代码更具可读性，我们可以提取重复的指令。
- en: Regarding the quote mentioned earlier that says that macros should be replaced
    by equivalent C functions, we know that the quote is there for the sake of design
    and it can be ignored in some contexts. In a context where improved performance
    is a key requirement, having a linear set of instructions that lead to better
    performance may be a necessity.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 关于之前提到的那个说宏应该被等效的C函数替换的引用，我们知道这个引用是为了设计而存在的，在某些情况下可以忽略。在一个性能提升是关键要求的上下文中，有一系列线性指令可以带来更好的性能，这可能是必要的。
- en: Code generation is another common application of macros. They can be used for
    introducing DSLs into a project. *Microsoft MFC*, *Qt*, *Linux Kernel*, and *wxWidgets*
    are a few projects out of thousands that are using macros to define their own
    DSLs. Most of them are C++ projects, but they are using this C feature to facilitate
    their APIs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成是宏的另一个常见应用。它们可以用于将 DSL 引入项目中。*Microsoft MFC*、*Qt*、*Linux Kernel* 和 *wxWidgets*
    是成千上万个使用宏来定义他们自己的 DSL 的项目中的几个。大多数是 C++ 项目，但它们使用这个 C 特性来简化他们的 API。
- en: As a conclusion, C macros can have advantages if the impacts of their preprocessed
    form are investigated and known. If you're working on a project within a team,
    always share your decisions regarding the usage of the macros in the team and
    keep yourself aligned with the decisions made within the team.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结论，如果调查并了解其预处理形式的影响，C 宏可以具有优势。如果你在一个团队项目中工作，总是要分享你在团队中关于宏使用的决策，并确保自己与团队做出的决策保持一致。
- en: Conditional compilation
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件编译
- en: 'Conditional compilation is another unique feature of C. It allows you to have
    different preprocessed source code based on different conditions. Despite the
    meaning it implies, the compiler is not doing anything conditionally, but the
    preprocessed code that is passed to the compiler can be different based on some
    specified conditions. These conditions are evaluated by the preprocessor while
    preparing the preprocessed code. There are different directives contributing to
    the conditional compilation. You can see a list of them as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 条件编译是 C 的另一个独特特性。它允许你根据不同的条件拥有不同的预处理源代码。尽管它暗示的意义，编译器并没有进行任何条件操作，但传递给编译器的预处理代码可以根据一些指定的条件而不同。这些条件是在准备预处理代码时由预处理器评估的。有不同指令有助于条件编译。你可以看到以下列表：
- en: '`#ifdef`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#ifdef`'
- en: '`#ifndef`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#ifndef`'
- en: '`#else`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#else`'
- en: '`#elif`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#elif`'
- en: '`#endif`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#endif`'
- en: 'The following example, *example 1.7*, demonstrates a very basic usage of these
    directives:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例，*示例 1.7*，展示了这些指令的基本用法：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Code Box 1-14 [ExtremeC_examples_chapter1_7.c]: An example of conditional compilation'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-14 [ExtremeC_examples_chapter1_7.c]：条件编译的示例
- en: While preprocessing the preceding code, the preprocessor sees the `CONDITION`
    macro's definition and marks it as defined. Note that no value is proposed for
    the `CONDITION` macro and this is totally valid. Then, the preprocessor goes down
    further until it reaches the `#ifdef` statement. Since the `CONDITION` macro is
    already defined, all lines between `#ifdef` and `#endif` will be copied to the
    final source code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在预处理前面的代码时，预处理器看到 `CONDITION` 宏的定义并将其标记为已定义。请注意，没有为 `CONDITION` 宏提出任何值，这是完全有效的。然后，预处理器继续向下直到它到达
    `#ifdef` 语句。由于 `CONDITION` 宏已经定义，`#ifdef` 和 `#endif` 之间的所有行都将复制到最终源代码中。
- en: 'You can see the preprocessed code in the following code box:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下面的代码框中看到预处理后的代码：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Code Box 1-15: Example 1.7 after preprocessing phase'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-15：预处理阶段后的示例 1.7
- en: 'If the macro was not defined, we wouldn''t see any replacement for the `#if-#endif`
    directives. Therefore, the preprocessed code could be something like the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果宏未定义，我们就不会看到任何 `#if-#endif` 指令的替换。因此，预处理后的代码可能如下所示：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Code Box 1-16: Example 1.7 after preprocessing phase assuming that CONDITION
    macro is not defined'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-16：预处理阶段后的示例 1.7，假设 `CONDITION` 宏未定义
- en: Note the empty lines, in both code boxes *1-15* and *1-16*, which have been
    remained from the preprocessing phase, after replacing the `#ifdef-#endif` section
    with its evaluated value.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在代码框 *1-15* 和 *1-16* 中保留的空行，这些空行是在预处理阶段，将 `#ifdef-#endif` 部分替换为其评估值后留下的。
- en: 'Macros can be defined using `-D` options passed to the compilation command.
    Regarding the preceding example, we can define the `CONDITION` macro as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用传递给编译命令的 `-D` 选项来定义宏。关于前面的例子，我们可以如下定义 `CONDITION` 宏：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a great feature because it allows you to have macros defined out of
    source files. This is especially helpful when having a single source code but
    compiling it for different architectures, for example, Linux or macOS, which have
    different default macro definitions and libraries.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很棒的特性，因为它允许你在源代码之外定义宏。这在只有一个源代码但需要为不同的架构编译它时特别有用，例如 Linux 或 macOS，它们有不同的默认宏定义和库。
- en: One of the very common usages of `#ifndef` is to serve as a *header guard* statement.
    This statement protects a header file from being included twice in the preprocessing
    phase, and we can say that almost all C and C++ header files in nearly every project
    have this statement as their first instruction.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`#ifndef`的一个非常常见的用法是作为*头文件保护*语句。这个语句保护头文件在预处理阶段不被重复包含，我们可以说几乎每个项目中几乎所有C和C++的头文件都将这个语句作为它们的第一个指令。'
- en: 'The following code, *example 1.8*, is an example on how to use a header guard
    statement. Suppose that this is the content of a header file and by chance, it
    could be included twice in a compilation unit. Note that *example 1.8* is just
    one header file and it is not supposed to be compiled:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码，*示例 1.8*，展示了如何使用头文件保护语句。假设这是头文件的内容，并且意外地在一个编译单元中被包含两次。请注意，*示例 1.8*只是一个头文件，它不应该被编译：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Code Box 1-17 [ExtremeC_examples_chapter1_8.h]: An example of a header guard'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-17 [ExtremeC_examples_chapter1_8.h]：头文件保护器的示例
- en: As you see, all variable and function declarations are put inside the `#ifndef`
    and `#endif` pair and they are protected against multiple inclusions by a macro.
    In the following paragraph, we explain how.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，所有变量和函数声明都放在`#ifndef`和`#endif`对之间，并且通过宏来防止多次包含。在下一段中，我们将解释如何做到这一点。
- en: As the first inclusion happens, the `EXAMPLE_1_8_H` macro is not yet defined,
    so the preprocessor continues by entering the `#ifndef-#endif` block. The next
    statement defines the `EXAMPLE_1_8_H` macro, and the preprocessor copies everything
    to the preprocessed code until it reaches the `#endif` directive. As the second
    inclusion happens, the `EXAMPLE_1_8_H` macro is already defined, so the preprocessor
    skips all of the content inside the `#ifndef-#endif` section and moves to the
    next statement after `#endif`, if there is any.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次包含发生时，`EXAMPLE_1_8_H`宏尚未定义，因此预处理器继续进入`#ifndef-#endif`块。下一个语句定义了`EXAMPLE_1_8_H`宏，预处理器将所有内容复制到预处理的代码中，直到它达到`#endif`指令。当第二次包含发生时，`EXAMPLE_1_8_H`宏已经定义，因此预处理器跳过`#ifndef-#endif`部分内的所有内容，并移动到`#endif`之后的下一个语句（如果有的话）。
- en: It is a common practice that the whole content of a header file is put between
    the `#ifndef-#endif` pair, and nothing but comments are left outside.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个头文件内容放在`#ifndef-#endif`对之间是一种常见的做法，除了注释外，外部不留下任何内容。
- en: As a final note in this section, instead of having a pair of `#ifndef-#endif`
    directives, one could use `#pragma once` in order to protect the header file from
    the *double inclusion* issue. The difference between conditional directives and
    the `#pragma once` directive is that the latter is not a C standard, despite the
    fact that it is supported by almost all C preprocessors. However, it is better
    to not to use it if *portability* of your code is a requirement.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后一点，为了避免`#ifndef-#endif`指令对，可以使用`#pragma once`来保护头文件免受双重包含问题的影响。条件指令与`#pragma
    once`指令的区别在于，尽管它被几乎所有C预处理器支持，但它并不是C标准的一部分。然而，如果你的代码需要*可移植性*，最好不要使用它。
- en: 'The following code box contains a demonstration on how to use `#pragma once`
    in *example 1.8*, instead of `#ifndef-#endif` directives:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框包含了一个如何在使用`#pragma once`指令而不是`#ifndef-#endif`指令的*示例 1.8*中的演示：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Code Box 1-18: Using #pragma once directive as part of example 1.8'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 1-18：在示例 1.8 中使用 #pragma once 指令'
- en: Now, we close the topic of preprocessor directives while we have demonstrated
    some of their interesting characteristics and various applications. The next section
    is about variable pointers, which are another important feature of C.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经展示了预处理指令的一些有趣特性和各种应用，我们将关闭预处理指令这一主题。下一节将介绍变量指针，这是C语言的另一个重要特性。
- en: Variable pointers
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量指针
- en: The concept of a variable pointer, or for short pointer, is one of the most
    fundamental concepts in C. You can hardly find any direct sign of them in most
    high-level programming languages. In fact, they have been replaced by some twin
    concepts, for example, *references* in Java. It is worth mentioning that pointers
    are unique in the sense that the addresses they point to can be used directly
    by hardware, but this is not the case for the higher-level twin concepts like references.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 变量指针的概念，或简称为指针，是C语言中最基本的概念之一。在大多数高级编程语言中，你几乎找不到它们的直接迹象。实际上，它们已经被一些双胞胎概念所取代，例如Java中的*引用*。值得注意的是，指针的独特之处在于它们所指向的地址可以直接由硬件使用，而高级的双胞胎概念如引用则不是这样。
- en: Having a deep understanding about pointers and the way they work is crucial
    to become a skilled C programmer. They are one of the most fundamental concepts
    in memory management, and despite their simple syntax, they have the potential
    to lead to a disaster when used in a wrong way. We will cover memory management-related
    topics in *Chapter 4*, *Process Memory Structure*, and *Chapter 5*, *Stack and
    Heap*, but here in this chapter, we want to recap everything about pointers. If
    you feel confident about the basic terminology and the concepts surrounding the
    pointers, you can skip this section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 深入理解指针及其工作方式对于成为一名熟练的C程序员至关重要。它们是内存管理中最基本的概念之一，尽管它们的语法很简单，但使用不当可能会导致灾难。我们将在*第4章*，*进程内存结构*和*第5章*，*栈和堆*中涵盖与内存管理相关的主题，但在这里本章中，我们想要回顾关于指针的所有内容。如果你对指针的基本术语和概念感到自信，你可以跳过这一节。
- en: Syntax
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法
- en: 'The idea behind any kind of pointer is very simple; it is just a simple variable
    that keeps a *memory address*. The first thing you may recall about them is the
    asterisk character, `*`, which is used for declaring a pointer in C. You can see
    it in *example 1.9*. The following code box demonstrates how to declare and use
    a variable pointer:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的指针背后的思想非常简单；它只是一个简单的变量，用于保存一个*内存地址*。你可能会首先想起它们中的星号字符，`*`，在C语言中用于声明指针。你可以在*示例1.9*中看到它。下面的代码框演示了如何声明和使用变量指针：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Code Box 1-19 [ExtremeC_examples_chapter1_9.c]: Example on how to declare and
    use a pointer in C'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框1-19 [ExtremeC_examples_chapter1_9.c]: C语言中声明和使用指针的示例'
- en: The preceding example has everything you need to know about the pointer's syntax.
    The first line declares the `var` variable on top of the *Stack segment*. We will
    discuss the Stack segment in *Chapter 4*, *Process Memory Structure*. The second
    line declares the pointer `ptr` with an initial value of zero. A pointer which
    has the zero value is called a *null pointer*. As long as the `ptr` pointer retains
    its zero value, it is considered to be a null pointer. It is very important to
    *nullify* a pointer if you are *not* going to store a valid address upon declaration.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例包含了你需要了解的所有关于指针语法的知识。第一行在*栈段*上声明了`var`变量。我们将在*第4章*，*进程内存结构*中讨论栈段。第二行声明了初始值为零的指针`ptr`。具有零值的指针称为*空指针*。只要`ptr`指针保持其零值，它就被认为是空指针。如果你在声明时不打算存储有效的地址，那么*置空*指针非常重要。
- en: As you see in *Code Box 1-19*, no header file is included. Pointers are part
    of the C language, and you don't need to have anything included to be able to
    use them. Indeed, we can have C programs, which do not include any header file
    at all.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在*代码框1-19*中看到的，没有包含任何头文件。指针是C语言的一部分，你不需要包含任何内容就能使用它们。实际上，我们可以有完全不包含任何头文件的C程序。
- en: 'All of the following declarations are valid in C:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有声明在C语言中都是有效的：
- en: '`int* ptr = 0;`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`int* ptr = 0;`'
- en: '`int * ptr = 0;`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`int * ptr = 0;`'
- en: '`int *ptr = 0;`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`int *ptr = 0;`'
- en: The third line in the `main` function introduces the `&` operator, which is
    called the *referencing operator*. It returns the address of the variable next
    to it. We need this operator to obtain the address of a variable. Otherwise, we
    cannot initialize pointers with valid addresses.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数中的第三行引入了`&`操作符，称为*引用操作符*。它返回其旁边变量的地址。我们需要这个操作符来获取变量的地址。否则，我们无法用有效的地址初始化指针。'
- en: On the same line, the returned address is stored into the `ptr` pointer. Now,
    the `ptr` pointer is not a null pointer anymore. On the fourth line, we see another
    operator prior to the pointer, which is called the *dereferencing operator* and
    denoted by `*`. This operator allows you to have indirect access to the memory
    cell that the `ptr` pointer is pointing to. In other words, it allows you to read
    and modify the `var` variable through the pointer that is pointing to it. The
    fourth line is equivalent to the `var = 200;` statement.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，返回的地址被存储到`ptr`指针中。现在，`ptr`指针不再是空指针了。在第四行，我们看到指针之前还有一个操作符，称为*解引用操作符*，表示为`*`。这个操作符允许你间接访问`ptr`指针所指向的内存单元。换句话说，它允许你通过指向它的指针来读取和修改`var`变量。第四行等价于`var
    = 200;`语句。
- en: A null pointer is not pointing to a valid memory address. Therefore, dereferencing
    a null pointer *must* be avoided because it is considered as an *undefined behavior*,
    which usually leads to a crash.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 空指针不指向有效的内存地址。因此，解引用空指针*必须*避免，因为这被认为是*未定义行为*，通常会导致崩溃。
- en: 'As a final note regarding the preceding example, we usually have the default
    macro `NULL` defined with value `0`, and it can be used to nullify pointers upon
    declaration. It is a good practice to use this macro instead of `0` directly because
    it makes it easier to distinguish between the variables and the pointers:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的示例的最后一句话，我们通常将默认宏 `NULL` 定义为值 `0`，并且可以在声明时用来使指针无效。使用这个宏而不是直接使用 `0` 是一个好习惯，因为它 使得区分变量和指针更容易：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Code Box 1-20: Using the NULL macro to nullify a pointer'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-20：使用 NULL 宏来使指针无效
- en: 'The pointers in C++ are exactly the same as in C. They need to be nullified
    by storing `0` or `NULL` in them, but C++11 has a new keyword for initializing
    the pointers. It is not a macro like `NULL` nor an integer like `0`. The keyword
    is `nullptr` and can be used to nullify the pointers or check whether they are
    null. The following example demonstrates how it is used in C++11:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的指针与 C 中的完全相同。它们需要通过在其中存储 `0` 或 `NULL` 来使它们无效，但 C++11 有一个用于初始化指针的新关键字。它既不是像
    `NULL` 这样的宏，也不是像 `0` 这样的整数。这个关键字是 `nullptr`，可以用来使指针无效或检查它们是否为空。以下示例演示了它在 C++11
    中的用法：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Code Box 1-21: Using nullptr to nullify a pointer in C++11'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-21：在 C++11 中使用 nullptr 使指针无效
- en: It is crucial to remember that pointers *must* be initialized upon declaration.
    If you don't want to store any valid memory address while declaring them, don't
    leave them uninitialized. Make it null by assigning `0` or `NULL!` Do this otherwise
    you may face a fatal bug!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点至关重要，指针 *必须* 在声明时初始化。如果你在声明时不希望存储任何有效的内存地址，不要让它们保持未初始化状态。通过分配 `0` 或 `NULL!`
    来使其为空。否则，你可能会遇到致命的错误！
- en: In most modern compilers, an uninitialized pointer is always nullified. This
    means that the initial value is `0` for all uninitialized pointers. But this shouldn't
    be considered as an excuse to declare pointers without initializing them properly.
    Keep in mind that you are writing code for different architectures, old and new,
    and this may cause problems on legacy systems. In addition, you will get a list
    of errors and warnings for these kinds of uninitialized pointers in most *memory
    profilers*. Memory profilers will be explained thoroughly as part of *Chapter
    4*, *Process Memory Structure*, and *Chapter 5*, *Stack and Heap*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现代编译器中，未初始化的指针总是被置为空。这意味着所有未初始化的指针的初始值都是 `0`。但这不应被视为不正确初始化指针的借口。记住，你正在为不同的架构编写代码，新旧架构，这可能在旧系统上引起问题。此外，你将在大多数
    *内存分析器* 中为这些类型的未初始化指针获得错误和警告列表。内存分析器将在 *第四章*，*进程内存结构* 和 *第五章*，*栈和堆* 中详细解释。
- en: Arithmetic on variable pointers
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量指针的算术运算
- en: The simplest picture of memory is a very long one-dimensional array of bytes.
    With this picture in mind, if you're standing on one byte, you can only go back
    and forth in the array; there's no other possible movement. So, this would be
    the same for the pointers addressing different bytes in the memory. Incrementing
    the pointer makes the pointer go forward and decrementing it makes the pointer
    go backward. No other arithmetic operation is possible for the pointers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 内存最简单的图景是一个非常长的单维字节数组。带着这个图景，如果你站在一个字节上，你只能在数组中前后移动；没有其他可能的移动。所以，这也会适用于指向内存中不同字节的指针。增加指针会使指针向前移动，而减少它会使指针向后移动。指针不可能进行其他算术运算。
- en: 'Like we said previously, the arithmetic operations on a pointer are analogous
    to the movements in an array of bytes. We can use this figure to introduce a new
    concept: the *arithmetic step size*. We need to have this new concept because
    when you increment a pointer by 1, it might go forward more than 1 byte in the
    memory. Each pointer has an arithmetic step size, which means the number of bytes
    that the pointer will move if it is incremented or decremented by 1\. This arithmetic
    step size is determined by the C *data type* of the pointer.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，指针上的算术运算与字节数组中的移动类似。我们可以用这个图来介绍一个新概念：*算术步长*。我们需要这个新概念，因为当你将指针增加 1
    时，它可能在内存中向前移动超过 1 个字节。每个指针都有一个算术步长，这意味着如果指针增加或减少 1，它将移动的字节数。这个算术步长由指针的 C *数据类型*
    决定。
- en: In every platform, we have one single unit of memory and all pointers store
    the addresses inside that memory. So, all pointers should have equal sizes in
    terms of bytes. But this doesn't mean that all of them have equal arithmetic step
    sizes. As we mentioned earlier, the arithmetic step size of a pointer is determined
    by its C data type.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个平台上，我们只有一个单一的内存单元，所有指针都存储在该内存中的地址。因此，从字节大小来看，所有指针应该具有相同的大小。但这并不意味着它们的算术步长都相同。正如我们之前提到的，指针的算术步长由其
    C 数据类型决定。
- en: 'For example, an `int` pointer has the same size as a `char` pointer, but they
    have different arithmetic step sizes. `int*` usually has a 4-byte arithmetic step
    size and `char*` has a 1-byte arithmetic step size. Therefore, incrementing an
    integer pointer makes it move forward by 4 bytes in the memory (adds 4 bytes to
    the current address), and incrementing a character pointer makes it move forward
    by only 1 byte in the memory. The following example, *example 1.10*, demonstrates
    the arithmetic step sizes of two pointers with two different data types:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`int` 指针的大小与 `char` 指针相同，但它们的算术步长不同。`int*` 通常具有 4 字节的算术步长，而 `char*` 具有字节的算术步长。因此，增加整数指针会使它在内存中向前移动
    4 字节（将 4 字节添加到当前地址），而增加字符指针只会使它在内存中向前移动 1 字节。以下示例，*示例 1.10*，演示了两种不同数据类型的两个指针的算术步长：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Code Box 1-22 [ExtremeC_examples_chapter1_10.c]: Arithmetic step sizes of two
    pointers'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 1-22 [ExtremeC_examples_chapter1_10.c]: 两个指针的算术步长'
- en: 'The following shell box shows the output of *example 1.10*. Note that the printed
    addresses can be different for two successive runs on the same machine, and even
    from a platform to another, therefore you probably observe different addresses
    in your output:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 框显示 *示例 1.10* 的输出。请注意，在同一台机器上连续两次运行可能打印不同的地址，甚至从平台到平台，因此你可能在输出中观察到不同的地址：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Shell Box 1-4: Output of example 1.10 after first run'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 1-4：第一次运行示例 1.10 的输出
- en: 'It is clear from the comparison of the addresses before and after the arithmetic
    operations that the step size for the integer pointer is 4 bytes, and it is 1
    byte for the character pointer. If you run the example again, the pointers probably
    refer to some other addresses, but their arithmetic step sizes remain the same:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从算术操作前后的地址比较中可以清楚地看出，整数指针的步长是 4 字节，而字符指针的步长是 1 字节。如果你再次运行示例，指针可能指向其他地址，但它们的算术步长保持不变：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Shell Box 1-5: Output of example 1.10 after second run'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 1-5：第二次运行示例 1.10 的输出
- en: Now that you know about the arithmetic step sizes, we can talk about a classic
    example of using pointer arithmetic to *iterate* over a region of memory. The
    examples 1.11 and 1.12 are about to print all the elements of an integer array.
    The trivial approach without using the pointers is brought in *example 1.11*,
    and the solution based on pointer arithmetic is given as part of *example 1.12*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了算术步长，我们可以讨论使用指针算术来 *迭代* 内存区域的经典示例。示例 1.11 和 1.12 是关于打印整数数组所有元素的。没有使用指针的简单方法在
    *示例 1.11* 中提出，而基于指针算术的解决方案作为 *示例 1.12* 的一部分给出。
- en: 'The following code box shows the code for *example 1.11*:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码框显示了 *示例 1.11* 的代码：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Code Box 1-23 [ExtremeC_examples_chapter1_11.c]: Iterating over an array without
    using pointer arithmetic'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 1-23 [ExtremeC_examples_chapter1_11.c]: 不使用指针算术遍历数组'
- en: 'The code in *Code Box 1-23* should be familiar to you. It just uses a *loop
    counter* to refer to a specific index of the array and read its content. But if
    you want to use pointers instead of accessing the elements via the *indexer* syntax
    (an integer between `[` and `]`), it should be done differently. The following
    code box demonstrates how to use pointers to iterate over the array boundary:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码框 1-23* 中的代码你应该很熟悉。它只是使用 *循环计数器* 来引用数组的特定索引并读取其内容。但如果你想使用指针而不是通过 *索引器* 语法（`[`
    和 `]` 之间的整数）来访问元素，应该以不同的方式完成。以下代码框演示了如何使用指针遍历数组边界：'
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Code Box 1-24 [ExtremeC_examples_chapter1_12.c]: Iterating over an array using
    pointer arithmetic'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 1-24 [ExtremeC_examples_chapter1_12.c]: 使用指针算术遍历数组'
- en: The second approach, demonstrated in *Code Box 1-24*, uses an infinite loop,
    which breaks when the address of the `ptr` pointer is the same as the last element
    of the array.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法，在 *代码框 1-24* 中演示，使用无限循环，当 `ptr` 指针的地址与数组的最后一个元素相同时会中断。
- en: We know that arrays are adjacent variables inside the memory, so incrementing
    and decrementing a pointer which is pointing to an element effectively makes it
    move back and forth inside the array and eventually point to a different element.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道数组是内存中的相邻变量，所以增加和减少一个指向元素的指针实际上使其在数组内部来回移动，最终指向不同的元素。
- en: As is clear from the preceding code, the `ptr` pointer has the data type `int*`.
    That's because of the fact that it must be able to point to any individual element
    of the array which is an integer of type `int`. Note that all the elements of
    an array are from the same type hence they have equal sizes. Therefore, incrementing
    the `ptr` pointer makes it point to the next element inside the array. As you
    see, before the `for` loop, `ptr` points to the first element of the array, and
    by further increments, it moves forward along the array's memory region. This
    is a very classic usage of pointer arithmetic.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看出，`ptr`指针的数据类型是`int*`。这是因为它必须能够指向数组的任何单个元素，该元素是类型为`int`的整数。请注意，数组的所有元素都是同一类型，因此它们具有相同的大小。因此，增加`ptr`指针使其指向数组内部的下一个元素。正如你所见，在`for`循环之前，`ptr`指向数组的第一个元素，通过进一步的增加，它沿着数组的内存区域向前移动。这是指针算术的一个非常经典的用法。
- en: 'Note that in C, an array is actually a pointer that points to its first element.
    So, in the example, the actual data type of `arr` is `int*`. Therefore, we could
    have written the line as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在C语言中，数组实际上是一个指向其第一个元素的指针。因此，在示例中，`arr`的实际数据类型是`int*`。因此，我们可以将这一行写成如下：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Instead of the line:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 代替以下行：
- en: '[PRE31]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Generic pointers
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型指针
- en: 'A pointer of type `void*` is said to be a generic pointer. It can point to
    any address like all other pointers, but we don''t know its actual data type hence
    we don''t know its arithmetic step size. Generic pointers are usually used to
    hold the content of other pointers, but they forget the actual data types of those
    pointers. Therefore, a generic pointer cannot be dereferenced, and one cannot
    do arithmetic on it because its underlying data type is unknown. The following
    example, *example 1.13*, shows us that dereferencing a generic pointer is not possible:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为`void*`的指针被称为泛型指针。它可以指向任何地址，就像所有其他指针一样，但我们不知道它的实际数据类型，因此我们不知道它的算术步长。泛型指针通常用于存储其他指针的内容，但它们忘记了那些指针的实际数据类型。因此，泛型指针不能被解引用，并且不能对其进行算术运算，因为其底层数据类型是未知的。以下示例，*示例1.13*，展示了解引用泛型指针是不可能的：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Code Box 1-25 [ExtremeC_examples_chapter1_13.c]: Dereferencing a generic pointer
    generates a compilation error!'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 1-25 [ExtremeC_examples_chapter1_13.c]：解引用泛型指针会生成编译错误！
- en: 'If you compile the preceding code using `gcc` in Linux, you will get the following
    error:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Linux中的`gcc`编译前面的代码，你会得到以下错误：
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Shell Box 1-6: Compiling example 1.13 in Linux'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 1-6：在Linux中编译示例1.13
- en: 'And if you compile it using `clang` in macOS, the error message is different,
    but it refers to the same issue:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用macOS中的`clang`编译它，错误信息不同，但它指的是相同的问题：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Shell Box 1-7: Compiling example 1.13 in macOS'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 1-7：在macOS中编译示例1.13
- en: 'As you see, both compilers don''t accept dereferencing a generic pointer. In
    fact, it is meaningless to dereference a generic pointer! So, what are they good
    for? In fact, generic pointers are very handy to define *generic functions* that
    can accept a wide range of different pointers as their input arguments. The following
    example, *example 1.14*, tries to uncover the details regarding generic functions:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这两个编译器都不接受对泛型指针进行解引用。实际上，对泛型指针进行解引用是没有意义的！那么，它们有什么用呢？实际上，泛型指针非常适合定义*泛型函数*，这些函数可以接受广泛范围的不同指针作为它们的输入参数。以下示例，*示例1.14*，试图揭示有关泛型函数的细节：
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Code Box 1-26 [ExtremeC_examples_chapter1_14.c]: An example of a generic function'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 1-26 [ExtremeC_examples_chapter1_14.c]：泛型函数的示例
- en: In the preceding code box, the `print_bytes` function receives an address as
    a `void*` pointer and an integer indicating the length. Using these arguments,
    the function prints all the bytes starting from the given address up to the given
    length. As you see, the function accepts a generic pointer, which allows the user
    to pass whatever pointer they want. Keep in mind that assignment to a *void pointer*
    (generic pointer) does *not* need an explicit cast. That is why we have passed
    the addresses of `a` and `b` without explicit casts.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码框中，`print_bytes`函数接收一个地址作为`void*`指针和一个表示长度的整数。使用这些参数，函数从指定的地址开始打印所有字节，直到指定的长度。正如你所看到的，该函数接受一个通用指针，允许用户传递他们想要的任何指针。请注意，对*void指针*（通用指针）的赋值*不需要*显式转换。这就是为什么我们没有对`a`和`b`的地址进行显式转换。
- en: Inside the `print_bytes` function, we have to use an `unsigned char` pointer
    in order to move inside the memory. Otherwise, we cannot do any arithmetic on
    the void pointer parameter, `data`, directly. As you may know, the step size of
    a `char*` or `unsigned char*` is one byte. So, it is the best pointer type for
    iterating over a range of memory addresses one byte at a time and processing all
    of those bytes one by one.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在`print_bytes`函数内部，我们必须使用一个`unsigned char`指针来在内存中移动。否则，我们无法直接对void指针参数`data`进行任何算术运算。正如你可能知道的，`char*`或`unsigned
    char*`的步长为1字节。因此，它是逐字节遍历内存地址范围并逐个处理所有这些字节的最佳指针类型。
- en: As a final note about this example, `size_t` is a standard and unsigned data
    type usually used for storing sizes in C.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个示例的最后一句话，`size_t`是一个标准的无符号数据类型，通常用于在C语言中存储大小。
- en: '`size_t` is defined in section 6.5.3.4 of the ISO/ICE 9899:TC3 standard. This
    ISO standard is the famous C99 specification revised in 2007\. This standard has
    been the basis for all C implementa[tions up until today. The link to ISO/ICE
    9899:TC3 (2007)](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf) is
    [http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`size_t`在ISO/ICE 9899:TC3标准的第6.5.3.4节中定义。这个ISO标准是著名的2007年修订的C99规范。这个标准一直是所有C语言实现的基础。ISO/ICE
    9899:TC3 (2007)的链接是[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf)。'
- en: Size of a pointer
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针大小
- en: If you search for the *size of a pointer in C* on Google, you may realize that
    you cannot find a definitive answer to that. There are many answers out there,
    and it is true that you cannot define a fixed size for a pointer in different
    architectures. The size of a pointer depends on the architecture rather than being
    a specific C concept. C doesn't worry too much about such hardware-related details,
    and it tries to provide a generic way of working with pointers and other programming
    concepts. That is why we know C as a standard. Only pointers and the arithmetic
    on them are important to C.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用谷歌搜索“C中指针的大小”，你可能会意识到你无法找到对该问题的明确答案。网上有很多答案，确实，你无法在不同的架构上为指针定义一个固定的大小。指针的大小取决于架构，而不是一个特定的C语言概念。C语言并不太关心这样的与硬件相关的细节，它试图提供一种通用的方式来处理指针和其他编程概念。这就是为什么我们称C语言为标准。对C语言来说，只有指针及其上的算术运算才是重要的。
- en: Architecture refers to the hardware used in a computer system. You will find
    more details in the upcoming chapter, *Compilation and Linking*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 架构指的是计算机系统中使用的硬件。你将在即将到来的章节“编译和链接”中找到更多细节。
- en: You can always use the `sizeof` function to obtain the size of a pointer. It
    is enough to see the result of `sizeof(char*)` on your target architecture. As
    a rule of thumb, pointers are 4 bytes in 32-bit architectures and 8 bytes in 64-bit
    architectures, but you may find different sizes in other architectures. Keep in
    mind that the code you write *should not* be dependent on a specific value for
    the size of a pointer, and it should not make any assumptions about it. Otherwise,
    you will be in trouble while porting your code to other architectures.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你始终可以使用`sizeof`函数来获取指针的大小。查看你的目标架构上`sizeof(char*)`的结果就足够了。一般来说，32位架构上的指针是4字节，64位架构上的指针是8字节，但在其他架构上你可能找到不同的大小。请记住，你编写的代码*不应该*依赖于指针大小的特定值，也不应该对其做出任何假设。否则，当你将代码移植到其他架构时，你可能会遇到麻烦。
- en: Dangling pointers
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 悬挂指针
- en: There are many known issues caused by misusing pointers. The issue of dangling
    pointers is a very famous one. A pointer usually points to an address to which
    there is a variable allocated. Reading or modifying an address where there is
    no variable registered is a big mistake and can result in a crash or a *segmentation
    fault* situation. Segmentation fault is a scary error that every C/C++ developer
    should have seen it at least once while working on code. This situation usually
    happens when you are misusing pointers. You are accessing places in memory that
    you are not allowed to. You had a variable there before, but it is deallocated
    by now.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于指针误用导致的问题有很多，悬垂指针的问题尤为著名。指针通常指向一个已分配变量的地址。读取或修改没有注册变量的地址是一个大错误，可能会导致崩溃或*段错误*情况。段错误是一个令人恐惧的错误，每个C/C++开发者至少应该在编写代码时遇到过一次。这种情况通常发生在你误用指针时。你正在访问你无权访问的内存位置。之前那里有一个变量，但现在已经被释放了。
- en: 'Let''s try to produce this situation as part of the following example, *example
    1.15*:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在以下示例中产生这种情况，*示例 1.15*：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Code Box 1-27 [ExtremeC_examples_chapter1_15.c]: Producing a segmentation fault
    situation'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-27 [ExtremeC_examples_chapter1_15.c]：产生段错误情况
- en: In the preceding example, the `create_an_integer` function is used to create
    an integer. It declares an integer with a default value and returns its address
    to the caller. In the `main` function, the address of the created integer, `var`,
    is received and it gets stored in the `ptr` pointer. Then, the `ptr` pointer is
    dereferenced, and the value stored in the `var` variable gets printed.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`create_an_integer`函数用于创建一个整数。它声明了一个具有默认值的整数并返回其地址给调用者。在`main`函数中，接收创建的整数`var`的地址并将其存储在`ptr`指针中。然后，解引用`ptr`指针，并打印出`var`变量中的值。
- en: 'But things are not that easy. When you want to compile this code using the
    `gcc` compiler on a Linux machine, it generates a warning as follows, but still
    successfully finishes the compilation, and you get the final executable:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但事情并不那么简单。当你想在Linux机器上使用`gcc`编译器编译这段代码时，它会生成以下警告，但仍然成功完成编译，并得到最终的可执行文件：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Shell Box 1-8: Compiling example 1.15 in Linux'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 1-8：在 Linux 中编译 example 1.15
- en: This is indeed an important warning message which can be easily missed and forgotten
    by the programmer. We'll talk more about this later as part of *Chapter 5*, *Stack
    and Heap*. Let's see what happens if we proceed and execute the resulting executable.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一条重要的警告信息，程序员很容易忽略并忘记。我们将在*第五章*，*栈和堆*中更详细地讨论这个问题。让我们看看如果我们继续执行生成的可执行文件会发生什么。
- en: 'When you run *example 1.15*, you get a segmentation fault error, and the program
    crashes immediately:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行*示例 1.15*时，你会得到一个段错误错误，程序会立即崩溃：
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Shell Box 1-9: Segmentation fault when running example 1.15'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 1-9：运行 example 1.15 时发生段错误
- en: So, what went wrong? The `ptr` pointer is dangling and points to an already
    deallocated portion of memory that was known to be the memory place of the variable,
    `var`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，出了什么问题呢？`ptr`指针是悬垂的，它指向一个已释放的内存部分，这部分内存曾经是变量`var`的内存位置。
- en: The `var` variable is a local variable to the `create_an_integer` function,
    and it will be deallocated after leaving the function, but its address can be
    returned from the function. So, after copying the returned address into `ptr`
    as part of the `main` function, `ptr` becomes a dangling pointer pointing to an
    invalid address in memory. Now, dereferencing the pointer causes a serious problem
    and the program crashes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`变量是`create_an_integer`函数的局部变量，在离开函数后将被释放，但其地址可以从函数中返回。因此，在将返回的地址复制到`main`函数中的`ptr`作为部分内容后，`ptr`变成了一个悬垂指针，指向内存中的无效地址。现在，解引用指针会导致严重问题，程序会崩溃。'
- en: If you look back at the warning generated by the compiler, it is clearly stating
    the problem.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾编译器生成的警告，它清楚地指出了问题。
- en: It says that you are *returning the address of a local variable*, which will
    be deallocated after returning from the function. Smart compiler! If you take
    these warnings seriously, you won't face these scary bugs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 它说你在*返回局部变量的地址*，这个地址在函数返回后将被释放。聪明的编译器！如果你认真对待这些警告，你就不会遇到这些令人恐惧的bug。
- en: But what is the proper way to rewrite the example? Yes, using the *Heap memory*.
    We will cover heap memory fully in *Chapter 4*, *Process Memory Structure*, and
    *Chapter 5*, *Stack and Heap*, but, for now, we will rewrite the example using
    *Heap allocation*, and you will see how you can benefit from using *Heap* instead
    of the *Stack*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，重写示例的正确方法是什么？是的，使用 *堆内存*。我们将在 *第四章* *进程内存结构* 和 *第五章* *栈和堆* 中全面介绍堆内存，但现在，我们将使用
    *堆分配* 来重写示例，你将看到如何从使用 *堆* 而不是 *栈* 中受益。
- en: '*Example 1.16* below shows how to use Heap memory for allocating variables,
    and enabling the passing addresses between functions without facing any issues:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1.16* 以下展示了如何使用堆内存分配变量，并允许函数之间传递地址而不遇到任何问题：'
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Code Box 1-28 [ExtremeC_examples_chapter1_16.c]: Rewriting example 1.15 using
    Heap memory'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 1-28 [ExtremeC_examples_chapter1_16.c]: 使用堆内存重写示例 1.15'
- en: 'As you see in the preceding code box, we have included a new header file, `stdlib.h`,
    and we are using two new functions, `malloc` and `free`. The simple explanation
    is like this: the created integer variable inside the `create_an_integer` function
    is not a local variable anymore. Instead, it is a variable allocated from the
    Heap memory and its lifetime is not limited to the function declaring it. Therefore,
    it can be accessed in the caller (outer) function. The pointers pointing to this
    variable are not dangling anymore, and they can be dereferenced as long as the
    variable exists and is not freed. Eventually, the variable becomes deallocated
    by calling the `free` function as an end to its lifetime. Note that deallocating
    a Heap variable is mandatory when it is not needed anymore.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的代码框中看到的，我们包含了一个新的头文件 `stdlib.h`，并且使用了两个新的函数，`malloc` 和 `free`。简单的解释是这样的：在
    `create_an_integer` 函数内部创建的整型变量不再是局部变量了。相反，它是一个从堆内存分配的变量，其生命周期不再局限于声明它的函数。因此，它可以在调用者（外部）函数中被访问。指向这个变量的指针也不再是悬垂指针了，只要变量存在且没有被释放，它们就可以被解引用。最终，通过调用
    `free` 函数来释放变量，结束其生命周期。请注意，当不再需要堆变量时，释放堆变量是强制性的。
- en: In this section, we went through all the essential discussions regarding variable
    pointers. In the upcoming section, we'll be talking about functions and their
    anatomy in C.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了有关变量指针的所有基本问题。在下一节中，我们将讨论 C 中的函数及其解剖结构。
- en: Some details about functions
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于函数的一些细节
- en: C is a *procedural* programming language. In C, functions act as procedures,
    and they are building blocks of a C program. So, it is important to know what
    they are, how they behave, and what is happening when you enter or leave a function.
    In general, functions (or procedures) are analogous to ordinary variables that
    store algorithms instead of values. By putting variables and functions together
    into a new type, we can store relevant values and algorithms under the same concept.
    This is what we do in *object-oriented programming*, and it will be covered in
    the third part of the book, *Object Orientation*. In this section, we want to
    explore functions and discuss their properties in C.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: C 是一种 *过程式* 编程语言。在 C 中，函数充当过程，它们是 C 程序的构建块。因此，了解它们是什么，它们如何表现，以及当你进入或离开函数时会发生什么，是很重要的。一般来说，函数（或过程）类似于普通变量，它们存储算法而不是值。通过将变量和函数组合成新的类型，我们可以在相同的概念下存储相关的值和算法。这就是我们在
    *面向对象编程* 中所做的事情，它将在本书的第三部分 *面向对象* 中介绍。在本节中，我们想要探索函数，并讨论它们在 C 中的属性。
- en: Anatomy of a function
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的解剖结构
- en: In this section, we want to recap everything about a C function in a single
    place. If you feel this is familiar to you, you can simply skip this section.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们希望在单个地方回顾有关 C 函数的所有内容。如果你觉得这对你来说很熟悉，你可以简单地跳过这一节。
- en: A function is a box of logic that has a name, a list of input parameters, and
    a list of output results. In C and many other programming languages that are influenced
    by C, functions return only one value. In object-oriented languages such as C++
    and Java, functions (which are usually called *methods*) can also throw an *exception*,
    which is not the case for C. Functions are invoked by a function call, which is
    simply using the name of the function to execute its logic. A correct function
    call should pass all required arguments to the function and wait for its execution.
    Note that functions are always *blocking* in C. This means that the caller has
    to wait for the called function to finish and only then can it collect the returned
    result.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一个具有名称、输入参数列表和输出结果列表的逻辑盒子。在C语言以及受C语言影响的许多其他编程语言中，函数只返回一个值。在C++和Java这样的面向对象语言中，函数（通常称为*方法*）也可以抛出*异常*，而C语言则不行。函数通过函数调用来调用，即简单地使用函数名称来执行其逻辑。正确的函数调用应该传递所有必需的参数给函数，并等待其执行。请注意，在C语言中，函数总是*阻塞*的。这意味着调用者必须等待被调用函数完成，然后才能收集返回的结果。
- en: Opposite to a blocking function, we can have a *non-blocking* function. When
    calling a non-blocking function, the caller doesn't wait for the function to finish
    and it can continue its execution. In this scheme, there is usually a *callback*
    mechanism which is triggered when the called (or callee) function is finished.
    A non-blocking function can also be referred to as an *asynchronous function*
    or simply an *async function*. Since we don't have async functions in C, we need
    to implement them using multithreading solutions. We will explain these concepts
    in more detail in the fifth part of the book, *Concurrency*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 与阻塞函数相反，我们可以有一个*非阻塞*函数。在调用非阻塞函数时，调用者不需要等待函数完成，它可以继续执行。在这种方案中，通常有一个*回调*机制，当被调用（或被调用者）函数完成时触发。非阻塞函数也可以称为*异步函数*或简单地称为*async函数*。由于C语言中没有异步函数，我们需要使用多线程解决方案来实现它们。我们将在本书的第五部分*并发*中更详细地解释这些概念。
- en: It is interesting to add that nowadays, there is a growing interest in using
    non-blocking functions over blocking functions. It is usually referred to as *event-oriented
    programming*. Non-blocking functions are centric in this programming approach,
    and most of the written functions are non-blocking.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，现在对使用非阻塞函数而非阻塞函数的兴趣日益增长。这通常被称为*事件驱动编程*。在这种编程方法中，非阻塞函数是核心，大多数编写的函数都是非阻塞的。
- en: In event-oriented programming, actual function calls happen inside an *event
    loop*, and proper callbacks are triggered upon the occurrence of an event. Frameworks
    such as `libuv` and `libev` promote this way of coding, and they allow you to
    design your software around one or several event loops.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动编程中，实际的功能调用发生在*事件循环*内部，并且当事件发生时，会触发适当的回调。例如，`libuv`和`libev`这样的框架推广了这种编程方式，并允许你围绕一个或多个事件循环来设计你的软件。
- en: Importance in design
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计中的重要性
- en: Functions are fundamental building blocks of procedural programming. Since their
    official support in programming languages, they have had a huge impact on the
    way we write code. Using functions, we can store logic in semi-variable entities
    and summon them whenever and wherever they are needed. Using them, we can write
    a specific logic only once and use it multiple times in various places.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是过程式编程的基本构建块。自从编程语言中正式支持它们以来，它们对我们编写代码的方式产生了巨大影响。使用函数，我们可以将逻辑存储在半变量实体中，并在需要时随时随地进行调用。使用它们，我们只需编写一次特定逻辑，就可以在多个地方多次使用。
- en: In addition, functions allow us to hide a piece of logic from other existing
    logic. In other words, they introduce a level of abstraction between various logical
    components. To give an example, suppose that you have a function, `avg`, which
    calculates the average of an input array. And you have another function, `main`,
    which calls the function, `avg`. We say that the logic inside the `avg` function
    is hidden from the logic inside the `main` function.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，函数允许我们隐藏一段逻辑，使其不被其他现有逻辑看到。换句话说，它们在各个逻辑组件之间引入了一个抽象层次。例如，假设你有一个名为`avg`的函数，它计算输入数组的平均值。你还有一个名为`main`的函数，它调用`avg`函数。我们说`avg`函数内部的逻辑对`main`函数内部的逻辑是隐藏的。
- en: Therefore, if you want to change the logic inside `avg`, you don't need to change
    the logic inside the `main` function. That's because the `main` function only
    depends on the name and the availability of the `avg` function. This is a great
    achievement, at least for those years when we had to use punched cards to write
    and execute programs!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想更改`avg`函数内部的逻辑，你不需要更改`main`函数内部的逻辑。这是因为`main`函数只依赖于`avg`函数的名称和可用性。这是一个巨大的成就，至少在我们不得不使用穿孔卡片来编写和执行程序的那些年里是这样！
- en: We are still using this feature in designing libraries written in C or even
    higher-level programming languages such as C++ and Java.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然在使用这个特性来设计用C编写的库，甚至是C++和Java这样的高级编程语言。
- en: Stack management
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈管理
- en: If you look at the memory layout of a process running in a Unix-like operating
    system, you notice that all of the processes share a similar layout. We will discuss
    this layout in more detail in *Chapter 4*, *Process Memory Structure*, but for
    now, we want to introduce one of its *segments*; the Stack segment. The Stack
    segment is the default memory location where all local variables, arrays, and
    structures are allocated from. So, when you declare a local variable in a function,
    it is being allocated from the Stack segment. This allocation always happens on
    top of the Stack segment.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看在类Unix操作系统中运行的过程的内存布局，你会注意到所有进程都共享一个类似的布局。我们将在 *第4章*，*进程内存结构* 中更详细地讨论这个布局，但现在，我们想要介绍其
    *段* 之一；栈段。栈段是所有局部变量、数组和结构默认分配的内存位置。所以，当你在一个函数中声明一个局部变量时，它就是从栈段分配的。这种分配总是在栈段顶部发生。
- en: Notice the term *stack* in the name of the segment. It means that this segment
    behaves like a stack. The variables and arrays are always allocated on top of
    it, and those at the top are the first variables to get removed. Remember this
    analogy with the stack concept. We will return to this in the next paragraph.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到段名称中的术语 *栈*。这意味着这个段的行为就像一个栈。变量和数组总是分配在其顶部，而顶部的变量是首先被移除的。记住这个与栈概念的类比。我们将在下一段中回到这个话题。
- en: The Stack segment is also used for function calls. When you call a function,
    a *stack frame* containing the return address and all of the passing arguments
    is put on top of the Stack segment, and only then is the function logic executed.
    When returning from the function, the stack frame is popped out, and the instruction
    addressed by the return address gets executed, which should usually continue the
    caller function.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 栈段也用于函数调用。当你调用一个函数时，一个包含返回地址和所有传递参数的 *栈帧* 被放置在栈段顶部，然后才执行函数逻辑。当从函数返回时，栈帧被弹出，由返回地址指定的指令被执行，这通常应该继续调用函数。
- en: All local variables declared in the function body are put on top of the Stack
    segment. So, when leaving the function, all Stack variables become freed. That
    is why we call them *local variables* and that is why a function cannot access
    the variables in another function. This mechanism also explains why local variables
    are not defined before entering a function and after leaving it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体内声明的所有局部变量都被放置在栈段顶部。所以，当离开函数时，所有栈变量都会被释放。这就是为什么我们称它们为 *局部变量*，也是为什么一个函数不能访问另一个函数中的变量。这种机制也解释了为什么在进入函数之前和离开函数之后不会定义局部变量。
- en: Understanding the Stack segment and the way it works is crucial to writing correct
    and meaningful code. It also prevents common memory bugs from occurring. It is
    also a reminder that you cannot create any variable on the Stack with any size
    you like. The Stack is a limited portion of memory, and you could fill it up and
    potentially receive a *stack overflow* error. This usually happens when we have
    too many function calls consuming up all the Stack segment by their stack frames.
    This is very common when dealing with recursive functions, when a function calls
    itself without any break condition or limit.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 理解栈段及其工作方式对于编写正确和有意义的代码至关重要。它还能防止常见的内存错误发生。它也是一个提醒，你不能在栈上创建任何你想要的尺寸的变量。栈是内存的一个有限部分，你可能会填满它并可能收到
    *栈溢出* 错误。这通常发生在我们有很多函数调用消耗了所有的栈段，它们的栈帧时。这在处理递归函数时非常常见，当函数在没有任何中断条件或限制的情况下调用自己时。
- en: Pass-by-value versus pass-by-reference
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值传递与引用传递
- en: In most computer programming books, there is a section dedicated to pass-by-value
    and pass-by-reference regarding the arguments passed to a function. Fortunately,
    or unfortunately, we have only pass-by-value in C.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数计算机编程书籍中，都有一个关于函数参数按值传递和按引用传递的章节。幸运的是，或者不幸的是，在 C 中我们只有按值传递。
- en: There is no reference in C, so there is no pass-by-reference either. Everything
    is copied into the function's local variables, and you cannot read or modify them
    after leaving a function.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中没有引用，因此也没有按引用传递。所有内容都复制到函数的局部变量中，函数退出后无法读取或修改它们。
- en: 'Despite the many examples that seem to demonstrate pass-by-reference function
    calls, I should say that passing by reference is an illusion in C. In the rest
    of this section, we want to uncover this illusion and convince you that those
    examples are also pass-by-value. The following example will demonstrate this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有许多示例似乎证明了按引用传递函数调用，但我应该说的是，在 C 中按引用传递是一种错觉。在本节的其余部分，我们想要揭露这个错觉，并说服你那些示例也是按值传递。以下示例将演示这一点：
- en: '[PRE40]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Code Box 1-29 [ExtremeC_examples_chapter1_17.c]: An example of a pass-by-value
    function call'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 1-29 [ExtremeC_examples_chapter1_17.c]：一个按值传递函数调用的示例
- en: 'It is easy to predict the output. Nothing changes about the `x` variable because
    it is passed by value. The following shell box shows the output of *example 1.17*
    and confirms our prediction:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 预测输出很容易。`x` 变量没有变化，因为它是以值传递的。以下 shell box 展示了 *示例 1.17* 的输出并证实了我们的预测：
- en: '[PRE41]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Shell Box 1-10: Output of example 1.17'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 1-10：示例 1.17 的输出
- en: 'The following example, *example 1.18*, demonstrates that passing by reference
    doesn''t exist in C:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例，*示例 1.18*，演示了在 C 中不存在按引用传递：
- en: '[PRE42]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Code Box 1-30 [ExtremeC_examples_chapter1_18.c]: An example of pass-by-pointer
    function call which differs from pass-by-reference'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 1-30 [ExtremeC_examples_chapter1_18.c]：一个按指针传递函数调用的示例，与按引用传递不同
- en: 'And this is the output:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是输出结果：
- en: '[PRE43]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Shell Box 1-11: Output of example 1.18'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 1-11：示例 1.18 的输出
- en: As you see, the value of the pointer is not changed after the function call.
    This means that the pointer is passed as a pass-by-value argument. Dereferencing
    the pointer inside the `func` function has allowed accessing the variable where
    the pointer is pointing to. But you see that changing the value of the pointer
    parameter inside the function doesn't change its counterpart argument in the caller
    function. During a function call in C, all arguments are passed by value and dereferencing
    the pointers allows the modification of the caller function's variables.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，函数调用后指针的值没有改变。这意味着指针是以按值传递的参数传递的。在 `func` 函数内部解引用指针允许访问指针指向的变量。但你看到，在函数内部改变指针参数的值并不会改变调用函数中的对应参数。在
    C 的函数调用过程中，所有参数都是按值传递的，解引用指针允许修改调用函数的变量。
- en: It is worth adding that the above example demonstrates a pass-by-pointer example
    in which we pass pointers to variables instead of passing them directly. It is
    usually recommended to use pointers as arguments instead of passing big objects
    to a function but why? It is easy to guess. Copying 8 bytes of a pointer argument
    is much more efficient than copying hundreds of bytes of a big object.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，上述示例演示了一个按指针传递的示例，其中我们传递变量的指针而不是直接传递它们。通常建议使用指针作为参数而不是将大对象传递给函数，但为什么？这很容易猜测。复制指针参数的
    8 个字节比复制大对象的数百个字节要高效得多。
- en: Surprisingly, passing the pointer is not efficient in the above example! That's
    because of the fact that the `int` type is 4 bytes and copying it is more efficient
    than copying 8 bytes of its pointer. But this is not the case regarding structures
    and arrays. Since copying structures and arrays is done byte-wise, and all of
    the bytes in them should be copied one by one, it is usually better to pass pointers
    instead.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 意外地，在上面的示例中传递指针并不高效！这是因为 `int` 类型是 4 个字节，复制它比复制其指针的 8 个字节更高效。但结构体和数组的情况并非如此。由于结构体和数组的复制是按字节进行的，并且它们中的所有字节都应该一个接一个地复制，因此通常最好传递指针。
- en: Now that we've covered some details regarding the functions in C, let's talk
    about function pointers.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了有关 C 中函数的一些细节，让我们来谈谈函数指针。
- en: Function pointers
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数指针
- en: 'Having function pointers is another super feature of the C programming language.
    The two previous sections were about variable pointers and functions, and this
    section is going to combine them and talk about a more interesting topic: pointers
    to functions.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针是C编程语言的另一个超级特性。前两个部分是关于变量指针和函数的，本节将结合它们，讨论一个更有趣的话题：函数指针。
- en: They have many applications, but splitting a large binary into smaller binaries
    and loading them again in another small executable is one of the most important
    applications. This has led to *modularization* and software design. Function pointers
    are building blocks for the implementation of polymorphism in C++ and allow us
    to extend our existing logic. In this section, we are going to cover them and
    prepare you for more advanced topics we'll cover over the coming chapters.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有众多应用，但将大型二进制文件拆分为较小的二进制文件，并在另一个小的可执行文件中重新加载，是其中最重要的应用之一。这导致了*模块化*和软件设计。函数指针是C++中实现多态性的构建块，并允许我们扩展现有的逻辑。在本节中，我们将介绍它们，并为我们在接下来的章节中将要覆盖的更高级主题做好准备。
- en: 'Like a variable pointer addressing a variable, a function pointer addresses
    a function and allows you to call that function indirectly. The following example,
    *example 1.19*, can be a good starter for this topic:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 就像变量指针指向变量一样，函数指针指向函数，并允许你间接调用该函数。下面的例子，*例子1.19*，可以作为这个主题的良好起点：
- en: '[PRE44]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Code Box 1-31 [ExtremeC_examples_chapter1_19.c]: Using a single function pointer
    to call different functions'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 1-31 [ExtremeC_examples_chapter1_19.c]：使用单个函数指针调用不同的函数
- en: In the preceding code box, `func_ptr` is a function pointer. It can only point
    to a specific class of functions that match its signature. The signature limits
    the pointer to only point to functions that accept two integer arguments and return
    an integer result.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码框中，`func_ptr`是一个函数指针。它只能指向与它的签名相匹配的特定类别的函数。签名限制了指针只能指向接受两个整数参数并返回整数结果的函数。
- en: 'As you see, we have defined two functions called `sum` and `subtract` matching
    the `func_ptr` pointer''s signature. The preceding example uses the `func_ptr`
    function pointer to point to the `sum` and `subtract` functions separately, then
    call them with the same arguments and compare the results. This is the output
    of the example:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们定义了两个名为`sum`和`subtract`的函数，它们与`func_ptr`指针的签名相匹配。先前的例子使用`func_ptr`函数指针分别指向`sum`和`subtract`函数，然后使用相同的参数调用它们并比较结果。这是例子的输出：
- en: '[PRE45]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Shell Box 1-12: Output of example 1.19'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 1-12：例子1.19的输出
- en: As you see in *example 1.19*, we can call different functions for the same list
    of arguments using a single function pointer, and this is an important feature.
    If you are familiar with object-oriented programming, the first thing that comes
    to mind is *polymorphism* and *virtual functions*. In fact, this is the only way
    to support polymorphism in C and mimic the C++ virtual functions. We will cover
    OOP as part of the third part of the book, *Object* *Orientation*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在*例子1.19*中看到的，我们可以使用单个函数指针调用具有相同参数列表的不同函数，这是一个重要的特性。如果你熟悉面向对象编程，首先想到的可能是*多态*和*虚函数*。实际上，这是在C语言中支持多态并模仿C++虚函数的唯一方法。我们将作为本书第三部分*对象*
    *导向*的一部分介绍面向对象编程。
- en: Like variable pointers, it is important to initialize function pointers properly.
    For those function pointers which are not going to be initialized immediately
    upon declaration, it is mandatory to make them null. The nullification of function
    pointers is demonstrated in the preceding example, and it is pretty similar to
    variable pointers.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 就像变量指针一样，正确初始化函数指针非常重要。对于那些在声明时不会立即初始化的函数指针，必须将它们设置为null。函数指针的null化在先前的例子中得到了演示，并且它与变量指针非常相似。
- en: 'It is usually advised to define a new *type alias* for function pointers. The
    following example, *example 1.20*, demonstrates the way it should be done:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议为函数指针定义一个新的*类型别名*。下面的例子，*例子1.20*，演示了应该如何做：
- en: '[PRE46]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Code Box 1-32 [ExtremeC_examples_chapter1_20.c]: Using a single function pointer
    to call different functions'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 1-32 [ExtremeC_examples_chapter1_20.c]：使用单个函数指针调用不同的函数
- en: 'The `typedef` keyword allows you to define an alias for an already defined
    type. There are two new type aliases in the preceding example: `bool_t`, which
    is an alias for the `int` type, and the `less_than_func_t` type, which is an alias
    type for the function pointer type, `bool_t (*)(int, int)`. These aliases add
    readability to the code and let you choose a shorter name for a long and complex
    type. In C, the name of a new type usually ends with `_t` by convention, and you
    can find this convention in many other standard type aliases such as `size_t`
    and `time_t`.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`typedef` 关键字允许你为已定义的类型定义一个别名。在先前的例子中有两个新的类型别名：`bool_t`，它是 `int` 类型的别名，以及 `less_than_func_t`
    类型，它是函数指针类型 `bool_t (*)(int, int)` 的别名类型。这些别名增加了代码的可读性，并允许你为长而复杂的类型选择一个更短的名字。在
    C 语言中，新类型的名字通常以 `_t` 结尾，你可以在许多其他标准类型别名中找到这个约定，例如 `size_t` 和 `time_t`。'
- en: Structures
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: From the design perspective, structures are one of the most fundamental concepts
    in C. Nowadays, they are not unique to C, and you can find their twin concepts
    nearly in every modern programming language.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 从设计角度来看，结构体是 C 语言中最基本的概念之一。如今，它们不再仅限于 C 语言，你几乎可以在每种现代编程语言中找到它们对应的理念。
- en: But we should discuss them in the history of computation when there were no
    other programming languages offering such a concept. Among many efforts to move
    away from machine-level programming languages, introducing structures was a great
    step toward having *encapsulation* in a programming language. For thousands of
    years, the way we think hasn't changed a lot, and encapsulation has been a centric
    means for our logical reasoning.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们应该在计算历史的背景下讨论它们，当时没有其他编程语言提供这样的概念。在许多努力摆脱机器级编程语言的尝试中，引入结构体是朝着在编程语言中实现**封装**迈出的重要一步。数千年来，我们的思维方式并没有发生太大的变化，封装一直是我们的逻辑推理的核心手段。
- en: But it was just after C that we finally had some tool, in this case, a programming
    language, which was able to understand the way we think and could store and process
    the building blocks of our reasoning. Finally, we got a language that resembles
    our thoughts and ideas, and all of this happened when we got structures. C structures
    weren't perfect in comparison to the encapsulation mechanisms found in modern
    languages, but they were enough for us to build a platform upon which to create
    our finest tools.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 C 语言之后，我们终于有了某种工具，在这种情况下，是一种编程语言，它能够理解我们的思维方式，并能存储和处理我们推理的构建块。最终，我们得到了一种类似于我们思维和想法的语言，所有这一切都发生在我们得到结构体的时候。与现代语言中发现的封装机制相比，C
    语言的结构体并不完美，但它们足以让我们构建一个平台，在这个平台上创建我们最好的工具。
- en: Why structures?
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要结构体？
- en: You know that every programming language has some **Primitive Data Types** (**PDTs**).
    Using these PDTs, you can design your data structures and write your algorithms
    around them. These PDTs are part of the programming language, and they cannot
    be changed or removed. As an example, you cannot have C without the primitive
    types, `int` and `double`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道每种编程语言都有一些**基本数据类型**（**PDTs**）。使用这些基本数据类型，你可以设计你的数据结构，并围绕它们编写算法。这些基本数据类型是编程语言的一部分，它们不能被更改或删除。例如，没有
    `int` 和 `double` 这两种基本类型，你将无法使用 C 语言。
- en: Structures come into play when you need to have your own defined data types,
    and the data types in the language are not enough. **User-Defined Types** (**UDTs**)
    are those types which are created by the user and they are not part of the language.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要自定义数据类型，而语言中的数据类型又不足以满足需求时，结构体就派上用场了。**用户定义类型**（**UDTs**）是由用户创建的类型，它们不是语言的一部分。
- en: Note that UDTs are different from the types you could define using `typedef`.
    The keyword `typedef` doesn't really create a new type, but rather it defines
    an alias or synonym for an already defined type. But structures allow you to introduce
    totally new UDTs into your program.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，用户定义类型（UDTs）与使用 `typedef` 定义的类型不同。关键字 `typedef` 并没有真正创建一个新类型，而是为已定义的类型定义了一个别名或同义词。但结构体允许你将全新的用户定义类型（UDTs）引入到你的程序中。
- en: Structures have twin concepts in other programming languages, for example, classes
    in C++ and Java or packages in Perl. They are considered to be the *type-makers*
    in these languages.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体在其他编程语言中具有对应的概念，例如 C++ 和 Java 中的类或 Perl 中的包。在这些语言中，它们被认为是**类型创建者**。
- en: Why user-defined types?
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要用户定义类型？
- en: So, why do we need to create new types in a program? The answer to this question
    reveals the principles behind software design and the methods we use for our daily
    software development. We create new types because we do it every day using our
    brains in a routine analysis.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们需要在程序中创建新的类型呢？这个问题的答案揭示了软件设计背后的原则以及我们用于日常软件开发的 方法。我们创建新的类型，因为我们每天都在用大脑进行常规分析时这样做。
- en: We don't look at our surroundings as integers, doubles, or characters. We have
    learned to group related attributes under the same object. We will discuss more
    the way we analyze our surroundings in *Chapter 6*, *OOP and Encapsulation*. But
    as an answer to our starting question, we need new types because we use them to
    analyze our problems at a higher level of logic, close enough to our human logic.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会把周围的环境看作整数、双精度浮点数或字符。我们已经学会了将相关的属性分组到同一个对象下。我们将在*第6章*，*面向对象编程和封装*中更详细地讨论我们分析周围环境的方式。但作为对起始问题的回答，我们需要新的类型，因为我们使用它们在更高层次的逻辑上分析我们的问题，接近于人类的逻辑。
- en: Here, you need to become familiar with the term *business logic*. Business logic
    is a set of all entities and regulations found in a business. For example, in
    the business logic of a banking system, you face concepts such as client, account,
    balance, money, cash, payment, and many more, which are there to make operations
    such as money withdrawal possible and meaningful.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你需要熟悉**商业逻辑**这个术语。商业逻辑是在商业中找到的所有实体和规则的总和。例如，在银行系统的商业逻辑中，你会遇到客户、账户、余额、货币、现金、支付等概念，这些都是为了使货币提取等操作成为可能和有意义的。
- en: Suppose that you had to explain some banking logic in pure integers, floats,
    or characters. It is almost impossible. If it is possible for programmers, it
    is almost meaningless to *business analysts*. In a real software development environment
    that has a well-defined business logic, programmers and business analysts cooperate
    closely. Therefore, they need to have a shared set of terminology, glossary, types,
    operations, regulations, logic, and so on.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你必须用纯整数、浮点数或字符来解释一些银行逻辑。这几乎是不可能的。如果对程序员来说可能，那么对**商业分析师**来说几乎毫无意义。在一个具有明确商业逻辑的真实软件开发环境中，程序员和商业分析师需要紧密合作。因此，他们需要拥有一套共享的术语、词汇表、类型、操作、规则、逻辑等等。
- en: Today, a programming language that does not support new types in its *type system*
    can be considered as a dead language. Maybe that's why most people see C as a
    dead programming language, mainly because they cannot easily define their new
    types in C, and they prefer to move to a higher-level language such as C++ or
    Java. Yes, it's not that easy to create a nice type system in C, but everything
    you need is present there.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，不支持在其*类型系统*中创建新类型的编程语言可以被认为是一种死语言。也许这就是为什么大多数人认为C是一种死编程语言，主要是因为他们无法在C中轻松定义新的类型，他们更愿意转向C++或Java等高级语言。是的，在C中创建一个良好的类型系统并不容易，但你需要的一切都在那里。
- en: Even today, there can be many reasons behind choosing C as the project's main
    language and accepting the efforts of creating and maintaining a nice type system
    in a C project and even today many companies do that.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 即使今天，选择C作为项目的主要语言，并接受在C项目中创建和维护一个良好的类型系统的努力，背后可能有多种原因。甚至今天，许多公司都在这样做。
- en: Despite the fact that we need new types in our daily software analysis, CPUs
    do not understand these new types. CPUs try to stick to the PDTs and fast calculations
    because they are designed to do that. So, if you have a program written in your
    high-level language, it should be translated to CPU level instructions, and this
    may cost you more time and resources.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们每天在软件分析中需要新的类型，但CPU并不理解这些新的类型。CPU试图坚持PDTs（程序数据类型）和快速计算，因为它们被设计成这样做。所以，如果你用高级语言编写了一个程序，它应该被翻译成CPU级别的指令，这可能会花费你更多的时间和资源。
- en: In this sense, fortunately, C is not very far away from the CPU-level logic,
    and it has a type system which can be easily translated. You may have heard that
    C is a low-level or hardware-level programming language. This is one of the reasons
    why some companies and organizations try to write and maintain their core frameworks
    in C, even today.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种意义上，幸运的是，C与CPU级别的逻辑并不遥远，它有一个可以轻松转换的类型系统。你可能听说过C是一种低级或硬件级别的编程语言。这是为什么一些公司和组织试图用C编写和维护他们的核心框架，即使今天也是如此。
- en: What do structures do?
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构有什么作用？
- en: 'Structures encapsulate related values under a single unified type. As an early
    example, we can group `red`, `green`, and `blue` variables under a new single
    data type called `color_t`. The new type, `color_t`, can represent an RGB color
    in various programs like an image editing application. We can define the corresponding
    C structure as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体将相关的值封装在单个统一类型下。作为一个早期示例，我们可以将`red`、`green`和`blue`变量组合在一个新的单一数据类型`color_t`下。新的类型`color_t`可以在各种程序中表示RGB颜色，例如图像编辑应用程序。我们可以定义相应的C结构体如下：
- en: '[PRE47]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Code Box 1-33: A structure in C representing an RGB color'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框1-33：C语言中表示RGB颜色的结构体
- en: As we said before, structures do encapsulation. Encapsulation is one of the
    most fundamental concepts in software design. It is about grouping and encapsulating
    related fields under a new type. Then, we can use this new type to define the
    required variables. We will describe encapsulation thoroughly in *Chapter 6*,
    *OOP and Encapsulation*, while talking about object-oriented design.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，结构体具有封装性。封装是软件设计中最基本的概念之一。它涉及到将相关的字段分组并封装在一个新的类型下。然后，我们可以使用这个新类型来定义所需的变量。我们将在*第6章*，*面向对象编程与封装*中详细描述封装，同时讨论面向对象设计。
- en: Note that we use an `_t` suffix for naming new data types.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`_t`后缀来命名新的数据类型。
- en: Memory layout
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存布局
- en: It is usually important to C programmers to know exactly the memory layout of
    a structure variable. Having a bad layout in memory could cause performance degradations
    in certain architectures. Don't forget that we code to produce the instructions
    for the CPU. The values are stored in the memory, and the CPU should be able to
    read and write them fast enough. Knowing the memory layout helps a developer to
    understand the way the CPU works and to adjust their code to gain a better result.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C程序员来说，了解结构变量的确切内存布局通常很重要。在内存中有一个糟糕的布局可能会在某些架构中导致性能下降。不要忘记，我们编写代码是为了生成CPU的指令。值存储在内存中，CPU应该能够足够快地读写它们。了解内存布局有助于开发者理解CPU的工作方式，并调整他们的代码以获得更好的结果。
- en: 'The following example, *example 1.21*, defines a new structure type, `sample_t`,
    and declares one structure variable, `var`. Then, it populates its fields with
    some values and prints the size and the actual bytes of the variable in the memory.
    This way, we can observe the memory layout of the variable:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例，*示例1.21*，定义了一个新的结构类型`sample_t`，并声明了一个结构变量`var`。然后，它用一些值填充其字段，并打印变量在内存中的大小和实际字节数。这样，我们可以观察变量的内存布局：
- en: '[PRE48]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Code Box 1-34 [ExtremeC_examples_chapter1_21.c]: Printing the number of the
    bytes allocated for a structure variable'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框1-34 [ExtremeC_examples_chapter1_21.c]：打印分配给结构变量的字节数
- en: The thirst to know the exact memory layout of everything is a bit C/C++ specific,
    and vanishes as the programming languages become high level. For example, in Java
    and Python, the programmers tend to know less about the very low-level memory
    management details, and on the other hand, these languages don't provide many
    details about the memory.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 对了解一切的确切内存布局的渴望是C/C++特有的，随着编程语言变得高级，这种渴望会消失。例如，在Java和Python中，程序员对非常低级的内存管理细节了解较少，另一方面，这些语言不提供很多关于内存的细节。
- en: As you see in *Code Box 1-34*, in C, you have to use the `struct` keyword before
    declaring a structure variable. Therefore, in the preceding example we have `struct
    sample_t var`, which shows how you should use the keyword before the structure
    type in the declaration clause. It is trivial to mention that you need to use
    a `.` (dot) to access the fields of a structure variable. If it is a structure
    pointer, you need to use `->` (arrow) to access its fields.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在*代码框1-34*中看到的，在C语言中，在声明结构变量之前必须使用`struct`关键字。因此，在前面的例子中我们有`struct sample_t
    var`，这展示了你应该如何在声明语句中使用关键字在结构类型之前。提到这一点是显而易见的，你需要使用一个`.`（点）来访问结构变量的字段。如果它是一个结构指针，你需要使用`->`（箭头）来访问其字段。
- en: 'In order to prevent typing a lot of `struct`s throughout the code, while defining
    a new structure type and while declaring a new structure variable, we could use
    `typedef` to define a new alias type for the structure. Following is an example:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止在代码中大量使用`struct`，在定义一个新的结构类型和声明一个新的结构变量时，我们可以使用`typedef`来为结构定义一个新的别名类型。以下是一个示例：
- en: '[PRE49]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, you can declare the variable without using the keyword `struct`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以声明变量而不使用`struct`关键字：
- en: '[PRE50]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following is the output of the preceding example after being compiled and
    executed on a macOS machine. Note that the numbers generated may vary depending
    upon the host system:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 macOS 机器上编译并执行前一个示例后的输出。请注意，生成的数字可能因主机系统而异：
- en: '[PRE51]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Shell Box 1-13: Output of example 1.21'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell Box 1-13: 示例 1.21 的输出'
- en: As you see in the preceding shell box, `sizeof(sample_t)` has returned 6 bytes.
    The memory layout of a structure variable is very similar to an array. In an array,
    all elements are adjacent to each other in the memory, and this is the same for
    a structure variable and its field. The difference is that, in an array, all elements
    have the same type and therefore the same size, but this is not the case regarding
    a structure variable. Each field can have a different type, and hence, it can
    have a different size. Unlike an array, the memory size of which is easily calculated,
    the size of a structure variable in the memory depends on a few factors and cannot
    be easily determined.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前一个 Shell Box 中看到的，`sizeof(sample_t)` 返回了 6 个字节。结构变量的内存布局与数组非常相似。在数组中，所有元素在内存中相邻，这对于结构变量及其字段也是如此。区别在于，在数组中，所有元素具有相同的类型和大小，但在结构变量中并非如此。每个字段可以具有不同的类型，因此它也可以具有不同的大小。与内存大小容易计算的数组不同，结构变量在内存中的大小取决于几个因素，并且不容易确定。
- en: At first, it seems to be easy to guess the size of a structure variable. For
    the structure in the preceding example, it has four fields, three `char` fields,
    and one `short` field. With a simple calculation, if we suppose that `sizeof(char)`
    is 1 byte and `sizeof(short)` is 2 bytes, each variable of the type `sample_t`
    should have 5 bytes in its memory layout. But when we look at the output, we see
    that `sizeof(sample_t)` is 6 bytes. 1 byte more! Why do we have this extra byte?
    Again, while looking at the bytes in the memory layout of the structure variable,
    `var`, we can see that it is a bit different from our expectation which is `65
    66 67 253 2`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，猜测结构变量的大小似乎很简单。对于前一个示例中的结构，它有四个字段，三个 `char` 字段和一个 `short` 字段。通过简单的计算，如果我们假设
    `sizeof(char)` 是 1 个字节，`sizeof(short)` 是 2 个字节，那么 `sample_t` 类型的每个变量在其内存布局中应该有
    5 个字节。但当我们查看输出时，我们看到 `sizeof(sample_t)` 是 6 个字节。多出 1 个字节！为什么会有这个额外的字节？再次，当我们查看结构变量
    `var` 的内存布局中的字节时，我们可以看到它与我们的预期 `65 66 67 253 2` 略有不同。
- en: For making this clearer and explaining why the size of the structure variable
    is not 5 bytes, we need to introduce the *memory alignment* concept. The CPU always
    does all the computations. Besides that, it needs to load values from memory before
    being able to compute anything and needs to store the results back again in the
    memory after a computation. Computation is super-fast inside the CPU, but the
    memory access is very slow in comparison. It is important to know how the CPU
    interacts with the memory because then we can use the knowledge to boost a program
    or debug an issue.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这一点更清晰并解释为什么结构变量的大小不是 5 个字节，我们需要引入 *内存对齐* 的概念。CPU 总是执行所有计算。除此之外，它需要在计算任何内容之前从内存中加载值，并在计算后需要将结果存储回内存。计算在
    CPU 内部非常快，但与内存访问相比非常慢。了解 CPU 如何与内存交互非常重要，因为这样我们可以利用这些知识来提升程序或调试问题。
- en: The CPU usually reads a specific number of bytes in each memory access. This
    number of bytes is usually called a *word*. So, the memory is split into words
    and a word is an atomic unit used by the CPU to read from and write to the memory.
    The actual number of bytes in a word is an architecture-dependent factor. For
    example, in most 64-bit machines, the word size is 32 bits or 4 bytes. Regarding
    the memory alignment, we say that a variable is aligned in the memory if its starting
    byte is at the beginning of a word. This way, the CPU can load its value in an
    optimized number of memory accesses.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 通常在每次内存访问中读取特定数量的字节。这个字节数通常被称为 *字*。因此，内存被分成字，字是 CPU 用来从内存读取和写入的原子单元。一个字中实际的字节数是一个架构相关的因素。例如，在大多数
    64 位机器上，字大小是 32 位或 4 个字节。关于内存对齐，我们说如果变量的起始字节位于字的开始处，则该变量在内存中是对齐的。这样，CPU 可以以优化的内存访问次数加载其值。
- en: Regarding the previous example, *example 1.21*, the first 3 fields, `first`,
    `second`, and `third`, are 1 byte each, and they reside in the first word of the
    structure's layout, and they all can be read by just one memory access. About
    the fourth field, `fourth` occupies 2 bytes. If we forget about the memory alignment,
    its first byte will be the last byte of the first word, which makes it unaligned.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的例子，*例子 1.21*，前三个字段，`first`、`second` 和 `third`，每个字段都是 1 字节，它们位于结构布局的第一个单词中，并且它们都可以通过一次内存访问来读取。关于第四个字段，`fourth`
    占用 2 字节。如果我们不考虑内存对齐，它的第一个字节将是第一个单词的最后一个字节，这使得它未对齐。
- en: If this was the case, the CPU would be required to make two memory accesses
    together with shifting some bits in order to retrieve the value of the field.
    That is why we see an extra zero after byte `67`. The zero byte has been added
    in order to complete the current word and let the fourth field start in the next
    word. Here, we say that the first word is padded by one zero byte. The compiler
    uses the *padding* technique to align values in the memory. Padding is the extra
    bytes added to match the alignment.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样的话，CPU 就需要一起进行两次内存访问和一些位移动，才能检索字段的值。这就是为什么我们在字节 `67` 后看到一个额外的零。这个零字节被添加是为了完成当前单词，并让第四个字段从下一个单词开始。在这里，我们说第一个单词被一个零字节填充。编译器使用
    *填充* 技术在内存中对齐值。填充是为了匹配对齐而添加的额外字节。
- en: 'It is possible to turn off the alignment. In C terminology, we use a more specific
    term for aligned structures. We say that the structure is not packed. *Packed
    structures* are not aligned and using them may lead to binary incompatibilities
    and performance degradation. You can easily define a structure that is packed.
    We will do it in the next example, *example 1.22*, which is pretty similar to
    the previous example, *example 1.21*. The `sample_t` structure is packed in this
    example. The following code box shows *example 1.22*. Note that the similar code
    are replaced by ellipses:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 可以关闭对齐。在 C 术语中，我们使用一个更具体的术语来表示对齐的结构。我们说结构不是打包的。*打包结构*没有对齐，使用它们可能会导致二进制不兼容和性能下降。你可以轻松地定义一个打包的结构。我们将在下一个例子，*例子
    1.22*，中这样做，它与前面的例子，*例子 1.21*，非常相似。在这个例子中，`sample_t` 结构是打包的。下面的代码框显示了 *例子 1.22*。请注意，类似的代码被省略号替换了：
- en: '[PRE52]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Code Box 1-35 [ExtremeC_examples_chapter1_22.c]: Declaring a packed structure'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-35 [ExtremeC_examples_chapter1_22.c]：声明一个打包的结构
- en: 'In the following shell box, the preceding code is compiled using `clang` and
    run on macOS:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 shell 框中，前面的代码使用 `clang` 在 macOS 上编译并运行：
- en: '[PRE53]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Shell Box 1-14: Output of example 1.22'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 1-14：*例子 1.22* 的输出
- en: As you see in *Shell Box 1-14*, the printed size is exactly what we were expecting
    as part of *example 1.21*. The final layout is also matched with our expectation.
    Packed structures are usually used in memory-constrained environments, but they
    can have a huge negative impact on the performance on most architectures. Only
    new CPUs can handle reading an unaligned value from multiple words without enforcing
    extra cost. Note that memory alignment is enabled by default.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 *Shell Box 1-14* 中看到的那样，打印的大小正好是我们预期的 *例子 1.21* 的一部分。最终的布局也与我们的预期相匹配。打包结构通常用于内存受限的环境，但它们可能会对大多数架构的性能产生巨大的负面影响。只有新的
    CPU 可以在不强制额外成本的情况下从多个单词中读取未对齐的值。请注意，默认情况下启用了内存对齐。
- en: Nested structures
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套结构
- en: As we have explained in the previous sections, in general, we have two kinds
    of data types in C. There are the types that are primitive to the language and
    there are types which are defined by the programmers using the `struct` keyword.
    The former types are PDTs, and the latter are UDTs.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中解释的那样，在 C 语言中，我们通常有两种数据类型。有一种是语言的基本类型，还有一种是由程序员使用 `struct` 关键字定义的类型。前者是
    PDTs，后者是 UDTs。
- en: So far, our structure examples have been about UDTs (structures) made up of
    only PDTs. But in this section, we are going to give an example of UDTs (structures)
    that are made from other UDTs (structures). These are called *complex data types*,
    which are the result of nesting a few structures.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的结构示例都是关于仅由 PDTs（结构）组成的 UDTs（结构）。但在这个部分，我们将给出一个由其他 UDTs（结构）组成的 UDTs（结构）的例子。这些被称为
    *复杂数据类型*，它们是嵌套几个结构的结果。
- en: 'Let''s begin with the example, *example 1.23*:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从例子，*例子 1.23*，开始：
- en: '[PRE54]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Code Box 1-36 [ExtremeC_examples_chapter1_23.c]: Declaring some nested structures'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-36 [ExtremeC_examples_chapter1_23.c]：声明一些嵌套的结构
- en: In the preceding code box, we have three structures; `point_t`, `circle_t`,
    and `line_t`. The `point_t` structure is a simple UDT because it is made up of
    only PDTs, but other structures contain a variable of the `point_t` type, which
    makes them complex UDTs.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码框中，我们有三个结构；`point_t`、`circle_t` 和 `line_t`。`point_t` 结构是一个简单的 UDT，因为它仅由
    PDT 组成，但其他结构包含 `point_t` 类型的变量，这使得它们成为复杂的 UDT。
- en: The size of a complex structure is calculated exactly the same as a simple structure,
    by summing up the sizes of all its fields. We should be still careful about the
    alignment, of course, because it can affect the size of a complex structure. So,
    `sizeof(point_t)` would be 8 bytes if `sizeof(int)` is 4 bytes. Then, `sizeof(circle_t)`
    is 12 bytes and `sizeof(line_t)` is 16 bytes.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂结构的大小计算方式与简单结构完全相同，即通过将所有字段的大小相加。当然，我们仍然应该注意对齐，因为它可能会影响复杂结构的大小。因此，如果 `sizeof(int)`
    是 4 字节，则 `sizeof(point_t)` 将是 8 字节。然后，`sizeof(circle_t)` 是 12 字节，`sizeof(line_t)`
    是 16 字节。
- en: It is common to call structure variables objects. They are exactly analogous
    to objects in object-oriented programming, and we will see that they can encapsulate
    both values and functions. So, it is not wrong at all to call them C objects.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 通常将结构变量称为对象。它们与面向对象编程中的对象完全类似，我们将看到它们可以封装值和函数。因此，称它们为 C 对象并没错。
- en: Structure pointers
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构指针
- en: Like pointers to PDTs, we can have pointers to UDTs as well. They work exactly
    the same as PDT pointers. They point to an address in memory, and you can do arithmetic
    on them just like with the PDT pointers. UDT pointers also have arithmetic step
    sizes equivalent to the size of the UDT. If you don't know anything about the
    pointers or the allowed arithmetic operations on them, please go to the *Pointers*
    section and give it a read.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 与指向 PDT 指针类似，我们也可以有指向 UDT 的指针。它们的工作方式与 PDT 指针完全相同。它们指向内存中的一个地址，你可以像对 PDT 指针那样对它们进行算术运算。UDT
    指针也有与 UDT 大小相等的算术步长。如果你对指针或允许在它们上进行的算术运算一无所知，请前往 *指针* 部分，并阅读它。
- en: 'It is important to know that a structure variable points to the address of
    the first field of the structure variable. In the previous example, *example 1.23*,
    a pointer of type `point_t` would point to the address of its first field, `x`.
    This is also true for the type, `circle_t`. A pointer of type `circle_t` would
    point to its first field, `center`, and since it is actually a `point_t` object,
    it would point to the address of the first field, `x`, in the `point_t` type.
    Therefore, we can have 3 different pointers addressing the same cell in the memory.
    The following code will demonstrate this:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，结构变量指向结构变量第一个字段的位置。在前面的例子 *示例 1.23* 中，类型为 `point_t` 的指针将指向其第一个字段 `x`
    的地址。这同样适用于类型 `circle_t`。类型为 `circle_t` 的指针将指向其第一个字段 `center`，因为它实际上是一个 `point_t`
    对象，所以它将指向 `point_t` 类型中第一个字段 `x` 的地址。因此，我们可以有 3 个不同的指针指向内存中的同一单元格。以下代码将演示这一点：
- en: '[PRE55]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Code Box 1-37 [ExtremeC_examples_chapter1_24.c]: Having three different pointers
    from three different types addressing the same byte in memory'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 1-37 [ExtremeC_examples_chapter1_24.c]：三个不同类型的指针指向内存中的同一字节
- en: 'And this is the output:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE56]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Shell Box 1-15: Output of example 1.24'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell Box 1-15: 示例 1.24 的输出'
- en: As you see, all of the pointers are addressing the same byte, but their types
    are different. This is usually used to extend structures coming from other libraries
    by adding more fields. This is also the way we implement *inheritance* in C. We
    will discuss this in *Chapter 8*, *Inheritance and Polymorphism*.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，所有指针都指向同一字节，但它们的类型不同。这通常用于通过添加更多字段来扩展来自其他库的结构。这也是我们在 C 中实现 *继承* 的方式。我们将在
    *第 8 章*，*继承和多态* 中讨论这一点。
- en: This was the last section in this chapter. In the upcoming chapter, we will
    dive into the C compilation pipeline and how to properly compile and link a C
    project.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这章的最后部分。在下一章中，我们将深入了解 C 编译器管道以及如何正确编译和链接 C 项目。
- en: Summary
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we revisited some of the important features of the C programming
    language. We tried to go further and show the design aspects of these features
    and the concepts behind them. Of course, the proper use of a feature requires
    a deeper insight into the different aspects of that feature. As part of this chapter,
    we discussed the following:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了 C 编程语言的一些重要特性。我们试图更进一步，展示这些特性的设计方面以及背后的概念。当然，正确使用一个特性需要对该特性的不同方面有更深入的了解。作为本章的一部分，我们讨论了以下内容：
- en: We talked about the C preprocessing phase and how various directives can influence
    the preprocessor to act differently or generate a specific C code for us.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了C语言的预处理阶段以及各种指令如何影响预处理器以不同的方式行动或为我们生成特定的C代码。
- en: Macros and the macro expansion mechanism allow us to generate C code before
    passing the translation unit to the compilation phase.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏和宏展开机制允许我们在将翻译单元传递到编译阶段之前生成C代码。
- en: Conditional directives allow us to alter the preprocessed code based on certain
    conditions and allow us to have different code for different situations.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件指令允许我们根据某些条件修改预处理的代码，并允许我们针对不同情况有不同的代码。
- en: We also looked at variable pointers, and how they are employed in C.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还研究了变量指针以及它们在C语言中的应用。
- en: We introduced generic pointers and how we can have a function that accepts any
    kind of pointer.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了泛型指针以及如何有一个可以接受任何类型指针的函数。
- en: We discussed some issues such as segmentation faults and dangling pointers to
    show a few disastrous situations that can arise from misusing pointers.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了一些问题，例如段错误和悬挂指针，以展示由于误用指针可能出现的几种灾难性情况。
- en: Functions were discussed next, and we reviewed their syntax.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来讨论了函数，并回顾了它们的语法。
- en: We explored functions' design aspects and how they contribute to a nicely shaped
    procedural C program.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们探讨了函数的设计方面以及它们如何有助于构建一个结构良好的C程序过程。
- en: We also explained the function call mechanism and how arguments are passed to
    a function using stack frames.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还解释了函数调用机制以及如何使用栈帧将参数传递给函数。
- en: Function pointers were explored in this chapter. The powerful syntax of function
    pointers allows us to store logics in variable-like entities and use them later.
    They are, in fact, the fundamental mechanism that every single program uses today
    to be loaded and operate.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章探讨了函数指针。函数指针强大的语法允许我们将逻辑存储在类似变量的实体中，并在以后使用它们。实际上，这是当今每个程序使用的根本机制，用于加载和操作。
- en: Structures together with function pointers gave rise to encapsulation in C.
    We speak more about this in the third part of the book, *Object Orientation*.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构与函数指针的结合在C语言中产生了封装。我们将在本书的第三部分*面向对象*中更多地讨论这一点。
- en: We tried to explain the design aspects of structures and their effect on the
    way we design programs in C.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们试图解释结构的设计方面以及它们对我们以C语言设计程序的影响。
- en: We also discussed the memory layout of structure variables and how they are
    placed inside memory to maximize CPU utilization.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还讨论了结构变量的内存布局以及它们如何在内存中放置以最大化CPU利用率。
- en: Nested structures were also discussed. We also took a look inside the complex
    structure variables and discussed how their memory layout should look.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还讨论了嵌套结构。我们也查看了一下复杂结构变量的内部，并讨论了它们的内存布局应该如何。
- en: As the final section in this chapter, we talked about structure pointers.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为本章的最后一部分，我们讨论了结构指针。
- en: The next chapter will be our first step in building a C project. The C compilation
    pipeline and linking mechanism will be discussed as part of the next chapter.
    Reading it thoroughly will be essential to continue with the book and proceed
    to further chapters.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将是构建C项目的第一步。下一章将讨论C编译管道和链接机制。彻底阅读它对于继续阅读本书并进入后续章节至关重要。
