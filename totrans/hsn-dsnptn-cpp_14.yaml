- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: The Template Method Pattern and the Non-Virtual Idiom
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法模式和伪虚函数
- en: The Template Method is one of the classic *Gang of Four* design patterns, or,
    more formally, one of the 24 patterns described in the book *Design Patterns –
    Elements of Reusable Object-Oriented Software* by Erich Gamma, Richard Helm, Ralph
    Johnson, and John Vlissides. It is a behavioral design pattern, meaning that it
    describes a way for communicating between different objects. As an object-oriented
    language, C++, of course, fully supports the Template Method pattern, although
    there are some implementation details that are specific or unique to C++ that
    this chapter will elucidate.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法是经典的*四人帮*设计模式之一，或者更正式地说，是Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides在《设计模式
    - 可复用面向对象软件元素》一书中描述的24个模式之一。它是一种行为设计模式，意味着它描述了不同对象之间通信的方式。作为面向对象的语言，C++当然完全支持模板方法模式，尽管本章将阐明一些特定于C++的实现细节。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is the Template Method pattern, and what problems does it solve?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法模式是什么，它解决了什么问题？
- en: What is the non-virtual interface?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是非虚接口？
- en: Should you make virtual functions public, private, or protected by default?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该默认将虚函数设置为公有、私有还是保护？
- en: Should you always make destructors virtual and public in polymorphic classes?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否应该始终在多态类中将析构函数设置为虚的和公有的？
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The example code for this chapter can be found at the following GitHub link:
    [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter14](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter14).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在以下GitHub链接中找到：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter14](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter14).
- en: The Template Method pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法模式
- en: The Template Method pattern is a common way to implement an algorithm whose
    overall structure is pre-determined, but some of the details of the implementation
    need to be customized. If you are thinking about a solution that goes something
    like this—first, we do *X*, then *Y*, and then *Z*, but how exactly we do *Y*
    depends on the data we process—you are thinking about the Template Method. As
    a pattern that allows the behavior of a program to change dynamically, the Template
    Method is somewhat similar to the strategy pattern. The key difference is that
    the strategy pattern changes the entire algorithm at runtime, while the Template
    Method lets us customize specific parts of the algorithm. This section deals with
    the latter, while we have a separate [*Chapter 16*](B19262_16.xhtml#_idTextAnchor739),
    *Policy-Based Design*, dedicated to the former.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式是实现一个算法的常见方式，其整体结构是预先确定的，但实现的一些细节需要定制。如果你正在考虑一个解决方案，类似于这样——首先，我们做*X*，然后*Y*，然后*Z*，但我们如何做*Y*取决于我们处理的数据——你正在考虑模板方法。作为一个允许程序行为动态变化的模式，模板方法在某种程度上类似于策略模式。关键区别在于，策略模式在运行时改变整个算法，而模板方法允许我们定制算法的特定部分。本节处理后者，而我们有专门的[*第16章*](B19262_16.xhtml#_idTextAnchor739)，*基于策略的设计*，专门用于前者。
- en: The Template Method in C++
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++中的模板方法
- en: 'The Template Method pattern is easily implemented in any object-oriented language.
    The C++ implementation uses inheritance and virtual functions. Note that this
    has nothing to do with C++ templates, as in generic programming. The *template*
    here is the skeleton implementation of the algorithm:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式在任何面向对象的语言中都可以轻松实现。C++实现使用继承和虚函数。请注意，这与泛型编程中的C++模板无关。这里的*模板*是算法的骨架实现：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The *template* here is the structure of the algorithm—all implementations must
    first do *step 1*, which may fail. If this happens, the entire algorithm is considered
    to have failed, and nothing more is done. If *step 1* succeeded, we must do *step
    2*. By design, *step 2* cannot fail, and the overall algorithm computation is
    considered a success once *step 2* is completed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的*模板*是算法的结构——所有实现都必须首先执行*步骤1*，这可能失败。如果发生这种情况，整个算法被认为是失败的，不再进行任何操作。如果*步骤1*成功，我们必须执行*步骤2*。按照设计，*步骤2*不能失败，一旦*步骤2*完成，整体算法计算被认为是成功的。
- en: 'Note that the `TheAlgorithm()` method is public but not virtual—any class derived
    from `Base` has it as a part of its interface but cannot override what it does.
    What the derived classes can override are the implementations of *step 1* and
    *step 2*, within the restrictions of the algorithm template – *step 1* may fail
    and must signal the failure by returning `false`, while *step 2* may not fail:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`TheAlgorithm()`方法是公开的但不是虚拟的——任何从`Base`派生的类都有它作为其接口的一部分，但不能覆盖它的行为。派生类可以覆盖的是在算法模板限制内的*步骤
    1*和*步骤 2*的实现——*步骤 1*可能失败，必须通过返回`false`来表示失败，而*步骤 2*可能不会失败：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, overriding the potentially failing *step 1* is optional,
    and the default implementation is trivial; it does nothing and never fails. *Step
    2* must be implemented by every derived class—there is no default, and it is declared
    as a pure virtual function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，覆盖可能失败的*步骤 1*是可选的，默认实现很简单；它什么都不做，永远不会失败。*步骤 2*必须由每个派生类实现——没有默认实现，并且它被声明为一个纯虚函数。
- en: You can see that the overall flow of control—the framework—remains invariant,
    but it has *placeholders* for customizable options, possibly with a default offered
    by the framework itself. Such a flow is known as the inversion of control. In
    a traditional control flow, its specific implementation determines the flow of
    computation and sequence of operations and makes calls to library functions or
    other lower-level functions to implement the necessary general algorithms. In
    the Template Method, it is the framework that calls specific implementations in
    the custom code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到整体的控制流程——框架——保持不变，但它有*占位符*用于可定制的选项，可能由框架本身提供默认值。这种流程被称为控制反转。在传统的控制流程中，它的具体实现决定了计算的流程和操作的顺序，并调用库函数或其他低级函数来实现必要的通用算法。在模板方法中，是框架在自定义代码中调用特定的实现。
- en: Applications of the Template Method
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板方法的应用
- en: 'There are many reasons to use the Template Method. In general, it is used to
    control what can and cannot be sub-classed—as opposed to a general polymorphic
    override, where the entire virtual function can be replaced, the base class here
    determines what can and cannot be overridden. Another common use of the Template
    Method is to avoid code duplication, and in this context, you can arrive at the
    use of the Template Method as follows. Suppose that you start with the regular
    polymorphism—a virtual function—and it overrides. For example, let’s consider
    this toy design for a turn-based combat system for a game:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板方法有许多原因。一般来说，它用于控制可以和不可以被子类化的内容——与通用多态覆盖相反，在通用多态覆盖中，整个虚拟函数可以被替换，这里的基类决定了可以和不可以被覆盖的内容。模板方法的另一个常见用途是避免代码重复，在这种情况下，你可以这样得出使用模板方法的结论。假设你从一个常规的多态开始——一个虚拟函数——并覆盖它。例如，让我们考虑这个玩具设计，为一个游戏的回合制战斗系统：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note how this code is highly repetitive—all characters may be forced to disengage
    from combat on their turn, then they must take a turn to get ready for combat,
    and only then, if they are ready and strong enough, can they use their offensive
    capabilities. If you see this pattern repeating over and over, it is a strong
    hint that the Template Method may be called for. With the Template Method, the
    overall sequence of the combat turn is fixed, but how each character advances
    to the next step and what he/she does once he/she gets there remains character-specific:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个代码是多么的重复——所有角色可能在它们的回合被迫退出战斗，然后他们必须进行一个回合来为战斗做准备，只有在这种情况下，如果他们准备好了并且足够强大，他们才能使用他们的攻击能力。如果你看到这个模式反复出现，这是一个强烈的提示，可能需要调用模板方法。使用模板方法，战斗回合的整体顺序是固定的，但每个角色如何前进到下一步以及到达那里后他们做什么仍然是角色特定的：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now each derived class must implement only the part of the code that is unique
    to this class:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个派生类只需实现这个类独有的代码部分：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note how this code is much less repetitive. The advantage of the Template Method
    goes beyond good looks, though. Let’s say that in the next revision of the game,
    we have added healing potions, and at the beginning of the turn, each character
    may drink a potion. Now, imagine going through every derived class and adding
    code like `if (health_ < ... some class-specific value ... && potion_count_ >
    0) ...`. If the design already used the Template Method, the logic of potion-quaffing
    needs to be coded only once, and different classes implement their specific conditions
    for using a potion, as well as the consequences of drinking one. However, don’t
    rush to implement this solution until you get to the end of this chapter, as this
    is not the best C++ code you can do.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这段代码的重复性明显减少。尽管模板方法的优势不仅仅在于外观上的美观。假设在游戏的下一个版本中，我们增加了治疗药水，并且在回合开始时，每个角色都可以喝上一瓶药水。现在，想象一下需要遍历每一个派生类并添加类似
    `if (health_ < ... some class-specific value ... && potion_count_ > 0) ...` 的代码。如果设计已经使用了模板方法，那么药水饮用的逻辑只需要编写一次，不同的类实现它们使用药水的特定条件，以及饮用药水的后果。然而，在你读完这一章之前，不要急于实施这个解决方案，因为这并不是你能编写的最好的C++代码。
- en: Pre-and post-conditions and actions
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预条件和后置条件以及动作
- en: 'Another common use of the Template Method is dealing with pre-and post-conditions
    or actions. In a class hierarchy, pre- and post-conditions generally verify that
    the design invariants of an abstraction provided by an interface are not violated
    by any specific implementation at any point during execution. Such verification
    naturally submits to the Template Method’s design:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法的另一个常见用途是处理预条件和后置条件或动作。在类层次结构中，预条件和后置条件通常验证在执行过程中，接口提供的抽象设计不变量没有被任何特定的实现违反。这种验证自然符合模板方法的设计：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The invariants are the requirements that the object must satisfy when it’s
    accessible to the client, i.e., before any member function is called on it or
    after it returns. The member functions themselves often have to temporarily break
    the invariants, but they must restore the correct state of the class before returning
    control to the caller. Let us say that our classes from the preceding example
    keep track of how many actions have been executed. Each action is registered when
    it starts and again when it’s done, and the two counts must be the same: once
    an action is initiated, it has to complete before control is returned to the caller.
    Of course, inside the `ActionImpl()` member function this invariant is violated
    since an action is in progress:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不变量是对象在客户端可访问时必须满足的要求，即在任何成员函数被调用之前或返回之后。成员函数本身通常需要暂时破坏不变量，但它们必须在将控制权返回给调用者之前恢复类的正确状态。让我们假设我们前面例子中的类跟踪执行了多少个动作。每个动作在开始时注册，完成时再次注册，这两个计数必须相同：一旦一个动作被启动，它必须完成，然后才能将控制权返回给调用者。当然，在
    `ActionImpl()` 成员函数内部，这个不变量被违反了，因为动作正在进行中：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Of course, any practical implementation of pre- and post-conditions must take
    into account several additional factors. First, some member functions may have
    additional invariants, i.e., they can be called only when the object is in a restricted
    state. Such functions would have specific pre-conditions to test. Second, we have
    not considered the possibility that an action is aborted due to an error (this
    may or may not involve throwing an exception). A well-designed implementation
    of error handling must guarantee that the class invariants are not violated after
    such an error. In our case, a failed action may be ignored altogether (in which
    case, we need to decrement the count of started actions) or our invariant may
    have to be more complex: all started actions must end up as completed or failed,
    and we need to count both:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，任何实际的预条件和后置条件的实现都必须考虑几个额外的因素。首先，一些成员函数可能有额外的不变量，即它们只能在对象处于受限制状态时调用。这样的函数将具有特定的前置条件进行测试。其次，我们没有考虑动作由于错误而中止的可能性（这可能涉及抛出异常）。一个精心设计的错误处理实现必须保证在错误发生后类的不变量没有被违反。在我们的例子中，一个失败的动作可能完全被忽略（在这种情况下，我们需要减少已启动动作的计数）或者我们的不变量可能需要更复杂：所有已启动的动作最终都必须完成或失败，我们需要计算两者：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In a real program, you must ensure that a failed transaction isn’t just counted
    correctly but is handled correctly too (often, it must be undone). We have discussed
    it in great detail in [*Chapter 5*](B19262_05.xhtml#_idTextAnchor199), *A Comprehensive
    Look at RAII*, and again in [*Chapter 11*](B19262_11.xhtml#_idTextAnchor509),
    *ScopeGuard*. Finally, in a concurrent program, it is no longer true that an object
    cannot be observed while a member function is being executed, and the entire subject
    of class invariants becomes much more complex and intertwined with thread-safety
    guarantees.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的程序中，你必须确保失败的交易不仅被正确计数，而且也要得到正确的处理（通常，它必须被撤销）。我们已经在[*第5章*](B19262_05.xhtml#_idTextAnchor199)
    *全面审视RAII*和[*第11章*](B19262_11.xhtml#_idTextAnchor509) *ScopeGuard*中进行了详细讨论。最后，在并发程序中，一个对象在成员函数执行期间无法被观察的事实不再成立，类不变性的整个主题变得更加复杂，并且与线程安全保证交织在一起。
- en: 'Of course, in software design, one man’s invariants are another’s customization
    points. Sometimes, it is the main code that remains the same, but what happens
    right before and right after depends on the specific application. In this case,
    we probably wouldn’t be verifying any invariants, but instead executing initial
    and final actions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在软件设计中，一个人的不变性是另一个人的定制点。有时，主要代码保持不变，但发生的事情取决于具体的应用。在这种情况下，我们可能不会验证任何不变性，而是执行初始和最终操作：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There is, of course, no reason why pre- and post-conditions cannot be combined
    with opening and closing actions – the base class can have several “standard”
    member function calls before and after the primary implementation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有理由将前置条件和后置条件与打开和关闭操作结合在一起——基类可以在主要实现前后有多个“标准”成员函数调用。
- en: While this code gets the job done, it still has some deficiencies that we are
    about to expose.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码完成了任务，但它仍然存在一些我们将要揭露的缺陷。
- en: The Non-Virtual Interface
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非虚接口
- en: The implementation of the dynamically customizable parts of the templated algorithm
    is usually done with virtual functions. For a general Template Method pattern,
    this is not a requirement, but in C++, we rarely need another way. Now, we are
    going to focus specifically on using the virtual functions and improving on what
    we have learned.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 动态可定制算法部分的实现通常使用虚函数来完成。对于一般的模板方法模式，这不是必需的，但在C++中，我们很少需要其他方式。现在，我们将专门关注使用虚函数并改进我们所学的知识。
- en: Virtual functions and access
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚函数和访问
- en: Let’s start with a general question—should virtual functions be public or private?
    The textbook object-oriented design style uses public virtual functions, so we
    often make them public without a second thought. Within the Template Method, this
    practice needs to be reevaluated—a public function is part of the class interface.
    In our case, the class interface includes the entire algorithm, and the framework
    we put in place in the base class. This function should be public, but it is also
    non-virtual. The customized implementations of some parts of the algorithm were
    never meant to be called directly by the clients of the class hierarchy. They
    are used in one place only—in the non-virtual public function, where they replace
    the placeholders we put in the template of the algorithm.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个问题开始——虚函数应该是公共的还是私有的？教科书中的面向对象设计风格使用公共虚函数，所以我们经常不加思考地使它们成为公共的。在模板方法中，这种做法需要重新评估——公共函数是类接口的一部分。在我们的情况下，类接口包括整个算法，以及我们在基类中设置的框架。这个函数应该是公共的，但它也是非虚的。算法某些部分的定制实现从未打算直接由类层次结构的客户端调用。它们只在一个地方使用——在非虚公共函数中，它们替换了我们放在算法模板中的占位符。
- en: 'This idea may seem trivial, but it comes as a surprise to many programmers.
    I’ve had this question asked more than once—*does C++ even allow virtual functions
    to be anything other than public?* In fact, the language itself makes no restrictions
    on access to virtual functions; they can be private, protected, or public, just
    like any other class member functions. This can take some time to wrap your mind
    around; perhaps an example would help:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法可能看起来微不足道，但它对许多程序员来说却是一个惊喜。我多次被问到这个问题——*C++甚至允许虚函数不是公共的吗？*事实上，语言本身对虚函数的访问没有限制；它们可以是私有的、受保护的或公共的，就像任何其他类的成员函数一样。这可能需要一些时间来理解；也许一个例子会有所帮助：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, `Derived::method2()` and `Derived::method3()`are both private. Can the
    base class even call private methods of its derived classes? The answer is, it
    doesn’t have to—`Base::method1()` only calls `Base::method2()` and `Base::method3()`
    which are its own member functions (public and private, respectively); there is
    no problem with calling private member functions of the same class. But if the
    actual class type is `Derived`, the virtual override of `method2()` is called
    at runtime instead. These two decisions, *can I call* `method2()`*?* and *which*
    `method2()`*?*, happen at totally different times—the former happens when the
    module containing the `Base` class is compiled (and the `Derived` class may not
    have even been written yet), while the latter happens when the program is executed
    (and the words *private* or *public* don’t mean anything at that point). Also
    note that, as shown by `method3()` in the preceding example, a virtual function
    and its override can have different access. Again, the function invoked at compile
    time (`Base::method3()` in our case) must be accessible at the point of the call;
    the override that ends up executed at runtime doesn’t have to be (however, if
    we were to call `Derived::method3()` directly outside of the class itself, we
    would be trying to call a private method of that class).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Derived::method2()` 和 `Derived::method3()` 都是私有的。基类甚至可以调用其派生类的私有方法吗？答案是，它不必这样做——`Base::method1()`
    只调用它自己的成员函数（分别是公共和私有）；调用同一类的私有成员函数没有问题。但如果实际类类型是 `Derived`，则在运行时会调用 `method2()`
    的虚拟重写。这两个决定，“我是否可以调用” `method2()` 和 “哪个” `method2()`，发生在完全不同的时间——前者发生在包含 `Base`
    类的模块编译时（而 `Derived` 类可能甚至还没有被编写），而后者发生在程序执行时（在那个点上，“私有”或“公共”这些词没有任何意义）。此外，请注意，正如前例中的
    `method3()` 所示，虚拟函数及其重写可以有不同的访问权限。再次强调，编译时调用的函数（在我们的例子中是 `Base::method3()`）必须在调用点可访问；最终在运行时执行的覆盖函数不必如此（然而，如果我们直接在类外部调用
    `Derived::method3()`，我们就会尝试调用该类的私有方法）。
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is another, more fundamental reason, to avoid public virtual functions.
    A public method is a part of the class interface. A virtual function override
    is a customization of the implementation. A public virtual function inherently
    does both of these tasks, at once. The same entity performs two very different
    functions that should not be coupled—declaring the public interface and providing
    an alternative implementation. Each of these functions has different constraints—the
    implementation can be altered in any way, as long as the hierarchy invariants
    hold. But the interface cannot be actually changed by the virtual function (except
    for returning covariant types, but even that does not really change the interface).
    All the public virtual function does is restate that yes, indeed, the public interface
    still looks like what the base class has declared. Such a mixing of two very distinct
    roles calls for a better separation of concerns. The Template Method pattern is
    an answer to that design problem, and in C++, it takes the form of the **Non-Virtual**
    **Interface** (**NVI**).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 避免公共虚拟函数的另一个更根本的原因是，公共方法构成了类接口的一部分。虚拟函数的重写是对实现的定制。一个公共虚拟函数本质上同时执行这两个任务。同一个实体执行了两个非常不同的功能，这些功能不应该耦合在一起——声明公共接口和提供替代实现。这些功能各自有不同的约束——只要层次不变量保持不变，实现可以被以任何方式更改。但是，接口实际上不能通过虚拟函数来改变（除了返回协变类型，但这实际上并没有改变接口）。所有公共虚拟函数所做的只是重申，是的，公共接口仍然看起来像基类所声明的。这种两种非常不同的角色的混合需要更好的关注点分离。模板方法模式是对该设计问题的回答，在C++中，它以**非虚拟接口**（NVI）的形式出现。
- en: The NVI idiom in C++
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++中的NVI习语
- en: The tension between the two roles of a public virtual function, and the unnecessary
    exposure of the customization points created by such functions, lead us to the
    idea of making the implementation-specific virtual functions private. Herb Sutter
    in his article, *Virtuality* ([http://www.gotw.ca/publications/mill18.htm](http://www.gotw.ca/publications/mill18.htm)),
    suggests that most, if not all, virtual functions should be private.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 公共虚拟函数的两个角色之间的紧张关系，以及由这些函数创建的不必要的定制点暴露，导致我们产生了将实现特定的虚拟函数设为私有的想法。Herb Sutter
    在他的文章《虚拟性》([http://www.gotw.ca/publications/mill18.htm](http://www.gotw.ca/publications/mill18.htm))中建议，大多数，如果不是所有，虚拟函数都应该设为私有。
- en: 'For the Template Method, moving virtual functions from public to private comes
    with no consequences (other than the initial shock of seeing a private virtual
    function, if you have never realized that C++ allows them):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模板方法，将虚拟函数从公共部分移动到私有部分不会带来任何后果（除了看到私有虚拟函数时的初始震惊，如果你从未意识到C++允许它们）：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This design nicely separates the interface and the implementation—the client
    interface is, and always was, the one call to run the entire algorithm. The possibility
    to change parts of the algorithm’s implementation is not reflected in the interface.
    Therefore, the user of this class hierarchy who only accesses it through the public
    interface and does not need to extend the hierarchy (write more derived classes),
    remains unaware of such implementation details. To see how this works in practice,
    you can convert every example in this chapter from public virtual functions to
    NVI; we are going to do just one, example 06, and leave the rest as an exercise
    to the reader.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计很好地将接口和实现分离开来——客户端接口始终是运行整个算法的一个调用。算法实现部分的可变性并没有在接口中得到体现。因此，仅通过公共接口访问这个类层次结构且不需要扩展层次结构（编写更多派生类）的用户，对这样的实现细节并不知情。为了了解这在实践中是如何工作的，你可以将本章中的每一个示例从公共虚拟函数转换为NVI；我们将只做其中一个，即示例06，其余的留给读者作为练习。
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The NVI gives complete control of the interface to the base class. The derived
    classes can only customize the implementation of this interface. The base class
    can determine and verify the invariants, impose the overall structure of the implementation,
    and specify which parts can, must, and cannot be customized. The NVI also separates
    the interface from the implementation explicitly. The implementers of the derived
    classes do not need to be concerned with exposing part of their implementation
    to the callers unintentionally—the implementation-only private methods cannot
    be called by anyone except the base class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: NVI（Non-Virtual Interface）将接口的完全控制权交给了基类。派生类只能自定义这个接口的实现。基类可以确定并验证不变性，强加实现的总体结构，并指定哪些部分可以、必须和不能被自定义。NVI还明确地将接口与实现分离。派生类的实现者不需要担心无意中将实现的一部分暴露给调用者——仅实现私有的方法只能被基类调用。
- en: 'Note that it is still possible for a derived class such as `LoggingFileWriter`
    to declare its own non-virtual function named `Write`. This is known as “shadowing”
    in C++: a name introduced in a derived class shadows (or makes inaccessible) all
    functions with the same name that would have been otherwise inherited from the
    base class. This causes the interfaces of the base and derived classes to diverge
    and is a very bad practice. Unfortunately, there is no good way for the base class
    implementer to protect from intentional shadowing. Accidental shadowing sometimes
    occurs when a function that is intended as a virtual override is declared with
    slightly different arguments; this can be avoided if the `override` keyword is
    used for all overrides.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，派生类如`LoggingFileWriter`仍然可以声明自己的非虚拟函数`Write`。这在C++中被称为“阴影”：在派生类中引入的名称会阴影（或使不可访问）所有具有相同名称的函数，这些函数原本会从基类继承而来。这会导致基类和派生类的接口发生分歧，这是一种非常不好的做法。不幸的是，基类实现者没有好的方法来防止有意阴影。有时，当打算作为虚拟覆盖的函数以略有不同的参数声明时，会发生意外阴影；如果所有覆盖都使用`override`关键字，则可以避免这种情况。
- en: 'So far, we have made all virtual functions that customize the implementation
    private. That, however, is not exactly the main point of the NVI—this idiom, and
    the more general Template Method, focus on making the public interface non-virtual.
    It follows, by extension, that the implementation-specific overrides should not
    be public since they are not part of the interface. It does not necessarily follow
    that they should be private. That leaves *protected*. So, should the virtual functions
    that provide customizations for the algorithm be private or protected? The Template
    Method allows both—the client of the hierarchy cannot directly call either one,
    so the framework of the algorithm remains unaffected. The answer depends on whether
    the derived classes may need to sub-invoke the implementations provided by the
    base class. For an example of the latter, consider a class hierarchy that can
    be serialized and sent to a remote machine through a socket:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将所有自定义实现的虚函数设置为私有。然而，这并不是NVI（Non-Virtual Interface）的主要观点——这个惯用表达式以及更一般的模板方法，关注的是使公共接口非虚。由此延伸，实现特定的覆盖不应是公共的，因为它们不是接口的一部分。但这并不意味着它们应该是私有的。这就留下了*受保护的*。那么，为算法提供自定义的虚函数应该是私有的还是受保护的？模板方法允许两者——层次结构的客户端不能直接调用任何一个，因此算法的框架不受影响。答案取决于派生类是否可能需要调用基类提供的实现。以下是一个后者的例子，考虑一个可以序列化并通过套接字发送到远程机器的类层次结构：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the framework is provided by the public non-virtual method `Base::Send()`,
    which handles the connection protocol and, at the right time, sends the data across
    the network. Of course, it can only send the data that the base class knows about.
    That is why `SendData` is a customization point and is made virtual. The derived
    class must send its own data, of course, but someone must still send the base
    class data, and so the derived class makes a call to the protected virtual function
    in the base class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，框架由公共非虚方法`Base::Send()`提供，它处理连接协议，并在适当的时候通过网络发送数据。当然，它只能发送基类知道的数据。这就是为什么`SendData`是一个自定义点并且被设置为虚函数。派生类当然必须发送自己的数据，但仍然需要有人发送基类的数据，因此派生类调用基类中的受保护虚函数。
- en: 'If this example looks like it’s missing something, there is a good reason for
    it. While we provided the general template for how to send data and a customization
    point for each class to handle its own data, there is another behavior aspect
    that should be user-configurable: *how* to send data. This is a great place to
    show the (sometimes obscure) difference between the template method pattern and
    the strategy pattern.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个例子看起来好像缺少了什么，那是有充分理由的。虽然我们提供了发送数据的一般模板以及每个类处理其自身数据的一个自定义点，但还有一个应该由用户可配置的行为方面：*如何*发送数据。这是一个展示模板方法模式和策略模式（有时是隐晦的）之间差异的好地方。
- en: Template Method vs Strategy
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板方法 vs 策略
- en: While this chapter is not about the Strategy pattern, it is sometimes confused
    with the Template Method, so we will now clarify the difference. We can use the
    example from the previous section to do this.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章不是关于策略模式，但它有时会与模板方法混淆，所以我们现在将澄清两者的区别。我们可以使用上一节的例子来做这件事。
- en: 'We have already used the Template Method to provide an overall template for
    the execution of the “send” operation in `Base::Send()`. There are three steps
    to the operation: open the connection, send the data, and close the connection.
    Sending data is the step that depends on the actual type of the object (which
    derived class it really is), and so it is explicitly designated as a customization
    point. The rest of the template is set in stone.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用模板方法为`Base::Send()`中“发送”操作的执行提供了一个整体模板。操作有三个步骤：打开连接、发送数据和关闭连接。发送数据是依赖于对象实际类型的步骤（它实际上是哪个派生类），因此它被明确指定为自定义点。模板的其余部分是固定的。
- en: 'However we need another kind of customization: the `Base` class, in general,
    is not the right place to define how to open and close the connection. Neither
    is the derived class: the same objects could be sent across different types of
    connections (sockets, files, shared memory, etc). This is where we can use the
    Strategy pattern to define communication strategy. The strategy is provided by
    a separate class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要另一种类型的自定义：在一般情况下，`Base`类不是定义如何打开和关闭连接的正确地方。派生类也不是：相同的对象可以通过不同类型的连接（套接字、文件、共享内存等）发送。这就是我们可以使用策略模式来定义通信策略的地方。策略由一个单独的类提供：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Isn’t it frustrating that template functions cannot be virtual? For a better
    solution to this problem, you have to wait until [*Chapter 15*](B19262_15.xhtml#_idTextAnchor689),
    *Policy-Based Design*. Anyway, now that we have the communication strategy, we
    can use it to parametrize the `Send()` operation template:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 模板函数不能是虚函数，这不是很令人沮丧吗？对于这个问题的更好解决方案，你必须等到 [*第15章*](B19262_15.xhtml#_idTextAnchor689)，*基于策略的设计*。无论如何，现在我们有了通信策略，我们可以用它来参数化
    `Send()` 操作模板：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note that the template for sending the data is basically unchanged, but we
    delegated the implementation of the specific steps to another class – the strategy.
    This is the key difference: the Strategy pattern allows us to choose (generally,
    at runtime) which implementation should be used for a particular operation. The
    public interface is fixed but the entire implementation is up to the specific
    strategy. The Template Method pattern enforces the overall implementation flow
    as well as the public interface. Only the specific steps of the algorithm can
    be customized.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，发送数据的模板基本上没有改变，但我们委托了具体步骤的实现给另一个类——策略。这是关键的区别：策略模式允许我们选择（通常在运行时）特定操作应使用哪种实现。公共接口是固定的，但整个实现完全取决于特定的策略。模板方法模式强制执行整体实现流程以及公共接口。只有算法的具体步骤可以定制。
- en: 'The second difference is where the customization happens: `Base::Send()` is
    customized in two ways. The customizations to the template are done in the derived
    classes; the implementations of the strategy are provided by the classes outside
    of the `Base` hierarchy.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别在于定制的位置：`Base::Send()` 以两种方式进行了定制。对模板的定制是在派生类中完成的；策略的实现由 `Base` 层次之外的类提供。
- en: As we pointed out at the beginning of this section, there are good reasons to
    make all virtual member functions, by default, private (or protected), and they
    go beyond the applications of the Template Method pattern. However, there is one
    particular member function – the destructor - that deserves separate consideration
    because the rules for destructors are somewhat different.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节开头所指出的，有很好的理由将所有虚成员函数默认设置为私有（或保护），这不仅仅适用于模板方法模式的应用。然而，有一个特定的成员函数——析构函数——值得单独考虑，因为析构函数的规则有所不同。
- en: A note about destructors
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于析构函数的说明
- en: The entire discussion of the NVI is an elaboration on a simple guideline—make
    virtual functions private (or protected), and present the public interface through
    non-virtual base class functions. This sounds fine until it runs head-on into
    another well-known guideline—if the class has at least one virtual function, its
    destructor must also be made virtual. Since the two are in conflict, some clarification
    is needed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对 NVI 的整个讨论是对一个简单指南的详细阐述——使虚函数私有（或保护），并通过非虚基类函数呈现公共接口。这听起来不错，直到它与另一个众所周知的指南正面冲突——如果一个类至少有一个虚函数，那么它的析构函数也必须是虚函数。由于这两个存在冲突，需要一些澄清。
- en: 'The reason to make destructors virtual is that if the object is deleted polymorphically
    - for example, a derived class object is deleted through a pointer to the base
    class - the destructor must be virtual; otherwise, only the base part of the class
    will be destructed (the usual result is the *slicing* of the class, partial deletion,
    although the standard simply states that the results are undefined). So, if the
    objects are deleted through the base class pointers, the destructors must be virtual;
    there is no way around it. But that is the only reason. If the objects are always
    deleted with the correct derived type, then this reason does not apply. This situation
    is not uncommon: for example, if derived class objects are stored in a container,
    they will be deleted as their true type.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使析构函数为虚函数的原因是，如果对象以多态方式被删除——例如，通过基类指针删除派生类对象——则析构函数必须是虚函数；否则，只有类的基部分将被析构（通常的结果是类的*切片*，部分删除，尽管标准只是简单地声明结果是不确定的）。因此，如果对象是通过基类指针删除的，析构函数必须是虚函数；没有其他选择。但这只是唯一的原因。如果对象总是以正确的派生类型被删除，那么这个原因就不适用。这种情况并不少见：例如，如果派生类对象存储在容器中，它们将按其真实类型被删除。
- en: The container has to know how much memory to allocate for the object, so it
    can’t store a mix of base and derived objects, or delete them as base objects
    (note that a container of pointers to the base class object is a different construct
    altogether, and is usually created specifically so that we can store and delete
    objects polymorphically).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 容器必须知道为对象分配多少内存，因此它不能存储基类和派生类的混合对象，或者将它们作为基类对象删除（请注意，指向基类对象的指针容器是另一种完全不同的结构，通常是为了我们可以以多态方式存储和删除对象而专门创建的）。
- en: Now, if the derived class has to be deleted as itself, its destructor does not
    need to be virtual. However, bad things will still happen if someone calls the
    destructor of the base class when the actual object is of the derived class type.
    To safely prevent that from happening, we can declare the non-virtual base class
    destructor as protected instead of public. Of course, if the base class is not
    abstract, and there are objects of both base and derived types around, then both
    destructors must be made public, and the safer option is to make them virtual
    (a runtime check can be implemented to verify that the base class destructor is
    not called to destroy a derived class object).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果派生类必须以自身类型被删除，其析构函数不需要是虚函数。然而，如果有人在实际对象为派生类类型时调用基类的析构函数，仍然会发生不好的事情。为了安全地防止这种情况发生，我们可以将非虚基类析构函数声明为受保护的，而不是公共的。当然，如果基类不是抽象的，并且周围有基类和派生类的对象，那么两个析构函数都必须是公共的，更安全的选项是将它们声明为虚函数（可以实施运行时检查来验证基类析构函数没有被用来销毁派生类对象）。
- en: By the way, if polymorphic deletion (deletion through the base class pointer)
    is the only reason you need to write a destructor in the base class, writing `virtual
    ~Base() = default;` is perfectly acceptable – a destructor can be both `virtual`
    and `default` at the same time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果你只需要在基类中编写析构函数来实现多态删除（通过基类指针进行删除），编写`virtual ~Base() = default;`是完全可接受的——析构函数可以同时是`virtual`和`default`。
- en: 'We must also caution the reader against trying to employ the Template Method,
    or the non-virtual interface idiom, for class destructors. It may be tempting
    to do something like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须警告读者不要尝试为类析构函数使用模板方法或非虚接口习惯用法。可能会诱使人们做类似这样的事情：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: However, this is not going to work (if the base class has a pure virtual `Base::clear()`
    instead of a default implementation, it is not going to work in a rather spectacular
    fashion). The reason for this is that, inside the destructor of the base class,
    `Base::~Base()`, the actual, real, and true type of the object is not `Derived`
    anymore. It’s `Base`. That’s right—when the `Derived::~Derived()` destructor is
    done with its work and the control is transferred to the base class destructor,
    the dynamic type of the object changes to `Base`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不会起作用（如果基类有一个纯虚的`Base::clear()`而不是默认实现，它将以相当壮观的方式失败）。原因在于，在基类析构函数`Base::~Base()`内部，对象的实际、真实和真正类型不再是`Derived`。它是`Base`。没错——当`Derived::~Derived()`析构函数完成其工作并将控制权传递给基类析构函数时，对象的动态类型变为`Base`。
- en: The only other class member that works this way is the constructor—the type
    of the object is `Base` as long as the base constructor is running, and then changes
    to `Derived` when the derived constructor has started. For all other member functions,
    the type of the object is always the type it was created with. If the object was
    created as `Derived`, then that is the type, even if a method of the base class
    is called. So, what happens if, in the preceding example, `Base::clear()` is pure
    virtual? It’s called anyway! The result depends on the compiler; most compilers
    will generate code that aborts the program, with some diagnostic that *a pure
    virtual function* *was called*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一其他以这种方式工作的类成员是构造函数——只要基类构造函数正在运行，对象的类型就是`Base`，然后当派生类构造函数开始运行时，类型变为`Derived`。对于所有其他成员函数，对象的类型始终是其创建时的类型。如果对象是以`Derived`类型创建的，那么这就是其类型，即使调用了基类的方法。那么，如果在先前的例子中，`Base::clear()`是纯虚函数，会发生什么？它仍然会被调用！结果取决于编译器；大多数编译器将生成代码来终止程序，并带有一些诊断信息，指出*调用了纯虚函数*。
- en: Drawbacks of the Non-Virtual Interface
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非虚接口的缺点
- en: There aren’t many drawbacks regarding the use of the NVI. That is why the guideline
    to always make virtual functions private, and use the NVI to call them, is widely
    accepted. However, there are some considerations that you must be aware of when
    deciding whether the Template Method is the right design pattern to follow. The
    use of the template pattern may lead to fragile hierarchies. Also, there is some
    overlap between design problems that can be solved using the template pattern
    and the ones better served by the strategy pattern, or, in C++, policies. We will
    review both considerations in this section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用NVI（非虚拟接口）方面，并没有太多缺点。这就是为什么总是将虚函数设为私有，并使用NVI来调用它们的指南被广泛接受。然而，在决定模板方法是否是正确的设计模式时，你必须注意一些考虑因素。使用模板模式可能会导致脆弱的层次结构。此外，使用模板模式可以解决的问题和那些更适合使用策略模式或C++中的策略的问题之间存在一些重叠。我们将在本节中回顾这两个考虑因素。
- en: Composability
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可组合性
- en: 'Consider the earlier design for `LoggingFileWriter`. Now, suppose that we want
    to also have `CountingFileWriter` that counts how many characters were written
    into the file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下`LoggingFileWriter`的早期设计。现在，假设我们还想有一个`CountingFileWriter`，它可以计算写入文件中的字符数：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That was easy. But there is no reason a counting file writer cannot also log.
    How would we implement a `CountingLoggingFileWriter`? No problem, we have the
    technology—change the private virtual functions to protected and call the base
    class version from the derived class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。但是，没有理由计数文件写入器不能也进行日志记录。我们如何实现`CountingLoggingFileWriter`？没问题，我们有技术——将私有虚函数改为受保护的，并从派生类中调用基类版本：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Or should it be `LoggingCountingFileWriter` that inherits from `CountingFileWriter`?
    Note that, either way, some code is duplicated—in our case, the counting code
    is present in both `CountingLoggingFileWriter` and `CountingFileWriter`. This
    duplication is only going to get worse as we add more variations. The Template
    Method just isn’t the right pattern if you need composable customizations. For
    that, you should read [*Chapter 15*](B19262_15.xhtml#_idTextAnchor689), *Policy-Based
    Design*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它应该是从`CountingFileWriter`继承的`LoggingCountingFileWriter`？请注意，无论哪种方式，都会有一些代码重复——在我们的例子中，计数代码同时存在于`CountingLoggingFileWriter`和`CountingFileWriter`中。随着我们添加更多变体，这种重复只会变得更糟。如果你需要可组合的自定义化，模板方法根本就不是正确的模式。为此，你应该阅读[*第15章*](B19262_15.xhtml#_idTextAnchor689)，*基于策略的设计*。
- en: The Fragile Base Class problem
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脆弱基类问题
- en: 'The Fragile Base Class problem is not limited to the Template Method, but is,
    to some degree, inherent in all object-oriented languages. The problem arises
    when changes to the base class break the derived class. To see how this can happen,
    specifically when using the non-virtual interface, let’s go back to the file writer
    and add the ability to write many strings at once:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 脆弱基类问题不仅限于模板方法，在一定程度上，它是所有面向对象语言固有的。问题出现在对基类的更改破坏了派生类。为了了解这是如何发生的，特别是当使用非虚拟接口时，让我们回到文件写入器并添加一次性写入多个字符串的能力：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The counting writer is kept up to date with the changes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 计数写入器会随着更改而保持最新：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So far, so good. Later, a well-intentioned programmer notices that the base
    class suffers from some code duplication and decides to refactor it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。后来，一个有良好意图的程序员注意到基类存在一些代码重复，并决定对其进行重构：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, the derived class is broken—the counting customizations of both versions
    of `Write` are called when a vector of strings is written, and the data size is
    counted twice. Note that we are not talking about the more basic kind of fragility
    where an override method in a derived class can stop being an override if the
    signature of the base class method is changed: this kind of fragility is largely
    avoided by the proper use of the `override` keyword as recommended in [*Chapter
    1*](B19262_01.xhtml#_idTextAnchor014), *An Introduction to Inheritance* *and Polymorphism*.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，派生类被破坏了——当写入字符串向量时，会调用`Write`的两个版本的计数自定义化，数据大小被计算了两次。请注意，我们不是在谈论更基本的脆弱性，即如果基类方法的签名发生变化，派生类中的重写方法可能会停止重写：这种脆弱性在很大程度上可以通过在[*第1章*](B19262_01.xhtml#_idTextAnchor014)，*继承和多态简介*中推荐使用`override`关键字来避免。
- en: While there is no general solution to the Fragile Base Class problem as long
    as inheritance is used at all, the guideline that helps to avoid it when using
    the Template Method is straightforward—when changing the base class and the structure
    of the algorithms, or the framework, avoid changing which customization points
    are invoked. Specifically, do not skip any customization options that were already
    invoked, and do not add new calls to already existing ones (it’s OK to add new
    customization points, as long as the default implementation is sensible). If such
    a change cannot be avoided, you will need to review every derived class to see
    whether it relied on the implementation override that is now removed or replaced,
    and what the consequences of such a change are.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管只要使用继承，就没有解决脆弱基类问题的通用方法，但使用模板方法时避免该问题的指南是直接的——当更改基类和算法结构或框架时，避免更改被调用的定制点。具体来说，不要跳过已经调用的任何定制选项，也不要向已经存在的选项中添加新的调用（只要默认实现是合理的，添加新的定制点是允许的）。如果无法避免这种更改，您需要审查每个派生类，以确定它是否依赖于现在已删除或替换的实现覆盖，以及这种更改的后果。
- en: A cautionary note about template customization points
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于模板定制点的注意事项
- en: This brief section is not a drawback of the Template Method, but rather a warning
    about a somewhat arcane corner of C++. Many of the design patterns that were originally
    developed as run-time behaviors (object-oriented patterns) found their compile-time
    analogs in C++ generic programming. So, is there a compile-time template method?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的章节并不是模板方法的缺点，而是一个关于 C++ 中某个较为晦涩角落的警告。许多最初作为运行时行为（面向对象模式）开发的设计模式，在 C++ 泛型编程中找到了它们的编译时对应物。那么，编译时模板方法是否存在呢？
- en: 'Of course, there is an obvious one: we can have a function or a class template
    that accepts function parameters, or, more generally, callable parameters, for
    a certain step of the otherwise fixed algorithm. The standard library has a plethora
    of examples, such as `std::find_if`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有一个明显的例子：我们可以有一个函数或类模板，它接受函数参数，或者更普遍地说，接受可调用参数，用于算法的某个固定步骤。标准库中有许多例子，例如 `std::find_if`：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The algorithm of `std::find_if` is known and cannot be altered, except for the
    step where it checks whether a particular value satisfies the caller’s predicate.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::find_if` 的算法是已知的，无法更改，除非它在检查特定值是否满足调用者的谓词这一步。'
- en: If we want to do the same for class hierarchies, we can use member function
    pointers (although it is easier to invoke member functions through lambdas), but
    there is no way to say “*call a member function with the same name but on a different
    class*” except by using virtual functions and their overrides. There is no equivalent
    to that in generic programming.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想对类层次结构做同样的事情，我们可以使用成员函数指针（尽管通过 lambda 表达式调用成员函数更容易），但除了使用虚拟函数及其覆盖之外，没有其他方法可以说“*在具有不同名称的类上调用具有相同名称的成员函数*”。在泛型编程中没有与之等效的方法。
- en: 'Unfortunately, there is a case where a template can be customized by accident,
    usually with unintended results. Consider this example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有一种情况，模板可能会意外地被定制，通常会产生意料之外的结果。考虑以下示例：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Which function `f()` is called from inside `B<T>::h()`? On a standard-compliant
    compiler, it should be the free-standing function, i.e. `::f()`, and not the member
    function of the base class! This may come as a surprise: if `A` and `B` were non-template
    classes, the base class method `A::f()` would have been called. This behavior
    arises from the complexities of parsing templates in C++ (if you want to learn
    more about this, `two-phase template parse` or `two-stage name lookup` are the
    terms to search for, but the matter is far outside the subject of this book).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `B<T>::h()` 内部调用的是哪个函数 `f()`？在符合标准的编译器中，应该是独立函数，即 `::f()`，而不是基类的成员函数！这可能会让人感到惊讶：如果
    `A` 和 `B` 都是非模板类，那么就会调用基类的方法 `A::f()`。这种行为源于 C++ 解析模板的复杂性（如果你想了解更多关于这个话题的信息，可以搜索“两阶段模板解析”或“两阶段名称查找”，但这个问题远远超出了本书的主题）。
- en: What would have happened if the global function `f()` was not available in the
    first place? Then we have to call the one in the base class, don’t we?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果全局函数 `f()` 本来就不存在，会发生什么？那么我们不得不调用基类中的那个，不是吗？
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you tried this code and it has called `A<T>::f()`, then you have a buggy
    compiler: the standard says that this should not compile at all! But what should
    you do if you want to call a member function of your own base class? The answer
    is very simple but looks strange if you haven’t written a lot of template code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试了这段代码并且它调用了`A<T>::f()`，那么你有一个有缺陷的编译器：标准规定这根本不应该编译！但如果你想要调用你自己的基类的成员函数，你应该怎么做？答案是简单但如果你没有编写很多模板代码可能会看起来奇怪：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That’s right, you have to explicitly call `this->f()` to ensure that you’re
    calling a member function. If you do this, `A<T>::f()` gets called whether or
    not there is a global `f()` declared. By the way, if you intended to call the
    global function, the way to do this unambiguously is `::f()`, or, if the function
    is in a namespace `NS`, `NS::f()`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，你必须显式地调用`this->f()`来确保你正在调用一个成员函数。如果你这样做，无论是否声明了全局的`f()`，都会调用`A<T>::f()`。顺便说一句，如果你打算调用全局函数，明确这样做的方式是`::f()`，或者如果函数在命名空间`NS`中，则是`NS::f()`。
- en: 'The compilation error where the compiler cannot find a member function that
    is clearly present in the base class is one of the more confusing C++ errors;
    it is even worse if the compiler does not issue this error and compiles the code
    “as intended” instead: if someone adds a global function with the same name later
    (or it is declared in another header you include), the compiler will switch to
    that function with no warning. The general guideline is to always qualify member
    function calls in a class template with `this->`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器无法找到在基类中明显存在的成员函数的编译错误是C++中较为令人困惑的错误之一；如果编译器没有报告这个错误，而是“按预期”编译了代码，那就更糟糕了：如果后来有人添加了一个具有相同名称的全局函数（或者它在另一个你包含的头文件中声明），编译器将无警告地切换到那个函数。一般准则是在类模板中对成员函数调用使用`this->`进行限定。
- en: 'Overall, the Template Method is one of the few patterns that remain purely
    object-oriented in C++: the template form we saw employed by `std::find_if` (and
    many more templates) usually falls under the general umbrella of Policy-Based
    designs that we’re going to study in the next chapter.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，模板方法是少数几个在C++中仍然纯粹面向对象的模式之一：我们看到的`std::find_if`（以及许多其他模板）的模板形式通常属于我们将在下一章研究的基于策略的设计的一般范畴。
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have reviewed a classic object-oriented design pattern,
    the Template Method, as it applies to C++ programs. This pattern works in C++
    as well as in any other object-oriented language, but C++ also has its own flavor
    of the Template Method—the non-virtual interface idiom. The advantages of this
    design pattern lead to a rather broad guideline—make all virtual functions private
    or protected. Be mindful, however, of the specifics of the destructors with regard
    to polymorphism. Here are the general guidelines for access (public vs private)
    to virtual functions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了经典面向对象设计模式之一，即模板方法，以及它如何应用于C++程序。这个模式在C++中以及任何其他面向对象的语言中都适用，但C++也有自己风格的模板方法——非虚接口习语。这种设计模式的优势导致了一个相当广泛的准则——将所有虚函数设为私有或保护。然而，关于多态，要注意析构函数的具体细节。以下是访问（公共与私有）虚函数的一般准则：
- en: Prefer to make interfaces nonvirtual, using the Template Method design pattern
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更倾向于使用模板方法设计模式将接口设为非虚
- en: Prefer to make virtual functions private
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更倾向于将虚函数设为私有
- en: Only if derived classes need to invoke the base implementation of a virtual
    function, make the virtual function protected.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当派生类需要调用虚拟函数的基类实现时，才将虚拟函数设为保护。
- en: A base class destructor should be either public and virtual (if objects are
    deleted through the base class pointer) or protected and nonvirtual (if derived
    objects are deleted directly).
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基类析构函数应该是公共和虚的（如果对象通过基类指针被删除）或者保护和非虚的（如果直接删除派生对象）。
- en: We already mentioned the Strategy pattern in this chapter by way of clarifying
    how it differs from the Template Method pattern. Strategy is also a popular pattern
    in C++, in particular, its generic programming equivalent. This is going to be
    the subject of the next chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经通过阐明它与模板方法模式的区别来提到了策略模式。策略也是C++中一个流行的模式，特别是它的泛型编程等价物。这将是下一章的主题。
- en: Questions
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a behavioral design pattern?
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是行为设计模式？
- en: What is the Template Method pattern?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板方法模式是什么？
- en: Why is the Template Method considered a behavioral pattern?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么模板方法被认为是行为模式？
- en: What is the inversion of control, and how does it apply to the Template Method?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制反转是什么，它如何应用于模板方法？
- en: What is the non-virtual interface?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非虚接口是什么？
- en: Why is it recommended to make all virtual functions in C++ private?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么建议在 C++ 中将所有虚函数设置为私有？
- en: When should virtual functions be protected?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该在何时将虚函数设置为保护？
- en: Why can’t the Template Method be used for destructors?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么模板方法不能用于析构函数？
- en: What is the Fragile Base class problem, and how can we avoid it when employing
    the Template Method?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是脆弱基类问题，以及我们在使用模板方法时如何避免它？
- en: 'Part 4: Advanced C++ Design Patterns'
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：高级 C++ 设计模式
- en: This part continues with the description and detailed explanation of C++ design
    patterns, moving on to the more advanced patterns. Some of these patterns use
    advanced features of the C++ language. Others represent complex concepts and address
    more difficult design problems. Yet other patterns implement very open-ended designs,
    where part of the solution can be factored out into a commonly accepted pattern,
    but the entire system must be customizable within very wide limits.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分继续描述和详细解释 C++ 设计模式，并转向更高级的模式。其中一些模式使用了 C++ 语言的先进特性。其他模式代表了复杂的概念，并解决了更困难的设计问题。还有一些模式实现了非常开放的设计，其中解决方案的一部分可以分解为一种普遍接受的模式，但整个系统必须在非常广泛的范围内可定制。
- en: 'This part has the following chapters:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 15*](B19262_15.xhtml#_idTextAnchor689), *Policy-Based Design*'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B19262_15.xhtml#_idTextAnchor689)，*基于策略的设计*'
- en: '[*Chapter 16*](B19262_16.xhtml#_idTextAnchor739), *Adapters and Decorators*'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B19262_16.xhtml#_idTextAnchor739)，*适配器和装饰器*'
- en: '[*Chapter 17*](B19262_17.xhtml#_idTextAnchor783), *The Visitor Pattern and
    Multiple Dispatch*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第17章*](B19262_17.xhtml#_idTextAnchor783)，*访问者模式和多重分派*'
- en: '[*Chapter 18*](B19262_18.xhtml#_idTextAnchor832), *Patterns for Concurrency*'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第18章*](B19262_18.xhtml#_idTextAnchor832)，*并发模式*'
