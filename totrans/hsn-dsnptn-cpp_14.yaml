- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Template Method Pattern and the Non-Virtual Idiom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Template Method is one of the classic *Gang of Four* design patterns, or,
    more formally, one of the 24 patterns described in the book *Design Patterns –
    Elements of Reusable Object-Oriented Software* by Erich Gamma, Richard Helm, Ralph
    Johnson, and John Vlissides. It is a behavioral design pattern, meaning that it
    describes a way for communicating between different objects. As an object-oriented
    language, C++, of course, fully supports the Template Method pattern, although
    there are some implementation details that are specific or unique to C++ that
    this chapter will elucidate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the Template Method pattern, and what problems does it solve?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the non-virtual interface?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should you make virtual functions public, private, or protected by default?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should you always make destructors virtual and public in polymorphic classes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example code for this chapter can be found at the following GitHub link:
    [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter14](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter14).'
  prefs: []
  type: TYPE_NORMAL
- en: The Template Method pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Template Method pattern is a common way to implement an algorithm whose
    overall structure is pre-determined, but some of the details of the implementation
    need to be customized. If you are thinking about a solution that goes something
    like this—first, we do *X*, then *Y*, and then *Z*, but how exactly we do *Y*
    depends on the data we process—you are thinking about the Template Method. As
    a pattern that allows the behavior of a program to change dynamically, the Template
    Method is somewhat similar to the strategy pattern. The key difference is that
    the strategy pattern changes the entire algorithm at runtime, while the Template
    Method lets us customize specific parts of the algorithm. This section deals with
    the latter, while we have a separate [*Chapter 16*](B19262_16.xhtml#_idTextAnchor739),
    *Policy-Based Design*, dedicated to the former.
  prefs: []
  type: TYPE_NORMAL
- en: The Template Method in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Template Method pattern is easily implemented in any object-oriented language.
    The C++ implementation uses inheritance and virtual functions. Note that this
    has nothing to do with C++ templates, as in generic programming. The *template*
    here is the skeleton implementation of the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The *template* here is the structure of the algorithm—all implementations must
    first do *step 1*, which may fail. If this happens, the entire algorithm is considered
    to have failed, and nothing more is done. If *step 1* succeeded, we must do *step
    2*. By design, *step 2* cannot fail, and the overall algorithm computation is
    considered a success once *step 2* is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `TheAlgorithm()` method is public but not virtual—any class derived
    from `Base` has it as a part of its interface but cannot override what it does.
    What the derived classes can override are the implementations of *step 1* and
    *step 2*, within the restrictions of the algorithm template – *step 1* may fail
    and must signal the failure by returning `false`, while *step 2* may not fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, overriding the potentially failing *step 1* is optional,
    and the default implementation is trivial; it does nothing and never fails. *Step
    2* must be implemented by every derived class—there is no default, and it is declared
    as a pure virtual function.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the overall flow of control—the framework—remains invariant,
    but it has *placeholders* for customizable options, possibly with a default offered
    by the framework itself. Such a flow is known as the inversion of control. In
    a traditional control flow, its specific implementation determines the flow of
    computation and sequence of operations and makes calls to library functions or
    other lower-level functions to implement the necessary general algorithms. In
    the Template Method, it is the framework that calls specific implementations in
    the custom code.
  prefs: []
  type: TYPE_NORMAL
- en: Applications of the Template Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many reasons to use the Template Method. In general, it is used to
    control what can and cannot be sub-classed—as opposed to a general polymorphic
    override, where the entire virtual function can be replaced, the base class here
    determines what can and cannot be overridden. Another common use of the Template
    Method is to avoid code duplication, and in this context, you can arrive at the
    use of the Template Method as follows. Suppose that you start with the regular
    polymorphism—a virtual function—and it overrides. For example, let’s consider
    this toy design for a turn-based combat system for a game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how this code is highly repetitive—all characters may be forced to disengage
    from combat on their turn, then they must take a turn to get ready for combat,
    and only then, if they are ready and strong enough, can they use their offensive
    capabilities. If you see this pattern repeating over and over, it is a strong
    hint that the Template Method may be called for. With the Template Method, the
    overall sequence of the combat turn is fixed, but how each character advances
    to the next step and what he/she does once he/she gets there remains character-specific:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now each derived class must implement only the part of the code that is unique
    to this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note how this code is much less repetitive. The advantage of the Template Method
    goes beyond good looks, though. Let’s say that in the next revision of the game,
    we have added healing potions, and at the beginning of the turn, each character
    may drink a potion. Now, imagine going through every derived class and adding
    code like `if (health_ < ... some class-specific value ... && potion_count_ >
    0) ...`. If the design already used the Template Method, the logic of potion-quaffing
    needs to be coded only once, and different classes implement their specific conditions
    for using a potion, as well as the consequences of drinking one. However, don’t
    rush to implement this solution until you get to the end of this chapter, as this
    is not the best C++ code you can do.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-and post-conditions and actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another common use of the Template Method is dealing with pre-and post-conditions
    or actions. In a class hierarchy, pre- and post-conditions generally verify that
    the design invariants of an abstraction provided by an interface are not violated
    by any specific implementation at any point during execution. Such verification
    naturally submits to the Template Method’s design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The invariants are the requirements that the object must satisfy when it’s
    accessible to the client, i.e., before any member function is called on it or
    after it returns. The member functions themselves often have to temporarily break
    the invariants, but they must restore the correct state of the class before returning
    control to the caller. Let us say that our classes from the preceding example
    keep track of how many actions have been executed. Each action is registered when
    it starts and again when it’s done, and the two counts must be the same: once
    an action is initiated, it has to complete before control is returned to the caller.
    Of course, inside the `ActionImpl()` member function this invariant is violated
    since an action is in progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, any practical implementation of pre- and post-conditions must take
    into account several additional factors. First, some member functions may have
    additional invariants, i.e., they can be called only when the object is in a restricted
    state. Such functions would have specific pre-conditions to test. Second, we have
    not considered the possibility that an action is aborted due to an error (this
    may or may not involve throwing an exception). A well-designed implementation
    of error handling must guarantee that the class invariants are not violated after
    such an error. In our case, a failed action may be ignored altogether (in which
    case, we need to decrement the count of started actions) or our invariant may
    have to be more complex: all started actions must end up as completed or failed,
    and we need to count both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In a real program, you must ensure that a failed transaction isn’t just counted
    correctly but is handled correctly too (often, it must be undone). We have discussed
    it in great detail in [*Chapter 5*](B19262_05.xhtml#_idTextAnchor199), *A Comprehensive
    Look at RAII*, and again in [*Chapter 11*](B19262_11.xhtml#_idTextAnchor509),
    *ScopeGuard*. Finally, in a concurrent program, it is no longer true that an object
    cannot be observed while a member function is being executed, and the entire subject
    of class invariants becomes much more complex and intertwined with thread-safety
    guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, in software design, one man’s invariants are another’s customization
    points. Sometimes, it is the main code that remains the same, but what happens
    right before and right after depends on the specific application. In this case,
    we probably wouldn’t be verifying any invariants, but instead executing initial
    and final actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There is, of course, no reason why pre- and post-conditions cannot be combined
    with opening and closing actions – the base class can have several “standard”
    member function calls before and after the primary implementation.
  prefs: []
  type: TYPE_NORMAL
- en: While this code gets the job done, it still has some deficiencies that we are
    about to expose.
  prefs: []
  type: TYPE_NORMAL
- en: The Non-Virtual Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of the dynamically customizable parts of the templated algorithm
    is usually done with virtual functions. For a general Template Method pattern,
    this is not a requirement, but in C++, we rarely need another way. Now, we are
    going to focus specifically on using the virtual functions and improving on what
    we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual functions and access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with a general question—should virtual functions be public or private?
    The textbook object-oriented design style uses public virtual functions, so we
    often make them public without a second thought. Within the Template Method, this
    practice needs to be reevaluated—a public function is part of the class interface.
    In our case, the class interface includes the entire algorithm, and the framework
    we put in place in the base class. This function should be public, but it is also
    non-virtual. The customized implementations of some parts of the algorithm were
    never meant to be called directly by the clients of the class hierarchy. They
    are used in one place only—in the non-virtual public function, where they replace
    the placeholders we put in the template of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'This idea may seem trivial, but it comes as a surprise to many programmers.
    I’ve had this question asked more than once—*does C++ even allow virtual functions
    to be anything other than public?* In fact, the language itself makes no restrictions
    on access to virtual functions; they can be private, protected, or public, just
    like any other class member functions. This can take some time to wrap your mind
    around; perhaps an example would help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Derived::method2()` and `Derived::method3()`are both private. Can the
    base class even call private methods of its derived classes? The answer is, it
    doesn’t have to—`Base::method1()` only calls `Base::method2()` and `Base::method3()`
    which are its own member functions (public and private, respectively); there is
    no problem with calling private member functions of the same class. But if the
    actual class type is `Derived`, the virtual override of `method2()` is called
    at runtime instead. These two decisions, *can I call* `method2()`*?* and *which*
    `method2()`*?*, happen at totally different times—the former happens when the
    module containing the `Base` class is compiled (and the `Derived` class may not
    have even been written yet), while the latter happens when the program is executed
    (and the words *private* or *public* don’t mean anything at that point). Also
    note that, as shown by `method3()` in the preceding example, a virtual function
    and its override can have different access. Again, the function invoked at compile
    time (`Base::method3()` in our case) must be accessible at the point of the call;
    the override that ends up executed at runtime doesn’t have to be (however, if
    we were to call `Derived::method3()` directly outside of the class itself, we
    would be trying to call a private method of that class).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is another, more fundamental reason, to avoid public virtual functions.
    A public method is a part of the class interface. A virtual function override
    is a customization of the implementation. A public virtual function inherently
    does both of these tasks, at once. The same entity performs two very different
    functions that should not be coupled—declaring the public interface and providing
    an alternative implementation. Each of these functions has different constraints—the
    implementation can be altered in any way, as long as the hierarchy invariants
    hold. But the interface cannot be actually changed by the virtual function (except
    for returning covariant types, but even that does not really change the interface).
    All the public virtual function does is restate that yes, indeed, the public interface
    still looks like what the base class has declared. Such a mixing of two very distinct
    roles calls for a better separation of concerns. The Template Method pattern is
    an answer to that design problem, and in C++, it takes the form of the **Non-Virtual**
    **Interface** (**NVI**).
  prefs: []
  type: TYPE_NORMAL
- en: The NVI idiom in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tension between the two roles of a public virtual function, and the unnecessary
    exposure of the customization points created by such functions, lead us to the
    idea of making the implementation-specific virtual functions private. Herb Sutter
    in his article, *Virtuality* ([http://www.gotw.ca/publications/mill18.htm](http://www.gotw.ca/publications/mill18.htm)),
    suggests that most, if not all, virtual functions should be private.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Template Method, moving virtual functions from public to private comes
    with no consequences (other than the initial shock of seeing a private virtual
    function, if you have never realized that C++ allows them):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This design nicely separates the interface and the implementation—the client
    interface is, and always was, the one call to run the entire algorithm. The possibility
    to change parts of the algorithm’s implementation is not reflected in the interface.
    Therefore, the user of this class hierarchy who only accesses it through the public
    interface and does not need to extend the hierarchy (write more derived classes),
    remains unaware of such implementation details. To see how this works in practice,
    you can convert every example in this chapter from public virtual functions to
    NVI; we are going to do just one, example 06, and leave the rest as an exercise
    to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The NVI gives complete control of the interface to the base class. The derived
    classes can only customize the implementation of this interface. The base class
    can determine and verify the invariants, impose the overall structure of the implementation,
    and specify which parts can, must, and cannot be customized. The NVI also separates
    the interface from the implementation explicitly. The implementers of the derived
    classes do not need to be concerned with exposing part of their implementation
    to the callers unintentionally—the implementation-only private methods cannot
    be called by anyone except the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that it is still possible for a derived class such as `LoggingFileWriter`
    to declare its own non-virtual function named `Write`. This is known as “shadowing”
    in C++: a name introduced in a derived class shadows (or makes inaccessible) all
    functions with the same name that would have been otherwise inherited from the
    base class. This causes the interfaces of the base and derived classes to diverge
    and is a very bad practice. Unfortunately, there is no good way for the base class
    implementer to protect from intentional shadowing. Accidental shadowing sometimes
    occurs when a function that is intended as a virtual override is declared with
    slightly different arguments; this can be avoided if the `override` keyword is
    used for all overrides.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have made all virtual functions that customize the implementation
    private. That, however, is not exactly the main point of the NVI—this idiom, and
    the more general Template Method, focus on making the public interface non-virtual.
    It follows, by extension, that the implementation-specific overrides should not
    be public since they are not part of the interface. It does not necessarily follow
    that they should be private. That leaves *protected*. So, should the virtual functions
    that provide customizations for the algorithm be private or protected? The Template
    Method allows both—the client of the hierarchy cannot directly call either one,
    so the framework of the algorithm remains unaffected. The answer depends on whether
    the derived classes may need to sub-invoke the implementations provided by the
    base class. For an example of the latter, consider a class hierarchy that can
    be serialized and sent to a remote machine through a socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, the framework is provided by the public non-virtual method `Base::Send()`,
    which handles the connection protocol and, at the right time, sends the data across
    the network. Of course, it can only send the data that the base class knows about.
    That is why `SendData` is a customization point and is made virtual. The derived
    class must send its own data, of course, but someone must still send the base
    class data, and so the derived class makes a call to the protected virtual function
    in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this example looks like it’s missing something, there is a good reason for
    it. While we provided the general template for how to send data and a customization
    point for each class to handle its own data, there is another behavior aspect
    that should be user-configurable: *how* to send data. This is a great place to
    show the (sometimes obscure) difference between the template method pattern and
    the strategy pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Template Method vs Strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this chapter is not about the Strategy pattern, it is sometimes confused
    with the Template Method, so we will now clarify the difference. We can use the
    example from the previous section to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already used the Template Method to provide an overall template for
    the execution of the “send” operation in `Base::Send()`. There are three steps
    to the operation: open the connection, send the data, and close the connection.
    Sending data is the step that depends on the actual type of the object (which
    derived class it really is), and so it is explicitly designated as a customization
    point. The rest of the template is set in stone.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However we need another kind of customization: the `Base` class, in general,
    is not the right place to define how to open and close the connection. Neither
    is the derived class: the same objects could be sent across different types of
    connections (sockets, files, shared memory, etc). This is where we can use the
    Strategy pattern to define communication strategy. The strategy is provided by
    a separate class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Isn’t it frustrating that template functions cannot be virtual? For a better
    solution to this problem, you have to wait until [*Chapter 15*](B19262_15.xhtml#_idTextAnchor689),
    *Policy-Based Design*. Anyway, now that we have the communication strategy, we
    can use it to parametrize the `Send()` operation template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the template for sending the data is basically unchanged, but we
    delegated the implementation of the specific steps to another class – the strategy.
    This is the key difference: the Strategy pattern allows us to choose (generally,
    at runtime) which implementation should be used for a particular operation. The
    public interface is fixed but the entire implementation is up to the specific
    strategy. The Template Method pattern enforces the overall implementation flow
    as well as the public interface. Only the specific steps of the algorithm can
    be customized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second difference is where the customization happens: `Base::Send()` is
    customized in two ways. The customizations to the template are done in the derived
    classes; the implementations of the strategy are provided by the classes outside
    of the `Base` hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: As we pointed out at the beginning of this section, there are good reasons to
    make all virtual member functions, by default, private (or protected), and they
    go beyond the applications of the Template Method pattern. However, there is one
    particular member function – the destructor - that deserves separate consideration
    because the rules for destructors are somewhat different.
  prefs: []
  type: TYPE_NORMAL
- en: A note about destructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The entire discussion of the NVI is an elaboration on a simple guideline—make
    virtual functions private (or protected), and present the public interface through
    non-virtual base class functions. This sounds fine until it runs head-on into
    another well-known guideline—if the class has at least one virtual function, its
    destructor must also be made virtual. Since the two are in conflict, some clarification
    is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason to make destructors virtual is that if the object is deleted polymorphically
    - for example, a derived class object is deleted through a pointer to the base
    class - the destructor must be virtual; otherwise, only the base part of the class
    will be destructed (the usual result is the *slicing* of the class, partial deletion,
    although the standard simply states that the results are undefined). So, if the
    objects are deleted through the base class pointers, the destructors must be virtual;
    there is no way around it. But that is the only reason. If the objects are always
    deleted with the correct derived type, then this reason does not apply. This situation
    is not uncommon: for example, if derived class objects are stored in a container,
    they will be deleted as their true type.'
  prefs: []
  type: TYPE_NORMAL
- en: The container has to know how much memory to allocate for the object, so it
    can’t store a mix of base and derived objects, or delete them as base objects
    (note that a container of pointers to the base class object is a different construct
    altogether, and is usually created specifically so that we can store and delete
    objects polymorphically).
  prefs: []
  type: TYPE_NORMAL
- en: Now, if the derived class has to be deleted as itself, its destructor does not
    need to be virtual. However, bad things will still happen if someone calls the
    destructor of the base class when the actual object is of the derived class type.
    To safely prevent that from happening, we can declare the non-virtual base class
    destructor as protected instead of public. Of course, if the base class is not
    abstract, and there are objects of both base and derived types around, then both
    destructors must be made public, and the safer option is to make them virtual
    (a runtime check can be implemented to verify that the base class destructor is
    not called to destroy a derived class object).
  prefs: []
  type: TYPE_NORMAL
- en: By the way, if polymorphic deletion (deletion through the base class pointer)
    is the only reason you need to write a destructor in the base class, writing `virtual
    ~Base() = default;` is perfectly acceptable – a destructor can be both `virtual`
    and `default` at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also caution the reader against trying to employ the Template Method,
    or the non-virtual interface idiom, for class destructors. It may be tempting
    to do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, this is not going to work (if the base class has a pure virtual `Base::clear()`
    instead of a default implementation, it is not going to work in a rather spectacular
    fashion). The reason for this is that, inside the destructor of the base class,
    `Base::~Base()`, the actual, real, and true type of the object is not `Derived`
    anymore. It’s `Base`. That’s right—when the `Derived::~Derived()` destructor is
    done with its work and the control is transferred to the base class destructor,
    the dynamic type of the object changes to `Base`.
  prefs: []
  type: TYPE_NORMAL
- en: The only other class member that works this way is the constructor—the type
    of the object is `Base` as long as the base constructor is running, and then changes
    to `Derived` when the derived constructor has started. For all other member functions,
    the type of the object is always the type it was created with. If the object was
    created as `Derived`, then that is the type, even if a method of the base class
    is called. So, what happens if, in the preceding example, `Base::clear()` is pure
    virtual? It’s called anyway! The result depends on the compiler; most compilers
    will generate code that aborts the program, with some diagnostic that *a pure
    virtual function* *was called*.
  prefs: []
  type: TYPE_NORMAL
- en: Drawbacks of the Non-Virtual Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There aren’t many drawbacks regarding the use of the NVI. That is why the guideline
    to always make virtual functions private, and use the NVI to call them, is widely
    accepted. However, there are some considerations that you must be aware of when
    deciding whether the Template Method is the right design pattern to follow. The
    use of the template pattern may lead to fragile hierarchies. Also, there is some
    overlap between design problems that can be solved using the template pattern
    and the ones better served by the strategy pattern, or, in C++, policies. We will
    review both considerations in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Composability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the earlier design for `LoggingFileWriter`. Now, suppose that we want
    to also have `CountingFileWriter` that counts how many characters were written
    into the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That was easy. But there is no reason a counting file writer cannot also log.
    How would we implement a `CountingLoggingFileWriter`? No problem, we have the
    technology—change the private virtual functions to protected and call the base
    class version from the derived class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Or should it be `LoggingCountingFileWriter` that inherits from `CountingFileWriter`?
    Note that, either way, some code is duplicated—in our case, the counting code
    is present in both `CountingLoggingFileWriter` and `CountingFileWriter`. This
    duplication is only going to get worse as we add more variations. The Template
    Method just isn’t the right pattern if you need composable customizations. For
    that, you should read [*Chapter 15*](B19262_15.xhtml#_idTextAnchor689), *Policy-Based
    Design*.
  prefs: []
  type: TYPE_NORMAL
- en: The Fragile Base Class problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Fragile Base Class problem is not limited to the Template Method, but is,
    to some degree, inherent in all object-oriented languages. The problem arises
    when changes to the base class break the derived class. To see how this can happen,
    specifically when using the non-virtual interface, let’s go back to the file writer
    and add the ability to write many strings at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The counting writer is kept up to date with the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. Later, a well-intentioned programmer notices that the base
    class suffers from some code duplication and decides to refactor it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the derived class is broken—the counting customizations of both versions
    of `Write` are called when a vector of strings is written, and the data size is
    counted twice. Note that we are not talking about the more basic kind of fragility
    where an override method in a derived class can stop being an override if the
    signature of the base class method is changed: this kind of fragility is largely
    avoided by the proper use of the `override` keyword as recommended in [*Chapter
    1*](B19262_01.xhtml#_idTextAnchor014), *An Introduction to Inheritance* *and Polymorphism*.'
  prefs: []
  type: TYPE_NORMAL
- en: While there is no general solution to the Fragile Base Class problem as long
    as inheritance is used at all, the guideline that helps to avoid it when using
    the Template Method is straightforward—when changing the base class and the structure
    of the algorithms, or the framework, avoid changing which customization points
    are invoked. Specifically, do not skip any customization options that were already
    invoked, and do not add new calls to already existing ones (it’s OK to add new
    customization points, as long as the default implementation is sensible). If such
    a change cannot be avoided, you will need to review every derived class to see
    whether it relied on the implementation override that is now removed or replaced,
    and what the consequences of such a change are.
  prefs: []
  type: TYPE_NORMAL
- en: A cautionary note about template customization points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This brief section is not a drawback of the Template Method, but rather a warning
    about a somewhat arcane corner of C++. Many of the design patterns that were originally
    developed as run-time behaviors (object-oriented patterns) found their compile-time
    analogs in C++ generic programming. So, is there a compile-time template method?
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there is an obvious one: we can have a function or a class template
    that accepts function parameters, or, more generally, callable parameters, for
    a certain step of the otherwise fixed algorithm. The standard library has a plethora
    of examples, such as `std::find_if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm of `std::find_if` is known and cannot be altered, except for the
    step where it checks whether a particular value satisfies the caller’s predicate.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to do the same for class hierarchies, we can use member function
    pointers (although it is easier to invoke member functions through lambdas), but
    there is no way to say “*call a member function with the same name but on a different
    class*” except by using virtual functions and their overrides. There is no equivalent
    to that in generic programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, there is a case where a template can be customized by accident,
    usually with unintended results. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Which function `f()` is called from inside `B<T>::h()`? On a standard-compliant
    compiler, it should be the free-standing function, i.e. `::f()`, and not the member
    function of the base class! This may come as a surprise: if `A` and `B` were non-template
    classes, the base class method `A::f()` would have been called. This behavior
    arises from the complexities of parsing templates in C++ (if you want to learn
    more about this, `two-phase template parse` or `two-stage name lookup` are the
    terms to search for, but the matter is far outside the subject of this book).'
  prefs: []
  type: TYPE_NORMAL
- en: What would have happened if the global function `f()` was not available in the
    first place? Then we have to call the one in the base class, don’t we?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you tried this code and it has called `A<T>::f()`, then you have a buggy
    compiler: the standard says that this should not compile at all! But what should
    you do if you want to call a member function of your own base class? The answer
    is very simple but looks strange if you haven’t written a lot of template code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That’s right, you have to explicitly call `this->f()` to ensure that you’re
    calling a member function. If you do this, `A<T>::f()` gets called whether or
    not there is a global `f()` declared. By the way, if you intended to call the
    global function, the way to do this unambiguously is `::f()`, or, if the function
    is in a namespace `NS`, `NS::f()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compilation error where the compiler cannot find a member function that
    is clearly present in the base class is one of the more confusing C++ errors;
    it is even worse if the compiler does not issue this error and compiles the code
    “as intended” instead: if someone adds a global function with the same name later
    (or it is declared in another header you include), the compiler will switch to
    that function with no warning. The general guideline is to always qualify member
    function calls in a class template with `this->`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, the Template Method is one of the few patterns that remain purely
    object-oriented in C++: the template form we saw employed by `std::find_if` (and
    many more templates) usually falls under the general umbrella of Policy-Based
    designs that we’re going to study in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have reviewed a classic object-oriented design pattern,
    the Template Method, as it applies to C++ programs. This pattern works in C++
    as well as in any other object-oriented language, but C++ also has its own flavor
    of the Template Method—the non-virtual interface idiom. The advantages of this
    design pattern lead to a rather broad guideline—make all virtual functions private
    or protected. Be mindful, however, of the specifics of the destructors with regard
    to polymorphism. Here are the general guidelines for access (public vs private)
    to virtual functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Prefer to make interfaces nonvirtual, using the Template Method design pattern
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prefer to make virtual functions private
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only if derived classes need to invoke the base implementation of a virtual
    function, make the virtual function protected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A base class destructor should be either public and virtual (if objects are
    deleted through the base class pointer) or protected and nonvirtual (if derived
    objects are deleted directly).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We already mentioned the Strategy pattern in this chapter by way of clarifying
    how it differs from the Template Method pattern. Strategy is also a popular pattern
    in C++, in particular, its generic programming equivalent. This is going to be
    the subject of the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a behavioral design pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Template Method pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the Template Method considered a behavioral pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the inversion of control, and how does it apply to the Template Method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the non-virtual interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it recommended to make all virtual functions in C++ private?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should virtual functions be protected?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why can’t the Template Method be used for destructors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Fragile Base class problem, and how can we avoid it when employing
    the Template Method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 4: Advanced C++ Design Patterns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part continues with the description and detailed explanation of C++ design
    patterns, moving on to the more advanced patterns. Some of these patterns use
    advanced features of the C++ language. Others represent complex concepts and address
    more difficult design problems. Yet other patterns implement very open-ended designs,
    where part of the solution can be factored out into a commonly accepted pattern,
    but the entire system must be customizable within very wide limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B19262_15.xhtml#_idTextAnchor689), *Policy-Based Design*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B19262_16.xhtml#_idTextAnchor739), *Adapters and Decorators*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 17*](B19262_17.xhtml#_idTextAnchor783), *The Visitor Pattern and
    Multiple Dispatch*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 18*](B19262_18.xhtml#_idTextAnchor832), *Patterns for Concurrency*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
