- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Menus, Making Enemies, and Using Autoloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although it was a lot of fun setting up all the current systems, the game is
    still kind of boring. There is no real adversary, nothing to stop the player from
    just picking up all the gold coins they desire. Let’s bring some challenge into
    the mix by creating enemies that attack the player and try to stop their road
    to glory and fame!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next to that, we’ll also create a little menu to start our game from. We’ll
    do this with Godot’s **user interface** (**UI**) system, which makes use of **Control**
    nodes. In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making enemies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shooting projectiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scoring highscores in autoloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As for every chapter, you can find the final code on the GitHub repository
    in the subfolder for this chapter: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter10](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most exciting part of developing a game is, of course, making the game
    itself! Making things move, fight, jump, shoot, interact, and so forth. But there
    is another part that is just as important: the UI. A UI binds everything together.
    It informs the player of what is happening and lets them navigate from menu to
    menu with ease and without having to think about how to get from one interface
    to the other.'
  prefs: []
  type: TYPE_NORMAL
- en: Good user experience, UI, or human-computer interaction design is hard! But
    it all starts with learning how to make the UI in the first place. So, let’s have
    a look at how we can create menus and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Control nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Godot engine comes with an extensive library of interface nodes. We already
    made use of one, the **Label** node, in [*Chapter 6*](B19358_06.xhtml#_idTextAnchor411).
    These nodes are called **Control nodes** and get labeled by the color green:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Some Control nodes can be recognized by their green color](img/B19358_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Some Control nodes can be recognized by their green color
  prefs: []
  type: TYPE_NORMAL
- en: If you go and open the **Create New Node** menu, you’ll see there are a lot
    of these **Control** nodes. We could categorize these into three different groups.
    Let’s go over some of the nodes and what they can do for us in each group.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes showing information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first group of nodes shows information. In this group, you would find the
    **Label** node we used in [*Chapter 6*](B19358_06.xhtml#_idTextAnchor411), but
    also the **ColorRect** and **TextureRect** nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Label**: Shows a short string of text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RichTextLabel**: Shows a longer piece of text that can be formatted in specific
    ways.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ColorRect**: Shows a solid rectangle in one color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TextureRect**: Shows a texture in a rectangle. This node is similar to the
    **Sprite2D** node in that they are both used to show a texture but in different
    contexts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following figure, you can see what these nodes look like in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Examples of Control nodes that show information](img/B19358_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Examples of Control nodes that show information
  prefs: []
  type: TYPE_NORMAL
- en: These nodes all show something to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes taking input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any good UI can also take input, with – for example – buttons. Here are some
    of the input nodes that the Godot engine UI nodes provide:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Button**: A simple button that can be clicked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CheckBox**: A checkbox that can be turned on and off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CheckButton**: The same as a checkbox, but just with a different aesthetic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LineEdit**: A simple node that can take a single line of text input and provide
    it as a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HSlider** and **VSlider**: Sliders that are used to input a number. **HSlider**
    slides horizontally while **VSlider** slides vertically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following figure, you can see what these nodes look like in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Examples of Control nodes that take input](img/B19358_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Examples of Control nodes that take input
  prefs: []
  type: TYPE_NORMAL
- en: These nodes all take input in one way or another.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes containing other nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lastly, there are the nodes that you don’t see but that are very important because
    they make sure all the other UI elements are placed correctly. These nodes form
    the skeleton in which the other **Control** nodes can find their place.
  prefs: []
  type: TYPE_NORMAL
- en: '**Container** nodes help us to lay out the UI as we want. This type of node
    can display elements nicely next to each other, add some spacing between nodes,
    and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: These containers can also help keep the interface usable and beautiful when
    we resize the screen. This does not happen often, but games can be played on so
    many different screen sizes and aspect ratios these days. Just think about the
    difference between a computer screen and a phone screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some interesting container nodes are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VBoxContainer** and **HBoxContainer**: Organize all their child nodes nicely,
    vertically or horizontally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CenterContainer**: Centers its child nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GridContainer**: Organizes all its child nodes in a tidy grid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MarginContainer**: Adds spacing around its child nodes so that they have
    some room to breathe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Panel**: Provides a background that shows this part of the UI logically belongs
    together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following figure, you can see what these nodes look like in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Examples of Control nodes that can contain other nodes](img/B19358_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Examples of Control nodes that can contain other nodes
  prefs: []
  type: TYPE_NORMAL
- en: '**Container** nodes all contain and place their child nodes in a specific way.'
  prefs: []
  type: TYPE_NORMAL
- en: The lists of nodes in this section are not exhaustive; a quick glance in the
    **Control** node category while adding a node makes this pretty obvious. But these
    are the most important nodes that you will likely use first. The others are more
    specialized.
  prefs: []
  type: TYPE_NORMAL
- en: The cool thing is that the complete Godot editor itself is constructed out of
    these Control nodes, just to show how flexible and powerful they are for building
    out UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic knowledge of the different **Control** nodes, we can
    start making a menu with them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic start menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a start menu that displays when we start up the game. This menu
    should simply display the game’s name, a button to start playing, a button to
    exit the game, and lastly, we could add some information on who created the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – This is what our start menu will look like](img/B19358_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – This is what our start menu will look like
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over the steps to create a start menu, as shown in *Figure 10**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene called `menu.tscn` under a new `screens/ui` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **User Interface** as the root node’s type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Choosing User Interface as the root node for our menu](img/B19358_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Choosing User Interface as the root node for our menu
  prefs: []
  type: TYPE_NORMAL
- en: Rename the root node `Menu`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start by adding a **ColorRect** node to the menu; this will be our background
    color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, to stretch the **ColorRect** node to cover the whole screen, **Control**
    nodes have a handy dandy little menu in the top bar. Select the **ColorRect**
    node in the scene tree and select **Full Rect** from the **Anchor** **preset**
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Choosing Full Rect to make the ColorRect node cover the full
    screen](img/B19358_10_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Choosing Full Rect to make the ColorRect node cover the full screen
  prefs: []
  type: TYPE_NORMAL
- en: Now, add a `MainUIContainer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add a `TitleLabel`. This label will show the title of our game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.8 – The scene tree of our menu until now](img/B19358_10_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – The scene tree of our menu until now
  prefs: []
  type: TYPE_NORMAL
- en: Think of a good title for the game and put it in the text field of the **TitleLabel**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, go to `60` px:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.9 – You can change the font size of a label in Theme Overrides](img/B19358_10_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – You can change the font size of a label in Theme Overrides
  prefs: []
  type: TYPE_NORMAL
- en: This was just to create a title label for our game UI. It might seem like a
    lot of steps, but some of the nodes we used will make it easy to extend the UI
    in the next few steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a panel with buttons and a credit line:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **PanelContainer** node to the **MainUIContainer** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create the following structure in this panel container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.10 – The scene tree structure from the PanelContainer node](img/B19358_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – The scene tree structure from the PanelContainer node
  prefs: []
  type: TYPE_NORMAL
- en: Rename the first button `PLAY`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the second button `EXIT`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the label **CreditLabel** and change its text to whatever you would like
    it to say!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, go into the first `50` px.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `20` px.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, set the `200` px.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Great work – the UI layout is finished. The complete scene tree should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – The complete scene tree of our menu](img/B19358_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – The complete scene tree of our menu
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left to do is to make the buttons functional! Let us do that
    real quick:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an empty script to the root `menu.gd`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, connect the pressed signal of the **PlayButton** node to this node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The body of the connected function is quite simple:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, connect the pressed signal of the **ExitButton** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The body of this function is even simpler:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippets, we reached out to the root of the scene tree
    with `get_tree()`. This function returns `SceneTree`, the object that manages
    the whole hierarchy of nodes while the game is running.
  prefs: []
  type: TYPE_NORMAL
- en: In the function that is connected to the `change_scene_to_file()` function on
    this object, which switches out the current running scene to the one that is specified
    by the path we provide to the function. So, to start the main game scene, we just
    give it the path, starting from the root of the project, to the `main.tscn` scene.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It’s good to note that from the moment it is called, `change_scene_to file()`
    will also load the scene file it is supposed to switch to. This means that the
    game will block or freeze for this loading duration. This is not great when we
    are switching to a big scene, which we luckily are not doing in our case.
  prefs: []
  type: TYPE_NORMAL
- en: In the function that is connected to the `quit()` function, which simply shits
    down the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: You can now try out the menu by running it!
  prefs: []
  type: TYPE_NORMAL
- en: Setting the main scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make sure our menu is the main scene that boots up the game, we’ll quickly
    need to step into the project settings to declare this. In the project settings,
    under `menu.tscn` is the main scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Setting the main scene in the project settings](img/B19358_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Setting the main scene in the project settings
  prefs: []
  type: TYPE_NORMAL
- en: This will make sure that when we run the game, using the `menu.tscn` scene is
    the scene that gets launched by default.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when there is no main scene set and we run the game through the
    aforementioned methods, Godot will ask us if we want to use the currently opened
    scene as the main scene.
  prefs: []
  type: TYPE_NORMAL
- en: We learned a lot about **Control** nodes and how to use them to quickly construct
    UIs. Let’s go and make some enemies.
  prefs: []
  type: TYPE_NORMAL
- en: Making enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In real life, making enemies is never a good idea. But in the context of video
    game development, it is often a great way to challenge the player and put them
    against some opposition.
  prefs: []
  type: TYPE_NORMAL
- en: The enemy that we will be creating is fairly simple and straightforward. But
    we will still learn a lot along the way – for example, how to let enemies navigate
    toward the player to attack them.
  prefs: []
  type: TYPE_NORMAL
- en: Like I said, we’ll keep the enemy simple. We’ll be making an enemy that spawns
    at a random time in a random spot of the arena and starts charging toward the
    player. From the moment the enemy touches the player, we’ll deduct one health
    point from the player’s life and remove the enemy from the game. This way, the
    player has some adversaries but should not get overwhelmed by a horde of enemies.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, *Shooting projectiles*, we’ll develop a way for the
    player to defend themselves. But for now, we’ll solely focus on the enemy and
    its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the base scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with any new part of our game, let’s start by creating the base structure
    in a scene tree for the enemy and add code and other interesting things later
    in the section:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `parts/enemy` folder, and within it, create a new scene called `enemy.tscn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Recreate the following scene tree. Note that the root is a **CharacterBody**
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.13 – The scene tree of our Enemy scene](img/B19358_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – The scene tree of our Enemy scene
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose a sprite from the `assets/sprites/enemies` folder as the texture for
    the **Sprite2D** node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.14 – The Enemy scene in the 2D editor](img/B19358_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – The Enemy scene in the 2D editor
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you set the scale of the sprite node to `(``3, 3)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the moment, the `Enemy` scene is very simple. Let’s look into how we could
    do navigation to complexify it a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating enemies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can easily make enemies move directly toward the player. The problem with
    this is that they will get stuck behind walls and bump into boulders, which doesn’t
    feel very natural and makes them look quite dumb.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the Godot engine comes with a **NavigationServer** property that calculates
    a path around all these obstacles and makes enemy movement more natural and fluent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we will look at two new nodes: `NavigationRegion2D` and
    `NavigationAgent2D`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a NavigationRegion2D node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Firstly, we need to define in what region of the level our enemy can move around,
    then we want to cut out spots where a wall or boulder is situated from this region.
    This is exactly what the `NavigationRegion2D` node does! Let’s define one:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `main.tscn` game scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the root node called `Main`, add a `NavigationRegion2D` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the empty **Navigation Polygon** property and select **New NavigationPolygon**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Clicking on New NavigationPolygon](img/B19358_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Clicking on New NavigationPolygon
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’ll first define the outer bounds of where enemies will be able to move.
    Draw a polygon shape by clicking in the editor. Try to trace the outside of the
    arena closely. Don’t forget to close the shape by clicking the first point you
    placed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Creating the outer bounds of the NavigationRegion2D node](img/B19358_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Creating the outer bounds of the NavigationRegion2D node
  prefs: []
  type: TYPE_NORMAL
- en: 'Press **Bake NavigationPolygon** at the top of the window to create a navigation
    polygon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Pressing Bake NavigationPolygon](img/B19358_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Pressing Bake NavigationPolygon
  prefs: []
  type: TYPE_NORMAL
- en: 'After following these steps, the `NavigationRegion2D` node should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – The NavigationRegion2D node after baking the polygon for the
    first time](img/B19358_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – The NavigationRegion2D node after baking the polygon for the
    first time
  prefs: []
  type: TYPE_NORMAL
- en: The blue/greenish area is where enemies will be able to navigate and move in.
    But you can already see a problem – this region also spans over our walls and
    boulders. We don’t want enemies to think that they can walk through them because,
    well, they can’t; they are static physics bodies. Luckily, Godot has the functionality
    to automatically detect these and bake the `NavigationPolygon` property in such
    a way that it takes them into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfold the `NavigationRegion2D` node by clicking on it and configure it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Set **Geometry** | **Parsed Geometry Type** to **Static Colliders**. We do this
    to only consider static colliders in the automatic generation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Geometry** | **Source Geometry Mode** to **Group With Children**. This
    way, the automatic generation will scan through the children of nodes to find
    the static colliders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set `40` px. With this, we define the radius of the agents we want to use in
    the `NavigationRegion2D` node, and the automatic generation can take this into
    account so that agents don’t bump into obstacles they should be able to avoid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.19 – Configuring the NavigationPolygon property](img/B19358_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 – Configuring the NavigationPolygon property
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `Arena` node and switch to the **Node** tab, next to the **Inspector**
    tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.20 – Going to the Node tab](img/B19358_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 – Going to the Node tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the **Groups** tab, which is next to the **Signals** tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.21 – Switching to the Groups tab](img/B19358_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.21 – Switching to the Groups tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Paste `navigation_polygon_source_geometry_group` into the text field and press
    **Add**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.22 – Adding the navigation_polygon_source_geometry_group group](img/B19358_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.22 – Adding the navigation_polygon_source_geometry_group group
  prefs: []
  type: TYPE_NORMAL
- en: Now, select the `NavigationRegion2D` node again and press **Bake** **NavigationPolygon**
    again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you are done, the navigation region should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.23 – The resulting NavigationRegion2D node](img/B19358_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.23 – The resulting NavigationRegion2D node
  prefs: []
  type: TYPE_NORMAL
- en: The blue/greenish region now nicely avoids walls and boulders. You can also
    see that there is some margin between obstacles and where the region begins. This
    is what we set up when defining the **Radius** property of the agents. This margin
    makes sure the pathfinding doesn’t come too close to obstacles, making enemies
    avoid colliding with them.
  prefs: []
  type: TYPE_NORMAL
- en: In *steps 2* to *4*, we added the `Arena` node to a `navigation_polygon_source_geometry_group`
    node group and consider the static bodies within them. Let’s take a small detour
    to talk about node groups.
  prefs: []
  type: TYPE_NORMAL
- en: What are node groups?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Groups** or **node groups** in the Godot engine are like tags in other pieces
    of software. You can add any number of groups to a node. We can simply do this
    through the **Groups** tab, just like we did in the steps of the last section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Groups are extremely useful because you can, for example, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if a node is part of a group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get all nodes within a group from the tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call methods on all nodes within a group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll use groups some more later on.
  prefs: []
  type: TYPE_NORMAL
- en: The `NavigationRegion2D` node is ready, so now, let’s take a look at the process
    of adding a `NavigationAgent2D` node to the `Enemy` scene.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a NavigationAgent2D node to the Enemy scene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last thing we need to add to the `enemy.tscn` scene from within the editor
    before starting to write code is a `NavigationAgent2D` node. This node handles
    pathfinding and navigation within the `NavigationRegion2D` node that we created
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just add a `NavigationAgent2D` node in the root `Enemy` node. We don’t have
    to do any other setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.24 – Adding a NavigationAgent2D node to the Enemy scene](img/B19358_10_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.24 – Adding a NavigationAgent2D node to the Enemy scene
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can start writing the code for our enemy!
  prefs: []
  type: TYPE_NORMAL
- en: Writing the enemy script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code for our enemy is going to be very similar to the code for our player.
    They both walk around based on the physics of an accelerating velocity. The only
    difference is that for the enemy, the position where it wants to move is defined
    by the `NavigationServer` property. This server looks at the `NavigationRegion2D`
    node and the current position of the `NavigationAgent2D` node to calculate the
    best route with the point on the map we choose to go to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start out by writing some boilerplate code that defines some of our enemy’s
    movement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, this code is very similar to the movement code that we wrote for
    the `player.gd` script. The only difference is that we now use the `NavigationAgent2D`
    node to say where we need to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are going toward the global position of the `player` variable.
    We’ll define this `player` variable in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Position and global_position
  prefs: []
  type: TYPE_NORMAL
- en: The `position` variable of a `global_position` variable, on the other hand,
    is the position of the node in world space, relative to the root of the scene
    tree. Both get automatically updated when the node moves in 2D space; it is basically
    the same data but with a different point of reference.
  prefs: []
  type: TYPE_NORMAL
- en: We need to use the `global_position` variable here because the target position
    of a `NavigationAgent2D` node has to be a global position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to check whether we need to move or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to move, we ask the `NavigationAgent2D` node what the next position
    we should move to is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then, all we need to do is calculate the direction from our current position
    to this next position, and the rest of the code is exactly the same as for the
    `Player` scene from [*Chapter 7*](B19358_07.xhtml#_idTextAnchor523).
  prefs: []
  type: TYPE_NORMAL
- en: 'To select the `Player` node, we are going to use node groups by adding this
    `_ready()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To get the player from within the scene tree, we do something new. We ask the
    current scene tree for all nodes that are in the `player` group. This function
    will return an array with nodes that belong to this group. So, we’ll have to take
    the first element, if there is any.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It might look weird to ask for all the player nodes in the scene while there
    is only one. We do this so that we can use roughly the same code to target more
    players when we deal with multiple players in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: These node groups are a useful feature of the Godot engine because the engine
    will keep track of all nodes within a group so that we can easily query them or
    check if a node belongs to a certain group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this code will not work yet because, well, the player is actually not
    yet in the `player` group! To add them to this group, we need to alter the `Player`
    scene a little:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `player.tscn` scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the root node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the window that contains the node’s signals, there is a button called **Groups**.
    Press it, and you will see the **Groups** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.25 – Adding the player’s root node to the node group called player](img/B19358_10_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.25 – Adding the player’s root node to the node group called player
  prefs: []
  type: TYPE_NORMAL
- en: Here, type `player` into the line input and press **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put an enemy in the main scene, and you will see that it starts moving toward
    the player! This is great. But enemies should be able to damage the player, so
    let’s work on that next.
  prefs: []
  type: TYPE_NORMAL
- en: Damaging the player in a collision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To detect if an enemy is close enough to the player to deal damage, we are
    going to use an **Area2D** node, as we did for collectibles in [*Chapter 9*](B19358_09.xhtml#_idTextAnchor590):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding a `get``_hit()` function to the `player.gd` script. This
    function will get called when the player is hit by an enemy and lower the health
    of the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add an `enemy.tscn` scene and call it `PlayerDetectionArea`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under this area, add a **CollisionShape2D** node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.26 – Adding an Area2D node to the Enemy scene](img/B19358_10_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.26 – Adding an Area2D node to the Enemy scene
  prefs: []
  type: TYPE_NORMAL
- en: 'Make this collision shape a **CircleShape2D** node that is a little bigger
    than the enemy’s sprite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.27 – Covering the whole enemy with some margin with the CollisionShape2D
    node](img/B19358_10_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.27 – Covering the whole enemy with some margin with the CollisionShape2D
    node
  prefs: []
  type: TYPE_NORMAL
- en: Connect the `body_entered` signal to the root node of the enemy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, use the next snippet of code as the body of the connected function in
    the enemy’s script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code of this function is straightforward. First, we check if the body that
    entered the area actually is the player. We can do this simply with the following
    check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can check whether a certain node is in a certain group. If this
    body is not in the `player` group, we return out of the function.
  prefs: []
  type: TYPE_NORMAL
- en: But if the body is a player node, then we remove one point from its health and
    free the enemy that made contact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great – our enemy can now damage the player when it comes close enough. There
    is only one more problem: there are only as many enemies as we can drag and drop
    into the scene. Enemies should be able to spawn automatically and constantly!
    Otherwise, the game would be over very quickly. Let’s make an automatic spawner
    that spawns enemies but also health potions.'
  prefs: []
  type: TYPE_NORMAL
- en: Spawning enemies and collectibles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To automatically spawn enemies or collectibles in our playfield is actually
    harder than it looks at first sight. We can randomly pick a location and spawn
    something there. Doing this, however, could spawn an enemy or a collectible within
    a wall or boulder. Even worse, the enemy or collectible could spawn miles away
    from the arena and the navigation region, rendering them useless.
  prefs: []
  type: TYPE_NORMAL
- en: We could solve this in many smart and abstract ways, but often, the simplest
    way is the best to start out with. That is why we’ll construct our own entity
    spawner that can spawn different kinds of entities, enemies, collectibles, or
    anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the scene structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An easier way of solving the problem of the location of enemy spawning is by
    defining certain points within the arena at which we are sure the enemy can safely
    spawn. So, that is what we are going to do in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene that derives from the `EntitySpawner`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save this scene as `entity_spawner.tscn` under `parts/entity_spawner`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `EntitySpawner`, add another `Positions`. Here we’ll later define all
    positions where we can spawn something:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.28 – The structure for our EntitySpawner scene](img/B19358_10_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.28 – The structure for our EntitySpawner scene
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop an instance of `EntitySpawner` into the `main.tscn` scene and
    rename it `EnemySpawner`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, right-click `EnemySpawner` and select **Editable Children**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.29 – Enabling Editable Children to directly edit the children of
    an instanced scene](img/B19358_10_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.29 – Enabling Editable Children to directly edit the children of an
    instanced scene
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the `EnemySpawner` scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.30 – Adding Marker2D nodes that will be used to position enemies](img/B19358_10_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.30 – Adding Marker2D nodes that will be used to position enemies
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, under this **Positions** node, add multiple **Marker2D** nodes and place
    them at locations where you want enemies to be able to spawn:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.31 – The different positions at which I wanted enemies to spawn](img/B19358_10_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.31 – The different positions at which I wanted enemies to spawn
  prefs: []
  type: TYPE_NORMAL
- en: The `EnemySpawner` node was pretty simple to set up until now, but we did use
    some new things. Firstly, we enabled **Editable Children** on a node that is a
    complete scene. This exposes that whole scene’s structure to us and makes it easy
    for us to edit the individual nodes within. This is very useful for reusing scenes
    very directly.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the nodes under the `EnemySpawner` node are grayed out. This means
    that we can edit them, move them around, and such, just like when we inherited
    from the collectible scene to make the health potion, but we cannot delete these
    grayed-out nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next to editing the children, we used a new node type: **Marker2D**. This is
    a node that actually does nothing special during the game, but in the editor,
    it will display a little cross to mark the location it is positioned at. This
    node gets used if you need to mark a position like we are doing here.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the base code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the code, we’ll do something pretty simple and provide a `spawn_entity()`
    function that spawns a new entity, be it an enemy or a health potion, at one of
    the defined positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first new thing that we encounter is an exported variable of the `PackedScene`
    type. This `PackedScene` variable is basically the definition of any scene – a
    scene file. Any scene file can fill this variable.
  prefs: []
  type: TYPE_NORMAL
- en: Difference between a PackedScene variable and a Node variable
  prefs: []
  type: TYPE_NORMAL
- en: A `PackedScene` variable represents a scene file, such as the `enemy.tscn` file.
    It is a template that we can use to create new nodes from.
  prefs: []
  type: TYPE_NORMAL
- en: A `Node` variable, on the other hand, is a building block of the scene tree
    and can be an instance of a `PackedScene` variable.
  prefs: []
  type: TYPE_NORMAL
- en: You could see a `PackedScene` variable as a class, while a `Node` variable is
    an instanced object of that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, later, we can use this packed scene to instantiate a new entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The last thing we need to do to make this new instanced entity a part of the
    scene tree is to add it to an existing node within the tree because if we don’t
    add it somewhere within the scene tree, it is not used within the game or its
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a new node as a child to another node by calling the `add_child()`
    function on any node within the tree with this new entity node as the parameter.
    The entity will then get added as a child to that node. Here, we add the entity
    node to `EntitySpawner`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, the entity is truly put into the tree and thus within the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'To select a random position, we also do something new. First, we get an array
    of children from the `get_children()`, which is an array of position markers.
    Then, to pick a random element from this array, we can make use of the `pick_random()`
    function to easily select one random position marker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will provide us with a **Marker2D** node at random that we can use to spawn
    the enemy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our `EnemySpawner` node that is in the `main.tscn` scene spawn enemies,
    we just need to drag and drop the `enemy.tscn` scene on top of the `EnemySpawner`
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.32 – Dragging and dropping the enemy.tscn file into the Entity
    Scene property](img/B19358_10_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.32 – Dragging and dropping the enemy.tscn file into the Entity Scene
    property
  prefs: []
  type: TYPE_NORMAL
- en: With this set up, we can start spawning entities at a fixed time interval.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically spawning entities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have a function that can spawn an entity, we still need to trigger
    it at some point. To do this, we are going to make use of the `timeout` signal
    when the timer runs out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a `EntitySpawner` scene:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `entity_spawner.tscn` scene file and call it `SpawnTimer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, connect the timeout signal to the `EntitySpawner` root node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the connected function, just call the `spawn_entity()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a reference to the `SpawnTimer` node and an `export` variable that will
    represent the interval at which we’ll spawn entities at the top of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can add two extra functions that help us start and stop the timer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, to autostart the timer at the start of the game, add this `_ready()`
    function to the `EntitySpawner` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Remember – when we talk about a scene, we talk about a whole scene file, such
    as the `entity_spawner.tscn` file. When we talk about a node, we are talking about
    a specific node within the scene file, such as the `EntitySpawner` node.
  prefs: []
  type: TYPE_NORMAL
- en: The start and stop functions will help when we want to stop enemies from spawning
    when the player dies, for example. In the body, they just start and stop `_spawn_timer`
    directly. You can see that when starting a timer, we can give a time in seconds
    that will be used as the amount of time before the timer runs out.
  prefs: []
  type: TYPE_NORMAL
- en: Running the game now, we’ll get a new enemy every 1.5 seconds. Great! Now that
    we have a stream of enemies coming in, let’s spawn some potions so that the player
    can heal themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning health potions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To spawn health potion collectibles, we can easily use the same `EntitySpawner`
    node that we just constructed! Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `EntitySpawner` node to the `main.tscn` scene and call it `HealthPotionSpawner`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make this spawner’s children editable and add **Marker2D** nodes to the **Positions**
    node at which you want to spawn health potions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.33 – Adding Marker2D nodes where I would like to spawn health potions](img/B19358_10_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.33 – Adding Marker2D nodes where I would like to spawn health potions
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop the `health_potion.tscn` scene into the `Entity Scene` property
    of the spawner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Spawn Interval** value of the spawner to a bigger number, such as
    20, so that we don’t spawn too many health potions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.34 – Setting the Spawn Interval value to 20 seconds](img/B19358_10_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.34 – Setting the Spawn Interval value to 20 seconds
  prefs: []
  type: TYPE_NORMAL
- en: That is it! Spawning new things is easy if we create a scene, `EntitySpawner`,
    that is easily reusable for it, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: Making a Game Over screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that enemies can damage the player and the player’s health goes down, we
    need to account for the scenario where the player’s health reaches 0\. This would
    mean the end of the game. We’ll add a little `Game Over` screen that gives the
    player the option to retry or go back to the main menu after dying.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the base scene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As always, we’ll start off by creating the scene structure:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene that has a `GameOverMenu`, and save the scene as `game_over_menu.tscn`
    in `parts/game_over_scene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Recreate the following scene structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.35 – The scene tree for the Game Over menu](img/B19358_10_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.35 – The scene tree for the Game Over menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill each element with the right text, enlarge the `GameOverLabel` node, and
    add some separation to the **VBoxContainer** node that holds the two buttons.
    Make it so that the UI looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.36 – What the Game Over menu will look like](img/B19358_10_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.36 – What the Game Over menu will look like
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, select the `GameOverMenu` root node and set its **Anchor preset** type
    to **Full Rect**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.37 – Choosing Full Rect from the Anchor presets list](img/B19358_10_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.37 – Choosing Full Rect from the Anchor presets list
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a little menu, let’s add it to the `main.tscn` scene:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `main.tscn` scene, add a `CanvasLayer` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under this `CanvasLayer` node, add our freshly created `GameOverMenu` node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.38 – The GameOverMenu node added to the scene tree](img/B19358_10_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.38 – The GameOverMenu node added to the scene tree
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, hide the `GameOverMenu` node by clicking the eye symbol next to the name
    of the node. We only want to show this menu when the player is dead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.39 – Hiding the GameOverMenu node by clicking the eye symbol next
    to its name](img/B19358_10_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.39 – Hiding the GameOverMenu node by clicking the eye symbol next
    to its name
  prefs: []
  type: TYPE_NORMAL
- en: We use a `CanvasLayer` node to display our menu here because this node makes
    sure that all its children are displayed on top of everything else. The `CanvasLayer`
    node does not adhere to the display order that is determined by the scene tree
    order of the nodes. Within the `CanvasLayer` node, its children do again adhere
    to this order. This makes the `CanvasLayer` node very suitable for UIs within
    the game itself.
  prefs: []
  type: TYPE_NORMAL
- en: That was it for the base scene structure; now, we should add some logic to the
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: Adding logic to the Game Over menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The script for the `GameOverMenu` node is very simple. All we want to do is
    add functionality when the buttons are pressed. When the **Play** button is pressed,
    we reload the main game scene, and when the menu button is pressed, we go back
    to the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, connect both buttons and load the right scene in each of their connected
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that we used a new function, `reload_current_scene()`, on the tree. This
    function is very similar to `change_scene_to_file()`, except it will just change
    to the same scene as we are currently in, and we don’t have to load the scene
    file as it is obviously already loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The **Game Over** menu is ready; now, we just need to make use of it within
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the Game Over menu when the player dies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have seen how we can connect to signals that nodes throw. But we can also
    make and throw our own signals! We’ll make use of this to detect when the player
    dies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `player.gd` script, right under the line that carries the `extends`
    keyword, add our new signal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'set(new_value):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var new_health: int = clamp(new_value, 0, MAX_HEALTH)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if health > 0 and new_health == 0:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: died.emit()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set_physics_process(false)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: health = new_health
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: update_health_label()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can see that to define a new signal, we just need to use the `signal` keyword,
    followed by the name of the signal.
  prefs: []
  type: TYPE_NORMAL
- en: Then, later on, we can just emit this signal by calling the `emit()` function
    on it. In a way, a signal is also a variable.
  prefs: []
  type: TYPE_NORMAL
- en: To check whether the player died, we check whether the current `health` value
    is greater than 0 and the `new_health` value is 0\. This way, we are sure that
    we only trigger the `died` signal once, when the player goes from a living to
    a dead state. We don’t want this signal thrown multiple times because that would
    signal the game that the player died more than once and create unwanted side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we also use the `set_physics_process()` function and give it `false` as
    the only parameter. This tells the node if it should stop executing the `_physics_process()`
    function and will effectively stop the player from moving because that is where
    all our movement code lives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the `Player` node throws a signal when it dies, we can hook into this
    with the `main.tscn` scene:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.tscn` scene, select the `Player` node. You’ll see that a new signal
    has appeared – the `died` signal that we defined in the `player.gd` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.40 – The signal we defined in the player’s script also turns up
    in the signal menu](img/B19358_10_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.40 – The signal we defined in the player’s script also turns up in
    the signal menu
  prefs: []
  type: TYPE_NORMAL
- en: Add an empty script to the `Main` node of the `main.tscn` scene and connect
    the `died` signal to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the connected function, we should show the `GameOverMenu` node and stop
    the `EnemySpawner` node and `HealthPotionSpawner`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script is pretty simple because it just needs to handle the menu and stop
    some spawners.
  prefs: []
  type: TYPE_NORMAL
- en: We covered a lot of ground in this section. We learned about how we can use
    the `NavigationRegion2D` and `NavigationAgent2D` nodes to make enemies navigate
    toward the player character. We used `PackedScene` variables to instance scenes
    from within the code. We used the `CanvasLayer` node to show a **Game Over** menu
    on top of the game. We created a custom signal and hooked into it. We had a lot
    of fun, and now it is time for the player to learn how to defend themselves!
  prefs: []
  type: TYPE_NORMAL
- en: Shooting projectiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve sent enough enemies at the player without them being able to defend themselves.
    Let’s change that in this section! We’ll be creating projectiles the player character
    automatically shoots at enemies to kill them off. To keep it simple, we’ll make
    the projectile hone in on the target we are trying to hit; this way, it never
    misses.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the base scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can shoot the projectiles, we’ll have to construct the base scene
    we’ll work from. Let’s do that right now with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene that has a `Projectile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a scene structure as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.41 – The scene tree of the projectile scene](img/B19358_10_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.41 – The scene tree of the projectile scene
  prefs: []
  type: TYPE_NORMAL
- en: 'Use one of the textures from `assets/sprites/projectils/` as the texture for
    the sprite. Remember to set the scale of the sprite to `(``3, 3)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.42 – The projectile](img/B19358_10_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.42 – The projectile
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, use a `CapsuleShape2D` node for the `CollisionShape2D` node’s shape and
    make sure it covers the sprite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.43 – Covering the projectile’s sprite with the CollisionShape2D
    node](img/B19358_10_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.43 – Covering the projectile’s sprite with the CollisionShape2D node
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the `EnemyDetectionArea`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To detect the `Enemy` node entering the `EnemyDetectionArea` area node, name
    the third **2D Physics** layer **Projectile**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `EnemyDetectionArea` area node’s **Collision Mask** property to detect
    the **Projectile** layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.44 – The Collision layer configuration for the EnemyDetectionArea
    area node](img/B19358_10_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.44 – The Collision layer configuration for the EnemyDetectionArea
    area node
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `enemy.tscn` scene, set the `Enemy` node’s **Collision Layer** property
    to be on the **Projectile** layer too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.45 – The Collision layer configuration for the enemy](img/B19358_10_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.45 – The Collision layer configuration for the enemy
  prefs: []
  type: TYPE_NORMAL
- en: This is all we need in terms of the scene structure, so let’s get to writing
    the behavior of the projectile.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the logic of the projectile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next up is the code that steers the projectile toward a target, destroys it
    on impact, and notifies the enemy it has been hit. We’ll make the projectile always
    go straight toward its target; this makes it easy for us code-wise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attach a script called `projectile.gd` to the `Projectile` root node and fill
    it with the following code to move it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve seen most of this code already, except for the `look_at()` function. This
    function rotates a node to orient itself toward a point in space that we provide
    it. So, here, it rotates the projectile node toward the position of the target.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, connect the `body_entered` signal from the `EnemyDetectionArea` node to
    the projectile’s script. All we need to do in the connected function is to notify
    the enemy that it got hit and destroy the projectile itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, in the `enemy.gd` script, add this `get_hit()` function that we want
    to use when the projectile hits the enemy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is all we need code-wise on the side of the projectile itself.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning projectiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want the projectile to be shot automatically every so often. To achieve
    this, we’ll need to make some changes in the `Player` and `Enemy` scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Timer` node to the `Player` scene and call this new node `ShootTimer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the time of this `ShootTimer` node to `0.5` and enable **Autostart**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.46 – Adding a Timer node called ShootTimer to the Player scene](img/B19358_10_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.46 – Adding a Timer node called ShootTimer to the Player scene
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the player’s script, preload the projectile scene at the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While the `Player` node is selected, drag and drop the `projectile.tscn` file
    into the **Projectile Scene** property in the **Inspector** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just like with the `EntitySpawner` node, we export a variable of the `PackedScene`
    type that we can fill from the editor and instantiate later on when we need it.
    This time, though, we directly fill it with the `projectile.tscn` scene. The `preload()`
    function loads this scene and puts it in the `projectile_scene` variable, ready
    to be used. But this variable is also exported, which means that if, someday,
    we want the player to shoot a different kind of projectile, we can drag and drop
    this scene in the **Inspector** tab of the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll now add the logic that actually spawns the projectile:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `enemy.tscn` scene, add the root node to the `enemy` group as we did
    for the player. This will make sure we can access all enemy nodes later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.47 – Adding the enemy node to the enemy group](img/B19358_10_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.47 – Adding the enemy node to the enemy group
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `export` variable to the top of the `player.gd` script. This variable
    will represent how far the player can shoot in pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, connect the timeout signal of the `ShootTimer` node to the `Player` node’s
    script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should be the body for the connected signal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should also stop the `ShootTimer` node when the player dies, cache the `ShootTimer`
    node at the top of the player script, and stop it when the player’s health reaches
    0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The high-level explanation of this function’s body is that we first get a list
    of all enemies, using the group functionality. Then, we go over every single one
    of them to see how far away they are from the player. While doing this loop, we
    always keep the enemy that is the closest along with that distance. This way,
    we know that we’ll end up with the enemy that is nearest to the player character.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this algorithm can result in no enemy being selected. That is
    why we need to make sure `closest_enemy` is not accidentally empty and need to
    return from the function if it is.
  prefs: []
  type: TYPE_NORMAL
- en: After all this, we create a new projectile, set its target, add it to the scene
    tree, and put its position to the position of the player.
  prefs: []
  type: TYPE_NORMAL
- en: That was it for creating projectiles! You can now run the game and start trying
    to survive as long as possible. We also saw some more intricate code with an algorithm
    to find the closest node from any other node and how to preload a scene within
    a script.
  prefs: []
  type: TYPE_NORMAL
- en: Storing highscores in autoloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the player can fight back and survive, we might need to give the player
    a goal to attain – something that will make them play again and again. We could
    add a highscore – for example, the amount of time the player was able to survive.
    The player can then try to better their own time or compare times with their friends.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we will be using an autoload. This is a node that gets initialized
    at the start of the game and will exist throughout the complete execution of the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Using an autoload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The survival time should be stored somewhere so that it is easily accessible
    from anywhere within the game. This way, we can change it after the player dies
    but also display the score on the main menu, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normal nodes and scenes have to be managed by us, the programmer. But there
    is another kind of node that we could use: autoloads. An autoload is a scene or
    script that is always loaded. The Godot engine initiates this scene for us anytime
    we run the game.'
  prefs: []
  type: TYPE_NORMAL
- en: A node or script that is autoloaded will exist as long as the game is running.
    Earlier, when using `get_tree().change_scene_to_file()` to change scenes, everything
    of the current scene gets removed from the scene tree and switched out for the
    new scene. However, autoloads do not share the same faith; they stay put and retain
    the values of all their variables.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Although autoloads are great, they should not be misused or overused. They should
    only be used for systems that are truly global, such as the `HighscoreManager`
    autoload we are going to create in this section.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to store the highscore autoload in a file just yet; we’ll do
    this in [*Chapter 15*](B19358_15.xhtml#_idTextAnchor740). For now, we just want
    to save and load the highscore autoload while the game is running.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a HighscoreManager autoload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an autoload, we first need to create a normal scene or script. Because
    we don’t really need a whole scene to keep track of a highscore, which is basically
    just a number, we are going to write a script. When the Godot engine initiates
    our game, it will create a node and attach our script to it. The following steps
    illustrate the process of creating an autoload:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `autoloads/` folder in the root of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new script in this folder called `highscore_manager.gd`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `HighscoreManager` script is going to be pretty simple and straightforward:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code defined a `highscore` variable and a `set_new_highscore()`.
    function. This function checks if the new score is bigger than the current highscore.
    If it is, we save this new, higher score; otherwise, we don’t need to bother.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s set this script up as an autoload:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project settings and navigate to the **Autoload** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the file icon button to search for a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.48 – Pressing the folder icon to select a file that you want to
    load as an autoload](img/B19358_10_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.48 – Pressing the folder icon to select a file that you want to load
    as an autoload
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `autoloads/highscore_manager.gd` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select it and press **Open**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, back in on the **Autoload** panel within the project settings, press the
    **Add** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That is all for setting up our autoload. You’ll see that the **Highscore**
    autoload is now displayed within the list of autoloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.49 – The highscore_manager.gd script is loaded as an autoload](img/B19358_10_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.49 – The highscore_manager.gd script is loaded as an autoload
  prefs: []
  type: TYPE_NORMAL
- en: Next to seeing the script in the list of autoloads, there is another way we
    can check whether the autoload is there.
  prefs: []
  type: TYPE_NORMAL
- en: Using a scene as an autoload
  prefs: []
  type: TYPE_NORMAL
- en: Both scripts and full scenes can be autoloads. To use a scene, load the scene
    just like we did for the script just now.
  prefs: []
  type: TYPE_NORMAL
- en: Autoloads in the remote tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As said earlier, autoloads get instantiated by the Godot engine when the game
    starts running. So, we can’t see them present in separate scenes, but they should
    be there in the remote tree when we run the game.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game using the **Run Project** button or any scene of the game using
    the **Run Current Scene** button. Open the remote tree, and you will see a node
    called **HighscoreManager**. This is our **HighscoreManager** autoload!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.50 – We can see the HighscoreManager node in the remote tree](img/B19358_10_51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.50 – We can see the HighscoreManager node in the remote tree
  prefs: []
  type: TYPE_NORMAL
- en: Now that we set up our **HighscoreManager** autoload, let’s use it within the
    game and keep some highscores!
  prefs: []
  type: TYPE_NORMAL
- en: Adding a UI in the main menu and game scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we’ll need to make sure the player knows what their score is while playing
    the game. Because we said that the score would be the amount of time the player
    is able to survive, we’ll show this score by adding a timer on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `main.tscn` scene, under the existing `CanvasLayer` node, add a `TimerUI`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the `TimerUI` node, select the **Top Wide** anchor so that it stays on
    the top of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.51 – Selecting Top Wide from the Anchor preset list](img/B19358_10_52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.51 – Selecting Top Wide from the Anchor preset list
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `TimerUI` and call it `TimeLabel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.52 – The scene structure for our timer](img/B19358_10_53.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.52 – The scene structure for our timer
  prefs: []
  type: TYPE_NORMAL
- en: Let’s fill this label with a fake time of `"123"` so that we can see how the
    score will look when it is filled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the font size of this label to something larger, such as `30` px.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we’ll need to account for the timer in the `main.gd` game script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First cache a reference to the `TimeLabel` node at the top of the script and
    add a variable in which we’ll keep the current elapsed time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, all we need to do is update the value of this `_time` variable. We’ll
    do this in the `_process()` function by adding the delta to the current time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we’ll need to submit this time whenever the player dies and stop the
    game from counting more time. So, change the function that is connected to the
    `died` signal from the player to include the following two lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s it to get the highscore linked within the game itself. Now, we’ll tackle
    showing the highscore in the main menu too.
  prefs: []
  type: TYPE_NORMAL
- en: Using the highscore in the main menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we can make new highscores, let’s display the highest score within
    the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `menu.tscn` scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `HighscoreLabel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in the `menu.gd` script, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is that the menu will now show the current highscore:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.53 – The main menu with an added Highscore label](img/B19358_10_54.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.53 – The main menu with an added Highscore label
  prefs: []
  type: TYPE_NORMAL
- en: None of this code is new to us. First, we save the `highscore_label`. Next,
    when the menu scene is ready, we populate the **HighscoreLabe**l with a string
    that contains the current highest score.
  prefs: []
  type: TYPE_NORMAL
- en: That was our venture into autoloads. We saw how easy it is to add a script or
    scene as a node that is always loaded at the start of our game without having
    to manage this node ourselves. Then, we made use of this autoload through its
    global variable to save information between different scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Additional exercises – Sharpening the axe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enemies get spawned at a slow, fixed rate. This can get a little boring because
    the difficulty never really increases. Make it so that enemies get spawned faster
    and faster after every round. For a simple way of doing this, you could follow
    the next steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `start_interval`, `end_interval`, and `time_delta` as export variables
    to the `EntitySpawner` node. The `start_interval` variable will be the time we
    use between spawning entities at the start of the game, `end_interval` will be
    the final value, and `time_delta` is the increment at which we will go from the
    `start_interval` variable to the `end_interval` variable:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.54 – The new exported variables for the EntitySpawner node](img/B19358_10_55.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.54 – The new exported variables for the EntitySpawner node
  prefs: []
  type: TYPE_NORMAL
- en: Now, track in a separate variable, `_current_spawn_interval`, the time for the
    next enemy to spawn. Set `_current_spawn_interval` equal to the `start_interval`
    variable at the start of the game. This variable replaces the old `spawn_interval`
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every time we spawn an entity in the `spawn_entity` function, add the `time_delta`
    variable to the `_current_spawn_interva``l` variable. Make sure to not go past
    the `end_interval` variable, though.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, still in the `spawn_entity()` function, start `_spawn_timer` again but
    with the new `_current_spawn_interval` variable: by calling `start_timer()` again.
    For the `HealthPotionSpawner` node, you’ll have to set `time_delta` to `0.0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The menu that shows up when the player dies is quite lacking in information.
    Add a nice label to show the score the player just achieved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned and created so many different things within this chapter. First,
    we learned all about `NavigationServer` property. To let the player have a chance
    to defend themselves, we created projectiles that get shot automatically on a
    timer. Lastly, we added a small high-score system that stores the current highscore
    within an autoload so that the player is incentivized to replay the game and try
    to beat their own best time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll do something very interesting: make our game multiplayer!'
  prefs: []
  type: TYPE_NORMAL
- en: Quiz time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Control** nodes are used to create UIs such as menus. For each of the following
    scenarios, give a **Control** node that could do the job:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing a long piece of text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping other **Control** nodes to the center of the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing a button to start the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which node did we add to the `Enemy` scene to make it find a path to the player?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s say that we have this piece of code where we define a signal called `shot`
    to indicate that we shot a projectile:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write the line of code that is needed to emit this signal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How do you load a scene from within the code into a variable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we make a script globally accessible?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
